void CMYK64_mark_pixelmask(uint64_t a1, int a2)
{
  v2 = *(a1 + 48);
  v3 = *(a1 + 136);
  v4 = *(a1 + 12);
  v5 = *(a1 + 16);
  if (v2)
  {
    v6 = *(a1 + 32) >> 1;
    v7 = (v2 + 2 * v6 * v5 + 2 * v4);
    v8 = -1;
    if (!v3)
    {
      return;
    }
  }

  else
  {
    v7 = 0;
    v6 = 0;
    v8 = 0;
    if (!v3)
    {
      return;
    }
  }

  v9 = *(a1 + 4);
  v10 = *(a1 + 8);
  v12 = *(a1 + 88);
  v11 = *(a1 + 96);
  v13 = *(a1 + 28) >> 3;
  v14 = (*(a1 + 40) + 8 * v13 * v5 + 8 * v4);
  v15 = *(a1 + 124);
  v16 = (v3 + *(a1 + 108) * v15 + *(a1 + 104));
  v17 = *(a1 + 56);
  v18 = *(a1 + 60);
  v19 = *(a1 + 76);
  if ((*a1 & 0xFF00) != 0x100)
  {
    v21 = *(a1 + 64);
    v22 = *(a1 + 68);
    v823 = v19 >> 3;
    if (v11)
    {
      v821 = *(a1 + 80) >> 1;
      v20 = 1;
    }

    else
    {
      v821 = 0;
      v20 = 0;
    }

    v28 = v12 + 8 * v823 * v22;
    v8 &= 1u;
    v27 = 1;
    v29 = v12;
    v23 = v12;
    goto LABEL_19;
  }

  v823 = v19 >> 3;
  if (v11)
  {
    v821 = *(a1 + 80) >> 1;
    v11 += v821 * v18 + v17;
    v20 = -1;
  }

  else
  {
    v821 = 0;
    v20 = 0;
  }

  v23 = (v12 + 8 * v823 * v18 + 8 * v17);
  if (v823 == v13)
  {
    v24 = (v14 - v23) >> 3;
    if (v24 >= 1)
    {
      if (v24 <= v9)
      {
        v14 += v9 - 1;
        v23 += 8 * v9 - 8;
        v16 += v9 - 1;
        v7 += v8 & (v9 - 1);
        v27 = -1;
        v823 = *(a1 + 28) >> 3;
        v11 += v20 & (v9 - 1);
        goto LABEL_16;
      }

      v25 = v10 - 1;
      v26 = &v23[8 * v13 * v25];
      if (v14 <= &v26[4 * v9 - 4])
      {
        v14 += v13 * v25;
        v16 += v15 * v25;
        v15 = -v15;
        v7 += v6 * v25;
        v6 = -v6;
        v8 &= 1u;
        v11 += v821 * v25;
        v821 = -v821;
        v20 &= 1u;
        v27 = 1;
        v23 = v26;
        v823 = -v13;
        v13 = -v13;
        goto LABEL_16;
      }
    }
  }

  v8 &= 1u;
  v20 &= 1u;
  v27 = 1;
LABEL_16:
  v28 = 0;
  v29 = 0;
  v12 = -1;
  v22 = v821;
  v21 = v823;
LABEL_19:
  v30 = v27 * v9;
  v822 = v9;
  v818 = v28;
  v826 = v10;
  if (v28)
  {
    v31 = v18 % v22;
    v32 = &v23[8 * v823 * v31];
    v33 = v17 % v21;
    v23 = &v32[4 * v33];
    v34 = v21;
    v12 = &v32[4 * v21];
    if (v20)
    {
      v11 += v821 * v31 + v33;
    }

    v824 = v11;
    v825 = &v32[4 * v33];
  }

  else
  {
    v824 = v11;
    v825 = v29;
    v823 -= v30;
    v821 -= v20 * v9;
    v34 = v21;
  }

  v819 = v13 - v30;
  v820 = v15 - v30;
  v817 = v6 - v8 * v822;
  v35 = v27;
  v869 = v20;
  v827 = v8;
  switch(a2)
  {
    case 0:
      if (v8)
      {
        v36 = 2 * v8;
        do
        {
          v37 = v822;
          v38 = v826;
          do
          {
            v39 = *v16;
            if (*v16)
            {
              if (v39 == 255)
              {
                *v14 = 0;
                *v7 = 0;
              }

              else
              {
                CMYK64_DAM(v14, v7, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, (v39 | (v39 << 8)) ^ 0xFFFF);
              }
            }

            v16 += v35;
            v7 = (v7 + v36);
            v14 += v35;
            --v37;
          }

          while (v37);
          v16 += v820;
          v14 += v819;
          v7 += v817;
          --v826;
        }

        while (v38 != 1);
      }

      else
      {
        v679.i64[0] = 0x100000001;
        v679.i64[1] = 0x100000001;
        do
        {
          v680 = v822;
          v681 = v826;
          do
          {
            v682 = *v16;
            if (*v16)
            {
              if (v682 == 255)
              {
                *v14 = 0;
              }

              else
              {
                v683 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v684.i32[0] = v683;
                v684.i32[1] = vshr_n_u32(vdup_n_s32(v683), 0x10uLL).i32[1];
                v684.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
                v685 = vmulq_s32(v684, vdupq_n_s32(v682 | (v682 << 8)));
                v684.i32[0] = v683;
                *v14 = vrev16_s8(vmovn_s32(vsubq_s32(v684, vshrq_n_u32(vaddq_s32(vsraq_n_u32(v685, v685, 0x10uLL), v679), 0x10uLL))));
              }
            }

            v16 += v27;
            v14 += v27;
            --v680;
          }

          while (v680);
          v16 += v820;
          v14 += v819;
          --v826;
        }

        while (v681 != 1);
      }

      return;
    case 1:
      if (v8)
      {
        if (v20)
        {
          v296 = v20;
          v297 = -v34;
          v835 = -(v823 * v22);
          v803 = -(v821 * v22);
          v298 = 2 * v8;
          v299 = 8 * v35;
          v300 = v824;
          v873 = v20;
          do
          {
            v301 = v822;
            v854 = v12;
            do
            {
              v302 = *v16;
              if (*v16)
              {
                if (v302 == 255)
                {
                  *v14 = *v23;
                  *v7 = *v300;
                }

                else
                {
                  v303 = v302 | (v302 << 8);
                  v304 = v35;
                  v305 = v299;
                  CMYK64_DAMplusDAM(v14, v7, ((bswap32(*(v23 + 2)) >> 16) << 32) | ((bswap32(*(v23 + 3)) >> 16) << 48) | bswap32(*(v23 + 1)) & 0xFFFF0000 | (bswap32(*v23) >> 16), bswap32(*v300) >> 16, v303, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, v303 ^ 0xFFFF);
                  v299 = v305;
                  v35 = v304;
                  v12 = v854;
                  v296 = v873;
                }
              }

              v16 += v35;
              v306 = &v23[8 * v35];
              if (v306 >= v12)
              {
                v307 = v297;
              }

              else
              {
                v307 = 0;
              }

              v300 += v296 + v307;
              v23 = &v306[4 * v307];
              v7 = (v7 + v298);
              v14 = (v14 + v299);
              --v301;
            }

            while (v301);
            if (v818)
            {
              v308 = &v825[4 * v823];
              v309 = v803;
              if (v308 < v818)
              {
                v309 = 0;
              }

              v300 = &v824[v821 + v309];
              v310 = v835;
              if (v308 < v818)
              {
                v310 = 0;
              }

              v23 = &v308[8 * v310];
              v12 += 8 * v310 + 8 * v823;
              v824 += v821 + v309;
              v825 = v23;
            }

            else
            {
              v23 += 8 * v823;
              v300 += v821;
            }

            v16 += v820;
            v14 += v819;
            v7 += v817;
            --v826;
          }

          while (v826);
        }

        else
        {
          v727 = -v34;
          v877 = -(v823 * v22);
          v728 = 2 * v8;
          do
          {
            v729 = v822;
            do
            {
              v730 = *v16;
              if (*v16)
              {
                if (v730 == 255)
                {
                  *v14 = *v23;
                  *v7 = -1;
                }

                else
                {
                  v731 = v730 | (v730 << 8);
                  v732 = v12;
                  CMYK64_DAMplusDAM(v14, v7, ((bswap32(*(v23 + 2)) >> 16) << 32) | ((bswap32(*(v23 + 3)) >> 16) << 48) | bswap32(*(v23 + 1)) & 0xFFFF0000 | (bswap32(*v23) >> 16), 0xFFFF, v731, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, v731 ^ 0xFFFF);
                  v12 = v732;
                }
              }

              v16 += v35;
              v733 = &v23[8 * v35];
              if (v733 >= v12)
              {
                v734 = v727;
              }

              else
              {
                v734 = 0;
              }

              v23 = &v733[4 * v734];
              v7 = (v7 + v728);
              v14 += v35;
              --v729;
            }

            while (v729);
            v16 += v820;
            v14 += v819;
            v7 += v817;
            v735 = v825;
            v736 = &v825[4 * v823];
            v737 = v877;
            if (v736 < v818)
            {
              v737 = 0;
            }

            v738 = &v736[8 * v737];
            v739 = v12 + 8 * v737 + 8 * v823;
            if (v818)
            {
              v12 = v739;
              v735 = v738;
              v23 = v738;
            }

            else
            {
              v23 += 8 * v823;
            }

            v619 = v826 == 1;
            v825 = v735;
            --v826;
          }

          while (!v619);
        }
      }

      else
      {
        v686 = -v34;
        v687 = -(v823 * v22);
        do
        {
          v688 = v822;
          v689 = v826;
          do
          {
            v690 = *v16;
            if (*v16)
            {
              if (v690 == 255)
              {
                *v14 = *v23;
              }

              else
              {
                v691 = bswap32(*(v23 + 1) | (*v23 << 16));
                v692 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v693.i32[0] = v690 | (v690 << 8);
                v693.i32[1] = ~v693.i32[0];
                *v694.i8 = vand_s8(v693, 0xFFFF0000FFFFLL);
                v695.i64[0] = v694.i64[0];
                v695.i64[1] = v694.i64[0];
                v696.i32[0] = v692;
                v696.i32[1] = HIWORD(v691);
                v696.i64[1] = __PAIR64__(bswap32(*(v23 + 3)) >> 16, bswap32(v14->u16[2]) >> 16);
                v694.i64[1] = v694.i64[0];
                v697 = vmulq_s32(v696, vrev64q_s32(v694));
                v696.i32[0] = v691;
                v696.i32[1] = HIWORD(v692);
                v696.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(*(v23 + 2)) >> 16);
                v698 = vmlaq_s32(v697, v696, v695);
                *v14 = vrev16_s8(vsubhn_s32(vshrq_n_u32(v698, 0x10uLL), vmvnq_s8(v698)));
              }
            }

            v16 += v35;
            v699 = &v23[8 * v35];
            if (v699 >= v12)
            {
              v700 = v686;
            }

            else
            {
              v700 = 0;
            }

            v23 = &v699[4 * v700];
            v14 += v35;
            --v688;
          }

          while (v688);
          v16 += v820;
          v14 += v819;
          v701 = v825;
          v702 = &v825[4 * v823];
          if (v702 >= v818)
          {
            v703 = v687;
          }

          else
          {
            v703 = 0;
          }

          v704 = &v702[8 * v703];
          v705 = v12 + 8 * v703 + 8 * v823;
          if (v818)
          {
            v12 = v705;
            v701 = v704;
            v23 = v704;
          }

          else
          {
            v23 += 8 * v823;
          }

          v825 = v701;
          --v826;
        }

        while (v689 != 1);
      }

      return;
    case 2:
      if (v8)
      {
        v221 = v20;
        v222 = -v34;
        v832 = -(v823 * v22);
        v799 = -(v821 * v22);
        v223 = 2 * v8;
        v224 = v824;
        v871 = v20;
        while (1)
        {
          v225 = v822;
          v850 = v12;
          do
          {
            v226 = *v16;
            if (!*v16)
            {
              goto LABEL_275;
            }

            if (v226 == 255)
            {
              v227 = *v224;
              v228 = __rev16(v227);
              if (!v228)
              {
                goto LABEL_275;
              }

              if (v228 == 0xFFFF)
              {
                *v14 = *v23;
                *v7 = v227;
                goto LABEL_275;
              }

              v236 = bswap32(*v7) >> 16;
              v237 = ((bswap32(*(v23 + 2)) >> 16) << 32) | ((bswap32(*(v23 + 3)) >> 16) << 48) | bswap32(*(v23 + 1)) & 0xFFFF0000 | (bswap32(*v23) >> 16);
              v238 = ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16);
              v239 = v228 ^ 0xFFFF;
            }

            else
            {
              v229 = bswap32(*v224) >> 16;
              v230 = (v226 | (v226 << 8)) ^ 0xFFFF;
              v231 = v229 - ((v230 * v229 + ((v230 * v229) >> 16) + 1) >> 16);
              if (v229 == (v230 * v229 + ((v230 * v229) >> 16) + 1) >> 16)
              {
                goto LABEL_275;
              }

              v232 = bswap32(*(v23 + 2));
              v233 = bswap32(*(v23 + 3));
              v234 = ((HIWORD(v233) - ((v230 * HIWORD(v233) + ((v230 * HIWORD(v233)) >> 16) + 1) >> 16)) << 48) | ((HIWORD(v232) - ((v230 * HIWORD(v232) + ((v230 * HIWORD(v232)) >> 16) + 1) >> 16)) << 32);
              v235 = bswap32(*(v23 + 1) | (*v23 << 16));
              v236 = bswap32(*v7) >> 16;
              v237 = v234 | ((HIWORD(v235) - ((HIWORD(v235) * v230 + ((HIWORD(v235) * v230) >> 16) + 1) >> 16)) << 16) | (v235 - ((v235 * v230 + ((v235 * v230) >> 16) + 1) >> 16));
              v228 = v231;
              v238 = ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16);
              v239 = ~v231;
            }

            CMYK64_DAplusDAM(v14, v7, v237, v228, v238, v236, v239);
            v12 = v850;
            v221 = v871;
LABEL_275:
            v16 += v35;
            v240 = &v23[8 * v35];
            if (v240 >= v12)
            {
              v241 = v222;
            }

            else
            {
              v241 = 0;
            }

            v224 += v221 + v241;
            v23 = &v240[4 * v241];
            v7 = (v7 + v223);
            v14 += v35;
            --v225;
          }

          while (v225);
          if (v818)
          {
            v242 = &v825[4 * v823];
            v243 = v799;
            if (v242 < v818)
            {
              v243 = 0;
            }

            v224 = &v824[v821 + v243];
            v244 = v832;
            if (v242 < v818)
            {
              v244 = 0;
            }

            v23 = &v242[8 * v244];
            v12 += 8 * v244 + 8 * v823;
            v824 += v821 + v243;
            v825 = v23;
          }

          else
          {
            v23 += 8 * v823;
            v224 += v821;
          }

          v16 += v820;
          v14 += v819;
          v7 += v817;
          if (!--v826)
          {
            return;
          }
        }
      }

      v620 = v20;
      v621 = -(v823 * v22);
      v622 = -(v821 * v22);
      v623.i64[0] = 0x100000001;
      v623.i64[1] = 0x100000001;
      v624 = v824;
LABEL_761:
      v625 = v822;
      v626 = v826;
      while (1)
      {
        v627 = *v16;
        if (*v16)
        {
          if (v627 == 255)
          {
            v628 = bswap32(*v624) >> 16;
            if (v628)
            {
              if (v628 != 0xFFFF)
              {
                v643 = ((bswap32(*(v23 + 2)) >> 16) << 32) | ((bswap32(*(v23 + 3)) >> 16) << 48) | bswap32(*(v23 + 1)) & 0xFFFF0000 | (bswap32(*v23) >> 16);
                v637 = WORD1(v643);
                v638 = vshlq_u64(vdupq_n_s64(v643), xmmword_18439CB80);
                v644.i32[0] = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v644.i32[1] = HIWORD(v644.i32[0]);
                v644.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
                v645 = vmull_u16(vmovn_s32(v644), vdup_n_s16(~v628));
                v641 = vsraq_n_u32(v645, v645, 0x10uLL);
                v642.i32[0] = v643;
                goto LABEL_770;
              }

              *v14 = *v23;
            }
          }

          else
          {
            v629 = bswap32(*v624) >> 16;
            v630 = (v627 | (v627 << 8)) ^ 0xFFFF;
            v631 = v630 * v629 + ((v630 * v629) >> 16) + 1;
            if (v629 != HIWORD(v631))
            {
              v632 = bswap32(*(v23 + 2));
              v633 = bswap32(*(v23 + 3));
              v634 = ((HIWORD(v633) - ((v630 * HIWORD(v633) + ((v630 * HIWORD(v633)) >> 16) + 1) >> 16)) << 48) | ((HIWORD(v632) - ((v630 * HIWORD(v632) + ((v630 * HIWORD(v632)) >> 16) + 1) >> 16)) << 32);
              v635 = bswap32(*(v23 + 1) | (*v23 << 16));
              v636 = v634 | ((HIWORD(v635) - ((HIWORD(v635) * v630 + ((HIWORD(v635) * v630) >> 16) + 1) >> 16)) << 16) | (v635 - ((v635 * v630 + ((v635 * v630) >> 16) + 1) >> 16));
              v637 = WORD1(v636);
              v638 = vshlq_u64(vdupq_n_s64(v636), xmmword_18439CB80);
              v639.i32[0] = bswap32(v14->u16[1] | (v14->u16[0] << 16));
              v639.i32[1] = HIWORD(v639.i32[0]);
              v639.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
              v640 = vmull_u16(vmovn_s32(v639), vdup_n_s16(~v629 + HIWORD(v631)));
              v641 = vsraq_n_u32(v640, v640, 0x10uLL);
              v642.i32[0] = v636;
LABEL_770:
              v642.i32[1] = v637;
              *v14 = vrev16_s8(vmovn_s32(vsraq_n_u32(vmovn_hight_s64(v642, v638), vaddq_s32(v641, v623), 0x10uLL)));
            }
          }
        }

        v16 += v27;
        v646 = &v23[8 * v27];
        v647 = &v624[v620];
        if (v646 >= v12)
        {
          v648 = -v34;
        }

        else
        {
          v648 = 0;
        }

        v624 = &v647[v648];
        v23 = &v646[4 * v648];
        v14 += v27;
        if (!--v625)
        {
          if (v818)
          {
            v649 = &v825[4 * v823];
            if (v649 >= v818)
            {
              v650 = v622;
            }

            else
            {
              v650 = 0;
            }

            v651 = &v824[v821 + v650];
            if (v649 >= v818)
            {
              v652 = v621;
            }

            else
            {
              v652 = 0;
            }

            v23 = &v649[8 * v652];
            v12 += 8 * v652 + 8 * v823;
            v824 += v821 + v650;
            v825 = v23;
            v624 = v651;
          }

          else
          {
            v23 += 8 * v823;
            v624 += v821;
          }

          v16 += v820;
          v14 += v819;
          --v826;
          if (v626 == 1)
          {
            return;
          }

          goto LABEL_761;
        }
      }

    case 3:
      v833 = -v34;
      v852 = v20;
      v269 = v824;
      v779 = -(v821 * v22);
      v801 = -(v823 * v22);
      v270 = 2 * v8;
      do
      {
        v271 = v822;
        v272 = v12;
        do
        {
          v273 = *v16;
          if (*v16)
          {
            if (v273 == 255)
            {
              if (v20)
              {
                v274 = bswap32(*v269) >> 16;
              }

              else
              {
                v274 = 0xFFFF;
              }

              CMYK64_DAM(v14, v7, ((bswap32(*(v23 + 2)) >> 16) << 32) | ((bswap32(*(v23 + 3)) >> 16) << 48) | bswap32(*(v23 + 1)) & 0xFFFF0000 | (bswap32(*v23) >> 16), v274, bswap32(*v7) >> 16);
            }

            else
            {
              if (v20)
              {
                v275 = bswap32(*v269) >> 16;
              }

              else
              {
                v275 = 0xFFFF;
              }

              v276 = v273 | (v273 << 8);
              v277 = bswap32(*v7) >> 16;
              CMYK64_DAMplusDAM(v14, v7, ((bswap32(*(v23 + 2)) >> 16) << 32) | ((bswap32(*(v23 + 3)) >> 16) << 48) | bswap32(*(v23 + 1)) & 0xFFFF0000 | (bswap32(*v23) >> 16), v275, (v277 * v276 + ((v277 * v276) >> 16) + 1) >> 16, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v277, v276 ^ 0xFFFF);
            }

            v12 = v272;
            v20 = v869;
          }

          v16 += v35;
          v278 = &v23[8 * v35];
          v279 = v833;
          if (v278 < v12)
          {
            v279 = 0;
          }

          v269 += v852 + v279;
          v23 = &v278[4 * v279];
          v7 = (v7 + v270);
          v14 += v35;
          --v271;
        }

        while (v271);
        if (v818)
        {
          v280 = &v825[4 * v823];
          v281 = v779;
          if (v280 < v818)
          {
            v281 = 0;
          }

          v269 = &v824[v821 + v281];
          v282 = v801;
          if (v280 < v818)
          {
            v282 = 0;
          }

          v23 = &v280[8 * v282];
          v12 += 8 * v282 + 8 * v823;
          v824 += v821 + v281;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v269 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        --v826;
      }

      while (v826);
      return;
    case 4:
      v829 = -v34;
      v845 = v20;
      v126 = v824;
      v774 = -(v821 * v22);
      v794 = -(v823 * v22);
      v127 = 2 * v8;
      do
      {
        v128 = v822;
        v129 = v12;
        do
        {
          v130 = *v16;
          if (*v16)
          {
            if (v130 == 255)
            {
              if (v20)
              {
                v131 = bswap32(*v126) >> 16;
              }

              else
              {
                v131 = 0xFFFF;
              }

              CMYK64_DAM(v14, v7, ((bswap32(*(v23 + 2)) >> 16) << 32) | ((bswap32(*(v23 + 3)) >> 16) << 48) | bswap32(*(v23 + 1)) & 0xFFFF0000 | (bswap32(*v23) >> 16), v131, bswap32(~*v7) >> 16);
            }

            else
            {
              if (v20)
              {
                v132 = bswap32(*v126) >> 16;
              }

              else
              {
                v132 = 0xFFFF;
              }

              v133 = v130 | (v130 << 8);
              v134 = bswap32(*v7) >> 16;
              CMYK64_DAMplusDAM(v14, v7, ((bswap32(*(v23 + 2)) >> 16) << 32) | ((bswap32(*(v23 + 3)) >> 16) << 48) | bswap32(*(v23 + 1)) & 0xFFFF0000 | (bswap32(*v23) >> 16), v132, ((v134 ^ 0xFFFF) * v133 + (((v134 ^ 0xFFFF) * v133) >> 16) + 1) >> 16, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v134, v133 ^ 0xFFFF);
            }

            v12 = v129;
            v20 = v869;
          }

          v16 += v35;
          v135 = &v23[8 * v35];
          v136 = v829;
          if (v135 < v12)
          {
            v136 = 0;
          }

          v126 += v845 + v136;
          v23 = &v135[4 * v136];
          v7 = (v7 + v127);
          v14 += v35;
          --v128;
        }

        while (v128);
        if (v818)
        {
          v137 = &v825[4 * v823];
          v138 = v774;
          if (v137 < v818)
          {
            v138 = 0;
          }

          v126 = &v824[v821 + v138];
          v139 = v794;
          if (v137 < v818)
          {
            v139 = 0;
          }

          v23 = &v137[8 * v139];
          v12 += 8 * v139 + 8 * v823;
          v824 += v821 + v138;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v126 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        --v826;
      }

      while (v826);
      return;
    case 5:
      v857 = -v34;
      v874 = v20;
      v836 = -(v823 * v22);
      v806 = -(v821 * v22);
      v359 = 2 * v8;
      v360 = v824;
      do
      {
        v361 = v822;
        do
        {
          if (*v16)
          {
            v362 = bswap32(*v360);
            v363 = bswap32(*(v23 + 3)) >> 16;
            v364 = bswap32(*(v23 + 1) | (*v23 << 16));
            v365 = bswap32(*(v23 + 2)) >> 16;
            v366 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v367 = ((v363 - ((v366 * v363 + ((v366 * v363) >> 16) + 1) >> 16)) << 48) | ((v365 - ((v366 * v365 + ((v366 * v365) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v364) - ((HIWORD(v364) * v366 + ((HIWORD(v364) * v366) >> 16) + 1) >> 16)) << 16);
            v368 = (v364 - ((v364 * v366 + ((v364 * v366) >> 16) + 1) >> 16));
            v369 = HIWORD(v362) - ((v366 * HIWORD(v362) + ((v366 * HIWORD(v362)) >> 16) + 1) >> 16);
            v370 = v12;
            v371 = bswap32(*v7) >> 16;
            CMYK64_DAMplusDAM(v14, v7, v367 | v368, v369, v371, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v371, ~v369);
            v12 = v370;
          }

          v16 += v35;
          v372 = &v23[8 * v35];
          v373 = v857;
          if (v372 < v12)
          {
            v373 = 0;
          }

          v360 += v874 + v373;
          v23 = &v372[4 * v373];
          v7 = (v7 + v359);
          v14 += v35;
          --v361;
        }

        while (v361);
        if (v818)
        {
          v374 = &v825[4 * v823];
          v375 = v806;
          if (v374 < v818)
          {
            v375 = 0;
          }

          v360 = &v824[v821 + v375];
          v376 = v836;
          if (v374 < v818)
          {
            v376 = 0;
          }

          v23 = &v374[8 * v376];
          v12 += 8 * v376 + 8 * v823;
          v824 += v821 + v375;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v360 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        --v826;
      }

      while (v826);
      return;
    case 6:
      v425 = v20;
      v426 = -v34;
      v427 = v824;
      v784 = -(v821 * v22);
      v809 = -(v823 * v22);
      v428 = 2 * v8;
      v837 = v20;
      do
      {
        v429 = v822;
        v860 = v12;
        do
        {
          v430 = *v16;
          if (*v16)
          {
            v431 = bswap32(*v7);
            if (HIWORD(v431) != 0xFFFF)
            {
              if (~HIWORD(v431) == 0xFFFF)
              {
                if (v20)
                {
                  v432 = bswap32(*v427) >> 16;
                }

                else
                {
                  v432 = 0xFFFF;
                }

                CMYK64_DAM(v14, v7, ((bswap32(*(v23 + 2)) >> 16) << 32) | ((bswap32(*(v23 + 3)) >> 16) << 48) | bswap32(*(v23 + 1)) & 0xFFFF0000 | (bswap32(*v23) >> 16), v432, v430 | (v430 << 8));
              }

              else
              {
                if (v20)
                {
                  v433 = bswap32(*v427) >> 16;
                }

                else
                {
                  v433 = 0xFFFF;
                }

                CMYK64_DAplusDAM(v14, v7, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), HIWORD(v431), ((bswap32(*(v23 + 2)) >> 16) << 32) | ((bswap32(*(v23 + 3)) >> 16) << 48) | bswap32(*(v23 + 1)) & 0xFFFF0000 | (bswap32(*v23) >> 16), v433, (257 * v430 * ~HIWORD(v431) + ((257 * v430 * ~HIWORD(v431)) >> 16) + 1) >> 16);
              }

              v12 = v860;
              v20 = v869;
              v425 = v837;
            }
          }

          v16 += v35;
          v434 = &v23[8 * v35];
          if (v434 >= v12)
          {
            v435 = v426;
          }

          else
          {
            v435 = 0;
          }

          v427 += v425 + v435;
          v23 = &v434[4 * v435];
          v7 = (v7 + v428);
          v14 += v35;
          --v429;
        }

        while (v429);
        if (v818)
        {
          v436 = &v825[4 * v823];
          v437 = v784;
          if (v436 < v818)
          {
            v437 = 0;
          }

          v427 = &v824[v821 + v437];
          v438 = v809;
          if (v436 < v818)
          {
            v438 = 0;
          }

          v23 = &v436[8 * v438];
          v12 += 8 * v438 + 8 * v823;
          v824 += v821 + v437;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v427 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        --v826;
      }

      while (v826);
      return;
    case 7:
      if (v8)
      {
        v872 = v20;
        v853 = -v34;
        v834 = -(v823 * v22);
        v802 = -(v821 * v22);
        v283 = 2 * v8;
        v284 = v824;
        do
        {
          v285 = v822;
          do
          {
            v286 = *v16;
            if (*v16)
            {
              v287 = v12;
              if (v286 == 255)
              {
                CMYK64_DAM(v14, v7, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, bswap32(*v284) >> 16);
              }

              else
              {
                v288 = bswap32(*v284);
                v289 = ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16);
                v290 = bswap32(*v7) >> 16;
                CMYK64_DAMplusDAM(v14, v7, v289, v290, (HIWORD(v288) * (v286 | (v286 << 8)) + ((HIWORD(v288) * (v286 | (v286 << 8))) >> 16) + 1) >> 16, v289, v290, (v286 | (v286 << 8)) ^ 0xFFFF);
              }

              v12 = v287;
            }

            v16 += v35;
            v291 = &v23[8 * v35];
            v292 = v853;
            if (v291 < v12)
            {
              v292 = 0;
            }

            v284 += v872 + v292;
            v23 = &v291[4 * v292];
            v7 = (v7 + v283);
            v14 += v35;
            --v285;
          }

          while (v285);
          if (v818)
          {
            v293 = &v825[4 * v823];
            v294 = v802;
            if (v293 < v818)
            {
              v294 = 0;
            }

            v284 = &v824[v821 + v294];
            v295 = v834;
            if (v293 < v818)
            {
              v295 = 0;
            }

            v23 = &v293[8 * v295];
            v12 += 8 * v295 + 8 * v823;
            v824 += v821 + v294;
            v825 = v23;
          }

          else
          {
            v23 += 8 * v823;
            v284 += v821;
          }

          v16 += v820;
          v14 += v819;
          v7 += v817;
          --v826;
        }

        while (v826);
      }

      else
      {
        v653 = v824;
        v654 = -(v823 * v22);
        v655 = -(v821 * v22);
        v656.i64[0] = 0x100000001;
        v656.i64[1] = 0x100000001;
        do
        {
          v657 = v822;
          v658 = v826;
          do
          {
            v659 = *v16;
            if (*v16)
            {
              if (v659 == 255)
              {
                v660 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v661.i32[0] = v660;
                v661.i32[1] = vshr_n_u32(vdup_n_s32(v660), 0x10uLL).i32[1];
                v661.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
                v662 = vmulq_s32(v661, vmovl_u16(vdup_n_s16(bswap32(~*v653) >> 16)));
                v661.i32[0] = v660;
                v663 = vsubq_s32(v661, vshrq_n_u32(vaddq_s32(vsraq_n_u32(v662, v662, 0x10uLL), v656), 0x10uLL));
              }

              else
              {
                v664 = v659 | (v659 << 8);
                v665 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v666 = bswap32(*v653);
                v667.i32[0] = (HIWORD(v666) * v664 + ((HIWORD(v666) * v664) >> 16) + 1) >> 16;
                v667.i32[1] = ~v664;
                *v668.i8 = vand_s8(v667, 0xFFFF0000FFFFLL);
                v669.i64[0] = v668.i64[0];
                v669.i64[1] = v668.i64[0];
                v670.i32[0] = v665;
                v670.i32[1] = HIWORD(v665);
                v670.i32[2] = bswap32(v14->u16[2]) >> 16;
                v670.i32[3] = bswap32(v14->u16[3]) >> 16;
                v668.i64[1] = v668.i64[0];
                v671 = vmulq_s32(v670, vaddq_s32(v669, vrev64q_s32(v668)));
                v663 = vshrq_n_u32(vsubq_s32(vshrq_n_u32(v671, 0x10uLL), vmvnq_s8(v671)), 0x10uLL);
              }

              *v14 = vrev16_s8(vmovn_s32(v663));
            }

            v16 += v35;
            v672 = &v23[8 * v35];
            v673 = &v653[v20];
            if (v672 >= v12)
            {
              v674 = -v34;
            }

            else
            {
              v674 = 0;
            }

            v653 = &v673[v674];
            v23 = &v672[4 * v674];
            v14 += v35;
            --v657;
          }

          while (v657);
          if (v818)
          {
            v675 = &v825[4 * v823];
            if (v675 >= v818)
            {
              v676 = v655;
            }

            else
            {
              v676 = 0;
            }

            v677 = &v824[v821 + v676];
            if (v675 >= v818)
            {
              v678 = v654;
            }

            else
            {
              v678 = 0;
            }

            v23 = &v675[8 * v678];
            v12 += 8 * v678 + 8 * v823;
            v824 += v821 + v676;
            v825 = v23;
            v653 = v677;
          }

          else
          {
            v23 += 8 * v823;
            v653 += v821;
          }

          v16 += v820;
          v14 += v819;
          --v826;
        }

        while (v658 != 1);
      }

      return;
    case 8:
      if (v8)
      {
        v876 = v20;
        v863 = -v34;
        v839 = -(v823 * v22);
        v812 = -(v821 * v22);
        v481 = 2 * v8;
        v482 = v824;
        do
        {
          v483 = v822;
          do
          {
            v484 = *v16;
            if (*v16)
            {
              v485 = v12;
              v486 = bswap32(*v7) >> 16;
              if (v484 == 255)
              {
                v487 = bswap32(~*v482) >> 16;
              }

              else
              {
                v488 = bswap32(*v482) >> 16;
                v487 = ~(257 * v484 * v488 + ((257 * v484 * v488) >> 16) + 1) >> 16;
              }

              CMYK64_DAM(v14, v7, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v486, v487);
              v12 = v485;
            }

            v16 += v35;
            v489 = &v23[8 * v35];
            v490 = v863;
            if (v489 < v12)
            {
              v490 = 0;
            }

            v482 += v876 + v490;
            v23 = &v489[4 * v490];
            v7 = (v7 + v481);
            v14 += v35;
            --v483;
          }

          while (v483);
          if (v818)
          {
            v491 = &v825[4 * v823];
            v492 = v812;
            if (v491 < v818)
            {
              v492 = 0;
            }

            v482 = &v824[v821 + v492];
            v493 = v839;
            if (v491 < v818)
            {
              v493 = 0;
            }

            v23 = &v491[8 * v493];
            v12 += 8 * v493 + 8 * v823;
            v824 += v821 + v492;
            v825 = v23;
          }

          else
          {
            v23 += 8 * v823;
            v482 += v821;
          }

          v16 += v820;
          v14 += v819;
          v7 += v817;
          --v826;
        }

        while (v826);
      }

      else
      {
        v706 = v824;
        v707 = -(v823 * v22);
        v708 = -(v821 * v22);
        v709.i64[0] = 0x100000001;
        v709.i64[1] = 0x100000001;
        do
        {
          v710 = v822;
          v711 = v826;
          do
          {
            v712 = *v16;
            if (*v16)
            {
              v713 = bswap32(v14->u16[3]) >> 16;
              v714 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
              if (v712 == 255)
              {
                v715.i32[0] = v714;
                v715.i32[1] = vshr_n_u32(vdup_n_s32(v714), 0x10uLL).i32[1];
                v716 = bswap32(v14->u16[2]) >> 16;
                v717 = bswap32(*v706) >> 16;
              }

              else
              {
                v718 = bswap32(*v706);
                v715.i32[0] = v714;
                v717 = (257 * v712 * HIWORD(v718) + ((257 * v712 * HIWORD(v718)) >> 16) + 1) >> 16;
                v715.i32[1] = vshr_n_u32(vdup_n_s32(v714), 0x10uLL).i32[1];
                v716 = bswap32(v14->u16[2]) >> 16;
              }

              v715.i64[1] = __PAIR64__(v713, v716);
              v719 = vmulq_s32(v715, vmovl_u16(vdup_n_s16(v717)));
              v715.i32[0] = v714;
              v715.i32[2] = v716;
              *v14 = vrev16_s8(vmovn_s32(vsubq_s32(v715, vshrq_n_u32(vaddq_s32(vsraq_n_u32(v719, v719, 0x10uLL), v709), 0x10uLL))));
            }

            v16 += v35;
            v720 = &v23[8 * v35];
            v721 = &v706[v20];
            if (v720 >= v12)
            {
              v722 = -v34;
            }

            else
            {
              v722 = 0;
            }

            v706 = &v721[v722];
            v23 = &v720[4 * v722];
            v14 += v35;
            --v710;
          }

          while (v710);
          if (v818)
          {
            v723 = &v825[4 * v823];
            if (v723 >= v818)
            {
              v724 = v708;
            }

            else
            {
              v724 = 0;
            }

            v725 = &v824[v821 + v724];
            if (v723 >= v818)
            {
              v726 = v707;
            }

            else
            {
              v726 = 0;
            }

            v23 = &v723[8 * v726];
            v12 += 8 * v726 + 8 * v823;
            v824 += v821 + v724;
            v825 = v23;
            v706 = v725;
          }

          else
          {
            v23 += 8 * v823;
            v706 += v821;
          }

          v16 += v820;
          v14 += v819;
          --v826;
        }

        while (v711 != 1);
      }

      return;
    case 9:
      v847 = -v34;
      v870 = v20;
      v831 = -(v823 * v22);
      v796 = -(v821 * v22);
      v154 = 2 * v8;
      v155 = v824;
      do
      {
        v156 = v822;
        do
        {
          if (*v16)
          {
            v157 = bswap32(*v7) >> 16;
            v158 = bswap32(*v155);
            v159 = bswap32(*(v23 + 3));
            v160 = bswap32(*(v23 + 1) | (*v23 << 16));
            v161 = bswap32(*(v23 + 2)) >> 16;
            v162 = ~(*v16 | (*v16 << 8));
            v163 = v162;
            v164 = ((HIWORD(v159) - ((HIWORD(v159) * v163 + ((HIWORD(v159) * v163) >> 16) + 1) >> 16)) << 48) | ((v161 - ((v161 * v163 + ((v161 * v163) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v160) - ((HIWORD(v160) * v163 + ((HIWORD(v160) * v163) >> 16) + 1) >> 16)) << 16);
            v165 = (v160 - ((v160 * v163 + ((v160 * v163) >> 16) + 1) >> 16));
            v166 = HIWORD(v158) - ((HIWORD(v158) * v163 + ((HIWORD(v158) * v163) >> 16) + 1) >> 16);
            v167 = v12;
            CMYK64_DAMplusDAM(v14, v7, v164 | v165, v166, v157 ^ 0xFFFF, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v157, (v166 + v162));
            v12 = v167;
          }

          v16 += v35;
          v168 = &v23[8 * v35];
          v169 = v847;
          if (v168 < v12)
          {
            v169 = 0;
          }

          v155 += v870 + v169;
          v23 = &v168[4 * v169];
          v7 = (v7 + v154);
          v14 += v35;
          --v156;
        }

        while (v156);
        if (v818)
        {
          v170 = &v825[4 * v823];
          v171 = v796;
          if (v170 < v818)
          {
            v171 = 0;
          }

          v155 = &v824[v821 + v171];
          v172 = v831;
          if (v170 < v818)
          {
            v172 = 0;
          }

          v23 = &v170[8 * v172];
          v12 += 8 * v172 + 8 * v823;
          v824 += v821 + v171;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v155 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        --v826;
      }

      while (v826);
      return;
    case 10:
      v862 = -v34;
      v875 = v20;
      v838 = -(v823 * v22);
      v811 = -(v821 * v22);
      v463 = 2 * v8;
      v464 = v824;
      do
      {
        v465 = v822;
        do
        {
          if (*v16)
          {
            v466 = bswap32(*v7) >> 16;
            v467 = bswap32(*v464);
            v468 = bswap32(*(v23 + 3)) >> 16;
            v469 = bswap32(*(v23 + 1) | (*v23 << 16));
            v470 = bswap32(*(v23 + 2)) >> 16;
            v471 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v472 = ((v468 - ((v471 * v468 + ((v471 * v468) >> 16) + 1) >> 16)) << 48) | ((v470 - ((v471 * v470 + ((v471 * v470) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v469) - ((HIWORD(v469) * v471 + ((HIWORD(v469) * v471) >> 16) + 1) >> 16)) << 16);
            v473 = (v469 - ((v469 * v471 + ((v469 * v471) >> 16) + 1) >> 16));
            v474 = HIWORD(v467) - ((v471 * HIWORD(v467) + ((v471 * HIWORD(v467)) >> 16) + 1) >> 16);
            v475 = v12;
            CMYK64_DAMplusDAM(v14, v7, v472 | v473, v474, v466 ^ 0xFFFF, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v466, ~v474);
            v12 = v475;
          }

          v16 += v35;
          v476 = &v23[8 * v35];
          v477 = v862;
          if (v476 < v12)
          {
            v477 = 0;
          }

          v464 += v875 + v477;
          v23 = &v476[4 * v477];
          v7 = (v7 + v463);
          v14 += v35;
          --v465;
        }

        while (v465);
        if (v818)
        {
          v478 = &v825[4 * v823];
          v479 = v811;
          if (v478 < v818)
          {
            v479 = 0;
          }

          v464 = &v824[v821 + v479];
          v480 = v838;
          if (v478 < v818)
          {
            v480 = 0;
          }

          v23 = &v478[8 * v480];
          v12 += 8 * v480 + 8 * v823;
          v824 += v821 + v479;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v464 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        --v826;
      }

      while (v826);
      return;
    case 11:
      if (v8)
      {
        v828 = -v34;
        v844 = v20;
        v112 = v824;
        v773 = -(v821 * v22);
        v793 = -(v823 * v22);
        v113 = 2 * v8;
        do
        {
          v114 = v822;
          v115 = v12;
          do
          {
            if (*v16)
            {
              if (v20)
              {
                v116 = bswap32(*v112) >> 16;
              }

              else
              {
                v116 = 0xFFFF;
              }

              v117 = bswap32(*(v23 + 3)) >> 16;
              v118 = bswap32(*(v23 + 1) | (*v23 << 16));
              v119 = bswap32(*(v23 + 2)) >> 16;
              v120 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              CMYK64_DAplusdDA(v14, v7, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, ((v117 - ((v120 * v117 + ((v120 * v117) >> 16) + 1) >> 16)) << 48) | ((v119 - ((v120 * v119 + ((v120 * v119) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v118) - ((HIWORD(v118) * v120 + ((HIWORD(v118) * v120) >> 16) + 1) >> 16)) << 16) | (v118 - ((v118 * v120 + ((v118 * v120) >> 16) + 1) >> 16)), (v116 - ((v116 * v120 + ((v116 * v120) >> 16) + 1) >> 16)));
              v12 = v115;
              v20 = v869;
            }

            v16 += v35;
            v121 = &v23[8 * v35];
            v122 = v828;
            if (v121 < v12)
            {
              v122 = 0;
            }

            v112 += v844 + v122;
            v23 = &v121[4 * v122];
            v7 = (v7 + v113);
            v14 += v35;
            --v114;
          }

          while (v114);
          if (v818)
          {
            v123 = &v825[4 * v823];
            v124 = v773;
            if (v123 < v818)
            {
              v124 = 0;
            }

            v112 = &v824[v821 + v124];
            v125 = v793;
            if (v123 < v818)
            {
              v125 = 0;
            }

            v23 = &v123[8 * v125];
            v12 += 8 * v125 + 8 * v823;
            v824 += v821 + v124;
            v825 = v23;
          }

          else
          {
            v23 += 8 * v823;
            v112 += v821;
          }

          v16 += v820;
          v14 += v819;
          v7 += v817;
          --v826;
        }

        while (v826);
      }

      else
      {
        v589 = v20;
        v590 = -v34;
        v868 = -(v823 * v22);
        v840 = -(v821 * v22);
        v591 = v824;
        do
        {
          v592 = v822;
          v593 = v12;
          do
          {
            if (*v16)
            {
              if (v20)
              {
                v594 = bswap32(*v591) >> 16;
              }

              else
              {
                v594 = 0xFFFF;
              }

              v595 = bswap32(*(v23 + 3)) >> 16;
              v596 = bswap32(*(v23 + 1) | (*v23 << 16));
              v597 = bswap32(*(v23 + 2)) >> 16;
              v598 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              CMYK64_DplusdDA(v14, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), ((v595 - ((v598 * v595 + ((v598 * v595) >> 16) + 1) >> 16)) << 48) | ((v597 - ((v598 * v597 + ((v598 * v597) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v596) - ((HIWORD(v596) * v598 + ((HIWORD(v596) * v598) >> 16) + 1) >> 16)) << 16) | (v596 - ((v596 * v598 + ((v596 * v598) >> 16) + 1) >> 16)), (v594 - ((v594 * v598 + ((v594 * v598) >> 16) + 1) >> 16)));
              v12 = v593;
              v20 = v869;
            }

            v16 += v35;
            v599 = &v23[8 * v35];
            if (v599 >= v12)
            {
              v600 = v590;
            }

            else
            {
              v600 = 0;
            }

            v591 += v589 + v600;
            v23 = &v599[4 * v600];
            v14 += v35;
            --v592;
          }

          while (v592);
          if (v818)
          {
            v601 = &v825[4 * v823];
            v602 = v840;
            if (v601 < v818)
            {
              v602 = 0;
            }

            v591 = &v824[v821 + v602];
            v603 = v868;
            if (v601 < v818)
            {
              v603 = 0;
            }

            v23 = &v601[8 * v603];
            v12 += 8 * v603 + 8 * v823;
            v824 += v821 + v602;
            v825 = v23;
          }

          else
          {
            v23 += 8 * v823;
            v591 += v821;
          }

          v16 += v820;
          v14 += v819;
          --v826;
        }

        while (v826);
      }

      return;
    case 12:
      if (v8)
      {
        v830 = -v34;
        v846 = v20;
        v140 = v824;
        v775 = -(v821 * v22);
        v795 = -(v823 * v22);
        v141 = 2 * v8;
        do
        {
          v142 = v822;
          v143 = v12;
          do
          {
            if (*v16)
            {
              if (v20)
              {
                v144 = bswap32(*v140) >> 16;
              }

              else
              {
                v144 = 0xFFFF;
              }

              v145 = bswap32(*(v23 + 3)) >> 16;
              v146 = bswap32(*(v23 + 1) | (*v23 << 16));
              v147 = bswap32(*(v23 + 2)) >> 16;
              v148 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              CMYK64_DApluslDA(v14, v7, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, ((v145 - ((v148 * v145 + ((v148 * v145) >> 16) + 1) >> 16)) << 48) | ((v147 - ((v148 * v147 + ((v148 * v147) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v146) - ((HIWORD(v146) * v148 + ((HIWORD(v146) * v148) >> 16) + 1) >> 16)) << 16) | (v146 - ((v146 * v148 + ((v146 * v148) >> 16) + 1) >> 16)), (v144 - ((v144 * v148 + ((v144 * v148) >> 16) + 1) >> 16)));
              v12 = v143;
              v20 = v869;
            }

            v16 += v35;
            v149 = &v23[8 * v35];
            v150 = v830;
            if (v149 < v12)
            {
              v150 = 0;
            }

            v140 += v846 + v150;
            v23 = &v149[4 * v150];
            v7 = (v7 + v141);
            v14 += v35;
            --v142;
          }

          while (v142);
          if (v818)
          {
            v151 = &v825[4 * v823];
            v152 = v775;
            if (v151 < v818)
            {
              v152 = 0;
            }

            v140 = &v824[v821 + v152];
            v153 = v795;
            if (v151 < v818)
            {
              v153 = 0;
            }

            v23 = &v151[8 * v153];
            v12 += 8 * v153 + 8 * v823;
            v824 += v821 + v152;
            v825 = v23;
          }

          else
          {
            v23 += 8 * v823;
            v140 += v821;
          }

          v16 += v820;
          v14 += v819;
          v7 += v817;
          --v826;
        }

        while (v826);
      }

      else
      {
        v604 = -v34;
        v605 = -(v823 * v22);
        do
        {
          v606 = v822;
          do
          {
            if (*v16)
            {
              v607 = bswap32(*(v23 + 3));
              v608 = bswap32(*(v23 + 1) | (*v23 << 16));
              v609 = bswap32(*(v23 + 2)) >> 16;
              v610 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              v611 = v12;
              CMYK64_DpluslD(v14, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), ((HIWORD(v607) - ((v610 * HIWORD(v607) + ((v610 * HIWORD(v607)) >> 16) + 1) >> 16)) << 48) | ((v609 - ((v610 * v609 + ((v610 * v609) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v608) - ((HIWORD(v608) * v610 + ((HIWORD(v608) * v610) >> 16) + 1) >> 16)) << 16) | (v608 - ((v608 * v610 + ((v608 * v610) >> 16) + 1) >> 16)));
              v12 = v611;
            }

            v16 += v35;
            v612 = &v23[8 * v35];
            if (v612 >= v12)
            {
              v613 = v604;
            }

            else
            {
              v613 = 0;
            }

            v23 = &v612[4 * v613];
            v14 += v35;
            --v606;
          }

          while (v606);
          v16 += v820;
          v14 += v819;
          v614 = v825;
          v615 = &v825[4 * v823];
          if (v615 >= v818)
          {
            v616 = v605;
          }

          else
          {
            v616 = 0;
          }

          v617 = &v615[8 * v616];
          v618 = v12 + 8 * v616 + 8 * v823;
          if (v818)
          {
            v12 = v618;
            v614 = v617;
            v23 = v617;
          }

          else
          {
            v23 += 8 * v823;
          }

          v619 = v826 == 1;
          v825 = v614;
          --v826;
        }

        while (!v619);
      }

      return;
    case 13:
      v401 = v20;
      v402 = -v34;
      v403 = v824;
      v749 = -(v821 * v22);
      v764 = -(v823 * v22);
      v404 = 2 * v8;
      v783 = -v34;
      v808 = v20;
      while (1)
      {
        v405 = v822;
        v859 = v12;
        do
        {
          if (*v16)
          {
            v406 = v20 ? bswap32(*v403) >> 16 : 0xFFFF;
            v407 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v408 = v406 - ((v406 * v407 + ((v406 * v407) >> 16) + 1) >> 16);
            LODWORD(v409) = (v406 - ((v406 * v407 + ((v406 * v407) >> 16) + 1) >> 16));
            if (v406 != (v406 * v407 + ((v406 * v407) >> 16) + 1) >> 16)
            {
              v410 = bswap32(*(v23 + 3)) >> 16;
              v411 = bswap32(*(v23 + 1) | (*v23 << 16));
              v412 = HIWORD(v411);
              v413 = bswap32(*(v23 + 2)) >> 16;
              v414 = ((v410 - ((v407 * v410 + ((v407 * v410) >> 16) + 1) >> 16)) << 48) | ((v413 - ((v407 * v413 + ((v407 * v413) >> 16) + 1) >> 16)) << 32) | ((v412 - ((v412 * v407 + ((v412 * v407) >> 16) + 1) >> 16)) << 16) | (v411 - ((v411 * v407 + ((v411 * v407) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v415 = __rev16(*v7);
                  goto LABEL_497;
                }

LABEL_499:
                v418 = bswap32(v414);
                v14->i16[0] = HIWORD(v418);
                v14->i16[1] = v418;
                v14->i16[2] = bswap32(HIDWORD(v414)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v414));
                v416 = v7;
              }

              else
              {
                v415 = 0xFFFF;
LABEL_497:
                v416 = v14 + 3;
                v417 = PDAmultiplyPDA_11872(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v415, v414, v408);
                v414 = v417;
                v8 = v827;
                if (v827)
                {
                  v12 = v859;
                  v20 = v869;
                  v402 = v783;
                  v401 = v808;
                  goto LABEL_499;
                }

                v409 = HIWORD(v417);
                v419 = bswap32(v417);
                v14->i16[0] = HIWORD(v419);
                v14->i16[1] = v419;
                v14->i16[2] = bswap32(HIDWORD(v417)) >> 16;
                v12 = v859;
                v20 = v869;
                v402 = v783;
                v401 = v808;
              }

              *v416 = bswap32(v409) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v420 = &v23[8 * v35];
          if (v420 >= v12)
          {
            v421 = v402;
          }

          else
          {
            v421 = 0;
          }

          v403 += v401 + v421;
          v23 = &v420[4 * v421];
          v7 = (v7 + v404);
          --v405;
        }

        while (v405);
        if (v818)
        {
          v422 = &v825[4 * v823];
          v423 = v749;
          if (v422 < v818)
          {
            v423 = 0;
          }

          v403 = &v824[v821 + v423];
          v424 = v764;
          if (v422 < v818)
          {
            v424 = 0;
          }

          v23 = &v422[8 * v424];
          v12 += 8 * v424 + 8 * v823;
          v824 += v821 + v423;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v403 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 14:
      v88 = v20;
      v89 = -v34;
      v90 = v824;
      v742 = -(v821 * v22);
      v757 = -(v823 * v22);
      v91 = 2 * v8;
      v772 = -v34;
      v792 = v20;
      while (1)
      {
        v92 = v822;
        v843 = v12;
        do
        {
          if (*v16)
          {
            v93 = v20 ? bswap32(*v90) >> 16 : 0xFFFF;
            v94 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v95 = v93 - ((v93 * v94 + ((v93 * v94) >> 16) + 1) >> 16);
            LODWORD(v96) = (v93 - ((v93 * v94 + ((v93 * v94) >> 16) + 1) >> 16));
            if (v93 != (v93 * v94 + ((v93 * v94) >> 16) + 1) >> 16)
            {
              v97 = bswap32(*(v23 + 3)) >> 16;
              v98 = bswap32(*(v23 + 1) | (*v23 << 16));
              v99 = HIWORD(v98);
              v100 = bswap32(*(v23 + 2)) >> 16;
              v101 = ((v97 - ((v94 * v97 + ((v94 * v97) >> 16) + 1) >> 16)) << 48) | ((v100 - ((v94 * v100 + ((v94 * v100) >> 16) + 1) >> 16)) << 32) | ((v99 - ((v99 * v94 + ((v99 * v94) >> 16) + 1) >> 16)) << 16) | (v98 - ((v98 * v94 + ((v98 * v94) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v102 = __rev16(*v7);
                  goto LABEL_106;
                }

LABEL_108:
                v105 = bswap32(v101);
                v14->i16[0] = HIWORD(v105);
                v14->i16[1] = v105;
                v14->i16[2] = bswap32(HIDWORD(v101)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v101));
                v103 = v7;
              }

              else
              {
                v102 = 0xFFFF;
LABEL_106:
                v103 = v14 + 3;
                v104 = PDAscreenPDA_11873(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v102, v101, v95);
                v101 = v104;
                v8 = v827;
                if (v827)
                {
                  v12 = v843;
                  v20 = v869;
                  v89 = v772;
                  v88 = v792;
                  goto LABEL_108;
                }

                v96 = HIWORD(v104);
                v106 = bswap32(v104);
                v14->i16[0] = HIWORD(v106);
                v14->i16[1] = v106;
                v14->i16[2] = bswap32(HIDWORD(v104)) >> 16;
                v12 = v843;
                v20 = v869;
                v89 = v772;
                v88 = v792;
              }

              *v103 = bswap32(v96) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v107 = &v23[8 * v35];
          if (v107 >= v12)
          {
            v108 = v89;
          }

          else
          {
            v108 = 0;
          }

          v90 += v88 + v108;
          v23 = &v107[4 * v108];
          v7 = (v7 + v91);
          --v92;
        }

        while (v92);
        if (v818)
        {
          v109 = &v825[4 * v823];
          v110 = v742;
          if (v109 < v818)
          {
            v110 = 0;
          }

          v90 = &v824[v821 + v110];
          v111 = v757;
          if (v109 < v818)
          {
            v111 = 0;
          }

          v23 = &v109[8 * v111];
          v12 += 8 * v111 + 8 * v823;
          v824 += v821 + v110;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v90 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 15:
      v245 = v20;
      v246 = -v34;
      v247 = v824;
      v745 = -(v821 * v22);
      v760 = -(v823 * v22);
      v248 = 2 * v8;
      v778 = -v34;
      v800 = v20;
      while (1)
      {
        v249 = v822;
        v851 = v12;
        do
        {
          if (*v16)
          {
            v250 = v20 ? bswap32(*v247) >> 16 : 0xFFFF;
            v251 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v252 = v250 - ((v250 * v251 + ((v250 * v251) >> 16) + 1) >> 16);
            LODWORD(v253) = (v250 - ((v250 * v251 + ((v250 * v251) >> 16) + 1) >> 16));
            if (v250 != (v250 * v251 + ((v250 * v251) >> 16) + 1) >> 16)
            {
              v254 = bswap32(*(v23 + 3)) >> 16;
              v255 = bswap32(*(v23 + 1) | (*v23 << 16));
              v256 = HIWORD(v255);
              v257 = bswap32(*(v23 + 2)) >> 16;
              v258 = ((v254 - ((v251 * v254 + ((v251 * v254) >> 16) + 1) >> 16)) << 48) | ((v257 - ((v251 * v257 + ((v251 * v257) >> 16) + 1) >> 16)) << 32) | ((v256 - ((v256 * v251 + ((v256 * v251) >> 16) + 1) >> 16)) << 16) | (v255 - ((v255 * v251 + ((v255 * v251) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v259 = __rev16(*v7);
                  goto LABEL_299;
                }

LABEL_301:
                v262 = bswap32(v258);
                v14->i16[0] = HIWORD(v262);
                v14->i16[1] = v262;
                v14->i16[2] = bswap32(HIDWORD(v258)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v258));
                v260 = v7;
              }

              else
              {
                v259 = 0xFFFF;
LABEL_299:
                v260 = v14 + 3;
                v261 = PDAoverlayPDA_11874(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v259, v258, v252);
                v258 = v261;
                v8 = v827;
                if (v827)
                {
                  v12 = v851;
                  v20 = v869;
                  v246 = v778;
                  v245 = v800;
                  goto LABEL_301;
                }

                v253 = HIWORD(v261);
                v263 = bswap32(v261);
                v14->i16[0] = HIWORD(v263);
                v14->i16[1] = v263;
                v14->i16[2] = bswap32(HIDWORD(v261)) >> 16;
                v12 = v851;
                v20 = v869;
                v246 = v778;
                v245 = v800;
              }

              *v260 = bswap32(v253) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v264 = &v23[8 * v35];
          if (v264 >= v12)
          {
            v265 = v246;
          }

          else
          {
            v265 = 0;
          }

          v247 += v245 + v265;
          v23 = &v264[4 * v265];
          v7 = (v7 + v248);
          --v249;
        }

        while (v249);
        if (v818)
        {
          v266 = &v825[4 * v823];
          v267 = v745;
          if (v266 < v818)
          {
            v267 = 0;
          }

          v247 = &v824[v821 + v267];
          v268 = v760;
          if (v266 < v818)
          {
            v268 = 0;
          }

          v23 = &v266[8 * v268];
          v12 += 8 * v268 + 8 * v823;
          v824 += v821 + v267;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v247 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 16:
      v64 = v20;
      v65 = -v34;
      v66 = v824;
      v741 = -(v821 * v22);
      v756 = -(v823 * v22);
      v67 = 2 * v8;
      v771 = -v34;
      v791 = v20;
      while (1)
      {
        v68 = v822;
        v842 = v12;
        do
        {
          if (*v16)
          {
            v69 = v20 ? bswap32(*v66) >> 16 : 0xFFFF;
            v70 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v71 = v69 - ((v69 * v70 + ((v69 * v70) >> 16) + 1) >> 16);
            LODWORD(v72) = (v69 - ((v69 * v70 + ((v69 * v70) >> 16) + 1) >> 16));
            if (v69 != (v69 * v70 + ((v69 * v70) >> 16) + 1) >> 16)
            {
              v73 = bswap32(*(v23 + 3)) >> 16;
              v74 = bswap32(*(v23 + 1) | (*v23 << 16));
              v75 = HIWORD(v74);
              v76 = bswap32(*(v23 + 2)) >> 16;
              v77 = ((v73 - ((v70 * v73 + ((v70 * v73) >> 16) + 1) >> 16)) << 48) | ((v76 - ((v70 * v76 + ((v70 * v76) >> 16) + 1) >> 16)) << 32) | ((v75 - ((v75 * v70 + ((v75 * v70) >> 16) + 1) >> 16)) << 16) | (v74 - ((v74 * v70 + ((v74 * v70) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v78 = __rev16(*v7);
                  goto LABEL_77;
                }

LABEL_79:
                v81 = bswap32(v77);
                v14->i16[0] = HIWORD(v81);
                v14->i16[1] = v81;
                v14->i16[2] = bswap32(HIDWORD(v77)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v77));
                v79 = v7;
              }

              else
              {
                v78 = 0xFFFF;
LABEL_77:
                v79 = v14 + 3;
                v80 = PDAdarkenPDA_11876(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v78, v77, v71);
                v77 = v80;
                v8 = v827;
                if (v827)
                {
                  v12 = v842;
                  v20 = v869;
                  v65 = v771;
                  v64 = v791;
                  goto LABEL_79;
                }

                v72 = HIWORD(v80);
                v82 = bswap32(v80);
                v14->i16[0] = HIWORD(v82);
                v14->i16[1] = v82;
                v14->i16[2] = bswap32(HIDWORD(v80)) >> 16;
                v12 = v842;
                v20 = v869;
                v65 = v771;
                v64 = v791;
              }

              *v79 = bswap32(v72) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v83 = &v23[8 * v35];
          if (v83 >= v12)
          {
            v84 = v65;
          }

          else
          {
            v84 = 0;
          }

          v66 += v64 + v84;
          v23 = &v83[4 * v84];
          v7 = (v7 + v67);
          --v68;
        }

        while (v68);
        if (v818)
        {
          v85 = &v825[4 * v823];
          v86 = v741;
          if (v85 < v818)
          {
            v86 = 0;
          }

          v66 = &v824[v821 + v86];
          v87 = v756;
          if (v85 < v818)
          {
            v87 = 0;
          }

          v23 = &v85[8 * v87];
          v12 += 8 * v87 + 8 * v823;
          v824 += v821 + v86;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v66 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 17:
      v311 = v20;
      v312 = -v34;
      v313 = v824;
      v746 = -(v821 * v22);
      v761 = -(v823 * v22);
      v314 = 2 * v8;
      v780 = -v34;
      v804 = v20;
      while (1)
      {
        v315 = v822;
        v855 = v12;
        do
        {
          if (*v16)
          {
            v316 = v20 ? bswap32(*v313) >> 16 : 0xFFFF;
            v317 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v318 = v316 - ((v316 * v317 + ((v316 * v317) >> 16) + 1) >> 16);
            LODWORD(v319) = (v316 - ((v316 * v317 + ((v316 * v317) >> 16) + 1) >> 16));
            if (v316 != (v316 * v317 + ((v316 * v317) >> 16) + 1) >> 16)
            {
              v320 = bswap32(*(v23 + 3)) >> 16;
              v321 = bswap32(*(v23 + 1) | (*v23 << 16));
              v322 = HIWORD(v321);
              v323 = bswap32(*(v23 + 2)) >> 16;
              v324 = ((v320 - ((v317 * v320 + ((v317 * v320) >> 16) + 1) >> 16)) << 48) | ((v323 - ((v317 * v323 + ((v317 * v323) >> 16) + 1) >> 16)) << 32) | ((v322 - ((v322 * v317 + ((v322 * v317) >> 16) + 1) >> 16)) << 16) | (v321 - ((v321 * v317 + ((v321 * v317) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v325 = __rev16(*v7);
                  goto LABEL_394;
                }

LABEL_396:
                v328 = bswap32(v324);
                v14->i16[0] = HIWORD(v328);
                v14->i16[1] = v328;
                v14->i16[2] = bswap32(HIDWORD(v324)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v324));
                v326 = v7;
              }

              else
              {
                v325 = 0xFFFF;
LABEL_394:
                v326 = v14 + 3;
                v327 = PDAlightenPDA_11875(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v325, v324, v318);
                v324 = v327;
                v8 = v827;
                if (v827)
                {
                  v12 = v855;
                  v20 = v869;
                  v312 = v780;
                  v311 = v804;
                  goto LABEL_396;
                }

                v319 = HIWORD(v327);
                v329 = bswap32(v327);
                v14->i16[0] = HIWORD(v329);
                v14->i16[1] = v329;
                v14->i16[2] = bswap32(HIDWORD(v327)) >> 16;
                v12 = v855;
                v20 = v869;
                v312 = v780;
                v311 = v804;
              }

              *v326 = bswap32(v319) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v330 = &v23[8 * v35];
          if (v330 >= v12)
          {
            v331 = v312;
          }

          else
          {
            v331 = 0;
          }

          v313 += v311 + v331;
          v23 = &v330[4 * v331];
          v7 = (v7 + v314);
          --v315;
        }

        while (v315);
        if (v818)
        {
          v332 = &v825[4 * v823];
          v333 = v746;
          if (v332 < v818)
          {
            v333 = 0;
          }

          v313 = &v824[v821 + v333];
          v334 = v761;
          if (v332 < v818)
          {
            v334 = 0;
          }

          v23 = &v332[8 * v334];
          v12 += 8 * v334 + 8 * v823;
          v824 += v821 + v333;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v313 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 18:
      v439 = v20;
      v440 = -v34;
      v441 = v824;
      v750 = -(v821 * v22);
      v765 = -(v823 * v22);
      v442 = 2 * v8;
      v785 = -v34;
      v810 = v20;
      while (1)
      {
        v443 = v822;
        v861 = v12;
        do
        {
          if (*v16)
          {
            v444 = v20 ? bswap32(*v441) >> 16 : 0xFFFF;
            v445 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v446 = v444 - ((v444 * v445 + ((v444 * v445) >> 16) + 1) >> 16);
            LODWORD(v447) = (v444 - ((v444 * v445 + ((v444 * v445) >> 16) + 1) >> 16));
            if (v444 != (v444 * v445 + ((v444 * v445) >> 16) + 1) >> 16)
            {
              v448 = bswap32(*(v23 + 3)) >> 16;
              v449 = bswap32(*(v23 + 1) | (*v23 << 16));
              v450 = HIWORD(v449);
              v451 = bswap32(*(v23 + 2)) >> 16;
              v452 = ((v448 - ((v445 * v448 + ((v445 * v448) >> 16) + 1) >> 16)) << 48) | ((v451 - ((v445 * v451 + ((v445 * v451) >> 16) + 1) >> 16)) << 32) | ((v450 - ((v450 * v445 + ((v450 * v445) >> 16) + 1) >> 16)) << 16) | (v449 - ((v449 * v445 + ((v449 * v445) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v453 = __rev16(*v7);
                  goto LABEL_553;
                }

LABEL_555:
                v456 = bswap32(v452);
                v14->i16[0] = HIWORD(v456);
                v14->i16[1] = v456;
                v14->i16[2] = bswap32(HIDWORD(v452)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v452));
                v454 = v7;
              }

              else
              {
                v453 = 0xFFFF;
LABEL_553:
                v454 = v14 + 3;
                v455 = PDAcolordodgePDA_11877(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v453, v452, v446);
                v452 = v455;
                v8 = v827;
                if (v827)
                {
                  v12 = v861;
                  v20 = v869;
                  v440 = v785;
                  v439 = v810;
                  goto LABEL_555;
                }

                v447 = HIWORD(v455);
                v457 = bswap32(v455);
                v14->i16[0] = HIWORD(v457);
                v14->i16[1] = v457;
                v14->i16[2] = bswap32(HIDWORD(v455)) >> 16;
                v12 = v861;
                v20 = v869;
                v440 = v785;
                v439 = v810;
              }

              *v454 = bswap32(v447) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v458 = &v23[8 * v35];
          if (v458 >= v12)
          {
            v459 = v440;
          }

          else
          {
            v459 = 0;
          }

          v441 += v439 + v459;
          v23 = &v458[4 * v459];
          v7 = (v7 + v442);
          --v443;
        }

        while (v443);
        if (v818)
        {
          v460 = &v825[4 * v823];
          v461 = v750;
          if (v460 < v818)
          {
            v461 = 0;
          }

          v441 = &v824[v821 + v461];
          v462 = v765;
          if (v460 < v818)
          {
            v462 = 0;
          }

          v23 = &v460[8 * v462];
          v12 += 8 * v462 + 8 * v823;
          v824 += v821 + v461;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v441 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 19:
      v518 = v20;
      v519 = -v34;
      v520 = v824;
      v752 = -(v821 * v22);
      v767 = -(v823 * v22);
      v521 = 2 * v8;
      v787 = -v34;
      v814 = v20;
      while (1)
      {
        v522 = v822;
        v865 = v12;
        do
        {
          if (*v16)
          {
            v523 = v20 ? bswap32(*v520) >> 16 : 0xFFFF;
            v524 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v525 = v523 - ((v523 * v524 + ((v523 * v524) >> 16) + 1) >> 16);
            LODWORD(v526) = (v523 - ((v523 * v524 + ((v523 * v524) >> 16) + 1) >> 16));
            if (v523 != (v523 * v524 + ((v523 * v524) >> 16) + 1) >> 16)
            {
              v527 = bswap32(*(v23 + 3)) >> 16;
              v528 = bswap32(*(v23 + 1) | (*v23 << 16));
              v529 = HIWORD(v528);
              v530 = bswap32(*(v23 + 2)) >> 16;
              v531 = ((v527 - ((v524 * v527 + ((v524 * v527) >> 16) + 1) >> 16)) << 48) | ((v530 - ((v524 * v530 + ((v524 * v530) >> 16) + 1) >> 16)) << 32) | ((v529 - ((v529 * v524 + ((v529 * v524) >> 16) + 1) >> 16)) << 16) | (v528 - ((v528 * v524 + ((v528 * v524) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v532 = __rev16(*v7);
                  goto LABEL_647;
                }

LABEL_649:
                v535 = bswap32(v531);
                v14->i16[0] = HIWORD(v535);
                v14->i16[1] = v535;
                v14->i16[2] = bswap32(HIDWORD(v531)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v531));
                v533 = v7;
              }

              else
              {
                v532 = 0xFFFF;
LABEL_647:
                v533 = v14 + 3;
                v534 = PDAcolorburnPDA_11878(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v532, v531, v525);
                v531 = v534;
                v8 = v827;
                if (v827)
                {
                  v12 = v865;
                  v20 = v869;
                  v519 = v787;
                  v518 = v814;
                  goto LABEL_649;
                }

                v526 = HIWORD(v534);
                v536 = bswap32(v534);
                v14->i16[0] = HIWORD(v536);
                v14->i16[1] = v536;
                v14->i16[2] = bswap32(HIDWORD(v534)) >> 16;
                v12 = v865;
                v20 = v869;
                v519 = v787;
                v518 = v814;
              }

              *v533 = bswap32(v526) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v537 = &v23[8 * v35];
          if (v537 >= v12)
          {
            v538 = v519;
          }

          else
          {
            v538 = 0;
          }

          v520 += v518 + v538;
          v23 = &v537[4 * v538];
          v7 = (v7 + v521);
          --v522;
        }

        while (v522);
        if (v818)
        {
          v539 = &v825[4 * v823];
          v540 = v752;
          if (v539 < v818)
          {
            v540 = 0;
          }

          v520 = &v824[v821 + v540];
          v541 = v767;
          if (v539 < v818)
          {
            v541 = 0;
          }

          v23 = &v539[8 * v541];
          v12 += 8 * v541 + 8 * v823;
          v824 += v821 + v540;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v520 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 20:
      v335 = v20;
      v336 = -v34;
      v337 = v824;
      v747 = -(v821 * v22);
      v762 = -(v823 * v22);
      v338 = 2 * v8;
      v781 = -v34;
      v805 = v20;
      while (1)
      {
        v339 = v822;
        v856 = v12;
        do
        {
          if (*v16)
          {
            v340 = v20 ? bswap32(*v337) >> 16 : 0xFFFF;
            v341 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v342 = v340 - ((v340 * v341 + ((v340 * v341) >> 16) + 1) >> 16);
            LODWORD(v343) = (v340 - ((v340 * v341 + ((v340 * v341) >> 16) + 1) >> 16));
            if (v340 != (v340 * v341 + ((v340 * v341) >> 16) + 1) >> 16)
            {
              v344 = bswap32(*(v23 + 3)) >> 16;
              v345 = bswap32(*(v23 + 1) | (*v23 << 16));
              v346 = HIWORD(v345);
              v347 = bswap32(*(v23 + 2)) >> 16;
              v348 = ((v344 - ((v341 * v344 + ((v341 * v344) >> 16) + 1) >> 16)) << 48) | ((v347 - ((v341 * v347 + ((v341 * v347) >> 16) + 1) >> 16)) << 32) | ((v346 - ((v346 * v341 + ((v346 * v341) >> 16) + 1) >> 16)) << 16) | (v345 - ((v345 * v341 + ((v345 * v341) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v349 = __rev16(*v7);
                  goto LABEL_423;
                }

LABEL_425:
                v352 = bswap32(v348);
                v14->i16[0] = HIWORD(v352);
                v14->i16[1] = v352;
                v14->i16[2] = bswap32(HIDWORD(v348)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v348));
                v350 = v7;
              }

              else
              {
                v349 = 0xFFFF;
LABEL_423:
                v350 = v14 + 3;
                v351 = PDAsoftlightPDA_11880(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v349, v348, v342);
                v348 = v351;
                v8 = v827;
                if (v827)
                {
                  v12 = v856;
                  v20 = v869;
                  v336 = v781;
                  v335 = v805;
                  goto LABEL_425;
                }

                v343 = HIWORD(v351);
                v353 = bswap32(v351);
                v14->i16[0] = HIWORD(v353);
                v14->i16[1] = v353;
                v14->i16[2] = bswap32(HIDWORD(v351)) >> 16;
                v12 = v856;
                v20 = v869;
                v336 = v781;
                v335 = v805;
              }

              *v350 = bswap32(v343) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v354 = &v23[8 * v35];
          if (v354 >= v12)
          {
            v355 = v336;
          }

          else
          {
            v355 = 0;
          }

          v337 += v335 + v355;
          v23 = &v354[4 * v355];
          v7 = (v7 + v338);
          --v339;
        }

        while (v339);
        if (v818)
        {
          v356 = &v825[4 * v823];
          v357 = v747;
          if (v356 < v818)
          {
            v357 = 0;
          }

          v337 = &v824[v821 + v357];
          v358 = v762;
          if (v356 < v818)
          {
            v358 = 0;
          }

          v23 = &v356[8 * v358];
          v12 += 8 * v358 + 8 * v823;
          v824 += v821 + v357;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v337 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 21:
      v377 = v20;
      v378 = -v34;
      v379 = v824;
      v748 = -(v821 * v22);
      v763 = -(v823 * v22);
      v380 = 2 * v8;
      v782 = -v34;
      v807 = v20;
      while (1)
      {
        v381 = v822;
        v858 = v12;
        do
        {
          if (*v16)
          {
            v382 = v20 ? bswap32(*v379) >> 16 : 0xFFFF;
            v383 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v384 = v382 - ((v382 * v383 + ((v382 * v383) >> 16) + 1) >> 16);
            LODWORD(v385) = (v382 - ((v382 * v383 + ((v382 * v383) >> 16) + 1) >> 16));
            if (v382 != (v382 * v383 + ((v382 * v383) >> 16) + 1) >> 16)
            {
              v386 = bswap32(*(v23 + 3)) >> 16;
              v387 = bswap32(*(v23 + 1) | (*v23 << 16));
              v388 = HIWORD(v387);
              v389 = bswap32(*(v23 + 2)) >> 16;
              v390 = ((v386 - ((v383 * v386 + ((v383 * v386) >> 16) + 1) >> 16)) << 48) | ((v389 - ((v383 * v389 + ((v383 * v389) >> 16) + 1) >> 16)) << 32) | ((v388 - ((v388 * v383 + ((v388 * v383) >> 16) + 1) >> 16)) << 16) | (v387 - ((v387 * v383 + ((v387 * v383) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v391 = __rev16(*v7);
                  goto LABEL_468;
                }

LABEL_470:
                v394 = bswap32(v390);
                v14->i16[0] = HIWORD(v394);
                v14->i16[1] = v394;
                v14->i16[2] = bswap32(HIDWORD(v390)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v390));
                v392 = v7;
              }

              else
              {
                v391 = 0xFFFF;
LABEL_468:
                v392 = v14 + 3;
                v393 = PDAhardlightPDA_11879(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v391, v390, v384);
                v390 = v393;
                v8 = v827;
                if (v827)
                {
                  v12 = v858;
                  v20 = v869;
                  v378 = v782;
                  v377 = v807;
                  goto LABEL_470;
                }

                v385 = HIWORD(v393);
                v395 = bswap32(v393);
                v14->i16[0] = HIWORD(v395);
                v14->i16[1] = v395;
                v14->i16[2] = bswap32(HIDWORD(v393)) >> 16;
                v12 = v858;
                v20 = v869;
                v378 = v782;
                v377 = v807;
              }

              *v392 = bswap32(v385) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v396 = &v23[8 * v35];
          if (v396 >= v12)
          {
            v397 = v378;
          }

          else
          {
            v397 = 0;
          }

          v379 += v377 + v397;
          v23 = &v396[4 * v397];
          v7 = (v7 + v380);
          --v381;
        }

        while (v381);
        if (v818)
        {
          v398 = &v825[4 * v823];
          v399 = v748;
          if (v398 < v818)
          {
            v399 = 0;
          }

          v379 = &v824[v821 + v399];
          v400 = v763;
          if (v398 < v818)
          {
            v400 = 0;
          }

          v23 = &v398[8 * v400];
          v12 += 8 * v400 + 8 * v823;
          v824 += v821 + v399;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v379 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 22:
      v494 = v20;
      v495 = -v34;
      v496 = v824;
      v751 = -(v821 * v22);
      v766 = -(v823 * v22);
      v497 = 2 * v8;
      v786 = -v34;
      v813 = v20;
      while (1)
      {
        v498 = v822;
        v864 = v12;
        do
        {
          if (*v16)
          {
            v499 = v20 ? bswap32(*v496) >> 16 : 0xFFFF;
            v500 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v501 = v499 - ((v499 * v500 + ((v499 * v500) >> 16) + 1) >> 16);
            LODWORD(v502) = (v499 - ((v499 * v500 + ((v499 * v500) >> 16) + 1) >> 16));
            if (v499 != (v499 * v500 + ((v499 * v500) >> 16) + 1) >> 16)
            {
              v503 = bswap32(*(v23 + 3)) >> 16;
              v504 = bswap32(*(v23 + 1) | (*v23 << 16));
              v505 = HIWORD(v504);
              v506 = bswap32(*(v23 + 2)) >> 16;
              v507 = ((v503 - ((v500 * v503 + ((v500 * v503) >> 16) + 1) >> 16)) << 48) | ((v506 - ((v500 * v506 + ((v500 * v506) >> 16) + 1) >> 16)) << 32) | ((v505 - ((v505 * v500 + ((v505 * v500) >> 16) + 1) >> 16)) << 16) | (v504 - ((v504 * v500 + ((v504 * v500) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v508 = __rev16(*v7);
                  goto LABEL_618;
                }

LABEL_620:
                v511 = bswap32(v507);
                v14->i16[0] = HIWORD(v511);
                v14->i16[1] = v511;
                v14->i16[2] = bswap32(HIDWORD(v507)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v507));
                v509 = v7;
              }

              else
              {
                v508 = 0xFFFF;
LABEL_618:
                v509 = v14 + 3;
                v510 = PDAdifferencePDA_11881(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v508, v507, v501);
                v507 = v510;
                v8 = v827;
                if (v827)
                {
                  v12 = v864;
                  v20 = v869;
                  v495 = v786;
                  v494 = v813;
                  goto LABEL_620;
                }

                v502 = HIWORD(v510);
                v512 = bswap32(v510);
                v14->i16[0] = HIWORD(v512);
                v14->i16[1] = v512;
                v14->i16[2] = bswap32(HIDWORD(v510)) >> 16;
                v12 = v864;
                v20 = v869;
                v495 = v786;
                v494 = v813;
              }

              *v509 = bswap32(v502) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v513 = &v23[8 * v35];
          if (v513 >= v12)
          {
            v514 = v495;
          }

          else
          {
            v514 = 0;
          }

          v496 += v494 + v514;
          v23 = &v513[4 * v514];
          v7 = (v7 + v497);
          --v498;
        }

        while (v498);
        if (v818)
        {
          v515 = &v825[4 * v823];
          v516 = v751;
          if (v515 < v818)
          {
            v516 = 0;
          }

          v496 = &v824[v821 + v516];
          v517 = v766;
          if (v515 < v818)
          {
            v517 = 0;
          }

          v23 = &v515[8 * v517];
          v12 += 8 * v517 + 8 * v823;
          v824 += v821 + v516;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v496 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 23:
      v542 = v20;
      v543 = -v34;
      v544 = v824;
      v753 = -(v821 * v22);
      v768 = -(v823 * v22);
      v545 = 2 * v8;
      v788 = -v34;
      v815 = v20;
      while (1)
      {
        v546 = v822;
        v866 = v12;
        do
        {
          if (*v16)
          {
            v547 = v20 ? bswap32(*v544) >> 16 : 0xFFFF;
            v548 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v549 = v547 - ((v547 * v548 + ((v547 * v548) >> 16) + 1) >> 16);
            LODWORD(v550) = (v547 - ((v547 * v548 + ((v547 * v548) >> 16) + 1) >> 16));
            if (v547 != (v547 * v548 + ((v547 * v548) >> 16) + 1) >> 16)
            {
              v551 = bswap32(*(v23 + 3)) >> 16;
              v552 = bswap32(*(v23 + 1) | (*v23 << 16));
              v553 = HIWORD(v552);
              v554 = bswap32(*(v23 + 2)) >> 16;
              v555 = ((v551 - ((v548 * v551 + ((v548 * v551) >> 16) + 1) >> 16)) << 48) | ((v554 - ((v548 * v554 + ((v548 * v554) >> 16) + 1) >> 16)) << 32) | ((v553 - ((v553 * v548 + ((v553 * v548) >> 16) + 1) >> 16)) << 16) | (v552 - ((v552 * v548 + ((v552 * v548) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v556 = __rev16(*v7);
                  goto LABEL_676;
                }

LABEL_678:
                v559 = bswap32(v555);
                v14->i16[0] = HIWORD(v559);
                v14->i16[1] = v559;
                v14->i16[2] = bswap32(HIDWORD(v555)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v555));
                v557 = v7;
              }

              else
              {
                v556 = 0xFFFF;
LABEL_676:
                v557 = v14 + 3;
                v558 = PDAexclusionPDA_11882(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v556, v555, v549);
                v555 = v558;
                v8 = v827;
                if (v827)
                {
                  v12 = v866;
                  v20 = v869;
                  v543 = v788;
                  v542 = v815;
                  goto LABEL_678;
                }

                v550 = HIWORD(v558);
                v560 = bswap32(v558);
                v14->i16[0] = HIWORD(v560);
                v14->i16[1] = v560;
                v14->i16[2] = bswap32(HIDWORD(v558)) >> 16;
                v12 = v866;
                v20 = v869;
                v543 = v788;
                v542 = v815;
              }

              *v557 = bswap32(v550) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v561 = &v23[8 * v35];
          if (v561 >= v12)
          {
            v562 = v543;
          }

          else
          {
            v562 = 0;
          }

          v544 += v542 + v562;
          v23 = &v561[4 * v562];
          v7 = (v7 + v545);
          --v546;
        }

        while (v546);
        if (v818)
        {
          v563 = &v825[4 * v823];
          v564 = v753;
          if (v563 < v818)
          {
            v564 = 0;
          }

          v544 = &v824[v821 + v564];
          v565 = v768;
          if (v563 < v818)
          {
            v565 = 0;
          }

          v23 = &v563[8 * v565];
          v12 += 8 * v565 + 8 * v823;
          v824 += v821 + v564;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v544 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 24:
      v197 = v20;
      v198 = -v34;
      v199 = v824;
      v744 = -(v821 * v22);
      v759 = -(v823 * v22);
      v200 = 2 * v8;
      v777 = -v34;
      v798 = v20;
      while (1)
      {
        v201 = v822;
        v849 = v12;
        do
        {
          if (*v16)
          {
            v202 = v20 ? bswap32(*v199) >> 16 : 0xFFFF;
            v203 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v204 = v202 - ((v202 * v203 + ((v202 * v203) >> 16) + 1) >> 16);
            LODWORD(v205) = (v202 - ((v202 * v203 + ((v202 * v203) >> 16) + 1) >> 16));
            if (v202 != (v202 * v203 + ((v202 * v203) >> 16) + 1) >> 16)
            {
              v206 = bswap32(*(v23 + 3)) >> 16;
              v207 = bswap32(*(v23 + 1) | (*v23 << 16));
              v208 = HIWORD(v207);
              v209 = bswap32(*(v23 + 2)) >> 16;
              v210 = ((v206 - ((v203 * v206 + ((v203 * v206) >> 16) + 1) >> 16)) << 48) | ((v209 - ((v203 * v209 + ((v203 * v209) >> 16) + 1) >> 16)) << 32) | ((v208 - ((v208 * v203 + ((v208 * v203) >> 16) + 1) >> 16)) << 16) | (v207 - ((v207 * v203 + ((v207 * v203) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v211 = __rev16(*v7);
                  goto LABEL_245;
                }

LABEL_247:
                v214 = bswap32(v210);
                v14->i16[0] = HIWORD(v214);
                v14->i16[1] = v214;
                v14->i16[2] = bswap32(HIDWORD(v210)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v210));
                v212 = v7;
              }

              else
              {
                v211 = 0xFFFF;
LABEL_245:
                v212 = v14 + 3;
                v213 = PDAhuePDA_11883(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v211, v210, v204);
                v210 = v213;
                v8 = v827;
                if (v827)
                {
                  v12 = v849;
                  v20 = v869;
                  v198 = v777;
                  v197 = v798;
                  goto LABEL_247;
                }

                v205 = HIWORD(v213);
                v215 = bswap32(v213);
                v14->i16[0] = HIWORD(v215);
                v14->i16[1] = v215;
                v14->i16[2] = bswap32(HIDWORD(v213)) >> 16;
                v12 = v849;
                v20 = v869;
                v198 = v777;
                v197 = v798;
              }

              *v212 = bswap32(v205) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v216 = &v23[8 * v35];
          if (v216 >= v12)
          {
            v217 = v198;
          }

          else
          {
            v217 = 0;
          }

          v199 += v197 + v217;
          v23 = &v216[4 * v217];
          v7 = (v7 + v200);
          --v201;
        }

        while (v201);
        if (v818)
        {
          v218 = &v825[4 * v823];
          v219 = v744;
          if (v218 < v818)
          {
            v219 = 0;
          }

          v199 = &v824[v821 + v219];
          v220 = v759;
          if (v218 < v818)
          {
            v220 = 0;
          }

          v23 = &v218[8 * v220];
          v12 += 8 * v220 + 8 * v823;
          v824 += v821 + v219;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v199 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 25:
      v173 = v20;
      v174 = -v34;
      v175 = v824;
      v743 = -(v821 * v22);
      v758 = -(v823 * v22);
      v176 = 2 * v8;
      v776 = -v34;
      v797 = v20;
      while (1)
      {
        v177 = v822;
        v848 = v12;
        do
        {
          if (*v16)
          {
            v178 = v20 ? bswap32(*v175) >> 16 : 0xFFFF;
            v179 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v180 = v178 - ((v178 * v179 + ((v178 * v179) >> 16) + 1) >> 16);
            LODWORD(v181) = (v178 - ((v178 * v179 + ((v178 * v179) >> 16) + 1) >> 16));
            if (v178 != (v178 * v179 + ((v178 * v179) >> 16) + 1) >> 16)
            {
              v182 = bswap32(*(v23 + 3)) >> 16;
              v183 = bswap32(*(v23 + 1) | (*v23 << 16));
              v184 = HIWORD(v183);
              v185 = bswap32(*(v23 + 2)) >> 16;
              v186 = ((v182 - ((v179 * v182 + ((v179 * v182) >> 16) + 1) >> 16)) << 48) | ((v185 - ((v179 * v185 + ((v179 * v185) >> 16) + 1) >> 16)) << 32) | ((v184 - ((v184 * v179 + ((v184 * v179) >> 16) + 1) >> 16)) << 16) | (v183 - ((v183 * v179 + ((v183 * v179) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v187 = __rev16(*v7);
                  goto LABEL_216;
                }

LABEL_218:
                v190 = bswap32(v186);
                v14->i16[0] = HIWORD(v190);
                v14->i16[1] = v190;
                v14->i16[2] = bswap32(HIDWORD(v186)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v186));
                v188 = v7;
              }

              else
              {
                v187 = 0xFFFF;
LABEL_216:
                v188 = v14 + 3;
                v189 = PDAsaturationPDA_11884(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v187, v186, v180);
                v186 = v189;
                v8 = v827;
                if (v827)
                {
                  v12 = v848;
                  v20 = v869;
                  v174 = v776;
                  v173 = v797;
                  goto LABEL_218;
                }

                v181 = HIWORD(v189);
                v191 = bswap32(v189);
                v14->i16[0] = HIWORD(v191);
                v14->i16[1] = v191;
                v14->i16[2] = bswap32(HIDWORD(v189)) >> 16;
                v12 = v848;
                v20 = v869;
                v174 = v776;
                v173 = v797;
              }

              *v188 = bswap32(v181) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v192 = &v23[8 * v35];
          if (v192 >= v12)
          {
            v193 = v174;
          }

          else
          {
            v193 = 0;
          }

          v175 += v173 + v193;
          v23 = &v192[4 * v193];
          v7 = (v7 + v176);
          --v177;
        }

        while (v177);
        if (v818)
        {
          v194 = &v825[4 * v823];
          v195 = v743;
          if (v194 < v818)
          {
            v195 = 0;
          }

          v175 = &v824[v821 + v195];
          v196 = v758;
          if (v194 < v818)
          {
            v196 = 0;
          }

          v23 = &v194[8 * v196];
          v12 += 8 * v196 + 8 * v823;
          v824 += v821 + v195;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v175 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 26:
      v566 = v20;
      v567 = -v34;
      v568 = v824;
      v754 = -(v821 * v22);
      v769 = -(v823 * v22);
      v569 = 2 * v8;
      v789 = -v34;
      v816 = v20;
      while (1)
      {
        v570 = v822;
        v867 = v12;
        do
        {
          if (*v16)
          {
            v571 = v20 ? bswap32(*v568) >> 16 : 0xFFFF;
            v572 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v573 = v571 - ((v571 * v572 + ((v571 * v572) >> 16) + 1) >> 16);
            LODWORD(v574) = (v571 - ((v571 * v572 + ((v571 * v572) >> 16) + 1) >> 16));
            if (v571 != (v571 * v572 + ((v571 * v572) >> 16) + 1) >> 16)
            {
              v575 = bswap32(*(v23 + 3)) >> 16;
              v576 = bswap32(*(v23 + 1) | (*v23 << 16));
              v577 = HIWORD(v576);
              v578 = bswap32(*(v23 + 2)) >> 16;
              v579 = ((v575 - ((v572 * v575 + ((v572 * v575) >> 16) + 1) >> 16)) << 48) | ((v578 - ((v572 * v578 + ((v572 * v578) >> 16) + 1) >> 16)) << 32) | ((v577 - ((v577 * v572 + ((v577 * v572) >> 16) + 1) >> 16)) << 16) | (v576 - ((v576 * v572 + ((v576 * v572) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v580 = __rev16(*v7);
                  goto LABEL_705;
                }

LABEL_707:
                v582 = bswap32(v579);
                v14->i16[0] = HIWORD(v582);
                v14->i16[1] = v582;
                v14->i16[2] = bswap32(HIDWORD(v579)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v579));
                v581 = v7;
              }

              else
              {
                v580 = 0xFFFF;
LABEL_705:
                v581 = v14 + 3;
                v579 = PDAluminosityPDA_11885(v579, v573, ((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v580);
                v8 = v827;
                if (v827)
                {
                  v12 = v867;
                  v20 = v869;
                  v567 = v789;
                  v566 = v816;
                  goto LABEL_707;
                }

                v574 = HIWORD(v579);
                v583 = bswap32(v579);
                v14->i16[0] = HIWORD(v583);
                v14->i16[1] = v583;
                v14->i16[2] = bswap32(HIDWORD(v579)) >> 16;
                v12 = v867;
                v20 = v869;
                v567 = v789;
                v566 = v816;
              }

              *v581 = bswap32(v574) >> 16;
            }
          }

          v16 += v35;
          v14 += v35;
          v584 = &v23[8 * v35];
          if (v584 >= v12)
          {
            v585 = v567;
          }

          else
          {
            v585 = 0;
          }

          v568 += v566 + v585;
          v23 = &v584[4 * v585];
          v7 = (v7 + v569);
          --v570;
        }

        while (v570);
        if (v818)
        {
          v586 = &v825[4 * v823];
          v587 = v754;
          if (v586 < v818)
          {
            v587 = 0;
          }

          v568 = &v824[v821 + v587];
          v588 = v769;
          if (v586 < v818)
          {
            v588 = 0;
          }

          v23 = &v586[8 * v588];
          v12 += 8 * v588 + 8 * v823;
          v824 += v821 + v587;
          v825 = v23;
        }

        else
        {
          v23 += 8 * v823;
          v568 += v821;
        }

        v16 += v820;
        v14 += v819;
        v7 += v817;
        if (!--v826)
        {
          return;
        }
      }

    case 27:
      v40 = v20;
      v41 = -v34;
      v42 = v824;
      v740 = -(v821 * v22);
      v755 = -(v823 * v22);
      v43 = 2 * v8;
      v770 = -v34;
      v790 = v20;
      break;
    default:
      return;
  }

  do
  {
    v44 = v822;
    v841 = v12;
    do
    {
      if (*v16)
      {
        v45 = v20 ? bswap32(*v42) >> 16 : 0xFFFF;
        v46 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
        v47 = v45 - ((v45 * v46 + ((v45 * v46) >> 16) + 1) >> 16);
        LODWORD(v48) = (v45 - ((v45 * v46 + ((v45 * v46) >> 16) + 1) >> 16));
        if (v45 != (v45 * v46 + ((v45 * v46) >> 16) + 1) >> 16)
        {
          v49 = bswap32(*(v23 + 3)) >> 16;
          v50 = bswap32(*(v23 + 1) | (*v23 << 16));
          v51 = HIWORD(v50);
          v52 = bswap32(*(v23 + 2)) >> 16;
          v53 = ((v49 - ((v46 * v49 + ((v46 * v49) >> 16) + 1) >> 16)) << 48) | ((v52 - ((v46 * v52 + ((v46 * v52) >> 16) + 1) >> 16)) << 32) | ((v51 - ((v51 * v46 + ((v51 * v46) >> 16) + 1) >> 16)) << 16) | (v50 - ((v50 * v46 + ((v50 * v46) >> 16) + 1) >> 16));
          if (v8)
          {
            if (!*v7)
            {
              goto LABEL_50;
            }

            v54 = __rev16(*v7);
          }

          else
          {
            v54 = 0xFFFF;
          }

          v55 = v14 + 3;
          v56 = PDAluminosityPDA_11885(((bswap32(v14->u16[2]) >> 16) << 32) | ((bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (bswap32(v14->u16[0]) >> 16), v54, v53, v47);
          v53 = v56;
          v8 = v827;
          if (!v827)
          {
            v48 = HIWORD(v56);
            v58 = bswap32(v56);
            v14->i16[0] = HIWORD(v58);
            v14->i16[1] = v58;
            v14->i16[2] = bswap32(HIDWORD(v56)) >> 16;
            v12 = v841;
            v20 = v869;
            v41 = v770;
            v40 = v790;
            goto LABEL_52;
          }

          v12 = v841;
          v20 = v869;
          v41 = v770;
          v40 = v790;
LABEL_50:
          v57 = bswap32(v53);
          v14->i16[0] = HIWORD(v57);
          v14->i16[1] = v57;
          v14->i16[2] = bswap32(HIDWORD(v53)) >> 16;
          v14->i16[3] = __rev16(HIWORD(v53));
          v55 = v7;
LABEL_52:
          *v55 = bswap32(v48) >> 16;
        }
      }

      v16 += v35;
      v14 += v35;
      v59 = &v23[8 * v35];
      if (v59 >= v12)
      {
        v60 = v41;
      }

      else
      {
        v60 = 0;
      }

      v42 += v40 + v60;
      v23 = &v59[4 * v60];
      v7 = (v7 + v43);
      --v44;
    }

    while (v44);
    if (v818)
    {
      v61 = &v825[4 * v823];
      v62 = v740;
      if (v61 < v818)
      {
        v62 = 0;
      }

      v42 = &v824[v821 + v62];
      v63 = v755;
      if (v61 < v818)
      {
        v63 = 0;
      }

      v23 = &v61[8 * v63];
      v12 += 8 * v63 + 8 * v823;
      v824 += v821 + v62;
      v825 = v23;
    }

    else
    {
      v23 += 8 * v823;
      v42 += v821;
    }

    v16 += v820;
    v14 += v819;
    v7 += v817;
    --v826;
  }

  while (v826);
}

_DWORD *CMYK64_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float32x2_t *a5, float a6, double a7, double a8, double a9)
{
  v11 = PIXELCONSTANT_11889(*(*a1 + 64), a4, a5, a6, a7, a8, a9);
  v13 = v12;
  if (a2 && a3 > 0xB || (a2 = malloc_type_malloc(0x3CuLL, 0x1080040E00A32E4uLL)) != 0)
  {
    *a2 = xmmword_18439CB50;
    a2[6] = 0;
    v14 = bswap32(v11);
    *(a2 + 24) = HIWORD(v14);
    *(a2 + 2) = 1;
    *(a2 + 4) = a2 + 12;
    *(a2 + 25) = v14;
    *(a2 + 26) = bswap32(HIDWORD(v11)) >> 16;
    *(a2 + 27) = __rev16(HIWORD(v11));
    if (v13 == 0xFFFF)
    {
      *(a2 + 5) = 0;
    }

    else
    {
      a2[14] = bswap32(v13 | (v13 << 16));
      *(a2 + 5) = a2 + 14;
    }
  }

  return a2;
}

uint64_t CGPDFArchiveCreate()
{
  if (!CGPDFArchiveGetTypeID_id)
  {
    CGPDFArchiveGetTypeID_id = _CFRuntimeRegisterClass();
  }

  Instance = _CFRuntimeCreateInstance();
  *(Instance + 16) = objc_alloc_init(CPArchive);
  return Instance;
}

CFTypeRef CGPDFArchiveRetain(CFTypeRef cf)
{
  if (cf)
  {
    return CFRetain(cf);
  }

  return cf;
}

void CGPDFArchiveRelease(CFTypeRef cf)
{
  if (cf)
  {
    CFRelease(cf);
  }
}

uint64_t CGPDFArchiveAddSelection(uint64_t result, uint64_t a2)
{
  if (result)
  {
    return [*(result + 16) addSelection:a2];
  }

  return result;
}

uint64_t CGPDFArchiveGetPlainText(uint64_t result)
{
  if (result)
  {
    return [*(result + 16) plainText];
  }

  return result;
}

uint64_t CGPDFArchiveGetHTML(uint64_t result)
{
  if (result)
  {
    return [*(result + 16) html];
  }

  return result;
}

uint64_t CGPDFArchiveGetWebArchiveData(uint64_t result)
{
  if (result)
  {
    return [*(result + 16) webArchiveData];
  }

  return result;
}

uint64_t CGPDFArchiveGetStructuredString(uint64_t result)
{
  if (result)
  {
    return [*(result + 16) structuredString];
  }

  return result;
}

uint64_t CGPDFArchiveGetRTFDData(uint64_t result)
{
  if (result)
  {
    return [*(result + 16) RTFDData];
  }

  return result;
}

_BYTE *lzw_decoder_create(const void *a1, char a2)
{
  v4 = malloc_type_calloc(1uLL, 0x4450uLL, 0x1030040EB8D5A71uLL);
  if (v4)
  {
    if (a1)
    {
      CFRetain(a1);
    }

    *v4 = a1;
    v4[10] = a2;
    *(v4 + 264) = 9;
    *(v4 + 8722) = 258;
    *(v4 + 8724) = 0;
  }

  return v4;
}

void lzw_decoder_release(void **a1)
{
  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      CFRelease(v2);
    }

    free(a1[2185]);

    free(a1);
  }
}

uint64_t lzw_read_code(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v8 = a1 + 0x4000;
  v9 = *(a1 + 17456);
  v10 = *(a1 + 1056);
  if (v9 >= v10)
  {
    v13 = *(a1 + 17452);
LABEL_6:
    v14 = v9 - v10;
    *(v8 + 1072) = v14;
    return ((v13 >> v14) & ~(-1 << v10));
  }

  else
  {
    while (1)
    {
      v12 = CGPDFSourceGetc(*a1, a2, a3, a4, a5, a6, a7, a8);
      if (v12 == -1)
      {
        break;
      }

      v13 = v12 | (*(v8 + 1068) << 8);
      *(v8 + 1068) = v13;
      v9 = *(v8 + 1072) + 8;
      *(v8 + 1072) = v9;
      v10 = *(a1 + 1056);
      if (v9 >= v10)
      {
        goto LABEL_6;
      }
    }

    pdf_error("LZW decode: encountered unexpected EOF.");
    *(a1 + 9) = 1;
    LOWORD(v15) = 257;
  }

  return v15;
}

void *lzw_push(void *result, char a2)
{
  v3 = result;
  v4 = *(result + 2183);
  v5 = *(result + 2184);
  if (v4 == v5)
  {
    v5 = 2 * v4 + 10;
    v6 = malloc_type_realloc(*(result + 2185), v5, 0xCEEBCDCDuLL);
    v3[2185] = v6;
    result = memmove(&v6[v5 - v3[2184]], v6, v3[2184]);
    v3[2184] = v5;
    v4 = v3[2183];
  }

  v7 = v4 + 1;
  v3[2183] = v7;
  *(v3[2185] + v5 - v7) = a2;
  return result;
}

uint64_t CGPDFFormCreate(CGPDFDictionary *a1)
{
  v9 = *MEMORY[0x1E69E9840];
  if (CGPDFFormGetTypeID_onceToken != -1)
  {
    dispatch_once(&CGPDFFormGetTypeID_onceToken, &__block_literal_global_12001);
  }

  cftype = pdf_create_cftype();
  v3 = cftype;
  if (cftype)
  {
    value = 0;
    *(cftype + 16) = a1;
    if (a1)
    {
      a1 = *(a1 + 6);
    }

    if (CGPDFDictionaryGetInteger(a1, "FormType", &value) && value != 1)
    {
LABEL_13:
      CFRelease(v3);
      return 0;
    }

    if (!CGPDFDictionaryGetRect(a1, "BBox", (v3 + 24)))
    {
      goto LABEL_13;
    }

    if (CGPDFDictionaryGetNumbers(a1, "Matrix", v8, 6))
    {
      v4 = v8[1];
      *(v3 + 56) = v8[0];
      *(v3 + 72) = v4;
      v5 = v8[2];
    }

    else
    {
      *(v3 + 56) = *&CGAffineTransformIdentity.a;
      *(v3 + 72) = *&CGAffineTransformIdentity.c;
      v5 = *&CGAffineTransformIdentity.tx;
    }

    *(v3 + 88) = v5;
    if (!CGPDFDictionaryGetDictionary(a1, "Resources", (v3 + 104)))
    {
      *(v3 + 104) = 0;
    }
  }

  return v3;
}

uint64_t __CGPDFFormGetTypeID_block_invoke()
{
  result = pdf_register_cftype(&CGPDFFormGetTypeID_class);
  CGPDFFormGetTypeID_id = result;
  return result;
}

void CGPDFFormRelease(CFTypeRef cf)
{
  if (cf)
  {
    CFRelease(cf);
  }
}

CFTypeRef CGPDFFormRetain(CFTypeRef cf)
{
  if (cf)
  {
    CFRetain(cf);
  }

  return cf;
}

uint64_t CGPDFFormGetStream(uint64_t result)
{
  if (result)
  {
    return *(result + 16);
  }

  return result;
}

CGFloat CGPDFFormGetBBox(uint64_t a1)
{
  v1 = &CGRectNull;
  if (a1)
  {
    v1 = (a1 + 24);
  }

  return v1->origin.x;
}

__n128 CGPDFFormGetMatrix@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v2 = (a1 + 56);
  if (!a1)
  {
    v2 = &CGAffineTransformIdentity;
  }

  v3 = *&v2->c;
  *a2 = *&v2->a;
  *(a2 + 16) = v3;
  result = *&v2->tx;
  *(a2 + 32) = result;
  return result;
}

uint64_t CGPDFFormGetResources(uint64_t result)
{
  if (result)
  {
    return *(result + 104);
  }

  return result;
}

void shape_enum_alloc(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  v6 = a2;
  shape_enum_allocate(a2, 0, a4);
  if (v6 != &the_empty_shape && v6[v6[1]] != 0x7FFFFFFF)
  {
    *(v7 + 4) = a3;
    if (a4 < 0)
    {
      v10 = (v7 + 56);
      while (*v6 != 0x7FFFFFFF)
      {
        v11 = v6[1];
        *v10++ = -v11;
        v6 += v11;
      }

      *(v7 + 32) = v6 - 2;
      *(v7 + 40) = v6;
      v8 = v10 - 1;
      v9 = 48;
    }

    else
    {
      *(v7 + 32) = v6;
      v8 = v6 + 2;
      v9 = 40;
    }

    *(v7 + v9) = v8;
  }
}

uint64_t shape_enum_next(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  v5 = *(a1 + 32);
  if (v5)
  {
    v6 = *(a1 + 8);
    v7 = *(a1 + 48);
    if (v7)
    {
      if (!v6)
      {
        v8 = (v7 - 4);
        while (1)
        {
          v9 = v5;
          v10 = v8;
          v11 = *v8;
          v5 += v11;
          if (*v5 == 0x80000000)
          {
            break;
          }

          --v8;
          if (v11 != -2)
          {
            v6 = -2 - v11;
            *(a1 + 32) = v5;
            *(a1 + 40) = v9;
            *(a1 + 48) = v10;
            goto LABEL_13;
          }
        }

        v5 = 0;
        *(a1 + 48) = v8;
LABEL_20:
        *(a1 + 32) = 0;
        *(a1 + 40) = v9;
        return v5;
      }
    }

    else if (!v6)
    {
      v9 = *(a1 + 40);
      while (1)
      {
        v5 = v9;
        v12 = v9[1];
        v9 += v12;
        if (*v9 == 0x7FFFFFFF)
        {
          break;
        }

        v6 = v12 - 2;
        if (v6)
        {
          *(a1 + 32) = v5;
          *(a1 + 40) = v9;
          goto LABEL_13;
        }
      }

      v5 = 0;
      goto LABEL_20;
    }

LABEL_13:
    *(a1 + 8) = v6 - 2;
    if ((*(a1 + 4) & 0x80000000) != 0)
    {
      v14 = &v5[v6];
      v13 = *(a1 + 40);
    }

    else
    {
      v13 = *(a1 + 40);
      v14 = &v13[-v6];
    }

    *a2 = *v14;
    *a4 = v14[1];
    *a3 = *v5;
    *a5 = *v13;
    return 1;
  }

  return v5;
}

float32x2_t shape_enum_allocate(_DWORD *a1, int a2, int a3)
{
  if (a3 < 0 && *a1 != 0x7FFFFFFF)
  {
    v7 = 0;
    do
    {
      ++v7;
      a1 += a1[1];
    }

    while (*a1 != 0x7FFFFFFF);
    v4 = 4 * v7 + 56;
  }

  else
  {
    v4 = 56;
  }

  v5 = malloc_type_malloc(v4, 0x1050040CAC2EC8CuLL);
  *v5 = a2;
  *(v5 + 4) = xmmword_18439CC20;
  result = vneg_f32(0x100000001);
  *(v5 + 20) = result;
  *(v5 + 5) = 0;
  *(v5 + 6) = 0;
  *(v5 + 4) = 0;
  return result;
}

uint64_t shape_forward_enum@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  a2[2] = 0;
  if (result == &the_empty_shape)
  {
    v2 = &unk_184562BD8;
    v3 = 1;
    goto LABEL_5;
  }

  v2 = (result + 8);
  v3 = *(result + 4 * *(result + 4)) == 0x7FFFFFFF;
  if (*(result + 4 * *(result + 4)) == 0x7FFFFFFF)
  {
LABEL_5:
    result = 0;
  }

  if (v3)
  {
    v2 = 0;
  }

  *a2 = result;
  a2[1] = v2;
  return result;
}

uint64_t shape_forward_enum_next(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  v5 = *a1;
  if (*a1)
  {
    v6 = *(a1 + 16);
    v7 = *(a1 + 8);
    if (v6)
    {
LABEL_6:
      *(a1 + 16) = v6 - 2;
      v9 = &v7[-v6];
      *a2 = *v9;
      *a4 = v9[1];
      *a3 = *v5;
      *a5 = *v7;
      return 1;
    }

    else
    {
      while (1)
      {
        v5 = v7;
        v8 = v7[1];
        v7 += v8;
        if (*v7 == 0x7FFFFFFF)
        {
          break;
        }

        v6 = v8 - 2;
        if (v6)
        {
          *a1 = v5;
          *(a1 + 8) = v7;
          goto LABEL_6;
        }
      }

      v5 = 0;
      *a1 = 0;
      *(a1 + 8) = v7;
    }
  }

  return v5;
}

void *shape_enum_binary_init(void *result, uint64_t a2)
{
  v2 = (a2 + 4 * *(a2 + 4));
  if (*v2 == 0x7FFFFFFF || (v3 = v2[1], v4 = &v2[v3], *v4 == 0x7FFFFFFF))
  {
    v5 = 0;
  }

  else
  {
    v5 = 0;
    do
    {
      v5 = v5 + v3 / 2 - 1;
      v3 = v4[1];
      v4 += v3;
    }

    while (*v4 != 0x7FFFFFFF);
  }

  do
  {
    v6 = v5;
    v5 &= v5 - 1;
  }

  while (v5);
  result[1] = 0;
  result[2] = a2;
  *result = 0;
  result[3] = (4 * v6);
  return result;
}

uint64_t shape_enum_binary_next(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  v5 = *(a1 + 24);
  if (v5 < 2)
  {
    return 0;
  }

  v7 = *a1;
  if (*a1)
  {
    v8 = *(a1 + 8);
    v9 = *(a1 + 28);
    v10 = 2 * v5;
    v11 = *(a1 + 24);
  }

  else
  {
    v11 = v5 >> 1;
    v7 = *(a1 + 16);
    v12 = v7[1];
    *(a1 + 24) = v5 >> 1;
    if (v5 < 4)
    {
      return 0;
    }

    v8 = &v7[v12];
    v9 = v12 - 2;
    v10 = v11 - 2;
  }

  if (v9 <= v10)
  {
    do
    {
      v14 = v8[1];
      v13 = &v8[v14];
      if (*v13 == 0x7FFFFFFF)
      {
        v8 = *(a1 + 16);
        v15 = v8[1];
        *(a1 + 24) = v11 >> 1;
        if (v11 < 4)
        {
          return 0;
        }

        v10 = (v11 >> 1) - 2;
        v11 >>= 1;
        LODWORD(v14) = v15;
        v13 = &v8[v15];
      }

      else
      {
        v10 -= v9;
      }

      v7 = v8;
      v9 = v14 - 2;
      v8 = v13;
    }

    while (v14 - 2 <= v10);
  }

  else
  {
    v13 = v8;
  }

  *a1 = v7;
  *(a1 + 8) = v13;
  *(a1 + 28) = v9 - v10;
  v16 = &v13[-(v9 - v10)];
  *a3 = *v7;
  *a5 = *v13;
  *a2 = *v16;
  *a4 = v16[1];
  return 1;
}

float32x2_t shape_enum_clip_alloc(uint64_t a1, uint64_t a2, int *a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  if (!a3)
  {
    return result;
  }

  v10 = a3;
  if (*a3 != 0x80000000)
  {
    return result;
  }

  v11 = a3[1];
  if (v11 < 1)
  {
    return result;
  }

  v18 = a9 < 1 || a10 < 1;
  if (a3 == &the_empty_shape)
  {
    v19 = 1;
    if (v18)
    {
LABEL_18:

      return shape_enum_allocate(a3, 2, a5);
    }
  }

  else
  {
    v19 = a3[v11] == 0x7FFFFFFF;
    if (v18)
    {
      goto LABEL_18;
    }
  }

  v20 = !v19;
  if (a6 < 1)
  {
    v20 = 1;
  }

  if ((v20 & 1) == 0)
  {
    goto LABEL_18;
  }

  if (v19)
  {
    if (a6 >= 0)
    {
      v22 = 3;
    }

    else
    {
      v22 = 4;
    }

    result = shape_enum_allocate(a3, v22, a5);
    *(v23 + 4) = 0;
    *(v23 + 12) = a7;
    *(v23 + 16) = a8;
    *(v23 + 20) = a9 + a7;
    *(v23 + 24) = a10 + a8;
    *(v23 + 32) = &the_empty_shape;
    *(v23 + 40) = &the_empty_shape;
  }

  else
  {
    if (a6)
    {
      v24 = 4;
    }

    else
    {
      v24 = 3;
    }

    if (a6 <= 0)
    {
      v25 = v24;
    }

    else
    {
      v25 = 2;
    }

    result = shape_enum_allocate(a3, v25, a5);
    *(*&v26 + 4) = a4;
    *(*&v26 + 12) = a7;
    *(*&v26 + 16) = a8;
    *(*&v26 + 20) = a9 + a7;
    *(*&v26 + 24) = a10 + a8;
    if (a5 < 0)
    {
      v27 = (*&v26 + 56);
      for (i = *v10; i != 0x7FFFFFFF; i = *v10)
      {
        v29 = v10[1];
        *v27++ = -v29;
        v10 += v29;
      }

      *(*&v26 + 40) = v10;
      if (a6 < 1)
      {
        *(*&v26 + 32) = v10;
      }

      else
      {
        *(*&v26 + 32) = v10 - 2;
        --v27;
      }

      *(*&v26 + 48) = v27;
    }

    else
    {
      *(*&v26 + 32) = v10;
      *(*&v26 + 40) = &v10[2 * (a6 > 0)];
    }
  }

  return result;
}

uint64_t shape_enum_clip_next(uint64_t a1, int *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  v5 = *(a1 + 32);
  if (!v5)
  {
    return 0;
  }

  v6 = *(a1 + 4);
  v7 = *(a1 + 8);
  v8 = *a1;
  v10 = *(a1 + 40);
  v9 = *(a1 + 48);
  if (*a1 != 2)
  {
    if (v8 < 3)
    {
      return 0;
    }

    v27 = *(a1 + 48);
    if (v7)
    {
      goto LABEL_42;
    }

    while (1)
    {
      if (v9)
      {
        v29 = *(v27 - 4);
        v27 -= 4;
        *(a1 + 40) = v5;
        *(a1 + 48) = v27;
        v10 = &v5[4 * v29];
        if (*v10 == 0x80000000)
        {
          v30 = 0;
        }

        else
        {
          v30 = v10;
        }
      }

      else
      {
        v30 = 0;
        v5 = &v10[4 * *(v10 + 1)];
        *(a1 + 32) = v10;
        *(a1 + 40) = v5;
        if (*v5 != 0x7FFFFFFF)
        {
          goto LABEL_39;
        }
      }

      *(a1 + 32) = v30;
LABEL_39:
      v31 = v5;
      v32 = (v5 - v10) >> 2;
      v7 = v32 - 1;
      if (v32 == 2)
      {
        v7 = 0;
      }

      v5 = v10;
      v10 = v31;
LABEL_42:
      v33 = *(a1 + 16);
      v34 = *v10;
      v35 = *(a1 + 24);
      v36 = *v5;
      if (v9)
      {
        if (v36 < v35)
        {
          if (v34 > v33)
          {
            goto LABEL_48;
          }

          return 0;
        }
      }

      else if (v34 > v33)
      {
        if (v36 < v35)
        {
LABEL_48:
          if (v34 >= v35)
          {
            v34 = *(a1 + 24);
          }

          if (v36 <= v33)
          {
            v36 = *(a1 + 16);
          }

          *a5 = v34 - v36;
          v37 = v35 - v34;
          v38 = v36 - v33;
          if (v9)
          {
            v38 = v37;
          }

          *a3 = v38;
          v22 = *(a1 + 12);
          v25 = *(a1 + 20);
          if (!v7 || *(v5 + 2) >= v25 || *(v10 - 1) <= v22)
          {
            *(a1 + 8) = 0;
            *a2 = 0;
            *a4 = v25 - v22;
            return 0xFFFFFFFFLL;
          }

          v39 = &v5[4 * v7];
          v40 = &v10[-4 * v7--];
LABEL_58:
          if (v6 >= 0)
          {
            v41 = v40;
          }

          else
          {
            v41 = v39;
          }

          if (v41 == (v5 + 4))
          {
            v23 = v41[1];
            v24 = -2147483647;
          }

          else if (v41 == (v10 - 4))
          {
            v24 = *v41;
            v23 = 2147483646;
          }

          else
          {
            v42 = v41;
            v24 = *v41;
            v23 = v42[1];
          }

          if (v6 < 1)
          {
            if (v24 < v25)
            {
              if (v23 <= v22)
              {
                continue;
              }

              goto LABEL_72;
            }
          }

          else if (v23 > v22)
          {
            if (v24 >= v25)
            {
              continue;
            }

LABEL_72:
            if ((v7 & 1) == 0 || v8 != 4)
            {
              if (v7)
              {
                v26 = 254;
              }

              else
              {
                v26 = 0xFFFFFFFFLL;
              }

              goto LABEL_78;
            }
          }

          --v7;
          --v39;
          ++v40;
          goto LABEL_58;
        }

        return 0;
      }
    }
  }

  v11 = *(a1 + 48);
  while (1)
  {
    if (!v7)
    {
      while (1)
      {
        if (v9)
        {
          v12 = *(v11 - 4);
          v11 -= 4;
          *(a1 + 40) = v5;
          *(a1 + 48) = v11;
          v13 = &v5[4 * v12];
          *(a1 + 32) = v13;
          if (*v13 == 0x80000000)
          {
            goto LABEL_30;
          }

          v10 = v5;
        }

        else
        {
          *(a1 + 32) = v10;
          v13 = v10;
          v10 += 4 * *(v10 + 1);
          *(a1 + 40) = v10;
          if (*v10 == 0x7FFFFFFF)
          {
LABEL_30:
            v26 = 0;
            *(a1 + 32) = 0;
            return v26;
          }
        }

        v5 = v13;
        v7 = ((v10 - v13) >> 2) - 2;
        if (((v10 - v13) >> 2) != 2)
        {
          v5 = v13;
          break;
        }
      }
    }

    v14 = *(a1 + 16);
    v15 = *v10;
    v16 = *(a1 + 24);
    v17 = *v5;
    v18 = &v10[-4 * v7];
    if (v6 <= 0)
    {
      v18 = &v5[4 * v7];
    }

    v7 -= 2;
    if (v15 > v14 && v17 < v16)
    {
      if (v15 >= v16)
      {
        v15 = *(a1 + 24);
      }

      if (v17 <= v14)
      {
        v17 = *(a1 + 16);
      }

      *a5 = v15 - v17;
      v20 = v16 - v15;
      v21 = v17 - v14;
      if (v9)
      {
        v21 = v20;
      }

      *a3 = v21;
      v22 = *(a1 + 12);
      v23 = v18[1];
      if (v23 > v22)
      {
        v24 = *v18;
        v25 = *(a1 + 20);
        if (v24 < v25)
        {
          break;
        }
      }
    }
  }

  v26 = 2;
LABEL_78:
  if (v23 >= v25)
  {
    v43 = v25;
  }

  else
  {
    v43 = v23;
  }

  if (v24 <= v22)
  {
    v44 = v22;
  }

  else
  {
    v44 = v24;
  }

  *a4 = v43 - v44;
  v45 = v25 - v43;
  v46 = v44 - v22;
  if (v6 >= 0)
  {
    v47 = v46;
  }

  else
  {
    v47 = v45;
  }

  *a2 = v47;
  *(a1 + 8) = v7;
  return v26;
}

uint64_t shape_enum_clip_scan(uint64_t a1, _DWORD *a2)
{
  v2 = *(a1 + 32);
  if (*a1 < 2 || v2 == 0)
  {
    return 0;
  }

  v5 = a1;
  v7 = *(a1 + 40);
  v6 = *(a1 + 48);
  v38 = (a2 + 4);
  v35 = a2;
  v34 = v6;
  while (v6)
  {
    v8 = *(v5 + 48);
    v9 = *(v8 - 4);
    *(v5 + 40) = v2;
    *(v5 + 48) = v8 - 4;
    v10 = &v2[v9];
    *(v5 + 32) = v10;
    v7 = v2;
    if (*v10 == 0x80000000)
    {
      goto LABEL_53;
    }

LABEL_11:
    v11 = v10 + 2;
    v2 = v10;
    if (v10 + 2 != v7)
    {
      v12 = *(v5 + 16);
      v13 = *(v5 + 24);
      v14 = *v10;
      v15 = *v7 > v12 && v14 < v13;
      v2 = v10;
      if (v15)
      {
        if (*v7 >= v13)
        {
          v16 = *(v5 + 24);
        }

        else
        {
          v16 = *v7;
        }

        if (v14 <= v12)
        {
          v17 = *(v5 + 16);
        }

        else
        {
          v17 = *v10;
        }

        v18 = v16 - v17;
        v19 = v16 - v13;
        v20 = v17 - v12;
        if (!v6)
        {
          v19 = v20;
        }

        *a2 = v19;
        a2[1] = v18;
        v2 = v10;
        if (v11 < v7)
        {
          v21 = *(v5 + 12);
          v22 = *(v5 + 20);
          v37 = v10;
          v23 = -1;
          v39 = -1;
          do
          {
            v24 = *v11;
            v25 = v11[1];
            if (v25 > v21 && v24 < v22)
            {
              v27 = v25 >= v22 ? v22 : v11[1];
              v28 = v24 <= v21 ? v21 : *v11;
              v29 = v27 - v28;
              if (v27 != v28)
              {
                v30 = v39;
                if (v39 < 0)
                {
                  bzero(v38, v22 - v21);
                  v30 = v28;
                }

                v39 = v30;
                v31 = &v38[v28 - v21];
                do
                {
                  if ((v31 & 3) == 0)
                  {
                    if (v29 >= 4)
                    {
                      v32 = v29 - 7;
                      if (v29 < 7)
                      {
                        v32 = 0;
                      }

                      v33 = (v32 + 3) & 0x7FFFFFFC;
                      memset(v31, 255, v33 + 4);
                      v29 = v29 - v33 - 4;
                      v31 += v33 + 4;
                    }

                    if (!v29)
                    {
                      break;
                    }
                  }

                  *v31++ = -1;
                  --v29;
                }

                while (v29);
                v23 = v27;
              }
            }

            v11 += 2;
          }

          while (v11 < v7);
          v5 = a1;
          v2 = v37;
          v6 = v34;
          a2 = v35;
          if ((v39 & 0x80000000) == 0)
          {
            v35[2] = v39 - v21;
            v35[3] = v23 - v39;
            return 1;
          }
        }
      }
    }
  }

  *(v5 + 32) = v7;
  v10 = v7;
  v7 += v7[1];
  *(v5 + 40) = v7;
  if (*v7 != 0x7FFFFFFF)
  {
    goto LABEL_11;
  }

LABEL_53:
  result = 0;
  *(v5 + 32) = 0;
  return result;
}

uint64_t img_decode_read_alpha(uint64_t a1, int a2, uint64_t a3, int16x4_t **a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  v12 = img_decode_read(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  if (v12 < 1)
  {
    return 0;
  }

  v15 = v12;
  v16 = *(a1 + 40);
  if (v16 == 16)
  {
    v17 = 2;
  }

  else
  {
    v17 = 1;
  }

  if (v16 == 32)
  {
    v18 = 4;
  }

  else
  {
    v18 = v17;
  }

  if (*(a1 + 208) == 5)
  {
    v19 = 5;
  }

  else
  {
    v19 = v18;
  }

  v20 = *(a1 + 44);
  if (v20 == 9)
  {
    v21 = 8;
  }

  else
  {
    v21 = *(a1 + 44);
  }

  if (v20 == 4)
  {
    v22 = 2;
  }

  else
  {
    v22 = v21;
  }

  if (v20 == 3)
  {
    v23 = 1;
  }

  else
  {
    v23 = v22;
  }

  img_alpha(*(a1 + 48), v12, *(a1 + 36), v23, a4, a5, v20, a4, v13, v14, a5, v19);
  v26 = *(a1 + 168);
  if (v26)
  {
    decode_data(v26, *(a1 + 48), v15, *a4, *a5, *a4, *a5, a4[1], v24, v25, a5[1]);
  }

  v27 = *(a1 + 176);
  if (v27)
  {
    decode_data(v27, *(a1 + 48), v15, a4[1], a5[1], a4[1], a5[1], 0, v24, v25, 0);
  }

  return v15;
}

void img_alpha(int a1, int a2, uint64_t a3, int a4, short float **a5, int *a6, uint64_t a7, uint64_t a8, float _S0, float _S1, int *a11, int a12)
{
  v17 = a3;
  v18 = a1;
  v19 = a4 - 1;
  v349 = a2;
  if ((a4 - 1) > 7)
  {
    v21 = 0;
    v20 = -1;
  }

  else
  {
    v20 = dword_1844E0C18[v19];
    v21 = dword_1844E0C38[v19];
  }

  v22 = a7 - 1;
  if ((a7 - 1) > 7)
  {
    v24 = 0;
    v23 = 0xFFFFFFFFLL;
  }

  else
  {
    v23 = dword_1844E0C18[v22];
    v24 = dword_1844E0C38[v22];
  }

  if (v24 == v21 && *a5 == *a8 && *a6 == *a11 && a5[1] == *(a8 + 8) && a6[1] == a11[1])
  {
    if (v20 + v23)
    {
      return;
    }
  }

  else if (v23 + v20)
  {
    v23 = 0;
  }

  else
  {
    v23 = v23;
  }

  if (a12 > 3)
  {
    if (a12 != 4)
    {
      if (a12 != 5)
      {
LABEL_522:
        _CGHandleAssert("img_alpha", 159, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "0", "unhandled component type %d", a6, a7, v21, a12);
      }

      if (v24 != v21)
      {
        convert_alpha_float16_interleved(v23, a1, a2, a3, *a5, a5[1], *a6, a6[1], _S0, _S1, v21, *a8, *(a8 + 8), *a11, a11[1], v24);
        return;
      }

      if (v21)
      {
        v30 = *a5;
        v31 = a5[1];
        v32 = *a6;
        v33 = a6[1];
        if (*a5 == v31)
        {
          v34 = *a8;
          if (v32 == v33)
          {
            if (v34 == *(a8 + 8))
            {
              v212 = *a11;
              if (*a11 == a11[1])
              {

                convert_alpha_float16_meshed(v23, a1, a2, a3, v30, v32, v34, v212, _S0, _S1, v21);
                return;
              }
            }

            v33 = *a6;
          }
        }

        else
        {
          v34 = *a8;
        }

        convert_alpha_float16_interleved(v23, a1, a2, a3, v30, v31, v32, v33, _S0, _S1, v21, v34, *(a8 + 8), *a11, a11[1], v21);
        return;
      }

      v343 = a6[1] - 2 * a1;
      v345 = *a6 - 2 * a3 * a1;
      v335 = a11[1] - 2 * a1;
      v339 = *a11 - 2 * a3 * a1;
      v195 = *a5;
      v196 = a5[1];
      v197 = *a8;
      v198 = *(a8 + 8);
      if (a3 != 3)
      {
        v199 = a3 - 1;
        if (a3 != 1)
        {
          v317 = 2 * a3;
          do
          {
            if (v18 >= 1)
            {
              do
              {
                v318 = *v196++;
                *v198++ = v318;
                __asm { FCMP            H1, #0 }

                if (_ZF)
                {
                  if (v17 >= 1)
                  {
                    bzero(v197, 2 * v17);
                  }
                }

                else
                {
                  *&_S0 = v195[v199];
                  if (!v23 || _H1 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                  {
                    if (v17 < 2)
                    {
                      _S1 = _S0;
                    }

                    else
                    {
                      v324 = (v17 - 1);
                      do
                      {
                        *&_S1 = v195[v324 - 1];
                        *&v197[2 * v324] = LOWORD(_S0);
                        _S0 = _S1;
                        v299 = v324-- <= 1;
                      }

                      while (!v299);
                    }

                    *v197 = LOWORD(_S1);
                  }

                  else
                  {
                    __asm
                    {
                      FCVT            S1, H1
                      FCVT            S0, H0
                    }

                    if (v23 < 1)
                    {
                      _S1 = 1.0 / _S1;
                      if (v17 > 1)
                      {
                        v325 = (v17 - 1);
                        do
                        {
                          _S2 = _S1 * _S0;
                          _H0 = v195[v325 - 1];
                          __asm
                          {
                            FCVT            S0, H0
                            FCVT            H2, S2
                          }

                          *&v197[2 * v325] = LOWORD(_S2);
                          v299 = v325-- <= 1;
                        }

                        while (!v299);
                      }

                      _S0 = _S1 * _S0;
                    }

                    else
                    {
                      if (v17 >= 2)
                      {
                        v321 = (v17 - 1);
                        do
                        {
                          _S2 = _S0 * _S1;
                          _H0 = v195[v321 - 1];
                          __asm
                          {
                            FCVT            S0, H0
                            FCVT            H2, S2
                          }

                          *&v197[2 * v321] = LOWORD(_S2);
                          v299 = v321-- <= 1;
                        }

                        while (!v299);
                      }

                      _S0 = _S0 * _S1;
                    }

                    __asm { FCVT            H0, S0 }

                    *v197 = _H0;
                  }
                }

                v195 = (v195 + v317);
                v197 += v317;
                v299 = v18-- <= 1;
              }

              while (!v299);
            }

            v18 = a1;
            v195 = (v195 + v345);
            v196 = (v196 + v343);
            v197 += v339;
            v198 = (v198 + v335);
            v299 = v349-- <= 1;
          }

          while (!v299);
          return;
        }

        while (a1 < 1)
        {
          v201 = v349;
LABEL_287:
          v195 = (v195 + v345);
          v196 = (v196 + v343);
          v197 += v339;
          v198 = (v198 + v335);
          v349 = v201 - 1;
          if (v201 == 1)
          {
            return;
          }
        }

        v200 = a1 + 1;
        v201 = v349;
        while (1)
        {
          v202 = *v196++;
          *v198++ = v202;
          if (v202 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
          {
            LOWORD(_H3) = 0;
            __asm { FCMP            H2, #0 }

            if (_ZF)
            {
              goto LABEL_280;
            }

            if (v23)
            {
              if (v23 < 1)
              {
                __asm { FCVT            S2, H2 }

                _H3 = *v195;
                __asm { FCVT            S3, H3 }

                _S2 = (1.0 / _S2) * _S3;
                __asm { FCVT            H3, S2 }
              }

              else
              {
                _H3 = _H2 * *v195;
              }

              goto LABEL_280;
            }
          }

          _H3 = *v195;
LABEL_280:
          *v197 = _H3;
          v197 += 2;
          ++v195;
          if (--v200 <= 1)
          {
            goto LABEL_287;
          }
        }
      }

      while (a1 < 1)
      {
        v277 = v349;
LABEL_411:
        v195 = (v195 + v345);
        v196 = (v196 + v343);
        v197 += v339;
        v198 = (v198 + v335);
        v349 = v277 - 1;
        if (v277 == 1)
        {
          return;
        }
      }

      v276 = a1 + 1;
      v277 = v349;
      while (1)
      {
        v278 = *v196++;
        *v198++ = v278;
        if (v278 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
        {
          __asm { FCMP            H2, #0 }

          if (_ZF)
          {
            *v197 = 0;
            LOWORD(_H2) = 0;
            goto LABEL_404;
          }

          if (v23)
          {
            if (v23 < 1)
            {
              __asm { FCVT            S2, H2 }

              v283 = 1.0 / _S2;
              _H3 = *v195;
              __asm { FCVT            S3, H3 }

              _H4 = *(v195 + 1);
              __asm { FCVT            S4, H4 }

              _S3 = v283 * _S3;
              _S4 = v283 * _S4;
              __asm { FCVT            H3, S3 }

              *v197 = LOWORD(_S3);
              __asm { FCVT            H3, S4 }

              *(v197 + 1) = LOWORD(_S3);
              *&_S3 = v195[2];
              __asm { FCVT            S3, H3 }

              _S2 = v283 * _S3;
              __asm { FCVT            H2, S2 }
            }

            else
            {
              v281 = v195[1];
              *v197 = _H2 * *v195;
              *(v197 + 1) = _H2 * v281;
              _H2 = _H2 * v195[2];
            }

            goto LABEL_404;
          }
        }

        *v197 = *v195;
        _H2 = v195[2];
LABEL_404:
        *(v197 + 2) = _H2;
        v195 += 3;
        v197 += 6;
        if (--v276 <= 1)
        {
          goto LABEL_411;
        }
      }
    }

    if (v24 != v21)
    {
      CGSConvertAlphaFloatInterleved(v23, a1, a2, a3, *a5, a5[1], *a6, a6[1], v21, *a8, *(a8 + 8), *a11, a11[1], v24);
      return;
    }

    if (v21)
    {
      v40 = *a5;
      v41 = a5[1];
      v42 = *a6;
      v43 = a6[1];
      if (*a5 == v41)
      {
        v44 = *a8;
        if (v42 == v43)
        {
          if (v44 == *(a8 + 8))
          {
            v218 = *a11;
            if (*a11 == a11[1])
            {

              CGSConvertAlphaFloatMeshed(v23, a1, a2, a3, v40, v42, v44, v218, v21);
              return;
            }
          }

          v43 = *a6;
        }
      }

      else
      {
        v44 = *a8;
      }

      CGSConvertAlphaFloatInterleved(v23, a1, a2, a3, v40, v41, v42, v43, v21, v44, *(a8 + 8), *a11, a11[1], v21);
      return;
    }

    v337 = a6[1] - 4 * a1;
    v341 = *a6 - 4 * a3 * a1;
    v330 = a11[1] - 4 * a1;
    v333 = *a11 - 4 * a3 * a1;
    v162 = *a5;
    v163 = a5[1];
    v164 = *a8;
    v165 = *(a8 + 8);
    if (a3 != 3)
    {
      if (a3 != 1)
      {
        v346 = (a3 - 1);
        v292 = a3 - 1;
        v293 = 4 * a3;
        do
        {
          if (v18 >= 1)
          {
            do
            {
              v294 = *v163++;
              v295 = v294;
              *v165++ = v294;
              if (v294 == 0.0)
              {
                if (v17 >= 1)
                {
                  bzero(v164, 4 * v17);
                }
              }

              else
              {
                v296 = v162->f32[v292];
                if (!v23 || v295 == 1.0)
                {
                  if (v17 < 2)
                  {
                    v301 = v162->f32[v292];
                  }

                  else
                  {
                    v300 = v346;
                    do
                    {
                      v301 = v162->f32[v300 - 1];
                      *&v164[4 * v300] = v296;
                      v296 = v301;
                      v299 = v300-- <= 1;
                    }

                    while (!v299);
                  }

                  *v164 = v301;
                }

                else
                {
                  if (v23 < 1)
                  {
                    v295 = 1.0 / v295;
                    if (v17 > 1)
                    {
                      v302 = v346;
                      do
                      {
                        v303 = v295 * v296;
                        v296 = v162->f32[v302 - 1];
                        *&v164[4 * v302] = v303;
                        v299 = v302-- <= 1;
                      }

                      while (!v299);
                    }
                  }

                  else if (v17 >= 2)
                  {
                    v297 = v346;
                    do
                    {
                      v298 = v295 * v296;
                      v296 = v162->f32[v297 - 1];
                      *&v164[4 * v297] = v298;
                      v299 = v297-- <= 1;
                    }

                    while (!v299);
                  }

                  *v164 = v295 * v296;
                }
              }

              v162 = (v162 + v293);
              v164 += v293;
              v299 = v18-- <= 1;
            }

            while (!v299);
          }

          v18 = a1;
          v162 = (v162 + v341);
          v163 = (v163 + v337);
          v164 += v333;
          v165 = (v165 + v330);
          v299 = v349-- <= 1;
        }

        while (!v299);
        return;
      }

      while (a1 < 1)
      {
        v167 = v349;
LABEL_206:
        v162 = (v162 + v341);
        v163 = (v163 + v337);
        v164 += v333;
        v165 = (v165 + v330);
        v349 = v167 - 1;
        if (v167 == 1)
        {
          return;
        }
      }

      v166 = a1 + 1;
      v167 = v349;
      while (1)
      {
        v168 = *v163++;
        v169 = v168;
        *v165++ = v168;
        if (v168 != 1.0)
        {
          v170 = 0.0;
          if (v169 == 0.0)
          {
            goto LABEL_203;
          }

          if (v23)
          {
            if (v23 < 1)
            {
              v169 = 1.0 / v169;
            }

            v170 = v169 * v162->f32[0];
            goto LABEL_203;
          }
        }

        v170 = v162->f32[0];
LABEL_203:
        *v164 = v170;
        v164 += 4;
        v162 = (v162 + 4);
        if (--v166 <= 1)
        {
          goto LABEL_206;
        }
      }
    }

    while (a1 < 1)
    {
      v224 = v349;
LABEL_330:
      v162 = (v162 + v341);
      v163 = (v163 + v337);
      v164 += v333;
      v165 = (v165 + v330);
      v349 = v224 - 1;
      if (v224 == 1)
      {
        return;
      }
    }

    v223 = a1 + 1;
    v224 = v349;
    while (1)
    {
      v225 = *v163++;
      v226 = v225;
      *v165++ = v225;
      if (v225 != 1.0)
      {
        if (v226 == 0.0)
        {
          *v164 = 0;
          v227 = 0.0;
          goto LABEL_327;
        }

        if (v23)
        {
          if (v23 < 1)
          {
            v226 = 1.0 / v226;
          }

          *v164 = vmul_n_f32(*v162, v226);
          v227 = v226 * v162[1].f32[0];
          goto LABEL_327;
        }
      }

      *v164 = *v162;
      v227 = v162[1].f32[0];
LABEL_327:
      *(v164 + 2) = v227;
      v162 = (v162 + 12);
      v164 += 12;
      if (--v223 <= 1)
      {
        goto LABEL_330;
      }
    }
  }

  if (a12 == 1)
  {
    if (v24 != v21)
    {
      v45 = *a8;
      v46 = *(a8 + 8);
      if (a3 != 3 || v21)
      {
        v47 = *a11;
      }

      else
      {
        v47 = *a11;
        if (v45 == v46 && v47 == a11[1])
        {
          v48 = *a6 - (3 * a1);
          v49 = v47;
          v50 = a6[1] - v18;
          v51 = v24 < 1;
          v52 = *a5;
          v53 = a5[1];
          if (v24 >= 1)
          {
            v54 = 3;
          }

          else
          {
            v54 = 0;
          }

          v55 = 2;
          if (v24 < 1)
          {
            v55 = 3;
          }

          v56 = 1;
          if (v24 < 1)
          {
            v56 = 2;
          }

          v57 = v54 | 0xC;
          v58 = v49 - 4 * v18;
          do
          {
            v59 = v52 & 3;
            if (v59 > v18 || ((v53 + v52) & 3) != 0)
            {
              v59 = v18;
            }

            v60 = v349;
            if (v59 >= 1)
            {
              v61 = v59 + 1;
              do
              {
                v63 = *v53;
                v53 = (v53 + 1);
                v62 = v63;
                if (v63)
                {
                  if (v62 == 255 || !v23)
                  {
                    *&v45[v51] = *v52;
                    LOBYTE(v66) = *(v52 + 2);
                  }

                  else
                  {
                    if (v23 < 1)
                    {
                      v67 = inverted_8bit_alpha[v62];
                      v68 = *(v52 + 1) * v67;
                      v45[v51] = (*v52 * v67) >> 8;
                      v45[v56] = HIBYTE(v68);
                      v65 = *(v52 + 2) * v67;
                    }

                    else
                    {
                      v64 = *(v52 + 1) * v62 + ((*(v52 + 1) * v62) >> 8) + 1;
                      v45[v51] = (*v52 * v62 + ((*v52 * v62) >> 8) + 1) >> 8;
                      v45[v56] = BYTE1(v64);
                      v65 = *(v52 + 2) * v62 + ((*(v52 + 2) * v62) >> 8) + 1;
                    }

                    v66 = v65 >> 8;
                    v18 = a1;
                  }
                }

                else
                {
                  LOBYTE(v66) = 0;
                  *&v45[v51] = 0;
                }

                v45[v55] = v66;
                v52 = (v52 + 3);
                v45[v54] = v62;
                v45 += 4;
                --v61;
              }

              while (v61 > 1);
            }

            v69 = v18 - v59;
            v70 = v69 >> 2;
            if (v23)
            {
              if (v70 >= 1)
              {
                v71 = v70 + 1;
                do
                {
                  v73 = *v53;
                  v53 += 2;
                  v72 = v73;
                  if (v73)
                  {
                    if (v72 == -1)
                    {
                      v75 = *v52;
                      v74 = *(v52 + 1);
                      v76 = *(v52 + 2);
                      if (v24 < 1)
                      {
                        *v45 = (v75 << 8) | 0xFF;
                        *(v45 + 1) = (__PAIR64__(v74, v75) >> 16) | 0xFF;
                        *(v45 + 2) = (__PAIR64__(v76, v74) >> 8) | 0xFF;
                        *(v45 + 3) = v76 | 0xFF;
                      }

                      else
                      {
                        *v45 = v75 | 0xFF000000;
                        *(v45 + 1) = (__PAIR64__(v74, v75) >> 24) | 0xFF000000;
                        *(v45 + 2) = (__PAIR64__(v76, v74) >> 16) | 0xFF000000;
                        *(v45 + 3) = (v76 >> 8) | 0xFF000000;
                      }
                    }

                    else
                    {
                      LOBYTE(v77) = v72;
                      if ((v23 & 0x80000000) != 0)
                      {
                        if (v72)
                        {
                          if (v72 == 255)
                          {
                            *&v45[v51] = *v52;
                            LOBYTE(v77) = *(v52 + 2);
                          }

                          else
                          {
                            v90 = inverted_8bit_alpha[v72];
                            v91 = *(v52 + 1) * v90;
                            v92 = &v45[v51];
                            *v92 = (*v52 * v90) >> 8;
                            v92[1] = HIBYTE(v91);
                            v77 = (*(v52 + 2) * v90) >> 8;
                          }
                        }

                        else
                        {
                          *&v45[v51] = 0;
                        }

                        v45[v51 + 2] = v77;
                        v45[v57 - 12] = v72;
                        LOBYTE(v77) = BYTE1(v72);
                        if (BYTE1(v72))
                        {
                          if (BYTE1(v72) == 255)
                          {
                            *&v45[v51 + 4] = *(v52 + 3);
                            LOBYTE(v77) = *(v52 + 5);
                          }

                          else
                          {
                            v93 = inverted_8bit_alpha[BYTE1(v72)];
                            v94 = *(v52 + 4) * v93;
                            v95 = &v45[v51];
                            v95[4] = (*(v52 + 3) * v93) >> 8;
                            v95[5] = HIBYTE(v94);
                            v77 = (*(v52 + 5) * v93) >> 8;
                          }
                        }

                        else
                        {
                          *&v45[v51 + 4] = 0;
                        }

                        v45[v51 + 6] = v77;
                        v45[v57 - 8] = BYTE1(v72);
                        LOBYTE(v96) = BYTE2(v72);
                        if (BYTE2(v72))
                        {
                          if (BYTE2(v72) == 255)
                          {
                            *&v45[v51 + 8] = v52[3];
                            LOBYTE(v96) = *(v52 + 8);
                          }

                          else
                          {
                            v97 = inverted_8bit_alpha[BYTE2(v72)];
                            v98 = *(v52 + 7) * v97;
                            v99 = &v45[v51];
                            v99[8] = (*(v52 + 6) * v97) >> 8;
                            v99[9] = HIBYTE(v98);
                            v96 = (*(v52 + 8) * v97) >> 8;
                          }
                        }

                        else
                        {
                          *&v45[v51 + 8] = 0;
                        }

                        v45[v51 + 10] = v96;
                        v45[v57 - 4] = BYTE2(v72);
                        if ((v72 >> 24) == 255)
                        {
                          *&v45[v51 + 12] = *(v52 + 9);
                          LOBYTE(v87) = *(v52 + 11);
                        }

                        else if (BYTE3(v72))
                        {
                          v100 = inverted_8bit_alpha[v72 >> 24];
                          v101 = *(v52 + 10) * v100;
                          v102 = &v45[v51];
                          v102[12] = (*(v52 + 9) * v100) >> 8;
                          v102[13] = HIBYTE(v101);
                          v87 = (*(v52 + 11) * v100) >> 8;
                        }

                        else
                        {
                          LOBYTE(v87) = 0;
                          *&v45[v51 + 12] = 0;
                        }

                        LOBYTE(v72) = BYTE3(v72);
                      }

                      else
                      {
                        if (v72)
                        {
                          if (v72 == 255)
                          {
                            *&v45[v51] = *v52;
                            LOBYTE(v77) = *(v52 + 2);
                          }

                          else
                          {
                            v78 = v72 * *(v52 + 1);
                            v79 = &v45[v51];
                            *v79 = (v72 * *v52 + ((v72 * *v52) >> 8) + 1) >> 8;
                            v79[1] = (v78 + (v78 >> 8) + 1) >> 8;
                            v77 = (v72 * *(v52 + 2) + ((v72 * *(v52 + 2)) >> 8) + 1) >> 8;
                          }
                        }

                        else
                        {
                          *&v45[v51] = 0;
                        }

                        v45[v51 + 2] = v77;
                        v45[v57 - 12] = v72;
                        LOBYTE(v77) = BYTE1(v72);
                        if (BYTE1(v72))
                        {
                          if (BYTE1(v72) == 255)
                          {
                            *&v45[v51 + 4] = *(v52 + 3);
                            LOBYTE(v77) = *(v52 + 5);
                          }

                          else
                          {
                            v80 = BYTE1(v72) * *(v52 + 3);
                            v81 = BYTE1(v72) * *(v52 + 4);
                            v82 = &v45[v51];
                            v82[4] = (v80 + (v80 >> 8) + 1) >> 8;
                            v82[5] = (v81 + (v81 >> 8) + 1) >> 8;
                            v77 = (BYTE1(v72) * *(v52 + 5) + ((BYTE1(v72) * *(v52 + 5)) >> 8) + 1) >> 8;
                          }
                        }

                        else
                        {
                          *&v45[v51 + 4] = 0;
                        }

                        v45[v51 + 6] = v77;
                        v45[v57 - 8] = BYTE1(v72);
                        LOBYTE(v83) = BYTE2(v72);
                        if (BYTE2(v72))
                        {
                          if (BYTE2(v72) == 255)
                          {
                            *&v45[v51 + 8] = v52[3];
                            LOBYTE(v83) = *(v52 + 8);
                          }

                          else
                          {
                            v84 = BYTE2(v72) * *(v52 + 6);
                            v85 = BYTE2(v72) * *(v52 + 7);
                            v86 = &v45[v51];
                            v86[8] = (v84 + (v84 >> 8) + 1) >> 8;
                            v86[9] = (v85 + (v85 >> 8) + 1) >> 8;
                            v83 = (BYTE2(v72) * *(v52 + 8) + ((BYTE2(v72) * *(v52 + 8)) >> 8) + 1) >> 8;
                          }
                        }

                        else
                        {
                          *&v45[v51 + 8] = 0;
                        }

                        v45[v51 + 10] = v83;
                        v45[v57 - 4] = BYTE2(v72);
                        LODWORD(v72) = BYTE3(v72);
                        if (v72 == 255)
                        {
                          *&v45[v51 + 12] = *(v52 + 9);
                          LOBYTE(v87) = *(v52 + 11);
                        }

                        else if (v72)
                        {
                          v88 = v72 * *(v52 + 10) + ((v72 * *(v52 + 10)) >> 8) + 1;
                          v89 = &v45[v51];
                          v89[12] = (v72 * *(v52 + 9) + ((v72 * *(v52 + 9)) >> 8) + 1) >> 8;
                          v89[13] = BYTE1(v88);
                          v87 = (v72 * *(v52 + 11) + ((v72 * *(v52 + 11)) >> 8) + 1) >> 8;
                        }

                        else
                        {
                          LOBYTE(v87) = 0;
                          *&v45[v51 + 12] = 0;
                        }
                      }

                      v45[v51 + 14] = v87;
                      v45[v57] = v72;
                    }

                    v18 = a1;
                  }

                  else
                  {
                    *v45 = 0;
                    *(v45 + 1) = 0;
                  }

                  v52 += 6;
                  v45 += 16;
                  --v71;
                }

                while (v71 > 1);
              }
            }

            else if (v70 >= 1)
            {
              v103 = v70 + 1;
              do
              {
                v104 = v52;
                v106 = *v53;
                v53 += 2;
                v105 = v106;
                v107 = *v104;
                v108 = *(v104 + 2);
                v13.i32[0] = v106;
                v12.i32[0] = *v104;
                v109 = v108.u32[1];
                if (v24 < 1)
                {
                  v12.i32[1] = v105;
                  v12 = vand_s8(vshr_n_u32(v12, 0x10uLL), 0xFF0000FF00);
                  v13 = vand_s8(vshr_n_u32(vzip1_s32(v13, v108), 8uLL), 0xFFFF00000000FFLL);
                  v111 = vorr_s8(v12, vorr_s8(v13, vshl_u32(v108, 0x1800000010)));
                  v110 = v105 | (v107 << 8);
                  v112 = v109 & 0xFFFFFF00 | HIBYTE(v105);
                }

                else
                {
                  v110 = v107 & 0xFFFFFF | (v105 << 24);
                  v12 = vshl_u32(vzip1_s32(v12, v108), 0xFFFFFFF0FFFFFFE8);
                  v13 = vand_s8(vshl_u32(vdup_lane_s32(v13, 0), 0x800000010), 0xFF000000FF000000);
                  v111 = vorr_s8(v13, vorr_s8(v12, vand_s8(vshl_u32(v108, 0x1000000008), 0xFF000000FFFF00)));
                  v112 = v105 & 0xFF000000 | (v109 >> 8);
                }

                *v45 = v110;
                *(v45 + 4) = v111;
                *(v45 + 3) = v112;
                v45 += 16;
                --v103;
                v52 = v104 + 6;
              }

              while (v103 > 1);
              v52 = v104 + 6;
              v18 = a1;
            }

            v113 = v69 & 3;
            if (v113)
            {
              v114 = v113 + 1;
              do
              {
                v116 = *v53;
                v53 = (v53 + 1);
                v115 = v116;
                if (v116)
                {
                  if (v115 == 255 || !v23)
                  {
                    *&v45[v51] = *v52;
                    LOBYTE(v119) = *(v52 + 2);
                  }

                  else
                  {
                    if (v23 < 1)
                    {
                      v120 = inverted_8bit_alpha[v115];
                      v121 = *(v52 + 1) * v120;
                      v45[v51] = (*v52 * v120) >> 8;
                      v122 = v121 >> 8;
                      v18 = a1;
                      v45[v56] = v122;
                      v118 = *(v52 + 2) * v120;
                    }

                    else
                    {
                      v117 = *(v52 + 1) * v115 + ((*(v52 + 1) * v115) >> 8) + 1;
                      v45[v51] = (*v52 * v115 + ((*v52 * v115) >> 8) + 1) >> 8;
                      v45[v56] = BYTE1(v117);
                      v118 = *(v52 + 2) * v115 + ((*(v52 + 2) * v115) >> 8) + 1;
                    }

                    v119 = v118 >> 8;
                  }
                }

                else
                {
                  LOBYTE(v119) = 0;
                  *&v45[v51] = 0;
                }

                v45[v55] = v119;
                v52 = (v52 + 3);
                v45[v54] = v115;
                v45 += 4;
                --v114;
              }

              while (v114 > 1);
            }

            v52 = (v52 + v48);
            v53 = (v53 + v50);
            v45 += v58;
            --v349;
          }

          while (v60 > 1);
          return;
        }
      }

      CGSConvertAlphaByteInterleved(v23, a1, a2, a3, *a5, a5[1], *a6, a6[1], v21, v45, v46, v47, a11[1], v24);
      return;
    }

    v35 = a6[1];
    if (v21)
    {
      v36 = *a5;
      v37 = a5[1];
      v38 = *a6;
      if (*a5 == v37)
      {
        v39 = *a8;
        if (v38 == v35)
        {
          if (v39 == *(a8 + 8))
          {
            v213 = *a11;
            if (*a11 == a11[1])
            {
              if (a3 == 3)
              {
                v214 = *a5;
                v215 = *a6;
                v216 = *a8;
                v217 = *a11;

                CGSConvertAlphaByteMeshedXXXX(v23, a1, a2, v214, v215, v216, v217, v21);
              }

              else
              {
                v329 = *a6;

                CGSConvertAlphaByteMeshed(v23, a1, a2, a3, a5, v329, a8, v213, v21);
              }

              return;
            }
          }

          v35 = *a6;
        }
      }

      else
      {
        v39 = *a8;
      }

      CGSConvertAlphaByteInterleved(v23, a1, a2, a3, v36, v37, v38, v35, v21, v39, *(a8 + 8), *a11, a11[1], v21);
      return;
    }

    v344 = a3 * a1;
    v124 = *a5;
    v123 = a5[1];
    v125 = *a8;
    v336 = *a11;
    v340 = *a6;
    v332 = a6[1];
    CGBlt_copyBytes(a1, a2, v123, *(a8 + 8), v35, a11[1]);
    if (!v23)
    {
      v219 = *a5;
      v220 = *a8;
      v221 = *a6;
      v222 = *a11;

      CGBlt_copyBytes(v344, a2, v219, v220, v221, v222);
      return;
    }

    v127 = v349;
    _ZF = a1 > 3 && v17 == 1;
    v129 = _ZF;
    while (1)
    {
      if (v17 == 3)
      {
        v130 = v127;
        if (a1 >= 4)
        {
          v131 = 0;
          v132 = a1;
          do
          {
            v133 = v132;
            v134 = &v125[v131 * 2];
            if (*v123 == -1)
            {
              v148 = *&v124[v131];
              *(v134 + 2) = *&v124[v131 + 4];
              *v134 = v148;
            }

            else if (*v123)
            {
              v135 = &v124[v131];
              v136 = LOBYTE(v124[v131]);
              v137 = &v125[v131 * 2];
              if (v23 == 1)
              {
                *v137 = (*v123 * v136 + ((*v123 * v136) >> 8) + 1) >> 8;
                v138 = *v123 * v135[1];
                v137[1] = (v138 + (v138 >> 8) + 1) >> 8;
                v139 = *v123 * v135[2];
                v137[2] = (v139 + (v139 >> 8) + 1) >> 8;
                v140 = v123[1] * v135[3];
                v137[3] = (v140 + (v140 >> 8) + 1) >> 8;
                v141 = v123[1] * v135[4];
                v137[4] = (v141 + (v141 >> 8) + 1) >> 8;
                v142 = v123[1] * v135[5];
                v137[5] = (v142 + (v142 >> 8) + 1) >> 8;
                v143 = v123[2] * v135[6];
                v137[6] = (v143 + (v143 >> 8) + 1) >> 8;
                v144 = v123[2] * v135[7];
                v137[7] = (v144 + (v144 >> 8) + 1) >> 8;
                v145 = v123[2] * v135[8];
                v137[8] = (v145 + (v145 >> 8) + 1) >> 8;
                v146 = v123[3] * v135[9];
                v137[9] = (v146 + (v146 >> 8) + 1) >> 8;
                v137[10] = (v123[3] * v135[10] + ((v123[3] * v135[10]) >> 8) + 1) >> 8;
                v147 = v123[3] * v135[11] + ((v123[3] * v135[11]) >> 8) + 1;
              }

              else
              {
                *v137 = (inverted_8bit_alpha[*v123] * v136) >> 8;
                v137[1] = (inverted_8bit_alpha[*v123] * v135[1]) >> 8;
                v137[2] = (inverted_8bit_alpha[*v123] * v135[2]) >> 8;
                v137[3] = (inverted_8bit_alpha[v123[1]] * v135[3]) >> 8;
                v137[4] = (inverted_8bit_alpha[v123[1]] * v135[4]) >> 8;
                v137[5] = (inverted_8bit_alpha[v123[1]] * v135[5]) >> 8;
                v137[6] = (inverted_8bit_alpha[v123[2]] * v135[6]) >> 8;
                v137[7] = (inverted_8bit_alpha[v123[2]] * v135[7]) >> 8;
                v137[8] = (inverted_8bit_alpha[v123[2]] * v135[8]) >> 8;
                v137[9] = (inverted_8bit_alpha[v123[3]] * v135[9]) >> 8;
                v137[10] = (inverted_8bit_alpha[v123[3]] * v135[10]) >> 8;
                LOWORD(v147) = inverted_8bit_alpha[v123[3]] * v135[11];
              }

              v137[11] = BYTE1(v147);
            }

            else
            {
              *(v134 + 2) = 0;
              *v134 = 0;
            }

            v132 = v133 - 4;
            v123 += 4;
            v131 += 6;
          }

          while (v133 > 7);
          v125 += v131 * 2;
          v124 = (v124 + v131 * 2);
          goto LABEL_179;
        }
      }

      else
      {
        v130 = v127;
        if (v129)
        {
          v149 = 0;
          v150 = a1 + 4;
          do
          {
            if (*&v123[v149] == -1)
            {
              *&v125[v149] = *&v124[v149 / 2];
            }

            else if (*&v123[v149])
            {
              v151 = &v124[v149 / 2];
              v152 = LOBYTE(v124[v149 / 2]);
              v153 = &v123[v149];
              v154 = &v125[v149];
              if (v23 == 1)
              {
                *v154 = (v123[v149] * v152 + ((v123[v149] * v152) >> 8) + 1) >> 8;
                v155 = v153[1] * v151[1];
                v154[1] = (v155 + (v155 >> 8) + 1) >> 8;
                v154[2] = (v153[2] * v151[2] + ((v153[2] * v151[2]) >> 8) + 1) >> 8;
                v156 = v153[3] * v151[3] + ((v153[3] * v151[3]) >> 8) + 1;
              }

              else
              {
                *v154 = (inverted_8bit_alpha[v123[v149]] * v152) >> 8;
                v154[1] = (inverted_8bit_alpha[v153[1]] * v151[1]) >> 8;
                v154[2] = (inverted_8bit_alpha[v153[2]] * v151[2]) >> 8;
                LOWORD(v156) = inverted_8bit_alpha[v153[3]] * v151[3];
              }

              v154[3] = BYTE1(v156);
            }

            else
            {
              *&v125[v149] = 0;
            }

            v150 -= 4;
            v149 += 4;
          }

          while (v150 > 7);
          v132 = a1 - v149;
          v124 = (v124 + v149);
          v125 += v149;
          v123 += v149;
          goto LABEL_179;
        }
      }

      v132 = a1;
LABEL_179:
      if (v132 >= 1)
      {
        do
        {
          v157 = *v123;
          if (v23 == 1)
          {
            if (v17 >= 1)
            {
              for (i = 0; i != v17; ++i)
              {
                v125[i] = (*(v124 + i) * v157 + ((*(v124 + i) * v157) >> 8) + 1) >> 8;
              }
            }
          }

          else if (v17 >= 1)
          {
            v159 = 0;
            v160 = inverted_8bit_alpha[v157];
            do
            {
              v125[v159] = (*(v124 + v159) * v160) >> 8;
              ++v159;
            }

            while (v17 != v159);
          }

          v124 = (v124 + v17);
          v125 += v17;
          ++v123;
          _VF = __OFSUB__(v132--, 1);
        }

        while (!((v132 < 0) ^ _VF | (v132 == 0)));
      }

      v127 = v130 - 1;
      v124 = (v124 + v340 - v344);
      v123 += v332 - a1;
      v125 += v336 - v344;
      if (v130 <= 1)
      {
        return;
      }
    }
  }

  if (a12 != 2)
  {
    goto LABEL_522;
  }

  if (v24 != v21)
  {
    CGSConvertAlphaWordInterleved(v23, a1, a2, a3, *a5, a5[1], *a6, a6[1], v21, *a8, *(a8 + 8), *a11, a11[1], v24);
    return;
  }

  if (v21)
  {
    v25 = *a5;
    v26 = a5[1];
    v27 = *a6;
    v28 = a6[1];
    if (*a5 == v26)
    {
      v29 = *a8;
      if (v27 == v28)
      {
        if (v29 == *(a8 + 8))
        {
          v211 = *a11;
          if (*a11 == a11[1])
          {

            CGSConvertAlphaWordMeshed(v23, a1, a2, a3, v25, v27, v29, v211, v21);
            return;
          }
        }

        v28 = *a6;
      }
    }

    else
    {
      v29 = *a8;
    }

    CGSConvertAlphaWordInterleved(v23, a1, a2, a3, v25, v26, v27, v28, v21, v29, *(a8 + 8), *a11, a11[1], v21);
    return;
  }

  v338 = a6[1] - 2 * a1;
  v342 = *a6 - 2 * a3 * a1;
  v331 = a11[1] - 2 * a1;
  v334 = *a11 - 2 * a3 * a1;
  v172 = *a5;
  v171 = a5[1];
  v173 = *a8;
  v174 = *(a8 + 8);
  if (a3 == 3)
  {
    v228 = a1 >> 2;
    v229 = a1 & 3;
    while (v228 < 1)
    {
LABEL_382:
      if (v229)
      {
        v266 = 0;
        v267 = v229 + 1;
        do
        {
          v269 = *v171++;
          v268 = v269;
          *v174++ = v269;
          if (v269)
          {
            if (v268 == 0xFFFF || !v23)
            {
              *&v173[v266 * 2] = *&v172[v266];
              *&v268 = v172[v266 + 2];
            }

            else
            {
              if (v23 < 1)
              {
                v273 = 0xFFFFFFFF / v268;
                v274 = v273 * LOWORD(v172[v266 + 1]);
                v275 = &v173[v266 * 2];
                *v275 = (v273 * LOWORD(v172[v266])) >> 16;
                *(v275 + 1) = HIWORD(v274);
                v272 = v273 * LOWORD(v172[v266 + 2]);
              }

              else
              {
                v270 = LOWORD(v172[v266 + 1]) * v268;
                v271 = &v173[v266 * 2];
                *v271 = (LOWORD(v172[v266]) * v268 + ((LOWORD(v172[v266]) * v268) >> 16) + 1) >> 16;
                *(v271 + 1) = (v270 + HIWORD(v270) + 1) >> 16;
                v272 = LOWORD(v172[v266 + 2]) * v268 + ((LOWORD(v172[v266 + 2]) * v268) >> 16) + 1;
              }

              v268 = HIWORD(v272);
            }
          }

          else
          {
            *&v173[v266 * 2] = 0;
          }

          *&v173[v266 * 2 + 4] = v268;
          --v267;
          v266 += 3;
        }

        while (v267 > 1);
        v172 = (v172 + v266 * 2);
        v173 += v266 * 2;
      }

      v172 = (v172 + v342);
      v171 = (v171 + v338);
      v173 += v334;
      v174 = (v174 + v331);
      if (!--v349)
      {
        return;
      }
    }

    v230 = 0;
    v231 = v228 + 1;
    while (1)
    {
      v232 = &v173[v230 * 2];
      v234 = *v171;
      v171 += 4;
      v233 = v234;
      *v174 = v234;
      v174 += 4;
      if (!v23 || v233 == 0xFFFFFFFF)
      {
        v239 = *&v172[v230 + 8];
        *v232 = *&v172[v230];
        *(v232 + 2) = v239;
      }

      else if (v233)
      {
        v235 = WORD1(v233);
        LOWORD(v236) = WORD2(v233);
        v237 = HIWORD(v233);
        if (v23 < 1)
        {
          if (v233)
          {
            if (v233 == 0xFFFF)
            {
              *v232 = *&v172[v230];
              *&v240 = v172[v230 + 2];
            }

            else
            {
              v254 = 0xFFFFFFFF / v233;
              v255 = v254 * LOWORD(v172[v230 + 1]);
              v256 = &v173[v230 * 2];
              *v256 = (v254 * LOWORD(v172[v230])) >> 16;
              *(v256 + 1) = HIWORD(v255);
              v240 = (v254 * LOWORD(v172[v230 + 2])) >> 16;
            }
          }

          else
          {
            LOWORD(v240) = 0;
            *v232 = 0;
          }

          *&v173[v230 * 2 + 4] = v240;
          if (v235 == 0xFFFF)
          {
            *&v173[v230 * 2 + 6] = *&v172[v230 + 3];
            *&v235 = v172[v230 + 5];
          }

          else if (v235)
          {
            v257 = 0xFFFFFFFF / v235;
            v258 = v257 * LOWORD(v172[v230 + 4]);
            v259 = &v173[v230 * 2];
            *(v259 + 3) = (v257 * LOWORD(v172[v230 + 3])) >> 16;
            *(v259 + 4) = HIWORD(v258);
            v235 = (v257 * LOWORD(v172[v230 + 5])) >> 16;
          }

          else
          {
            *&v173[v230 * 2 + 6] = 0;
          }

          *&v173[v230 * 2 + 10] = v235;
          if (WORD2(v233))
          {
            if (WORD2(v233) == 0xFFFF)
            {
              *&v173[v230 * 2 + 12] = *&v172[v230 + 6];
              *&v236 = v172[v230 + 8];
            }

            else
            {
              v260 = 0xFFFFFFFF / WORD2(v233);
              v261 = v260 * LOWORD(v172[v230 + 7]);
              v262 = &v173[v230 * 2];
              *(v262 + 6) = (v260 * LOWORD(v172[v230 + 6])) >> 16;
              *(v262 + 7) = HIWORD(v261);
              v236 = (v260 * LOWORD(v172[v230 + 8])) >> 16;
            }
          }

          else
          {
            *&v173[v230 * 2 + 12] = 0;
          }

          v249 = &v173[v230 * 2];
          *&v173[v230 * 2 + 16] = v236;
          if (v237 != 0xFFFF)
          {
            if (v237)
            {
              v264 = 0xFFFFFFFF / v237;
              v265 = v264 * LOWORD(v172[v230 + 10]);
              v252 = &v173[v230 * 2];
              *(v252 + 9) = (v264 * LOWORD(v172[v230 + 9])) >> 16;
              *(v252 + 10) = HIWORD(v265);
              v253 = v264 * LOWORD(v172[v230 + 11]);
              goto LABEL_379;
            }

            goto LABEL_377;
          }
        }

        else
        {
          if (v233)
          {
            if (v233 == 0xFFFF)
            {
              *v232 = *&v172[v230];
              *&v238 = v172[v230 + 2];
            }

            else
            {
              v241 = v233 * LOWORD(v172[v230 + 1]);
              v242 = &v173[v230 * 2];
              *v242 = (v233 * LOWORD(v172[v230]) + ((v233 * LOWORD(v172[v230])) >> 16) + 1) >> 16;
              *(v242 + 1) = (v241 + HIWORD(v241) + 1) >> 16;
              v243 = v233 * LOWORD(v172[v230 + 2]);
              v238 = (v243 + HIWORD(v243) + 1) >> 16;
            }
          }

          else
          {
            LOWORD(v238) = 0;
            *v232 = 0;
          }

          *&v173[v230 * 2 + 4] = v238;
          if (v235 == 0xFFFF)
          {
            *&v173[v230 * 2 + 6] = *&v172[v230 + 3];
            *&v235 = v172[v230 + 5];
          }

          else if (v235)
          {
            v244 = v235 * LOWORD(v172[v230 + 3]);
            v245 = v235 * LOWORD(v172[v230 + 4]);
            v246 = &v173[v230 * 2];
            *(v246 + 3) = (v244 + HIWORD(v244) + 1) >> 16;
            *(v246 + 4) = (v245 + HIWORD(v245) + 1) >> 16;
            v235 = (v235 * LOWORD(v172[v230 + 5]) + ((v235 * LOWORD(v172[v230 + 5])) >> 16) + 1) >> 16;
          }

          else
          {
            *&v173[v230 * 2 + 6] = 0;
          }

          *&v173[v230 * 2 + 10] = v235;
          if (WORD2(v233))
          {
            if (WORD2(v233) == 0xFFFF)
            {
              *&v173[v230 * 2 + 12] = *&v172[v230 + 6];
              *&v236 = v172[v230 + 8];
            }

            else
            {
              v247 = WORD2(v233) * LOWORD(v172[v230 + 6]);
              LODWORD(v233) = WORD2(v233) * LOWORD(v172[v230 + 7]);
              v248 = &v173[v230 * 2];
              *(v248 + 6) = (v247 + HIWORD(v247) + 1) >> 16;
              *(v248 + 7) = (v233 + WORD1(v233) + 1) >> 16;
              v236 = (WORD2(v233) * LOWORD(v172[v230 + 8]) + ((WORD2(v233) * LOWORD(v172[v230 + 8])) >> 16) + 1) >> 16;
            }
          }

          else
          {
            *&v173[v230 * 2 + 12] = 0;
          }

          v249 = &v173[v230 * 2];
          *&v173[v230 * 2 + 16] = v236;
          if (v237 != 0xFFFF)
          {
            if (v237)
            {
              v250 = LOWORD(v172[v230 + 9]) * v237;
              v251 = LOWORD(v172[v230 + 10]) * v237;
              v252 = &v173[v230 * 2];
              *(v252 + 9) = (v250 + HIWORD(v250) + 1) >> 16;
              *(v252 + 10) = (v251 + HIWORD(v251) + 1) >> 16;
              v253 = LOWORD(v172[v230 + 11]) * v237 + ((LOWORD(v172[v230 + 11]) * v237) >> 16) + 1;
LABEL_379:
              *(v252 + 11) = HIWORD(v253);
              goto LABEL_380;
            }

LABEL_377:
            v263 = &v173[v230 * 2];
            *(v263 + 18) = 0;
            *(v263 + 11) = 0;
            goto LABEL_380;
          }
        }

        *(v249 + 18) = *&v172[v230 + 9];
        *(v249 + 11) = v172[v230 + 11];
      }

      else
      {
        *v232 = 0;
        *(v232 + 1) = 0;
        *(v232 + 2) = 0;
      }

LABEL_380:
      --v231;
      v230 += 12;
      if (v231 <= 1)
      {
        v173 += v230 * 2;
        v172 = (v172 + v230 * 2);
        goto LABEL_382;
      }
    }
  }

  v175 = a3 - 1;
  if (a3 != 1)
  {
    v347 = 2 * a3;
    v304 = 2 * a3;
    while (v18 < 1)
    {
LABEL_476:
      v18 = a1;
      v172 = (v172 + v342);
      v171 = (v171 + v338);
      v173 += v334;
      v174 = (v174 + v331);
      v299 = v349-- <= 1;
      if (v299)
      {
        return;
      }
    }

    while (1)
    {
      v306 = *v171++;
      v305 = v306;
      *v174++ = v306;
      if (v306 == 0xFFFF)
      {
        *&v307 = v172[v175];
        if (v17 >= 2)
        {
          v308 = (v17 - 1);
          do
          {
            v309 = v172[v308 - 1];
            *&v173[2 * v308] = v307;
            *&v307 = v309;
            v299 = v308-- <= 1;
          }

          while (!v299);
          goto LABEL_467;
        }
      }

      else
      {
        if (!v305)
        {
          if (v17 >= 1)
          {
            bzero(v173, v347);
          }

          goto LABEL_474;
        }

        v307 = LOWORD(v172[v175]);
        if (v23)
        {
          if (v23 < 1)
          {
            v314 = 0xFFFFFFFF / v305;
            if (v17 > 1)
            {
              v315 = (v17 - 1);
              do
              {
                v316 = v307 * v314;
                v307 = LOWORD(v172[v315 - 1]);
                *&v173[2 * v315] = HIWORD(v316);
                v299 = v315-- <= 1;
              }

              while (!v299);
            }

            v312 = v307 * v314;
          }

          else
          {
            if (v17 >= 2)
            {
              v310 = (v17 - 1);
              do
              {
                v311 = v307 * v305;
                v307 = LOWORD(v172[v310 - 1]);
                *&v173[2 * v310] = (v311 + HIWORD(v311) + 1) >> 16;
                v299 = v310-- <= 1;
              }

              while (!v299);
            }

            v312 = v307 * v305 + ((v307 * v305) >> 16) + 1;
          }

          *v173 = HIWORD(v312);
          goto LABEL_474;
        }

        if (v17 >= 2)
        {
          v313 = (v17 - 1);
          do
          {
            v309 = v172[v313 - 1];
            *&v173[2 * v313] = v307;
            *&v307 = v309;
            v299 = v313-- <= 1;
          }

          while (!v299);
          goto LABEL_467;
        }
      }

      v309 = *&v307;
LABEL_467:
      *v173 = v309;
LABEL_474:
      v172 = (v172 + v304);
      v173 += v304;
      v299 = v18-- <= 1;
      if (v299)
      {
        goto LABEL_476;
      }
    }
  }

  v176 = a1 >> 2;
  v177 = a1 & 3;
  do
  {
    if (v176 < 1)
    {
      goto LABEL_259;
    }

    v178 = 0;
    v179 = v176 + 1;
    do
    {
      v180 = *&v171[v178];
      *&v174[v178] = v180;
      if (!v23 || v180 == 0xFFFFFFFF)
      {
        *&v173[v178 * 2] = *&v172[v178];
        goto LABEL_257;
      }

      if (!v180)
      {
        *&v173[v178 * 2] = 0;
        goto LABEL_257;
      }

      LOWORD(v181) = v180;
      if (v23 < 1)
      {
        if (v180)
        {
          if (v180 == 0xFFFF)
          {
            *&v181 = v172[v178];
          }

          else
          {
            v181 = (0xFFFFFFFF / v180 * LOWORD(v172[v178])) >> 16;
          }
        }

        *&v173[v178 * 2] = v181;
        if (WORD1(v180) == 0xFFFF)
        {
          *&v187 = v172[v178 + 1];
        }

        else if (v180 >= 0x10000)
        {
          v187 = (0xFFFFFFFF / WORD1(v180) * LOWORD(v172[v178 + 1])) >> 16;
        }

        else
        {
          LOWORD(v187) = 0;
        }

        *&v173[v178 * 2 + 2] = v187;
        if (WORD2(v180))
        {
          if (WORD2(v180) == 0xFFFF)
          {
            *&v188 = v172[v178 + 2];
          }

          else
          {
            LODWORD(v188) = (0xFFFFFFFF / WORD2(v180) * LOWORD(v172[v178 + 2])) >> 16;
          }
        }

        else
        {
          v188 = HIDWORD(v180);
        }

        *&v173[v178 * 2 + 4] = v188;
        v189 = HIWORD(v180);
        if (v189 != 0xFFFF)
        {
          if (!v189)
          {
LABEL_253:
            *&v173[v178 * 2 + 6] = 0;
            goto LABEL_257;
          }

          v186 = 0xFFFFFFFF / v189 * LOWORD(v172[v178 + 3]);
          goto LABEL_255;
        }
      }

      else
      {
        if (v180)
        {
          if (v180 == 0xFFFF)
          {
            *&v181 = v172[v178];
          }

          else
          {
            v181 = (v180 * LOWORD(v172[v178]) + ((v180 * LOWORD(v172[v178])) >> 16) + 1) >> 16;
          }
        }

        *&v173[v178 * 2] = v181;
        if (WORD1(v180) == 0xFFFF)
        {
          *&v182 = v172[v178 + 1];
        }

        else if (v180 >= 0x10000)
        {
          v183 = WORD1(v180) * LOWORD(v172[v178 + 1]);
          v182 = (v183 + HIWORD(v183) + 1) >> 16;
        }

        else
        {
          LOWORD(v182) = 0;
        }

        *&v173[v178 * 2 + 2] = v182;
        if (WORD2(v180))
        {
          if (WORD2(v180) == 0xFFFF)
          {
            *&v184 = v172[v178 + 2];
          }

          else
          {
            LODWORD(v184) = (WORD2(v180) * LOWORD(v172[v178 + 2]) + ((WORD2(v180) * LOWORD(v172[v178 + 2])) >> 16) + 1) >> 16;
          }
        }

        else
        {
          v184 = HIDWORD(v180);
        }

        *&v173[v178 * 2 + 4] = v184;
        v185 = HIWORD(v180);
        if (v185 != 0xFFFF)
        {
          if (!v185)
          {
            goto LABEL_253;
          }

          v186 = LOWORD(v172[v178 + 3]) * v185 + ((LOWORD(v172[v178 + 3]) * v185) >> 16) + 1;
LABEL_255:
          v190 = HIWORD(v186);
          goto LABEL_256;
        }
      }

      *&v190 = v172[v178 + 3];
LABEL_256:
      *&v173[v178 * 2 + 6] = v190;
LABEL_257:
      --v179;
      v178 += 4;
    }

    while (v179 > 1);
    v174 = (v174 + v178 * 2);
    v172 = (v172 + v178 * 2);
    v171 = (v171 + v178 * 2);
    v173 += v178 * 2;
LABEL_259:
    if (v177)
    {
      v191 = v177 + 1;
      do
      {
        v193 = *v171++;
        v192 = v193;
        *v174++ = v193;
        if (v193)
        {
          if (v192 == 0xFFFF || !v23)
          {
            *&v192 = *v172;
          }

          else
          {
            if (v23 < 1)
            {
              v194 = 0xFFFFFFFF / v192 * *v172;
            }

            else
            {
              v194 = *v172 * v192 + ((*v172 * v192) >> 16) + 1;
            }

            v192 = HIWORD(v194);
          }
        }

        *v173 = v192;
        v173 += 2;
        ++v172;
        --v191;
      }

      while (v191 > 1);
    }

    v172 = (v172 + v342);
    v171 = (v171 + v338);
    v173 += v334;
    v174 = (v174 + v331);
    --v349;
  }

  while (v349);
}

void img_blocks_error(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4)
  {
    v8 = "%s: %s\nCGImageProviderCopyImageBlockSet(<CGImageProvider %p> (component-type = %s, pixel-size = %ld, size = [%g x %g]));\n\t<CGImageBlockSet %p> (size = [%g x %g], rect = (%g, %g) x [%g, %g], count %ld) [%ld];\n\t\t<CGImageBlock %p> (rect = (%g, %g) x [%g, %g], data = %p, bytes-per-row = %ld)";
  }

  else
  {
    v8 = "%s: %s\nCGImageProviderCopyImageBlockSet(<CGImageProvider %p> (component-type = %s, pixel-size = %ld, size = [%g x %g]));\n\t<CGImageBlockSet %p> (size = [%g x %g], rect = (%g, %g) x [%g, %g], count = %ld) [%ld]";
  }

  CGPostError(v8, a2, a3, a4, a5, a6, a7, a8, "img_blocks_create");
}

CFDictionaryRef __img_blocks_options_block_invoke()
{
  keys[2] = *MEMORY[0x1E69E9840];
  keys[0] = @"kCGImageBlockFormatRequest";
  keys[1] = @"kCGImageBlockSingletonRequest";
  v0 = *MEMORY[0x1E695E4D0];
  values[0] = @"kCGImageBlockFormatBGRx8";
  values[1] = v0;
  result = CFDictionaryCreate(0, keys, values, 2, MEMORY[0x1E695E9D8], MEMORY[0x1E695E9E8]);
  img_blocks_options_options_singleton = result;
  return result;
}

uint64_t img_extent(uint64_t *a1)
{
  result = *a1;
  if (result)
  {
    return (*(result + 8))();
  }

  return result;
}

uint64_t img_raw_data(uint64_t a1, signed int a2, uint64_t a3, void *a4, _DWORD *a5)
{
  v10 = *(a1 + 96);
  if (v10 == -1)
  {
    v17 = *(a1 + 184);
    if (!v17)
    {
      return 0;
    }

    v18 = v17[5];
    if (v18 != v17[6] || v18 < 1)
    {
      return 0;
    }

    v20 = 0;
    for (i = (v17[9] + 12); ; i += 4)
    {
      v22 = *(i - 2);
      v23 = a2 - v22;
      if (a2 >= v22)
      {
        v24 = *i + v22;
        if (v24 > a2)
        {
          break;
        }
      }

      if (v18 == ++v20)
      {
        return 0;
      }
    }

    v31 = *(v17[11] + 8 * v20);
    v32 = v31 * v23;
    if (v32 != v32)
    {
      return 0;
    }

    v33 = *(v17[10] + 8 * v20) + v32;
    if (a4[1] == *a4)
    {
      a4[1] = v33;
      a5[1] = v31;
    }

    *a4 = v33;
    *a5 = v31;
    v34 = a3 + a2;
    if (a3 + a2 >= v24)
    {
      v34 = v24;
    }

    *(a1 + 88) = v34;
    return (v34 - a2);
  }

  else
  {
    if (v10)
    {
      v26 = *(a1 + 136);
      v25 = *(a1 + 144);
      if (v10 == 2 && a4[1] && (*(a1 + 44) & 0xFFFFFFFE) == 8)
      {
        v27 = v26[1];
        v28 = v27 * a2;
        if (v28 != v28)
        {
          return 0;
        }

        a4[1] = v25[1] + v28;
        a5[1] = v27;
      }

      v29 = *v26;
      v30 = v29 * a2;
      if (v30 == v30)
      {
        *a4 = *v25 + v30;
        *a5 = v29;
        v16 = a3 + a2;
LABEL_28:
        *(a1 + 88) = v16;
        return a3;
      }

      return 0;
    }

    image_pointer = get_image_pointer(a1);
    result = 0;
    if (a3 >= 1 && (a2 & 0x80000000) == 0 && image_pointer)
    {
      v13 = *(a1 + 136);
      v14 = v13 * a2;
      if (v14 == v14 && (v14 & 0x80000000) == 0)
      {
        v15 = image_pointer + v14;
        if (a4[1] == *a4)
        {
          a4[1] = v15;
          a5[1] = v13;
        }

        *a4 = v15;
        *a5 = v13;
        v16 = (a3 + a2);
        goto LABEL_28;
      }

      return 0;
    }
  }

  return result;
}

uint64_t img_interpolate_extent(uint64_t *a1, uint64_t a2)
{
  v2 = *a1;
  if (!*a1)
  {
    return 0;
  }

  v3 = a1[11];
  v8 = 0;
  v9 = 0;
  v4 = *(v2 + 8);
  if (!v4)
  {
    return 0;
  }

  if (a2)
  {
    v7 = *(v2 + 8);
    LODWORD(v9) = resample_range(v3, 1, *a2, *(a2 + 8), &v8);
    if ((v9 & 0x80000000) != 0)
    {
      return 0xFFFFFFFFLL;
    }

    HIDWORD(v9) = resample_range(v3, 2, *(a2 + 4), *(a2 + 12), &v8 + 1);
    if (v9 < 0)
    {
      return 0xFFFFFFFFLL;
    }

    else
    {
      return v7(v2, &v8);
    }
  }

  else
  {

    return v4(v2, 0);
  }
}

uint64_t img_alphamerge_end(uint64_t *a1)
{
  result = *a1;
  if (result)
  {
    return (*(result + 24))();
  }

  return result;
}

uint64_t img_alphamerge_read(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, int *a5, uint64_t a6)
{
  v9 = a3;
  v38[1] = *MEMORY[0x1E69E9840];
  v12 = *a1;
  v13 = *(a1 + 88);
  v38[0] = 0;
  v37 = 0uLL;
  switch(v13)
  {
    case 0:
      v23 = 0;
      goto LABEL_25;
    case 1:
      if (!*v12 && *(v12 + 16) == img_raw_read)
      {
        v23 = img_raw_access(v12, 0);
      }

      else
      {
        v23 = 0;
      }

      v24 = *a5 * (v9 - 1) / *(a1 + 56);
      if (v24 >= v9)
      {
        v9 = (v9 - 1);
      }

      else
      {
        v25 = *(a1 + 64);
        if (v25 >= v9)
        {
          v26 = v9;
        }

        else
        {
          v26 = *(a1 + 64);
        }

        if (v24 >= v25)
        {
          v9 = v24;
        }

        else
        {
          v9 = v26;
        }
      }

LABEL_25:
      if (!*v12 && *(v12 + 16) == img_raw_read)
      {
        v30 = img_raw_access(v12, 0);
        v37 = *a4;
        v38[0] = *a5;
        if ((v30 & 1) == 0)
        {
          break;
        }
      }

      else
      {
        v37 = *a4;
        v38[0] = *a5;
        if (!v23)
        {
          break;
        }
      }

      v27 = img_raw_data(v12, a2, v9, &v37, v38);
      goto LABEL_31;
    case 2:
      v14 = *a4;
      v15 = *a5;
      v16 = *(a1 + 56);
      v17 = *(a1 + 60);
      v38[0] = __PAIR64__(v17, v16);
      v18 = (a3 - 1);
      v19 = v15 * v18 / (v17 + v15);
      if (v19 >= a3 || (v20 = *(a1 + 64), v18 = (v15 * v18 / (v17 + v15)), v19 >= v20))
      {
        v21 = v14 + v15 * a3 - (v18 * v17);
        *(&v37 + 1) = v21;
        v9 = v18;
      }

      else
      {
        if (v20 >= a3)
        {
          v9 = a3;
        }

        else
        {
          v9 = v20;
        }

        v22 = *(a1 + 72);
        v21 = *(a1 + 80);
        *(&v37 + 1) = v21;
        if (v22)
        {
          *&v37 = v22;
          break;
        }
      }

      *&v37 = v21 - (v9 * v16);
      break;
  }

  v27 = (*(v12 + 16))(v12, a2, v9, &v37, v38, a6);
LABEL_31:
  if (v27 < 1)
  {
    return 0;
  }

  v31 = v27;
  v32 = *(v12 + 40);
  if (v32 == 16)
  {
    v33 = 2;
  }

  else
  {
    v33 = 1;
  }

  if (v32 == 32)
  {
    v34 = 4;
  }

  else
  {
    v34 = v33;
  }

  if (*(a1 + 112) == 5)
  {
    v35 = 5;
  }

  else
  {
    v35 = v34;
  }

  img_alpha(*(v12 + 48), v27, *(v12 + 36), *(v12 + 44), &v37, v38, *(a1 + 44), a4, v28, v29, a5, v35);
  return v31;
}

uint64_t img_blocks_read(void *a1, int a2, unsigned int a3, void *a4, int *a5)
{
  v5 = a1[23];
  v26 = 0;
  v27 = a2;
  v28 = a1[15];
  v29 = a3;
  if (*(v5 + 40) >= 1)
  {
    v7 = 0;
    v8 = 0;
    v9 = *(v5 + 32);
    v10 = *(v5 + 40) & 0x7FFFFFFFLL;
    do
    {
      v24 = 0;
      v25 = 0;
      v23 = 0uLL;
      v23 = *(*(v5 + 72) + v7);
      if (CGSBoundsIntersection(&v26, &v23, &v24))
      {
        v11 = *(*(v5 + 80) + 8 * v8);
        v12 = *(*(v5 + 88) + 8 * v8);
        v13 = (*a4 + (HIDWORD(v24) - v27) * *a5 + (v24 - v26) * v9);
        if (!v11)
        {
          CGBlt_fillBytes(v25 * v9, HIDWORD(v25), 0, v13, *a5);
        }

        v14 = a1[14];
        if (v14)
        {
          CGBlt_swapBytes(v25 * v9, HIDWORD(v25), (v11 + v12 * (SHIDWORD(v24) - SDWORD1(v23)) + (v24 - v23) * v9), v13, v12, *a5, v14);
        }

        else
        {
          if (*(v5 + 48) != *(v5 + 40))
          {
            v16 = v24;
            v17 = HIDWORD(v24);
            LODWORD(v15) = *a5;
LABEL_13:
            CGBlt_copyBytes(v25 * v9, SHIDWORD(v25), (v11 + v12 * (v17 - SDWORD1(v23)) + (v16 - v23) * v9), v13, v12, v15);
            goto LABEL_14;
          }

          v15 = *a5;
          v16 = v24;
          v17 = HIDWORD(v24);
          if ((v15 & 0x80000000) != 0 || v12 != v15)
          {
            goto LABEL_13;
          }

          memcpy(v13, (v11 + v12 * (SHIDWORD(v24) - SDWORD1(v23)) + (v24 - v23) * v9), v12 * SHIDWORD(v25));
        }
      }

LABEL_14:
      ++v8;
      v7 += 16;
    }

    while (v10 != v8);
  }

  result = a3;
  a1[11] = (a3 + a2);
  return result;
}

void AddPdfOperators(CGPDFOperatorTable *a1)
{
  CGPDFOperatorTableSetCallback(a1, "b", op_b_12419);
  CGPDFOperatorTableSetCallback(a1, "B", op_B_12418);
  CGPDFOperatorTableSetCallback(a1, "BMC", op_BMC_12417);
  CGPDFOperatorTableSetCallback(a1, "BDC", op_BDC_12416);
  CGPDFOperatorTableSetCallback(a1, "EMC", op_EMC_12415);
  CGPDFOperatorTableSetCallback(a1, "BT", op_BT_12414);
  CGPDFOperatorTableSetCallback(a1, "b*", op_bstar_12413);
  CGPDFOperatorTableSetCallback(a1, "B*", op_Bstar_12412);
  CGPDFOperatorTableSetCallback(a1, "c", op_c_12411);
  CGPDFOperatorTableSetCallback(a1, "cm", op_cm_12410);
  CGPDFOperatorTableSetCallback(a1, "cs", op_cs_12409);
  CGPDFOperatorTableSetCallback(a1, "CS", op_CS_12408);
  CGPDFOperatorTableSetCallback(a1, "Do", op_Do_12405);
  CGPDFOperatorTableSetCallback(a1, "d", op_d_12404);
  CGPDFOperatorTableSetCallback(a1, "DP", op_DP_12403);
  CGPDFOperatorTableSetCallback(a1, "d0", op_d0_12402);
  CGPDFOperatorTableSetCallback(a1, "d1", op_d1_12401);
  CGPDFOperatorTableSetCallback(a1, "EI", op_EI_12377);
  CGPDFOperatorTableSetCallback(a1, "ET", op_ET_12376);
  CGPDFOperatorTableSetCallback(a1, "f", op_f_12375);
  CGPDFOperatorTableSetCallback(a1, "F", op_f_12375);
  CGPDFOperatorTableSetCallback(a1, "f*", op_fstar_12374);
  CGPDFOperatorTableSetCallback(a1, "g", op_g_12373);
  CGPDFOperatorTableSetCallback(a1, "G", op_G_12372);
  CGPDFOperatorTableSetCallback(a1, "gs", op_gs_12368);
  CGPDFOperatorTableSetCallback(a1, "h", op_h_12351);
  CGPDFOperatorTableSetCallback(a1, "i", op_i_12367);
  CGPDFOperatorTableSetCallback(a1, "j", op_j_12366);
  CGPDFOperatorTableSetCallback(a1, "J", op_J_12365);
  CGPDFOperatorTableSetCallback(a1, "k", op_k_12364);
  CGPDFOperatorTableSetCallback(a1, "K", op_K_12363);
  CGPDFOperatorTableSetCallback(a1, "l", op_l_12362);
  CGPDFOperatorTableSetCallback(a1, "m", op_m_12361);
  CGPDFOperatorTableSetCallback(a1, "M", op_M_12360);
  CGPDFOperatorTableSetCallback(a1, "MP", op_MP_12359);
  CGPDFOperatorTableSetCallback(a1, "n", op_n_12358);
  CGPDFOperatorTableSetCallback(a1, "q", op_q_12357);
  CGPDFOperatorTableSetCallback(a1, "Q", op_Q_12356);
  CGPDFOperatorTableSetCallback(a1, "re", op_re_12355);
  CGPDFOperatorTableSetCallback(a1, "RG", op_RG_12354);
  CGPDFOperatorTableSetCallback(a1, "rg", op_rg_12353);
  CGPDFOperatorTableSetCallback(a1, "ri", op_ri_12352);
  CGPDFOperatorTableSetCallback(a1, "s", op_s_12350);
  CGPDFOperatorTableSetCallback(a1, "S", op_S_12349);
  CGPDFOperatorTableSetCallback(a1, "sc", op_sc_12348);
  CGPDFOperatorTableSetCallback(a1, "SC", op_SC_12347);
  CGPDFOperatorTableSetCallback(a1, "SCN", op_SCN_12346);
  CGPDFOperatorTableSetCallback(a1, "scn", op_scn_12345);
  CGPDFOperatorTableSetCallback(a1, "sh", op_sh_12344);
  CGPDFOperatorTableSetCallback(a1, "Tc", op_Tc_12343);
  CGPDFOperatorTableSetCallback(a1, "Td", op_Td_12342);
  CGPDFOperatorTableSetCallback(a1, "TD", op_TD_12341);
  CGPDFOperatorTableSetCallback(a1, "Tf", op_Tf_12339);
  CGPDFOperatorTableSetCallback(a1, "Tj", op_Tj_12338);
  CGPDFOperatorTableSetCallback(a1, "TJ", op_TJ_12337);
  CGPDFOperatorTableSetCallback(a1, "TL", op_TL_12336);
  CGPDFOperatorTableSetCallback(a1, "Tm", op_Tm_12335);
  CGPDFOperatorTableSetCallback(a1, "Tr", op_Tr_12334);
  CGPDFOperatorTableSetCallback(a1, "T*", op_Tstar_12324);
  CGPDFOperatorTableSetCallback(a1, "Ts", op_Ts_12333);
  CGPDFOperatorTableSetCallback(a1, "Tw", op_Tw_12332);
  CGPDFOperatorTableSetCallback(a1, "Tz", op_Tz_12331);
  CGPDFOperatorTableSetCallback(a1, "v", op_v_12330);
  CGPDFOperatorTableSetCallback(a1, "W", op_W_12329);
  CGPDFOperatorTableSetCallback(a1, "w", op_w_12328);
  CGPDFOperatorTableSetCallback(a1, "W*", op_Wstar_12327);
  CGPDFOperatorTableSetCallback(a1, "y", op_y_12326);
  CGPDFOperatorTableSetCallback(a1, "'", op_quo_12325);

  CGPDFOperatorTableSetCallback(a1, "", op_quoquo_12323);
}

void op_quoquo_12323(CGPDFScanner *a1, uint64_t a2)
{
  value = 0;
  v4 = CGPDFScannerPopString(a1, &value);
  if (CGPDFScannerPopNumber(a1, (*(a2 + 40) + 184)))
  {
    v5 = CGPDFScannerPopNumber(a1, (*(a2 + 40) + 192));
    if (v5 && v4)
    {
      op_Tstar_12324(v5, a2);
      ShowText(a2, value);
    }
  }
}

__n128 op_Tstar_12324(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 40);
  v3 = *(v2 + 136);
  v4 = *(v2 + 152);
  v5 = vaddq_f64(*(v2 + 168), vmlaq_f64(vmulq_n_f64(v4, -*(v2 + 208)), 0, v3));
  *(v2 + 88) = vaddq_f64(v3, vmulq_f64(v4, 0));
  *(v2 + 104) = vmlaq_f64(v4, 0, v3);
  *(v2 + 120) = v5;
  v6 = *(a2 + 40);
  *(v6 + 152) = *(v6 + 104);
  *(v6 + 136) = *(v6 + 88);
  result = *(v6 + 120);
  *(v6 + 168) = result;
  return result;
}

void op_quo_12325(CGPDFScanner *a1, uint64_t a2)
{
  op_Tstar_12324(a1, a2);
  value = 0;
  if (CGPDFScannerPopString(a1, &value))
  {
    ShowText(a2, value);
  }
}

void op_y_12326(CGPDFScanner *a1, uint64_t a2)
{
  value = 0.0;
  v7 = 0.0;
  v4 = 0.0;
  v5 = 0.0;
  if (CGPDFScannerPopNumber(a1, &value) && CGPDFScannerPopNumber(a1, &v7) && CGPDFScannerPopNumber(a1, &v4) && CGPDFScannerPopNumber(a1, &v5) && !CGPathIsEmpty(*(*(a2 + 40) + 64)))
  {
    CGPathAddCurveToPoint(*(*(a2 + 40) + 64), (*(a2 + 40) + 16), v5, v4, v7, value, v7, value);
  }
}

BOOL op_w_12328(CGPDFScanner *a1, uint64_t a2)
{
  result = CGPDFScannerPopNumber(a1, (*(a2 + 40) + 296));
  if (result)
  {
    *(*(a2 + 40) + 9) = 1;
  }

  return result;
}

void op_v_12330(CGPDFScanner *a1, uint64_t a2)
{
  value = 0.0;
  v9 = 0.0;
  v6 = 0.0;
  v7 = 0.0;
  if (CGPDFScannerPopNumber(a1, &value) && CGPDFScannerPopNumber(a1, &v9) && CGPDFScannerPopNumber(a1, &v6) && CGPDFScannerPopNumber(a1, &v7) && !CGPathIsEmpty(*(*(a2 + 40) + 64)))
  {
    CurrentPoint = CGPathGetCurrentPoint(*(*(a2 + 40) + 64));
    v5 = *(a2 + 40);
    CGPathAddCurveToPoint(*(v5 + 64), 0, CurrentPoint.x, CurrentPoint.y, *(v5 + 48) + v6 * *(v5 + 32) + *(v5 + 16) * v7, *(v5 + 56) + v6 * *(v5 + 40) + *(v5 + 24) * v7, *(v5 + 48) + *(v5 + 32) * value + *(v5 + 16) * v9, *(v5 + 56) + *(v5 + 40) * value + *(v5 + 24) * v9);
  }
}

__n128 op_Tm_12335(CGPDFScanner *a1, uint64_t a2)
{
  *(*(a2 + 40) + 88) = CGAffineTransformIdentity;
  if (CGPDFScannerPopNumber(a1, (*(a2 + 40) + 128)) && CGPDFScannerPopNumber(a1, (*(a2 + 40) + 120)) && CGPDFScannerPopNumber(a1, (*(a2 + 40) + 112)) && CGPDFScannerPopNumber(a1, (*(a2 + 40) + 104)) && CGPDFScannerPopNumber(a1, (*(a2 + 40) + 96)) && CGPDFScannerPopNumber(a1, (*(a2 + 40) + 88)))
  {
    v5 = *(a2 + 40);
    *(v5 + 136) = *(v5 + 88);
    *(v5 + 152) = *(v5 + 104);
    result = *(v5 + 120);
    *(v5 + 168) = result;
    *(*(a2 + 40) + 9) = 1;
  }

  return result;
}

void op_TJ_12337(CGPDFScanner *a1, uint64_t a2)
{
  value = 0;
  if (CGPDFScannerPopArray(a1, &value))
  {
    if (value)
    {
      v3 = *(value + 3) - *(value + 2);
      if (v3)
      {
        v4 = 0;
        v5 = v3 >> 3;
        while (1)
        {
          v8 = 0;
          if (!CGPDFArrayGetObject(value, v4, &v8) || !v8)
          {
            goto LABEL_16;
          }

          v6 = *(v8 + 2);
          if (v6 > 5)
          {
            break;
          }

          if (v6 == 3)
          {
            goto LABEL_14;
          }

          if (v6 == 4)
          {
            v7 = *(v8 + 4);
            goto LABEL_15;
          }

LABEL_16:
          if (v5 == ++v4)
          {
            return;
          }
        }

        if (v6 != 12)
        {
          if (v6 == 6)
          {
            ShowText(a2, *(v8 + 4));
          }

          goto LABEL_16;
        }

LABEL_14:
        v7 = *(v8 + 4);
LABEL_15:
        AdjustPosition(a2, v7);
        goto LABEL_16;
      }
    }
  }
}

void op_Tj_12338(CGPDFScanner *a1, uint64_t a2)
{
  value = 0;
  if (CGPDFScannerPopString(a1, &value))
  {
    ShowText(a2, value);
  }
}

void op_Tf_12339(CGPDFScanner *a1, uint64_t a2)
{
  v11 = 0;
  value = 0;
  if (CGPDFScannerPopNumber(a1, &v11) && CGPDFScannerPopName(a1, &value))
  {
    v4 = *(a1 + 7);
    if (v4)
    {
      Resource = CGPDFContentStreamGetResource(v4, "Font", value);
      if (Resource)
      {
        if (*(Resource + 2) == 8)
        {
          v6 = *(Resource + 4);
          if (v6)
          {
            v7 = CFDictionaryGetValue(*(a2 + 2240), v6);
            if (!v7)
            {
              v7 = [[CPFont alloc] initWith:v6];
              CFDictionaryAddValue(*(a2 + 2240), v6, v7);
            }

            v8 = *(a2 + 40);
            v9 = v11;
            v10 = *(v8 + 248);
            if (v10 != v7)
            {

              *(v8 + 248) = v7;
            }

            *(v8 + 216) = v9;
            *(v8 + 9) = 1;
          }
        }

        *(*(a2 + 40) + 9) = 1;
      }
    }
  }
}

__n128 op_TD_12341(CGPDFScanner *a1, uint64_t a2)
{
  v11 = *&CGAffineTransformIdentity.tx;
  if (CGPDFScannerPopNumber(a1, &v11 + 1) && CGPDFScannerPopNumber(a1, &v11))
  {
    v5 = *(&v11 + 1);
    v6 = *(a2 + 40);
    *(v6 + 208) = -*(&v11 + 1);
    v7 = *(v6 + 136);
    v8 = *(v6 + 152);
    v9 = vaddq_f64(*(v6 + 168), vmlaq_n_f64(vmulq_n_f64(v8, v5), v7, *&v11));
    *(v6 + 88) = vmlaq_n_f64(vmulq_n_f64(v8, 0.0), v7, 1.0);
    *(v6 + 104) = vmlaq_n_f64(vmulq_n_f64(v8, 1.0), v7, 0.0);
    *(v6 + 120) = v9;
    v10 = *(a2 + 40);
    *(v10 + 136) = *(v10 + 88);
    *(v10 + 168) = *(v10 + 120);
    result = *(v10 + 104);
    *(v10 + 152) = result;
  }

  return result;
}

__n128 op_Td_12342(CGPDFScanner *a1, uint64_t a2)
{
  v10 = *&CGAffineTransformIdentity.tx;
  if (CGPDFScannerPopNumber(a1, &v10 + 1) && CGPDFScannerPopNumber(a1, &v10))
  {
    v5 = *(a2 + 40);
    v6 = *(v5 + 136);
    v7 = *(v5 + 152);
    v8 = vaddq_f64(*(v5 + 168), vmlaq_n_f64(vmulq_n_f64(v7, *(&v10 + 1)), v6, *&v10));
    *(v5 + 88) = vmlaq_n_f64(vmulq_n_f64(v7, 0.0), v6, 1.0);
    *(v5 + 104) = vmlaq_n_f64(vmulq_n_f64(v7, 1.0), v6, 0.0);
    *(v5 + 120) = v8;
    v9 = *(a2 + 40);
    *(v9 + 168) = *(v9 + 120);
    *(v9 + 152) = *(v9 + 104);
    result = *(v9 + 88);
    *(v9 + 136) = result;
  }

  return result;
}

void op_sh_12344(CGPDFScanner *a1, uint64_t a2)
{
  v6 = 0;
  v7 = 0;
  if (common_op_sh(a1, a2, &v7, &v6))
  {
    CPPDFContextSaveGState(a2);
    v3 = *(a2 + 40);
    *(v3 + 376) = v7;
    v4 = *(v3 + 64);
    if (v4)
    {
      CFRelease(v4);
      v3 = *(a2 + 40);
    }

    *(v3 + 64) = v6;
    v5 = *(v3 + 8);
    *(v3 + 8) = 1;
    CPPDFContextAddShape(a2, 1, 1);
    *(*(a2 + 40) + 8) = v5;

    CPPDFContextRestoreGState(a2);
  }
}

uint64_t op_s_12350(uint64_t a1, uint64_t a2)
{
  op_h_12351(a1, a2);

  return CPPDFContextAddStroke(a2);
}

void op_h_12351(uint64_t a1, uint64_t a2)
{
  if (!CGPathIsEmpty(*(*(a2 + 40) + 64)))
  {
    v3 = *(*(a2 + 40) + 64);

    CGPathCloseSubpath(v3);
  }
}

void op_rg_12353(CGPDFScanner *a1, uint64_t a2)
{
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  v5 = common_PopRGBAlphaCGColorCreate(a1, DeviceRGB);
  v6 = *(a2 + 40);
  v7 = *(v6 + 256);
  if (v7)
  {
    CFRelease(v7);
    v6 = *(a2 + 40);
  }

  *(v6 + 256) = v5;
  v8 = *(v6 + 264);
  if (v8)
  {
    CGColorSpaceRelease(v8);
    v6 = *(a2 + 40);
  }

  *(v6 + 264) = DeviceRGB;
  *(v6 + 9) = 1;
}

void op_RG_12354(CGPDFScanner *a1, uint64_t a2)
{
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  v5 = common_PopRGBAlphaCGColorCreate(a1, DeviceRGB);
  v6 = *(a2 + 40);
  v7 = *(v6 + 272);
  if (v7)
  {
    CFRelease(v7);
    v6 = *(a2 + 40);
  }

  *(v6 + 272) = v5;
  v8 = *(v6 + 280);
  if (v8)
  {
    CGColorSpaceRelease(v8);
    v6 = *(a2 + 40);
  }

  *(v6 + 280) = DeviceRGB;
  *(v6 + 9) = 1;
}

void op_re_12355(CGPDFScanner *a1, uint64_t a2)
{
  memset(&v3, 0, sizeof(v3));
  if (common_ReadCGRect(a1, &v3.origin.x))
  {
    CGPathAddRect(*(*(a2 + 40) + 64), (*(a2 + 40) + 16), v3);
  }
}

CGMutablePathRef op_n_12358(uint64_t a1, uint64_t a2)
{
  CPPDFContextAddPathToClip(a2, 0);
  v3 = *(*(a2 + 40) + 64);
  if (v3)
  {
    CFRelease(v3);
  }

  result = CGPathCreateMutable();
  *(*(a2 + 40) + 64) = result;
  return result;
}

BOOL op_M_12360(CGPDFScanner *a1, uint64_t a2)
{
  result = CGPDFScannerPopNumber(a1, (*(a2 + 40) + 288));
  if (result)
  {
    *(*(a2 + 40) + 9) = 1;
  }

  return result;
}

void op_m_12361(CGPDFScanner *a1, uint64_t a2)
{
  y = 0.0;
  value = 0.0;
  if (!CGPDFScannerPopNumber(a1, &y))
  {
    y = 0.0;
  }

  if (CGPDFScannerPopNumber(a1, &value))
  {
    v4 = value;
  }

  else
  {
    value = 0.0;
    v4 = 0.0;
  }

  CGPathMoveToPoint(*(*(a2 + 40) + 64), (*(a2 + 40) + 16), v4, y);
}

void op_l_12362(CGPDFScanner *a1, uint64_t a2)
{
  v4 = 0.0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v4) && CGPDFScannerPopNumber(a1, &value) && !CGPathIsEmpty(*(*(a2 + 40) + 64)))
  {
    CGPathAddLineToPoint(*(*(a2 + 40) + 64), (*(a2 + 40) + 16), value, v4);
  }
}

void op_K_12363(CGPDFScanner *a1, uint64_t a2)
{
  DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
  v5 = common_PopCMYKAlphaCGColorCreate(a1, DeviceCMYK);
  v6 = *(a2 + 40);
  v7 = *(v6 + 272);
  if (v7)
  {
    CFRelease(v7);
    v6 = *(a2 + 40);
  }

  *(v6 + 272) = v5;
  v8 = *(v6 + 280);
  if (v8)
  {
    CGColorSpaceRelease(v8);
    v6 = *(a2 + 40);
  }

  *(v6 + 280) = DeviceCMYK;
  *(v6 + 9) = 1;
}

void op_k_12364(CGPDFScanner *a1, uint64_t a2)
{
  DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
  v5 = common_PopCMYKAlphaCGColorCreate(a1, DeviceCMYK);
  v6 = *(a2 + 40);
  v7 = *(v6 + 256);
  if (v7)
  {
    CFRelease(v7);
    v6 = *(a2 + 40);
  }

  *(v6 + 256) = v5;
  v8 = *(v6 + 264);
  if (v8)
  {
    CGColorSpaceRelease(v8);
    v6 = *(a2 + 40);
  }

  *(v6 + 264) = DeviceCMYK;
  *(v6 + 9) = 1;
}

BOOL op_J_12365(CGPDFScanner *a1, uint64_t a2)
{
  value = 0;
  result = CGPDFScannerPopInteger(a1, &value);
  if (result)
  {
    v4 = *(a2 + 40);
    *(v4 + 304) = value;
    *(v4 + 9) = 1;
  }

  return result;
}

BOOL op_j_12366(CGPDFScanner *a1, uint64_t a2)
{
  value = 0;
  result = CGPDFScannerPopInteger(a1, &value);
  if (result)
  {
    v4 = *(a2 + 40);
    *(v4 + 305) = value;
    *(v4 + 9) = 1;
  }

  return result;
}

CGPDFReal op_i_12367(CGPDFScanner *a1, uint64_t a2)
{
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value))
  {
    result = value;
    v4 = *(a2 + 40);
    *(v4 + 312) = value;
    *(v4 + 9) = 1;
  }

  return result;
}

CGPDFDictionary *op_gs_12368(CGPDFObjectRef *a1, uint64_t a2)
{
  value = 0;
  result = CGPDFScannerPopName(a1, &value);
  if (result)
  {
    result = common_GetResourceDictionary(a1[7], "ExtGState", value);
    if (result)
    {
      v5 = result;
      result = common_op_gs(a2, result);
      if (result)
      {
        array = 0;
        if (CGPDFDictionaryGetArray(v5, "D", &array))
        {
          v8 = 0;
          v9 = 0;
          if (CGPDFArrayGetArray(array, 0, &v9) && CGPDFArrayGetNumber(array, 1uLL, &v8))
          {
            v6 = *(a2 + 40);
            *(v6 + 360) = v9;
            *(v6 + 352) = v8;
          }
        }

        v9 = 0;
        result = CGPDFDictionaryGetDictionary(v5, "SMask", &v9);
        v7 = *(a2 + 40);
        if (result)
        {
          *(v7 + 368) = v9;
        }

        *(v7 + 9) = 1;
      }
    }
  }

  return result;
}

void op_G_12372(CGPDFScanner *a1, uint64_t a2)
{
  value[2] = *MEMORY[0x1E69E9840];
  DeviceGray = CGColorSpaceCreateDeviceGray();
  if (!CGPDFScannerPopNumber(a1, value))
  {
    value[0] = 0.0;
  }

  value[1] = 1.0;
  v5 = CGColorCreate(DeviceGray, value);
  v6 = *(a2 + 40);
  v7 = *(v6 + 280);
  if (v7)
  {
    CGColorSpaceRelease(v7);
    v6 = *(a2 + 40);
  }

  *(v6 + 280) = DeviceGray;
  v8 = *(v6 + 272);
  if (v8)
  {
    CFRelease(v8);
    v6 = *(a2 + 40);
  }

  *(v6 + 272) = v5;
  *(v6 + 9) = 1;
}

void op_g_12373(CGPDFScanner *a1, uint64_t a2)
{
  value[2] = *MEMORY[0x1E69E9840];
  DeviceGray = CGColorSpaceCreateDeviceGray();
  if (!CGPDFScannerPopNumber(a1, value))
  {
    value[0] = 0.0;
  }

  value[1] = 1.0;
  v5 = CGColorCreate(DeviceGray, value);
  v6 = *(a2 + 40);
  v7 = *(v6 + 264);
  if (v7)
  {
    CGColorSpaceRelease(v7);
    v6 = *(a2 + 40);
  }

  *(v6 + 264) = DeviceGray;
  v8 = *(v6 + 256);
  if (v8)
  {
    CFRelease(v8);
    v6 = *(a2 + 40);
  }

  *(v6 + 256) = v5;
  *(v6 + 9) = 1;
}

void op_EI_12377(CGPDFScanner *a1, uint64_t a2)
{
  value = 0;
  if (!CGPDFScannerPopStream(a1, &value))
  {
    return;
  }

  if (!value)
  {
    return;
  }

  v3 = *(value + 6);
  if (!v3)
  {
    return;
  }

  v47 = 0;
  if (!CGPDFDictionaryGetInteger(v3, "W", &v47) && !CGPDFDictionaryGetInteger(v3, "Width", &v47))
  {
    return;
  }

  v46 = 0;
  if (!CGPDFDictionaryGetInteger(v3, "H", &v46) && !CGPDFDictionaryGetInteger(v3, "Height", &v46))
  {
    return;
  }

  v45 = 0;
  if (!CGPDFDictionaryGetInteger(v3, "BPC", &v45) && !CGPDFDictionaryGetInteger(v3, "BitsPerComponent", &v45))
  {
    v45 = 0;
  }

  v44 = 0;
  if (!CGPDFDictionaryGetObject(v3, "CS", &v44) && !CGPDFDictionaryGetObject(v3, "ColorSpace", &v44))
  {
    v44 = 0;
  }

  v43 = 0;
  if (!CGPDFDictionaryGetBoolean(v3, "IM", &v43) && !CGPDFDictionaryGetBoolean(v3, "ImageMask", &v43))
  {
    v43 = 0;
  }

  v42 = 0;
  if (!CGPDFDictionaryGetBoolean(v3, "I", &v42) && !CGPDFDictionaryGetBoolean(v3, "Interpolate", &v42))
  {
    v42 = 0;
  }

  v41 = 0;
  v4 = CGPDFDictionaryGetArray(v3, "D", &v41) || CGPDFDictionaryGetArray(v3, "Decode", &v41);
  v40 = 0;
  if (v44 && !v43)
  {
    CreateColorSpaceFromInlineObject(v44, &v40);
  }

  if (!v4)
  {
    decode = 0;
    goto LABEL_50;
  }

  if (v41)
  {
    v5 = (*(v41 + 3) - *(v41 + 2)) >> 3;
  }

  else
  {
    v5 = 0;
  }

  v7 = v40;
  if (v40)
  {
    v8 = 2 * *(*(v40 + 3) + 48);
  }

  else
  {
    v8 = 0;
  }

  decode = 0;
  if (v5 && v5 == v8)
  {
    decode = malloc_type_malloc(8 * v5, 0x100004000313F17uLL);
    for (i = 0; i != v5; ++i)
    {
      v28[0] = 0.0;
      CGPDFArrayGetNumber(v41, i, v28);
      decode[i] = v28[0];
    }
  }

  if (v43)
  {
    v10 = 0;
  }

  else
  {
    v10 = v7 == 0;
  }

  if (v10)
  {
    switch(v5)
    {
      case 8:
        DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
        break;
      case 6:
        DeviceCMYK = CGColorSpaceCreateDeviceRGB();
        break;
      case 2:
        DeviceCMYK = CGColorSpaceCreateDeviceGray();
        break;
      default:
        goto LABEL_50;
    }

    v40 = DeviceCMYK;
  }

LABEL_50:
  format = CGPDFDataFormatRaw;
  v12 = CGPDFStreamCopyData(value, &format);
  if (v12)
  {
    v13 = v12;
    v14 = CGDataProviderCreateWithCFData(v12);
    if (!v14)
    {
      v18 = 0;
LABEL_72:
      CFRelease(v13);
      goto LABEL_73;
    }

    v15 = v14;
    intent = *(*(a2 + 40) + 308);
    if (format)
    {
      if (format == CGPDFDataFormatJPEG2000)
      {
        v19 = CFDictionaryCreate(*MEMORY[0x1E695E480], &kCGImageSourceTypeIdentifierHint, &kUTTypeJPEG2000, 1, MEMORY[0x1E695E9D8], MEMORY[0x1E695E9E8]);
        if (op_EI_predicate != -1)
        {
          dispatch_once(&op_EI_predicate, &__block_literal_global_12389);
        }

        v20 = op_EI_f(v13, v19);
        CFRelease(v19);
        if (v20)
        {
          if (op_EI_predicate_86 != -1)
          {
            dispatch_once(&op_EI_predicate_86, &__block_literal_global_88_12390);
          }

          v18 = op_EI_f_85(v20, 0, 0);
          CFRelease(v20);
          goto LABEL_71;
        }
      }

      else if (format == CGPDFDataFormatJPEGEncoded)
      {
        v17 = CGImageCreateWithJPEGDataProvider2(v14, 0, 0, v42 != 0, *(*(a2 + 40) + 308));
LABEL_66:
        v18 = v17;
LABEL_71:
        CGDataProviderRelease(v15);
        goto LABEL_72;
      }
    }

    else
    {
      if (v43)
      {
        v45 = 1;
        v17 = mask_create(v47, v46, 1uLL, 1uLL, vcvtps_u32_f32(vcvts_n_f32_s64(v47, 3uLL)), v14, 0, v42 != 0, 4);
        goto LABEL_66;
      }

      v18 = 0;
      v21 = v40;
      if (!v40)
      {
        goto LABEL_71;
      }

      v22 = v45;
      if (v45 < 1)
      {
        goto LABEL_71;
      }

      v23 = *(*(v40 + 3) + 48);
      v24 = v47;
      Length = CFDataGetLength(v13);
      if (Length >= v47 * v23 * v46 * v45 / 8)
      {
        v17 = CGImageCreate(v47, v46, v45, v22 * v23, vcvtps_u32_f32(vcvts_n_f32_u64(v22 * v23 * v24, 3uLL)), v21, 0, v15, decode, v42 != 0, intent);
        goto LABEL_66;
      }
    }

    v18 = 0;
    goto LABEL_71;
  }

  v18 = 0;
LABEL_73:
  if (v40)
  {
    CGColorSpaceRelease(v40);
  }

  if (decode)
  {
    free(decode);
  }

  v38 = 0;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v29 = 0u;
  v28[0] = 0.0;
  v28[1] = 0.0;
  v28[2] = v47;
  v28[3] = v46;
  v26 = *(a2 + 40);
  DWORD2(v32) = *(v26 + 308);
  *&v33 = v18;
  *(&v36 + 1) = *(v26 + 368);
  if (v43)
  {
    v27 = *(v26 + 256);
  }

  else
  {
    v27 = 0;
  }

  *(&v37 + 1) = v27;
  CPPDFContextAddImage(a2, v28);
  if (v18)
  {
    CFRelease(v18);
  }
}

void op_DP_12403(CGPDFScanner *a1)
{
  v3 = *(a1 + 18);
  if (v3 <= 0)
  {

    pdf_error("stack underflow.");
  }

  else
  {
    value[1] = v1;
    value[2] = v2;
    *(a1 + 18) = v3 - 1;
    CGPDFScannerPopName(a1, value);
  }
}

CGPDFReal op_d_12404(CGPDFScanner *a1, uint64_t a2)
{
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value))
  {
    v6 = 0;
    if (CGPDFScannerPopArray(a1, &v6))
    {
      v5 = *(a2 + 40);
      *(v5 + 360) = v6;
      result = value;
      *(v5 + 352) = value;
      *(v5 + 9) = 1;
    }
  }

  return result;
}

void op_Do_12405(CGPDFScanner *a1, uint64_t a2)
{
  v27 = 0;
  v28 = 0;
  v26 = 0;
  if (common_op_Do(a1, &v28, &v27, &v26))
  {
    v3 = v28;
    if (!strcmp(v28, "Image"))
    {
      v24 = 0.0;
      value = 0.0;
      v4 = v27;
      if (!CGPDFDictionaryGetNumber(v27, "Width", &value))
      {
        value = 0.0;
      }

      if (!CGPDFDictionaryGetNumber(v4, "Height", &v24))
      {
        v24 = 0.0;
      }

      v23 = 0;
      if (CGPDFDictionaryGetBoolean(v4, "ImageMask", &v23))
      {
        v5 = v23 == 0;
      }

      else
      {
        v23 = 0;
        v5 = 1;
      }

      v6 = 0;
      v15 = 0u;
      v7 = *(a2 + 40);
      DWORD2(v15) = *(v7 + 308);
      *&v15 = v26;
      v8 = *(v7 + 368);
      v19 = 0;
      v20 = v8;
      v22 = 0;
      v21 = 0u;
      v18 = 0u;
      v17 = 0u;
      v16 = 0u;
      v14 = 0u;
      v13 = 0u;
      v12 = 0u;
      v9 = 0uLL;
      v10 = value;
      v11 = v24;
      if (!v5)
      {
        v6 = *(v7 + 256);
      }

      *(&v21 + 1) = v6;
      CPPDFContextAddImage(a2, &v9);
    }

    else if (!strcmp(v3, "Form"))
    {
      DoPdfForm(a2, v26, 0);
    }
  }
}

void op_CS_12408(CGPDFScanner *a1, uint64_t a2)
{
  v3 = CPPDFCreateColorSpace(a1, a2);
  if (v3)
  {
    v4 = v3;
    v5 = *(a2 + 40);
    v6 = *(v5 + 280);
    if (v6)
    {
      CGColorSpaceRelease(v6);
      v5 = *(a2 + 40);
    }

    *(v5 + 280) = v4;
    *(v5 + 9) = 1;
  }
}

CGColorSpaceRef CPPDFCreateColorSpace(CGPDFScanner *a1, uint64_t a2)
{
  value = 0;
  v4 = 0;
  if (CGPDFScannerPopName(a1, &value))
  {
    if (value)
    {
      v10 = 0;
      CreateColorSpaceFromName(value, &v10);
      v4 = v10;
      if (!v10)
      {
        v5 = *(a1 + 7);
        if (v5 && (Resource = CGPDFContentStreamGetResource(v5, "ColorSpace", value)) != 0)
        {
          v7 = Resource;
          v8 = CFDictionaryGetValue(*(a2 + 2248), Resource);
          v12 = v8;
          if (v8)
          {
            v4 = v8;
            CFRetain(v8);
          }

          else
          {
            CreateColorSpaceFromObject(v7, &v12);
            v4 = v12;
            if (v12)
            {
              CFDictionaryAddValue(*(a2 + 2248), v7, v12);
            }
          }
        }

        else
        {
          return 0;
        }
      }
    }
  }

  return v4;
}

void op_cs_12409(CGPDFScanner *a1, uint64_t a2)
{
  v3 = CPPDFCreateColorSpace(a1, a2);
  if (v3)
  {
    v4 = v3;
    v5 = *(a2 + 40);
    v6 = *(v5 + 264);
    if (v6)
    {
      CGColorSpaceRelease(v6);
      v5 = *(a2 + 40);
    }

    *(v5 + 264) = v4;
    *(v5 + 9) = 1;
  }
}

double op_cm_12410(CGPDFScanner *a1, uint64_t a2)
{
  v5 = CGAffineTransformIdentity;
  if (common_ReadCGAffineTransform(a1, &v5.a))
  {
    v4 = v5;
    *&result = *&CPPDFContextConcatCTM(*(a2 + 40), &v4.a);
  }

  return result;
}

void op_c_12411(CGPDFScanner *a1, uint64_t a2)
{
  v8 = 0.0;
  v6 = 0.0;
  v7 = 0.0;
  v4 = 0.0;
  v5 = 0.0;
  y = 0.0;
  if (common_ReadCGPathCurve(a1, &v8, &v7, &v6, &v5, &v4, &y) && !CGPathIsEmpty(*(*(a2 + 40) + 64)))
  {
    CGPathAddCurveToPoint(*(*(a2 + 40) + 64), (*(a2 + 40) + 16), v8, v7, v6, v5, v4, y);
  }
}

uint64_t op_bstar_12413(uint64_t a1, uint64_t a2)
{
  op_h_12351(a1, a2);

  return CPPDFContextAddStrokeAndFill(a2, 0);
}

CGFloat op_BT_12414(uint64_t a1, uint64_t a2)
{
  result = CGAffineTransformIdentity.a;
  *(*(a2 + 40) + 88) = CGAffineTransformIdentity;
  *(*(a2 + 40) + 136) = CGAffineTransformIdentity;
  return result;
}

uint64_t op_EMC_12415(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    v2 = *(a2 + 2344);
    if (v2)
    {
      v3 = *(v2 + 16);
      if (v3)
      {
        return TaggedParser::EndMarkedContentSequence(*v3, *(a2 + 2288));
      }
    }
  }

  return result;
}

void op_BDC_12416(uint64_t a1, uint64_t a2)
{
  v4 = *(a1 + 72);
  if (v4 <= 0)
  {

    pdf_error("stack underflow.");
  }

  else
  {
    v5 = *(a1 + 80) + 40 * v4;
    *(a1 + 72) = v4 - 1;
    if (v5 == 40)
    {
      return;
    }

    value[5] = v2;
    value[6] = v3;
    v7 = *(v5 - 32);
    if (v7 == 8)
    {
      v9 = 0;
      v8 = *(v5 - 8);
    }

    else
    {
      if (v7 != 5)
      {
        return;
      }

      v8 = 0;
      v9 = *(v5 - 8);
    }

    value[0] = 0;
    v10 = CGPDFScannerPopName(a1, value);
    if (a2)
    {
      if (v10)
      {
        v12 = *(a2 + 2344);
        if (v12)
        {
          v13 = *(a2 + 2288);
          v14 = *(v12 + 16);
          if (v9)
          {
            if (v14)
            {
              TaggedParser::BeginMarkedContentSequence(v14, v13, v9, v11);
            }
          }

          else if (v14)
          {
            TaggedParser::BeginMarkedContentSequence(v14, v13, v8, v11);
          }
        }
      }
    }
  }
}

void op_BMC_12417(CGPDFScanner *a1, uint64_t a2)
{
  value = 0;
  v3 = CGPDFScannerPopName(a1, &value);
  if (a2)
  {
    if (v3)
    {
      v5 = *(a2 + 2344);
      if (v5)
      {
        v6 = *(v5 + 16);
        if (v6)
        {
          TaggedParser::BeginMarkedContentSequence(v6, *(a2 + 2288), 0, v4);
        }
      }
    }
  }
}

uint64_t op_b_12419(uint64_t a1, uint64_t a2)
{
  op_h_12351(a1, a2);

  return CPPDFContextAddStrokeAndFill(a2, 1);
}

uint64_t path_add(unsigned __int8 **a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || (v10 = *a1) == 0)
  {
    _CGHandleAssert("path_add", 94, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Paths/path-internal.c", "pathp != NULL && *pathp != NULL", "Element type (%d) added to NULL path %p", a6, a7, a8, a2);
  }

  if (a2 > 0xFFFFFFFD)
  {
    return 0;
  }

  if (a2 + 3 >= 8)
  {
    abort();
  }

  v12 = dword_1844E0C58[a2 + 3];
  v13 = *(v10 + 5);
  if ((a2 | 4) == 4)
  {
    v14 = *(v10 + 2);
    if (v14 < &v10[v13 + 48] && *v14 == a2)
    {
      return *(v10 + 4);
    }
  }

  else
  {
    v14 = *(v10 + 2);
  }

  if (*(v10 + 3) + 16 * v12 > (v14 - 1))
  {
    if ((2 * v13) >= 0x7D1)
    {
      v15 = *(v10 + 5);
    }

    else
    {
      v15 = 2 * v13;
    }

    v16 = malloc_type_malloc(v15 + 48, 0x1030040004372B3uLL);
    *v16 = v10;
    *(v16 + 1) = 0;
    *(v16 + 2) = &v16[v15 + 48];
    *(v16 + 3) = (v16 + 55) & 0xFFFFFFFFFFFFFFF8;
    *(v10 + 1) = v16;
    *(v16 + 4) = *(v10 + 4);
    *(v16 + 5) = v15;
    *a1 = v16;
    v14 = *(v16 + 2);
    v10 = v16;
  }

  *(v10 + 2) = v14 - 1;
  *(v14 - 1) = a2;
  result = *(v10 + 3);
  *(v10 + 3) = result + 16 * v12;
  if (!a2 || a2 == -3)
  {
    *(v10 + 4) = result;
  }

  return result;
}

void *path_reset(void *result)
{
  if (result)
  {
    v1 = result;
    result = *result;
    if (result)
    {
      v2 = *result;
      if (*result)
      {
        do
        {
          v3 = v2;
          free(result);
          v3[1] = 0;
          v2 = *v3;
          result = v3;
        }

        while (*v3);
      }

      else
      {
        v3 = result;
      }

      *v1 = v3;
      v4 = v3 + v3[5];
      v3[3] = (v3 + 55) & 0xFFFFFFFFFFFFFFF8;
      v3[4] = 0;
      v3[2] = v4 + 48;
    }
  }

  return result;
}

void path_free(void *a1)
{
  v1 = a1;
  if (a1)
  {
    path_reset(&v1);
    if (v1)
    {
      free(v1);
    }
  }
}

uint64_t path_element(uint64_t result)
{
  if (result)
  {
    v1 = *result;
    if (!*result)
    {
      *(result + 16) = 0;
      *(result + 24) = 0;
      *(result + 8) = 4;
      return 0;
    }

    v2 = *(result + 24);
    if (v2 && (v3 = *(result + 16)) != 0)
    {
      v4 = *(result + 8) + 3;
      if (v4 >= 8)
      {
        abort();
      }

      v5 = (v2 - 1);
      *(result + 16) = v3 + 16 * dword_1844E0C58[v4];
      *(result + 24) = v5;
      if (v5 >= v1[2])
      {
        *(result + 8) = *v5;
        return result;
      }

      v6 = v1[1];
      *result = v6;
      if (!v6)
      {
        *(result + 8) = 4;
        *(result + 16) = 0;
        *(result + 24) = 0;
        return 0;
      }
    }

    else
    {
      do
      {
        v6 = v1;
        v1 = *v1;
      }

      while (v1);
    }

    v7 = v6 + v6[5] + 47;
    *(result + 24) = v7;
    if (v7 < v6[2])
    {
      *result = 0;
      *(result + 8) = 4;
      *(result + 16) = 0;
      *(result + 24) = 0;
      return 0;
    }

    *result = v6;
    *(result + 8) = *v7;
    *(result + 16) = (v6 + 55) & 0xFFFFFFFFFFFFFFF8;
  }

  return result;
}

void *path_iterator_iterate(void *result, uint64_t a2)
{
  if (result && a2)
  {
    v2 = result;
    v5[0] = a2;
    v5[1] = 4;
    v5[2] = 0;
    v5[3] = 0;
    v3 = result[2];
    if (v3)
    {
      v3(result[1], 0, result[6]);
    }

    while (1)
    {
      result = path_element(v5);
      if (!result)
      {
        break;
      }

      (v2[3])(v2[1], *(result + 2), result[2], v2[6]);
    }

    v4 = v2[4];
    if (v4)
    {
      return v4(v2[1], v2[6]);
    }
  }

  return result;
}

void *path_iterator_unrollpath(void *result, unsigned __int8 **a2)
{
  if (a2)
  {
    v3 = *a2;
    if (*a2)
    {
      v4 = result;
      do
      {
        while (1)
        {
          v5 = *(v3 + 2);
          if (v5 >= &v3[*(v3 + 5) + 48])
          {
            break;
          }

          *(v3 + 2) = v5 + 1;
          v6 = *v5;
          if (v6 >= 5)
          {
            abort();
          }

          *(v3 + 3) -= 16 * dword_1844E0C58[v6 + 3];
          (v4[3])(v4[1]);
        }

        v3 = *v3;
      }

      while (v3);

      return path_reset(a2);
    }
  }

  return result;
}

uint64_t CGPDFPageLayoutGetTypeID()
{
  if (CGPDFPageLayoutGetTypeID::onceToken != -1)
  {
    dispatch_once(&CGPDFPageLayoutGetTypeID::onceToken, &__block_literal_global_12431);
  }

  return CGPDFPageLayoutGetTypeID::typeID;
}

uint64_t __CGPDFPageLayoutGetTypeID_block_invoke()
{
  result = pdf_register_cftype(&CGPDFPageLayoutGetTypeID::CGPDFPageLayoutType);
  CGPDFPageLayoutGetTypeID::typeID = result;
  return result;
}

void CGPDFPageLayoutFinalize(char *a1)
{
  if (a1[552] == 1)
  {
    v16[3] = v1;
    v17 = v2;
    std::__tree<std::__value_type<double,std::list<Span>>,std::__map_value_compare<double,std::__value_type<double,std::list<Span>>,std::less<double>,true>,std::allocator<std::__value_type<double,std::list<Span>>>>::destroy(*(a1 + 67));
    std::__tree<std::__value_type<double,std::list<Span>>,std::__map_value_compare<double,std::__value_type<double,std::list<Span>>,std::less<double>,true>,std::allocator<std::__value_type<double,std::list<Span>>>>::destroy(*(a1 + 64));
    v4 = *(a1 + 60);
    if (v4)
    {
      *(a1 + 61) = v4;
      operator delete(v4);
    }

    v5 = *(a1 + 57);
    if (v5)
    {
      *(a1 + 58) = v5;
      operator delete(v5);
    }

    std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::~__hash_table((a1 + 408));

    v16[0] = (a1 + 368);
    std::vector<std::shared_ptr<PageLayoutTable>>::__destroy_vector::operator()[abi:fe200100](v16);
    v6 = *(a1 + 43);
    if (v6)
    {
      *(a1 + 44) = v6;
      operator delete(v6);
    }

    v7 = *(a1 + 40);
    if (v7)
    {
      *(a1 + 41) = v7;
      operator delete(v7);
    }

    v16[0] = (a1 + 296);
    std::vector<std::pair<std::string,unsigned int>>::__destroy_vector::operator()[abi:fe200100](v16);
    v8 = *(a1 + 34);
    if (v8)
    {
      *(a1 + 35) = v8;
      operator delete(v8);
    }

    v9 = *(a1 + 31);
    if (v9)
    {
      *(a1 + 32) = v9;
      operator delete(v9);
    }

    v16[0] = (a1 + 224);
    std::vector<PageLayout::CharacterStyle>::__destroy_vector::operator()[abi:fe200100](v16);
    v10 = *(a1 + 25);
    if (v10)
    {
      *(a1 + 26) = v10;
      operator delete(v10);
    }

    v11 = *(a1 + 22);
    if (v11)
    {
      *(a1 + 23) = v11;
      operator delete(v11);
    }

    v12 = *(a1 + 19);
    if (v12)
    {
      *(a1 + 20) = v12;
      operator delete(v12);
    }

    v13 = *(a1 + 16);
    if (v13)
    {
      *(a1 + 17) = v13;
      operator delete(v13);
    }

    v14 = *(a1 + 13);
    if (v14)
    {
      *(a1 + 14) = v14;
      operator delete(v14);
    }

    v16[0] = (a1 + 80);
    std::vector<std::shared_ptr<TextLine>>::__destroy_vector::operator()[abi:fe200100](v16);
    v15 = *(a1 + 9);
  }
}