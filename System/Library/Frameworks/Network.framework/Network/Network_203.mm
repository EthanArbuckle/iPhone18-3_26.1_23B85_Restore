void ___ZL38nwsc_start_asquic_listener_for_requestP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_225(xpc_object_t *a1, void *a2)
{
  v25 = *MEMORY[0x1E69E9840];
  v3 = a2;
  WeakRetained = objc_loadWeakRetained(a1 + 5);
  v5 = objc_loadWeakRetained(a1 + 6);
  if (v5 && WeakRetained)
  {
    string_ptr = xpc_string_get_string_ptr(a1[4]);
    v7 = nw_dictionary_copy_value(WeakRetained[15], string_ptr);

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if (v7)
    {
      if (v9)
      {
        v10 = a1[4];
        *buf = 136446978;
        v18 = "nwsc_start_asquic_listener_for_request_block_invoke";
        v19 = 2114;
        v20 = WeakRetained;
        v21 = 2112;
        v22 = v10;
        v23 = 2112;
        v24 = v3;
        _os_log_impl(&dword_181A37000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ listener for service %@ received new connection %@", buf, 0x2Au);
      }

      v14[0] = MEMORY[0x1E69E9820];
      v14[1] = 3221225472;
      v14[2] = ___ZL38nwsc_start_asquic_listener_for_requestP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_226;
      v14[3] = &unk_1E6A3D958;
      v11 = v3;
      v15 = v11;
      v12 = WeakRetained;
      v16 = v12;
      nw_connection_set_state_changed_handler(v11, v14);
      nw_connection_set_queue(v11, v12[4]);
      nw_connection_start(v11);
      nw_service_connector_should_accept_connection(v12, v11, 1, a1[4]);
    }

    else
    {
      if (v9)
      {
        v13 = a1[4];
        *buf = 136446722;
        v18 = "nwsc_start_asquic_listener_for_request_block_invoke";
        v19 = 2114;
        v20 = WeakRetained;
        v21 = 2112;
        v22 = v13;
        _os_log_impl(&dword_181A37000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ listener for service %@ is not active, ignoring incoming request", buf, 0x20u);
      }

      nw_connection_cancel(v3);
    }
  }
}

void ___ZL38nwsc_start_asquic_listener_for_requestP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_2(uint64_t a1, int a2, void *a3)
{
  v24 = *MEMORY[0x1E69E9840];
  v5 = a3;
  WeakRetained = objc_loadWeakRetained((a1 + 48));
  v7 = objc_loadWeakRetained((a1 + 56));
  v8 = v7;
  if (*(a1 + 32))
  {
    v9 = v7 == 0;
  }

  else
  {
    v9 = 1;
  }

  if (!v9)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = *(a1 + 40);
      v12 = 136447490;
      v13 = "nwsc_start_asquic_listener_for_request_block_invoke_2";
      v14 = 2114;
      v15 = WeakRetained;
      v16 = 2112;
      v17 = v8;
      v18 = 2112;
      v19 = v11;
      v20 = 1024;
      v21 = a2;
      v22 = 2112;
      v23 = v5;
      _os_log_impl(&dword_181A37000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ connection group %@ for service %@ entered state %d error %@", &v12, 0x3Au);
    }

    if (a2 == 4)
    {
      nw_array_remove_object(WeakRetained[16], v8);
    }

    else if (a2 == 3)
    {
      nw_connection_group_cancel(v8);
    }
  }
}

void ___ZL38nwsc_start_asquic_listener_for_requestP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_226(uint64_t a1, int a2)
{
  if ((a2 & 0xFFFFFFFE) == 4)
  {
    nw_connection_cancel(*(a1 + 32));
    v5 = *(a1 + 32);
    v4 = *(a1 + 40);

    nwsc_cancel_connection_group_for_connection(v4, v5);
  }
}

void nw_service_connector_use_large_uuid_for_testing(void *a1, char a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = v3[4];
    block[0] = MEMORY[0x1E69E9820];
    block[1] = 3221225472;
    block[2] = __nw_service_connector_use_large_uuid_for_testing_block_invoke;
    block[3] = &unk_1E6A3A258;
    v15 = v3;
    v16 = a2;
    dispatch_async(v5, block);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_service_connector_use_large_uuid_for_testing";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_service_connector_use_large_uuid_for_testing";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_service_connector_use_large_uuid_for_testing";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_service_connector_use_large_uuid_for_testing";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_service_connector_use_large_uuid_for_testing";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void nw_service_connector_fail_connection_after_verification_fails_for_testing(void *a1, char a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = v3[4];
    block[0] = MEMORY[0x1E69E9820];
    block[1] = 3221225472;
    block[2] = __nw_service_connector_fail_connection_after_verification_fails_for_testing_block_invoke;
    block[3] = &unk_1E6A3A258;
    v15 = v3;
    v16 = a2;
    dispatch_async(v5, block);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void nw_service_connector_fail_connection_after_verification_passes_for_testing(void *a1, char a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = v3[4];
    block[0] = MEMORY[0x1E69E9820];
    block[1] = 3221225472;
    block[2] = __nw_service_connector_fail_connection_after_verification_passes_for_testing_block_invoke;
    block[3] = &unk_1E6A3A258;
    v15 = v3;
    v16 = a2;
    dispatch_async(v5, block);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void nw_service_connector_cancel(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[4];
    block[0] = MEMORY[0x1E69E9820];
    block[1] = 3221225472;
    block[2] = __nw_service_connector_cancel_block_invoke;
    block[3] = &unk_1E6A3D868;
    v13 = v1;
    dispatch_async(v3, block);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_service_connector_cancel";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_service_connector_cancel";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_service_connector_cancel";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_service_connector_cancel";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_service_connector_cancel";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void __nw_service_connector_cancel_block_invoke(uint64_t a1)
{
  v107 = *MEMORY[0x1E69E9840];
  v2 = *(*(a1 + 32) + 16);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = gLogObj;
  v4 = v3;
  if (v2 != 4)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(a1 + 32);
      *buf = 136446466;
      v102 = "nw_service_connector_cancel_block_invoke";
      v103 = 2114;
      v104 = v10;
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s Client cancelling %{public}@", buf, 0x16u);
    }

    v12 = *(a1 + 32);
    v13 = *(v12 + 56);
    if (v13)
    {
      nw_queue_cancel_source(v13, v11);
      *(*(a1 + 32) + 56) = 0;
      v12 = *(a1 + 32);
    }

    *(v12 + 16) = 4;
    v14 = *(a1 + 32);
    v15 = *(v14 + 8);
    if (v15)
    {
      nw_listener_cancel(v15);
      v16 = *(a1 + 32);
      v17 = *(v16 + 8);
      *(v16 + 8) = 0;

      v14 = *(a1 + 32);
    }

    v18 = *(v14 + 64);
    *(v14 + 64) = 0;

    v19 = *(a1 + 32);
    v20 = v19[11];
    if (v20)
    {
      v97[0] = MEMORY[0x1E69E9820];
      v97[1] = 3221225472;
      v97[2] = __nw_service_connector_cancel_block_invoke_110;
      v97[3] = &unk_1E6A39A98;
      v98 = v19;
      nw_dictionary_apply(v20, v97);
      v21 = *(a1 + 32);
      v22 = *(v21 + 88);
      *(v21 + 88) = 0;

      goto LABEL_15;
    }

    v40 = __nwlog_obj();
    v41 = *(a1 + 32);
    *buf = 136446466;
    v102 = "nw_service_connector_cancel_block_invoke_2";
    v103 = 2114;
    v104 = v41;
    v42 = _os_log_send_and_compose_impl();

    v100 = OS_LOG_TYPE_ERROR;
    v99 = 0;
    if (__nwlog_fault(v42, &v100, &v99))
    {
      if (v100 == OS_LOG_TYPE_FAULT)
      {
        v43 = __nwlog_obj();
        v44 = v100;
        if (os_log_type_enabled(v43, v100))
        {
          v45 = *(a1 + 32);
          *buf = 136446466;
          v102 = "nw_service_connector_cancel_block_invoke";
          v103 = 2114;
          v104 = v45;
          _os_log_impl(&dword_181A37000, v43, v44, "%{public}s %{public}@ trying to apply NULL activeConnections", buf, 0x16u);
        }
      }

      else if (v99 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v43 = __nwlog_obj();
        v64 = v100;
        v65 = os_log_type_enabled(v43, v100);
        if (backtrace_string)
        {
          if (v65)
          {
            v66 = *(a1 + 32);
            *buf = 136446722;
            v102 = "nw_service_connector_cancel_block_invoke";
            v103 = 2114;
            v104 = v66;
            v105 = 2082;
            v106 = backtrace_string;
            _os_log_impl(&dword_181A37000, v43, v64, "%{public}s %{public}@ trying to apply NULL activeConnections, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_91;
        }

        if (v65)
        {
          v87 = *(a1 + 32);
          *buf = 136446466;
          v102 = "nw_service_connector_cancel_block_invoke";
          v103 = 2114;
          v104 = v87;
          _os_log_impl(&dword_181A37000, v43, v64, "%{public}s %{public}@ trying to apply NULL activeConnections, no backtrace", buf, 0x16u);
        }
      }

      else
      {
        v43 = __nwlog_obj();
        v79 = v100;
        if (os_log_type_enabled(v43, v100))
        {
          v80 = *(a1 + 32);
          *buf = 136446466;
          v102 = "nw_service_connector_cancel_block_invoke";
          v103 = 2114;
          v104 = v80;
          _os_log_impl(&dword_181A37000, v43, v79, "%{public}s %{public}@ trying to apply NULL activeConnections, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }

LABEL_91:
    if (v42)
    {
      free(v42);
    }

LABEL_15:
    v23 = *(*(a1 + 32) + 96);
    if (v23)
    {
      v24 = nw_dictionary_copy(v23);
      v95[0] = MEMORY[0x1E69E9820];
      v95[1] = 3221225472;
      v95[2] = __nw_service_connector_cancel_block_invoke_113;
      v95[3] = &unk_1E6A39A98;
      v96 = *(a1 + 32);
      nw_dictionary_apply(v24, v95);

      v25 = *(*(a1 + 32) + 96);
      *(*(a1 + 32) + 96) = 0;

      goto LABEL_17;
    }

    v46 = __nwlog_obj();
    v47 = *(a1 + 32);
    *buf = 136446466;
    v102 = "nw_service_connector_cancel_block_invoke_2";
    v103 = 2114;
    v104 = v47;
    v48 = _os_log_send_and_compose_impl();

    v100 = OS_LOG_TYPE_ERROR;
    v99 = 0;
    if (__nwlog_fault(v48, &v100, &v99))
    {
      if (v100 == OS_LOG_TYPE_FAULT)
      {
        v49 = __nwlog_obj();
        v50 = v100;
        if (os_log_type_enabled(v49, v100))
        {
          v51 = *(a1 + 32);
          *buf = 136446466;
          v102 = "nw_service_connector_cancel_block_invoke";
          v103 = 2114;
          v104 = v51;
          _os_log_impl(&dword_181A37000, v49, v50, "%{public}s %{public}@ trying to apply NULL activeOutgoingRequests", buf, 0x16u);
        }
      }

      else if (v99 == 1)
      {
        v67 = __nw_create_backtrace_string();
        v49 = __nwlog_obj();
        v68 = v100;
        v69 = os_log_type_enabled(v49, v100);
        if (v67)
        {
          if (v69)
          {
            v70 = *(a1 + 32);
            *buf = 136446722;
            v102 = "nw_service_connector_cancel_block_invoke";
            v103 = 2114;
            v104 = v70;
            v105 = 2082;
            v106 = v67;
            _os_log_impl(&dword_181A37000, v49, v68, "%{public}s %{public}@ trying to apply NULL activeOutgoingRequests, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v67);
          goto LABEL_96;
        }

        if (v69)
        {
          v88 = *(a1 + 32);
          *buf = 136446466;
          v102 = "nw_service_connector_cancel_block_invoke";
          v103 = 2114;
          v104 = v88;
          _os_log_impl(&dword_181A37000, v49, v68, "%{public}s %{public}@ trying to apply NULL activeOutgoingRequests, no backtrace", buf, 0x16u);
        }
      }

      else
      {
        v49 = __nwlog_obj();
        v81 = v100;
        if (os_log_type_enabled(v49, v100))
        {
          v82 = *(a1 + 32);
          *buf = 136446466;
          v102 = "nw_service_connector_cancel_block_invoke";
          v103 = 2114;
          v104 = v82;
          _os_log_impl(&dword_181A37000, v49, v81, "%{public}s %{public}@ trying to apply NULL activeOutgoingRequests, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }

LABEL_96:
    if (v48)
    {
      free(v48);
    }

LABEL_17:
    v26 = *(*(a1 + 32) + 80);
    if (v26)
    {
      v27 = nw_dictionary_copy(v26);
      v93[0] = MEMORY[0x1E69E9820];
      v93[1] = 3221225472;
      v93[2] = __nw_service_connector_cancel_block_invoke_114;
      v93[3] = &unk_1E6A39A98;
      v94 = *(a1 + 32);
      nw_dictionary_apply(v27, v93);

      v28 = *(*(a1 + 32) + 80);
      *(*(a1 + 32) + 80) = 0;

      goto LABEL_19;
    }

    v52 = __nwlog_obj();
    v53 = *(a1 + 32);
    *buf = 136446466;
    v102 = "nw_service_connector_cancel_block_invoke_2";
    v103 = 2114;
    v104 = v53;
    v54 = _os_log_send_and_compose_impl();

    v100 = OS_LOG_TYPE_ERROR;
    v99 = 0;
    if (__nwlog_fault(v54, &v100, &v99))
    {
      if (v100 == OS_LOG_TYPE_FAULT)
      {
        v55 = __nwlog_obj();
        v56 = v100;
        if (os_log_type_enabled(v55, v100))
        {
          v57 = *(a1 + 32);
          *buf = 136446466;
          v102 = "nw_service_connector_cancel_block_invoke";
          v103 = 2114;
          v104 = v57;
          _os_log_impl(&dword_181A37000, v55, v56, "%{public}s %{public}@ trying to apply NULL pendingIncomingRequests", buf, 0x16u);
        }
      }

      else if (v99 == 1)
      {
        v71 = __nw_create_backtrace_string();
        v55 = __nwlog_obj();
        v72 = v100;
        v73 = os_log_type_enabled(v55, v100);
        if (v71)
        {
          if (v73)
          {
            v74 = *(a1 + 32);
            *buf = 136446722;
            v102 = "nw_service_connector_cancel_block_invoke";
            v103 = 2114;
            v104 = v74;
            v105 = 2082;
            v106 = v71;
            _os_log_impl(&dword_181A37000, v55, v72, "%{public}s %{public}@ trying to apply NULL pendingIncomingRequests, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v71);
          goto LABEL_101;
        }

        if (v73)
        {
          v89 = *(a1 + 32);
          *buf = 136446466;
          v102 = "nw_service_connector_cancel_block_invoke";
          v103 = 2114;
          v104 = v89;
          _os_log_impl(&dword_181A37000, v55, v72, "%{public}s %{public}@ trying to apply NULL pendingIncomingRequests, no backtrace", buf, 0x16u);
        }
      }

      else
      {
        v55 = __nwlog_obj();
        v83 = v100;
        if (os_log_type_enabled(v55, v100))
        {
          v84 = *(a1 + 32);
          *buf = 136446466;
          v102 = "nw_service_connector_cancel_block_invoke";
          v103 = 2114;
          v104 = v84;
          _os_log_impl(&dword_181A37000, v55, v83, "%{public}s %{public}@ trying to apply NULL pendingIncomingRequests, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }

LABEL_101:
    if (v54)
    {
      free(v54);
    }

LABEL_19:
    v29 = *(a1 + 32);
    v30 = v29[9];
    if (v30)
    {
      aBlock[0] = MEMORY[0x1E69E9820];
      aBlock[1] = 3221225472;
      aBlock[2] = __nw_service_connector_cancel_block_invoke_115;
      aBlock[3] = &unk_1E6A3CCB8;
      v92 = v29;
      _nw_array_apply(v30, aBlock);
      v31 = *(a1 + 32);
      v32 = *(v31 + 72);
      *(v31 + 72) = 0;

      return;
    }

    v58 = __nwlog_obj();
    v59 = *(a1 + 32);
    *buf = 136446466;
    v102 = "nw_service_connector_cancel_block_invoke_2";
    v103 = 2114;
    v104 = v59;
    v6 = _os_log_send_and_compose_impl();

    v100 = OS_LOG_TYPE_ERROR;
    v99 = 0;
    if (__nwlog_fault(v6, &v100, &v99))
    {
      if (v100 == OS_LOG_TYPE_FAULT)
      {
        v60 = __nwlog_obj();
        v61 = v100;
        if (os_log_type_enabled(v60, v100))
        {
          v62 = *(a1 + 32);
          *buf = 136446466;
          v102 = "nw_service_connector_cancel_block_invoke";
          v103 = 2114;
          v104 = v62;
          _os_log_impl(&dword_181A37000, v60, v61, "%{public}s %{public}@ trying to apply NULL pendingUnverifiedIncomingRequests", buf, 0x16u);
        }

LABEL_105:

        goto LABEL_33;
      }

      if (v99 != 1)
      {
        v60 = __nwlog_obj();
        v85 = v100;
        if (os_log_type_enabled(v60, v100))
        {
          v86 = *(a1 + 32);
          *buf = 136446466;
          v102 = "nw_service_connector_cancel_block_invoke";
          v103 = 2114;
          v104 = v86;
          _os_log_impl(&dword_181A37000, v60, v85, "%{public}s %{public}@ trying to apply NULL pendingUnverifiedIncomingRequests, backtrace limit exceeded", buf, 0x16u);
        }

        goto LABEL_105;
      }

      v75 = __nw_create_backtrace_string();
      v60 = __nwlog_obj();
      v76 = v100;
      v77 = os_log_type_enabled(v60, v100);
      if (!v75)
      {
        if (v77)
        {
          v90 = *(a1 + 32);
          *buf = 136446466;
          v102 = "nw_service_connector_cancel_block_invoke";
          v103 = 2114;
          v104 = v90;
          _os_log_impl(&dword_181A37000, v60, v76, "%{public}s %{public}@ trying to apply NULL pendingUnverifiedIncomingRequests, no backtrace", buf, 0x16u);
        }

        goto LABEL_105;
      }

      if (v77)
      {
        v78 = *(a1 + 32);
        *buf = 136446722;
        v102 = "nw_service_connector_cancel_block_invoke";
        v103 = 2114;
        v104 = v78;
        v105 = 2082;
        v106 = v75;
        _os_log_impl(&dword_181A37000, v60, v76, "%{public}s %{public}@ trying to apply NULL pendingUnverifiedIncomingRequests, dumping backtrace:%{public}s", buf, 0x20u);
      }

      free(v75);
    }

LABEL_33:
    if (!v6)
    {
      return;
    }

    goto LABEL_34;
  }

  v5 = *(a1 + 32);
  *buf = 136446466;
  v102 = "nw_service_connector_cancel_block_invoke";
  v103 = 2114;
  v104 = v5;
  v6 = _os_log_send_and_compose_impl();

  v100 = OS_LOG_TYPE_ERROR;
  v99 = 0;
  if (!__nwlog_fault(v6, &v100, &v99))
  {
    goto LABEL_33;
  }

  if (v100 == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    v8 = v100;
    if (os_log_type_enabled(v7, v100))
    {
      v9 = *(a1 + 32);
      *buf = 136446466;
      v102 = "nw_service_connector_cancel_block_invoke";
      v103 = 2114;
      v104 = v9;
      _os_log_impl(&dword_181A37000, v7, v8, "%{public}s %{public}@ already cancelled", buf, 0x16u);
    }

LABEL_32:

    goto LABEL_33;
  }

  if (v99 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    v37 = v100;
    if (os_log_type_enabled(v7, v100))
    {
      v38 = *(a1 + 32);
      *buf = 136446466;
      v102 = "nw_service_connector_cancel_block_invoke";
      v103 = 2114;
      v104 = v38;
      _os_log_impl(&dword_181A37000, v7, v37, "%{public}s %{public}@ already cancelled, backtrace limit exceeded", buf, 0x16u);
    }

    goto LABEL_32;
  }

  v33 = __nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = gLogObj;
  v34 = v100;
  v35 = os_log_type_enabled(v7, v100);
  if (!v33)
  {
    if (v35)
    {
      v39 = *(a1 + 32);
      *buf = 136446466;
      v102 = "nw_service_connector_cancel_block_invoke";
      v103 = 2114;
      v104 = v39;
      _os_log_impl(&dword_181A37000, v7, v34, "%{public}s %{public}@ already cancelled, no backtrace", buf, 0x16u);
    }

    goto LABEL_32;
  }

  if (v35)
  {
    v36 = *(a1 + 32);
    *buf = 136446722;
    v102 = "nw_service_connector_cancel_block_invoke";
    v103 = 2114;
    v104 = v36;
    v105 = 2082;
    v106 = v33;
    _os_log_impl(&dword_181A37000, v7, v34, "%{public}s %{public}@ already cancelled, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v33);
  if (v6)
  {
LABEL_34:
    free(v6);
  }
}

uint64_t __nw_service_connector_cancel_block_invoke_113(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  nw_service_connector_cancel_request_inner(*(a1 + 32), *(v4 + 1), v4 + 24, *(v4 + 72), 1);
  nw_service_connector_trigger_request_complete_block_inner(*(a1 + 32), v4, 0, 0, 89);

  return 1;
}

void nw_service_connector_start_request(void *a1, void *a2, const char *a3, void *a4, void *a5)
{
  v87 = *MEMORY[0x1E69E9840];
  v9 = a1;
  v10 = a2;
  v74 = a4;
  v11 = a5;
  v12 = v11;
  v73 = v10;
  if (!v9)
  {
    v49 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_service_connector_start_request";
    v50 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v82 = 0;
    if (!__nwlog_fault(v50, &type, &v82))
    {
      goto LABEL_138;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v51 = __nwlog_obj();
      v52 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A37000, v51, v52, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v82 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v51 = __nwlog_obj();
      v60 = type;
      v61 = os_log_type_enabled(v51, type);
      if (backtrace_string)
      {
        if (v61)
        {
          *buf = 136446466;
          *&buf[4] = "nw_service_connector_start_request";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v51, v60, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_138:
        if (!v50)
        {
          goto LABEL_71;
        }

LABEL_139:
        free(v50);
        goto LABEL_71;
      }

      if (v61)
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A37000, v51, v60, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v51 = __nwlog_obj();
      v69 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A37000, v51, v69, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_137:

    goto LABEL_138;
  }

  if (!v10)
  {
    v53 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_service_connector_start_request";
    v50 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v82 = 0;
    if (!__nwlog_fault(v50, &type, &v82))
    {
      goto LABEL_138;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v51 = __nwlog_obj();
      v54 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A37000, v51, v54, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_137;
    }

    if (v82 != 1)
    {
      v51 = __nwlog_obj();
      v70 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A37000, v51, v70, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_137;
    }

    v62 = __nw_create_backtrace_string();
    v51 = __nwlog_obj();
    v63 = type;
    v64 = os_log_type_enabled(v51, type);
    if (!v62)
    {
      if (v64)
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A37000, v51, v63, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_137;
    }

    if (v64)
    {
      *buf = 136446466;
      *&buf[4] = "nw_service_connector_start_request";
      *&buf[12] = 2082;
      *&buf[14] = v62;
      _os_log_impl(&dword_181A37000, v51, v63, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_112;
  }

  if (!a3)
  {
    v55 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_service_connector_start_request";
    v50 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v82 = 0;
    if (!__nwlog_fault(v50, &type, &v82))
    {
      goto LABEL_138;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v51 = __nwlog_obj();
      v56 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A37000, v51, v56, "%{public}s called with null userService", buf, 0xCu);
      }

      goto LABEL_137;
    }

    if (v82 != 1)
    {
      v51 = __nwlog_obj();
      v71 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A37000, v51, v71, "%{public}s called with null userService, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_137;
    }

    v62 = __nw_create_backtrace_string();
    v51 = __nwlog_obj();
    v65 = type;
    v66 = os_log_type_enabled(v51, type);
    if (!v62)
    {
      if (v66)
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A37000, v51, v65, "%{public}s called with null userService, no backtrace", buf, 0xCu);
      }

      goto LABEL_137;
    }

    if (v66)
    {
      *buf = 136446466;
      *&buf[4] = "nw_service_connector_start_request";
      *&buf[12] = 2082;
      *&buf[14] = v62;
      _os_log_impl(&dword_181A37000, v51, v65, "%{public}s called with null userService, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_112;
  }

  if (!v11)
  {
    v57 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_service_connector_start_request";
    v50 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v82 = 0;
    if (!__nwlog_fault(v50, &type, &v82))
    {
      goto LABEL_138;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v51 = __nwlog_obj();
      v58 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A37000, v51, v58, "%{public}s called with null requestBlock", buf, 0xCu);
      }

      goto LABEL_137;
    }

    if (v82 != 1)
    {
      v51 = __nwlog_obj();
      v72 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A37000, v51, v72, "%{public}s called with null requestBlock, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_137;
    }

    v62 = __nw_create_backtrace_string();
    v51 = __nwlog_obj();
    v67 = type;
    v68 = os_log_type_enabled(v51, type);
    if (!v62)
    {
      if (v68)
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A37000, v51, v67, "%{public}s called with null requestBlock, no backtrace", buf, 0xCu);
      }

      goto LABEL_137;
    }

    if (v68)
    {
      *buf = 136446466;
      *&buf[4] = "nw_service_connector_start_request";
      *&buf[12] = 2082;
      *&buf[14] = v62;
      _os_log_impl(&dword_181A37000, v51, v67, "%{public}s called with null requestBlock, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_112:

    free(v62);
    if (!v50)
    {
      goto LABEL_71;
    }

    goto LABEL_139;
  }

  v13 = v10;
  v14 = _nw_endpoint_get_type(v13);

  if (v14 != 1)
  {
    v15 = v13;
    v16 = _nw_endpoint_get_type(v15);

    if (v16 != 6)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = gLogObj;
      *buf = 136446466;
      *&buf[4] = "nw_service_connector_start_request";
      *&buf[12] = 2114;
      *&buf[14] = v15;
      v27 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v82 = 0;
      if (__nwlog_fault(v27, &type, &v82))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v28 = gLogObj;
          v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            *buf = 136446466;
            *&buf[4] = "nw_service_connector_start_request";
            *&buf[12] = 2114;
            *&buf[14] = v15;
            _os_log_impl(&dword_181A37000, v28, v29, "%{public}s Specified endpoint %{public}@ is not an address/appsvc endpoint", buf, 0x16u);
          }
        }

        else if (v82 == 1)
        {
          v37 = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v28 = gLogObj;
          v38 = type;
          v39 = os_log_type_enabled(v28, type);
          if (v37)
          {
            if (v39)
            {
              *buf = 136446722;
              *&buf[4] = "nw_service_connector_start_request";
              *&buf[12] = 2114;
              *&buf[14] = v15;
              *&buf[22] = 2082;
              *&v85 = v37;
              _os_log_impl(&dword_181A37000, v28, v38, "%{public}s Specified endpoint %{public}@ is not an address/appsvc endpoint, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v37);
            if (!v27)
            {
              goto LABEL_54;
            }

            goto LABEL_62;
          }

          if (v39)
          {
            *buf = 136446466;
            *&buf[4] = "nw_service_connector_start_request";
            *&buf[12] = 2114;
            *&buf[14] = v15;
            _os_log_impl(&dword_181A37000, v28, v38, "%{public}s Specified endpoint %{public}@ is not an address/appsvc endpoint, no backtrace", buf, 0x16u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v28 = gLogObj;
          v45 = type;
          if (os_log_type_enabled(v28, type))
          {
            *buf = 136446466;
            *&buf[4] = "nw_service_connector_start_request";
            *&buf[12] = 2114;
            *&buf[14] = v15;
            _os_log_impl(&dword_181A37000, v28, v45, "%{public}s Specified endpoint %{public}@ is not an address/appsvc endpoint, backtrace limit exceeded", buf, 0x16u);
          }
        }
      }

      if (!v27)
      {
        goto LABEL_54;
      }

LABEL_62:
      free(v27);
      goto LABEL_54;
    }
  }

  v17 = strlen(a3);
  if (v17 < 0x101)
  {
    v22 = v17;
    v23 = xpc_string_create(a3);
    if (v23)
    {
      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x3032000000;
      *&v85 = __Block_byref_object_copy__51955;
      *(&v85 + 1) = __Block_byref_object_dispose__51956;
      v24 = v74;
      v86 = v24;
      v25 = v9[4];
      block[0] = MEMORY[0x1E69E9820];
      block[1] = 3221225472;
      block[2] = __nw_service_connector_start_request_block_invoke;
      block[3] = &unk_1E6A349E8;
      v76 = v23;
      v77 = v9;
      v78 = v24;
      v79 = v13;
      v81 = buf;
      v80 = v12;
      dispatch_async(v25, block);

      _Block_object_dispose(buf, 8);
LABEL_70:

LABEL_71:
      v46 = v12;
      goto LABEL_72;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v33 = gLogObj;
    *buf = 136446466;
    *&buf[4] = "nw_service_connector_start_request";
    *&buf[12] = 2048;
    *&buf[14] = v22;
    v34 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v82 = 0;
    if (__nwlog_fault(v34, &type, &v82))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = gLogObj;
        v36 = type;
        if (os_log_type_enabled(v35, type))
        {
          *buf = 136446466;
          *&buf[4] = "nw_service_connector_start_request";
          *&buf[12] = 2048;
          *&buf[14] = v22;
          _os_log_impl(&dword_181A37000, v35, v36, "%{public}s xpc_string_create(%zu) failed", buf, 0x16u);
        }
      }

      else if (v82 == 1)
      {
        v41 = __nw_create_backtrace_string();
        if (v41)
        {
          v42 = v41;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v43 = gLogObj;
          v44 = type;
          if (os_log_type_enabled(v43, type))
          {
            *buf = 136446722;
            *&buf[4] = "nw_service_connector_start_request";
            *&buf[12] = 2048;
            *&buf[14] = v22;
            *&buf[22] = 2082;
            *&v85 = v42;
            _os_log_impl(&dword_181A37000, v43, v44, "%{public}s xpc_string_create(%zu) failed, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v42);
          if (!v34)
          {
            goto LABEL_69;
          }

          goto LABEL_68;
        }

        v35 = __nwlog_obj();
        v48 = type;
        if (os_log_type_enabled(v35, type))
        {
          *buf = 136446466;
          *&buf[4] = "nw_service_connector_start_request";
          *&buf[12] = 2048;
          *&buf[14] = v22;
          _os_log_impl(&dword_181A37000, v35, v48, "%{public}s xpc_string_create(%zu) failed, no backtrace", buf, 0x16u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = gLogObj;
        v47 = type;
        if (os_log_type_enabled(v35, type))
        {
          *buf = 136446466;
          *&buf[4] = "nw_service_connector_start_request";
          *&buf[12] = 2048;
          *&buf[14] = v22;
          _os_log_impl(&dword_181A37000, v35, v47, "%{public}s xpc_string_create(%zu) failed, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }

    if (!v34)
    {
LABEL_69:
      nw_service_connector_trigger_request_complete_block_inner(v9, 0, v12, 0, 12);
      goto LABEL_70;
    }

LABEL_68:
    free(v34);
    goto LABEL_69;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v18 = gLogObj;
  *buf = 136446722;
  *&buf[4] = "nw_service_connector_start_request";
  *&buf[12] = 2082;
  *&buf[14] = a3;
  *&buf[22] = 1024;
  LODWORD(v85) = 256;
  v19 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v82 = 0;
  if (__nwlog_fault(v19, &type, &v82))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *buf = 136446722;
        *&buf[4] = "nw_service_connector_start_request";
        *&buf[12] = 2082;
        *&buf[14] = a3;
        *&buf[22] = 1024;
        LODWORD(v85) = 256;
        _os_log_impl(&dword_181A37000, v20, v21, "%{public}s Service name %{public}s too long. Max allowed length is %d", buf, 0x1Cu);
      }
    }

    else if (v82 == 1)
    {
      v30 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      v31 = type;
      v32 = os_log_type_enabled(v20, type);
      if (v30)
      {
        if (v32)
        {
          *buf = 136446978;
          *&buf[4] = "nw_service_connector_start_request";
          *&buf[12] = 2082;
          *&buf[14] = a3;
          *&buf[22] = 1024;
          LODWORD(v85) = 256;
          WORD2(v85) = 2082;
          *(&v85 + 6) = v30;
          _os_log_impl(&dword_181A37000, v20, v31, "%{public}s Service name %{public}s too long. Max allowed length is %d, dumping backtrace:%{public}s", buf, 0x26u);
        }

        free(v30);
        if (!v19)
        {
          goto LABEL_54;
        }

        goto LABEL_53;
      }

      if (v32)
      {
        *buf = 136446722;
        *&buf[4] = "nw_service_connector_start_request";
        *&buf[12] = 2082;
        *&buf[14] = a3;
        *&buf[22] = 1024;
        LODWORD(v85) = 256;
        _os_log_impl(&dword_181A37000, v20, v31, "%{public}s Service name %{public}s too long. Max allowed length is %d, no backtrace", buf, 0x1Cu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      v40 = type;
      if (os_log_type_enabled(v20, type))
      {
        *buf = 136446722;
        *&buf[4] = "nw_service_connector_start_request";
        *&buf[12] = 2082;
        *&buf[14] = a3;
        *&buf[22] = 1024;
        LODWORD(v85) = 256;
        _os_log_impl(&dword_181A37000, v20, v40, "%{public}s Service name %{public}s too long. Max allowed length is %d, backtrace limit exceeded", buf, 0x1Cu);
      }
    }
  }

  if (v19)
  {
LABEL_53:
    free(v19);
  }

LABEL_54:
  v46 = v12;
  nw_service_connector_trigger_request_complete_block_inner(v9, 0, v12, 0, 22);
LABEL_72:
}

void __nw_service_connector_start_request_block_invoke(uint64_t a1)
{
  v79[2] = *MEMORY[0x1E69E9840];
  string_ptr = xpc_string_get_string_ptr(*(a1 + 32));
  v3 = *(a1 + 48);
  v4 = *(*(a1 + 40) + 16);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = gLogObj;
  v6 = v5;
  if (v4 != 4)
  {
    v11 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v11)
      {
        v13 = *(a1 + 48);
        v12 = *(a1 + 56);
        v14 = *(a1 + 40);
        *buf = 136447234;
        *&buf[4] = "nw_service_connector_start_request_block_invoke";
        *&buf[12] = 2114;
        *&buf[14] = v14;
        *&buf[22] = 2082;
        v77 = string_ptr;
        *v78 = 2114;
        *&v78[2] = v12;
        *&v78[10] = 2114;
        *&v78[12] = v13;
        v15 = "%{public}s %{public}@ client requesting service %{public}s to %{public}@ parameters %{public}@";
        v16 = v6;
        v17 = 52;
LABEL_14:
        _os_log_impl(&dword_181A37000, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
      }
    }

    else if (v11)
    {
      v20 = *(a1 + 40);
      v21 = *(a1 + 56);
      *buf = 136446978;
      *&buf[4] = "nw_service_connector_start_request_block_invoke";
      *&buf[12] = 2114;
      *&buf[14] = v20;
      *&buf[22] = 2082;
      v77 = string_ptr;
      *v78 = 2114;
      *&v78[2] = v21;
      v15 = "%{public}s %{public}@ client requesting service %{public}s to %{public}@";
      v16 = v6;
      v17 = 42;
      goto LABEL_14;
    }

    if (nw_endpoint_get_type(*(a1 + 56)) == (nw_endpoint_type_url|nw_endpoint_type_host) && !*(*(*(a1 + 72) + 8) + 40))
    {
      v22 = _nw_parameters_create();
      if (nw_parameters_configure_application_service_quic(v22))
      {
        v23 = v22;
      }

      else
      {
        v23 = 0;
      }

      v24 = *(*(a1 + 72) + 8);
      v25 = *(v24 + 40);
      *(v24 + 40) = v23;
    }

    if (nw_endpoint_get_type(*(a1 + 56)) != (nw_endpoint_type_url|nw_endpoint_type_host) || nw_endpoint_get_device_id(*(a1 + 56)))
    {
      nw_service_connector_start_request_inner(*(a1 + 40), *(a1 + 56), *(a1 + 32), *(*(*(a1 + 72) + 8) + 40), *(a1 + 64));
      return;
    }

    v26 = _nw_parameters_copy(*(*(*(a1 + 72) + 8) + 40));
    v27 = *(a1 + 56);
    v28 = v27;
    if (v27 && (v29 = v27, type = _nw_endpoint_get_type(v29), v29, type == 6))
    {
      v31 = v29;
      application_service_name = _nw_endpoint_get_application_service_name(v31);
    }

    else
    {
      application_service_name = 0;
    }

    v33 = *(a1 + 40);
    v66[0] = MEMORY[0x1E69E9820];
    v66[1] = 3221225472;
    v66[2] = __nw_service_connector_start_request_block_invoke_117;
    v66[3] = &unk_1E6A349C0;
    v67 = v33;
    v68 = *(a1 + 32);
    v65 = *(a1 + 64);
    v34 = v65;
    v69 = v65;
    v35 = v67;
    v36 = v26;
    v37 = v66;
    if (v35)
    {
      if (!application_service_name)
      {
        v50 = __nwlog_obj();
        *buf = 136446210;
        *&buf[4] = "nwsc_start_asquic_browse_for_service";
        v47 = _os_log_send_and_compose_impl();

        LOBYTE(state_changed_handler[0]) = 16;
        LOBYTE(location) = 0;
        if (!__nwlog_fault(v47, state_changed_handler, &location))
        {
          goto LABEL_89;
        }

        if (LOBYTE(state_changed_handler[0]) == 17)
        {
          v48 = __nwlog_obj();
          v51 = state_changed_handler[0];
          if (os_log_type_enabled(v48, state_changed_handler[0]))
          {
            *buf = 136446210;
            *&buf[4] = "nwsc_start_asquic_browse_for_service";
            _os_log_impl(&dword_181A37000, v48, v51, "%{public}s called with null service", buf, 0xCu);
          }

          goto LABEL_88;
        }

        if (location != 1)
        {
          v48 = __nwlog_obj();
          v63 = state_changed_handler[0];
          if (os_log_type_enabled(v48, state_changed_handler[0]))
          {
            *buf = 136446210;
            *&buf[4] = "nwsc_start_asquic_browse_for_service";
            _os_log_impl(&dword_181A37000, v48, v63, "%{public}s called with null service, backtrace limit exceeded", buf, 0xCu);
          }

          goto LABEL_88;
        }

        backtrace_string = __nw_create_backtrace_string();
        v48 = __nwlog_obj();
        v58 = state_changed_handler[0];
        v59 = os_log_type_enabled(v48, state_changed_handler[0]);
        if (!backtrace_string)
        {
          if (v59)
          {
            *buf = 136446210;
            *&buf[4] = "nwsc_start_asquic_browse_for_service";
            _os_log_impl(&dword_181A37000, v48, v58, "%{public}s called with null service, no backtrace", buf, 0xCu);
          }

          goto LABEL_88;
        }

        if (v59)
        {
          *buf = 136446466;
          *&buf[4] = "nwsc_start_asquic_browse_for_service";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v48, v58, "%{public}s called with null service, dumping backtrace:%{public}s", buf, 0x16u);
        }

        goto LABEL_69;
      }

      if (v36)
      {
        if (nw_utilities_get_self_name::onceToken != -1)
        {
          dispatch_once(&nw_utilities_get_self_name::onceToken, &__block_literal_global_11_47232);
        }

        application_service_with_bundle_id = nw_browse_descriptor_create_application_service_with_bundle_id(application_service_name, nw_utilities_get_self_name::name);
        nwsc_add_preferred_agent_to_parameters(v36, "ASResolver");
        v39 = nw_browser_create(application_service_with_bundle_id, v36);
        objc_initWeak(&location, v35);
        objc_initWeak(&from, v39);
        v40 = xpc_string_create(application_service_name);
        state_changed_handler[0] = MEMORY[0x1E69E9820];
        state_changed_handler[1] = 3221225472;
        state_changed_handler[2] = ___ZL36nwsc_start_asquic_browse_for_serviceP31NWConcrete_nw_service_connectorPKcPU27objcproto16OS_nw_parameters8NSObjectU13block_pointerFvPU25objcproto14OS_nw_endpointS3_E_block_invoke;
        state_changed_handler[3] = &unk_1E6A34C18;
        objc_copyWeak(&v72, &location);
        objc_copyWeak(&v73, &from);
        v41 = v40;
        v71 = v41;
        nw_browser_set_state_changed_handler(v39, state_changed_handler);
        *buf = MEMORY[0x1E69E9820];
        *&buf[8] = 3221225472;
        *&buf[16] = ___ZL36nwsc_start_asquic_browse_for_serviceP31NWConcrete_nw_service_connectorPKcPU27objcproto16OS_nw_parameters8NSObjectU13block_pointerFvPU25objcproto14OS_nw_endpointS3_E_block_invoke_230;
        v77 = &unk_1E6A34C40;
        objc_copyWeak(&v78[16], &from);
        objc_copyWeak(v79, &location);
        v42 = v41;
        *v78 = v42;
        *&v78[8] = v37;
        nw_browser_set_browse_results_changed_handler(v39, buf);
        nw_browser_set_queue(v39, *(v35 + 4));
        nw_browser_start(v39);
        v43 = *(v35 + 14);
        if (!v43)
        {
          v44 = _nw_array_create();
          v45 = *(v35 + 14);
          *(v35 + 14) = v44;

          v43 = *(v35 + 14);
        }

        if (v43 && v39)
        {
          _nw_array_append(v43, v39);
        }

        objc_destroyWeak(v79);
        objc_destroyWeak(&v78[16]);

        objc_destroyWeak(&v73);
        objc_destroyWeak(&v72);

        objc_destroyWeak(&from);
        objc_destroyWeak(&location);

        goto LABEL_39;
      }

      v52 = __nwlog_obj();
      *buf = 136446210;
      *&buf[4] = "nwsc_start_asquic_browse_for_service";
      v47 = _os_log_send_and_compose_impl();

      LOBYTE(state_changed_handler[0]) = 16;
      LOBYTE(location) = 0;
      if (__nwlog_fault(v47, state_changed_handler, &location))
      {
        if (LOBYTE(state_changed_handler[0]) == 17)
        {
          v48 = __nwlog_obj();
          v53 = state_changed_handler[0];
          if (os_log_type_enabled(v48, state_changed_handler[0]))
          {
            *buf = 136446210;
            *&buf[4] = "nwsc_start_asquic_browse_for_service";
            _os_log_impl(&dword_181A37000, v48, v53, "%{public}s called with null parameters", buf, 0xCu);
          }

LABEL_88:

          goto LABEL_89;
        }

        if (location != 1)
        {
          v48 = __nwlog_obj();
          v64 = state_changed_handler[0];
          if (os_log_type_enabled(v48, state_changed_handler[0]))
          {
            *buf = 136446210;
            *&buf[4] = "nwsc_start_asquic_browse_for_service";
            _os_log_impl(&dword_181A37000, v48, v64, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
          }

          goto LABEL_88;
        }

        backtrace_string = __nw_create_backtrace_string();
        v48 = __nwlog_obj();
        v60 = state_changed_handler[0];
        v61 = os_log_type_enabled(v48, state_changed_handler[0]);
        if (!backtrace_string)
        {
          if (v61)
          {
            *buf = 136446210;
            *&buf[4] = "nwsc_start_asquic_browse_for_service";
            _os_log_impl(&dword_181A37000, v48, v60, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
          }

          goto LABEL_88;
        }

        if (v61)
        {
          *buf = 136446466;
          *&buf[4] = "nwsc_start_asquic_browse_for_service";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v48, v60, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

LABEL_69:

        free(backtrace_string);
        if (!v47)
        {
          goto LABEL_39;
        }

        goto LABEL_90;
      }
    }

    else
    {
      v46 = __nwlog_obj();
      *buf = 136446210;
      *&buf[4] = "nwsc_start_asquic_browse_for_service";
      v47 = _os_log_send_and_compose_impl();

      LOBYTE(state_changed_handler[0]) = 16;
      LOBYTE(location) = 0;
      if (!__nwlog_fault(v47, state_changed_handler, &location))
      {
        goto LABEL_89;
      }

      if (LOBYTE(state_changed_handler[0]) == 17)
      {
        v48 = __nwlog_obj();
        v49 = state_changed_handler[0];
        if (os_log_type_enabled(v48, state_changed_handler[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nwsc_start_asquic_browse_for_service";
          _os_log_impl(&dword_181A37000, v48, v49, "%{public}s called with null serviceConnector", buf, 0xCu);
        }

        goto LABEL_88;
      }

      if (location != 1)
      {
        v48 = __nwlog_obj();
        v62 = state_changed_handler[0];
        if (os_log_type_enabled(v48, state_changed_handler[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nwsc_start_asquic_browse_for_service";
          _os_log_impl(&dword_181A37000, v48, v62, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_88;
      }

      v54 = __nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v55 = state_changed_handler[0];
      v56 = os_log_type_enabled(v48, state_changed_handler[0]);
      if (!v54)
      {
        if (v56)
        {
          *buf = 136446210;
          *&buf[4] = "nwsc_start_asquic_browse_for_service";
          _os_log_impl(&dword_181A37000, v48, v55, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
        }

        goto LABEL_88;
      }

      if (v56)
      {
        *buf = 136446466;
        *&buf[4] = "nwsc_start_asquic_browse_for_service";
        *&buf[12] = 2082;
        *&buf[14] = v54;
        _os_log_impl(&dword_181A37000, v48, v55, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v54);
    }

LABEL_89:
    if (!v47)
    {
LABEL_39:

      return;
    }

LABEL_90:
    free(v47);
    goto LABEL_39;
  }

  v7 = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
  if (v3)
  {
    if (v7)
    {
      v9 = *(a1 + 48);
      v8 = *(a1 + 56);
      v10 = *(a1 + 40);
      *buf = 136447234;
      *&buf[4] = "nw_service_connector_start_request_block_invoke";
      *&buf[12] = 2114;
      *&buf[14] = v10;
      *&buf[22] = 2082;
      v77 = string_ptr;
      *v78 = 2114;
      *&v78[2] = v8;
      *&v78[10] = 2114;
      *&v78[12] = v9;
      _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring client requesting service %{public}s to %{public}@ parameters %{public}@", buf, 0x34u);
    }
  }

  else if (v7)
  {
    v18 = *(a1 + 40);
    v19 = *(a1 + 56);
    *buf = 136446978;
    *&buf[4] = "nw_service_connector_start_request_block_invoke";
    *&buf[12] = 2114;
    *&buf[14] = v18;
    *&buf[22] = 2082;
    v77 = string_ptr;
    *v78 = 2114;
    *&v78[2] = v19;
    _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring client requesting service %{public}s to %{public}@", buf, 0x2Au);
  }
}

void ___ZL36nwsc_start_asquic_browse_for_serviceP31NWConcrete_nw_service_connectorPKcPU27objcproto16OS_nw_parameters8NSObjectU13block_pointerFvPU25objcproto14OS_nw_endpointS3_E_block_invoke(uint64_t a1, int a2, void *a3)
{
  v23 = *MEMORY[0x1E69E9840];
  v5 = a3;
  WeakRetained = objc_loadWeakRetained((a1 + 40));
  if (WeakRetained)
  {
    v7 = objc_loadWeakRetained((a1 + 48));
    if (v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(a1 + 32);
        v13 = 136447234;
        v14 = "nwsc_start_asquic_browse_for_service_block_invoke";
        v15 = 2114;
        v16 = WeakRetained;
        v17 = 2112;
        v18 = v9;
        v19 = 1024;
        v20 = a2;
        v21 = 2112;
        v22 = v5;
        _os_log_impl(&dword_181A37000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ browser for service %@ entered state %u error %@", &v13, 0x30u);
      }

      if ((a2 & 0xFFFFFFFE) == 2)
      {
        v10 = WeakRetained[14];
        if (v10)
        {
          v11 = v10;
          v12 = v7;
          _nw_array_remove_object(v11, v12);
        }
      }
    }
  }
}

void ___ZL36nwsc_start_asquic_browse_for_serviceP31NWConcrete_nw_service_connectorPKcPU27objcproto16OS_nw_parameters8NSObjectU13block_pointerFvPU25objcproto14OS_nw_endpointS3_E_block_invoke_230(uint64_t a1, void *a2, void *a3)
{
  v23 = *MEMORY[0x1E69E9840];
  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((a1 + 48));
  if (WeakRetained)
  {
    v8 = objc_loadWeakRetained((a1 + 56));
    if (v8)
    {
      changes = nw_browse_result_get_changes(v5, v6);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v11 = *(a1 + 32);
        v15 = 136446978;
        v16 = "nwsc_start_asquic_browse_for_service_block_invoke";
        v17 = 2114;
        v18 = v8;
        v19 = 2112;
        v20 = v11;
        v21 = 2048;
        v22 = changes;
        _os_log_impl(&dword_181A37000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ browser for service %@ results changed %llu", &v15, 0x2Au);
      }

      if (changes == 2)
      {
        v12 = nw_browse_result_copy_endpoint(v6);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          v14 = *(a1 + 32);
          v15 = 136446978;
          v16 = "nwsc_start_asquic_browse_for_service_block_invoke";
          v17 = 2114;
          v18 = v8;
          v19 = 2112;
          v20 = v14;
          v21 = 2112;
          v22 = v12;
          _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ browser for service %@ added endpoint %@", &v15, 0x2Au);
        }

        (*(*(a1 + 40) + 16))();
        nw_browser_cancel(WeakRetained);
      }
    }
  }
}

void nw_service_connector_start_request_inner(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  v139 = *MEMORY[0x1E69E9840];
  v9 = a1;
  v10 = a2;
  xstring = a3;
  v101 = a4;
  aBlock = a5;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v11 = gLogObj;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 136446978;
    *&buf[4] = "nw_service_connector_start_request_inner";
    *&buf[12] = 2114;
    *&buf[14] = v9;
    *&buf[22] = 2112;
    *&buf[24] = xstring;
    LOWORD(v113) = 2112;
    *(&v113 + 2) = v10;
    _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ starting request for service %@ with endpoint %@", buf, 0x2Au);
  }

  string_ptr = xpc_string_get_string_ptr(xstring);
  v13 = nw_service_connector_copy_pending_incoming_request(v9, v10, string_ptr);
  v14 = v13;
  if (v13 && (*(v13 + 616) & 4) == 0)
  {
    *(v13 + 616) |= 4u;
    if (v101)
    {
      nw_service_connector_apply_user_parameters(v9, v13, *(v13 + 72), v101);
    }

    v15 = v14[72];
    v102[0] = MEMORY[0x1E69E9820];
    v102[1] = 3221225472;
    v102[2] = ___ZL40nw_service_connector_start_request_innerP31NWConcrete_nw_service_connectorPU25objcproto14OS_nw_endpoint8NSObjectPU24objcproto13OS_xpc_objectS1_PU27objcproto16OS_nw_parametersS1_U13block_pointerFvP24NWConcrete_nw_connectionP9__CFErrorE_block_invoke;
    v102[3] = &unk_1E6A34B28;
    v16 = v9;
    v103 = v16;
    v105 = aBlock;
    v17 = v14;
    v104 = v17;
    nw_service_connector_accept_connection_for_request(v16, v15, v17, v102);
    nw_service_connector_reject_incoming_request(v16, v17, 0);

    v18 = v103;
    goto LABEL_114;
  }

  v19 = nw_service_connector_copy_active_connection_with_endpoint_and_service(v9, v10, string_ptr);
  v97 = v19;
  if (!v19)
  {
    goto LABEL_14;
  }

  connection = v19->connection;
  if (!connection || (v21 = connection, *type = 0, *&type[8] = type, *&type[16] = 0x2020000000, LOBYTE(v109) = 0, *buf = MEMORY[0x1E69E9820], *&buf[8] = 3221225472, *&buf[16] = __nw_connection_is_cancelled_or_failed_block_invoke, *&buf[24] = &unk_1E6A3D738, *(&v113 + 1) = type, v22 = v21, *&v113 = v22, os_unfair_lock_lock(v21 + 34), (*&buf[16])(buf), os_unfair_lock_unlock(v21 + 34), v23 = *(*&type[8] + 24), v113, _Block_object_dispose(type, 8), v22, (v23 & 1) != 0))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = gLogObj;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 136446722;
      *&buf[4] = "nw_service_connector_start_request_inner";
      *&buf[12] = 2114;
      *&buf[14] = v9;
      *&buf[22] = 2114;
      *&buf[24] = v97;
      _os_log_impl(&dword_181A37000, v24, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ cleaning up dead activeConnection %{public}@", buf, 0x20u);
    }

    nw_service_connector_cancel_request_inner(v9, v10, string_ptr, v97->connection, 0);
LABEL_14:
    v25 = 0;
    goto LABEL_15;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v46 = gLogObj;
  if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
  {
    *buf = 136446722;
    *&buf[4] = "nw_service_connector_start_request_inner";
    *&buf[12] = 2114;
    *&buf[14] = v9;
    *&buf[22] = 2114;
    *&buf[24] = v97;
    _os_log_impl(&dword_181A37000, v46, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ got request for already existing activeConnection %{public}@", buf, 0x20u);
  }

  v25 = 1;
LABEL_15:
  v98 = nw_service_connector_copy_active_outgoing_request(v9, v10, string_ptr);
  if (!v98)
  {
    goto LABEL_21;
  }

  v26 = *(v98 + 72);
  if (v26 && (nw_connection_is_cancelled(v26) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v47 = gLogObj;
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446722;
      *&buf[4] = "nw_service_connector_start_request_inner";
      *&buf[12] = 2114;
      *&buf[14] = v9;
      *&buf[22] = 2114;
      *&buf[24] = v98;
      _os_log_impl(&dword_181A37000, v47, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ we already have active request %{public}@", buf, 0x20u);
    }

    v48 = _Block_copy(*(v98 + 74));
    if (v48)
    {
      v49 = _Block_copy(aBlock);
      v50 = *(v98 + 74);
      *(v98 + 74) = v49;

      nw_service_connector_trigger_request_complete_block_inner(v9, 0, v48, 0, 36);
LABEL_113:

      v18 = v97;
LABEL_114:

      return;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v70 = gLogObj;
    *buf = 136446210;
    *&buf[4] = "nw_service_connector_start_request_inner";
    v71 = _os_log_send_and_compose_impl();

    type[0] = 16;
    v107 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v71, type, &v107))
    {
      goto LABEL_121;
    }

    if (type[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v72 = gLogObj;
      v73 = type[0];
      if (os_log_type_enabled(v72, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request_inner";
        _os_log_impl(&dword_181A37000, v72, v73, "%{public}s Found an old request without a request completion block", buf, 0xCu);
      }
    }

    else if (v107 == OS_LOG_TYPE_INFO)
    {
      backtrace_string = __nw_create_backtrace_string();
      v72 = __nwlog_obj();
      v77 = type[0];
      v78 = os_log_type_enabled(v72, type[0]);
      if (backtrace_string)
      {
        if (v78)
        {
          *buf = 136446466;
          *&buf[4] = "nw_service_connector_start_request_inner";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v72, v77, "%{public}s Found an old request without a request completion block, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_121;
      }

      if (v78)
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request_inner";
        _os_log_impl(&dword_181A37000, v72, v77, "%{public}s Found an old request without a request completion block, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v72 = __nwlog_obj();
      v82 = type[0];
      if (os_log_type_enabled(v72, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_service_connector_start_request_inner";
        _os_log_impl(&dword_181A37000, v72, v82, "%{public}s Found an old request without a request completion block, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_121:
    if (v71)
    {
      free(v71);
    }

    nw_service_connector_trigger_request_complete_block_inner(v9, 0, aBlock, 0, 36);
    goto LABEL_106;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v27 = gLogObj;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 136446722;
    *&buf[4] = "nw_service_connector_start_request_inner";
    *&buf[12] = 2114;
    *&buf[14] = v9;
    *&buf[22] = 2114;
    *&buf[24] = v98;
    _os_log_impl(&dword_181A37000, v27, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ cleaning up dead request %{public}@", buf, 0x20u);
  }

  nw_service_connector_cancel_request_inner(v9, v10, string_ptr, *(v98 + 72), 0);
LABEL_21:
  v28 = objc_alloc_init(NWConcrete_nw_unique_connection_request);
  v29 = v28;
  if (!v28)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v38 = gLogObj;
    *buf = 136446210;
    *&buf[4] = "nw_service_connector_start_request_inner";
    v39 = _os_log_send_and_compose_impl();

    type[0] = 16;
    v107 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v39, type, &v107))
    {
      if (type[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = gLogObj;
        v41 = type[0];
        if (os_log_type_enabled(v40, type[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_service_connector_start_request_inner";
          _os_log_impl(&dword_181A37000, v40, v41, "%{public}s [nw_unique_connection_request init:] failed", buf, 0xCu);
        }
      }

      else if (v107 == OS_LOG_TYPE_INFO)
      {
        v51 = __nw_create_backtrace_string();
        if (v51)
        {
          v52 = v51;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v53 = gLogObj;
          v54 = type[0];
          if (os_log_type_enabled(v53, type[0]))
          {
            *buf = 136446466;
            *&buf[4] = "nw_service_connector_start_request_inner";
            *&buf[12] = 2082;
            *&buf[14] = v52;
            _os_log_impl(&dword_181A37000, v53, v54, "%{public}s [nw_unique_connection_request init:] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v52);
          if (!v39)
          {
            goto LABEL_105;
          }

          goto LABEL_104;
        }

        v40 = __nwlog_obj();
        v79 = type[0];
        if (os_log_type_enabled(v40, type[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_service_connector_start_request_inner";
          _os_log_impl(&dword_181A37000, v40, v79, "%{public}s [nw_unique_connection_request init:] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = gLogObj;
        v69 = type[0];
        if (os_log_type_enabled(v40, type[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_service_connector_start_request_inner";
          _os_log_impl(&dword_181A37000, v40, v69, "%{public}s [nw_unique_connection_request init:] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v39)
    {
LABEL_105:
      nw_service_connector_trigger_request_complete_block_inner(v9, 0, aBlock, 0, 12);
LABEL_106:
      v48 = 0;
      goto LABEL_113;
    }

LABEL_104:
    free(v39);
    goto LABEL_105;
  }

  *(v28 + 616) &= ~1u;
  v30 = _Block_copy(aBlock);
  requestCompletionBlock = v29->requestCompletionBlock;
  v29->requestCompletionBlock = v30;

  objc_storeStrong(&v29->endpoint, a2);
  if (v101)
  {
    v32 = _nw_parameters_copy(v101);
    userParameters = v29->userParameters;
    v29->userParameters = v32;
  }

  if (!string_ptr)
  {
    v83 = __nwlog_obj();
    os_log_type_enabled(v83, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    *&buf[4] = "_strict_strlcat";
    v84 = _os_log_send_and_compose_impl();

    if (__nwlog_should_abort(v84))
    {
      goto LABEL_148;
    }

    free(v84);
  }

  v34 = 436;
  service = v29->service;
  while (*service)
  {
    ++service;
    if (!--v34)
    {
      if (!string_ptr)
      {
        v36 = __nwlog_obj();
        os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
        *buf = 136446210;
        *&buf[4] = "_strict_strlcpy";
        v37 = _os_log_send_and_compose_impl();

        if (__nwlog_should_abort(v37))
        {
          goto LABEL_148;
        }

        free(v37);
      }

LABEL_41:
      uuid = v29->uuid;
      v44 = v97;
      do
      {
        do
        {
          uuid_generate_random(v29->uuid);
        }

        while (!*uuid);
      }

      while (!*&v29->uuid[4] || !*&v29->uuid[8] || !*&v29->uuid[12]);
      if (*(v9 + 184))
      {
        v85 = __nwlog_obj();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 136446722;
          *&buf[4] = "nw_service_connector_start_request_inner";
          *&buf[12] = 2114;
          *&buf[14] = v9;
          *&buf[22] = 2114;
          *&buf[24] = v29;
          _os_log_impl(&dword_181A37000, v85, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ using large TEST UUID for request: %{public}@", buf, 0x20u);
        }

        *uuid = -1;
        v44 = v97;
      }

      if (nw_endpoint_get_type(v29->endpoint) == (nw_endpoint_type_url|nw_endpoint_type_host))
      {
        *(v29 + 617) |= 4u;
        nwsc_start_asquic_listener_for_request(v9, v29);
      }

      if (v25)
      {
        *(v29 + 616) |= 0x10u;
        nwsc_schedule_prexisting_connection_retry(v9, v29, v44, 0);
      }

      else if (v9->state == 1)
      {
        *(v29 + 616) |= 8u;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v45 = gLogObj;
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 136446722;
          *&buf[4] = "nw_service_connector_start_request_inner";
          *&buf[12] = 2114;
          *&buf[14] = v9;
          *&buf[22] = 2114;
          *&buf[24] = v29;
          _os_log_impl(&dword_181A37000, v45, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ holding request for listener ready: %{public}@", buf, 0x20u);
        }
      }

      else
      {
        v55 = nwsc_request_create_and_start_connection_inner(v9, v29, 0);
        v56 = v55 == 0;

        if (v56)
        {
          nw_service_connector_cancel_request_inner(v9, v29->endpoint, v29->service, 0, 0);
          nw_service_connector_trigger_request_complete_block_inner(v9, v29, 0, 0, 12);
          v48 = v29;
          goto LABEL_113;
        }
      }

      v57 = v9;
      v48 = v29;
      if (v57[12])
      {
        v138 = 0;
        v136 = 0u;
        v137 = 0u;
        v134 = 0u;
        v135 = 0u;
        v132 = 0u;
        v133 = 0u;
        v130 = 0u;
        v131 = 0u;
        v128 = 0u;
        v129 = 0u;
        v126 = 0u;
        v127 = 0u;
        v124 = 0u;
        v125 = 0u;
        v122 = 0u;
        v123 = 0u;
        v120 = 0u;
        v121 = 0u;
        v118 = 0u;
        v119 = 0u;
        v116 = 0u;
        v117 = 0u;
        v114 = 0u;
        v115 = 0u;
        v113 = 0u;
        memset(buf, 0, sizeof(buf));
        if (nwsc_get_identifier(v29->endpoint, v29->service, buf, 0x1B4uLL))
        {
          nw_dictionary_set_value(v57[12], buf, v48);
LABEL_112:

          goto LABEL_113;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v95 = v57;
        v58 = gLogObj;
        endpoint = v29->endpoint;
        *type = 136446722;
        *&type[4] = "nw_service_connector_add_active_outgoing_request";
        *&type[12] = 2114;
        *&type[14] = endpoint;
        *&type[22] = 2082;
        v109 = v29->service;
        v60 = _os_log_send_and_compose_impl();

        v57 = v95;
        v107 = OS_LOG_TYPE_ERROR;
        v106 = 0;
        if (__nwlog_fault(v60, &v107, &v106))
        {
          if (v107 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v61 = gLogObj;
            v62 = v107;
            if (os_log_type_enabled(v61, v107))
            {
              v63 = v29->endpoint;
              *type = 136446722;
              *&type[4] = "nw_service_connector_add_active_outgoing_request";
              *&type[12] = 2114;
              *&type[14] = v63;
              *&type[22] = 2082;
              v109 = v29->service;
              _os_log_impl(&dword_181A37000, v61, v62, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s", type, 0x20u);
            }

            goto LABEL_109;
          }

          if (v106 == 1)
          {
            v64 = __nw_create_backtrace_string();
            if (v64)
            {
              v65 = v64;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v66 = gLogObj;
              v67 = v107;
              if (os_log_type_enabled(v66, v107))
              {
                v68 = v29->endpoint;
                *type = 136446978;
                *&type[4] = "nw_service_connector_add_active_outgoing_request";
                *&type[12] = 2114;
                *&type[14] = v68;
                *&type[22] = 2082;
                v109 = v29->service;
                v110 = 2082;
                v111 = v65;
                _os_log_impl(&dword_181A37000, v66, v67, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s", type, 0x2Au);
              }

              v57 = v95;
              free(v65);
              if (!v60)
              {
                goto LABEL_112;
              }

              goto LABEL_111;
            }

            v61 = __nwlog_obj();
            v80 = v107;
            if (os_log_type_enabled(v61, v107))
            {
              v81 = v29->endpoint;
              *type = 136446722;
              *&type[4] = "nw_service_connector_add_active_outgoing_request";
              *&type[12] = 2114;
              *&type[14] = v81;
              *&type[22] = 2082;
              v109 = v29->service;
              _os_log_impl(&dword_181A37000, v61, v80, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace", type, 0x20u);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v61 = gLogObj;
            v74 = v107;
            if (os_log_type_enabled(v61, v107))
            {
              v75 = v29->endpoint;
              *type = 136446722;
              *&type[4] = "nw_service_connector_add_active_outgoing_request";
              *&type[12] = 2114;
              *&type[14] = v75;
              *&type[22] = 2082;
              v109 = v29->service;
              _os_log_impl(&dword_181A37000, v61, v74, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded", type, 0x20u);
            }
          }

LABEL_109:

          v57 = v95;
        }

LABEL_110:
        if (!v60)
        {
          goto LABEL_112;
        }

LABEL_111:
        free(v60);
        goto LABEL_112;
      }

      __nwlog_obj();
      v87 = v86 = v57;
      *buf = 136446210;
      *&buf[4] = "nw_service_connector_add_active_outgoing_request";
      v60 = _os_log_send_and_compose_impl();

      v57 = v86;
      type[0] = 16;
      v107 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v60, type, &v107))
      {
        goto LABEL_110;
      }

      if (type[0] == 17)
      {
        v88 = __nwlog_obj();
        v89 = type[0];
        if (os_log_type_enabled(v88, type[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_service_connector_add_active_outgoing_request";
          _os_log_impl(&dword_181A37000, v88, v89, "%{public}s called with null serviceConnector->activeOutgoingRequests", buf, 0xCu);
        }
      }

      else if (v107 == OS_LOG_TYPE_INFO)
      {
        v91 = __nw_create_backtrace_string();
        v88 = __nwlog_obj();
        v92 = type[0];
        v93 = os_log_type_enabled(v88, type[0]);
        if (v91)
        {
          if (v93)
          {
            *buf = 136446466;
            *&buf[4] = "nw_service_connector_add_active_outgoing_request";
            *&buf[12] = 2082;
            *&buf[14] = v91;
            _os_log_impl(&dword_181A37000, v88, v92, "%{public}s called with null serviceConnector->activeOutgoingRequests, dumping backtrace:%{public}s", buf, 0x16u);
          }

          v57 = v86;
          free(v91);
          goto LABEL_110;
        }

        if (v93)
        {
          *buf = 136446210;
          *&buf[4] = "nw_service_connector_add_active_outgoing_request";
          _os_log_impl(&dword_181A37000, v88, v92, "%{public}s called with null serviceConnector->activeOutgoingRequests, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v88 = __nwlog_obj();
        v94 = type[0];
        if (os_log_type_enabled(v88, type[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_service_connector_add_active_outgoing_request";
          _os_log_impl(&dword_181A37000, v88, v94, "%{public}s called with null serviceConnector->activeOutgoingRequests, backtrace limit exceeded", buf, 0xCu);
        }
      }

      v57 = v86;
      goto LABEL_110;
    }
  }

  if (string_ptr)
  {
    if (v34 >= 2)
    {
      goto LABEL_38;
    }

    goto LABEL_40;
  }

  v96 = __nwlog_obj();
  os_log_type_enabled(v96, OS_LOG_TYPE_ERROR);
  *buf = 136446210;
  *&buf[4] = "_strict_strlcpy";
  v90 = _os_log_send_and_compose_impl();

  if (!__nwlog_should_abort(v90))
  {
    free(v90);
    if (v34 >= 2)
    {
LABEL_38:
      do
      {
        v42 = *string_ptr;
        *service = v42;
        if (!v42)
        {
          goto LABEL_41;
        }

        ++service;
        ++string_ptr;
      }

      while (--v34 > 1);
    }

LABEL_40:
    *service = 0;
    goto LABEL_41;
  }

LABEL_148:
  __break(1u);
}

void ___ZL40nw_service_connector_start_request_innerP31NWConcrete_nw_service_connectorPU25objcproto14OS_nw_endpoint8NSObjectPU24objcproto13OS_xpc_objectS1_PU27objcproto16OS_nw_parametersS1_U13block_pointerFvP24NWConcrete_nw_connectionP9__CFErrorE_block_invoke(uint64_t a1, int a2)
{
  v18 = *MEMORY[0x1E69E9840];
  if (a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *(a1 + 32);
      v6 = *(a1 + 40);
      v10 = 136446978;
      v11 = "nw_service_connector_start_request_inner_block_invoke";
      v12 = 2114;
      v13 = v5;
      v14 = 2114;
      v15 = v6;
      v16 = 1024;
      v17 = a2;
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ error when accepting request %{public}@ %{darwin.errno}d", &v10, 0x26u);
    }

    nw_service_connector_cancel_request_inner(*(a1 + 32), *(*(a1 + 40) + 8), (*(a1 + 40) + 24), *(*(a1 + 40) + 576), 0);
    nw_service_connector_trigger_request_complete_block_inner(*(a1 + 32), 0, *(a1 + 48), 0, a2);
  }

  else
  {
    v7 = *(a1 + 48);
    v8 = *(a1 + 32);
    v9 = *(*(a1 + 40) + 576);

    nw_service_connector_trigger_request_complete_block_inner(v8, 0, v7, v9, 0);
  }
}

void nwsc_schedule_prexisting_connection_retry(NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2, NWConcrete_nw_unique_connection *a3, unsigned int a4)
{
  v30 = *MEMORY[0x1E69E9840];
  v7 = a1;
  v8 = a2;
  v10 = a3;
  if (a4 < 0x14)
  {
    preexistingConnectionTimer = v8->preexistingConnectionTimer;
    if (preexistingConnectionTimer)
    {
      nw_queue_cancel_source(preexistingConnectionTimer, v9);
      v8->preexistingConnectionTimer = 0;
    }

    objc_initWeak(buf, v8);
    v17[0] = MEMORY[0x1E69E9820];
    v17[1] = 3221225472;
    v17[2] = ___ZL41nwsc_schedule_prexisting_connection_retryP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP31NWConcrete_nw_unique_connectionj_block_invoke;
    v17[3] = &unk_1E6A34B50;
    v18 = v7;
    objc_copyWeak(&v20, buf);
    v19 = v10;
    v21 = a4;
    source = nw_queue_context_create_source(0, 2, 3, 0, v17, 0);
    v8->preexistingConnectionTimer = source;
    v14 = source;
    v15 = dispatch_time(0x8000000000000000, 100000000);
    nw_queue_set_timer_values(v14, v15, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    nw_queue_activate_source(v8->preexistingConnectionTimer, v16);

    objc_destroyWeak(&v20);
    objc_destroyWeak(buf);
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446978;
      v23 = "nwsc_schedule_prexisting_connection_retry";
      v24 = 2114;
      v25 = v7;
      v26 = 2114;
      v27 = v8;
      v28 = 2114;
      v29 = v10;
      _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ request %{public}@ still has existing activeConnection %{public}@", buf, 0x2Au);
    }

    nw_service_connector_cancel_request_inner(v7, v8->endpoint, v8->service, 0, 0);
    nw_service_connector_trigger_request_complete_block_inner(v7, v8, 0, 0, 17);
  }
}

void sub_182844F74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak((v20 + 48));

  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void ___ZL41nwsc_schedule_prexisting_connection_retryP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP31NWConcrete_nw_unique_connectionj_block_invoke(uint64_t a1)
{
  v2 = *(*(a1 + 32) + 32);
  v3[0] = MEMORY[0x1E69E9820];
  v3[1] = 3221225472;
  v3[2] = ___ZL41nwsc_schedule_prexisting_connection_retryP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP31NWConcrete_nw_unique_connectionj_block_invoke_2;
  v3[3] = &unk_1E6A34B50;
  objc_copyWeak(&v6, (a1 + 48));
  v4 = *(a1 + 32);
  v5 = *(a1 + 40);
  v7 = *(a1 + 56);
  dispatch_async(v2, v3);

  objc_destroyWeak(&v6);
}

void ___ZL41nwsc_schedule_prexisting_connection_retryP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP31NWConcrete_nw_unique_connectionj_block_invoke_2(uint64_t a1)
{
  v25 = *MEMORY[0x1E69E9840];
  WeakRetained = objc_loadWeakRetained((a1 + 48));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    if (*(*(a1 + 32) + 16) == 4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v5 = *(a1 + 32);
        *buf = 136446466;
        *&buf[4] = "nwsc_schedule_prexisting_connection_retry_block_invoke_2";
        *&buf[12] = 2114;
        *&buf[14] = v5;
        _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring connection retry", buf, 0x16u);
      }
    }

    else if ((*(WeakRetained + 616) & 0x10) != 0)
    {
      v6 = *(*(a1 + 40) + 488);
      if (v6 && (v7 = v6, v18 = 0, v19 = &v18, v20 = 0x2020000000, v21 = 0, *buf = MEMORY[0x1E69E9820], *&buf[8] = 3221225472, *&buf[16] = __nw_connection_is_cancelled_or_failed_block_invoke, v23 = &unk_1E6A3D738, *(&v24 + 1) = &v18, v8 = v7, *&v24 = v8, os_unfair_lock_lock(v7 + 34), (*&buf[16])(buf), os_unfair_lock_unlock(v7 + 34), LOBYTE(v7) = *(v19 + 24), v24, _Block_object_dispose(&v18, 8), v8, (v7 & 1) == 0))
      {
        nwsc_schedule_prexisting_connection_retry(*(a1 + 32), v3, *(a1 + 40), *(a1 + 56) + 1);
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          v10 = *(a1 + 32);
          v11 = *(a1 + 40);
          *buf = 136446978;
          *&buf[4] = "nwsc_schedule_prexisting_connection_retry_block_invoke";
          *&buf[12] = 2114;
          *&buf[14] = v10;
          *&buf[22] = 2114;
          v23 = v3;
          LOWORD(v24) = 2114;
          *(&v24 + 2) = v11;
          _os_log_impl(&dword_181A37000, v9, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ restarting request %{public}@ with inactive activeConnection %{public}@", buf, 0x2Au);
        }

        v12 = *(a1 + 40);
        p_super = &v12->connection->super;
        if (p_super)
        {
          nw_connection_cancel(p_super);
          v14 = *(a1 + 40);
          v15 = *(v14 + 488);
          *(v14 + 488) = 0;

          v12 = *(a1 + 40);
        }

        nw_service_connector_remove_active_connection(*(a1 + 32), v12);
        *(v3 + 616) &= ~0x10u;
        v16 = nwsc_request_create_and_start_connection_inner(*(a1 + 32), v3, 0);
        v17 = v16 == 0;

        if (v17)
        {
          nw_service_connector_cancel_request_inner(*(a1 + 32), v3->endpoint, v3->service, 0, 0);
          nw_service_connector_trigger_request_complete_block_inner(*(a1 + 32), v3, 0, 0, 12);
        }
      }
    }
  }
}

void nw_service_connector_cancel_request(void *a1, void *a2, const char *a3)
{
  v60[2] = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a2;
  v7 = v6;
  if (!v5)
  {
    v31 = __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_service_connector_cancel_request";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v10, &type, &v53))
    {
      goto LABEL_35;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v32 = __nwlog_obj();
      v33 = type;
      if (os_log_type_enabled(v32, type))
      {
        *buf = 136446210;
        v56 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_181A37000, v32, v33, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v53 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v39 = type;
      v40 = os_log_type_enabled(v32, type);
      if (backtrace_string)
      {
        if (v40)
        {
          *buf = 136446466;
          v56 = "nw_service_connector_cancel_request";
          v57 = 2082;
          v58 = backtrace_string;
          _os_log_impl(&dword_181A37000, v32, v39, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }

      if (v40)
      {
        *buf = 136446210;
        v56 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_181A37000, v32, v39, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v32 = __nwlog_obj();
      v46 = type;
      if (os_log_type_enabled(v32, type))
      {
        *buf = 136446210;
        v56 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_181A37000, v32, v46, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_95:

    goto LABEL_35;
  }

  if (!v6)
  {
    v34 = __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_service_connector_cancel_request";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v10, &type, &v53))
    {
      goto LABEL_35;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v32 = __nwlog_obj();
      v35 = type;
      if (os_log_type_enabled(v32, type))
      {
        *buf = 136446210;
        v56 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_181A37000, v32, v35, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_95;
    }

    if (v53 != 1)
    {
      v32 = __nwlog_obj();
      v47 = type;
      if (os_log_type_enabled(v32, type))
      {
        *buf = 136446210;
        v56 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_181A37000, v32, v47, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_95;
    }

    v41 = __nw_create_backtrace_string();
    v32 = __nwlog_obj();
    v42 = type;
    v43 = os_log_type_enabled(v32, type);
    if (!v41)
    {
      if (v43)
      {
        *buf = 136446210;
        v56 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_181A37000, v32, v42, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_95;
    }

    if (v43)
    {
      *buf = 136446466;
      v56 = "nw_service_connector_cancel_request";
      v57 = 2082;
      v58 = v41;
      _os_log_impl(&dword_181A37000, v32, v42, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_76;
  }

  if (!a3)
  {
    v36 = __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_service_connector_cancel_request";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v10, &type, &v53))
    {
      goto LABEL_35;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v32 = __nwlog_obj();
      v37 = type;
      if (os_log_type_enabled(v32, type))
      {
        *buf = 136446210;
        v56 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_181A37000, v32, v37, "%{public}s called with null userService", buf, 0xCu);
      }

      goto LABEL_95;
    }

    if (v53 != 1)
    {
      v32 = __nwlog_obj();
      v48 = type;
      if (os_log_type_enabled(v32, type))
      {
        *buf = 136446210;
        v56 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_181A37000, v32, v48, "%{public}s called with null userService, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_95;
    }

    v41 = __nw_create_backtrace_string();
    v32 = __nwlog_obj();
    v44 = type;
    v45 = os_log_type_enabled(v32, type);
    if (!v41)
    {
      if (v45)
      {
        *buf = 136446210;
        v56 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_181A37000, v32, v44, "%{public}s called with null userService, no backtrace", buf, 0xCu);
      }

      goto LABEL_95;
    }

    if (v45)
    {
      *buf = 136446466;
      v56 = "nw_service_connector_cancel_request";
      v57 = 2082;
      v58 = v41;
      _os_log_impl(&dword_181A37000, v32, v44, "%{public}s called with null userService, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_76:

    free(v41);
    if (!v10)
    {
      goto LABEL_46;
    }

    goto LABEL_36;
  }

  v8 = strlen(a3);
  if (v8 < 0x101)
  {
    v13 = v8;
    v14 = xpc_string_create(a3);
    v15 = v14;
    if (v14)
    {
      v16 = v5[4];
      block[0] = MEMORY[0x1E69E9820];
      block[1] = 3221225472;
      block[2] = __nw_service_connector_cancel_request_block_invoke;
      block[3] = &unk_1E6A3B4E0;
      v50 = v14;
      v51 = v5;
      v52 = v7;
      dispatch_async(v16, block);

LABEL_45:
      goto LABEL_46;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = gLogObj;
    *buf = 136446466;
    v56 = "nw_service_connector_cancel_request";
    v57 = 2048;
    v58 = v13;
    v21 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (__nwlog_fault(v21, &type, &v53))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446466;
          v56 = "nw_service_connector_cancel_request";
          v57 = 2048;
          v58 = v13;
          _os_log_impl(&dword_181A37000, v22, v23, "%{public}s xpc_string_create(%zu) failed", buf, 0x16u);
        }
      }

      else if (v53 == 1)
      {
        v25 = __nw_create_backtrace_string();
        if (v25)
        {
          v26 = v25;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v27 = gLogObj;
          v28 = type;
          if (os_log_type_enabled(v27, type))
          {
            *buf = 136446722;
            v56 = "nw_service_connector_cancel_request";
            v57 = 2048;
            v58 = v13;
            v59 = 2082;
            v60[0] = v26;
            _os_log_impl(&dword_181A37000, v27, v28, "%{public}s xpc_string_create(%zu) failed, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v26);
          if (!v21)
          {
            goto LABEL_45;
          }

          goto LABEL_44;
        }

        v22 = __nwlog_obj();
        v30 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446466;
          v56 = "nw_service_connector_cancel_request";
          v57 = 2048;
          v58 = v13;
          _os_log_impl(&dword_181A37000, v22, v30, "%{public}s xpc_string_create(%zu) failed, no backtrace", buf, 0x16u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v29 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446466;
          v56 = "nw_service_connector_cancel_request";
          v57 = 2048;
          v58 = v13;
          _os_log_impl(&dword_181A37000, v22, v29, "%{public}s xpc_string_create(%zu) failed, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }

    if (!v21)
    {
      goto LABEL_45;
    }

LABEL_44:
    free(v21);
    goto LABEL_45;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v9 = gLogObj;
  *buf = 136446722;
  v56 = "nw_service_connector_cancel_request";
  v57 = 2082;
  v58 = a3;
  v59 = 1024;
  LODWORD(v60[0]) = 256;
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v53 = 0;
  if (__nwlog_fault(v10, &type, &v53))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446722;
        v56 = "nw_service_connector_cancel_request";
        v57 = 2082;
        v58 = a3;
        v59 = 1024;
        LODWORD(v60[0]) = 256;
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s Service name %{public}s too long. Max allowed length is %d", buf, 0x1Cu);
      }
    }

    else if (v53 == 1)
    {
      v17 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (v17)
      {
        if (v19)
        {
          *buf = 136446978;
          v56 = "nw_service_connector_cancel_request";
          v57 = 2082;
          v58 = a3;
          v59 = 1024;
          LODWORD(v60[0]) = 256;
          WORD2(v60[0]) = 2082;
          *(v60 + 6) = v17;
          _os_log_impl(&dword_181A37000, v11, v18, "%{public}s Service name %{public}s too long. Max allowed length is %d, dumping backtrace:%{public}s", buf, 0x26u);
        }

        free(v17);
        if (v10)
        {
          goto LABEL_36;
        }

        goto LABEL_46;
      }

      if (v19)
      {
        *buf = 136446722;
        v56 = "nw_service_connector_cancel_request";
        v57 = 2082;
        v58 = a3;
        v59 = 1024;
        LODWORD(v60[0]) = 256;
        _os_log_impl(&dword_181A37000, v11, v18, "%{public}s Service name %{public}s too long. Max allowed length is %d, no backtrace", buf, 0x1Cu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v24 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446722;
        v56 = "nw_service_connector_cancel_request";
        v57 = 2082;
        v58 = a3;
        v59 = 1024;
        LODWORD(v60[0]) = 256;
        _os_log_impl(&dword_181A37000, v11, v24, "%{public}s Service name %{public}s too long. Max allowed length is %d, backtrace limit exceeded", buf, 0x1Cu);
      }
    }
  }

LABEL_35:
  if (v10)
  {
LABEL_36:
    free(v10);
  }

LABEL_46:
}

void __nw_service_connector_cancel_request_block_invoke(xpc_object_t *a1)
{
  v23 = *MEMORY[0x1E69E9840];
  string_ptr = xpc_string_get_string_ptr(a1[4]);
  v3 = *(a1[5] + 4);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = gLogObj;
  v5 = v4;
  if (v3 == 4)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6 = a1[5];
      v7 = a1[6];
      v15 = 136446978;
      v16 = "nw_service_connector_cancel_request_block_invoke";
      v17 = 2114;
      v18 = v6;
      v19 = 2082;
      v20 = string_ptr;
      v21 = 2114;
      v22 = v7;
      _os_log_impl(&dword_181A37000, &v5->super, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring client cancelling service %{public}s to %{public}@", &v15, 0x2Au);
    }
  }

  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v8 = a1[5];
      v9 = a1[6];
      v15 = 136446978;
      v16 = "nw_service_connector_cancel_request_block_invoke";
      v17 = 2114;
      v18 = v8;
      v19 = 2082;
      v20 = string_ptr;
      v21 = 2114;
      v22 = v9;
      _os_log_impl(&dword_181A37000, &v5->super, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ client cancelling request for service %{public}s to %{public}@", &v15, 0x2Au);
    }

    v5 = nw_service_connector_copy_pending_incoming_request(a1[5], a1[6], string_ptr);
    if (v5)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v11 = a1[5];
        v15 = 136446722;
        v16 = "nw_service_connector_cancel_request_block_invoke";
        v17 = 2114;
        v18 = v11;
        v19 = 2114;
        v20 = v5;
        _os_log_impl(&dword_181A37000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ client cancel: rejecting incoming %{public}@", &v15, 0x20u);
      }

      nw_service_connector_reject_incoming_request(a1[5], v5, 1);
    }

    v12 = nw_service_connector_copy_active_outgoing_request(a1[5], a1[6], string_ptr);
    nw_service_connector_cancel_request_inner(a1[5], a1[6], string_ptr, 0, 0);
    if (v12)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        v14 = a1[5];
        v15 = 136446722;
        v16 = "nw_service_connector_cancel_request_block_invoke";
        v17 = 2114;
        v18 = v14;
        v19 = 2114;
        v20 = v5;
        _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ client cancel: cancelling outgoing %{public}@", &v15, 0x20u);
      }

      nw_service_connector_trigger_request_complete_block_inner(a1[5], v12, 0, 0, 89);
    }

    nwsc_cancel_asquic_listener_for_endpoint(a1[5], a1[6]);
  }
}

void nw_service_connector_cancel_active_connection(void *a1, void *a2, const char *a3, void *a4)
{
  v85[2] = *MEMORY[0x1E69E9840];
  v7 = a1;
  v8 = a2;
  v9 = a4;
  v10 = v9;
  if (!v7)
  {
    v59 = __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_service_connector_cancel_active_connection";
    v60 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v60, &type, &v78))
    {
      goto LABEL_137;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v61 = __nwlog_obj();
      v62 = type;
      if (os_log_type_enabled(v61, type))
      {
        *buf = 136446210;
        v81 = "nw_service_connector_cancel_active_connection";
        _os_log_impl(&dword_181A37000, v61, v62, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v78 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v61 = __nwlog_obj();
      v66 = type;
      v67 = os_log_type_enabled(v61, type);
      if (backtrace_string)
      {
        if (v67)
        {
          *buf = 136446466;
          v81 = "nw_service_connector_cancel_active_connection";
          v82 = 2082;
          v83 = backtrace_string;
          _os_log_impl(&dword_181A37000, v61, v66, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_137:
        if (!v60)
        {
          goto LABEL_96;
        }

LABEL_138:
        free(v60);
        goto LABEL_96;
      }

      if (v67)
      {
        *buf = 136446210;
        v81 = "nw_service_connector_cancel_active_connection";
        _os_log_impl(&dword_181A37000, v61, v66, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v61 = __nwlog_obj();
      v71 = type;
      if (os_log_type_enabled(v61, type))
      {
        *buf = 136446210;
        v81 = "nw_service_connector_cancel_active_connection";
        _os_log_impl(&dword_181A37000, v61, v71, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_136:

    goto LABEL_137;
  }

  if (v9)
  {
    if (v8)
    {
      if (a3)
      {
        v11 = v8;
        v12 = _nw_endpoint_get_type(v11);

        if (v12 == 1 || (v13 = v11, v14 = _nw_endpoint_get_type(v13), v13, v14 == 6))
        {
          v15 = strlen(a3);
          if (v15 >= 0x101)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v16 = gLogObj;
            *buf = 136446722;
            v81 = "nw_service_connector_cancel_active_connection";
            v82 = 2082;
            v83 = a3;
            v84 = 1024;
            LODWORD(v85[0]) = 256;
            v17 = _os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v78 = 0;
            if (__nwlog_fault(v17, &type, &v78))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v18 = gLogObj;
                v19 = type;
                if (os_log_type_enabled(v18, type))
                {
                  *buf = 136446722;
                  v81 = "nw_service_connector_cancel_active_connection";
                  v82 = 2082;
                  v83 = a3;
                  v84 = 1024;
                  LODWORD(v85[0]) = 256;
                  _os_log_impl(&dword_181A37000, v18, v19, "%{public}s Service name %{public}s too long. Max allowed length is %d", buf, 0x1Cu);
                }
              }

              else if (v78 == 1)
              {
                v39 = __nw_create_backtrace_string();
                if (v39)
                {
                  v40 = v39;
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v41 = gLogObj;
                  v42 = type;
                  if (os_log_type_enabled(v41, type))
                  {
                    *buf = 136446978;
                    v81 = "nw_service_connector_cancel_active_connection";
                    v82 = 2082;
                    v83 = a3;
                    v84 = 1024;
                    LODWORD(v85[0]) = 256;
                    WORD2(v85[0]) = 2082;
                    *(v85 + 6) = v40;
                    _os_log_impl(&dword_181A37000, v41, v42, "%{public}s Service name %{public}s too long. Max allowed length is %d, dumping backtrace:%{public}s", buf, 0x26u);
                  }

                  free(v40);
                  if (!v17)
                  {
                    goto LABEL_95;
                  }

                  goto LABEL_85;
                }

                v18 = __nwlog_obj();
                v56 = type;
                if (os_log_type_enabled(v18, type))
                {
                  *buf = 136446722;
                  v81 = "nw_service_connector_cancel_active_connection";
                  v82 = 2082;
                  v83 = a3;
                  v84 = 1024;
                  LODWORD(v85[0]) = 256;
                  _os_log_impl(&dword_181A37000, v18, v56, "%{public}s Service name %{public}s too long. Max allowed length is %d, no backtrace", buf, 0x1Cu);
                }
              }

              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v18 = gLogObj;
                v51 = type;
                if (os_log_type_enabled(v18, type))
                {
                  *buf = 136446722;
                  v81 = "nw_service_connector_cancel_active_connection";
                  v82 = 2082;
                  v83 = a3;
                  v84 = 1024;
                  LODWORD(v85[0]) = 256;
                  _os_log_impl(&dword_181A37000, v18, v51, "%{public}s Service name %{public}s too long. Max allowed length is %d, backtrace limit exceeded", buf, 0x1Cu);
                }
              }
            }

            if (v17)
            {
LABEL_85:
              v57 = v17;
LABEL_94:
              free(v57);
            }

LABEL_95:
            dispatch_async(v7[4], v10);
            goto LABEL_96;
          }

          v29 = v15;
          v30 = xpc_string_create(a3);
          v31 = v30;
          if (v30)
          {
            v32 = v7[4];
            block[0] = MEMORY[0x1E69E9820];
            block[1] = 3221225472;
            block[2] = __nw_service_connector_cancel_active_connection_block_invoke;
            block[3] = &unk_1E6A3B8E8;
            v74 = v30;
            v75 = v7;
            v76 = v11;
            v77 = v10;
            dispatch_async(v32, block);

LABEL_103:
            goto LABEL_96;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v44 = gLogObj;
          *buf = 136446466;
          v81 = "nw_service_connector_cancel_active_connection";
          v82 = 2048;
          v83 = v29;
          v45 = _os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v78 = 0;
          if (__nwlog_fault(v45, &type, &v78))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v46 = gLogObj;
              v47 = type;
              if (os_log_type_enabled(v46, type))
              {
                *buf = 136446466;
                v81 = "nw_service_connector_cancel_active_connection";
                v82 = 2048;
                v83 = v29;
                _os_log_impl(&dword_181A37000, v46, v47, "%{public}s xpc_string_create(%zu) failed", buf, 0x16u);
              }
            }

            else if (v78 == 1)
            {
              v52 = __nw_create_backtrace_string();
              v46 = __nwlog_obj();
              v53 = type;
              v54 = os_log_type_enabled(v46, type);
              if (v52)
              {
                if (v54)
                {
                  *buf = 136446722;
                  v81 = "nw_service_connector_cancel_active_connection";
                  v82 = 2048;
                  v83 = v29;
                  v84 = 2082;
                  v85[0] = v52;
                  _os_log_impl(&dword_181A37000, v46, v53, "%{public}s xpc_string_create(%zu) failed, dumping backtrace:%{public}s", buf, 0x20u);
                }

                free(v52);
                goto LABEL_100;
              }

              if (v54)
              {
                *buf = 136446466;
                v81 = "nw_service_connector_cancel_active_connection";
                v82 = 2048;
                v83 = v29;
                _os_log_impl(&dword_181A37000, v46, v53, "%{public}s xpc_string_create(%zu) failed, no backtrace", buf, 0x16u);
              }
            }

            else
            {
              v46 = __nwlog_obj();
              v58 = type;
              if (os_log_type_enabled(v46, type))
              {
                *buf = 136446466;
                v81 = "nw_service_connector_cancel_active_connection";
                v82 = 2048;
                v83 = v29;
                _os_log_impl(&dword_181A37000, v46, v58, "%{public}s xpc_string_create(%zu) failed, backtrace limit exceeded", buf, 0x16u);
              }
            }
          }

LABEL_100:
          if (v45)
          {
            free(v45);
          }

          dispatch_async(v7[4], v10);
          goto LABEL_103;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = gLogObj;
        *buf = 136446466;
        v81 = "nw_service_connector_cancel_active_connection";
        v82 = 2114;
        v83 = v13;
        v21 = _os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v78 = 0;
        if (__nwlog_fault(v21, &type, &v78))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v36 = gLogObj;
            v37 = type;
            if (os_log_type_enabled(v36, type))
            {
              *buf = 136446466;
              v81 = "nw_service_connector_cancel_active_connection";
              v82 = 2114;
              v83 = v13;
              _os_log_impl(&dword_181A37000, v36, v37, "%{public}s Specified endpoint %{public}@ is not an address/appsvc endpoint", buf, 0x16u);
            }
          }

          else if (v78 == 1)
          {
            v48 = __nw_create_backtrace_string();
            v36 = __nwlog_obj();
            v49 = type;
            v50 = os_log_type_enabled(v36, type);
            if (v48)
            {
              if (v50)
              {
                *buf = 136446722;
                v81 = "nw_service_connector_cancel_active_connection";
                v82 = 2114;
                v83 = v13;
                v84 = 2082;
                v85[0] = v48;
                _os_log_impl(&dword_181A37000, v36, v49, "%{public}s Specified endpoint %{public}@ is not an address/appsvc endpoint, dumping backtrace:%{public}s", buf, 0x20u);
              }

              free(v48);
              if (!v21)
              {
                goto LABEL_95;
              }

              goto LABEL_93;
            }

            if (v50)
            {
              *buf = 136446466;
              v81 = "nw_service_connector_cancel_active_connection";
              v82 = 2114;
              v83 = v13;
              _os_log_impl(&dword_181A37000, v36, v49, "%{public}s Specified endpoint %{public}@ is not an address/appsvc endpoint, no backtrace", buf, 0x16u);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v36 = gLogObj;
            v55 = type;
            if (os_log_type_enabled(v36, type))
            {
              *buf = 136446466;
              v81 = "nw_service_connector_cancel_active_connection";
              v82 = 2114;
              v83 = v13;
              _os_log_impl(&dword_181A37000, v36, v55, "%{public}s Specified endpoint %{public}@ is not an address/appsvc endpoint, backtrace limit exceeded", buf, 0x16u);
            }
          }
        }

LABEL_92:
        if (!v21)
        {
          goto LABEL_95;
        }

LABEL_93:
        v57 = v21;
        goto LABEL_94;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = gLogObj;
      *buf = 136446210;
      v81 = "nw_service_connector_cancel_active_connection";
      v21 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v78 = 0;
      if (!__nwlog_fault(v21, &type, &v78))
      {
        goto LABEL_92;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v25 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v81 = "nw_service_connector_cancel_active_connection";
          _os_log_impl(&dword_181A37000, v22, v25, "%{public}s called with null service", buf, 0xCu);
        }

LABEL_80:

        goto LABEL_92;
      }

      if (v78 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v43 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v81 = "nw_service_connector_cancel_active_connection";
          _os_log_impl(&dword_181A37000, v22, v43, "%{public}s called with null service, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_80;
      }

      v26 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      v33 = type;
      v34 = os_log_type_enabled(v22, type);
      if (!v26)
      {
        if (v34)
        {
          *buf = 136446210;
          v81 = "nw_service_connector_cancel_active_connection";
          _os_log_impl(&dword_181A37000, v22, v33, "%{public}s called with null service, no backtrace", buf, 0xCu);
        }

        goto LABEL_80;
      }

      if (v34)
      {
        *buf = 136446466;
        v81 = "nw_service_connector_cancel_active_connection";
        v82 = 2082;
        v83 = v26;
        _os_log_impl(&dword_181A37000, v22, v33, "%{public}s called with null service, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      *buf = 136446210;
      v81 = "nw_service_connector_cancel_active_connection";
      v21 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v78 = 0;
      if (!__nwlog_fault(v21, &type, &v78))
      {
        goto LABEL_92;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v81 = "nw_service_connector_cancel_active_connection";
          _os_log_impl(&dword_181A37000, v22, v23, "%{public}s called with null endpoint", buf, 0xCu);
        }

        goto LABEL_80;
      }

      if (v78 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v38 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v81 = "nw_service_connector_cancel_active_connection";
          _os_log_impl(&dword_181A37000, v22, v38, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_80;
      }

      v26 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      v27 = type;
      v28 = os_log_type_enabled(v22, type);
      if (!v26)
      {
        if (v28)
        {
          *buf = 136446210;
          v81 = "nw_service_connector_cancel_active_connection";
          _os_log_impl(&dword_181A37000, v22, v27, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }

        goto LABEL_80;
      }

      if (v28)
      {
        *buf = 136446466;
        v81 = "nw_service_connector_cancel_active_connection";
        v82 = 2082;
        v83 = v26;
        _os_log_impl(&dword_181A37000, v22, v27, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(v26);
    if (!v21)
    {
      goto LABEL_95;
    }

    goto LABEL_93;
  }

  v63 = __nwlog_obj();
  *buf = 136446210;
  v81 = "nw_service_connector_cancel_active_connection";
  v60 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v78 = 0;
  if (!__nwlog_fault(v60, &type, &v78))
  {
    goto LABEL_137;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v61 = __nwlog_obj();
    v64 = type;
    if (os_log_type_enabled(v61, type))
    {
      *buf = 136446210;
      v81 = "nw_service_connector_cancel_active_connection";
      _os_log_impl(&dword_181A37000, v61, v64, "%{public}s called with null completionBlock", buf, 0xCu);
    }

    goto LABEL_136;
  }

  if (v78 != 1)
  {
    v61 = __nwlog_obj();
    v72 = type;
    if (os_log_type_enabled(v61, type))
    {
      *buf = 136446210;
      v81 = "nw_service_connector_cancel_active_connection";
      _os_log_impl(&dword_181A37000, v61, v72, "%{public}s called with null completionBlock, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_136;
  }

  v68 = __nw_create_backtrace_string();
  v61 = __nwlog_obj();
  v69 = type;
  v70 = os_log_type_enabled(v61, type);
  if (!v68)
  {
    if (v70)
    {
      *buf = 136446210;
      v81 = "nw_service_connector_cancel_active_connection";
      _os_log_impl(&dword_181A37000, v61, v69, "%{public}s called with null completionBlock, no backtrace", buf, 0xCu);
    }

    goto LABEL_136;
  }

  if (v70)
  {
    *buf = 136446466;
    v81 = "nw_service_connector_cancel_active_connection";
    v82 = 2082;
    v83 = v68;
    _os_log_impl(&dword_181A37000, v61, v69, "%{public}s called with null completionBlock, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v68);
  if (v60)
  {
    goto LABEL_138;
  }

LABEL_96:
}

void __nw_service_connector_cancel_active_connection_block_invoke(uint64_t a1)
{
  v27 = *MEMORY[0x1E69E9840];
  string_ptr = xpc_string_get_string_ptr(*(a1 + 32));
  v3 = *(a1 + 40);
  if (v3[4] == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    if (os_log_type_enabled(&v4->super, OS_LOG_TYPE_ERROR))
    {
      v5 = *(a1 + 40);
      v6 = *(a1 + 48);
      *buf = 136446978;
      *&buf[4] = "nw_service_connector_cancel_active_connection_block_invoke";
      *&buf[12] = 2114;
      *&buf[14] = v5;
      *&buf[22] = 2082;
      v23 = string_ptr;
      *v24 = 2114;
      *&v24[2] = v6;
      _os_log_impl(&dword_181A37000, &v4->super, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring client cancelling active connection for service %{public}s to %{public}@", buf, 0x2Au);
    }
  }

  else
  {
    v4 = nw_service_connector_copy_active_connection_with_endpoint_and_service(v3, *(a1 + 48), string_ptr);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v4)
    {
      if (v8)
      {
        v10 = *(a1 + 40);
        v9 = *(a1 + 48);
        v11 = "dead";
        connection = v4->connection;
        if (connection)
        {
          v13 = connection;
          v18 = 0;
          v19 = &v18;
          v20 = 0x2020000000;
          v21 = 0;
          *buf = MEMORY[0x1E69E9820];
          *&buf[8] = 3221225472;
          *&buf[16] = __nw_connection_is_cancelled_or_failed_block_invoke;
          v23 = &unk_1E6A3D738;
          *&v24[8] = &v18;
          v14 = v13;
          *v24 = v14;
          os_unfair_lock_lock(v13 + 34);
          (*&buf[16])(buf);
          os_unfair_lock_unlock(v13 + 34);
          LODWORD(v13) = *(v19 + 24);

          _Block_object_dispose(&v18, 8);
          if (!v13)
          {
            v11 = "alive";
          }
        }

        *buf = 136447490;
        *&buf[4] = "nw_service_connector_cancel_active_connection_block_invoke";
        *&buf[12] = 2114;
        *&buf[14] = v10;
        *&buf[22] = 2082;
        v23 = string_ptr;
        *v24 = 2114;
        *&v24[2] = v9;
        *&v24[10] = 2082;
        *&v24[12] = v11;
        v25 = 2114;
        v26 = v4;
        _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ client cancelling active connection for service %{public}s to %{public}@: %{public}s activeConnection %{public}@", buf, 0x3Eu);
      }

      nwsc_unique_connection_shutdown_socket(*(a1 + 40), v4);
      v15 = v4->connection;
    }

    else
    {
      if (v8)
      {
        v16 = *(a1 + 40);
        v17 = *(a1 + 48);
        *buf = 136446978;
        *&buf[4] = "nw_service_connector_cancel_active_connection_block_invoke";
        *&buf[12] = 2114;
        *&buf[14] = v16;
        *&buf[22] = 2082;
        v23 = string_ptr;
        *v24 = 2114;
        *&v24[2] = v17;
        _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ client cancelling active connection for service %{public}s to %{public}@ but no active connection", buf, 0x2Au);
      }

      v15 = 0;
    }

    nw_service_connector_cancel_request_inner(*(a1 + 40), *(a1 + 48), string_ptr, v15, 0);
    nwsc_cancel_asquic_listener_for_endpoint(*(a1 + 40), *(a1 + 48));
    dispatch_async(*(*(a1 + 40) + 32), *(a1 + 56));
  }
}

void qenc_hist_update_size(uint64_t a1, unsigned int a2)
{
  if (*(a1 + 228) != a2)
  {
    if (!a2)
    {
      *(a1 + 224) = 0;
      *(a1 + 232) = 0;
      return;
    }

    v4 = malloc_type_malloc(8 * (a2 + 1), 0x100004000313F17uLL);
    if (!v4)
    {
      return;
    }

    v5 = v4;
    v6 = *(a1 + 200);
    if (v6)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v6);
      fprintf(*(a1 + 200), "history size change from %u to %u", *(a1 + 228), a2);
      fputc(10, *(a1 + 200));
    }

    v7 = *(a1 + 224);
    if (*(a1 + 232))
    {
      v8 = v7 + 1;
      v7 = *(a1 + 228);
      v9 = v8 % v7;
    }

    else
    {
      v9 = 0;
      if (!v7)
      {
        LODWORD(v10) = 0;
LABEL_15:
        v13 = v10 % a2;
        *(a1 + 224) = v13;
        *(a1 + 228) = a2;
        *(a1 + 232) = v13 == 0;
        free(*(a1 + 216));
        *(a1 + 216) = v5;
        return;
      }
    }

    v10 = 0;
    v11 = v7 - 1;
    do
    {
      v12 = v10;
      v5[v10] = *(*(a1 + 216) + 8 * ((v9 + v10) % *(a1 + 228)));
      ++v10;
    }

    while (v11 != v12 && v10 < a2);
    goto LABEL_15;
  }
}

uint64_t qenc_add_to_risked_list(uint64_t result, void *a2)
{
  a2[2] = 0;
  v2 = *(result + 120);
  a2[3] = v2;
  *v2 = a2;
  *(result + 120) = a2 + 2;
  v3 = *(result + 136);
  if (v3)
  {
    a2[4] = *(v3 + 32);
    *(v3 + 32) = a2;
  }

  else
  {
    v4 = *(result + 40) + 1;
    *(result + 40) = v4;
    v5 = *(result + 200);
    if (v5)
    {
      v6 = result;
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v5);
      fprintf(*(v6 + 200), "streams at risk: %u", *(v6 + 40));
      fputc(10, *(v6 + 200));
      result = v6;
      v4 = *(v6 + 40);
    }

    if (v4 > *(result + 36))
    {
      __assert_rtn("qenc_add_to_risked_list", "lsqpack.c", 1190, "enc->qpe_cur_streams_at_risk <= enc->qpe_max_risked_streams");
    }
  }

  return result;
}

uint64_t qenc_has_or_can_evict_at_least(uint64_t a1, unint64_t a2)
{
  v2 = (*(a1 + 20) - *(a1 + 16));
  if (v2 >= a2)
  {
    return 1;
  }

  v3 = *(a1 + 152);
  if ((v3 & 4) == 0)
  {
    v4 = *(a1 + 96);
    if (v4)
    {
      v5 = 0;
      do
      {
        v6 = *(v4 + 14);
        if (!v5 || (v6 ? (v7 = v6 >= v5) : (v7 = 1), !v7))
        {
          v5 = *(v4 + 14);
        }

        v4 = *v4;
      }

      while (v4);
    }

    else
    {
      v5 = 0;
    }

    *(a1 + 148) = v5;
    *(a1 + 152) = v3 | 4;
    v8 = *(a1 + 128);
    if (!v8)
    {
      goto LABEL_24;
    }

    goto LABEL_18;
  }

  v5 = *(a1 + 148);
  v8 = *(a1 + 128);
  if (v8)
  {
LABEL_18:
    v9 = *(v8 + 56);
    if (!v5 || (v9 ? (v10 = v9 >= v5) : (v10 = 1), !v10))
    {
      v5 = v9;
    }
  }

LABEL_24:
  v11 = *(a1 + 56);
  if (v11)
  {
    if (v5)
    {
      do
      {
        v12 = *(v11 + 24);
        if (v12 >= v5 || v12 > *(a1 + 4))
        {
          break;
        }

        v2 += (*(v11 + 48) + *(v11 + 52) + 32);
        if (v2 >= a2)
        {
          return 1;
        }

        v11 = *(v11 + 16);
      }

      while (v11);
    }

    else
    {
      do
      {
        if (*(v11 + 24) > *(a1 + 4))
        {
          break;
        }

        v2 += (*(v11 + 48) + *(v11 + 52) + 32);
        if (v2 >= a2)
        {
          return 1;
        }

        v11 = *(v11 + 16);
      }

      while (v11);
    }
  }

  return 0;
}

void *lsqpack_enc_push_entry(uint64_t a1, int a2, int a3, const void *a4, unsigned int a5, const void *a6, unsigned int a7)
{
  v8 = a6;
  v10 = a3;
  v11 = a2;
  v48[2] = *MEMORY[0x1E69E9840];
  v13 = *(a1 + 52);
  v14 = 1 << v13;
  if (*(a1 + 48) >= (1 << v13) >> 1)
  {
    v18 = malloc_type_malloc(32 * (1 << (v13 + 1)), 0xA004088793A40uLL);
    if (!v18)
    {
      return v18;
    }

    v19 = 0;
    v20 = *(a1 + 72);
    v21 = (1 << (v13 + 1)) - 1;
    v8 = a6;
    v11 = a2;
    v10 = a3;
    do
    {
      v22 = &v18[4 * v19];
      v23 = &v18[4 * (v14 + v19)];
      v48[0] = v22;
      v48[1] = v23;
      *v22 = 0;
      v22[1] = v22;
      *v23 = 0;
      v23[1] = v23;
      v22[2] = 0;
      v22[3] = v22 + 2;
      v23[2] = 0;
      v23[3] = v23 + 2;
      v24 = &v20[32 * v19];
      while (1)
      {
        v27 = *v24;
        if (!*v24)
        {
          break;
        }

        v28 = *(v27 + 8);
        *v24 = v28;
        if (!v28)
        {
          *(v24 + 1) = v24;
        }

        v25 = ((*(v27 + 44) & v21) >> v13) & 1;
        *(v27 + 8) = 0;
        v26 = v48[v25];
        **(v26 + 8) = v27;
        *(v26 + 8) = v27 + 8;
      }

      v29 = &v20[32 * v19];
      v32 = *(v29 + 2);
      v30 = (v29 + 16);
      v31 = v32;
      if (v32)
      {
        do
        {
          v35 = *v31;
          *v30 = *v31;
          if (!v35)
          {
            v30[1] = v30;
          }

          v33 = ((v31[5] & v21) >> v13) & 1;
          *v31 = 0;
          v34 = v48[v33];
          **(v34 + 24) = v31;
          *(v34 + 24) = v31;
          v31 = *v30;
        }

        while (*v30);
      }

      ++v19;
    }

    while (v19 != v14);
    free(v20);
    *(a1 + 52) = v13 + 1;
    *(a1 + 72) = v18;
  }

  v36 = malloc_type_malloc(a5 + a7 + 56, 0x6B21D0A1uLL);
  v18 = v36;
  if (v36)
  {
    v36[10] = v10;
    v36[11] = v11;
    v36[12] = a5;
    v36[13] = a7;
    v37 = *(a1 + 16);
    v36[8] = *(a1 + 32);
    v38 = *a1 + 1;
    *a1 = v38;
    v36[6] = v38;
    v36[7] = v37;
    v39 = (v36 + 14);
    memcpy(v36 + 14, a4, a5);
    memcpy(&v39[a5], v8, a7);
    v18[2] = 0;
    v40 = *(a1 + 72);
    **(a1 + 64) = v18;
    *(a1 + 64) = v18 + 2;
    v41 = *(a1 + 48);
    v42 = -1 << *(a1 + 52);
    *v18 = 0;
    v43 = v40 + 32 * (v10 & ~v42);
    **(v43 + 24) = v18;
    *(v43 + 24) = v18;
    v18[1] = 0;
    v44 = v40 + 32 * (v11 & ~v42);
    **(v44 + 8) = v18;
    *(v44 + 8) = v18 + 1;
    *(a1 + 16) += a5 + a7 + 32;
    *(a1 + 48) = v41 + 1;
    v45 = *(a1 + 200);
    if (v45)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v45);
      fputc(10, *(a1 + 200));
    }
  }

  return v18;
}

uint64_t enc_proc_header_ack(uint64_t a1, unint64_t a2)
{
  v4 = *(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(a1 + 200), "got Header Ack instruction, stream=%llu", a2);
    fputc(10, *(a1 + 200));
  }

  if (!(a2 >> 62))
  {
    v6 = a1 + 96;
    while (1)
    {
      v6 = *v6;
      if (!v6)
      {
        break;
      }

      if (*(v6 + 40) == a2)
      {
        if (*(v6 + 60) > *(a1 + 4))
        {
          qenc_remove_from_risked_list(a1, v6);
          *(a1 + 4) = *(v6 + 60);
          v7 = *(a1 + 112);
          if (v7)
          {
            do
            {
              v16 = *(v7 + 16);
              if (*(v7 + 60) <= *(a1 + 4))
              {
                qenc_remove_from_risked_list(a1, v7);
              }

              v7 = v16;
            }

            while (v16);
          }

          v8 = *(a1 + 200);
          if (v8)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
            fprintf(*(a1 + 200), "max acked ID is now %u", *(a1 + 4));
            fputc(10, *(a1 + 200));
          }
        }

        v9 = (a1 + 80);
        do
        {
          v9 = *v9;
          if (!v9)
          {
            __assert_rtn("enc_free_hinfo", "lsqpack.c", 381, "0");
          }

          v10 = v9 + 2;
        }

        while ((v9 + 2) > v6 || (v9 + 514) <= v6);
        result = 0;
        v9[1] &= ~(1 << ((v6 - v10) >> 6));
        v12 = &v10[8 * ((v6 - v10) >> 6)];
        v14 = *v12;
        v13 = v12[1];
        v15 = (a1 + 104);
        if (v14)
        {
          v15 = (v14 + 8);
        }

        *v15 = v13;
        *v13 = v14;
        return result;
      }
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t qenc_remove_from_risked_list(uint64_t result, void *a2)
{
  if (*(result + 112))
  {
    v2 = a2[2];
    v3 = a2[3];
    v4 = (result + 120);
    if (v2)
    {
      v4 = (v2 + 24);
    }

    *v4 = v3;
    *v3 = v2;
    v5 = a2[4];
    if (v5 == a2)
    {
      v8 = *(result + 40);
      if (!v8)
      {
        __assert_rtn("qenc_remove_from_risked_list", "lsqpack.c", 1208, "enc->qpe_cur_streams_at_risk > 0");
      }

      *(result + 40) = v8 - 1;
      v9 = *(result + 200);
      if (v9)
      {
        v10 = result;
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v9);
        fprintf(*(v10 + 200), "streams at risk: %u", *(v10 + 40));
        v11 = *(v10 + 200);

        return fputc(10, v11);
      }
    }

    else
    {
      v6 = a2[4];
      do
      {
        v7 = v6;
        v6 = v6[4];
      }

      while (v6 != a2);
      v7[4] = v5;
      a2[4] = a2;
    }
  }

  else if (*(result + 40))
  {
    __assert_rtn("qenc_remove_from_risked_list", "lsqpack.c", 1202, "enc->qpe_cur_streams_at_risk == 0");
  }

  return result;
}

uint64_t enc_proc_stream_cancel(uint64_t a1, unint64_t a2)
{
  v4 = *(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(a1 + 200), "got Cancel Stream instruction; stream=%llu", a2);
    fputc(10, *(a1 + 200));
  }

  if (!(a2 >> 62))
  {
    v7 = *(a1 + 96);
    if (v7)
    {
      v8 = 0;
      do
      {
        v13 = *v7;
        if (*(v7 + 40) == a2)
        {
          v14 = *(a1 + 200);
          if (v14)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v14);
            fprintf(*(a1 + 200), "cancel header block for stream %llu, seqno %u", a2, *(v7 + 48));
            fputc(10, *(a1 + 200));
          }

          if (*(v7 + 60) > *(a1 + 4))
          {
            qenc_remove_from_risked_list(a1, v7);
          }

          v15 = (a1 + 80);
          do
          {
            v15 = *v15;
            if (!v15)
            {
              __assert_rtn("enc_free_hinfo", "lsqpack.c", 381, "0");
            }

            v16 = v15 + 2;
          }

          while ((v15 + 2) > v7 || (v15 + 514) <= v7);
          v15[1] &= ~(1 << ((v7 - v16) >> 6));
          v9 = &v16[8 * ((v7 - v16) >> 6)];
          v11 = *v9;
          v10 = v9[1];
          v12 = (v11 + 8);
          if (!v11)
          {
            v12 = (a1 + 104);
          }

          *v12 = v10;
          *v10 = v11;
          ++v8;
        }

        v7 = v13;
      }

      while (v13);
    }

    else
    {
      v8 = 0;
    }

    v18 = *(a1 + 200);
    if (!v18)
    {
      return 0;
    }

    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v18);
    fprintf(*(a1 + 200), "cancelled %u header block%.*s of stream %llu", v8, v8 != 1, "s", a2);
    v6 = 0;
    goto LABEL_29;
  }

  v5 = *(a1 + 200);
  if (v5)
  {
    fwrite("qenc: info: ", 0xCuLL, 1uLL, v5);
    fprintf(*(a1 + 200), "Invalid stream ID %llu in Cancel Stream", a2);
    v6 = 0xFFFFFFFFLL;
LABEL_29:
    fputc(10, *(a1 + 200));
    return v6;
  }

  return 0xFFFFFFFFLL;
}

uint64_t enc_proc_ici(uint64_t a1, unint64_t a2)
{
  v4 = *(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(a1 + 200), "got ICI instruction, count=%llu", a2);
    fputc(10, *(a1 + 200));
  }

  if (!a2)
  {
    v6 = *(a1 + 200);
    if (v6)
    {
      fwrite("qenc: info: ", 0xCuLL, 1uLL, v6);
      fwrite("ICI=0 is an error", 0x11uLL, 1uLL, *(a1 + 200));
      goto LABEL_12;
    }

    return 0xFFFFFFFFLL;
  }

  if (HIDWORD(a2))
  {
    v5 = *(a1 + 200);
    if (v5)
    {
      fwrite("qenc: info: ", 0xCuLL, 1uLL, v5);
      fprintf(*(a1 + 200), "insertion count too high: %llu");
LABEL_12:
      v9 = 0xFFFFFFFFLL;
LABEL_13:
      fputc(10, *(a1 + 200));
      return v9;
    }

    return 0xFFFFFFFFLL;
  }

  v7 = *(a1 + 8) + a2;
  if (v7 > *a1)
  {
    v8 = *(a1 + 200);
    if (v8)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
      fprintf(*(a1 + 200), "ICI: max_acked %u is larger than number of inserts %u");
      goto LABEL_12;
    }

    return 0xFFFFFFFFLL;
  }

  if (v7 <= *(a1 + 4))
  {
    v13 = *(a1 + 200);
    if (v13)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v13);
      fprintf(*(a1 + 200), "duplicate ICI: %u", v7);
      v9 = 0;
      goto LABEL_13;
    }

    return 0;
  }

  *(a1 + 4) = v7;
  *(a1 + 8) = v7;
  v11 = *(a1 + 200);
  if (v11)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v11);
    fprintf(*(a1 + 200), "max acked ID is now %u", *(a1 + 4));
    fputc(10, *(a1 + 200));
  }

  v12 = *(a1 + 112);
  if (!v12)
  {
    return 0;
  }

  do
  {
    v9 = *(v12 + 16);
    if (*(v12 + 60) <= *(a1 + 4))
    {
      qenc_remove_from_risked_list(a1, v12);
    }

    v12 = v9;
  }

  while (v9);
  return v9;
}

uint64_t lsqpack_huff_decode_full(_BYTE *a1, int a2, _BYTE *a3, uint64_t a4, uint64_t a5, int a6)
{
  if (!a4)
  {
    v11 = 2;
    return v11 | (a4 << 32);
  }

  v6 = &a1[a2];
  v7 = &a3[a4];
  v8 = *a5;
  if (*a5 > 1)
  {
    v9 = a1;
    v10 = a3;
    if (v8 == 2)
    {
      goto LABEL_22;
    }

    LODWORD(v10) = a3;
    if (v8 == 3)
    {
      v12 = *(a5 + 4);
      v9 = a1;
      v10 = a3;
      goto LABEL_16;
    }

    goto LABEL_11;
  }

  if (!v8)
  {
    *(a5 + 4) = 256;
    v9 = a1;
    v10 = a3;
    if (a1 != v6)
    {
      goto LABEL_21;
    }

    goto LABEL_11;
  }

  v9 = a1;
  v10 = a3;
  if (v8 != 1)
  {
LABEL_11:
    if (a6)
    {
      a4 = (v10 - a3);
      v11 = 3;
      if (*(a5 + 5))
      {
        v11 = 0;
      }
    }

    else
    {
      v11 = 1;
      *a5 = 1;
      a4 = (v10 - a3);
    }

    return v11 | (a4 << 32);
  }

  while (2)
  {
    if (v9 == v6)
    {
      goto LABEL_11;
    }

    while (1)
    {
LABEL_21:
      if (v10 == v7)
      {
        v11 = 2;
        *a5 = 2;
        return v11 | (a4 << 32);
      }

LABEL_22:
      v16 = &decode_tables + 48 * *(a5 + 4) + 3 * (*v9 >> 4);
      v17 = v16[1];
      if ((v17 & 4) != 0)
      {
        goto LABEL_31;
      }

      v12 = *v16;
      if ((v16[1] & 2) != 0)
      {
        *v10++ = v16[2];
        *(a5 + 4) = v12;
        *(a5 + 5) = v17 & 1;
        if (v10 == v7)
        {
          goto LABEL_30;
        }
      }

      else
      {
        *(a5 + 4) = v12;
        *(a5 + 5) = v17 & 1;
        if (!v10)
        {
          goto LABEL_31;
        }

        if (v10 == v7)
        {
LABEL_30:
          *a5 = 3;
          v11 = 2;
          return v11 | (a4 << 32);
        }
      }

LABEL_16:
      v13 = &decode_tables + 48 * v12 + 3 * (*v9 & 0xF);
      v14 = v13[1];
      if ((v14 & 4) != 0)
      {
        goto LABEL_31;
      }

      v15 = *v13;
      if ((v13[1] & 2) == 0)
      {
        break;
      }

      *v10++ = v13[2];
      *(a5 + 4) = v15;
      *(a5 + 5) = v14 & 1;
      if (++v9 == v6)
      {
        goto LABEL_11;
      }
    }

    *(a5 + 4) = v15;
    *(a5 + 5) = v14 & 1;
    if (v10)
    {
      ++v9;
      continue;
    }

    break;
  }

LABEL_31:
  a4 = 0;
  v11 = 3;
  return v11 | (a4 << 32);
}

uint64_t header_out_dynamic_entry(int *a1, uint64_t a2, int a3)
{
  v4 = a1[5];
  if (v4)
  {
    v4 = (2 * v4 - a3 + a1[8]) % (2 * v4);
  }

  v5 = a1[14];
  if (!v5)
  {
    return 0xFFFFFFFFLL;
  }

  v6 = a1[15];
  v7 = a1[16];
  v8 = v6 >= v7;
  v9 = v6 - v7;
  v10 = v8 ? 0 : a1[14];
  if (v9 + v10 <= v4)
  {
    return 0xFFFFFFFFLL;
  }

  v11 = *(*(a1 + 9) + 8 * ((v5 + ~v4 + v6) % v5));
  if (!v11)
  {
    return 0xFFFFFFFFLL;
  }

  v12 = 4 * (*a1 & 1);
  v14 = (*(*(a1 + 5) + 8))(*(a2 + 32), 0, v11[1] + *v11 + v12);
  if (!v14)
  {
    return 0xFFFFFFFFLL;
  }

  v15 = v14;
  v16 = *a1;
  v17 = v11[6];
  if ((*a1 & 6) != 0 && (v17 & 1) == 0)
  {
    v17 |= 1u;
    v11[6] = v17;
    v18 = (v11 + 7);
    v19 = *v11;
    if (v19 < 0x10)
    {
      v30 = v19 + 414139866;
    }

    else
    {
      v20 = v18 + v19 - 15;
      v21 = 645669457;
      v22 = -2008766304;
      v23 = 39378473;
      v24 = 1679910008;
      do
      {
        HIDWORD(v25) = v21 - 2048144777 * *v18;
        LODWORD(v25) = HIDWORD(v25);
        v21 = -1640531535 * (v25 >> 19);
        HIDWORD(v25) = v22 - 2048144777 * v18[1];
        LODWORD(v25) = HIDWORD(v25);
        v22 = -1640531535 * (v25 >> 19);
        HIDWORD(v25) = v23 - 2048144777 * v18[2];
        LODWORD(v25) = HIDWORD(v25);
        v23 = -1640531535 * (v25 >> 19);
        HIDWORD(v25) = v24 - 2048144777 * v18[3];
        LODWORD(v25) = HIDWORD(v25);
        v24 = -1640531535 * (v25 >> 19);
        v18 += 4;
      }

      while (v18 < v20);
      HIDWORD(v27) = v21;
      LODWORD(v27) = v21;
      v26 = v27 >> 31;
      HIDWORD(v27) = v22;
      LODWORD(v27) = v22;
      v28 = v27 >> 25;
      HIDWORD(v27) = v23;
      LODWORD(v27) = v23;
      v29 = v27 >> 20;
      HIDWORD(v27) = v24;
      LODWORD(v27) = v24;
      v30 = v26 + v19 + v28 + v29 + (v27 >> 14);
      v19 &= 0xFu;
    }

    if (v19 >= 4)
    {
      do
      {
        v32 = *v18++;
        HIDWORD(v33) = v30 - 1028477379 * v32;
        LODWORD(v33) = HIDWORD(v33);
        v30 = 668265263 * (v33 >> 15);
        v19 -= 4;
      }

      while (v19 > 3);
    }

    for (; v19; --v19)
    {
      v34 = *v18;
      v18 = (v18 + 1);
      HIDWORD(v35) = v30 + 374761393 * v34;
      LODWORD(v35) = HIDWORD(v35);
      v30 = -1640531535 * (v35 >> 21);
    }

    v36 = -1028477379 * ((-2048144777 * (v30 ^ (v30 >> 15))) ^ ((-2048144777 * (v30 ^ (v30 >> 15))) >> 13));
    v11[3] = v36 ^ HIWORD(v36);
  }

  if ((v16 & 4) != 0 && (v17 & 2) == 0)
  {
    if ((v17 & 1) == 0)
    {
      __assert_rtn("qdec_maybe_update_entry_hashes", "lsqpack.c", 3000, "entry->dte_flags & DTEF_NAME_HASH");
    }

    v17 |= 2u;
    v11[6] = v17;
    v11[4] = XXH_INLINE_XXH32((v11 + *v11 + 28), v11[1], v11[3]);
  }

  if ((v17 & 1) == 0)
  {
    if ((v17 & 2) == 0)
    {
      goto LABEL_30;
    }

LABEL_35:
    *(v15 + 33) |= 0x10u;
    *(v15 + 12) = v11[4];
    if ((v11[6] & 4) == 0)
    {
      goto LABEL_32;
    }

    goto LABEL_31;
  }

  *(v15 + 33) |= 8u;
  *(v15 + 8) = v11[3];
  v17 = v11[6];
  if ((v17 & 2) != 0)
  {
    goto LABEL_35;
  }

LABEL_30:
  if ((v17 & 4) != 0)
  {
LABEL_31:
    *(v15 + 33) |= 2u;
    *(v15 + 31) = v11[5];
  }

LABEL_32:
  *(v15 + 35) = v12;
  v37 = *v11;
  v38 = v11[1];
  *(v15 + 24) = v37;
  *(v15 + 26) = v38;
  v39 = (*v15 + *(v15 + 16));
  v40 = v11 + 7;
  memcpy(v39, v11 + 7, v37);
  v41 = *v11;
  v42 = &v39[v41];
  if (v12)
  {
    *v42 = 8250;
    v43 = v42 + 2;
    *(v15 + 20) = v43 - *v15;
    memcpy(v43, v40 + *v11, v11[1]);
    *&v43[v11[1]] = 2573;
  }

  else
  {
    *(v15 + 20) = v42 - *v15;
    memcpy(v42, v40 + v41, v11[1]);
  }

  result = (*(*(a1 + 5) + 16))(*(a2 + 32), v15);
  if (!result)
  {
    a1[7] += v11[1] + *v11;
  }

  return result;
}

double header_out_begin_dynamic_nameref(int *a1, void *a2, unsigned int *a3, int a4)
{
  if (a2[10])
  {
    __assert_rtn("header_out_begin_dynamic_nameref", "lsqpack.c", 3167, "!read_ctx->hbrc_out.xhdr");
  }

  v8 = 4 * (*a1 & 1);
  v9 = (*(*(a1 + 5) + 8))(a2[4], 0, v8 + *a3);
  a2[10] = v9;
  if (v9)
  {
    v11 = v9;
    *(v9 + 35) = v8;
    if (a4)
    {
      *(v9 + 33) |= 0x40u;
    }

    v12 = *a1;
    v13 = *a1 & 6;
    v14 = a3[6];
    if (v13)
    {
      v15 = (a3[6] & 1) == 0;
    }

    else
    {
      v15 = 0;
    }

    if (v15)
    {
      v14 |= 1u;
      a3[6] = v14;
      v16 = (a3 + 7);
      v17 = *a3;
      if (v17 < 0x10)
      {
        v28 = v17 + 414139866;
      }

      else
      {
        v18 = v16 + v17 - 15;
        v19 = 645669457;
        v20 = -2008766304;
        v21 = 39378473;
        v22 = 1679910008;
        do
        {
          HIDWORD(v23) = v19 - 2048144777 * *v16;
          LODWORD(v23) = HIDWORD(v23);
          v19 = -1640531535 * (v23 >> 19);
          HIDWORD(v23) = v20 - 2048144777 * v16[1];
          LODWORD(v23) = HIDWORD(v23);
          v20 = -1640531535 * (v23 >> 19);
          HIDWORD(v23) = v21 - 2048144777 * v16[2];
          LODWORD(v23) = HIDWORD(v23);
          v21 = -1640531535 * (v23 >> 19);
          HIDWORD(v23) = v22 - 2048144777 * v16[3];
          LODWORD(v23) = HIDWORD(v23);
          v22 = -1640531535 * (v23 >> 19);
          v16 += 4;
        }

        while (v16 < v18);
        HIDWORD(v25) = v19;
        LODWORD(v25) = v19;
        v24 = v25 >> 31;
        HIDWORD(v25) = v20;
        LODWORD(v25) = v20;
        v26 = v25 >> 25;
        HIDWORD(v25) = v21;
        LODWORD(v25) = v21;
        v27 = v25 >> 20;
        HIDWORD(v25) = v22;
        LODWORD(v25) = v22;
        v28 = v24 + v17 + v26 + v27 + (v25 >> 14);
        v17 &= 0xFu;
      }

      if (v17 >= 4)
      {
        do
        {
          v29 = *v16++;
          HIDWORD(v30) = v28 - 1028477379 * v29;
          LODWORD(v30) = HIDWORD(v30);
          v28 = 668265263 * (v30 >> 15);
          v17 -= 4;
        }

        while (v17 > 3);
      }

      for (; v17; --v17)
      {
        v31 = *v16;
        v16 = (v16 + 1);
        HIDWORD(v32) = v28 + 374761393 * v31;
        LODWORD(v32) = HIDWORD(v32);
        v28 = -1640531535 * (v32 >> 21);
      }

      v33 = -1028477379 * ((-2048144777 * (v28 ^ (v28 >> 15))) ^ ((-2048144777 * (v28 ^ (v28 >> 15))) >> 13));
      a3[3] = v33 ^ HIWORD(v33);
    }

    if ((v12 & 4) != 0 && (v14 & 2) == 0)
    {
      if ((v14 & 1) == 0)
      {
        __assert_rtn("qdec_maybe_update_entry_hashes", "lsqpack.c", 3000, "entry->dte_flags & DTEF_NAME_HASH");
      }

      v14 |= 2u;
      a3[6] = v14;
      a3[4] = XXH_INLINE_XXH32((a3 + *a3 + 28), a3[1], a3[3]);
    }

    if (v14)
    {
      *(v11 + 33) |= 8u;
      *(v11 + 8) = a3[3];
      v14 = a3[6];
    }

    if ((v14 & 4) != 0)
    {
      *(v11 + 33) |= 2u;
      *(v11 + 31) = a3[5];
    }

    v34 = *a3;
    *(v11 + 24) = v34;
    v35 = (*v11 + *(v11 + 16));
    memcpy(v35, a3 + 7, v34);
    v36 = &v35[*a3];
    if (v8)
    {
      *v36 = 8250;
      LODWORD(v36) = v36 + 2;
    }

    *(v11 + 20) = v36 - *v11;
    *&result = 1;
    a2[11] = 1;
  }

  return result;
}

uint64_t header_out_grow_buf(uint64_t a1, uint64_t a2)
{
  v3 = (a2 + 80);
  v2 = *(a2 + 80);
  if (!v2)
  {
    __assert_rtn("header_out_grow_buf", "lsqpack.c", 3327, "read_ctx->hbrc_out.xhdr");
  }

  if (*(a2 + 88))
  {
    v5 = *(v2 + 20) - *(v2 + 16) + *(a2 + 92);
  }

  else
  {
    v5 = *(a2 + 92);
  }

  v6 = *(v2 + 26);
  v7 = v6 >= v5;
  v8 = v6 - v5;
  if (!v7)
  {
    __assert_rtn("header_out_grow_buf", "lsqpack.c", 3339, "read_ctx->hbrc_out.xhdr->val_len >= off");
  }

  if (v8 <= 2)
  {
    v8 = 2;
  }

  v9 = (v8 >> 1) + *(v2 + 26);
  if (v9 >> 16)
  {
    return 0xFFFFFFFFLL;
  }

  v11 = (*(*(a1 + 40) + 8))(*(a2 + 32), *(a2 + 80), v9);
  *(a2 + 80) = v11;
  if (!v11)
  {
    return 0xFFFFFFFFLL;
  }

  if (v9 > *(v11 + 26))
  {
    v12 = *(a1 + 48);
    if (v12)
    {
      fwrite("qdec: info: ", 0xCuLL, 1uLL, v12);
      fprintf(*(a1 + 48), "allocated xhdr size (%zd) is smaller than requested (%zd)", *(*v3 + 26), v9);
      fputc(10, *(a1 + 48));
    }

    *v3 = 0;
    v3[1] = 0;
    return 0xFFFFFFFFLL;
  }

  return 0;
}

uint64_t lsqpack_dec_push_entry(uint64_t a1, const char *a2)
{
  v4 = *(a1 + 56);
  if (v4)
  {
    if ((*(a1 + 60) + 1) % v4 != *(a1 + 64))
    {
      v11 = *(a1 + 72);
      goto LABEL_12;
    }

    v5 = malloc_type_malloc(16 * v4, 0x80040B8603338uLL);
    if (v5)
    {
      v6 = *(a1 + 60);
      v7 = *(a1 + 64);
      if (v6 >= v7)
      {
        v12 = v6 - v7;
        v9 = v5;
        memcpy(v5, (*(a1 + 72) + 8 * v7), 8 * (v6 - v7 + 1));
        v10 = 0;
        *(a1 + 60) = v12;
      }

      else
      {
        v8 = v5;
        memcpy(v5, *(a1 + 72), 8 * v6 + 8);
        v9 = v8;
        memcpy(&v8[8 * *(a1 + 56) + 8 * *(a1 + 64)], (*(a1 + 72) + 8 * *(a1 + 64)), 8 * (*(a1 + 56) - *(a1 + 64)));
        v10 = *(a1 + 64) + *(a1 + 56);
      }

      *(a1 + 64) = v10;
      free(*(a1 + 72));
      v11 = v9;
      *(a1 + 72) = v9;
      v4 = 2 * *(a1 + 56);
      goto LABEL_11;
    }

    return 0xFFFFFFFFLL;
  }

  v11 = malloc_type_malloc(0x20uLL, 0x80040B8603338uLL);
  *(a1 + 72) = v11;
  if (!v11)
  {
    return 0xFFFFFFFFLL;
  }

  v4 = 4;
LABEL_11:
  *(a1 + 56) = v4;
LABEL_12:
  v13 = *(a1 + 60);
  v11[v13] = a2;
  *(a1 + 60) = (v13 + 1) % v4;
  *(a1 + 12) += *a2 + *(a2 + 1) + 32;
  v14 = *(a1 + 48);
  if (v14)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v14);
    fputc(10, *(a1 + 48));
  }

  v15 = *(a1 + 20);
  if (v15)
  {
    v15 = (*(a1 + 32) + 1) % (2 * v15);
  }

  *(a1 + 32) = v15;
  qdec_remove_overflow_entries(a1);
  v16 = a1 + 16 * (*(a1 + 32) & 7);
  v19 = *(v16 + 96);
  v17 = v16 + 96;
  v18 = v19;
  if (v19)
  {
    v20 = (v17 + 8);
    do
    {
      v21 = *(v18 + 16);
      if (*(v18 + 64) == *(a1 + 32))
      {
        *(v18 + 104) &= ~4u;
        v22 = *(v18 + 24);
        v23 = (v21 + 24);
        if (!v21)
        {
          v23 = v20;
        }

        *v23 = v22;
        *v22 = v21;
        --*(a1 + 224);
        v24 = *(a1 + 48);
        if (v24)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v24);
          fprintf(*(a1 + 48), "header block for stream %llu has become unblocked", *(v18 + 40));
          fputc(10, *(a1 + 48));
        }

        (**(a1 + 40))(*(v18 + 32));
      }

      v18 = v21;
    }

    while (v21);
  }

  if (*(a1 + 12) > *(a1 + 8))
  {
    return 0xFFFFFFFFLL;
  }

  return 0;
}

void qdec_remove_overflow_entries(uint64_t a1)
{
  v1 = *(a1 + 12);
  while (v1 > *(a1 + 8))
  {
    v3 = *(a1 + 48);
    if (v3)
    {
      fwrite("qdec: debug: ", 0xDuLL, 1uLL, v3);
      fprintf(*(a1 + 48), "capacity %u, drop entry", *(a1 + 12));
      fputc(10, *(a1 + 48));
      v1 = *(a1 + 12);
    }

    v4 = *(a1 + 64);
    v5 = *(*(a1 + 72) + 8 * v4);
    *(a1 + 64) = (v4 + 1) % *(a1 + 56);
    v1 = v1 - (*v5 + v5[1]) - 32;
    *(a1 + 12) = v1;
    v6 = v5[2] - 1;
    v5[2] = v6;
    if (!v6)
    {
      free(v5);
      v1 = *(a1 + 12);
    }
  }
}

uint64_t nw_endpoint_get_url_port(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    url_port = _nw_endpoint_get_url_port(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_endpoint_get_url_port";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_get_url_port";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_endpoint_get_url_port";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_endpoint_get_url_port";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_get_url_port";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  url_port = 0;
LABEL_3:

  return url_port;
}

uint64_t nw_endpoint_copy_cfurl(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_endpoint_copy_cfurl(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_endpoint_copy_cfurl";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_copy_cfurl";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_endpoint_copy_cfurl";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_endpoint_copy_cfurl";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_copy_cfurl";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_endpoint_get_sanitized_url(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    sanitized_url = _nw_endpoint_get_sanitized_url(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_endpoint_get_sanitized_url";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_get_sanitized_url";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_endpoint_get_sanitized_url";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_endpoint_get_sanitized_url";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_get_sanitized_url";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  sanitized_url = 0;
LABEL_3:

  return sanitized_url;
}

uint64_t nw_endpoint_get_url_hash(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    url_hash = _nw_endpoint_get_url_hash(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_endpoint_get_url_hash";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_get_url_hash";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_endpoint_get_url_hash";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_endpoint_get_url_hash";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_get_url_hash";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  url_hash = 0;
LABEL_3:

  return url_hash;
}

uint64_t nw_endpoint_url_scheme_is_secure(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    is_secure = _nw_endpoint_url_scheme_is_secure(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_endpoint_url_scheme_is_secure";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_url_scheme_is_secure";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_endpoint_url_scheme_is_secure";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_endpoint_url_scheme_is_secure";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_url_scheme_is_secure";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  is_secure = 0;
LABEL_3:

  return is_secure;
}

uint64_t countOfBytesExpectedToReceive(void *a1)
{
  v1 = a1;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && ([v1 valueForHTTPHeaderField:@"Content-Encoding"], (v2 = objc_claimAutoreleasedReturnValue()) != 0) && (v3 = v2, v4 = objc_msgSend(v2, "caseInsensitiveCompare:", @"identity"), v3, v4))
  {
    v5 = *MEMORY[0x1E695ABD8];
  }

  else
  {
    v5 = [v1 expectedContentLength];
  }

  return v5;
}

uint64_t nw_interface_get_shallow_hash(uint64_t a1)
{
  if (a1)
  {
    return _nw_interface_get_shallow_hash(a1);
  }

  return a1;
}

uint64_t nw_interface_create_with_index_and_name(int a1, uint64_t a2)
{
  v21 = *MEMORY[0x1E69E9840];
  if (a1 <= 0)
  {
    v3 = __nwlog_obj();
    *buf = 136446466;
    v16 = "nw_interface_create_with_index_and_name";
    v17 = 2082;
    v18 = "Invalid interface index";
    v4 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v4, &type, &v13))
    {
      goto LABEL_35;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446466;
        v16 = "nw_interface_create_with_index_and_name";
        v17 = 2082;
        v18 = "Invalid interface index";
        v7 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
LABEL_33:
        _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0x16u);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v10 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446722;
          v16 = "nw_interface_create_with_index_and_name";
          v17 = 2082;
          v18 = "Invalid interface index";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v5, v6, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(backtrace_string);
LABEL_35:
        if (!v4)
        {
          return 0;
        }

LABEL_36:
        free(v4);
        return 0;
      }

      if (v10)
      {
        *buf = 136446466;
        v16 = "nw_interface_create_with_index_and_name";
        v17 = 2082;
        v18 = "Invalid interface index";
        v7 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_33;
      }
    }

    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446466;
        v16 = "nw_interface_create_with_index_and_name";
        v17 = 2082;
        v18 = "Invalid interface index";
        v7 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_33;
      }
    }

LABEL_34:

    goto LABEL_35;
  }

  if (!a2)
  {
    v8 = __nwlog_obj();
    *buf = 136446466;
    v16 = "nw_interface_create_with_index_and_name";
    v17 = 2082;
    v18 = "Invalid interface name";
    v4 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v4, &type, &v13))
    {
      goto LABEL_35;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446466;
        v16 = "nw_interface_create_with_index_and_name";
        v17 = 2082;
        v18 = "Invalid interface name";
        v7 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
        goto LABEL_33;
      }
    }

    else
    {
      if (v13 == 1)
      {
        v11 = __nw_create_backtrace_string();
        v5 = __nwlog_obj();
        v6 = type;
        v12 = os_log_type_enabled(v5, type);
        if (v11)
        {
          if (v12)
          {
            *buf = 136446722;
            v16 = "nw_interface_create_with_index_and_name";
            v17 = 2082;
            v18 = "Invalid interface name";
            v19 = 2082;
            v20 = v11;
            _os_log_impl(&dword_181A37000, v5, v6, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v11);
          if (!v4)
          {
            return 0;
          }

          goto LABEL_36;
        }

        if (!v12)
        {
          goto LABEL_34;
        }

        *buf = 136446466;
        v16 = "nw_interface_create_with_index_and_name";
        v17 = 2082;
        v18 = "Invalid interface name";
        v7 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_33;
      }

      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446466;
        v16 = "nw_interface_create_with_index_and_name";
        v17 = 2082;
        v18 = "Invalid interface name";
        v7 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_33;
      }
    }

    goto LABEL_34;
  }

  return _nw_interface_create_with_index_and_name();
}

uint64_t nw_interface_get_ipv4_netmask(uint64_t a1, char *a2)
{
  v18 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_interface_get_ipv4_netmask(a1, a2);
  }

  v3 = __nwlog_obj();
  *buf = 136446466;
  v13 = "nw_interface_get_ipv4_netmask";
  v14 = 2082;
  v15 = "Invalid interface object";
  v4 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446466;
        v13 = "nw_interface_get_ipv4_netmask";
        v14 = 2082;
        v15 = "Invalid interface object";
        v7 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
LABEL_18:
        _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0x16u);
      }
    }

    else
    {
      if (v10 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v5 = __nwlog_obj();
        v6 = type;
        v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *buf = 136446722;
            v13 = "nw_interface_get_ipv4_netmask";
            v14 = 2082;
            v15 = "Invalid interface object";
            v16 = 2082;
            v17 = backtrace_string;
            _os_log_impl(&dword_181A37000, v5, v6, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v9)
        {
          goto LABEL_19;
        }

        *buf = 136446466;
        v13 = "nw_interface_get_ipv4_netmask";
        v14 = 2082;
        v15 = "Invalid interface object";
        v7 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_18;
      }

      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446466;
        v13 = "nw_interface_get_ipv4_netmask";
        v14 = 2082;
        v15 = "Invalid interface object";
        v7 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v4)
  {
    free(v4);
  }

  return 0;
}

uint64_t nw_interface_get_ipv4_broadcast(uint64_t a1, char *a2)
{
  v18 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_interface_get_ipv4_broadcast(a1, a2);
  }

  v3 = __nwlog_obj();
  *buf = 136446466;
  v13 = "nw_interface_get_ipv4_broadcast";
  v14 = 2082;
  v15 = "Invalid interface object";
  v4 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446466;
        v13 = "nw_interface_get_ipv4_broadcast";
        v14 = 2082;
        v15 = "Invalid interface object";
        v7 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
LABEL_18:
        _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0x16u);
      }
    }

    else
    {
      if (v10 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v5 = __nwlog_obj();
        v6 = type;
        v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *buf = 136446722;
            v13 = "nw_interface_get_ipv4_broadcast";
            v14 = 2082;
            v15 = "Invalid interface object";
            v16 = 2082;
            v17 = backtrace_string;
            _os_log_impl(&dword_181A37000, v5, v6, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v9)
        {
          goto LABEL_19;
        }

        *buf = 136446466;
        v13 = "nw_interface_get_ipv4_broadcast";
        v14 = 2082;
        v15 = "Invalid interface object";
        v7 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_18;
      }

      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446466;
        v13 = "nw_interface_get_ipv4_broadcast";
        v14 = 2082;
        v15 = "Invalid interface object";
        v7 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v4)
  {
    free(v4);
  }

  return 0;
}

uint64_t nw_interface_is_multilayer_packet_logging_enabled(uint64_t a1)
{
  v17 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_interface_is_multilayer_packet_logging_enabled(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446466;
  v12 = "nw_interface_is_multilayer_packet_logging_enabled";
  v13 = 2082;
  v14 = "Invalid interface object";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446466;
        v12 = "nw_interface_is_multilayer_packet_logging_enabled";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0x16u);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446722;
            v12 = "nw_interface_is_multilayer_packet_logging_enabled";
            v13 = 2082;
            v14 = "Invalid interface object";
            v15 = 2082;
            v16 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446466;
        v12 = "nw_interface_is_multilayer_packet_logging_enabled";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446466;
        v12 = "nw_interface_is_multilayer_packet_logging_enabled";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

unint64_t nw_interface_get_tso_max_segment_size_v4(uint64_t a1)
{
  v17 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_interface_get_tso_max_segment_size_v4(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446466;
  v12 = "nw_interface_get_tso_max_segment_size_v4";
  v13 = 2082;
  v14 = "Invalid interface object";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446466;
        v12 = "nw_interface_get_tso_max_segment_size_v4";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0x16u);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446722;
            v12 = "nw_interface_get_tso_max_segment_size_v4";
            v13 = 2082;
            v14 = "Invalid interface object";
            v15 = 2082;
            v16 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446466;
        v12 = "nw_interface_get_tso_max_segment_size_v4";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446466;
        v12 = "nw_interface_get_tso_max_segment_size_v4";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

unint64_t nw_interface_get_tso_max_segment_size_v6(uint64_t a1)
{
  v17 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_interface_get_tso_max_segment_size_v6(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446466;
  v12 = "nw_interface_get_tso_max_segment_size_v6";
  v13 = 2082;
  v14 = "Invalid interface object";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446466;
        v12 = "nw_interface_get_tso_max_segment_size_v6";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0x16u);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446722;
            v12 = "nw_interface_get_tso_max_segment_size_v6";
            v13 = 2082;
            v14 = "Invalid interface object";
            v15 = 2082;
            v16 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446466;
        v12 = "nw_interface_get_tso_max_segment_size_v6";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446466;
        v12 = "nw_interface_get_tso_max_segment_size_v6";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

uint64_t nw_interface_get_low_power_wake(uint64_t a1)
{
  v17 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_interface_get_low_power_wake(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446466;
  v12 = "nw_interface_get_low_power_wake";
  v13 = 2082;
  v14 = "Invalid interface object";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446466;
        v12 = "nw_interface_get_low_power_wake";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0x16u);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446722;
            v12 = "nw_interface_get_low_power_wake";
            v13 = 2082;
            v14 = "Invalid interface object";
            v15 = 2082;
            v16 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446466;
        v12 = "nw_interface_get_low_power_wake";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446466;
        v12 = "nw_interface_get_low_power_wake";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

unint64_t nw_interface_get_csum_flags(uint64_t a1)
{
  v17 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_interface_get_csum_flags(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446466;
  v12 = "nw_interface_get_csum_flags";
  v13 = 2082;
  v14 = "Invalid interface object";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446466;
        v12 = "nw_interface_get_csum_flags";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0x16u);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446722;
            v12 = "nw_interface_get_csum_flags";
            v13 = 2082;
            v14 = "Invalid interface object";
            v15 = 2082;
            v16 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446466;
        v12 = "nw_interface_get_csum_flags";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446466;
        v12 = "nw_interface_get_csum_flags";
        v13 = 2082;
        v14 = "Invalid interface object";
        v6 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

const char *nw_interface_type_get_description(unsigned int a1)
{
  if (a1 > 4)
  {
    return "unknown";
  }

  else
  {
    return off_1E6A357B8[a1];
  }
}

const char *nw_interface_subtype_get_description(int a1)
{
  if (a1 <= 1001)
  {
    if (!a1)
    {
      return "other";
    }

    if (a1 == 1001)
    {
      return "wifi_infrastructure";
    }
  }

  else
  {
    switch(a1)
    {
      case 1002:
        return "wifi_awdl";
      case 4001:
        return "coprocessor";
      case 5001:
        return "companion";
    }
  }

  return "unknown";
}

uint64_t nw_interface_copy_local_address_for_remote_address(void *a1, void *a2)
{
  v60 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    v23 = __nwlog_obj();
    *__src = 136446210;
    *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
    v15 = _os_log_send_and_compose_impl();

    v42[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (!__nwlog_fault(v15, v42, buf))
    {
      goto LABEL_34;
    }

    if (v42[0] == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = v42[0];
      if (os_log_type_enabled(v24, v42[0]))
      {
        *__src = 136446210;
        *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_181A37000, v24, v25, "%{public}s called with null interface", __src, 0xCu);
      }

      goto LABEL_85;
    }

    if (buf[0] != 1)
    {
      v24 = __nwlog_obj();
      v37 = v42[0];
      if (os_log_type_enabled(v24, v42[0]))
      {
        *__src = 136446210;
        *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_181A37000, v24, v37, "%{public}s called with null interface, backtrace limit exceeded", __src, 0xCu);
      }

      goto LABEL_85;
    }

    backtrace_string = __nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v31 = v42[0];
    v32 = os_log_type_enabled(v24, v42[0]);
    if (!backtrace_string)
    {
      if (v32)
      {
        *__src = 136446210;
        *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_181A37000, v24, v31, "%{public}s called with null interface, no backtrace", __src, 0xCu);
      }

      goto LABEL_85;
    }

    if (v32)
    {
      *__src = 136446466;
      *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
      *&__src[12] = 2082;
      *&__src[14] = backtrace_string;
      _os_log_impl(&dword_181A37000, v24, v31, "%{public}s called with null interface, dumping backtrace:%{public}s", __src, 0x16u);
    }

    goto LABEL_67;
  }

  if (!v4)
  {
    v26 = __nwlog_obj();
    *__src = 136446210;
    *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
    v15 = _os_log_send_and_compose_impl();

    v42[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (!__nwlog_fault(v15, v42, buf))
    {
      goto LABEL_34;
    }

    if (v42[0] == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v27 = v42[0];
      if (os_log_type_enabled(v24, v42[0]))
      {
        *__src = 136446210;
        *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_181A37000, v24, v27, "%{public}s called with null remote_endpoint", __src, 0xCu);
      }

      goto LABEL_85;
    }

    if (buf[0] != 1)
    {
      v24 = __nwlog_obj();
      v38 = v42[0];
      if (os_log_type_enabled(v24, v42[0]))
      {
        *__src = 136446210;
        *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_181A37000, v24, v38, "%{public}s called with null remote_endpoint, backtrace limit exceeded", __src, 0xCu);
      }

      goto LABEL_85;
    }

    backtrace_string = __nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v33 = v42[0];
    v34 = os_log_type_enabled(v24, v42[0]);
    if (!backtrace_string)
    {
      if (v34)
      {
        *__src = 136446210;
        *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_181A37000, v24, v33, "%{public}s called with null remote_endpoint, no backtrace", __src, 0xCu);
      }

      goto LABEL_85;
    }

    if (v34)
    {
      *__src = 136446466;
      *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
      *&__src[12] = 2082;
      *&__src[14] = backtrace_string;
      _os_log_impl(&dword_181A37000, v24, v33, "%{public}s called with null remote_endpoint, dumping backtrace:%{public}s", __src, 0x16u);
    }

    goto LABEL_67;
  }

  v6 = v4;
  v7 = _nw_endpoint_get_type(v6);

  if (v7 != 1)
  {
    v28 = __nwlog_obj();
    *__src = 136446210;
    *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
    v15 = _os_log_send_and_compose_impl();

    v42[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (!__nwlog_fault(v15, v42, buf))
    {
      goto LABEL_34;
    }

    if (v42[0] == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v29 = v42[0];
      if (os_log_type_enabled(v24, v42[0]))
      {
        *__src = 136446210;
        *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_181A37000, v24, v29, "%{public}s called with null (nw_endpoint_get_type(remote_endpoint) == nw_endpoint_type_address)", __src, 0xCu);
      }

LABEL_85:

      goto LABEL_34;
    }

    if (buf[0] != 1)
    {
      v24 = __nwlog_obj();
      v39 = v42[0];
      if (os_log_type_enabled(v24, v42[0]))
      {
        *__src = 136446210;
        *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_181A37000, v24, v39, "%{public}s called with null (nw_endpoint_get_type(remote_endpoint) == nw_endpoint_type_address), backtrace limit exceeded", __src, 0xCu);
      }

      goto LABEL_85;
    }

    backtrace_string = __nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v35 = v42[0];
    v36 = os_log_type_enabled(v24, v42[0]);
    if (!backtrace_string)
    {
      if (v36)
      {
        *__src = 136446210;
        *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_181A37000, v24, v35, "%{public}s called with null (nw_endpoint_get_type(remote_endpoint) == nw_endpoint_type_address), no backtrace", __src, 0xCu);
      }

      goto LABEL_85;
    }

    if (v36)
    {
      *__src = 136446466;
      *&__src[4] = "nw_interface_copy_local_address_for_remote_address";
      *&__src[12] = 2082;
      *&__src[14] = backtrace_string;
      _os_log_impl(&dword_181A37000, v24, v35, "%{public}s called with null (nw_endpoint_get_type(remote_endpoint) == nw_endpoint_type_address), dumping backtrace:%{public}s", __src, 0x16u);
    }

LABEL_67:

    free(backtrace_string);
    goto LABEL_34;
  }

  v45 = 0;
  index = _nw_interface_get_index(v3);
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  memset(__src, 0, sizeof(__src));
  *v42 = 0;
  v43 = 0;
  v44 = 0;
  v8 = nw_endpoint_fillout_v4v6_address(v6, v42);
  if ((v42[0] - 1) >= 0)
  {
    v9 = v8;
  }

  else
  {
    v9 = 0;
  }

  if (v9 == 1)
  {
    __memcpy_chk();
  }

  if (nw_context_copy_implicit_context::onceToken[0] != -1)
  {
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }

  v10 = nw_context_copy_implicit_context::implicit_context;
  nw_path_shared_necp_fd(v10);

  if (necp_client_action())
  {
    v11 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = v12;
    if (v11 == 2)
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446466;
        v48 = "nw_interface_copy_local_address_for_remote_address";
        v49 = 1024;
        v50 = 2;
        _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d", buf, 0x12u);
      }

      goto LABEL_36;
    }

    *buf = 136446466;
    v48 = "nw_interface_copy_local_address_for_remote_address";
    v49 = 1024;
    v50 = v11;
    v15 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v15, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *buf = 136446466;
          v48 = "nw_interface_copy_local_address_for_remote_address";
          v49 = 1024;
          v50 = v11;
          _os_log_impl(&dword_181A37000, v16, v17, "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d", buf, 0x12u);
        }
      }

      else if (v40 == 1)
      {
        v18 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        v19 = type;
        v20 = os_log_type_enabled(v16, type);
        if (v18)
        {
          if (v20)
          {
            *buf = 136446722;
            v48 = "nw_interface_copy_local_address_for_remote_address";
            v49 = 1024;
            v50 = v11;
            v51 = 2082;
            v52 = v18;
            _os_log_impl(&dword_181A37000, v16, v19, "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v18);
          if (!v15)
          {
            goto LABEL_36;
          }

          goto LABEL_35;
        }

        if (v20)
        {
          *buf = 136446466;
          v48 = "nw_interface_copy_local_address_for_remote_address";
          v49 = 1024;
          v50 = v11;
          _os_log_impl(&dword_181A37000, v16, v19, "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        v21 = type;
        if (os_log_type_enabled(v16, type))
        {
          *buf = 136446466;
          v48 = "nw_interface_copy_local_address_for_remote_address";
          v49 = 1024;
          v50 = v11;
          _os_log_impl(&dword_181A37000, v16, v21, "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }

LABEL_34:
    if (!v15)
    {
LABEL_36:
      address = 0;
      goto LABEL_37;
    }

LABEL_35:
    free(v15);
    goto LABEL_36;
  }

  address = _nw_endpoint_create_address(__src);
LABEL_37:

  return address;
}

uint64_t nw_interface_get_loopback_index()
{
  if (nw_interface_get_loopback_index_onceToken != -1)
  {
    dispatch_once(&nw_interface_get_loopback_index_onceToken, &__block_literal_global_53613);
  }

  return nw_interface_get_loopback_index_index;
}

uint64_t nw_interface_radio_type_from_string(const char *a1)
{
  if (!strncasecmp(a1, "802.11b", 8uLL))
  {
    return 1;
  }

  if (!strncasecmp(a1, "802.11a", 8uLL))
  {
    return 2;
  }

  if (!strncasecmp(a1, "802.11g", 8uLL))
  {
    return 3;
  }

  if (!strncasecmp(a1, "802.11n", 8uLL))
  {
    return 4;
  }

  if (!strncasecmp(a1, "802.11ac", 9uLL))
  {
    return 5;
  }

  if (!strncasecmp(a1, "802.11ax", 9uLL))
  {
    return 6;
  }

  if (!strncasecmp(a1, "lte", 4uLL))
  {
    return 128;
  }

  if (!strncasecmp(a1, "endc_sub6", 0xAuLL))
  {
    return 129;
  }

  if (!strncasecmp(a1, "endc_mmw", 9uLL))
  {
    return 130;
  }

  if (!strncasecmp(a1, "nr_sa_sub6", 0xBuLL))
  {
    return 131;
  }

  if (!strncasecmp(a1, "nr_sa_mmw", 0xAuLL))
  {
    return 132;
  }

  if (!strncasecmp(a1, "wcdma", 6uLL))
  {
    return 133;
  }

  if (!strncasecmp(a1, "gsm", 4uLL))
  {
    return 134;
  }

  if (!strncasecmp(a1, "cdma", 5uLL))
  {
    return 135;
  }

  if (!strncasecmp(a1, "evdo", 5uLL))
  {
    return 136;
  }

  return 0;
}

uint64_t nw_ws_allocate_options(void *a1)
{
  v1 = a1;
  v2 = malloc_type_calloc(1uLL, 0x48uLL, 0xC9ACE78uLL);
  v3 = v2;
  if (v2)
  {
    v2[8] = 0;
    *(v2 + 2) = 0u;
    *(v2 + 3) = 0u;
    *v2 = 0u;
    *(v2 + 1) = 0u;
LABEL_6:

    return v3;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = gLogObj;
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  v5 = _os_log_send_and_compose_impl();

  result = __nwlog_should_abort(v5);
  if (!result)
  {
    free(v5);
    MEMORY[0x30] = 0u;
    MEMORY[0x40] = 0;
    MEMORY[0x20] = 0u;
    MEMORY[0x10] = 0u;
    MEMORY[0] = 0u;
    MEMORY[0x28] = 0;
    MEMORY[0x30] = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    v8 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v8);
    if (!result)
    {
      free(v8);
      goto LABEL_6;
    }
  }

  __break(1u);
  return result;
}

nw_protocol_options_t nw_ws_create_options(nw_ws_version_t version)
{
  if (nw_protocol_copy_ws_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_ws_definition::onceToken, &__block_literal_global_4247);
  }

  v2 = nw_protocol_copy_ws_definition::definition;
  options = nw_protocol_create_options(v2);

  v5[0] = MEMORY[0x1E69E9820];
  v5[1] = 3221225472;
  v5[2] = __nw_ws_create_options_block_invoke;
  v5[3] = &__block_descriptor_36_e9_B16__0_v8l;
  v6 = version;
  nw_protocol_options_access_handle(options, v5);
  return options;
}

uint64_t __nw_ws_create_options_block_invoke(uint64_t a1, uint64_t a2)
{
  *(a2 + 56) = *(a1 + 32);
  v3 = xpc_array_create(0, 0);
  v4 = *a2;
  *a2 = v3;

  v5 = xpc_array_create(0, 0);
  v6 = *(a2 + 8);
  *(a2 + 8) = v5;

  v7 = xpc_array_create(0, 0);
  v8 = *(a2 + 16);
  *(a2 + 16) = v7;

  *(a2 + 70) = *(a2 + 70) & 0xC7 | 0x30;
  *(a2 + 68) = 3855;
  *(a2 + 60) = 0x100000001000;
  return 1;
}

uint64_t nw_ws_copy_options(void *a1, uint64_t a2)
{
  v34 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (!a2)
  {
    v18 = __nwlog_obj();
    *buf = 136446210;
    v29 = "nw_ws_copy_options";
    v19 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v19, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v20 = __nwlog_obj();
        v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *buf = 136446210;
          v29 = "nw_ws_copy_options";
          _os_log_impl(&dword_181A37000, v20, v21, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }

      else if (v26 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v20 = __nwlog_obj();
        v23 = type;
        v24 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *buf = 136446466;
            v29 = "nw_ws_copy_options";
            v30 = 2082;
            v31 = backtrace_string;
            _os_log_impl(&dword_181A37000, v20, v23, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v24)
        {
          *buf = 136446210;
          v29 = "nw_ws_copy_options";
          _os_log_impl(&dword_181A37000, v20, v23, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v20 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v20, type))
        {
          *buf = 136446210;
          v29 = "nw_ws_copy_options";
          _os_log_impl(&dword_181A37000, v20, v25, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_25:
    if (v19)
    {
      free(v19);
    }

    v5 = 0;
    goto LABEL_8;
  }

  v4 = malloc_type_calloc(1uLL, 0x48uLL, 0xEC527C79uLL);
  v5 = v4;
  if (v4)
  {
    v4[8] = 0;
    *(v4 + 2) = 0u;
    *(v4 + 3) = 0u;
    *v4 = 0u;
    *(v4 + 1) = 0u;
LABEL_7:
    objc_storeStrong(v5, *a2);
    objc_storeStrong(v5 + 1, *(a2 + 8));
    objc_storeStrong(v5 + 2, *(a2 + 16));
    v11 = _Block_copy(*(a2 + 40));
    v12 = v5[5];
    v5[5] = v11;

    objc_storeStrong(v5 + 6, *(a2 + 48));
    v13 = *(v5 + 70);
    *(v5 + 14) = *(a2 + 56);
    *(v5 + 70) = v13 & 0xFE | *(a2 + 70) & 1;
    v5[4] = *(a2 + 32);
    objc_storeStrong(v5 + 3, *(a2 + 24));
    v14 = *(v5 + 70) & 0xFD | (2 * ((*(a2 + 70) >> 1) & 1));
    *(v5 + 70) = v14;
    v15 = v14 & 0xFFFFFFFB | (4 * ((*(a2 + 70) >> 2) & 1));
    *(v5 + 70) = v15;
    v16 = v15 & 0xFFFFFFF7 | (8 * ((*(a2 + 70) >> 3) & 1));
    *(v5 + 70) = v16;
    v17 = v16 & 0xFFFFFFEF | (16 * ((*(a2 + 70) >> 4) & 1));
    *(v5 + 70) = v17;
    *(v5 + 70) = v17 & 0xDF | *(a2 + 70) & 0x20;
    *(v5 + 34) = *(a2 + 68);
    *(v5 + 60) = *(a2 + 60);
LABEL_8:

    return v5;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = gLogObj;
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v29 = "nw_ws_copy_options";
  v30 = 2048;
  v31 = 1;
  v32 = 2048;
  v33 = 72;
  v7 = _os_log_send_and_compose_impl();

  result = __nwlog_should_abort(v7);
  if (!result)
  {
    free(v7);
    MEMORY[0x30] = 0u;
    MEMORY[0x40] = 0;
    MEMORY[0x20] = 0u;
    MEMORY[0x10] = 0u;
    MEMORY[0] = 0u;
    MEMORY[0x28] = 0;
    MEMORY[0x30] = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v29 = "nw_ws_copy_options";
    v10 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v10);
    if (!result)
    {
      free(v10);
      goto LABEL_7;
    }
  }

  __break(1u);
  return result;
}

void nw_ws_deallocate_options(uint64_t a1, id *a2)
{
  v3 = *a2;
  *a2 = 0;

  v4 = a2[1];
  a2[1] = 0;

  v5 = a2[2];
  a2[2] = 0;

  v6 = a2[5];
  a2[5] = 0;

  v7 = a2[6];
  a2[6] = 0;

  free(a2);
}

uint64_t nw_ws_option_is_equal(void *a1, uint64_t a2, uint64_t a3)
{
  v5 = a1;
  count = xpc_array_get_count(*(a2 + 8));
  v7 = xpc_array_get_count(*(a3 + 8));
  v8 = xpc_array_get_count(*(a2 + 8));
  v9 = v8;
  if (count != v7 || v8 == 0)
  {
    if (count != v7)
    {
      goto LABEL_37;
    }

LABEL_24:
    if (nw_unordered_xpc_array_is_equal(*a2, *a3) && *(a2 + 40) == *(a3 + 40) && *(a2 + 48) == *(a3 + 48) && *(a2 + 56) == *(a3 + 56) && ((*(a3 + 70) ^ *(a2 + 70)) & 1) == 0 && *(a2 + 32) == *(a3 + 32))
    {
      v23 = 0;
      if (((*(a3 + 70) ^ *(a2 + 70)) & 0x3E) == 0 && *(a2 + 24) == *(a3 + 24))
      {
        if (*(a2 + 68) != *(a3 + 68) || *(a2 + 69) != *(a3 + 69) || *(a2 + 60) != *(a3 + 60))
        {
          goto LABEL_37;
        }

        v23 = *(a2 + 64) == *(a3 + 64);
      }
    }

    else
    {
LABEL_37:
      v23 = 0;
    }

    return v23;
  }

  else
  {
    v24 = v5;
    v11 = malloc_type_calloc(1uLL, v8, 0x9018D31EuLL);
    v12 = v11;
    if (v11)
    {
      goto LABEL_11;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = gLogObj;
    os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    v14 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v14);
    if (!result)
    {
      free(v14);
LABEL_11:
      v16 = 0;
      while (1)
      {
        v17 = xpc_array_get_value(*(a2 + 8), v16);
        v18 = xpc_array_get_value(*(a2 + 16), v16);
        v19 = 0;
        while ((v12[v19] & 1) != 0)
        {
LABEL_13:
          if (v9 == ++v19)
          {
            goto LABEL_19;
          }
        }

        v20 = xpc_array_get_value(*(a3 + 8), v19);
        v21 = xpc_array_get_value(*(a3 + 16), v19);
        if (!xpc_equal(v17, v20) || !xpc_equal(v18, v21))
        {
          break;
        }

        v12[v19] = 1;

LABEL_19:
        if (++v16 == v9)
        {
          v22 = 0;
          v5 = v24;
          while ((v12[v22] & 1) != 0)
          {
            if (v9 == ++v22)
            {
              free(v12);
              goto LABEL_24;
            }
          }

          free(v12);
          goto LABEL_37;
        }
      }

      goto LABEL_13;
    }

    __break(1u);
  }

  return result;
}

uint64_t nw_protocol_options_is_ws(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    if (nw_protocol_copy_ws_definition::onceToken != -1)
    {
      dispatch_once(&nw_protocol_copy_ws_definition::onceToken, &__block_literal_global_4247);
    }

    v2 = nw_protocol_copy_ws_definition::definition;
    v3 = nw_protocol_options_matches_definition(v1, v2);

    goto LABEL_5;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_protocol_options_is_ws";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_protocol_options_is_ws";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_protocol_options_is_ws";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_protocol_options_is_ws";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_protocol_options_is_ws";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_5:

  return v3;
}

void nw_ws_options_add_additional_header(nw_protocol_options_t options, const char *name, const char *value)
{
  v35 = *MEMORY[0x1E69E9840];
  v5 = options;
  if ((nw_protocol_options_is_ws(v5) & 1) == 0)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v30 = "nw_ws_options_add_additional_header";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v8, &type, &v27))
    {
      goto LABEL_63;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v27 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *buf = 136446466;
          v30 = "nw_ws_options_add_additional_header";
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_63:
        if (!v8)
        {
          goto LABEL_13;
        }

LABEL_64:
        free(v8);
        goto LABEL_13;
      }

      if (v17)
      {
        *buf = 136446210;
        v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A37000, v9, v23, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_62:

    goto LABEL_63;
  }

  if (!name)
  {
    v11 = __nwlog_obj();
    *buf = 136446210;
    v30 = "nw_ws_options_add_additional_header";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v8, &type, &v27))
    {
      goto LABEL_63;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null name", buf, 0xCu);
      }

      goto LABEL_62;
    }

    if (v27 != 1)
    {
      v9 = __nwlog_obj();
      v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A37000, v9, v24, "%{public}s called with null name, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_62;
    }

    v18 = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v19 = type;
    v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *buf = 136446210;
        v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null name, no backtrace", buf, 0xCu);
      }

      goto LABEL_62;
    }

    if (v20)
    {
      *buf = 136446466;
      v30 = "nw_ws_options_add_additional_header";
      v31 = 2082;
      v32 = v18;
      _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null name, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_43;
  }

  if (!value)
  {
    v13 = __nwlog_obj();
    *buf = 136446210;
    v30 = "nw_ws_options_add_additional_header";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v8, &type, &v27))
    {
      goto LABEL_63;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null value", buf, 0xCu);
      }

      goto LABEL_62;
    }

    if (v27 != 1)
    {
      v9 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A37000, v9, v25, "%{public}s called with null value, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_62;
    }

    v18 = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v21 = type;
    v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *buf = 136446210;
        v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A37000, v9, v21, "%{public}s called with null value, no backtrace", buf, 0xCu);
      }

      goto LABEL_62;
    }

    if (v22)
    {
      *buf = 136446466;
      v30 = "nw_ws_options_add_additional_header";
      v31 = 2082;
      v32 = v18;
      _os_log_impl(&dword_181A37000, v9, v21, "%{public}s called with null value, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_43:

    free(v18);
    if (!v8)
    {
      goto LABEL_13;
    }

    goto LABEL_64;
  }

  if (!strcasecmp(name, "Sec-WebSocket-Key") || !strcasecmp(name, "Sec-WebSocket-Protocol") || !strcasecmp(name, "Sec-WebSocket-Version") || !strcasecmp(name, "Upgrade") || !strcasecmp(name, "Connection"))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446722;
      v30 = "nw_ws_options_add_additional_header";
      v31 = 2080;
      v32 = name;
      v33 = 2080;
      v34 = value;
      _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_ERROR, "%{public}s Cannot override (%s, %s) header in the client's request", buf, 0x20u);
    }
  }

  else
  {
    v26[0] = MEMORY[0x1E69E9820];
    v26[1] = 3221225472;
    v26[2] = __nw_ws_options_add_additional_header_block_invoke;
    v26[3] = &__block_descriptor_48_e9_B16__0_v8l;
    v26[4] = name;
    v26[5] = value;
    nw_protocol_options_access_handle(v5, v26);
  }

LABEL_13:
}

uint64_t __nw_ws_options_add_additional_header_block_invoke(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 8);
  v5 = xpc_string_create(*(a1 + 32));
  xpc_array_append_value(v4, v5);

  v6 = *(a2 + 16);
  v7 = xpc_string_create(*(a1 + 40));
  xpc_array_append_value(v6, v7);

  return 1;
}

void nw_ws_options_set_maximum_message_size(nw_protocol_options_t options, size_t maximum_message_size)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = options;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_maximum_message_size_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = maximum_message_size;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_ws_options_set_maximum_message_size";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v16 = "nw_ws_options_set_maximum_message_size";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v16 = "nw_ws_options_set_maximum_message_size";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v16 = "nw_ws_options_set_maximum_message_size";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v16 = "nw_ws_options_set_maximum_message_size";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_ws_options_add_subprotocol(nw_protocol_options_t options, const char *subprotocol)
{
  v25 = *MEMORY[0x1E69E9840];
  v3 = options;
  if ((nw_protocol_options_is_ws(v3) & 1) == 0)
  {
    v4 = __nwlog_obj();
    *buf = 136446210;
    v22 = "nw_ws_options_add_subprotocol";
    v5 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v5, &type, &v19))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v22 = "nw_ws_options_add_subprotocol";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v19 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v22 = "nw_ws_options_add_subprotocol";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v5)
        {
          goto LABEL_4;
        }

LABEL_39:
        free(v5);
        goto LABEL_4;
      }

      if (v12)
      {
        *buf = 136446210;
        v22 = "nw_ws_options_add_subprotocol";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v22 = "nw_ws_options_add_subprotocol";
        _os_log_impl(&dword_181A37000, v6, v16, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_37:

    goto LABEL_38;
  }

  if (subprotocol)
  {
    v18[0] = MEMORY[0x1E69E9820];
    v18[1] = 3221225472;
    v18[2] = __nw_ws_options_add_subprotocol_block_invoke;
    v18[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v18[4] = subprotocol;
    nw_protocol_options_access_handle(v3, v18);
    goto LABEL_4;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  v22 = "nw_ws_options_add_subprotocol";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v5, &type, &v19))
  {
    goto LABEL_38;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v6 = __nwlog_obj();
    v9 = type;
    if (os_log_type_enabled(v6, type))
    {
      *buf = 136446210;
      v22 = "nw_ws_options_add_subprotocol";
      _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null subprotocol", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v19 != 1)
  {
    v6 = __nwlog_obj();
    v17 = type;
    if (os_log_type_enabled(v6, type))
    {
      *buf = 136446210;
      v22 = "nw_ws_options_add_subprotocol";
      _os_log_impl(&dword_181A37000, v6, v17, "%{public}s called with null subprotocol, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_37;
  }

  v13 = __nw_create_backtrace_string();
  v6 = __nwlog_obj();
  v14 = type;
  v15 = os_log_type_enabled(v6, type);
  if (!v13)
  {
    if (v15)
    {
      *buf = 136446210;
      v22 = "nw_ws_options_add_subprotocol";
      _os_log_impl(&dword_181A37000, v6, v14, "%{public}s called with null subprotocol, no backtrace", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v15)
  {
    *buf = 136446466;
    v22 = "nw_ws_options_add_subprotocol";
    v23 = 2082;
    v24 = v13;
    _os_log_impl(&dword_181A37000, v6, v14, "%{public}s called with null subprotocol, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v13);
  if (v5)
  {
    goto LABEL_39;
  }

LABEL_4:
}

uint64_t __nw_ws_options_add_subprotocol_block_invoke(uint64_t a1, void **a2)
{
  v2 = *a2;
  v3 = xpc_string_create(*(a1 + 32));
  xpc_array_append_value(v2, v3);

  return 1;
}

void nw_ws_options_set_auto_reply_ping(nw_protocol_options_t options, BOOL auto_reply_ping)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = options;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_auto_reply_ping_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = auto_reply_ping;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_ws_options_set_auto_reply_ping";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_auto_reply_ping";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_ws_options_set_auto_reply_ping";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_auto_reply_ping";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_auto_reply_ping";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_ws_options_set_skip_handshake(nw_protocol_options_t options, BOOL skip_handshake)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = options;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_skip_handshake_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = skip_handshake;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_ws_options_set_skip_handshake";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_skip_handshake";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_ws_options_set_skip_handshake";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_skip_handshake";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_skip_handshake";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_ws_options_set_prepend_data(void *a1, void *a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_options_is_ws(v3))
  {
    v13[0] = MEMORY[0x1E69E9820];
    v13[1] = 3221225472;
    v13[2] = __nw_ws_options_set_prepend_data_block_invoke;
    v13[3] = &unk_1E6A3A950;
    v14 = v4;
    nw_protocol_options_access_handle(v3, v13);

    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_ws_options_set_prepend_data";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v18 = "nw_ws_options_set_prepend_data";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v18 = "nw_ws_options_set_prepend_data";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v18 = "nw_ws_options_set_prepend_data";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v18 = "nw_ws_options_set_prepend_data";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

LABEL_3:
}

void nw_ws_options_set_client_request_handler(nw_protocol_options_t options, dispatch_queue_t client_queue, nw_ws_client_request_handler_t handler)
{
  v36 = *MEMORY[0x1E69E9840];
  v5 = options;
  v6 = client_queue;
  v7 = handler;
  if ((nw_protocol_options_is_ws(v5) & 1) == 0)
  {
    v8 = __nwlog_obj();
    *buf = 136446210;
    v33 = "nw_ws_options_set_client_request_handler";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v9, &type, &v30))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v30 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v17 = type;
      v18 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *buf = 136446466;
          v33 = "nw_ws_options_set_client_request_handler";
          v34 = 2082;
          v35 = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v17, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v9)
        {
          goto LABEL_5;
        }

LABEL_56:
        free(v9);
        goto LABEL_5;
      }

      if (v18)
      {
        *buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_181A37000, v10, v17, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v24 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_181A37000, v10, v24, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_54:

    goto LABEL_55;
  }

  if (!v6)
  {
    v12 = __nwlog_obj();
    *buf = 136446210;
    v33 = "nw_ws_options_set_client_request_handler";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v9, &type, &v30))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null client_queue", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v30 != 1)
    {
      v10 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_181A37000, v10, v25, "%{public}s called with null client_queue, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    v19 = __nw_create_backtrace_string();
    v10 = __nwlog_obj();
    v20 = type;
    v21 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v21)
      {
        *buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_181A37000, v10, v20, "%{public}s called with null client_queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *buf = 136446466;
      v33 = "nw_ws_options_set_client_request_handler";
      v34 = 2082;
      v35 = v19;
      _os_log_impl(&dword_181A37000, v10, v20, "%{public}s called with null client_queue, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_35;
  }

  if (!v7)
  {
    v14 = __nwlog_obj();
    *buf = 136446210;
    v33 = "nw_ws_options_set_client_request_handler";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v9, &type, &v30))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v30 != 1)
    {
      v10 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_181A37000, v10, v26, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    v19 = __nw_create_backtrace_string();
    v10 = __nwlog_obj();
    v22 = type;
    v23 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v23)
      {
        *buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_181A37000, v10, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *buf = 136446466;
      v33 = "nw_ws_options_set_client_request_handler";
      v34 = 2082;
      v35 = v19;
      _os_log_impl(&dword_181A37000, v10, v22, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_35:

    free(v19);
    if (!v9)
    {
      goto LABEL_5;
    }

    goto LABEL_56;
  }

  v27[0] = MEMORY[0x1E69E9820];
  v27[1] = 3221225472;
  v27[2] = __nw_ws_options_set_client_request_handler_block_invoke;
  v27[3] = &unk_1E6A3AA50;
  v28 = v6;
  v29 = v7;
  nw_protocol_options_access_handle(v5, v27);

LABEL_5:
}

uint64_t __nw_ws_options_set_client_request_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((a2 + 48), *(a1 + 32));
  v4 = _Block_copy(*(a1 + 40));
  v5 = *(a2 + 40);
  *(a2 + 40) = v4;

  return 1;
}

void nw_ws_options_set_permessage_deflate(void *a1, char a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_ws_options_set_permessage_deflate";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_ws_options_set_permessage_deflate";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

uint64_t nw_ws_options_get_permessage_deflate(void *a1)
{
  v17 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (nw_protocol_options_is_ws(v1))
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_get_permessage_deflate_block_invoke;
    v12[3] = &unk_1E6A3A858;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(*&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_ws_options_get_permessage_deflate";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_options_get_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          *&buf[4] = "nw_ws_options_get_permessage_deflate";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_options_get_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_options_get_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
LABEL_3:

  return v2 & 1;
}

void sub_182853810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void nw_ws_options_set_permessage_deflate_server_context_takeover(void *a1, char a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_server_context_takeover_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_ws_options_set_permessage_deflate_server_max_window_bits(void *a1, char a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_server_max_window_bits_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_ws_options_set_permessage_deflate_client_context_takeover(void *a1, char a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_client_context_takeover_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_ws_options_set_permessage_deflate_client_max_window_bits(void *a1, char a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_client_max_window_bits_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_ws_options_set_permessage_deflate_incoming_buffer_size(void *a1, int a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_incoming_buffer_size_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_ws_options_set_permessage_deflate_outgoing_buffer_size(void *a1, int a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_outgoing_buffer_size_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

nw_protocol_metadata_t nw_ws_create_metadata(nw_ws_opcode_t opcode)
{
  v20 = *MEMORY[0x1E69E9840];
  if (nw_protocol_copy_ws_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_ws_definition::onceToken, &__block_literal_global_4247);
  }

  v2 = nw_protocol_copy_ws_definition::definition;
  singleton = _nw_protocol_metadata_create_singleton();

  if (singleton)
  {
    nw_framer_message_set_value(singleton, "opcode", opcode, 0);
    nw_framer_message_set_value(singleton, "close", 0x3ED, 0);
    nw_framer_message_set_value(singleton, "permessage_deflate", 1, 0);
    v4 = singleton;
    goto LABEL_5;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_ws_create_metadata";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_create_metadata";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v17 = "nw_ws_create_metadata";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v12)
      {
        *buf = 136446210;
        v17 = "nw_ws_create_metadata";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_ws_create_metadata";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v7)
  {
    free(v7);
  }

LABEL_5:

  return singleton;
}

nw_ws_opcode_t nw_ws_metadata_get_opcode(nw_protocol_metadata_t metadata)
{
  v17 = *MEMORY[0x1E69E9840];
  v1 = metadata;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v16 = -1;
    access_value[0] = MEMORY[0x1E69E9820];
    access_value[1] = 3221225472;
    access_value[2] = __nw_ws_metadata_get_opcode_block_invoke;
    access_value[3] = &unk_1E6A357E8;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "opcode", access_value);
    v2 = *(*&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_ws_metadata_get_opcode";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_get_opcode";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          *&buf[4] = "nw_ws_metadata_get_opcode";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_get_opcode";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_get_opcode";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = nw_ws_opcode_invalid;
LABEL_3:

  return v2;
}

void sub_182855130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void nw_ws_metadata_set_close_code(nw_protocol_metadata_t metadata, nw_ws_close_code_t close_code)
{
  v18 = *MEMORY[0x1E69E9840];
  v3 = metadata;
  if (nw_protocol_metadata_is_ws(v3))
  {
    nw_framer_message_set_value(v3, "close", close_code, 0);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_ws_metadata_set_close_code";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_ws_metadata_set_close_code";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_ws_metadata_set_close_code";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_ws_metadata_set_close_code";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_ws_metadata_set_close_code";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

nw_ws_close_code_t nw_ws_metadata_get_close_code(nw_protocol_metadata_t metadata)
{
  v17 = *MEMORY[0x1E69E9840];
  v1 = metadata;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v16 = 1005;
    access_value[0] = MEMORY[0x1E69E9820];
    access_value[1] = 3221225472;
    access_value[2] = __nw_ws_metadata_get_close_code_block_invoke;
    access_value[3] = &unk_1E6A357E8;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "close", access_value);
    v2 = *(*&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_ws_metadata_get_close_code";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_get_close_code";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          *&buf[4] = "nw_ws_metadata_get_close_code";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_get_close_code";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_get_close_code";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = nw_ws_close_code_no_status_received;
LABEL_3:

  return v2;
}

void sub_182855754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void nw_ws_metadata_set_pong_handler(nw_protocol_metadata_t metadata, dispatch_queue_t client_queue, nw_ws_pong_handler_t pong_handler)
{
  v39 = *MEMORY[0x1E69E9840];
  v5 = metadata;
  v6 = client_queue;
  v7 = pong_handler;
  if (!nw_protocol_metadata_is_ws(v5))
  {
    v12 = __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_ws_metadata_set_pong_handler";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v13, &type, &v33))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }

    else if (v33 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v21 = type;
      v22 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *buf = 136446466;
          v36 = "nw_ws_metadata_set_pong_handler";
          v37 = 2082;
          v38 = backtrace_string;
          _os_log_impl(&dword_181A37000, v14, v21, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v13)
        {
          goto LABEL_5;
        }

LABEL_56:
        free(v13);
        goto LABEL_5;
      }

      if (v22)
      {
        *buf = 136446210;
        v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_181A37000, v14, v21, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v14 = __nwlog_obj();
      v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_181A37000, v14, v28, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_54:

    goto LABEL_55;
  }

  if (!v6)
  {
    v16 = __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_ws_metadata_set_pong_handler";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v13, &type, &v33))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_181A37000, v14, v17, "%{public}s called with null client_queue", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v33 != 1)
    {
      v14 = __nwlog_obj();
      v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_181A37000, v14, v29, "%{public}s called with null client_queue, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    v23 = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v24 = type;
    v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *buf = 136446210;
        v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_181A37000, v14, v24, "%{public}s called with null client_queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v25)
    {
      *buf = 136446466;
      v36 = "nw_ws_metadata_set_pong_handler";
      v37 = 2082;
      v38 = v23;
      _os_log_impl(&dword_181A37000, v14, v24, "%{public}s called with null client_queue, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_35;
  }

  if (!v7)
  {
    v18 = __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_ws_metadata_set_pong_handler";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v13, &type, &v33))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_181A37000, v14, v19, "%{public}s called with null pong_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v33 != 1)
    {
      v14 = __nwlog_obj();
      v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_181A37000, v14, v30, "%{public}s called with null pong_handler, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    v23 = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v26 = type;
    v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *buf = 136446210;
        v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_181A37000, v14, v26, "%{public}s called with null pong_handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v27)
    {
      *buf = 136446466;
      v36 = "nw_ws_metadata_set_pong_handler";
      v37 = 2082;
      v38 = v23;
      _os_log_impl(&dword_181A37000, v14, v26, "%{public}s called with null pong_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_35:

    free(v23);
    if (!v13)
    {
      goto LABEL_5;
    }

    goto LABEL_56;
  }

  v8 = v6;
  nw_framer_message_set_value(v5, "client_queue", v8, &__block_literal_global_53871);
  v9 = nw_dictionary_create();
  v10 = _Block_copy(v7);
  nw_dictionary_set_value(v9, "handler", v10);

  v11 = v9;
  dispose_value[0] = MEMORY[0x1E69E9820];
  dispose_value[1] = 3221225472;
  dispose_value[2] = __nw_ws_metadata_set_pong_handler_block_invoke_2;
  dispose_value[3] = &unk_1E6A35810;
  v32 = v8;
  nw_framer_message_set_value(v5, "pong_handler", v11, dispose_value);

LABEL_5:
}

void __nw_ws_metadata_set_pong_handler_block_invoke_2(uint64_t a1, void *a2)
{
  if (a2)
  {
    v4 = nw_dictionary_copy_value(a2, "handler");
    v5 = v4;
    if (v4)
    {
      v6 = *(a1 + 32);
      if (v6)
      {
        block[0] = MEMORY[0x1E69E9820];
        block[1] = 3221225472;
        block[2] = __nw_ws_metadata_set_pong_handler_block_invoke_3;
        block[3] = &unk_1E6A3CE48;
        v8 = v4;
        dispatch_async(v6, block);
      }
    }
  }
}

void __nw_ws_metadata_set_pong_handler_block_invoke_3(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [[NWConcrete_nw_error alloc] initWithDomain:89 code:?];
  (*(v1 + 16))(v1);
}

void *__Block_byref_object_copy__53883(uint64_t a1, uint64_t a2)
{
  result = _Block_copy(*(a2 + 40));
  *(a1 + 40) = result;
  return result;
}

uint64_t __nw_ws_metadata_copy_pong_handler_block_invoke(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = v3;
  if (v3)
  {
    v5 = nw_dictionary_copy_value(v3, "handler");
    v6 = *(*(a1 + 32) + 8);
    v7 = *(v6 + 40);
    *(v6 + 40) = v5;

    nw_dictionary_set_value(v4, "handler", 0);
  }

  return 1;
}

uint64_t __Block_byref_object_copy__23_53892(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

nw_ws_response_t nw_ws_metadata_copy_server_response(nw_protocol_metadata_t metadata)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = metadata;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x3032000000;
    v16 = __Block_byref_object_copy__23_53892;
    v17 = __Block_byref_object_dispose__24_53893;
    v18 = 0;
    access_value[0] = MEMORY[0x1E69E9820];
    access_value[1] = 3221225472;
    access_value[2] = __nw_ws_metadata_copy_server_response_block_invoke;
    access_value[3] = &unk_1E6A357E8;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "server_response", access_value);
    v2 = *(*&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_ws_metadata_copy_server_response";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_copy_server_response";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          *&buf[4] = "nw_ws_metadata_copy_server_response";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_copy_server_response";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_copy_server_response";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1828564F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, id a24)
{
  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_ws_metadata_get_negotiated_permessage_deflate(void *a1)
{
  v17 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v16 = 0;
    access_value[0] = MEMORY[0x1E69E9820];
    access_value[1] = 3221225472;
    access_value[2] = __nw_ws_metadata_get_negotiated_permessage_deflate_block_invoke;
    access_value[3] = &unk_1E6A357E8;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "negotiated_permessage_deflate", access_value);
    v2 = *(*&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          *&buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
LABEL_3:

  return v2 & 1;
}

void sub_182856870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void nw_ws_metadata_set_negotiated_permessage_deflate(void *a1, unsigned int a2)
{
  v18 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (nw_protocol_metadata_is_ws(v3))
  {
    nw_framer_message_set_value(v3, "negotiated_permessage_deflate", a2, 0);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

uint64_t nw_ws_metadata_get_permessage_deflate(void *a1)
{
  v17 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v16 = 1;
    access_value[0] = MEMORY[0x1E69E9820];
    access_value[1] = 3221225472;
    access_value[2] = __nw_ws_metadata_get_permessage_deflate_block_invoke;
    access_value[3] = &unk_1E6A357E8;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "permessage_deflate", access_value);
    v2 = *(*&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_ws_metadata_get_permessage_deflate";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_get_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          *&buf[4] = "nw_ws_metadata_get_permessage_deflate";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_get_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_ws_metadata_get_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
LABEL_3:

  return v2 & 1;
}

void sub_182856E9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void nw_ws_metadata_set_permessage_deflate(void *a1, unsigned int a2)
{
  v18 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (nw_protocol_metadata_is_ws(v3))
  {
    nw_framer_message_set_value(v3, "permessage_deflate", a2, 0);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_ws_metadata_set_permessage_deflate";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_ws_metadata_set_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_ws_metadata_set_permessage_deflate";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_ws_metadata_set_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_ws_metadata_set_permessage_deflate";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

uint64_t nw_array_prepend(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      return _nw_array_prepend(a1, a2);
    }
  }

  return a1;
}

void nw_array_insert_object_at_index(void *a1, void *a2, uint64_t a3)
{
  v24 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a2;
  v7 = v6;
  if (!v5)
  {
    v8 = __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_array_insert_object_at_index";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v9, &type, &v18))
    {
      goto LABEL_34;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v21 = "nw_array_insert_object_at_index";
        v12 = "%{public}s called with null array";
LABEL_32:
        _os_log_impl(&dword_181A37000, v10, v11, v12, buf, 0xCu);
      }
    }

    else if (v18 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v11 = type;
      v15 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v21 = "nw_array_insert_object_at_index";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v9)
        {
          goto LABEL_4;
        }

LABEL_35:
        free(v9);
        goto LABEL_4;
      }

      if (v15)
      {
        *buf = 136446210;
        v21 = "nw_array_insert_object_at_index";
        v12 = "%{public}s called with null array, no backtrace";
        goto LABEL_32;
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v21 = "nw_array_insert_object_at_index";
        v12 = "%{public}s called with null array, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

LABEL_33:

    goto LABEL_34;
  }

  if (v6)
  {
    _nw_array_insert_object_at_index(v5, v6, a3);
    goto LABEL_4;
  }

  v13 = __nwlog_obj();
  *buf = 136446210;
  v21 = "nw_array_insert_object_at_index";
  v9 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v9, &type, &v18))
  {
    goto LABEL_34;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v10 = __nwlog_obj();
    v11 = type;
    if (os_log_type_enabled(v10, type))
    {
      *buf = 136446210;
      v21 = "nw_array_insert_object_at_index";
      v12 = "%{public}s called with null object";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v18 != 1)
  {
    v10 = __nwlog_obj();
    v11 = type;
    if (os_log_type_enabled(v10, type))
    {
      *buf = 136446210;
      v21 = "nw_array_insert_object_at_index";
      v12 = "%{public}s called with null object, backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  v16 = __nw_create_backtrace_string();
  v10 = __nwlog_obj();
  v11 = type;
  v17 = os_log_type_enabled(v10, type);
  if (!v16)
  {
    if (v17)
    {
      *buf = 136446210;
      v21 = "nw_array_insert_object_at_index";
      v12 = "%{public}s called with null object, no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v17)
  {
    *buf = 136446466;
    v21 = "nw_array_insert_object_at_index";
    v22 = 2082;
    v23 = v16;
    _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null object, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v9)
  {
    goto LABEL_35;
  }

LABEL_4:
}

void nw_array_set_object_at_index(void *a1, void *a2, uint64_t a3)
{
  v24 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a2;
  v7 = v6;
  if (!v5)
  {
    v8 = __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_array_set_object_at_index";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v9, &type, &v18))
    {
      goto LABEL_34;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v21 = "nw_array_set_object_at_index";
        v12 = "%{public}s called with null array";
LABEL_32:
        _os_log_impl(&dword_181A37000, v10, v11, v12, buf, 0xCu);
      }
    }

    else if (v18 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v11 = type;
      v15 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v21 = "nw_array_set_object_at_index";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v9)
        {
          goto LABEL_4;
        }

LABEL_35:
        free(v9);
        goto LABEL_4;
      }

      if (v15)
      {
        *buf = 136446210;
        v21 = "nw_array_set_object_at_index";
        v12 = "%{public}s called with null array, no backtrace";
        goto LABEL_32;
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v21 = "nw_array_set_object_at_index";
        v12 = "%{public}s called with null array, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

LABEL_33:

    goto LABEL_34;
  }

  if (v6)
  {
    _nw_array_set_object_at_index(v5, v6, a3);
    goto LABEL_4;
  }

  v13 = __nwlog_obj();
  *buf = 136446210;
  v21 = "nw_array_set_object_at_index";
  v9 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v9, &type, &v18))
  {
    goto LABEL_34;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v10 = __nwlog_obj();
    v11 = type;
    if (os_log_type_enabled(v10, type))
    {
      *buf = 136446210;
      v21 = "nw_array_set_object_at_index";
      v12 = "%{public}s called with null object";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v18 != 1)
  {
    v10 = __nwlog_obj();
    v11 = type;
    if (os_log_type_enabled(v10, type))
    {
      *buf = 136446210;
      v21 = "nw_array_set_object_at_index";
      v12 = "%{public}s called with null object, backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  v16 = __nw_create_backtrace_string();
  v10 = __nwlog_obj();
  v11 = type;
  v17 = os_log_type_enabled(v10, type);
  if (!v16)
  {
    if (v17)
    {
      *buf = 136446210;
      v21 = "nw_array_set_object_at_index";
      v12 = "%{public}s called with null object, no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v17)
  {
    *buf = 136446466;
    v21 = "nw_array_set_object_at_index";
    v22 = 2082;
    v23 = v16;
    _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null object, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v9)
  {
    goto LABEL_35;
  }

LABEL_4:
}

uint64_t nw_array_contains_object(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    return _nw_array_contains_object(a1, a2);
  }

  else
  {
    return 0;
  }
}

void nw_array_assign(void *a1, void *a2)
{
  v22 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    v6 = __nwlog_obj();
    *buf = 136446210;
    v19 = "nw_array_assign";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v7, &type, &v16))
    {
      goto LABEL_34;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v19 = "nw_array_assign";
        v10 = "%{public}s called with null to";
LABEL_32:
        _os_log_impl(&dword_181A37000, v8, v9, v10, buf, 0xCu);
      }
    }

    else if (v16 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v13 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v19 = "nw_array_assign";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null to, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v7)
        {
          goto LABEL_4;
        }

LABEL_35:
        free(v7);
        goto LABEL_4;
      }

      if (v13)
      {
        *buf = 136446210;
        v19 = "nw_array_assign";
        v10 = "%{public}s called with null to, no backtrace";
        goto LABEL_32;
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v19 = "nw_array_assign";
        v10 = "%{public}s called with null to, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

LABEL_33:

    goto LABEL_34;
  }

  if (v4)
  {
    _nw_array_assign(v3, v4);
    goto LABEL_4;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v19 = "nw_array_assign";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v7, &type, &v16))
  {
    goto LABEL_34;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (os_log_type_enabled(v8, type))
    {
      *buf = 136446210;
      v19 = "nw_array_assign";
      v10 = "%{public}s called with null from";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v16 != 1)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (os_log_type_enabled(v8, type))
    {
      *buf = 136446210;
      v19 = "nw_array_assign";
      v10 = "%{public}s called with null from, backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  v14 = __nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v9 = type;
  v15 = os_log_type_enabled(v8, type);
  if (!v14)
  {
    if (v15)
    {
      *buf = 136446210;
      v19 = "nw_array_assign";
      v10 = "%{public}s called with null from, no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v15)
  {
    *buf = 136446466;
    v19 = "nw_array_assign";
    v20 = 2082;
    v21 = v14;
    _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null from, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v7)
  {
    goto LABEL_35;
  }

LABEL_4:
}

uint64_t nw_array_is_equal(void *a1, void *a2)
{
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3)
  {
    v6 = v4 == 0;
  }

  else
  {
    v6 = 1;
  }

  v7 = v6;
  if (v3 == v4)
  {
    is_equal = 1;
  }

  else
  {
    is_equal = v7 ^ 1u;
  }

  if ((v7 & 1) == 0 && v3 != v4)
  {
    is_equal = _nw_array_is_equal(v3, v4);
  }

  return is_equal;
}

char *nw_array_copy(void *a1)
{
  if (a1)
  {
    return _nw_array_copy(a1);
  }

  else
  {
    return _nw_array_create();
  }
}

id nw_array_create_combined_array(void *a1, void *a2)
{
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3 && v4)
  {
    combined_array = _nw_array_create_combined_array(v3, v4);
  }

  else if (v3)
  {
    combined_array = v3;
  }

  else if (v4)
  {
    combined_array = v4;
  }

  else
  {
    combined_array = _nw_array_create();
  }

  v7 = combined_array;

  return v7;
}

uint64_t nw_array_compare(void *a1, void *a2, void *a3)
{
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (v5)
  {
    count = _nw_array_get_count(v5);
    if (v6)
    {
      goto LABEL_3;
    }
  }

  else
  {
    count = 0;
    if (v6)
    {
LABEL_3:
      if (count == _nw_array_get_count(v6))
      {
        goto LABEL_4;
      }

LABEL_16:
      v13 = 0;
      goto LABEL_39;
    }
  }

  if (count)
  {
    goto LABEL_16;
  }

LABEL_4:
  if (count)
  {
    if (v5)
    {
      v9 = 0;
      if (v6)
      {
        v10 = count - 1;
        do
        {
          v11 = _nw_array_get_object_at_index(v5, v9);
          v12 = _nw_array_get_object_at_index(v6, v9);
          v13 = v7[2](v7, v11, v12);

          if (v13)
          {
            v14 = v10 == v9;
          }

          else
          {
            v14 = 1;
          }

          ++v9;
        }

        while (!v14);
      }

      else
      {
        v19 = count - 1;
        do
        {
          v20 = _nw_array_get_object_at_index(v5, v9);
          v13 = v7[2](v7, v20, 0);

          if (v13)
          {
            v21 = v19 == v9;
          }

          else
          {
            v21 = 1;
          }

          ++v9;
        }

        while (!v21);
      }
    }

    else if (v6)
    {
      v15 = 0;
      v16 = count - 1;
      do
      {
        v17 = _nw_array_get_object_at_index(v6, v15);
        v13 = v7[2](v7, 0, v17);

        if (v13)
        {
          v18 = v16 == v15;
        }

        else
        {
          v18 = 1;
        }

        ++v15;
      }

      while (!v18);
    }

    else
    {
      v22 = count - 1;
      do
      {
        v23 = v7[2](v7, 0, 0);
        v13 = v23;
        v25 = v22-- != 0;
      }

      while (v23 && v25);
    }
  }

  else
  {
    v13 = 1;
  }

LABEL_39:

  return v13;
}

void nw_array_review_change(void *a1, void *a2, void *a3, void *a4)
{
  v43 = a1;
  v7 = a2;
  v8 = a3;
  v42 = a4;
  if (v43)
  {
    count = _nw_array_get_count(v43);
  }

  else
  {
    count = 0;
  }

  v9 = _nw_array_create();
  v39 = v7;
  if (v7)
  {
    v10 = _nw_array_copy(v7);
  }

  else
  {
    v10 = _nw_array_create();
  }

  v11 = v10;
  v40 = v9;
  if (count)
  {
    if (v43)
    {
      for (i = 0; i != count; ++i)
      {
        if (v11)
        {
          v13 = _nw_array_get_count(v11);
        }

        else
        {
          v13 = 0;
        }

        v14 = _nw_array_get_object_at_index(v43, i);
        if (v13)
        {
          v15 = 0;
          if (v11)
          {
            while (1)
            {
              v16 = _nw_array_get_object_at_index(v43, i);
              v17 = _nw_array_get_object_at_index(v11, v15);
              v18 = v8[2](v8, v16, v17);

              if (v18)
              {
                break;
              }

              if (v13 == ++v15)
              {
                goto LABEL_22;
              }
            }
          }

          else
          {
            while (1)
            {
              v19 = _nw_array_get_object_at_index(v43, i);
              v20 = v8[2](v8, v19, 0);

              if (v20)
              {
                break;
              }

              if (v13 == ++v15)
              {
                goto LABEL_22;
              }
            }
          }

          v9 = v40;
        }

        else
        {
LABEL_22:
          v9 = v40;
          if (v40 && v14)
          {
            _nw_array_append(v40, v14);
          }
        }
      }
    }

    else if (v10)
    {
      for (j = 0; j != count; ++j)
      {
        v28 = _nw_array_get_count(v11);
        if (v28)
        {
          v29 = v28;
          v30 = 0;
          while (1)
          {
            v31 = _nw_array_get_object_at_index(v11, v30);
            v32 = v8[2](v8, 0, v31);

            if (v32)
            {
              break;
            }

            if (v29 == ++v30)
            {
              goto LABEL_36;
            }
          }
        }

LABEL_36:
        ;
      }
    }

    else
    {
      do
      {
        --count;
      }

      while (count);
    }
  }

  if (v11)
  {
    v22 = _nw_array_get_count(v11);
    if (v9)
    {
      goto LABEL_30;
    }

LABEL_43:
    v23 = 0;
    v24 = v22;
LABEL_44:
    if (v22)
    {
      v33 = 0;
      v34 = v22 - 1;
      v35 = ~v23 + v24;
      do
      {
        if (v11)
        {
          v36 = _nw_array_get_object_at_index(v11, v33);
        }

        else
        {
          v36 = 0;
        }

        v37 = v42[2](v42, v36, 1, v35 == v33);

        if (v37)
        {
          v38 = v34 == v33;
        }

        else
        {
          v38 = 1;
        }

        ++v33;
      }

      while (!v38);
    }

    goto LABEL_53;
  }

  v22 = 0;
  if (!v9)
  {
    goto LABEL_43;
  }

LABEL_30:
  v23 = _nw_array_get_count(v9);
  v24 = v23 + v22;
  if (!v23)
  {
    goto LABEL_44;
  }

  v25 = 0;
  while (1)
  {
    v26 = _nw_array_get_object_at_index(v9, v25);
    v27 = v42[2](v42, v26, 2, v24 - 1 == v25);

    if ((v27 & 1) == 0)
    {
      break;
    }

    ++v25;
    v9 = v40;
    if (v23 == v25)
    {
      goto LABEL_44;
    }
  }

LABEL_53:
}

uint64_t in_adjust_cksum(uint64_t a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  v6 = a4 - a3;
  if ((a4 - a3) >= 1)
  {
    v7 = (a1 + a3);
    if (v7)
    {
      v9 = (v7 + 1);
      v8 = *v7 << 8;
      --v6;
      if (((v7 + 1) & 2) == 0)
      {
LABEL_4:
        if (v6 >= 0x40)
        {
          goto LABEL_5;
        }

        goto LABEL_34;
      }
    }

    else
    {
      v8 = 0;
      v9 = (a1 + a3);
      if ((v7 & 2) == 0)
      {
        goto LABEL_4;
      }
    }

    v27 = v6 - 2;
    if (v6 < 2)
    {
      v10 = 0;
      if ((v6 & 1) == 0)
      {
        goto LABEL_18;
      }

      goto LABEL_17;
    }

    v28 = v9->u16[0];
    v9 = (v9 + 2);
    v8 += v28;
    v6 -= 2;
    if (v27 >= 0x40)
    {
LABEL_5:
      v10 = 0;
      _X13 = v9;
      do
      {
        __asm { PRFM            #0, [X13,#0x20] }

        v9 = _X13 + 8;
        __asm { PRFM            #0, [X13,#0x40] }

        v8 += vaddvq_s64(vaddq_s64(vaddq_s64(vaddl_u32(*_X13, _X13[4]), vaddl_u32(_X13[2], _X13[6])), vaddq_s64(vaddl_high_u32(*_X13->i8, *_X13[4].i8), vaddl_high_u32(*_X13[2].i8, *_X13[6].i8))));
        v6 -= 64;
        v17 = __ROR8__(v8, 56);
        if ((v7 & 1) == 0)
        {
          v17 = v8;
        }

        v18 = v10 + HIDWORD(v17) + v17;
        if (v8 >> 62)
        {
          v8 = 0;
          v10 = v18;
        }

        _X13 += 8;
      }

      while (v6 > 0x3F);
      if (v6 < 0x20)
      {
LABEL_12:
        if ((v6 & 0x10) == 0)
        {
          goto LABEL_13;
        }

        goto LABEL_36;
      }

LABEL_35:
      v29 = *v9->i8;
      v30 = *v9[2].i8;
      v9 += 4;
      v8 += vaddvq_s64(vaddq_s64(vaddl_u32(*v29.i8, *v30.i8), vaddl_high_u32(v29, v30)));
      if ((v6 & 0x10) == 0)
      {
LABEL_13:
        if ((v6 & 8) == 0)
        {
          goto LABEL_14;
        }

        goto LABEL_37;
      }

LABEL_36:
      v31 = *v9->i8;
      v9 += 2;
      v8 += vaddlvq_u32(v31);
      if ((v6 & 8) == 0)
      {
LABEL_14:
        if ((v6 & 4) == 0)
        {
          goto LABEL_15;
        }

        goto LABEL_38;
      }

LABEL_37:
      v32 = v9->u32[0];
      v33 = v9->u32[1];
      ++v9;
      v8 += v32 + v33;
      if ((v6 & 4) == 0)
      {
LABEL_15:
        if ((v6 & 2) == 0)
        {
          goto LABEL_16;
        }

        goto LABEL_39;
      }

LABEL_38:
      v34 = v9->i32[0];
      v9 = (v9 + 4);
      v8 += v34;
      if ((v6 & 2) == 0)
      {
LABEL_16:
        if ((v6 & 1) == 0)
        {
LABEL_18:
          v19 = __ROR8__(v8, 56);
          if (v7)
          {
            v20 = v19;
          }

          else
          {
            v20 = v8;
          }

          v21 = ((v10 + v20 + HIDWORD(v20)) >> 32) + (v10 + v20 + HIDWORD(v20));
          v22 = (((HIDWORD(v21) + v21 + WORD1(v21)) >> 16) + WORD2(v21) + v21 + WORD1(v21) + ((((HIDWORD(v21) + v21 + WORD1(v21)) >> 16) + (WORD2(v21) + v21 + WORD1(v21))) >> 16));
          goto LABEL_22;
        }

LABEL_17:
        v8 += v9->u8[0];
        goto LABEL_18;
      }

LABEL_39:
      v35 = v9->u16[0];
      v9 = (v9 + 2);
      v8 += v35;
      if ((v6 & 1) == 0)
      {
        goto LABEL_18;
      }

      goto LABEL_17;
    }

LABEL_34:
    v10 = 0;
    if (v6 < 0x20)
    {
      goto LABEL_12;
    }

    goto LABEL_35;
  }

  if ((v6 & 0x80000000) == 0)
  {
    v22 = 0;
    goto LABEL_22;
  }

  v40 = (a1 + a4);
  if (v40)
  {
    v43 = (v40 + 1);
    v41 = *v40 << 8;
    v42 = ~v6;
  }

  else
  {
    v41 = 0;
    v42 = a3 - a4;
    v43 = (a1 + a4);
  }

  if ((v43 & 2) != 0)
  {
    if (v42 < 2)
    {
      v63 = 0;
      if ((v42 & 1) == 0)
      {
        goto LABEL_105;
      }

      goto LABEL_104;
    }

    v64 = v43->u16[0];
    v43 = (v43 + 2);
    v41 += v64;
    v42 -= 2;
  }

  if (v42 < 0x40)
  {
    v63 = 0;
  }

  else
  {
    v63 = 0;
    _X13 = v43;
    if (v40)
    {
      do
      {
        __asm { PRFM            #0, [X13,#0x20] }

        v43 = _X13 + 8;
        __asm { PRFM            #0, [X13,#0x40] }

        v41 += vaddvq_s64(vaddq_s64(vaddq_s64(vaddl_u32(*_X13, _X13[4]), vaddl_u32(_X13[2], _X13[6])), vaddq_s64(vaddl_high_u32(*_X13->i8, *_X13[4].i8), vaddl_high_u32(*_X13[2].i8, *_X13[6].i8))));
        v42 -= 64;
        v71 = __ROR8__(v41, 56);
        v72 = v63 + HIDWORD(v71) + v71;
        if (v41 >> 62)
        {
          v41 = 0;
          v63 = v72;
        }

        _X13 += 8;
      }

      while (v42 > 0x3F);
    }

    else
    {
      do
      {
        __asm { PRFM            #0, [X13,#0x20] }

        v43 = _X13 + 8;
        __asm { PRFM            #0, [X13,#0x40] }

        v41 += vaddvq_s64(vaddq_s64(vaddq_s64(vaddl_u32(*_X13, _X13[4]), vaddl_u32(_X13[2], _X13[6])), vaddq_s64(vaddl_high_u32(*_X13->i8, *_X13[4].i8), vaddl_high_u32(*_X13[2].i8, *_X13[6].i8))));
        v42 -= 64;
        v68 = v63 + HIDWORD(v41) + v41;
        if (v41 >> 62)
        {
          v41 = 0;
          v63 = v68;
        }

        _X13 += 8;
      }

      while (v42 > 0x3F);
    }
  }

  if (v42 >= 0x20)
  {
    v75 = *v43->i8;
    v76 = *v43[2].i8;
    v43 += 4;
    v41 += vaddvq_s64(vaddq_s64(vaddl_u32(*v75.i8, *v76.i8), vaddl_high_u32(v75, v76)));
    if ((v42 & 0x10) == 0)
    {
LABEL_100:
      if ((v42 & 8) == 0)
      {
        goto LABEL_101;
      }

      goto LABEL_110;
    }
  }

  else if ((v42 & 0x10) == 0)
  {
    goto LABEL_100;
  }

  v77 = *v43->i8;
  v43 += 2;
  v41 += vaddlvq_u32(v77);
  if ((v42 & 8) == 0)
  {
LABEL_101:
    if ((v42 & 4) == 0)
    {
      goto LABEL_102;
    }

    goto LABEL_111;
  }

LABEL_110:
  v78 = v43->u32[0];
  v79 = v43->u32[1];
  ++v43;
  v41 += v78 + v79;
  if ((v42 & 4) == 0)
  {
LABEL_102:
    if ((v42 & 2) == 0)
    {
      goto LABEL_103;
    }

LABEL_112:
    v81 = v43->u16[0];
    v43 = (v43 + 2);
    v41 += v81;
    if ((v42 & 1) == 0)
    {
      goto LABEL_105;
    }

    goto LABEL_104;
  }

LABEL_111:
  v80 = v43->i32[0];
  v43 = (v43 + 4);
  v41 += v80;
  if ((v42 & 2) != 0)
  {
    goto LABEL_112;
  }

LABEL_103:
  if (v42)
  {
LABEL_104:
    v41 += v43->u8[0];
  }

LABEL_105:
  v22 = 0;
  _ZF = (v40 & 1) == 0;
  v73 = __ROR8__(v41, 56);
  if (_ZF)
  {
    v73 = v41;
  }

  v74 = ((v63 + v73 + HIDWORD(v73)) >> 32) + (v63 + v73 + HIDWORD(v73));
  a6 += (((HIDWORD(v74) + v74 + WORD1(v74)) >> 16) + WORD2(v74) + v74 + WORD1(v74) + ((((HIDWORD(v74) + v74 + WORD1(v74)) >> 16) + (WORD2(v74) + v74 + WORD1(v74))) >> 16));
LABEL_22:
  v23 = a2 - (a4 + a5);
  if (v23 < 1)
  {
    goto LABEL_23;
  }

  v36 = (a1 + a4 + a5);
  if (v36)
  {
    v38 = (v36 + 1);
    v37 = *v36 << 8;
    --v23;
  }

  else
  {
    v37 = 0;
    v38 = (a1 + a4 + a5);
  }

  if ((v38 & 2) != 0)
  {
    if (v23 < 2)
    {
      v39 = 0;
      if ((v23 & 1) == 0)
      {
        goto LABEL_69;
      }

      goto LABEL_68;
    }

    v44 = v38->u16[0];
    v38 = (v38 + 2);
    v37 += v44;
    v23 -= 2;
  }

  if (v23 < 0x40)
  {
    v39 = 0;
  }

  else
  {
    v39 = 0;
    _X14 = v38;
    do
    {
      __asm { PRFM            #0, [X14,#0x20] }

      v38 = _X14 + 8;
      __asm { PRFM            #0, [X14,#0x40] }

      v37 += vaddvq_s64(vaddq_s64(vaddq_s64(vaddl_u32(*_X14, _X14[4]), vaddl_u32(_X14[2], _X14[6])), vaddq_s64(vaddl_high_u32(*_X14->i8, *_X14[4].i8), vaddl_high_u32(*_X14[2].i8, *_X14[6].i8))));
      v23 -= 64;
      v48 = __ROR8__(v37, 56);
      if ((v36 & 1) == 0)
      {
        v48 = v37;
      }

      v49 = v39 + HIDWORD(v48) + v48;
      if (v37 >> 62)
      {
        v37 = 0;
        v39 = v49;
      }

      _X14 += 8;
    }

    while (v23 > 0x3F);
  }

  if (v23 >= 0x20)
  {
    v56 = *v38->i8;
    v57 = *v38[2].i8;
    v38 += 4;
    v37 += vaddvq_s64(vaddq_s64(vaddl_u32(*v56.i8, *v57.i8), vaddl_high_u32(v56, v57)));
    if ((v23 & 0x10) == 0)
    {
LABEL_64:
      if ((v23 & 8) == 0)
      {
        goto LABEL_65;
      }

      goto LABEL_77;
    }
  }

  else if ((v23 & 0x10) == 0)
  {
    goto LABEL_64;
  }

  v58 = *v38->i8;
  v38 += 2;
  v37 += vaddlvq_u32(v58);
  if ((v23 & 8) == 0)
  {
LABEL_65:
    if ((v23 & 4) == 0)
    {
      goto LABEL_66;
    }

    goto LABEL_78;
  }

LABEL_77:
  v59 = v38->u32[0];
  v60 = v38->u32[1];
  ++v38;
  v37 += v59 + v60;
  if ((v23 & 4) == 0)
  {
LABEL_66:
    if ((v23 & 2) == 0)
    {
      goto LABEL_67;
    }

LABEL_79:
    v62 = v38->u16[0];
    v38 = (v38 + 2);
    v37 += v62;
    if ((v23 & 1) == 0)
    {
      goto LABEL_69;
    }

    goto LABEL_68;
  }

LABEL_78:
  v61 = v38->i32[0];
  v38 = (v38 + 4);
  v37 += v61;
  if ((v23 & 2) != 0)
  {
    goto LABEL_79;
  }

LABEL_67:
  if (v23)
  {
LABEL_68:
    v37 += v38->u8[0];
  }

LABEL_69:
  v50 = __ROR8__(v37, 56);
  _ZF = (v36 & 1) == 0;
  if (v36)
  {
    v52 = v50;
  }

  else
  {
    v52 = v37;
  }

  v53 = ((v39 + v52 + HIDWORD(v52)) >> 32) + (v39 + v52 + HIDWORD(v52));
  LODWORD(v53) = ((HIDWORD(v53) + v53 + WORD1(v53)) >> 16) + (WORD2(v53) + v53 + WORD1(v53));
  v54 = v53 + WORD1(v53);
  v55 = bswap32(v54) >> 16;
  if (!_ZF)
  {
    LOWORD(v54) = v55;
  }

  v22 = ((v22 + v54) >> 16) + (v22 + v54);
LABEL_23:
  v24 = a6 - v22;
  if (a6 <= v22)
  {
    v24 = (a6 + ~v22);
  }

  if (v22)
  {
    v25 = v24;
  }

  else
  {
    v25 = a6;
  }

  return (((-65535 * HIWORD(v25) + v25) >> 16) + HIWORD(v25) + v25 + ((-65535 * ((-65535 * HIWORD(v25) + v25) >> 16) + -65535 * HIWORD(v25) + v25) >> 16));
}

uint64_t in_pseudo(unsigned int a1, unsigned int a2, unsigned int a3)
{
  v3 = a2 + a1 + a3;
  v4 = ((WORD1(v3) + v3 + HIDWORD(v3)) >> 16) + (WORD1(v3) + v3 + WORD2(v3));
  return ((((v4 >> 16) + v4) >> 16) + WORD1(v4) + v4 + ((-65535 * (((v4 >> 16) + v4) >> 16) + (v4 >> 16) + v4) >> 16));
}

void *nw_migration_helper_create(uint64_t a1)
{
  v33 = *MEMORY[0x1E69E9840];
  v2 = [NWConcrete_nw_migration_helper alloc];
  if (!v2)
  {
    goto LABEL_22;
  }

  v28.receiver = v2;
  v28.super_class = NWConcrete_nw_migration_helper;
  v3 = objc_msgSendSuper2(&v28, sel_init);
  if (v3)
  {
    v4 = v3;
    v5 = [objc_alloc(MEMORY[0x1E696AFB0]) initWithUUIDBytes:a1];
    v6 = v4[1];
    v4[1] = v5;

    v7 = v4;
    goto LABEL_4;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v30 = "[NWConcrete_nw_migration_helper initWithAgentUUID:]";
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (__nwlog_fault(v10, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v30 = "[NWConcrete_nw_migration_helper initWithAgentUUID:]";
        v13 = "%{public}s [super init] failed";
LABEL_18:
        _os_log_impl(&dword_181A37000, v11, v12, v13, buf, 0xCu);
      }
    }

    else
    {
      if (v26 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v11 = __nwlog_obj();
        v12 = type;
        v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *buf = 136446466;
            v30 = "[NWConcrete_nw_migration_helper initWithAgentUUID:]";
            v31 = 2082;
            v32 = backtrace_string;
            _os_log_impl(&dword_181A37000, v11, v12, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v15)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v30 = "[NWConcrete_nw_migration_helper initWithAgentUUID:]";
        v13 = "%{public}s [super init] failed, no backtrace";
        goto LABEL_18;
      }

      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v30 = "[NWConcrete_nw_migration_helper initWithAgentUUID:]";
        v13 = "%{public}s [super init] failed, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v10)
  {
    free(v10);
  }

LABEL_22:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v16 = gLogObj;
  *buf = 136446210;
  v30 = "nw_migration_helper_create";
  v17 = _os_log_send_and_compose_impl();

  LOBYTE(v28.receiver) = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v17, &v28, &type))
  {
    if (LOBYTE(v28.receiver) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = gLogObj;
      receiver = v28.receiver;
      if (os_log_type_enabled(v18, v28.receiver))
      {
        *buf = 136446210;
        v30 = "nw_migration_helper_create";
        v20 = "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_migration_helper) alloc] initWithAgentUUID:] failed";
LABEL_33:
        v24 = v18;
        v25 = receiver;
LABEL_34:
        _os_log_impl(&dword_181A37000, v24, v25, v20, buf, 0xCu);
      }
    }

    else
    {
      if (type == OS_LOG_TYPE_INFO)
      {
        v21 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        v22 = v28.receiver;
        v23 = os_log_type_enabled(v18, v28.receiver);
        if (v21)
        {
          if (v23)
          {
            *buf = 136446466;
            v30 = "nw_migration_helper_create";
            v31 = 2082;
            v32 = v21;
            _os_log_impl(&dword_181A37000, v18, v22, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_migration_helper) alloc] initWithAgentUUID:] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v21);
          goto LABEL_36;
        }

        if (!v23)
        {
          goto LABEL_35;
        }

        *buf = 136446210;
        v30 = "nw_migration_helper_create";
        v20 = "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_migration_helper) alloc] initWithAgentUUID:] failed, no backtrace";
        v24 = v18;
        v25 = v22;
        goto LABEL_34;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = gLogObj;
      receiver = v28.receiver;
      if (os_log_type_enabled(v18, v28.receiver))
      {
        *buf = 136446210;
        v30 = "nw_migration_helper_create";
        v20 = "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_migration_helper) alloc] initWithAgentUUID:] failed, backtrace limit exceeded";
        goto LABEL_33;
      }
    }

LABEL_35:
  }

LABEL_36:
  if (v17)
  {
    free(v17);
  }

  v7 = 0;
LABEL_4:

  return v7;
}

uint64_t nw_migration_helper_start_session(void *a1)
{
  v35 = *MEMORY[0x1E69E9840];
  v2 = a1;
  if (!v2)
  {
    v21 = __nwlog_obj();
    *buf = 136446210;
    v32 = "nw_migration_helper_start_session";
    v22 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v22, &type, &v28))
    {
      goto LABEL_29;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v32 = "nw_migration_helper_start_session";
        v25 = "%{public}s called with null migration_helper";
LABEL_27:
        _os_log_impl(&dword_181A37000, v23, v24, v25, buf, 0xCu);
      }
    }

    else
    {
      if (v28 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v23 = __nwlog_obj();
        v24 = type;
        v27 = os_log_type_enabled(v23, type);
        if (backtrace_string)
        {
          if (v27)
          {
            *buf = 136446466;
            v32 = "nw_migration_helper_start_session";
            v33 = 2082;
            v34 = backtrace_string;
            _os_log_impl(&dword_181A37000, v23, v24, "%{public}s called with null migration_helper, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }

        if (!v27)
        {
          goto LABEL_28;
        }

        *buf = 136446210;
        v32 = "nw_migration_helper_start_session";
        v25 = "%{public}s called with null migration_helper, no backtrace";
        goto LABEL_27;
      }

      v23 = __nwlog_obj();
      v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v32 = "nw_migration_helper_start_session";
        v25 = "%{public}s called with null migration_helper, backtrace limit exceeded";
        goto LABEL_27;
      }
    }

LABEL_28:

LABEL_29:
    if (v22)
    {
      free(v22);
    }

    goto LABEL_12;
  }

  gotLoadHelper_x24__OBJC_CLASS___NEPolicySession(v3);
  if (!objc_opt_class())
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v32 = "nw_migration_helper_start_session";
      _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_ERROR, "%{public}s NetworkExtension not available", buf, 0xCu);
    }

LABEL_11:

LABEL_12:
    v5 = 0;
    goto LABEL_13;
  }

  if (!v2[2])
  {
    Helper_x8__OBJC_CLASS___NEPolicyCondition = gotLoadHelper_x8__OBJC_CLASS___NEPolicyCondition(v4);
    v6 = [*(v8 + 4048) allInterfaces];
    Helper_x8__OBJC_CLASS___NEPolicyResult = gotLoadHelper_x8__OBJC_CLASS___NEPolicyResult(v9);
    v12 = [*(v11 + 4056) netAgentUUID:{v2[1], Helper_x8__OBJC_CLASS___NEPolicyResult}];
    gotLoadHelper_x8__OBJC_CLASS___NEPolicy(v13);
    v15 = objc_alloc(*(v14 + 4040));
    v30 = v6;
    v16 = [MEMORY[0x1E695DEC8] arrayWithObjects:&v30 count:1];
    v17 = [v15 initWithOrder:1 result:v12 conditions:v16];

    v18 = objc_alloc_init(*(v1 + 4064));
    if ([v18 addPolicy:v17] && objc_msgSend(v18, "apply"))
    {
      v19 = v2[2];
      v2[2] = v18;

      v5 = 1;
      goto LABEL_13;
    }

    goto LABEL_11;
  }

  v5 = 1;
LABEL_13:

  return v5;
}

uint64_t nw_migration_helper_stop_session(void *a1)
{
  v22 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v9 = __nwlog_obj();
    *buf = 136446210;
    v19 = "nw_migration_helper_stop_session";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v10, &type, &v16))
    {
      goto LABEL_24;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_migration_helper_stop_session";
        v13 = "%{public}s called with null migration_helper";
LABEL_22:
        _os_log_impl(&dword_181A37000, v11, v12, v13, buf, 0xCu);
      }
    }

    else
    {
      if (v16 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v11 = __nwlog_obj();
        v12 = type;
        v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *buf = 136446466;
            v19 = "nw_migration_helper_stop_session";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null migration_helper, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }

        if (!v15)
        {
          goto LABEL_23;
        }

        *buf = 136446210;
        v19 = "nw_migration_helper_stop_session";
        v13 = "%{public}s called with null migration_helper, no backtrace";
        goto LABEL_22;
      }

      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_migration_helper_stop_session";
        v13 = "%{public}s called with null migration_helper, backtrace limit exceeded";
        goto LABEL_22;
      }
    }

LABEL_23:

LABEL_24:
    if (v10)
    {
      free(v10);
    }

    goto LABEL_7;
  }

  v3 = v1[2];
  if (v3)
  {
    v4 = v3;
    v5 = v2[2];
    v2[2] = 0;

    if ([v4 removeAllPolicies])
    {
      v6 = [v4 apply];

      if (v6)
      {
        goto LABEL_5;
      }
    }

    else
    {
    }

LABEL_7:
    v7 = 0;
    goto LABEL_8;
  }

LABEL_5:
  v7 = 1;
LABEL_8:

  return v7;
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke_55328()
{
  result = networkd_settings_get_BOOL(nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

NWConcrete_nw_read_request *nw_read_request_create_multiple(unint64_t a1, unint64_t a2, void *a3, void *a4)
{
  v55 = *MEMORY[0x1E69E9840];
  v8 = a3;
  v9 = a4;
  if (v9)
  {
    if (a1 <= 1)
    {
      v10 = 1;
    }

    else
    {
      v10 = a1;
    }

    if (a2 >= 0x100)
    {
      v11 = 256;
    }

    else
    {
      v11 = a2;
    }

    if (v10 > v11)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      *buf = 136446722;
      v48 = "nw_read_request_create_multiple";
      v49 = 2048;
      v50 = v10;
      v51 = 2048;
      v52 = v11;
      v13 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v45 = 0;
      if (!__nwlog_fault(v13, &type, &v45))
      {
        goto LABEL_44;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *buf = 136446722;
          v48 = "nw_read_request_create_multiple";
          v49 = 2048;
          v50 = v10;
          v51 = 2048;
          v52 = v11;
          _os_log_impl(&dword_181A37000, v14, v15, "%{public}s min_data_count (%zu) > max_data_count (%zu)", buf, 0x20u);
        }
      }

      else if (v45 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v25 = type;
        v26 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *buf = 136446978;
            v48 = "nw_read_request_create_multiple";
            v49 = 2048;
            v50 = v10;
            v51 = 2048;
            v52 = v11;
            v53 = 2082;
            v54 = backtrace_string;
            _os_log_impl(&dword_181A37000, v14, v25, "%{public}s min_data_count (%zu) > max_data_count (%zu), dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(backtrace_string);
          if (!v13)
          {
            goto LABEL_46;
          }

          goto LABEL_45;
        }

        if (v26)
        {
          *buf = 136446722;
          v48 = "nw_read_request_create_multiple";
          v49 = 2048;
          v50 = v10;
          v51 = 2048;
          v52 = v11;
          _os_log_impl(&dword_181A37000, v14, v25, "%{public}s min_data_count (%zu) > max_data_count (%zu), no backtrace", buf, 0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v31 = type;
        if (os_log_type_enabled(v14, type))
        {
          *buf = 136446722;
          v48 = "nw_read_request_create_multiple";
          v49 = 2048;
          v50 = v10;
          v51 = 2048;
          v52 = v11;
          _os_log_impl(&dword_181A37000, v14, v31, "%{public}s min_data_count (%zu) > max_data_count (%zu), backtrace limit exceeded", buf, 0x20u);
        }
      }

      goto LABEL_43;
    }

    v16 = objc_alloc_init(NWConcrete_nw_read_request);
    if (v16)
    {
      v17 = _Block_copy(v9);
      data_multiple_completion = v16->data_multiple_completion;
      v16->data_multiple_completion = v17;

      objc_storeStrong(&v16->connection, a3);
      v16->qos_class = qos_class_self();
      v16->min = v10;
      v16->max = v11;
      v19 = _nw_array_create();
      read_array = v16->read_array;
      v16->read_array = v19;

      v21 = _nw_array_create();
      context_array = v16->context_array;
      v16->context_array = v21;

      v16->variant = 3;
      if (_nw_signposts_once != -1)
      {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_55325);
      }

      if (_nw_signposts_enabled == 1 && kdebug_is_enabled())
      {
        kdebug_trace();
      }

      v23 = v16;
      goto LABEL_55;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v27 = gLogObj;
    *buf = 136446210;
    v48 = "nw_read_request_create_multiple";
    v28 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (__nwlog_fault(v28, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v29 = gLogObj;
        v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          *buf = 136446210;
          v48 = "nw_read_request_create_multiple";
          _os_log_impl(&dword_181A37000, v29, v30, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed", buf, 0xCu);
        }
      }

      else if (v45 == 1)
      {
        v32 = __nw_create_backtrace_string();
        if (v32)
        {
          v33 = v32;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v34 = gLogObj;
          v35 = type;
          if (os_log_type_enabled(v34, type))
          {
            *buf = 136446466;
            v48 = "nw_read_request_create_multiple";
            v49 = 2082;
            v50 = v33;
            _os_log_impl(&dword_181A37000, v34, v35, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v33);
          if (!v28)
          {
            goto LABEL_55;
          }

          goto LABEL_54;
        }

        v29 = __nwlog_obj();
        v37 = type;
        if (os_log_type_enabled(v29, type))
        {
          *buf = 136446210;
          v48 = "nw_read_request_create_multiple";
          _os_log_impl(&dword_181A37000, v29, v37, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v29 = gLogObj;
        v36 = type;
        if (os_log_type_enabled(v29, type))
        {
          *buf = 136446210;
          v48 = "nw_read_request_create_multiple";
          _os_log_impl(&dword_181A37000, v29, v36, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v28)
    {
LABEL_55:

      goto LABEL_56;
    }

LABEL_54:
    free(v28);
    goto LABEL_55;
  }

  v39 = __nwlog_obj();
  *buf = 136446210;
  v48 = "nw_read_request_create_multiple";
  v13 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v45 = 0;
  if (__nwlog_fault(v13, &type, &v45))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v40 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v48 = "nw_read_request_create_multiple";
        _os_log_impl(&dword_181A37000, v14, v40, "%{public}s called with null completion", buf, 0xCu);
      }

LABEL_43:

      goto LABEL_44;
    }

    if (v45 != 1)
    {
      v14 = __nwlog_obj();
      v44 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v48 = "nw_read_request_create_multiple";
        _os_log_impl(&dword_181A37000, v14, v44, "%{public}s called with null completion, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_43;
    }

    v41 = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v42 = type;
    v43 = os_log_type_enabled(v14, type);
    if (!v41)
    {
      if (v43)
      {
        *buf = 136446210;
        v48 = "nw_read_request_create_multiple";
        _os_log_impl(&dword_181A37000, v14, v42, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }

      goto LABEL_43;
    }

    if (v43)
    {
      *buf = 136446466;
      v48 = "nw_read_request_create_multiple";
      v49 = 2082;
      v50 = v41;
      _os_log_impl(&dword_181A37000, v14, v42, "%{public}s called with null completion, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v41);
  }

LABEL_44:
  if (v13)
  {
LABEL_45:
    free(v13);
  }

LABEL_46:
  v16 = 0;
LABEL_56:

  return v16;
}

uint64_t nw_read_request_get_maximum_datagram_count(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if (*(v1 + 17) == 3)
    {
      v3 = v1[10];
    }

    else
    {
      maximum_datagram_count = v1[1];
      if (maximum_datagram_count)
      {
        maximum_datagram_count = nw_read_request_get_maximum_datagram_count();
      }

      v3 = maximum_datagram_count + 1;
    }

    goto LABEL_7;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_read_request_get_maximum_datagram_count";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_read_request_get_maximum_datagram_count";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null request", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v17 = "nw_read_request_get_maximum_datagram_count";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v12)
      {
        *buf = 136446210;
        v17 = "nw_read_request_get_maximum_datagram_count";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_read_request_get_maximum_datagram_count";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_24:
  if (v7)
  {
    free(v7);
  }

  v3 = 0;
LABEL_7:

  return v3;
}

void nw_read_request_fail(void *a1, int a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    posix_error = nw_error_create_posix_error(a2);
    v5 = v3[19];
    v3[19] = posix_error;

    nw_read_request_report(v3, 0);
    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_read_request_fail";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_read_request_fail";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null request", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v17 = "nw_read_request_fail";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v17 = "nw_read_request_fail";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_read_request_fail";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

uint64_t ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_104(void *a1, uint64_t a2, void *a3)
{
  v6 = a3;
  objc_storeStrong((*(*(a1[5] + 8) + 24) + 8 * a2), a3);
  if (a1[7] == a1[8])
  {
    v7 = *(a1[4] + 168);
    if (v7)
    {
      v7 = _nw_array_get_object_at_index(v7, a2);
    }

    v8 = *(*(a1[6] + 8) + 24);
    v9 = *(v8 + 8 * a2);
    *(v8 + 8 * a2) = v7;
  }

  return 1;
}

void ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_106(void *a1)
{
  (*(a1[5] + 16))();
  v2 = *(*(a1[6] + 8) + 24);
  if (v2 || *(*(a1[7] + 8) + 24))
  {
    if (a1[8])
    {
      v3 = 0;
      do
      {
        v4 = *(*(a1[6] + 8) + 24);
        if (v4)
        {
          v5 = *(v4 + 8 * v3);
          if (v5)
          {
            *(v4 + 8 * v3) = 0;
          }
        }

        v6 = *(*(a1[7] + 8) + 24);
        if (v6)
        {
          v7 = *(v6 + 8 * v3);
          if (v7)
          {
            *(v6 + 8 * v3) = 0;
          }
        }

        ++v3;
      }

      while (v3 < a1[8]);
      v2 = *(*(a1[6] + 8) + 24);
    }

    if (v2)
    {
      free(v2);
      *(*(a1[6] + 8) + 24) = 0;
    }

    v8 = *(*(a1[7] + 8) + 24);
    if (v8)
    {
      free(v8);
      *(*(a1[7] + 8) + 24) = 0;
    }
  }
}

uint64_t __Block_byref_object_copy__55438(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

uint64_t __nw_read_request_receive_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  v9 = a2;
  if (*(a1 + 72) < a5)
  {
    a5 = *(a1 + 72);
  }

  v24 = 0;
  v25 = &v24;
  v26 = 0x2020000000;
  v27 = 0;
  v10 = *(*(a1 + 32) + 96);
  v22[0] = MEMORY[0x1E69E9820];
  v22[1] = 3221225472;
  v22[2] = __nw_read_request_receive_block_invoke_2;
  v22[3] = &unk_1E6A35838;
  v22[4] = &v24;
  v22[5] = a4;
  v23 = a5;
  nw_fd_wrapper_get_fd(v10, v22);
  v11 = v25[3];
  if (v11)
  {
    if (v11 == -1)
    {
      posix_error = nw_error_create_posix_error(**(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8));
      v13 = *(a1 + 32);
      v14 = *(v13 + 152);
      *(v13 + 152) = posix_error;

      nw_read_request_report(*(a1 + 32), 0);
      v15 = *(*(a1 + 40) + 8);
      v16 = *(v15 + 40);
      *(v15 + 40) = 0;

      v17 = 0;
    }

    else if (v11 >= a5)
    {
      *(*(*(a1 + 48) + 8) + 24) += v11;
      v17 = 1;
    }

    else
    {
      subrange = dispatch_data_create_subrange(*(*(*(a1 + 40) + 8) + 40), v11 + a3, *(a1 + 64) - (v11 + a3));
      v19 = *(*(a1 + 40) + 8);
      v20 = *(v19 + 40);
      *(v19 + 40) = subrange;

      v17 = 0;
      *(*(*(a1 + 48) + 8) + 24) += *(v25 + 6);
      *(*(*(a1 + 56) + 8) + 24) = 1;
    }
  }

  else
  {
    v17 = 0;
    *(*(a1 + 32) + 176) |= 8u;
  }

  _Block_object_dispose(&v24, 8);

  return v17;
}

void sub_18285AAAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void ___ZL34nw_read_request_start_file_updatesP26NWConcrete_nw_read_request_block_invoke(uint64_t a1)
{
  WeakRetained = objc_loadWeakRetained((a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained)
  {
    v3 = _Block_copy(WeakRetained[4]);
    v4 = v3;
    if (v3)
    {
      v5 = v2[7];
      v6 = *(v2 + 16);
      v7[0] = MEMORY[0x1E69E9820];
      v7[1] = 3221225472;
      v7[2] = ___ZL34nw_read_request_start_file_updatesP26NWConcrete_nw_read_request_block_invoke_2;
      v7[3] = &unk_1E6A3D710;
      v9 = v3;
      v8 = v2;
      nw_connection_async_client_if_needed_with_override(v5, 0, v6, v7);
    }
  }
}

void ___ZL34nw_read_request_start_file_updatesP26NWConcrete_nw_read_request_block_invoke_2(uint64_t a1)
{
  if (((*(*(a1 + 40) + 16))() & 1) == 0)
  {
    v2 = *(a1 + 32);
    v3 = [[NWConcrete_nw_error alloc] initWithDomain:89 code:?];
    nw_read_request_report_error_with_override(v2, 0, v3);
  }
}

void __nw_http_connection_state_storage_copy_shared_block_invoke()
{
  v0 = objc_alloc_init(NWConcrete_nw_http_connection_state_storage);
  v1 = nw_http_connection_state_storage_copy_shared_storage;
  nw_http_connection_state_storage_copy_shared_storage = v0;

  if (_os_feature_enabled_impl())
  {
    v2 = 8;
    v3 = nw_storage_copy_shared();
  }

  else
  {
    v3 = [MEMORY[0x1E695ACE8] sharedPersistentStore];
    v2 = 16;
  }

  v4 = *(nw_http_connection_state_storage_copy_shared_storage + v2);
  *(nw_http_connection_state_storage_copy_shared_storage + v2) = v3;
}

NWConcrete_nw_http_connection_state_storage *nw_http_connection_state_storage_create_ns(void *a1)
{
  v1 = a1;
  v2 = objc_alloc_init(NWConcrete_nw_http_connection_state_storage);
  if (_os_feature_enabled_impl())
  {
    v3 = [v1 underlyingStorage];
    storage = v2->storage;
    v2->storage = v3;
  }

  else
  {
    v5 = v1;
    storage = v2->oldStorage;
    v2->oldStorage = v5;
  }

  return v2;
}

uint64_t __Block_byref_object_copy__55563(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

void __nw_http_connection_state_storage_lookup_block_invoke(uint64_t a1, int a2, void *a3)
{
  v6 = a3;
  if (a2)
  {
    if (a2 == 1)
    {
      objc_storeStrong((*(*(a1 + 64) + 8) + 40), a3);
    }
  }

  else
  {
    v7 = *(a1 + 40);
    v8 = *(*(a1 + 32) + 8);
    v9 = *(a1 + 72);
    v13[0] = MEMORY[0x1E69E9820];
    v13[1] = 3221225472;
    v13[2] = __nw_http_connection_state_storage_lookup_block_invoke_2;
    v13[3] = &unk_1E6A35928;
    v10 = *(a1 + 48);
    v11 = *(a1 + 56);
    v12 = *(a1 + 64);
    v14 = v11;
    v15 = v12;
    nw_storage_lookup_http_early_data_state(v8, v9, v7, v10, v13);
  }
}

void nw_http_connection_state_storage_parse_and_set_alt_svc(void *a1, uint64_t a2, void *a3, const char *a4, void *a5)
{
  v97 = *MEMORY[0x1E69E9840];
  v9 = a1;
  v10 = a3;
  v11 = a5;
  v12 = v11;
  v87 = v9;
  v85 = v10;
  if (!v9)
  {
    v65 = v11;
    v66 = __nwlog_obj();
    *buf = 136446210;
    v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
    v67 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (!__nwlog_fault(v67, &type, &v91))
    {
      goto LABEL_130;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v68 = __nwlog_obj();
      v69 = type;
      if (os_log_type_enabled(v68, type))
      {
        *buf = 136446210;
        v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
        _os_log_impl(&dword_181A37000, v68, v69, "%{public}s called with null storage", buf, 0xCu);
      }

      goto LABEL_129;
    }

    if (v91 != 1)
    {
      v68 = __nwlog_obj();
      v81 = type;
      if (os_log_type_enabled(v68, type))
      {
        *buf = 136446210;
        v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
        _os_log_impl(&dword_181A37000, v68, v81, "%{public}s called with null storage, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_129;
    }

    backtrace_string = __nw_create_backtrace_string();
    v68 = __nwlog_obj();
    v75 = type;
    v76 = os_log_type_enabled(v68, type);
    if (!backtrace_string)
    {
      if (v76)
      {
        *buf = 136446210;
        v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
        _os_log_impl(&dword_181A37000, v68, v75, "%{public}s called with null storage, no backtrace", buf, 0xCu);
      }

      goto LABEL_129;
    }

    if (v76)
    {
      *buf = 136446466;
      v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
      v95 = 2082;
      v96 = backtrace_string;
      _os_log_impl(&dword_181A37000, v68, v75, "%{public}s called with null storage, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_111;
  }

  if (!v10)
  {
    v65 = v11;
    v70 = __nwlog_obj();
    *buf = 136446210;
    v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
    v67 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (!__nwlog_fault(v67, &type, &v91))
    {
      goto LABEL_130;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v68 = __nwlog_obj();
      v71 = type;
      if (os_log_type_enabled(v68, type))
      {
        *buf = 136446210;
        v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
        _os_log_impl(&dword_181A37000, v68, v71, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_129;
    }

    if (v91 != 1)
    {
      v68 = __nwlog_obj();
      v82 = type;
      if (os_log_type_enabled(v68, type))
      {
        *buf = 136446210;
        v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
        _os_log_impl(&dword_181A37000, v68, v82, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_129;
    }

    backtrace_string = __nw_create_backtrace_string();
    v68 = __nwlog_obj();
    v77 = type;
    v78 = os_log_type_enabled(v68, type);
    if (!backtrace_string)
    {
      if (v78)
      {
        *buf = 136446210;
        v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
        _os_log_impl(&dword_181A37000, v68, v77, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_129;
    }

    if (v78)
    {
      *buf = 136446466;
      v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
      v95 = 2082;
      v96 = backtrace_string;
      _os_log_impl(&dword_181A37000, v68, v77, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_111;
  }

  if (!v11)
  {
    v65 = 0;
    v72 = __nwlog_obj();
    *buf = 136446210;
    v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
    v67 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (!__nwlog_fault(v67, &type, &v91))
    {
      goto LABEL_130;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v68 = __nwlog_obj();
      v73 = type;
      if (os_log_type_enabled(v68, type))
      {
        *buf = 136446210;
        v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
        _os_log_impl(&dword_181A37000, v68, v73, "%{public}s called with null sec_metadata", buf, 0xCu);
      }

LABEL_129:

LABEL_130:
      v12 = v65;
      if (v67)
      {
        free(v67);
      }

      goto LABEL_81;
    }

    if (v91 != 1)
    {
      v68 = __nwlog_obj();
      v83 = type;
      if (os_log_type_enabled(v68, type))
      {
        *buf = 136446210;
        v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
        _os_log_impl(&dword_181A37000, v68, v83, "%{public}s called with null sec_metadata, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_129;
    }

    backtrace_string = __nw_create_backtrace_string();
    v68 = __nwlog_obj();
    v79 = type;
    v80 = os_log_type_enabled(v68, type);
    if (!backtrace_string)
    {
      if (v80)
      {
        *buf = 136446210;
        v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
        _os_log_impl(&dword_181A37000, v68, v79, "%{public}s called with null sec_metadata, no backtrace", buf, 0xCu);
      }

      goto LABEL_129;
    }

    if (v80)
    {
      *buf = 136446466;
      v94 = "nw_http_connection_state_storage_parse_and_set_alt_svc";
      v95 = 2082;
      v96 = backtrace_string;
      _os_log_impl(&dword_181A37000, v68, v79, "%{public}s called with null sec_metadata, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_111:

    free(backtrace_string);
    goto LABEL_130;
  }

  if (!strcmp(a4, "clear"))
  {
    v59 = *(v9 + 1);
    if (v59)
    {
      nw_storage_delete_alt_svc(v59, a2, v10);
    }

    else
    {
      v60 = MEMORY[0x1E696AEC0];
      v61 = v10;
      hostname = _nw_endpoint_get_hostname(v61);

      v63 = [v60 stringWithUTF8String:hostname];
      v64 = v61;
      LODWORD(v61) = _nw_endpoint_get_port(v64);

      [v87[2] removeHTTPAlternativeServiceEntriesWithHost:v63 port:v61];
    }
  }

  else
  {
    v86 = v12;
    v89 = strlen(a4);
    v90 = objc_alloc_init(MEMORY[0x1E695ACD8]);
    if (v89 != -1)
    {
      v84 = a2;
      v13 = 0;
      v14 = 2;
      v15 = MEMORY[0x1E69E9830];
      v16 = a4;
      v88 = a4;
      while (1)
      {
        v18 = &a4[v13];
        v19 = a4[v13];
        if (v19 != 61)
        {
          v25 = v16;
          goto LABEL_36;
        }

        *v18 = 0;
        v20 = v16 - 1;
        do
        {
          v22 = v16;
          v23 = v20;
          v24 = *v16;
          if (*v16 < 0)
          {
            v21 = __maskrune(*v16, 0x4000uLL);
          }

          else
          {
            v21 = *(v15 + 4 * *v16 + 60) & 0x4000;
          }

          ++v16;
          v20 = v23 + 1;
        }

        while (v21);
        if (v24)
        {
          v26 = &v23[strlen(v22)];
          while (1)
          {
            v28 = v26;
            if (v26 <= v22)
            {
              break;
            }

            v29 = *v26;
            if (v29 < 0)
            {
              v27 = __maskrune(*v28, 0x4000uLL);
              v26 = v28 - 1;
              if (!v27)
              {
                break;
              }
            }

            else
            {
              v30 = *(v15 + 4 * v29 + 60) & 0x4000;
              v26 = v28 - 1;
              if (!v30)
              {
                break;
              }
            }
          }

          v28[1] = 0;
        }

        v25 = v18 + 1;
        v31 = *v22;
        if (v31 == 109)
        {
          break;
        }

        if (v31 != 104 || *v16 != 51 || v22[2])
        {
          goto LABEL_35;
        }

        [v90 setServiceType:1];
        v32 = MEMORY[0x1E696AEC0];
        v33 = v85;
        v34 = _nw_endpoint_get_hostname(v33);

        v35 = [v32 stringWithUTF8String:v34];
        [v90 setHost:v35];

        v36 = v33;
        LODWORD(v33) = _nw_endpoint_get_port(v36);

        [v90 setPort:v33];
        if (v84)
        {
          v37 = [MEMORY[0x1E696AEC0] stringWithUTF8String:?];
          [v90 setPartition:v37];
        }

        else
        {
          [v90 setPartition:?];
        }

        v14 = 0;
LABEL_36:
        v38 = v19 > 0x3B || ((1 << v19) & 0x800100000000001) == 0;
        if (v38)
        {
          goto LABEL_9;
        }

        *v18 = 0;
        v39 = v25 - 1;
        do
        {
          v41 = v25;
          v42 = v39;
          v43 = *v25;
          if (*v25 < 0)
          {
            v40 = __maskrune(*v25, 0x4000uLL);
          }

          else
          {
            v40 = *(v15 + 4 * *v25 + 60) & 0x4000;
          }

          ++v25;
          ++v39;
        }

        while (v40);
        if (v43)
        {
          v44 = &v42[strlen(v41)];
          while (1)
          {
            v46 = v44;
            if (v44 <= v41)
            {
              break;
            }

            v47 = *v44;
            if (v47 < 0)
            {
              v45 = __maskrune(*v46, 0x4000uLL);
              v44 = v46 - 1;
              if (!v45)
              {
                break;
              }
            }

            else
            {
              v48 = *(v15 + 4 * v47 + 60) & 0x4000;
              v44 = v46 - 1;
              if (!v48)
              {
                break;
              }
            }
          }

          *(v46 + 1) = 0;
        }

        if (v14 == 1)
        {
          v55 = atoi(v41);
          if (v55 >= 604800)
          {
            v56 = 604800;
          }

          else
          {
            v56 = v55;
          }

          v49 = [MEMORY[0x1E695DF00] dateWithTimeIntervalSinceNow:v56];
          [v90 setExpirationDate:v49];
LABEL_68:

          goto LABEL_69;
        }

        if (!v14)
        {
          v49 = v90;
          v50 = strlen(v41);
          if (v50 >= 2 && *v41 == 34)
          {
            v51 = &v41[v50];
            if (v41[v50 - 1] == 34)
            {
              if (v50 == -1)
              {
LABEL_61:
                v52 = 0;
              }

              else
              {
                v52 = 0;
                while (v39[v52] != 58)
                {
                  if (v50 + 1 == ++v52)
                  {
                    goto LABEL_61;
                  }
                }
              }

              v53 = &v41[v52];
              *v53 = 0;
              v54 = v53 + 1;
              *(v51 - 1) = 0;
              if (*v25)
              {
                [MEMORY[0x1E696AEC0] stringWithUTF8String:v25];
              }

              else
              {
                [v49 host];
              }
              v57 = ;
              [v49 setAlternateHost:v57];

              if (*v54)
              {
                v58 = atoi(v54);
              }

              else
              {
                v58 = [v49 port];
              }

              [v49 setAlternatePort:v58];
            }
          }

          goto LABEL_68;
        }

LABEL_69:
        v25 = v18 + 1;
        if (v19 == 44)
        {
          check_certs_and_store_entry(v87, v90, v86);
          v17 = objc_alloc_init(MEMORY[0x1E695ACD8]);

          v14 = 2;
          v90 = v17;
        }

        else
        {
          v14 = 2;
        }

        a4 = v88;
LABEL_9:
        v16 = v25;
        v38 = v13++ == v89;
        if (v38)
        {
          goto LABEL_77;
        }
      }

      if (*v16 == 97)
      {
        if (v22[2])
        {
          v14 = 2;
        }

        else
        {
          v14 = 1;
        }

        goto LABEL_36;
      }

LABEL_35:
      v14 = 2;
      goto LABEL_36;
    }

LABEL_77:
    v12 = v86;
    check_certs_and_store_entry(v87, v90, v86);
  }

LABEL_81:
}

void check_certs_and_store_entry(void *a1, void *a2, void *a3)
{
  v39 = *MEMORY[0x1E69E9840];
  v23 = a1;
  v5 = a2;
  v22 = a3;
  v6 = [v5 alternateHost];
  v7 = [v5 host];
  if ([v6 isEqualToString:v7])
  {

    goto LABEL_4;
  }

  v8 = [v5 alternateHost];
  v9 = v22;
  v10 = v8;
  v28 = 0;
  v29 = &v28;
  v30 = 0x2020000000;
  v31 = 0;
  v26[0] = 0;
  v26[1] = v26;
  v26[2] = 0x3032000000;
  v26[3] = __Block_byref_object_copy__55563;
  v26[4] = __Block_byref_object_dispose__55564;
  v27 = 0;
  v24[0] = 0;
  v24[1] = v24;
  v24[2] = 0x2020000000;
  v25 = 0;
  *&handler = MEMORY[0x1E69E9820];
  *(&handler + 1) = 3221225472;
  v33 = __check_certs_block_invoke;
  v34 = &unk_1E6A35978;
  v36 = &v28;
  v11 = v10;
  v35 = v11;
  v37 = v24;
  v38 = v26;
  sec_protocol_metadata_access_peer_certificate_chain(v9, &handler);
  LOBYTE(v8) = *(v29 + 24);

  _Block_object_dispose(v24, 8);
  _Block_object_dispose(v26, 8);

  _Block_object_dispose(&v28, 8);
  if (v8)
  {
LABEL_4:
    if (*(v23 + 1))
    {
      v12 = [v5 partition];
      v13 = [v5 host];
      v14 = [v5 alternateHost];
      host_with_numeric_port = nw_endpoint_create_host_with_numeric_port([v13 UTF8String], objc_msgSend(v5, "port"));
      v16 = nw_endpoint_create_host_with_numeric_port([v14 UTF8String], objc_msgSend(v5, "alternatePort"));
      v17 = *(v23 + 1);
      v18 = [v12 UTF8String];
      v19 = [v5 serviceType];
      v20 = [v5 expirationDate];
      [v20 timeIntervalSinceReferenceDate];
      nw_storage_store_alt_svc(v17, v18, host_with_numeric_port, v19, v16);
    }

    else
    {
      [*(v23 + 2) storeHTTPServiceEntry:v5];
    }

    goto LABEL_8;
  }

  if (gLogDatapath == 1)
  {
    v21 = __nwlog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(handler) = 136446210;
      *(&handler + 4) = "check_certs_and_store_entry";
      _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_DEBUG, "%{public}s Ignoring the alternative service header since it is not covered under the setting origin's certificate", &handler, 0xCu);
    }
  }

LABEL_8:
}

void sub_18285BEB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, void);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  va_copy(va2, va1);
  v9 = va_arg(va2, void);
  v11 = va_arg(va2, void);
  v12 = va_arg(va2, void);
  v13 = va_arg(va2, void);
  v14 = va_arg(va2, void);
  v15 = va_arg(va2, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose(va2, 8);
  _Unwind_Resume(a1);
}

void __check_certs_block_invoke(uint64_t a1, sec_certificate_t certificate)
{
  v23 = *MEMORY[0x1E69E9840];
  if ((*(*(*(a1 + 40) + 8) + 24) & 1) == 0)
  {
    v3 = sec_certificate_copy_ref(certificate);
    v4 = SecCertificateCopyDNSNames();
    if (v3)
    {
      CFRelease(v3);
    }

    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v5 = v4;
    v6 = [v5 countByEnumeratingWithState:&v18 objects:v22 count:16];
    if (v6)
    {
      v7 = v6;
      v8 = *v19;
      while (2)
      {
        for (i = 0; i != v7; ++i)
        {
          if (*v19 != v8)
          {
            objc_enumerationMutation(v5);
          }

          v12 = *(*(&v18 + 1) + 8 * i);
          if ([v12 isEqualToString:{*(a1 + 32), v18}])
          {
            goto LABEL_20;
          }

          if ([v12 hasPrefix:@"*"] && objc_msgSend(v12, "length") >= 2)
          {
            if ((*(*(*(a1 + 48) + 8) + 24) & 1) == 0)
            {
              v13 = [*(a1 + 32) rangeOfString:@"."];
              if (v14)
              {
                v15 = [*(a1 + 32) substringFromIndex:v13];
                v16 = *(*(a1 + 56) + 8);
                v17 = *(v16 + 40);
                *(v16 + 40) = v15;
              }

              *(*(*(a1 + 48) + 8) + 24) = 1;
            }

            v10 = *(*(*(a1 + 56) + 8) + 40);
            v11 = [v12 substringFromIndex:1];
            LOBYTE(v10) = [v10 isEqualToString:v11];

            if (v10)
            {
LABEL_20:
              *(*(*(a1 + 40) + 8) + 24) = 1;
              goto LABEL_21;
            }
          }
        }

        v7 = [v5 countByEnumeratingWithState:&v18 objects:v22 count:16];
        if (v7)
        {
          continue;
        }

        break;
      }
    }

LABEL_21:
  }
}

uint64_t __Block_byref_object_copy__55666(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

BOOL nw_ip_channel_sockaddrs_are_equal_without_port(sockaddr_in_4_6 *a1, sockaddr_in_4_6 *a2)
{
  v21 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v5 = __nwlog_obj();
    *buf = 136446210;
    v18 = "nw_ip_channel_sockaddrs_are_equal_without_port";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15))
    {
      goto LABEL_41;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v18 = "nw_ip_channel_sockaddrs_are_equal_without_port";
        v9 = "%{public}s called with null addr1";
LABEL_39:
        _os_log_impl(&dword_181A37000, v7, v8, v9, buf, 0xCu);
      }

LABEL_40:

LABEL_41:
      if (v6)
      {
        free(v6);
      }

      return 0;
    }

    if (v15 != 1)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v18 = "nw_ip_channel_sockaddrs_are_equal_without_port";
        v9 = "%{public}s called with null addr1, backtrace limit exceeded";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    backtrace_string = __nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v12 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *buf = 136446210;
        v18 = "nw_ip_channel_sockaddrs_are_equal_without_port";
        v9 = "%{public}s called with null addr1, no backtrace";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    if (v12)
    {
      *buf = 136446466;
      v18 = "nw_ip_channel_sockaddrs_are_equal_without_port";
      v19 = 2082;
      v20 = backtrace_string;
      v13 = "%{public}s called with null addr1, dumping backtrace:%{public}s";
LABEL_29:
      _os_log_impl(&dword_181A37000, v7, v8, v13, buf, 0x16u);
    }

LABEL_30:

    free(backtrace_string);
    goto LABEL_41;
  }

  if (!a2)
  {
    v10 = __nwlog_obj();
    *buf = 136446210;
    v18 = "nw_ip_channel_sockaddrs_are_equal_without_port";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15))
    {
      goto LABEL_41;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v18 = "nw_ip_channel_sockaddrs_are_equal_without_port";
        v9 = "%{public}s called with null addr2";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    if (v15 != 1)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v18 = "nw_ip_channel_sockaddrs_are_equal_without_port";
        v9 = "%{public}s called with null addr2, backtrace limit exceeded";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    backtrace_string = __nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v14 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *buf = 136446210;
        v18 = "nw_ip_channel_sockaddrs_are_equal_without_port";
        v9 = "%{public}s called with null addr2, no backtrace";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    if (v14)
    {
      *buf = 136446466;
      v18 = "nw_ip_channel_sockaddrs_are_equal_without_port";
      v19 = 2082;
      v20 = backtrace_string;
      v13 = "%{public}s called with null addr2, dumping backtrace:%{public}s";
      goto LABEL_29;
    }

    goto LABEL_30;
  }

  sa_family = a1->var0.sa_family;
  if (__PAIR64__(sa_family, a1->var0.sa_len) != __PAIR64__(a2->var0.sa_family, a2->var0.sa_len))
  {
    return 0;
  }

  if (sa_family == 30)
  {
    return *a1->var3.sin6_addr.__u6_addr8 == *a2->var3.sin6_addr.__u6_addr8 && *&a1->var3.sin6_addr.__u6_addr32[2] == *&a2->var3.sin6_addr.__u6_addr32[2];
  }

  if (sa_family != 2)
  {
    return 0;
  }

  return a1->var2.sin_addr.s_addr == a2->var2.sin_addr.s_addr;
}

uint64_t ___ZL38nw_ip_channel_inbox_handle_input_frameP19nw_ip_channel_inboxP11nw_protocolPU22objcproto11OS_nw_frame8NSObjectPU22objcproto11OS_nw_arrayS3_P27nw_ip_channel_fragment_info_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  v21 = *MEMORY[0x1E69E9840];
  v4 = a3;
  v5 = nw_connection_copy_endpoint(v4);
  v6 = nw_connection_copy_parameters(v4);
  v7 = nw_parameters_copy_local_endpoint(v6);
  if (v5 && (v8 = v5, type = _nw_endpoint_get_type(v8), v8, type == 1) && ((v10 = v8, v11 = _nw_endpoint_address_endpoint_matches_address(v10, (a1 + 40), 0, 0), v10, v7) ? (v12 = v11) : (v12 = 0), v12 == 1 && (v13 = v7, v14 = _nw_endpoint_get_type(v13), v13, v14 == 1) && (v15 = v13, v16 = _nw_endpoint_address_endpoint_matches_address(v15, (a1 + 68), 0, 0), v15, v16)))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      *v20 = 136446466;
      *&v20[4] = "nw_ip_channel_inbox_handle_input_frame_block_invoke";
      *&v20[12] = 2112;
      *&v20[14] = v4;
      _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_INFO, "%{public}s Reclassifying packet for %@", v20, 0x16u);
    }

    *v20 = 0;
    *&v20[8] = 0;
    nw_connection_get_flow_id_on_nw_queue(v4, v20);
    nw_frame_reclassify(*(a1 + 32), v20);
    v18 = 0;
  }

  else
  {
    v18 = 1;
  }

  return v18;
}

void nw_ip_metadata_set_ecn_flag(nw_protocol_metadata_t metadata, nw_ip_ecn_flag_t ecn_flag)
{
  v15 = *MEMORY[0x1E69E9840];
  if (metadata)
  {

    _nw_ip_metadata_set_ecn_flag();
    return;
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_ip_metadata_set_ecn_flag";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_set_ecn_flag";
        v6 = "%{public}s called with null metadata";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_ip_metadata_set_ecn_flag";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_ip_metadata_set_ecn_flag";
        v6 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_set_ecn_flag";
        v6 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }
}

nw_ip_ecn_flag_t nw_ip_metadata_get_ecn_flag(nw_protocol_metadata_t metadata)
{
  v15 = *MEMORY[0x1E69E9840];
  if (metadata)
  {

    return _nw_ip_metadata_get_ecn_flag(metadata);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_ip_metadata_get_ecn_flag";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_get_ecn_flag";
        v6 = "%{public}s called with null metadata";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_ip_metadata_get_ecn_flag";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_ip_metadata_get_ecn_flag";
        v6 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_get_ecn_flag";
        v6 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

void nw_ip_metadata_set_dscp_value(void *a1, unsigned int a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v5 = __nwlog_obj();
    *buf = 136446210;
    v18 = "nw_ip_metadata_set_dscp_value";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15))
    {
      goto LABEL_34;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v18 = "nw_ip_metadata_set_dscp_value";
        v9 = "%{public}s called with null metadata";
LABEL_32:
        _os_log_impl(&dword_181A37000, v7, v8, v9, buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v12 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v18 = "nw_ip_metadata_set_dscp_value";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v6)
        {
          goto LABEL_4;
        }

LABEL_35:
        free(v6);
        goto LABEL_4;
      }

      if (v12)
      {
        *buf = 136446210;
        v18 = "nw_ip_metadata_set_dscp_value";
        v9 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_32;
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v18 = "nw_ip_metadata_set_dscp_value";
        v9 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

LABEL_33:

    goto LABEL_34;
  }

  if (a2 < 0x40)
  {
    _nw_ip_metadata_set_dscp_value(v3, a2);
    goto LABEL_4;
  }

  v10 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_ip_metadata_set_dscp_value";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v6, &type, &v15))
  {
    goto LABEL_34;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v18 = "nw_ip_metadata_set_dscp_value";
      v9 = "%{public}s called with null (dscp_value <= _MAX_DSCP)";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v15 != 1)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v18 = "nw_ip_metadata_set_dscp_value";
      v9 = "%{public}s called with null (dscp_value <= _MAX_DSCP), backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  v13 = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v14 = os_log_type_enabled(v7, type);
  if (!v13)
  {
    if (v14)
    {
      *buf = 136446210;
      v18 = "nw_ip_metadata_set_dscp_value";
      v9 = "%{public}s called with null (dscp_value <= _MAX_DSCP), no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v14)
  {
    *buf = 136446466;
    v18 = "nw_ip_metadata_set_dscp_value";
    v19 = 2082;
    v20 = v13;
    _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null (dscp_value <= _MAX_DSCP), dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v13);
  if (v6)
  {
    goto LABEL_35;
  }

LABEL_4:
}

uint64_t nw_ip_metadata_get_dscp_value(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_ip_metadata_get_dscp_value(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_ip_metadata_get_dscp_value";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_get_dscp_value";
        v6 = "%{public}s called with null metadata";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_ip_metadata_get_dscp_value";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_ip_metadata_get_dscp_value";
        v6 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_get_dscp_value";
        v6 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

void nw_ip_metadata_set_service_class(nw_protocol_metadata_t metadata, nw_service_class_t service_class)
{
  v15 = *MEMORY[0x1E69E9840];
  if (metadata)
  {

    _nw_ip_metadata_set_service_class(metadata, *&service_class);
    return;
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_ip_metadata_set_service_class";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_set_service_class";
        v6 = "%{public}s called with null metadata";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_ip_metadata_set_service_class";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_ip_metadata_set_service_class";
        v6 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_set_service_class";
        v6 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }
}

nw_service_class_t nw_ip_metadata_get_service_class(nw_protocol_metadata_t metadata)
{
  v15 = *MEMORY[0x1E69E9840];
  if (metadata)
  {

    return _nw_ip_metadata_get_service_class(metadata);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_ip_metadata_get_service_class";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_get_service_class";
        v6 = "%{public}s called with null metadata";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_ip_metadata_get_service_class";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_ip_metadata_get_service_class";
        v6 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_get_service_class";
        v6 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

uint64_t nw_ip_metadata_get_receive_time(nw_protocol_metadata_t metadata)
{
  v15 = *MEMORY[0x1E69E9840];
  if (metadata)
  {

    return _nw_ip_metadata_get_receive_time(metadata);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_ip_metadata_get_receive_time";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_get_receive_time";
        v6 = "%{public}s called with null metadata";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_ip_metadata_get_receive_time";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_ip_metadata_get_receive_time";
        v6 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_get_receive_time";
        v6 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

uint64_t nw_ip_metadata_get_hop_limit(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_ip_metadata_get_hop_limit(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_ip_metadata_get_hop_limit";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_get_hop_limit";
        v6 = "%{public}s called with null metadata";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_ip_metadata_get_hop_limit";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_ip_metadata_get_hop_limit";
        v6 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_get_hop_limit";
        v6 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

void nw_ip_metadata_set_enable_fragmentation(uint64_t a1, char a2)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_ip_metadata_set_enable_fragmentation(a1, a2);
    return;
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_ip_metadata_set_enable_fragmentation";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_set_enable_fragmentation";
        v6 = "%{public}s called with null metadata";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_ip_metadata_set_enable_fragmentation";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_ip_metadata_set_enable_fragmentation";
        v6 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_set_enable_fragmentation";
        v6 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }
}

uint64_t nw_ip_metadata_get_fragmentation_value(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_ip_metadata_get_fragmentation_value(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_ip_metadata_get_fragmentation_value";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_get_fragmentation_value";
        v6 = "%{public}s called with null metadata";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_ip_metadata_get_fragmentation_value";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_ip_metadata_get_fragmentation_value";
        v6 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_ip_metadata_get_fragmentation_value";
        v6 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

void nw_ip_options_set_disable_fragmentation(nw_protocol_options_t options, BOOL disable_fragmentation)
{
  v2 = disable_fragmentation;
  v17 = *MEMORY[0x1E69E9840];
  v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    _nw_ip_options_set_disable_fragmentation(v3, v2);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v14 = "nw_ip_options_set_disable_fragmentation";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v14 = "nw_ip_options_set_disable_fragmentation";
        v8 = "%{public}s called with null nw_protocol_options_is_ip(options)";
LABEL_17:
        _os_log_impl(&dword_181A37000, v6, v7, v8, buf, 0xCu);
      }
    }

    else
    {
      if (v11 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v6 = __nwlog_obj();
        v7 = type;
        v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *buf = 136446466;
            v14 = "nw_ip_options_set_disable_fragmentation";
            v15 = 2082;
            v16 = backtrace_string;
            _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v10)
        {
          goto LABEL_18;
        }

        *buf = 136446210;
        v14 = "nw_ip_options_set_disable_fragmentation";
        v8 = "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace";
        goto LABEL_17;
      }

      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v14 = "nw_ip_options_set_disable_fragmentation";
        v8 = "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded";
        goto LABEL_17;
      }
    }

LABEL_18:
  }

LABEL_19:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_ip_options_set_dscp_value(void *a1, char a2)
{
  v17 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (nw_protocol_options_is_ip(v3))
  {
    _nw_ip_options_set_dscp_value(v3, a2);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v14 = "nw_ip_options_set_dscp_value";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v14 = "nw_ip_options_set_dscp_value";
        v8 = "%{public}s called with null nw_protocol_options_is_ip(options)";
LABEL_17:
        _os_log_impl(&dword_181A37000, v6, v7, v8, buf, 0xCu);
      }
    }

    else
    {
      if (v11 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v6 = __nwlog_obj();
        v7 = type;
        v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *buf = 136446466;
            v14 = "nw_ip_options_set_dscp_value";
            v15 = 2082;
            v16 = backtrace_string;
            _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v10)
        {
          goto LABEL_18;
        }

        *buf = 136446210;
        v14 = "nw_ip_options_set_dscp_value";
        v8 = "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace";
        goto LABEL_17;
      }

      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v14 = "nw_ip_options_set_dscp_value";
        v8 = "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded";
        goto LABEL_17;
      }
    }

LABEL_18:
  }

LABEL_19:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

uint64_t nw_custom_ip_options_get_protocol(void *a1)
{
  v17 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (nw_protocol_options_is_custom_ip(v1))
  {
    protocol = _nw_custom_ip_options_get_protocol(v1);
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v14 = "nw_custom_ip_options_get_protocol";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v14 = "nw_custom_ip_options_get_protocol";
        v8 = "%{public}s called with null nw_protocol_options_is_custom_ip(options)";
LABEL_17:
        _os_log_impl(&dword_181A37000, v6, v7, v8, buf, 0xCu);
      }
    }

    else
    {
      if (v11 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v6 = __nwlog_obj();
        v7 = type;
        v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *buf = 136446466;
            v14 = "nw_custom_ip_options_get_protocol";
            v15 = 2082;
            v16 = backtrace_string;
            _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null nw_protocol_options_is_custom_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v10)
        {
          goto LABEL_18;
        }

        *buf = 136446210;
        v14 = "nw_custom_ip_options_get_protocol";
        v8 = "%{public}s called with null nw_protocol_options_is_custom_ip(options), no backtrace";
        goto LABEL_17;
      }

      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v14 = "nw_custom_ip_options_get_protocol";
        v8 = "%{public}s called with null nw_protocol_options_is_custom_ip(options), backtrace limit exceeded";
        goto LABEL_17;
      }
    }

LABEL_18:
  }

LABEL_19:
  if (v5)
  {
    free(v5);
  }

  protocol = 0;
LABEL_3:

  return protocol;
}

void __Block_byref_object_copy__56246(uint64_t a1, uint64_t a2)
{
  v4 = (a1 + 48);
  *(a1 + 208) = 0;
  v5 = MEMORY[0x1E69E54E8];
  *(a1 + 160) = MEMORY[0x1E69E5590] + 16;
  v6 = *(v5 + 16);
  v7 = *(v5 + 8);
  *(a1 + 48) = v7;
  *(a1 + 48 + *(v7 - 24)) = v6;
  v8 = (a1 + 48 + *(*(a1 + 48) - 24));
  v9 = (a2 + 48 + *(*(a2 + 48) - 24));
  std::ios_base::move(v8, v9);
  v8[1].__vftable = v9[1].__vftable;
  v9[1].__vftable = 0;
  v8[1].__fmtflags_ = v9[1].__fmtflags_;
  *(a1 + 48) = MEMORY[0x1E69E5570] + 24;
  *(a1 + 160) = MEMORY[0x1E69E5570] + 64;
  *(a1 + 56) = MEMORY[0x1E69E5538] + 16;
  MEMORY[0x1865DC480](a1 + 64);
  *(a1 + 120) = 0;
  v10 = (a1 + 120);
  *(a1 + 88) = 0u;
  *(a1 + 104) = 0u;
  *(a1 + 72) = 0u;
  *(a1 + 56) = MEMORY[0x1E69E5548] + 16;
  *(a1 + 128) = 0;
  *(a1 + 136) = 0;
  *(a1 + 152) = *(a2 + 152);
  v11 = (a2 + 120);
  if (*(a2 + 143) >= 0)
  {
    v12 = a2 + 120;
  }

  else
  {
    v12 = *(a2 + 120);
  }

  v13 = *(a2 + 72);
  if (v13)
  {
    v14 = v13 - v12;
    v15 = *(a2 + 80) - v12;
    v16 = *(a2 + 88) - v12;
    v17 = *(a2 + 96);
    if (v17)
    {
LABEL_6:
      v18 = v17 - v12;
      v19 = *(a2 + 104) - v12;
      v20 = *(a2 + 112) - v12;
      goto LABEL_9;
    }
  }

  else
  {
    v16 = -1;
    v15 = -1;
    v14 = -1;
    v17 = *(a2 + 96);
    if (v17)
    {
      goto LABEL_6;
    }
  }

  v18 = -1;
  v19 = -1;
  v20 = -1;
LABEL_9:
  v21 = *(a2 + 144);
  v22 = v21 - v12;
  if (!v21)
  {
    v22 = -1;
  }

  v23 = *v11;
  *(a1 + 136) = *(a2 + 136);
  *v10 = v23;
  *(a2 + 143) = 0;
  *(a2 + 120) = 0;
  v24 = a1 + 120;
  if (*(a1 + 143) < 0)
  {
    v24 = *v10;
  }

  if (v14 != -1)
  {
    *(a1 + 72) = v24 + v14;
    *(a1 + 80) = v24 + v15;
    *(a1 + 88) = v24 + v16;
  }

  if (v18 != -1)
  {
    *(a1 + 112) = v24 + v20;
    *(a1 + 96) = v24 + v18;
    *(a1 + 104) = v24 + v18 + v19;
  }

  v25 = v24 + v22;
  if (v22 == -1)
  {
    v25 = 0;
  }

  *(a1 + 144) = v25;
  if (*(a2 + 143) < 0)
  {
    v11 = *(a2 + 120);
  }

  *(a2 + 72) = v11;
  *(a2 + 80) = v11;
  *(a2 + 88) = v11;
  *(a2 + 96) = v11;
  *(a2 + 104) = v11;
  *(a2 + 112) = v11;
  *(a2 + 144) = v11;
  std::locale::locale(&v26, (a2 + 64));
  (*(*(a1 + 56) + 16))(a1 + 56, &v26);
  std::locale::locale(&v27, (a1 + 64));
  std::locale::operator=((a1 + 64), &v26);
  std::locale::~locale(&v27);
  std::locale::~locale(&v26);
  *(v4 + *(*v4 - 24) + 40) = a1 + 56;
}

void sub_182862AD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
  std::locale::~locale(&a9);
  if (*(v10 + 143) < 0)
  {
    operator delete(*v13);
  }

  *v11 = v12;
  std::locale::~locale((v10 + 64));
  std::ostream::~ostream();
  MEMORY[0x1865DC4F0](v9);
  _Unwind_Resume(a1);
}

void __Block_byref_object_dispose__56247(uint64_t a1)
{
  v2 = MEMORY[0x1E69E54E8];
  v3 = *MEMORY[0x1E69E54E8];
  *(a1 + 48) = *MEMORY[0x1E69E54E8];
  *(a1 + 48 + *(v3 - 24)) = *(v2 + 24);
  *(a1 + 56) = MEMORY[0x1E69E5548] + 16;
  if (*(a1 + 143) < 0)
  {
    operator delete(*(a1 + 120));
  }

  *(a1 + 56) = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale((a1 + 64));
  std::ostream::~ostream();

  JUMPOUT(0x1865DC4F0);
}

uint64_t __Block_byref_object_copy__25_56289(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

uint64_t __nw_resolver_config_enumerate_search_domains_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  if (object_getClass(v4) == MEMORY[0x1E69E9F10])
  {
    v6 = *(a1 + 32);
    string_ptr = xpc_string_get_string_ptr(v4);
    v5 = (*(v6 + 16))(v6, string_ptr);
  }

  else
  {
    v5 = 1;
  }

  return v5;
}

NWConcrete_nw_resolver_config *nw_resolver_config_create()
{
  v0 = xpc_dictionary_create(0, 0, 0);
  result = nw_resolver_config_create_with_dictionary(v0);
  if (v0)
  {
    v2 = result;

    return v2;
  }

  return result;
}

nw_resolver_config_t nw_resolver_config_create_https(nw_endpoint_t url_endpoint)
{
  v42 = *MEMORY[0x1E69E9840];
  v1 = url_endpoint;
  v2 = v1;
  if (!v1)
  {
    v25 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_resolver_config_create_https";
    v8 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    out[0] = 0;
    if (!__nwlog_fault(v8, type, out))
    {
      goto LABEL_26;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_create_https";
        _os_log_impl(&dword_181A37000, v26, v27, "%{public}s called with null url_endpoint", buf, 0xCu);
      }
    }

    else if (out[0] == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v31 = type[0];
      v32 = os_log_type_enabled(v26, type[0]);
      if (backtrace_string)
      {
        if (v32)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_create_https";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v26, v31, "%{public}s called with null url_endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v8)
        {
          goto LABEL_28;
        }

        goto LABEL_27;
      }

      if (v32)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_create_https";
        _os_log_impl(&dword_181A37000, v26, v31, "%{public}s called with null url_endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v26 = __nwlog_obj();
      v36 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_create_https";
        _os_log_impl(&dword_181A37000, v26, v36, "%{public}s called with null url_endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_62;
  }

  v3 = v1;
  v4 = _nw_endpoint_get_type(v3);

  if (v4 != 4)
  {
    v28 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_resolver_config_create_https";
    v8 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    out[0] = 0;
    if (!__nwlog_fault(v8, type, out))
    {
      goto LABEL_26;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v29 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_create_https";
        _os_log_impl(&dword_181A37000, v26, v29, "%{public}s called with null (nw_endpoint_get_type(url_endpoint) == nw_endpoint_type_url)", buf, 0xCu);
      }
    }

    else if (out[0] == 1)
    {
      v33 = __nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v34 = type[0];
      v35 = os_log_type_enabled(v26, type[0]);
      if (v33)
      {
        if (v35)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_create_https";
          *&buf[12] = 2082;
          *&buf[14] = v33;
          _os_log_impl(&dword_181A37000, v26, v34, "%{public}s called with null (nw_endpoint_get_type(url_endpoint) == nw_endpoint_type_url), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v33);
LABEL_26:
        if (!v8)
        {
LABEL_28:
          v18 = 0;
          goto LABEL_29;
        }

LABEL_27:
        free(v8);
        goto LABEL_28;
      }

      if (v35)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_create_https";
        _os_log_impl(&dword_181A37000, v26, v34, "%{public}s called with null (nw_endpoint_get_type(url_endpoint) == nw_endpoint_type_url), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v26 = __nwlog_obj();
      v37 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_create_https";
        _os_log_impl(&dword_181A37000, v26, v37, "%{public}s called with null (nw_endpoint_get_type(url_endpoint) == nw_endpoint_type_url), backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_62:

    goto LABEL_26;
  }

  v5 = v3;
  url_scheme = _nw_endpoint_get_url_scheme(v5);

  if (!url_scheme || strcasecmp(url_scheme, "https"))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    *buf = 136446466;
    *&buf[4] = "nw_resolver_config_create_https";
    *&buf[12] = 2080;
    *&buf[14] = url_scheme;
    v8 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    out[0] = 0;
    if (__nwlog_fault(v8, type, out))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_create_https";
          *&buf[12] = 2080;
          *&buf[14] = url_scheme;
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s Invalid URL scheme: %s", buf, 0x16u);
        }
      }

      else if (out[0] == 1)
      {
        v11 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v12 = type[0];
        v13 = os_log_type_enabled(v9, type[0]);
        if (v11)
        {
          if (v13)
          {
            *buf = 136446722;
            *&buf[4] = "nw_resolver_config_create_https";
            *&buf[12] = 2080;
            *&buf[14] = url_scheme;
            *&buf[22] = 2082;
            *&buf[24] = v11;
            _os_log_impl(&dword_181A37000, v9, v12, "%{public}s Invalid URL scheme: %s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v11);
          if (!v8)
          {
            goto LABEL_28;
          }

          goto LABEL_27;
        }

        if (v13)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_create_https";
          *&buf[12] = 2080;
          *&buf[14] = url_scheme;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s Invalid URL scheme: %s, no backtrace", buf, 0x16u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v23 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_create_https";
          *&buf[12] = 2080;
          *&buf[14] = url_scheme;
          _os_log_impl(&dword_181A37000, v9, v23, "%{public}s Invalid URL scheme: %s, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }

    goto LABEL_26;
  }

  v14 = xpc_dictionary_create(0, 0, 0);
  *buf = v14;
  buf[8] = -1;
  v15 = nw_resolver_config_create_with_dictionary(v14);
  if (v14)
  {
  }

  *type = v15;
  v39 = -1;
  memset(out, 0, sizeof(out));
  uuid_generate_random(out);
  nw_resolver_config_set_identifier(v15, out);
  memset(buf, 0, 37);
  uuid_unparse(out, buf);
  m_obj = v15->dictionary.m_obj;
  v17 = v15;
  xpc_dictionary_set_string(m_obj, "Identifier", buf);

  nw_resolver_config_set_class(v17, 3);
  nw_resolver_config_set_protocol(v17, 2);
  v18 = v17;
  v19 = v5;
  hostname = _nw_endpoint_get_hostname(v19);

  nw_resolver_config_set_provider_name(v18, hostname);
  v21 = v19;
  url_path = _nw_endpoint_get_url_path(v21);

  if (url_path)
  {
    nw_resolver_config_set_provider_path(v18, url_path);
  }

LABEL_29:

  return v18;
}

void sub_182863760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va);

  _Unwind_Resume(a1);
}

void nw_resolver_config_set_class(void *a1, int a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_set_class_block_invoke;
    v14[3] = &unk_1E6A3BD68;
    v5 = v3;
    v15 = v5;
    v16 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_class_block_invoke(v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_resolver_config_set_class";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_class";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_resolver_config_set_class";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_class";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_class";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void nw_resolver_config_set_protocol(void *a1, int a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_set_protocol_block_invoke;
    v14[3] = &unk_1E6A3BD68;
    v5 = v3;
    v15 = v5;
    v16 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_protocol_block_invoke(v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_resolver_config_set_protocol";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_protocol";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_resolver_config_set_protocol";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_protocol";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_protocol";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void nw_resolver_config_set_provider_name(void *a1, uint64_t a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_set_provider_name_block_invoke;
    v14[3] = &unk_1E6A3AC58;
    v5 = v3;
    v15 = v5;
    v16 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_provider_name_block_invoke(v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_resolver_config_set_provider_name";
  v7 = _os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_provider_name";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_resolver_config_set_provider_name";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_provider_name";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_provider_name";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void nw_resolver_config_set_provider_path(void *a1, uint64_t a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_set_provider_path_block_invoke;
    v14[3] = &unk_1E6A3AC58;
    v5 = v3;
    v15 = v5;
    v16 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_provider_path_block_invoke(v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_resolver_config_set_provider_path";
  v7 = _os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_provider_path";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_resolver_config_set_provider_path";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_provider_path";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_provider_path";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

nw_resolver_config_t nw_resolver_config_create_tls(nw_endpoint_t server_endpoint)
{
  v31 = *MEMORY[0x1E69E9840];
  v1 = server_endpoint;
  v2 = v1;
  if (!v1)
  {
    v13 = __nwlog_obj();
    *string = 136446210;
    *&string[4] = "nw_resolver_config_create_tls";
    v14 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    out[0] = 0;
    if (!__nwlog_fault(v14, type, out))
    {
      goto LABEL_40;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *string = 136446210;
        *&string[4] = "nw_resolver_config_create_tls";
        _os_log_impl(&dword_181A37000, v15, v16, "%{public}s called with null server_endpoint", string, 0xCu);
      }
    }

    else if (out[0] == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v20 = type[0];
      v21 = os_log_type_enabled(v15, type[0]);
      if (backtrace_string)
      {
        if (v21)
        {
          *string = 136446466;
          *&string[4] = "nw_resolver_config_create_tls";
          *&string[12] = 2082;
          *&string[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v15, v20, "%{public}s called with null server_endpoint, dumping backtrace:%{public}s", string, 0x16u);
        }

        free(backtrace_string);
        if (!v14)
        {
          goto LABEL_42;
        }

        goto LABEL_41;
      }

      if (v21)
      {
        *string = 136446210;
        *&string[4] = "nw_resolver_config_create_tls";
        _os_log_impl(&dword_181A37000, v15, v20, "%{public}s called with null server_endpoint, no backtrace", string, 0xCu);
      }
    }

    else
    {
      v15 = __nwlog_obj();
      v25 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *string = 136446210;
        *&string[4] = "nw_resolver_config_create_tls";
        _os_log_impl(&dword_181A37000, v15, v25, "%{public}s called with null server_endpoint, backtrace limit exceeded", string, 0xCu);
      }
    }

    goto LABEL_39;
  }

  v3 = v1;
  v4 = _nw_endpoint_get_type(v3);

  if ((v4 - 3) < 0xFFFFFFFE)
  {
    v17 = __nwlog_obj();
    *string = 136446210;
    *&string[4] = "nw_resolver_config_create_tls";
    v14 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    out[0] = 0;
    if (!__nwlog_fault(v14, type, out))
    {
      goto LABEL_40;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v18 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *string = 136446210;
        *&string[4] = "nw_resolver_config_create_tls";
        _os_log_impl(&dword_181A37000, v15, v18, "%{public}s called with null (type == nw_endpoint_type_host || type == nw_endpoint_type_address)", string, 0xCu);
      }
    }

    else if (out[0] == 1)
    {
      v22 = __nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v23 = type[0];
      v24 = os_log_type_enabled(v15, type[0]);
      if (v22)
      {
        if (v24)
        {
          *string = 136446466;
          *&string[4] = "nw_resolver_config_create_tls";
          *&string[12] = 2082;
          *&string[14] = v22;
          _os_log_impl(&dword_181A37000, v15, v23, "%{public}s called with null (type == nw_endpoint_type_host || type == nw_endpoint_type_address), dumping backtrace:%{public}s", string, 0x16u);
        }

        free(v22);
LABEL_40:
        if (!v14)
        {
LABEL_42:
          v9 = 0;
          goto LABEL_6;
        }

LABEL_41:
        free(v14);
        goto LABEL_42;
      }

      if (v24)
      {
        *string = 136446210;
        *&string[4] = "nw_resolver_config_create_tls";
        _os_log_impl(&dword_181A37000, v15, v23, "%{public}s called with null (type == nw_endpoint_type_host || type == nw_endpoint_type_address), no backtrace", string, 0xCu);
      }
    }

    else
    {
      v15 = __nwlog_obj();
      v26 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *string = 136446210;
        *&string[4] = "nw_resolver_config_create_tls";
        _os_log_impl(&dword_181A37000, v15, v26, "%{public}s called with null (type == nw_endpoint_type_host || type == nw_endpoint_type_address), backtrace limit exceeded", string, 0xCu);
      }
    }

LABEL_39:

    goto LABEL_40;
  }

  v5 = xpc_dictionary_create(0, 0, 0);
  *string = v5;
  string[8] = -1;
  v6 = nw_resolver_config_create_with_dictionary(v5);
  if (v5)
  {
  }

  *type = v6;
  v28 = -1;
  memset(out, 0, sizeof(out));
  uuid_generate_random(out);
  nw_resolver_config_set_identifier(v6, out);
  memset(string, 0, sizeof(string));
  uuid_unparse(out, string);
  m_obj = v6->dictionary.m_obj;
  v8 = v6;
  xpc_dictionary_set_string(m_obj, "Identifier", string);

  nw_resolver_config_set_class(v8, 3);
  nw_resolver_config_set_protocol(v8, 1);
  v9 = v8;
  v10 = v3;
  hostname = _nw_endpoint_get_hostname(v10);

  nw_resolver_config_set_provider_name(v9, hostname);
LABEL_6:

  return v9;
}

void sub_182864A84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);

  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va);
  _Unwind_Resume(a1);
}

id nw_resolver_config_copy_dictionary(void *a1)
{
  v28 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x4012000000;
    v23 = __Block_byref_object_copy__15;
    v24 = __Block_byref_object_dispose__16;
    v25 = 256;
    v26 = 0;
    v27 = -1;
    v17[0] = MEMORY[0x1E69E9820];
    v17[1] = 3221225472;
    v17[2] = __nw_resolver_config_copy_dictionary_block_invoke;
    v17[3] = &unk_1E6A3D738;
    v19 = buf;
    v3 = v1;
    v18 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_copy_dictionary_block_invoke(v17);
    os_unfair_lock_unlock(v3 + 22);
    v4 = *&buf[8];
    v5 = *(*&buf[8] + 48);
    v6 = *(v4 + 48);
    *(v4 + 48) = 0;

    _Block_object_dispose(buf, 8);
    v7 = v26;
    if ((v27 & 1) != 0 && v26)
    {
      v26 = 0;

      v7 = v26;
    }

    v26 = 0;

    goto LABEL_6;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_resolver_config_copy_dictionary";
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v10, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_copy_dictionary";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_copy_dictionary";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v15)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_copy_dictionary";
        _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_copy_dictionary";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v10)
  {
    free(v10);
  }

  v5 = 0;
LABEL_6:

  return v5;
}

void sub_182864EAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(v14 + 48);

  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__15(uint64_t a1, uint64_t a2)
{
  *(a1 + 48) = *(a2 + 48);
  *(a1 + 56) = *(a1 + 56) & 0xFE | *(a2 + 56) & 1;
  v4 = *(a2 + 48);
  *(a2 + 48) = 0;

  *(a2 + 56) &= ~1u;
}

void __Block_byref_object_dispose__16(uint64_t a1)
{
  v2 = *(a1 + 48);
  if ((*(a1 + 56) & 1) != 0 && v2)
  {
    *(a1 + 48) = 0;

    v2 = *(a1 + 48);
  }

  *(a1 + 48) = 0;

  v3 = *(a1 + 48);
}

void __nw_resolver_config_copy_dictionary_block_invoke(uint64_t a1)
{
  v2 = *(*(a1 + 32) + 8);
  v3 = *(*(a1 + 40) + 8);
  v4 = *(v3 + 48);
  if ((*(v3 + 56) & 1) != 0 && v4)
  {
    *(v3 + 48) = 0;

    v4 = *(v3 + 48);
  }

  *(v3 + 48) = 0;

  v5 = *(v3 + 48);
  *(v3 + 48) = v2;
  v6 = v2;

  *(v3 + 56) |= 1u;
}

CFDataRef nw_resolver_config_copy_plist_data_ref(void *a1)
{
  v38 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *v32 = 0;
    *&v32[8] = v32;
    *&v32[16] = 0x4012000000;
    v33 = __Block_byref_object_copy__18;
    v34 = __Block_byref_object_dispose__19;
    v35 = &unk_182E7191A;
    v36 = 0;
    v37 = -1;
    v24[0] = MEMORY[0x1E69E9820];
    v24[1] = 3221225472;
    v24[2] = __nw_resolver_config_copy_plist_data_ref_block_invoke;
    v24[3] = &unk_1E6A3D738;
    v26 = v32;
    v3 = v1;
    v25 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_copy_plist_data_ref_block_invoke(v24);
    os_unfair_lock_unlock(v3 + 22);
    v4 = *(*&v32[8] + 48);
    if (v4)
    {
      Data = CFPropertyListCreateData(*MEMORY[0x1E695E480], v4, kCFPropertyListBinaryFormat_v1_0, 0, 0);
LABEL_12:

      _Block_object_dispose(v32, 8);
      if ((v37 & 1) != 0 && v36)
      {
        CFRelease(v36);
      }

      goto LABEL_15;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    *buf = 136446210;
    v29 = "nw_resolver_config_copy_plist_data_ref";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v7, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *buf = 136446210;
          v29 = "nw_resolver_config_copy_plist_data_ref";
          _os_log_impl(&dword_181A37000, v8, v9, "%{public}s _CFXPCCreateCFObjectFromXPCObject failed", buf, 0xCu);
        }
      }

      else if (v23 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v12 = type;
        v13 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *buf = 136446466;
            v29 = "nw_resolver_config_copy_plist_data_ref";
            v30 = 2082;
            v31 = backtrace_string;
            _os_log_impl(&dword_181A37000, v8, v12, "%{public}s _CFXPCCreateCFObjectFromXPCObject failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v7)
          {
            goto LABEL_11;
          }

          goto LABEL_10;
        }

        if (v13)
        {
          *buf = 136446210;
          v29 = "nw_resolver_config_copy_plist_data_ref";
          _os_log_impl(&dword_181A37000, v8, v12, "%{public}s _CFXPCCreateCFObjectFromXPCObject failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v14 = type;
        if (os_log_type_enabled(v8, type))
        {
          *buf = 136446210;
          v29 = "nw_resolver_config_copy_plist_data_ref";
          _os_log_impl(&dword_181A37000, v8, v14, "%{public}s _CFXPCCreateCFObjectFromXPCObject failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v7)
    {
LABEL_11:
      Data = 0;
      goto LABEL_12;
    }

LABEL_10:
    free(v7);
    goto LABEL_11;
  }

  v15 = __nwlog_obj();
  *v32 = 136446210;
  *&v32[4] = "nw_resolver_config_copy_plist_data_ref";
  v16 = _os_log_send_and_compose_impl();

  buf[0] = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v16, buf, &type))
  {
    if (buf[0] == 17)
    {
      v17 = __nwlog_obj();
      v18 = buf[0];
      if (os_log_type_enabled(v17, buf[0]))
      {
        *v32 = 136446210;
        *&v32[4] = "nw_resolver_config_copy_plist_data_ref";
        _os_log_impl(&dword_181A37000, v17, v18, "%{public}s called with null config", v32, 0xCu);
      }
    }

    else if (type == OS_LOG_TYPE_INFO)
    {
      v19 = __nw_create_backtrace_string();
      v17 = __nwlog_obj();
      v20 = buf[0];
      v21 = os_log_type_enabled(v17, buf[0]);
      if (v19)
      {
        if (v21)
        {
          *v32 = 136446466;
          *&v32[4] = "nw_resolver_config_copy_plist_data_ref";
          *&v32[12] = 2082;
          *&v32[14] = v19;
          _os_log_impl(&dword_181A37000, v17, v20, "%{public}s called with null config, dumping backtrace:%{public}s", v32, 0x16u);
        }

        free(v19);
        goto LABEL_44;
      }

      if (v21)
      {
        *v32 = 136446210;
        *&v32[4] = "nw_resolver_config_copy_plist_data_ref";
        _os_log_impl(&dword_181A37000, v17, v20, "%{public}s called with null config, no backtrace", v32, 0xCu);
      }
    }

    else
    {
      v17 = __nwlog_obj();
      v22 = buf[0];
      if (os_log_type_enabled(v17, buf[0]))
      {
        *v32 = 136446210;
        *&v32[4] = "nw_resolver_config_copy_plist_data_ref";
        _os_log_impl(&dword_181A37000, v17, v22, "%{public}s called with null config, backtrace limit exceeded", v32, 0xCu);
      }
    }
  }

LABEL_44:
  if (v16)
  {
    free(v16);
  }

  Data = 0;
LABEL_15:

  return Data;
}

void sub_182865664(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32)
{
  _Block_object_dispose(&a25, 8);
  if (a32)
  {
    v35 = *(v33 + 48);
    if (v35)
    {
      CFRelease(v35);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__18(uint64_t result, uint64_t a2)
{
  *(result + 48) = *(a2 + 48);
  *(result + 56) = *(result + 56) & 0xFE | *(a2 + 56) & 1;
  *(a2 + 48) = 0;
  *(a2 + 56) &= ~1u;
  return result;
}

uint64_t __Block_byref_object_dispose__19(uint64_t result)
{
  if ((*(result + 56) & 1) != 0 && *(result + 48))
  {
    v1 = result;
    CFRelease(*(result + 48));
    result = v1;
  }

  *(result + 48) = 0;
  return result;
}

void __nw_resolver_config_copy_plist_data_ref_block_invoke(uint64_t a1)
{
  v6 = *(*(a1 + 32) + 8);
  v2 = _CFXPCCreateCFObjectFromXPCObject();
  v3 = *(*(a1 + 40) + 8);
  v4 = *(v3 + 56);
  if (v4)
  {
    v5 = *(v3 + 48);
    if (v5)
    {
      CFRelease(v5);
      v4 = *(v3 + 56);
    }
  }

  *(v3 + 48) = v2;
  *(v3 + 56) = v4 | 1;
}

dispatch_data_t nw_resolver_config_copy_plist_data(void *a1)
{
  v25 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x4012000000;
    v20 = __Block_byref_object_copy__21_56472;
    v21 = __Block_byref_object_dispose__22_56473;
    v22 = &unk_182E7191A;
    cf = nw_resolver_config_copy_plist_data_ref(v1);
    v24 |= 1u;
    v3 = *(*&buf[8] + 48);
    if (v3)
    {
      BytePtr = CFDataGetBytePtr(v3);
      Length = CFDataGetLength(*(*&buf[8] + 48));
      destructor[0] = MEMORY[0x1E69E9820];
      destructor[1] = 3221225472;
      destructor[2] = __nw_resolver_config_copy_plist_data_block_invoke;
      destructor[3] = &unk_1E6A360D0;
      destructor[4] = buf;
      v6 = dispatch_data_create(BytePtr, Length, 0, destructor);
    }

    else
    {
      v6 = 0;
    }

    _Block_object_dispose(buf, 8);
    if ((v24 & 1) != 0 && cf)
    {
      CFRelease(cf);
    }

    goto LABEL_8;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_resolver_config_copy_plist_data";
  v9 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v9, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_copy_plist_data";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_copy_plist_data";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (v14)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_copy_plist_data";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_copy_plist_data";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_25:
  if (v9)
  {
    free(v9);
  }

  v6 = 0;
LABEL_8:

  return v6;
}

uint64_t __Block_byref_object_copy__21_56472(uint64_t result, uint64_t a2)
{
  *(result + 48) = *(a2 + 48);
  *(result + 56) = *(result + 56) & 0xFE | *(a2 + 56) & 1;
  *(a2 + 48) = 0;
  *(a2 + 56) &= ~1u;
  return result;
}

uint64_t __Block_byref_object_dispose__22_56473(uint64_t result)
{
  if ((*(result + 56) & 1) != 0 && *(result + 48))
  {
    v1 = result;
    CFRelease(*(result + 48));
    result = v1;
  }

  *(result + 48) = 0;
  return result;
}

void __nw_resolver_config_copy_plist_data_block_invoke(uint64_t a1)
{
  v1 = *(*(a1 + 32) + 8);
  v2 = *(v1 + 56);
  if (v2)
  {
    v3 = *(v1 + 48);
    if (v3)
    {
      CFRelease(v3);
      v2 = *(v1 + 56);
    }
  }

  *(v1 + 48) = 0;
  *(v1 + 56) = v2 | 1;
}

void nw_resolver_config_add_name_server(void *a1, uint64_t a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_add_name_server_block_invoke;
    v14[3] = &unk_1E6A3AC58;
    v5 = v3;
    v15 = v5;
    v16 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_add_name_server_block_invoke(v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_resolver_config_add_name_server";
  v7 = _os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_add_name_server";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_resolver_config_add_name_server";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_add_name_server";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_add_name_server";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void __nw_resolver_config_add_name_server_block_invoke(uint64_t a1)
{
  v2 = xpc_dictionary_get_value(*(*(a1 + 32) + 8), "NameServers");
  if (v2)
  {
    v3 = 0;
  }

  else
  {
    v3 = xpc_array_create(0, 0);
    v2 = v3;
  }

  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, *(a1 + 40));
  xpc_dictionary_set_value(*(*(a1 + 32) + 8), "NameServers", v2);

  if (v3)
  {
  }
}

void sub_182866038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va);
  _Unwind_Resume(a1);
}

void nw_resolver_config_clear_name_servers(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_resolver_config_clear_name_servers_block_invoke;
    v12[3] = &unk_1E6A3D868;
    v3 = v1;
    v13 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_name_servers_block_invoke(v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_resolver_config_clear_name_servers";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_name_servers";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_resolver_config_clear_name_servers";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_name_servers";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_name_servers";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_resolver_config_add_search_domain(void *a1, uint64_t a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_add_search_domain_block_invoke;
    v14[3] = &unk_1E6A3AC58;
    v5 = v3;
    v15 = v5;
    v16 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_add_search_domain_block_invoke(v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_resolver_config_add_search_domain";
  v7 = _os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_add_search_domain";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_resolver_config_add_search_domain";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_add_search_domain";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_add_search_domain";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void __nw_resolver_config_add_search_domain_block_invoke(uint64_t a1)
{
  v2 = xpc_dictionary_get_value(*(*(a1 + 32) + 8), "SearchDomains");
  if (v2)
  {
    v3 = 0;
  }

  else
  {
    v3 = xpc_array_create(0, 0);
    v2 = v3;
  }

  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, *(a1 + 40));
  xpc_dictionary_set_value(*(*(a1 + 32) + 8), "SearchDomains", v2);

  if (v3)
  {
  }
}

void sub_18286678C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va);
  _Unwind_Resume(a1);
}

void nw_resolver_config_clear_search_domains(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_resolver_config_clear_search_domains_block_invoke;
    v12[3] = &unk_1E6A3D868;
    v3 = v1;
    v13 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_search_domains_block_invoke(v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_resolver_config_clear_search_domains";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_search_domains";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_resolver_config_clear_search_domains";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_search_domains";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_search_domains";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_resolver_config_add_match_domain(void *a1, uint64_t a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_add_match_domain_block_invoke;
    v14[3] = &unk_1E6A3AC58;
    v5 = v3;
    v15 = v5;
    v16 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_add_match_domain_block_invoke(v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_resolver_config_add_match_domain";
  v7 = _os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_add_match_domain";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_resolver_config_add_match_domain";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_add_match_domain";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_add_match_domain";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void __nw_resolver_config_add_match_domain_block_invoke(uint64_t a1)
{
  v2 = xpc_dictionary_get_value(*(*(a1 + 32) + 8), "MatchDomains");
  if (v2)
  {
    v3 = 0;
  }

  else
  {
    v3 = xpc_array_create(0, 0);
    v2 = v3;
  }

  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, *(a1 + 40));
  xpc_dictionary_set_value(*(*(a1 + 32) + 8), "MatchDomains", v2);

  if (v3)
  {
  }
}

void sub_182866EE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va);
  _Unwind_Resume(a1);
}

void nw_resolver_config_clear_match_domains(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_resolver_config_clear_match_domains_block_invoke;
    v12[3] = &unk_1E6A3D868;
    v3 = v1;
    v13 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_match_domains_block_invoke(v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_resolver_config_clear_match_domains";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_match_domains";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_resolver_config_clear_match_domains";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_match_domains";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_match_domains";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_resolver_config_enumerate_match_domains(void *a1, void *a2)
{
  v26 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x3032000000;
    v23 = __Block_byref_object_copy__25_56289;
    v24 = __Block_byref_object_dispose__26_56290;
    v25 = 0;
    v17[0] = MEMORY[0x1E69E9820];
    v17[1] = 3221225472;
    v17[2] = __nw_resolver_config_enumerate_match_domains_block_invoke;
    v17[3] = &unk_1E6A3D738;
    v19 = buf;
    v5 = v3;
    v18 = v5;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_enumerate_match_domains_block_invoke(v17);
    os_unfair_lock_unlock(v5 + 22);
    v6 = *(*&buf[8] + 40);
    if (v6)
    {
      applier[0] = MEMORY[0x1E69E9820];
      applier[1] = 3221225472;
      applier[2] = __nw_resolver_config_enumerate_match_domains_block_invoke_2;
      applier[3] = &unk_1E6A35AD0;
      v16 = v4;
      xpc_array_apply(v6, applier);
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_resolver_config_enumerate_match_domains";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v8, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_enumerate_match_domains";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_enumerate_match_domains";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v13)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_enumerate_match_domains";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_enumerate_match_domains";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v8)
  {
    free(v8);
  }

LABEL_5:
}

void sub_182867614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, id a30)
{
  _Block_object_dispose(&a25, 8);

  _Unwind_Resume(a1);
}

void __nw_resolver_config_enumerate_match_domains_block_invoke(uint64_t a1)
{
  v5 = *(*(a1 + 32) + 8);
  v2 = xpc_dictionary_get_value(v5, "MatchDomains");
  v3 = *(*(a1 + 40) + 8);
  v4 = *(v3 + 40);
  *(v3 + 40) = v2;
}

uint64_t __nw_resolver_config_enumerate_match_domains_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  if (object_getClass(v4) == MEMORY[0x1E69E9F10])
  {
    v6 = *(a1 + 32);
    string_ptr = xpc_string_get_string_ptr(v4);
    v5 = (*(v6 + 16))(v6, string_ptr);
  }

  else
  {
    v5 = 1;
  }

  return v5;
}

void nw_resolver_config_add_server_raw_public_key(void *a1, uint64_t a2, uint64_t a3)
{
  v26 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = v5;
  if (v5)
  {
    v16[0] = MEMORY[0x1E69E9820];
    v16[1] = 3221225472;
    v16[2] = __nw_resolver_config_add_server_raw_public_key_block_invoke;
    v16[3] = &unk_1E6A3BAD8;
    v7 = v5;
    v17 = v7;
    v18 = a2;
    v19 = a3;
    os_unfair_lock_lock(v7 + 22);
    __nw_resolver_config_add_server_raw_public_key_block_invoke(v16);
    os_unfair_lock_unlock(v7 + 22);

    goto LABEL_3;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  v23 = "nw_resolver_config_add_server_raw_public_key";
  v9 = _os_log_send_and_compose_impl();

  v21 = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v9, &v21, &v20))
  {
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = v21;
      if (os_log_type_enabled(v10, v21))
      {
        *buf = 136446210;
        v23 = "nw_resolver_config_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v13 = v21;
      v14 = os_log_type_enabled(v10, v21);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v23 = "nw_resolver_config_add_server_raw_public_key";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *buf = 136446210;
        v23 = "nw_resolver_config_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v15 = v21;
      if (os_log_type_enabled(v10, v21))
      {
        *buf = 136446210;
        v23 = "nw_resolver_config_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v9)
  {
    free(v9);
  }

LABEL_3:
}

void __nw_resolver_config_add_server_raw_public_key_block_invoke(uint64_t a1)
{
  v2 = xpc_dictionary_get_value(*(*(a1 + 32) + 8), "ServerRawPublicKey");
  if (v2)
  {
    v3 = 0;
  }

  else
  {
    v3 = xpc_array_create(0, 0);
    v2 = v3;
  }

  xpc_array_set_data(v2, 0xFFFFFFFFFFFFFFFFLL, *(a1 + 40), *(a1 + 48));
  xpc_dictionary_set_value(*(*(a1 + 32) + 8), "ServerRawPublicKey", v2);

  if (v3)
  {
  }
}

void sub_182867B60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va);
  _Unwind_Resume(a1);
}

void nw_resolver_config_clear_server_raw_public_keys(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_resolver_config_clear_server_raw_public_keys_block_invoke;
    v12[3] = &unk_1E6A3D868;
    v3 = v1;
    v13 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_server_raw_public_keys_block_invoke(v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_resolver_config_clear_server_raw_public_keys";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_server_raw_public_keys";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_resolver_config_clear_server_raw_public_keys";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_server_raw_public_keys";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_server_raw_public_keys";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_resolver_config_enumerate_server_raw_public_keys(void *a1, void *a2)
{
  v26 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x3032000000;
    v23 = __Block_byref_object_copy__25_56289;
    v24 = __Block_byref_object_dispose__26_56290;
    v25 = 0;
    v17[0] = MEMORY[0x1E69E9820];
    v17[1] = 3221225472;
    v17[2] = __nw_resolver_config_enumerate_server_raw_public_keys_block_invoke;
    v17[3] = &unk_1E6A3D738;
    v19 = buf;
    v5 = v3;
    v18 = v5;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_enumerate_server_raw_public_keys_block_invoke(v17);
    os_unfair_lock_unlock(v5 + 22);
    v6 = *(*&buf[8] + 40);
    if (v6)
    {
      applier[0] = MEMORY[0x1E69E9820];
      applier[1] = 3221225472;
      applier[2] = __nw_resolver_config_enumerate_server_raw_public_keys_block_invoke_2;
      applier[3] = &unk_1E6A35AD0;
      v16 = v4;
      xpc_array_apply(v6, applier);
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_resolver_config_enumerate_server_raw_public_keys";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v8, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_enumerate_server_raw_public_keys";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_enumerate_server_raw_public_keys";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v13)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_enumerate_server_raw_public_keys";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_enumerate_server_raw_public_keys";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v8)
  {
    free(v8);
  }

LABEL_5:
}

void sub_182868294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, id a30)
{
  _Block_object_dispose(&a25, 8);

  _Unwind_Resume(a1);
}

void __nw_resolver_config_enumerate_server_raw_public_keys_block_invoke(uint64_t a1)
{
  v5 = *(*(a1 + 32) + 8);
  v2 = xpc_dictionary_get_value(v5, "ServerRawPublicKey");
  v3 = *(*(a1 + 40) + 8);
  v4 = *(v3 + 40);
  *(v3 + 40) = v2;
}

uint64_t __nw_resolver_config_enumerate_server_raw_public_keys_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  if (object_getClass(v4) == MEMORY[0x1E69E9E70])
  {
    v6 = *(a1 + 32);
    bytes_ptr = xpc_data_get_bytes_ptr(v4);
    length = xpc_data_get_length(v4);
    v5 = (*(v6 + 16))(v6, bytes_ptr, length);
  }

  else
  {
    v5 = 1;
  }

  return v5;
}

void nw_resolver_config_add_client_raw_public_key(void *a1, uint64_t a2, uint64_t a3)
{
  v26 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = v5;
  if (v5)
  {
    v16[0] = MEMORY[0x1E69E9820];
    v16[1] = 3221225472;
    v16[2] = __nw_resolver_config_add_client_raw_public_key_block_invoke;
    v16[3] = &unk_1E6A3BAD8;
    v7 = v5;
    v17 = v7;
    v18 = a2;
    v19 = a3;
    os_unfair_lock_lock(v7 + 22);
    __nw_resolver_config_add_client_raw_public_key_block_invoke(v16);
    os_unfair_lock_unlock(v7 + 22);

    goto LABEL_3;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  v23 = "nw_resolver_config_add_client_raw_public_key";
  v9 = _os_log_send_and_compose_impl();

  v21 = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v9, &v21, &v20))
  {
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = v21;
      if (os_log_type_enabled(v10, v21))
      {
        *buf = 136446210;
        v23 = "nw_resolver_config_add_client_raw_public_key";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v13 = v21;
      v14 = os_log_type_enabled(v10, v21);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v23 = "nw_resolver_config_add_client_raw_public_key";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *buf = 136446210;
        v23 = "nw_resolver_config_add_client_raw_public_key";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v15 = v21;
      if (os_log_type_enabled(v10, v21))
      {
        *buf = 136446210;
        v23 = "nw_resolver_config_add_client_raw_public_key";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v9)
  {
    free(v9);
  }

LABEL_3:
}

void __nw_resolver_config_add_client_raw_public_key_block_invoke(uint64_t a1)
{
  v2 = xpc_dictionary_get_value(*(*(a1 + 32) + 8), "ClientRawPublicKey");
  if (v2)
  {
    v3 = 0;
  }

  else
  {
    v3 = xpc_array_create(0, 0);
    v2 = v3;
  }

  xpc_array_set_data(v2, 0xFFFFFFFFFFFFFFFFLL, *(a1 + 40), *(a1 + 48));
  xpc_dictionary_set_value(*(*(a1 + 32) + 8), "ClientRawPublicKey", v2);

  if (v3)
  {
  }
}

void sub_1828687F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va);
  _Unwind_Resume(a1);
}

void nw_resolver_config_clear_client_raw_public_keys(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_resolver_config_clear_client_raw_public_keys_block_invoke;
    v12[3] = &unk_1E6A3D868;
    v3 = v1;
    v13 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_client_raw_public_keys_block_invoke(v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_resolver_config_clear_client_raw_public_keys";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_client_raw_public_keys";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_resolver_config_clear_client_raw_public_keys";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_client_raw_public_keys";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_client_raw_public_keys";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_resolver_config_enumerate_client_raw_public_keys(void *a1, void *a2)
{
  v26 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x3032000000;
    v23 = __Block_byref_object_copy__25_56289;
    v24 = __Block_byref_object_dispose__26_56290;
    v25 = 0;
    v17[0] = MEMORY[0x1E69E9820];
    v17[1] = 3221225472;
    v17[2] = __nw_resolver_config_enumerate_client_raw_public_keys_block_invoke;
    v17[3] = &unk_1E6A3D738;
    v19 = buf;
    v5 = v3;
    v18 = v5;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_enumerate_client_raw_public_keys_block_invoke(v17);
    os_unfair_lock_unlock(v5 + 22);
    v6 = *(*&buf[8] + 40);
    if (v6)
    {
      applier[0] = MEMORY[0x1E69E9820];
      applier[1] = 3221225472;
      applier[2] = __nw_resolver_config_enumerate_client_raw_public_keys_block_invoke_2;
      applier[3] = &unk_1E6A35AD0;
      v16 = v4;
      xpc_array_apply(v6, applier);
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_resolver_config_enumerate_client_raw_public_keys";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v8, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_enumerate_client_raw_public_keys";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_enumerate_client_raw_public_keys";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v13)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_enumerate_client_raw_public_keys";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_enumerate_client_raw_public_keys";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v8)
  {
    free(v8);
  }

LABEL_5:
}

void sub_182868F2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, id a30)
{
  _Block_object_dispose(&a25, 8);

  _Unwind_Resume(a1);
}

void __nw_resolver_config_enumerate_client_raw_public_keys_block_invoke(uint64_t a1)
{
  v5 = *(*(a1 + 32) + 8);
  v2 = xpc_dictionary_get_value(v5, "ClientRawPublicKey");
  v3 = *(*(a1 + 40) + 8);
  v4 = *(v3 + 40);
  *(v3 + 40) = v2;
}

uint64_t __nw_resolver_config_enumerate_client_raw_public_keys_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  if (object_getClass(v4) == MEMORY[0x1E69E9E70])
  {
    v6 = *(a1 + 32);
    bytes_ptr = xpc_data_get_bytes_ptr(v4);
    length = xpc_data_get_length(v4);
    v5 = (*(v6 + 16))(v6, bytes_ptr, length);
  }

  else
  {
    v5 = 1;
  }

  return v5;
}

void nw_resolver_config_set_interface_name(void *a1, uint64_t a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_set_interface_name_block_invoke;
    v14[3] = &unk_1E6A3AC58;
    v5 = v3;
    v15 = v5;
    v16 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_interface_name_block_invoke(v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_resolver_config_set_interface_name";
  v7 = _os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_interface_name";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_resolver_config_set_interface_name";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_interface_name";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_interface_name";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void nw_resolver_config_clear_interface_name(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_resolver_config_clear_interface_name_block_invoke;
    v12[3] = &unk_1E6A3D868;
    v3 = v1;
    v13 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_interface_name_block_invoke(v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_resolver_config_clear_interface_name";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_interface_name";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_resolver_config_clear_interface_name";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_interface_name";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_interface_name";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

uint64_t nw_resolver_config_get_interface_name(void *a1)
{
  v21 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v20 = 0;
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_get_interface_name_block_invoke;
    v14[3] = &unk_1E6A3D738;
    v16 = buf;
    v3 = v1;
    v15 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_get_interface_name_block_invoke(v14);
    os_unfair_lock_unlock(v3 + 22);
    v4 = *(*&buf[8] + 24);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_resolver_config_get_interface_name";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_get_interface_name";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_get_interface_name";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_get_interface_name";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_get_interface_name";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

  v4 = 0;
LABEL_3:

  return v4;
}

void sub_182869A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_get_interface_name_block_invoke(uint64_t a1)
{
  v2 = *(*(a1 + 32) + 8);
  *(*(*(a1 + 40) + 8) + 24) = xpc_dictionary_get_string(v2, "InterfaceName");
}

void nw_resolver_config_clear_provider_description(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_resolver_config_clear_provider_description_block_invoke;
    v12[3] = &unk_1E6A3D868;
    v3 = v1;
    v13 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_provider_description_block_invoke(v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_resolver_config_clear_provider_description";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_provider_description";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_resolver_config_clear_provider_description";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_provider_description";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_provider_description";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

uint64_t nw_resolver_config_get_provider_description(void *a1)
{
  v21 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v20 = 0;
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_get_provider_description_block_invoke;
    v14[3] = &unk_1E6A3D738;
    v16 = buf;
    v3 = v1;
    v15 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_get_provider_description_block_invoke(v14);
    os_unfair_lock_unlock(v3 + 22);
    v4 = *(*&buf[8] + 24);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_resolver_config_get_provider_description";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_get_provider_description";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_get_provider_description";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_get_provider_description";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_get_provider_description";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

  v4 = 0;
LABEL_3:

  return v4;
}

void sub_18286A14C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_get_provider_description_block_invoke(uint64_t a1)
{
  v2 = *(*(a1 + 32) + 8);
  *(*(*(a1 + 40) + 8) + 24) = xpc_dictionary_get_string(v2, "ProviderDescription");
}

void nw_resolver_config_clear_provider_name(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_resolver_config_clear_provider_name_block_invoke;
    v12[3] = &unk_1E6A3D868;
    v3 = v1;
    v13 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_provider_name_block_invoke(v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_resolver_config_clear_provider_name";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_provider_name";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_resolver_config_clear_provider_name";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_provider_name";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_provider_name";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_resolver_config_clear_provider_path(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_resolver_config_clear_provider_path_block_invoke;
    v12[3] = &unk_1E6A3D868;
    v3 = v1;
    v13 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_provider_path_block_invoke(v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_resolver_config_clear_provider_path";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_provider_path";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_resolver_config_clear_provider_path";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_provider_path";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_provider_path";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_resolver_config_set_proxy_agent(void *a1, uint64_t a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_set_proxy_agent_block_invoke;
    v14[3] = &unk_1E6A3AC58;
    v5 = v3;
    v15 = v5;
    v16 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_proxy_agent_block_invoke(v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_resolver_config_set_proxy_agent";
  v7 = _os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_proxy_agent";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_resolver_config_set_proxy_agent";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_proxy_agent";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_proxy_agent";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void nw_resolver_config_clear_proxy_agent(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_resolver_config_clear_proxy_agent_block_invoke;
    v12[3] = &unk_1E6A3D868;
    v3 = v1;
    v13 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_proxy_agent_block_invoke(v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_resolver_config_clear_proxy_agent";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_proxy_agent";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_resolver_config_clear_proxy_agent";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_proxy_agent";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_proxy_agent";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void nw_resolver_config_set_identity_reference(void *a1, uint64_t a2, uint64_t a3)
{
  v26 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = v5;
  if (v5)
  {
    v16[0] = MEMORY[0x1E69E9820];
    v16[1] = 3221225472;
    v16[2] = __nw_resolver_config_set_identity_reference_block_invoke;
    v16[3] = &unk_1E6A3BAD8;
    v7 = v5;
    v17 = v7;
    v18 = a2;
    v19 = a3;
    os_unfair_lock_lock(v7 + 22);
    __nw_resolver_config_set_identity_reference_block_invoke(v16);
    os_unfair_lock_unlock(v7 + 22);

    goto LABEL_3;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  v23 = "nw_resolver_config_set_identity_reference";
  v9 = _os_log_send_and_compose_impl();

  v21 = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v9, &v21, &v20))
  {
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = v21;
      if (os_log_type_enabled(v10, v21))
      {
        *buf = 136446210;
        v23 = "nw_resolver_config_set_identity_reference";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v13 = v21;
      v14 = os_log_type_enabled(v10, v21);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v23 = "nw_resolver_config_set_identity_reference";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *buf = 136446210;
        v23 = "nw_resolver_config_set_identity_reference";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v15 = v21;
      if (os_log_type_enabled(v10, v21))
      {
        *buf = 136446210;
        v23 = "nw_resolver_config_set_identity_reference";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v9)
  {
    free(v9);
  }

LABEL_3:
}

void nw_resolver_config_clear_identity_reference(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_resolver_config_clear_identity_reference_block_invoke;
    v12[3] = &unk_1E6A3D868;
    v3 = v1;
    v13 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_identity_reference_block_invoke(v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_resolver_config_clear_identity_reference";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_identity_reference";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_resolver_config_clear_identity_reference";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_identity_reference";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_identity_reference";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

uint64_t nw_resolver_config_get_identity_reference(void *a1, uint64_t a2)
{
  v24 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v23 = 0;
    v16[0] = MEMORY[0x1E69E9820];
    v16[1] = 3221225472;
    v16[2] = __nw_resolver_config_get_identity_reference_block_invoke;
    v16[3] = &unk_1E6A3D8B8;
    v18 = buf;
    v5 = v3;
    v17 = v5;
    v19 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_get_identity_reference_block_invoke(v16);
    os_unfair_lock_unlock(v5 + 22);
    v6 = *(*&buf[8] + 24);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_resolver_config_get_identity_reference";
  v9 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v9, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_get_identity_reference";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_get_identity_reference";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_get_identity_reference";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_get_identity_reference";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v9)
  {
    free(v9);
  }

  v6 = 0;
LABEL_3:

  return v6;
}

void sub_18286B890(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_get_identity_reference_block_invoke(uint64_t a1)
{
  v2 = *(*(a1 + 32) + 8);
  *(*(*(a1 + 40) + 8) + 24) = xpc_dictionary_get_data(v2, "IdentityReference", *(a1 + 48));
}

void nw_resolver_config_set_odoh_config(void *a1, uint64_t a2, uint64_t a3)
{
  v26 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = v5;
  if (v5)
  {
    v16[0] = MEMORY[0x1E69E9820];
    v16[1] = 3221225472;
    v16[2] = __nw_resolver_config_set_odoh_config_block_invoke;
    v16[3] = &unk_1E6A3BAD8;
    v7 = v5;
    v17 = v7;
    v18 = a2;
    v19 = a3;
    os_unfair_lock_lock(v7 + 22);
    __nw_resolver_config_set_odoh_config_block_invoke(v16);
    os_unfair_lock_unlock(v7 + 22);

    goto LABEL_3;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  v23 = "nw_resolver_config_set_odoh_config";
  v9 = _os_log_send_and_compose_impl();

  v21 = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v9, &v21, &v20))
  {
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = v21;
      if (os_log_type_enabled(v10, v21))
      {
        *buf = 136446210;
        v23 = "nw_resolver_config_set_odoh_config";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v13 = v21;
      v14 = os_log_type_enabled(v10, v21);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v23 = "nw_resolver_config_set_odoh_config";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *buf = 136446210;
        v23 = "nw_resolver_config_set_odoh_config";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v15 = v21;
      if (os_log_type_enabled(v10, v21))
      {
        *buf = 136446210;
        v23 = "nw_resolver_config_set_odoh_config";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v9)
  {
    free(v9);
  }

LABEL_3:
}

void nw_resolver_config_clear_odoh_config(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = __nw_resolver_config_clear_odoh_config_block_invoke;
    v12[3] = &unk_1E6A3D868;
    v3 = v1;
    v13 = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_odoh_config_block_invoke(v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_resolver_config_clear_odoh_config";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_odoh_config";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_resolver_config_clear_odoh_config";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_odoh_config";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_resolver_config_clear_odoh_config";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

uint64_t nw_resolver_config_get_odoh_config(void *a1, uint64_t a2)
{
  v24 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v23 = 0;
    v16[0] = MEMORY[0x1E69E9820];
    v16[1] = 3221225472;
    v16[2] = __nw_resolver_config_get_odoh_config_block_invoke;
    v16[3] = &unk_1E6A3D8B8;
    v18 = buf;
    v5 = v3;
    v17 = v5;
    v19 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_get_odoh_config_block_invoke(v16);
    os_unfair_lock_unlock(v5 + 22);
    v6 = *(*&buf[8] + 24);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_resolver_config_get_odoh_config";
  v9 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v9, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_get_odoh_config";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_get_odoh_config";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_get_odoh_config";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_get_odoh_config";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v9)
  {
    free(v9);
  }

  v6 = 0;
LABEL_3:

  return v6;
}

void sub_18286C2F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_get_odoh_config_block_invoke(uint64_t a1)
{
  v2 = *(*(a1 + 32) + 8);
  *(*(*(a1 + 40) + 8) + 24) = xpc_dictionary_get_data(v2, "ODoHConfig", *(a1 + 48));
}

void nw_resolver_config_set_allow_failover(void *a1, char a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_set_allow_failover_block_invoke;
    v14[3] = &unk_1E6A3A258;
    v5 = v3;
    v15 = v5;
    v16 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_allow_failover_block_invoke(v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_resolver_config_set_allow_failover";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_allow_failover";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_resolver_config_set_allow_failover";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_allow_failover";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_allow_failover";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

id nw_resolver_config_copy_proxy_config(void *a1)
{
  v21 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v8 = __nwlog_obj();
    *uu = 136446210;
    *&uu[4] = "nw_resolver_config_copy_proxy_config";
    v9 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v9, type, &v19))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v10 = __nwlog_obj();
        v11 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *uu = 136446210;
          *&uu[4] = "nw_resolver_config_copy_proxy_config";
          _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null config", uu, 0xCu);
        }
      }

      else if (v19 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v10 = __nwlog_obj();
        v13 = type[0];
        v14 = os_log_type_enabled(v10, type[0]);
        if (backtrace_string)
        {
          if (v14)
          {
            *uu = 136446466;
            *&uu[4] = "nw_resolver_config_copy_proxy_config";
            *&uu[12] = 2082;
            *&uu[14] = backtrace_string;
            _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, dumping backtrace:%{public}s", uu, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v14)
        {
          *uu = 136446210;
          *&uu[4] = "nw_resolver_config_copy_proxy_config";
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null config, no backtrace", uu, 0xCu);
        }
      }

      else
      {
        v10 = __nwlog_obj();
        v15 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *uu = 136446210;
          *&uu[4] = "nw_resolver_config_copy_proxy_config";
          _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null config, backtrace limit exceeded", uu, 0xCu);
        }
      }
    }

LABEL_25:
    if (v9)
    {
      free(v9);
    }

    goto LABEL_27;
  }

  proxy_agent = nw_resolver_config_get_proxy_agent(v1);
  if (!proxy_agent)
  {
LABEL_27:
    v5 = 0;
    goto LABEL_28;
  }

  *uu = 0;
  *&uu[8] = 0;
  uuid_parse(proxy_agent, uu);
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
  {
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }

  v4 = nw_context_copy_implicit_context::implicit_context;
  *type = v4;
  v18 = -1;
  v5 = nw_path_copy_proxy_config_for_agent_uuid(uu, -1, v4);
  if (v4)
  {
  }

  if (v5)
  {
    v6 = v2[23];
    v7 = v5;
    v7[41] = v6;
  }

LABEL_28:

  return v5;
}

void sub_18286CA04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va);

  _Unwind_Resume(a1);
}

void nw_resolver_config_add_server_address(nw_resolver_config_t config, nw_endpoint_t server_address)
{
  v35 = *MEMORY[0x1E69E9840];
  v3 = config;
  v4 = server_address;
  v5 = v4;
  if (!v3)
  {
    v10 = __nwlog_obj();
    *buf = 136446210;
    v32 = "nw_resolver_config_add_server_address";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v11, &type, &v29))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v32 = "nw_resolver_config_add_server_address";
        _os_log_impl(&dword_181A37000, v12, v13, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v29 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v19 = type;
      v20 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *buf = 136446466;
          v32 = "nw_resolver_config_add_server_address";
          v33 = 2082;
          v34 = backtrace_string;
          _os_log_impl(&dword_181A37000, v12, v19, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v11)
        {
          goto LABEL_5;
        }

LABEL_56:
        free(v11);
        goto LABEL_5;
      }

      if (v20)
      {
        *buf = 136446210;
        v32 = "nw_resolver_config_add_server_address";
        _os_log_impl(&dword_181A37000, v12, v19, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v12 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v32 = "nw_resolver_config_add_server_address";
        _os_log_impl(&dword_181A37000, v12, v26, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_54:

    goto LABEL_55;
  }

  if (!v4)
  {
    v14 = __nwlog_obj();
    *buf = 136446210;
    v32 = "nw_resolver_config_add_server_address";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v11, &type, &v29))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v32 = "nw_resolver_config_add_server_address";
        _os_log_impl(&dword_181A37000, v12, v15, "%{public}s called with null server_address", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v29 != 1)
    {
      v12 = __nwlog_obj();
      v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v32 = "nw_resolver_config_add_server_address";
        _os_log_impl(&dword_181A37000, v12, v27, "%{public}s called with null server_address, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    v21 = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v22 = type;
    v23 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v23)
      {
        *buf = 136446210;
        v32 = "nw_resolver_config_add_server_address";
        _os_log_impl(&dword_181A37000, v12, v22, "%{public}s called with null server_address, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *buf = 136446466;
      v32 = "nw_resolver_config_add_server_address";
      v33 = 2082;
      v34 = v21;
      _os_log_impl(&dword_181A37000, v12, v22, "%{public}s called with null server_address, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_35;
  }

  v6 = v4;
  v7 = _nw_endpoint_get_type(v6);

  if (v7 != 1)
  {
    v16 = __nwlog_obj();
    *buf = 136446210;
    v32 = "nw_resolver_config_add_server_address";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v11, &type, &v29))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v32 = "nw_resolver_config_add_server_address";
        _os_log_impl(&dword_181A37000, v12, v17, "%{public}s called with null (nw_endpoint_get_type(server_address) == nw_endpoint_type_address)", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v29 != 1)
    {
      v12 = __nwlog_obj();
      v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v32 = "nw_resolver_config_add_server_address";
        _os_log_impl(&dword_181A37000, v12, v28, "%{public}s called with null (nw_endpoint_get_type(server_address) == nw_endpoint_type_address), backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    v21 = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v24 = type;
    v25 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v25)
      {
        *buf = 136446210;
        v32 = "nw_resolver_config_add_server_address";
        _os_log_impl(&dword_181A37000, v12, v24, "%{public}s called with null (nw_endpoint_get_type(server_address) == nw_endpoint_type_address), no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v25)
    {
      *buf = 136446466;
      v32 = "nw_resolver_config_add_server_address";
      v33 = 2082;
      v34 = v21;
      _os_log_impl(&dword_181A37000, v12, v24, "%{public}s called with null (nw_endpoint_get_type(server_address) == nw_endpoint_type_address), dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_35:

    free(v21);
    if (!v11)
    {
      goto LABEL_5;
    }

    goto LABEL_56;
  }

  v8 = v6;
  hostname = _nw_endpoint_get_hostname(v8);

  nw_resolver_config_add_name_server(v3, hostname);
LABEL_5:
}

void nw_resolver_config_set_port(void *a1, __int16 a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_set_port_block_invoke;
    v14[3] = &unk_1E6A35AF8;
    v5 = v3;
    v15 = v5;
    v16 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_port_block_invoke(v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_resolver_config_set_port";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_port";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_resolver_config_set_port";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_port";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v20 = "nw_resolver_config_set_port";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void nw_resolver_config_watch_updates(void *a1, void *a2, void *a3)
{
  v43 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = v7;
  if (!v5)
  {
    v12 = __nwlog_obj();
    *buf = 136446210;
    v40 = "nw_resolver_config_watch_updates";
    v13 = _os_log_send_and_compose_impl();

    v38 = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v13, &v38, &v37))
    {
      goto LABEL_57;
    }

    if (v38 == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = v38;
      if (os_log_type_enabled(v14, v38))
      {
        *buf = 136446210;
        v40 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v37 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v21 = v38;
      v22 = os_log_type_enabled(v14, v38);
      if (backtrace_string)
      {
        if (v22)
        {
          *buf = 136446466;
          v40 = "nw_resolver_config_watch_updates";
          v41 = 2082;
          v42 = backtrace_string;
          _os_log_impl(&dword_181A37000, v14, v21, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_57:
        if (!v13)
        {
          goto LABEL_7;
        }

LABEL_58:
        free(v13);
        goto LABEL_7;
      }

      if (v22)
      {
        *buf = 136446210;
        v40 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A37000, v14, v21, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v14 = __nwlog_obj();
      v28 = v38;
      if (os_log_type_enabled(v14, v38))
      {
        *buf = 136446210;
        v40 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A37000, v14, v28, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_56:

    goto LABEL_57;
  }

  if (!v6)
  {
    v16 = __nwlog_obj();
    *buf = 136446210;
    v40 = "nw_resolver_config_watch_updates";
    v13 = _os_log_send_and_compose_impl();

    v38 = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v13, &v38, &v37))
    {
      goto LABEL_57;
    }

    if (v38 == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v17 = v38;
      if (os_log_type_enabled(v14, v38))
      {
        *buf = 136446210;
        v40 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A37000, v14, v17, "%{public}s called with null queue", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v37 != 1)
    {
      v14 = __nwlog_obj();
      v29 = v38;
      if (os_log_type_enabled(v14, v38))
      {
        *buf = 136446210;
        v40 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A37000, v14, v29, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_56;
    }

    v23 = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v24 = v38;
    v25 = os_log_type_enabled(v14, v38);
    if (!v23)
    {
      if (v25)
      {
        *buf = 136446210;
        v40 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A37000, v14, v24, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v25)
    {
      *buf = 136446466;
      v40 = "nw_resolver_config_watch_updates";
      v41 = 2082;
      v42 = v23;
      _os_log_impl(&dword_181A37000, v14, v24, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_37;
  }

  if (!v7)
  {
    v18 = __nwlog_obj();
    *buf = 136446210;
    v40 = "nw_resolver_config_watch_updates";
    v13 = _os_log_send_and_compose_impl();

    v38 = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v13, &v38, &v37))
    {
      goto LABEL_57;
    }

    if (v38 == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v19 = v38;
      if (os_log_type_enabled(v14, v38))
      {
        *buf = 136446210;
        v40 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A37000, v14, v19, "%{public}s called with null update_handler", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v37 != 1)
    {
      v14 = __nwlog_obj();
      v30 = v38;
      if (os_log_type_enabled(v14, v38))
      {
        *buf = 136446210;
        v40 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A37000, v14, v30, "%{public}s called with null update_handler, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_56;
    }

    v23 = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v26 = v38;
    v27 = os_log_type_enabled(v14, v38);
    if (!v23)
    {
      if (v27)
      {
        *buf = 136446210;
        v40 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A37000, v14, v26, "%{public}s called with null update_handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v27)
    {
      *buf = 136446466;
      v40 = "nw_resolver_config_watch_updates";
      v41 = 2082;
      v42 = v23;
      _os_log_impl(&dword_181A37000, v14, v26, "%{public}s called with null update_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_37:

    free(v23);
    if (!v13)
    {
      goto LABEL_7;
    }

    goto LABEL_58;
  }

  v33[0] = MEMORY[0x1E69E9820];
  v33[1] = 3221225472;
  v33[2] = __nw_resolver_config_watch_updates_block_invoke;
  v33[3] = &unk_1E6A39AE8;
  v9 = v5;
  v34 = v9;
  v10 = v6;
  v35 = v10;
  v11 = v8;
  v36 = v11;
  os_unfair_lock_lock(&v9->lock.m_mutex);
  __nw_resolver_config_watch_updates_block_invoke(v33);
  os_unfair_lock_unlock(&v9->lock.m_mutex);
  if (!nw_resolver_config_update_from_path(v9))
  {
    block[0] = MEMORY[0x1E69E9820];
    block[1] = 3221225472;
    block[2] = __nw_resolver_config_watch_updates_block_invoke_2;
    block[3] = &unk_1E6A3CE48;
    v32 = v11;
    dispatch_async(v10, block);
  }

LABEL_7:
}

void __nw_resolver_config_watch_updates_block_invoke(void *a1)
{
  v59 = *MEMORY[0x1E69E9840];
  v1 = a1[4];
  if (!v1[5])
  {
    v2 = a1[5];
    v3 = a1[6];
    v4 = v1;
    v5 = v2;
    v6 = v3;
    v7 = socket(32, 3, 1);
    v8 = v7;
    if (v7 < 0)
    {
LABEL_70:

      return;
    }

    v9 = nw_fd_wrapper_create(v7);
    v53 = v9;
    v54 = -1;
    nw_fd_wrapper_guard(v9);
    v51 = 0x100000001;
    v52 = 9;
    if (ioctl(v8, 0x800C6502uLL, &v51))
    {
      v10 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      *buf = 136446466;
      *&buf[4] = "nw_resolver_config_watch_kernel_events";
      *&buf[12] = 1024;
      *&buf[14] = v10;
      v12 = _os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v50) = 0;
      if (!__nwlog_fault(v12, type, &v50))
      {
        goto LABEL_64;
      }

      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v14 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_watch_kernel_events";
          *&buf[12] = 1024;
          *&buf[14] = v10;
          _os_log_impl(&dword_181A37000, v13, v14, "%{public}s ioctl(SIOCSKEVFILT) failed %{darwin.errno}d", buf, 0x12u);
        }
      }

      else if (v50 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          v19 = backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v20 = gLogObj;
          v21 = type[0];
          if (os_log_type_enabled(v20, type[0]))
          {
            *buf = 136446722;
            *&buf[4] = "nw_resolver_config_watch_kernel_events";
            *&buf[12] = 1024;
            *&buf[14] = v10;
            *&buf[18] = 2082;
            *&buf[20] = v19;
            _os_log_impl(&dword_181A37000, v20, v21, "%{public}s ioctl(SIOCSKEVFILT) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v19);
          if (!v12)
          {
            goto LABEL_66;
          }

          goto LABEL_65;
        }

        v13 = __nwlog_obj();
        v35 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_watch_kernel_events";
          *&buf[12] = 1024;
          *&buf[14] = v10;
          _os_log_impl(&dword_181A37000, v13, v35, "%{public}s ioctl(SIOCSKEVFILT) failed %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v22 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_watch_kernel_events";
          *&buf[12] = 1024;
          *&buf[14] = v10;
          _os_log_impl(&dword_181A37000, v13, v22, "%{public}s ioctl(SIOCSKEVFILT) failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }

    else
    {
      v50 = 1;
      if (ioctl(v8, 0x8004667EuLL, &v50))
      {
        v15 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        *buf = 136446466;
        *&buf[4] = "nw_resolver_config_watch_kernel_events";
        *&buf[12] = 1024;
        *&buf[14] = v15;
        v12 = _os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v49 = 0;
        if (!__nwlog_fault(v12, type, &v49))
        {
          goto LABEL_64;
        }

        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v13 = gLogObj;
          v17 = type[0];
          if (os_log_type_enabled(v13, type[0]))
          {
            *buf = 136446466;
            *&buf[4] = "nw_resolver_config_watch_kernel_events";
            *&buf[12] = 1024;
            *&buf[14] = v15;
            _os_log_impl(&dword_181A37000, v13, v17, "%{public}s ioctl(FIONBIO) failed %{darwin.errno}d", buf, 0x12u);
          }
        }

        else if (v49 == 1)
        {
          v32 = __nw_create_backtrace_string();
          v13 = __nwlog_obj();
          v33 = type[0];
          v34 = os_log_type_enabled(v13, type[0]);
          if (v32)
          {
            if (v34)
            {
              *buf = 136446722;
              *&buf[4] = "nw_resolver_config_watch_kernel_events";
              *&buf[12] = 1024;
              *&buf[14] = v15;
              *&buf[18] = 2082;
              *&buf[20] = v32;
              _os_log_impl(&dword_181A37000, v13, v33, "%{public}s ioctl(FIONBIO) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v32);
            if (!v12)
            {
              goto LABEL_66;
            }

            goto LABEL_65;
          }

          if (v34)
          {
            *buf = 136446466;
            *&buf[4] = "nw_resolver_config_watch_kernel_events";
            *&buf[12] = 1024;
            *&buf[14] = v15;
            _os_log_impl(&dword_181A37000, v13, v33, "%{public}s ioctl(FIONBIO) failed %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }

        else
        {
          v13 = __nwlog_obj();
          v36 = type[0];
          if (os_log_type_enabled(v13, type[0]))
          {
            *buf = 136446466;
            *&buf[4] = "nw_resolver_config_watch_kernel_events";
            *&buf[12] = 1024;
            *&buf[14] = v15;
            _os_log_impl(&dword_181A37000, v13, v36, "%{public}s ioctl(FIONBIO) failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }
      }

      else
      {
        v23 = dispatch_source_create(MEMORY[0x1E69E96F8], v8, 0, v5);
        if (v23)
        {
          v24 = v23;
          v25 = v1[5];
          if ((v4[6] & 1) != 0 && v25)
          {
            v1[5] = 0;

            v25 = v1[5];
          }

          v1[5] = 0;

          v26 = v1[5];
          v1[5] = v24;

          *(v4 + 48) |= 1u;
          v53 = 0;
          v27 = v4[7];
          if ((v4[8] & 1) != 0 && v27)
          {
            v4[7] = 0;

            v27 = v4[7];
          }

          v4[7] = 0;

          v28 = v4[7];
          v4[7] = v9;

          *(v4 + 64) |= 1u;
          v29 = v1[5];
          *type = MEMORY[0x1E69E9820];
          v45 = 3221225472;
          v46 = ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke;
          v47 = &unk_1E6A3D868;
          v30 = v4;
          v48 = v30;
          dispatch_source_set_cancel_handler(v29, type);
          v31 = v1[5];
          *buf = MEMORY[0x1E69E9820];
          *&buf[8] = 3221225472;
          *&buf[16] = ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_3;
          *&buf[24] = &unk_1E6A3D908;
          v58 = v8;
          v56 = v30;
          v57 = v6;
          dispatch_source_set_event_handler(v31, buf);
          dispatch_activate(v1[5]);

          v9 = 0;
          goto LABEL_66;
        }

        v37 = __nwlog_obj();
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_watch_kernel_events";
        v12 = _os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v49 = 0;
        if (!__nwlog_fault(v12, type, &v49))
        {
LABEL_64:
          if (!v12)
          {
LABEL_66:
            if (v9)
            {
              v53 = 0;

              v43 = v53;
            }

            else
            {
              v43 = 0;
            }

            goto LABEL_70;
          }

LABEL_65:
          free(v12);
          goto LABEL_66;
        }

        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v13 = __nwlog_obj();
          v38 = type[0];
          if (os_log_type_enabled(v13, type[0]))
          {
            *buf = 136446210;
            *&buf[4] = "nw_resolver_config_watch_kernel_events";
            _os_log_impl(&dword_181A37000, v13, v38, "%{public}s dispatch_source_create failed", buf, 0xCu);
          }
        }

        else if (v49 == 1)
        {
          v39 = __nw_create_backtrace_string();
          v13 = __nwlog_obj();
          v40 = type[0];
          v41 = os_log_type_enabled(v13, type[0]);
          if (v39)
          {
            if (v41)
            {
              *buf = 136446466;
              *&buf[4] = "nw_resolver_config_watch_kernel_events";
              *&buf[12] = 2082;
              *&buf[14] = v39;
              _os_log_impl(&dword_181A37000, v13, v40, "%{public}s dispatch_source_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v39);
            if (!v12)
            {
              goto LABEL_66;
            }

            goto LABEL_65;
          }

          if (v41)
          {
            *buf = 136446210;
            *&buf[4] = "nw_resolver_config_watch_kernel_events";
            _os_log_impl(&dword_181A37000, v13, v40, "%{public}s dispatch_source_create failed, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          v13 = __nwlog_obj();
          v42 = type[0];
          if (os_log_type_enabled(v13, type[0]))
          {
            *buf = 136446210;
            *&buf[4] = "nw_resolver_config_watch_kernel_events";
            _os_log_impl(&dword_181A37000, v13, v42, "%{public}s dispatch_source_create failed, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
    }

    goto LABEL_64;
  }
}

void sub_18286E71C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va);

  _Unwind_Resume(a1);
}

BOOL nw_resolver_config_update_from_path(NWConcrete_nw_resolver_config *a1)
{
  v1 = a1;
  v9 = 0;
  v10 = &v9;
  v11 = 0x4012000000;
  v12 = __Block_byref_object_copy__127;
  v13 = __Block_byref_object_dispose__128;
  v14 = 256;
  v15 = nw_path_copy_resolver_config_for_identifier();
  v16 |= 1u;
  v2 = v10[6];
  if (v2)
  {
    v6[0] = MEMORY[0x1E69E9820];
    v6[1] = 3221225472;
    v6[2] = ___ZL35nw_resolver_config_update_from_pathP29NWConcrete_nw_resolver_config_block_invoke;
    v6[3] = &unk_1E6A3D738;
    v3 = v1;
    v7 = v3;
    v8 = &v9;
    os_unfair_lock_lock(v3 + 22);
    ___ZL35nw_resolver_config_update_from_pathP29NWConcrete_nw_resolver_config_block_invoke(v6);
    os_unfair_lock_unlock(v3 + 22);
  }

  _Block_object_dispose(&v9, 8);
  v4 = v15;
  if ((v16 & 1) != 0 && v15)
  {
    v15 = 0;

    v4 = v15;
  }

  v15 = 0;

  return v2 != 0;
}

void sub_18286E8B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, ...)
{
  va_start(va, a7);

  _Block_object_dispose(va, 8);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(v8 + 48);

  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__127(uint64_t a1, uint64_t a2)
{
  *(a1 + 48) = *(a2 + 48);
  *(a1 + 56) = *(a1 + 56) & 0xFE | *(a2 + 56) & 1;
  v4 = *(a2 + 48);
  *(a2 + 48) = 0;

  *(a2 + 56) &= ~1u;
}

void __Block_byref_object_dispose__128(uint64_t a1)
{
  v2 = *(a1 + 48);
  if ((*(a1 + 56) & 1) != 0 && v2)
  {
    *(a1 + 48) = 0;

    v2 = *(a1 + 48);
  }

  *(a1 + 48) = 0;

  v3 = *(a1 + 48);
}

void ___ZL35nw_resolver_config_update_from_pathP29NWConcrete_nw_resolver_config_block_invoke(uint64_t a1)
{
  v7 = *(*(*(a1 + 40) + 8) + 48);
  v2 = v7[1];
  v3 = *(a1 + 32);
  v4 = *(v3 + 8);
  if ((*(v3 + 16) & 1) != 0 && v4)
  {
    *(v3 + 8) = 0;

    v4 = *(v3 + 8);
  }

  *(v3 + 8) = 0;

  v5 = *(v3 + 8);
  *(v3 + 8) = v2;
  v6 = v2;

  *(v3 + 16) |= 1u;
}

void ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v3[0] = MEMORY[0x1E69E9820];
  v3[1] = 3221225472;
  v3[2] = ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_2;
  v3[3] = &unk_1E6A3D868;
  v4 = v1;
  v2 = v4;
  os_unfair_lock_lock(v2 + 22);
  ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_2(v3);
  os_unfair_lock_unlock(v2 + 22);
}

void ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_3(uint64_t a1)
{
  v33 = *MEMORY[0x1E69E9840];
  memset(v32, 0, sizeof(v32));
  while (1)
  {
    v2 = recv(*(a1 + 48), v32, 0x80uLL, 0);
    v3 = v2;
    if (v2 < 1)
    {
      break;
    }

    v4 = *(a1 + 40);
    v5 = *(a1 + 32);
    v6 = v4;
    if (v3 >= 0x18 && DWORD1(v32[0]) == 1 && DWORD2(v32[0]) == 1 && HIDWORD(v32[0]) == 9 && LODWORD(v32[0]) >= 0x28 && v3 >= LODWORD(v32[0]) && (DWORD1(v32[1]) & 0xFFFFFFFE) == 2 && !uuid_compare(v5->identifier, &v32[1] + 8))
    {
      v10 = DWORD1(v32[1]);
      if (DWORD1(v32[1]) == 2 || nw_resolver_config_update_from_path(v5))
      {
        v6[2](v6, v10 == 2);
      }
    }
  }

  if (v2 < 0)
  {
    v11 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v11 != 35)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      *buf = 136446466;
      v27 = "nw_resolver_config_watch_kernel_events_block_invoke_3";
      v28 = 1024;
      v29 = v11;
      v13 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v24 = 0;
      if (__nwlog_fault(v13, &type, &v24))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = gLogObj;
          v15 = type;
          if (os_log_type_enabled(v14, type))
          {
            *buf = 136446466;
            v27 = "nw_resolver_config_watch_kernel_events_block_invoke";
            v28 = 1024;
            v29 = v11;
            _os_log_impl(&dword_181A37000, v14, v15, "%{public}s receive from kernel event socket failed %{darwin.errno}d", buf, 0x12u);
          }
        }

        else if (v24 == 1)
        {
          backtrace_string = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = gLogObj;
          v19 = type;
          v20 = os_log_type_enabled(v14, type);
          if (backtrace_string)
          {
            if (v20)
            {
              *buf = 136446722;
              v27 = "nw_resolver_config_watch_kernel_events_block_invoke";
              v28 = 1024;
              v29 = v11;
              v30 = 2082;
              v31 = backtrace_string;
              _os_log_impl(&dword_181A37000, v14, v19, "%{public}s receive from kernel event socket failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(backtrace_string);
            if (!v13)
            {
              goto LABEL_30;
            }

            goto LABEL_29;
          }

          if (v20)
          {
            *buf = 136446466;
            v27 = "nw_resolver_config_watch_kernel_events_block_invoke";
            v28 = 1024;
            v29 = v11;
            _os_log_impl(&dword_181A37000, v14, v19, "%{public}s receive from kernel event socket failed %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = gLogObj;
          v21 = type;
          if (os_log_type_enabled(v14, type))
          {
            *buf = 136446466;
            v27 = "nw_resolver_config_watch_kernel_events_block_invoke";
            v28 = 1024;
            v29 = v11;
            _os_log_impl(&dword_181A37000, v14, v21, "%{public}s receive from kernel event socket failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }
      }

      if (!v13)
      {
LABEL_30:
        v16 = *(a1 + 32);
        v22[0] = MEMORY[0x1E69E9820];
        v22[1] = 3221225472;
        v22[2] = ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_126;
        v22[3] = &unk_1E6A3D868;
        v23 = v16;
        v17 = v23;
        os_unfair_lock_lock(v17 + 22);
        ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_126(v22);
        os_unfair_lock_unlock(v17 + 22);

        return;
      }

LABEL_29:
      free(v13);
      goto LABEL_30;
    }
  }
}

void ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_126(uint64_t a1)
{
  v2 = *(*(a1 + 32) + 40);
  if (v2)
  {
    dispatch_source_cancel(v2);
    v3 = *(a1 + 32);
    v4 = *(v3 + 40);
    if (*(v3 + 48))
    {
      if (v4)
      {
        *(v3 + 40) = 0;

        v4 = *(v3 + 40);
      }
    }

    *(v3 + 40) = 0;

    v5 = *(v3 + 40);
    *(v3 + 40) = 0;

    *(v3 + 48) |= 1u;
  }
}

void ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_2(uint64_t a1)
{
  v2 = *(*(a1 + 32) + 56);
  if (v2)
  {
    nw_fd_wrapper_close(v2);
    v3 = *(a1 + 32);
    v4 = *(v3 + 56);
    if (*(v3 + 64))
    {
      if (v4)
      {
        *(v3 + 56) = 0;

        v4 = *(v3 + 56);
      }
    }

    *(v3 + 56) = 0;

    v5 = *(v3 + 56);
    *(v3 + 56) = 0;

    *(v3 + 64) |= 1u;
  }
}

void nw_resolver_config_cancel_updates(void *a1, void *a2, void *a3)
{
  v40 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = v7;
  if (!v5)
  {
    v12 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_resolver_config_cancel_updates";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v13, &type, &v36))
    {
      goto LABEL_57;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v36 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v21 = type;
      v22 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_cancel_updates";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v14, v21, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_57:
        if (!v13)
        {
          goto LABEL_7;
        }

LABEL_58:
        free(v13);
        goto LABEL_7;
      }

      if (v22)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A37000, v14, v21, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v14 = __nwlog_obj();
      v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A37000, v14, v28, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_56:

    goto LABEL_57;
  }

  if (!v6)
  {
    v16 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_resolver_config_cancel_updates";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v13, &type, &v36))
    {
      goto LABEL_57;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A37000, v14, v17, "%{public}s called with null queue", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v36 != 1)
    {
      v14 = __nwlog_obj();
      v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A37000, v14, v29, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_56;
    }

    v23 = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v24 = type;
    v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A37000, v14, v24, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v25)
    {
      *buf = 136446466;
      *&buf[4] = "nw_resolver_config_cancel_updates";
      *&buf[12] = 2082;
      *&buf[14] = v23;
      _os_log_impl(&dword_181A37000, v14, v24, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_37;
  }

  if (!v7)
  {
    v18 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_resolver_config_cancel_updates";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v13, &type, &v36))
    {
      goto LABEL_57;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A37000, v14, v19, "%{public}s called with null completion", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v36 != 1)
    {
      v14 = __nwlog_obj();
      v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A37000, v14, v30, "%{public}s called with null completion, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_56;
    }

    v23 = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v26 = type;
    v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A37000, v14, v26, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v27)
    {
      *buf = 136446466;
      *&buf[4] = "nw_resolver_config_cancel_updates";
      *&buf[12] = 2082;
      *&buf[14] = v23;
      _os_log_impl(&dword_181A37000, v14, v26, "%{public}s called with null completion, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_37:

    free(v23);
    if (!v13)
    {
      goto LABEL_7;
    }

    goto LABEL_58;
  }

  *buf = 0;
  *&buf[8] = buf;
  *&buf[16] = 0x2020000000;
  v39 = 0;
  v31[0] = MEMORY[0x1E69E9820];
  v31[1] = 3221225472;
  v31[2] = __nw_resolver_config_cancel_updates_block_invoke;
  v31[3] = &unk_1E6A35B20;
  v9 = v5;
  v32 = v9;
  v10 = v6;
  v33 = v10;
  v11 = v8;
  v34 = v11;
  v35 = buf;
  os_unfair_lock_lock(v9 + 22);
  __nw_resolver_config_cancel_updates_block_invoke(v31);
  os_unfair_lock_unlock(v9 + 22);
  if ((*(*&buf[8] + 24) & 1) == 0)
  {
    dispatch_async(v10, v11);
  }

  _Block_object_dispose(buf, 8);
LABEL_7:
}

void sub_18286F8A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_cancel_updates_block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = v1[5];
  if (v2)
  {
    handler[0] = MEMORY[0x1E69E9820];
    handler[1] = 3221225472;
    handler[2] = __nw_resolver_config_cancel_updates_block_invoke_2;
    handler[3] = &unk_1E6A39AE8;
    v8 = v1;
    v9 = *(a1 + 40);
    v10 = *(a1 + 48);
    dispatch_source_set_cancel_handler(v2, handler);
    dispatch_source_cancel(*(*(a1 + 32) + 40));
    v4 = *(a1 + 32);
    v5 = *(v4 + 40);
    if (*(v4 + 48))
    {
      if (v5)
      {
        *(v4 + 40) = 0;

        v5 = *(v4 + 40);
      }
    }

    *(v4 + 40) = 0;

    v6 = *(v4 + 40);
    *(v4 + 40) = 0;

    *(v4 + 48) |= 1u;
    *(*(*(a1 + 56) + 8) + 24) = 1;
  }
}

void __nw_resolver_config_cancel_updates_block_invoke_2(uint64_t a1)
{
  v2 = *(a1 + 32);
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3221225472;
  v4[2] = __nw_resolver_config_cancel_updates_block_invoke_3;
  v4[3] = &unk_1E6A3D868;
  v5 = v2;
  v3 = v5;
  os_unfair_lock_lock(v3 + 22);
  __nw_resolver_config_cancel_updates_block_invoke_3(v4);
  os_unfair_lock_unlock(v3 + 22);

  dispatch_async(*(a1 + 40), *(a1 + 48));
}

void __nw_resolver_config_cancel_updates_block_invoke_3(uint64_t a1)
{
  v2 = *(*(a1 + 32) + 56);
  if (v2)
  {
    nw_fd_wrapper_close(v2);
    v3 = *(a1 + 32);
    v4 = *(v3 + 56);
    if (*(v3 + 64))
    {
      if (v4)
      {
        *(v3 + 56) = 0;

        v4 = *(v3 + 56);
      }
    }

    *(v3 + 56) = 0;

    v5 = *(v3 + 56);
    *(v3 + 56) = 0;

    *(v3 + 64) |= 1u;
  }
}

void nw_resolver_config_report_error(void *a1, int a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (!uuid_is_null(v3 + 24))
    {
      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0, 0);
      v6 = evaluator_for_endpoint;
      *buf = evaluator_for_endpoint;
      buf[8] = -1;
      if (evaluator_for_endpoint)
      {
        v7 = evaluator_for_endpoint;
        os_unfair_lock_lock(v6 + 24);
        v8 = v7[6];
        os_unfair_lock_unlock(v6 + 24);
      }

      else
      {
        v8 = 0;
      }

      *type = v8;
      v18 = -1;
      nw_path_report_error_to_agent(v8, v4 + 24, a2);
      if (v8)
      {
      }

      if (v6)
      {
      }
    }

    goto LABEL_10;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_resolver_config_report_error";
  v10 = _os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v10, type, &v19))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_report_error";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v19 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v14 = type[0];
      v15 = os_log_type_enabled(v11, type[0]);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          *&buf[4] = "nw_resolver_config_report_error";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v15)
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_report_error";
        _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v16 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_resolver_config_report_error";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_27:
  if (v10)
  {
    free(v10);
  }

LABEL_10:
}

void sub_18286FE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v8 = va_arg(va1, void);
  v10 = va_arg(va1, void);
  v11 = va_arg(va1, void);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va1);

  _Unwind_Resume(a1);
}

uint64_t nw_resolver_config_publish(void *a1)
{
  v35 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[9];
    if (v3)
    {
      v27[0] = MEMORY[0x1E69E9820];
      v27[1] = 3221225472;
      v27[2] = __nw_resolver_config_publish_block_invoke;
      v27[3] = &unk_1E6A3C088;
      v28 = v1;
      v4 = v3;
      fd = nw_fd_wrapper_get_fd(v4, v27);
    }

    else
    {
      v6 = nw_network_agent_open_control_socket();
      v7 = nw_fd_wrapper_create(v6);
      v8 = v2[9];
      if ((v2[10] & 1) != 0 && v8)
      {
        v2[9] = 0;

        v8 = v2[9];
      }

      v2[9] = 0;

      v9 = v2[9];
      v2[9] = v7;

      *(v2 + 80) |= 1u;
      v10 = nw_resolver_config_copy_plist_data_ref(v2);
      provider_description = nw_resolver_config_get_provider_description(v2);
      if (!provider_description)
      {
        provider_description = nw_resolver_config_get_provider_name(v2);
      }

      if (provider_description)
      {
        v12 = provider_description;
      }

      else
      {
        v12 = "DNS";
      }

      BytePtr = CFDataGetBytePtr(v10);
      Length = CFDataGetLength(v10);
      v15 = nw_network_agent_ctl_setsockopt(v6, 1, (v2 + 3), "SystemConfig", "DNSAgent", v12, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, BytePtr, Length);
      fd = v15 >= 0;
      if (v15 < 0)
      {
        v16 = v2[9];
        if ((v2[10] & 1) != 0 && v16)
        {
          v2[9] = 0;

          v16 = v2[9];
        }

        v2[9] = 0;

        v17 = v2[9];
        v2[9] = 0;

        *(v2 + 80) |= 1u;
      }

      if (v10)
      {
        CFRelease(v10);
      }
    }

    goto LABEL_19;
  }

  v19 = __nwlog_obj();
  *buf = 136446210;
  v32 = "nw_resolver_config_publish";
  v20 = _os_log_send_and_compose_impl();

  v30 = OS_LOG_TYPE_ERROR;
  v29 = 0;
  if (__nwlog_fault(v20, &v30, &v29))
  {
    if (v30 == OS_LOG_TYPE_FAULT)
    {
      v21 = __nwlog_obj();
      v22 = v30;
      if (os_log_type_enabled(v21, v30))
      {
        *buf = 136446210;
        v32 = "nw_resolver_config_publish";
        _os_log_impl(&dword_181A37000, v21, v22, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v29 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v21 = __nwlog_obj();
      v24 = v30;
      v25 = os_log_type_enabled(v21, v30);
      if (backtrace_string)
      {
        if (v25)
        {
          *buf = 136446466;
          v32 = "nw_resolver_config_publish";
          v33 = 2082;
          v34 = backtrace_string;
          _os_log_impl(&dword_181A37000, v21, v24, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_36;
      }

      if (v25)
      {
        *buf = 136446210;
        v32 = "nw_resolver_config_publish";
        _os_log_impl(&dword_181A37000, v21, v24, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v21 = __nwlog_obj();
      v26 = v30;
      if (os_log_type_enabled(v21, v30))
      {
        *buf = 136446210;
        v32 = "nw_resolver_config_publish";
        _os_log_impl(&dword_181A37000, v21, v26, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_36:
  if (v20)
  {
    free(v20);
  }

  fd = 0;
LABEL_19:

  return fd;
}

BOOL __nw_resolver_config_publish_block_invoke(uint64_t a1, int a2)
{
  v4 = nw_resolver_config_copy_plist_data_ref(*(a1 + 32));
  provider_description = nw_resolver_config_get_provider_description(*(a1 + 32));
  if (!provider_description)
  {
    provider_description = nw_resolver_config_get_provider_name(*(a1 + 32));
  }

  v6 = *(a1 + 32);
  if (provider_description)
  {
    v7 = provider_description;
  }

  else
  {
    v7 = "DNS";
  }

  BytePtr = CFDataGetBytePtr(v4);
  Length = CFDataGetLength(v4);
  v10 = nw_network_agent_ctl_setsockopt(a2, 3, (v6 + 24), "SystemConfig", "DNSAgent", v7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, BytePtr, Length);
  if (v4)
  {
    CFRelease(v4);
  }

  return v10 >= 0;
}

void sub_1828703E0(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    CFRelease(v1);
  }

  _Unwind_Resume(exception_object);
}

void nw_resolver_config_unpublish(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    nw_fd_wrapper_close(v1[9]);
    v3 = v2[9];
    if ((v2[10] & 1) != 0 && v3)
    {
      v2[9] = 0;

      v3 = v2[9];
    }

    v2[9] = 0;

    v4 = v2[9];
    v2[9] = 0;

    *(v2 + 80) |= 1u;
    goto LABEL_6;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_resolver_config_unpublish";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_resolver_config_unpublish";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_resolver_config_unpublish";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_resolver_config_unpublish";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_resolver_config_unpublish";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v6)
  {
    free(v6);
  }

LABEL_6:
}

uint64_t nw_protocol_common_get_input_frames(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v67 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v60 = "nw_protocol_common_get_input_frames";
    v11 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v11, &type, &v57))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_input_frames";
      v14 = "%{public}s called with null protocol";
      goto LABEL_56;
    }

    if (v57 != 1)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_input_frames";
      v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v51 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v51)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_input_frames";
      v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_56;
    }

    if (!v51)
    {
      goto LABEL_104;
    }

    *buf = 136446466;
    v60 = "nw_protocol_common_get_input_frames";
    v61 = 2082;
    v62 = backtrace_string;
    v52 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_103;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v60 = "nw_protocol_common_get_input_frames";
    v11 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v11, &type, &v57))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_input_frames";
      v14 = "%{public}s called with null input_protocol";
      goto LABEL_56;
    }

    if (v57 != 1)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_input_frames";
      v14 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v53 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v53)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_input_frames";
      v14 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_56;
    }

    if (!v53)
    {
      goto LABEL_104;
    }

    *buf = 136446466;
    v60 = "nw_protocol_common_get_input_frames";
    v61 = 2082;
    v62 = backtrace_string;
    v52 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
LABEL_103:
    _os_log_impl(&dword_181A37000, v12, v13, v52, buf, 0x16u);
    goto LABEL_104;
  }

  if (!a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v60 = "nw_protocol_common_get_input_frames";
    v11 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v11, &type, &v57))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_input_frames";
      v14 = "%{public}s called with null return_array";
      goto LABEL_56;
    }

    if (v57 != 1)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_input_frames";
      v14 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v54 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v54)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_input_frames";
      v14 = "%{public}s called with null return_array, no backtrace";
      goto LABEL_56;
    }

    if (v54)
    {
      *buf = 136446466;
      v60 = "nw_protocol_common_get_input_frames";
      v61 = 2082;
      v62 = backtrace_string;
      v52 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
      goto LABEL_103;
    }

LABEL_104:
    free(backtrace_string);
    goto LABEL_58;
  }

  v6 = a1;
  v7 = a1[4];
  if (v7)
  {
    v8 = *(v7 + 40);
    v9 = a1[4];
    if (v8 == &nw_protocol_ref_counted_handle || v8 == &nw_protocol_ref_counted_additional_handle && (v9 = *(v7 + 64)) != 0)
    {
      v19 = *(v9 + 88);
      v10 = 0;
      if (v19)
      {
        *(v9 + 88) = v19 + 1;
      }
    }

    else
    {
      v10 = 1;
    }

    v20 = a1[5];
    v21 = a1;
    if (v20 == &nw_protocol_ref_counted_handle || v20 == &nw_protocol_ref_counted_additional_handle && (v21 = a1[8]) != 0)
    {
      v24 = v21[11];
      if (v24)
      {
        v22 = 0;
        v21[11] = v24 + 1;
        v23 = *(v7 + 24);
        if (!v23)
        {
          goto LABEL_64;
        }
      }

      else
      {
        v22 = 0;
        v23 = *(v7 + 24);
        if (!v23)
        {
          goto LABEL_64;
        }
      }
    }

    else
    {
      v22 = 1;
      v23 = *(v7 + 24);
      if (!v23)
      {
        goto LABEL_64;
      }
    }

    v25 = *(v23 + 80);
    if (v25)
    {
      result = v25(v7, a1);
      if (v22)
      {
LABEL_42:
        if ((v10 & 1) == 0)
        {
          v33 = *(v7 + 40);
          if (v33 == &nw_protocol_ref_counted_handle || v33 == &nw_protocol_ref_counted_additional_handle && (v7 = *(v7 + 64)) != 0)
          {
            v34 = *(v7 + 88);
            if (v34)
            {
              v35 = v34 - 1;
              *(v7 + 88) = v35;
              if (!v35)
              {
                v36 = result;
                v37 = *(v7 + 64);
                if (v37)
                {
                  *(v7 + 64) = 0;
                  v37[2](v37);
                  _Block_release(v37);
                }

                if (*(v7 + 72))
                {
                  v38 = *(v7 + 64);
                  if (v38)
                  {
                    _Block_release(v38);
                  }
                }

                free(v7);
                return v36;
              }
            }
          }
        }

        return result;
      }

LABEL_31:
      v27 = v6[5];
      if (v27 == &nw_protocol_ref_counted_handle || v27 == &nw_protocol_ref_counted_additional_handle && (v6 = v6[8]) != 0)
      {
        v28 = v6[11];
        if (v28)
        {
          v29 = v28 - 1;
          v6[11] = v29;
          if (!v29)
          {
            v30 = result;
            v31 = v6[8];
            if (v31)
            {
              v6[8] = 0;
              v31[2](v31);
              _Block_release(v31);
            }

            if (v6[9])
            {
              v32 = v6[8];
              if (v32)
              {
                _Block_release(v32);
              }
            }

            free(v6);
            result = v30;
          }
        }
      }

      goto LABEL_42;
    }

LABEL_64:
    __nwlog_obj();
    v41 = *(v7 + 16);
    *buf = 136446722;
    v60 = "__nw_protocol_get_input_frames";
    if (!v41)
    {
      v41 = "invalid";
    }

    v61 = 2082;
    v62 = v41;
    v63 = 2048;
    v64 = v7;
    v42 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (__nwlog_fault(v42, &type, &v57))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v43 = __nwlog_obj();
        v44 = type;
        if (!os_log_type_enabled(v43, type))
        {
          goto LABEL_120;
        }

        v45 = *(v7 + 16);
        if (!v45)
        {
          v45 = "invalid";
        }

        *buf = 136446722;
        v60 = "__nw_protocol_get_input_frames";
        v61 = 2082;
        v62 = v45;
        v63 = 2048;
        v64 = v7;
        v46 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_119:
        _os_log_impl(&dword_181A37000, v43, v44, v46, buf, 0x20u);
        goto LABEL_120;
      }

      if (v57 != 1)
      {
        v43 = __nwlog_obj();
        v44 = type;
        if (!os_log_type_enabled(v43, type))
        {
          goto LABEL_120;
        }

        v55 = *(v7 + 16);
        if (!v55)
        {
          v55 = "invalid";
        }

        *buf = 136446722;
        v60 = "__nw_protocol_get_input_frames";
        v61 = 2082;
        v62 = v55;
        v63 = 2048;
        v64 = v7;
        v46 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
        goto LABEL_119;
      }

      v47 = __nw_create_backtrace_string();
      v43 = __nwlog_obj();
      v44 = type;
      v48 = os_log_type_enabled(v43, type);
      if (!v47)
      {
        if (!v48)
        {
          goto LABEL_120;
        }

        v56 = *(v7 + 16);
        if (!v56)
        {
          v56 = "invalid";
        }

        *buf = 136446722;
        v60 = "__nw_protocol_get_input_frames";
        v61 = 2082;
        v62 = v56;
        v63 = 2048;
        v64 = v7;
        v46 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
        goto LABEL_119;
      }

      if (v48)
      {
        v49 = *(v7 + 16);
        if (!v49)
        {
          v49 = "invalid";
        }

        *buf = 136446978;
        v60 = "__nw_protocol_get_input_frames";
        v61 = 2082;
        v62 = v49;
        v63 = 2048;
        v64 = v7;
        v65 = 2082;
        v66 = v47;
        _os_log_impl(&dword_181A37000, v43, v44, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v47);
    }

LABEL_120:
    if (v42)
    {
      free(v42);
    }

    result = 0;
    if (v22)
    {
      goto LABEL_42;
    }

    goto LABEL_31;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446210;
  v60 = "nw_protocol_common_get_input_frames";
  v11 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v57 = 0;
  if (__nwlog_fault(v11, &type, &v57))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled(gLogObj, type))
      {
        *buf = 136446210;
        v60 = "nw_protocol_common_get_input_frames";
        v14 = "%{public}s get_input_frames requires an output handler";
LABEL_56:
        v39 = v12;
        v40 = v13;
LABEL_57:
        _os_log_impl(&dword_181A37000, v39, v40, v14, buf, 0xCu);
      }
    }

    else if (v57 == 1)
    {
      v15 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      v18 = os_log_type_enabled(gLogObj, type);
      if (v15)
      {
        if (v18)
        {
          *buf = 136446466;
          v60 = "nw_protocol_common_get_input_frames";
          v61 = 2082;
          v62 = v15;
          _os_log_impl(&dword_181A37000, v16, v17, "%{public}s get_input_frames requires an output handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v15);
        goto LABEL_58;
      }

      if (v18)
      {
        *buf = 136446210;
        v60 = "nw_protocol_common_get_input_frames";
        v14 = "%{public}s get_input_frames requires an output handler, no backtrace";
        v39 = v16;
        v40 = v17;
        goto LABEL_57;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled(gLogObj, type))
      {
        *buf = 136446210;
        v60 = "nw_protocol_common_get_input_frames";
        v14 = "%{public}s get_input_frames requires an output handler, backtrace limit exceeded";
        goto LABEL_56;
      }
    }
  }

LABEL_58:
  if (v11)
  {
    free(v11);
  }

  return 0;
}

uint64_t nw_protocol_common_get_output_frames(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v67 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v60 = "nw_protocol_common_get_output_frames";
    v11 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v11, &type, &v57))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_output_frames";
      v14 = "%{public}s called with null protocol";
      goto LABEL_56;
    }

    if (v57 != 1)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_output_frames";
      v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v51 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v51)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_output_frames";
      v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_56;
    }

    if (!v51)
    {
      goto LABEL_104;
    }

    *buf = 136446466;
    v60 = "nw_protocol_common_get_output_frames";
    v61 = 2082;
    v62 = backtrace_string;
    v52 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_103;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v60 = "nw_protocol_common_get_output_frames";
    v11 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v11, &type, &v57))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_output_frames";
      v14 = "%{public}s called with null input_protocol";
      goto LABEL_56;
    }

    if (v57 != 1)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_output_frames";
      v14 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v53 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v53)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_output_frames";
      v14 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_56;
    }

    if (!v53)
    {
      goto LABEL_104;
    }

    *buf = 136446466;
    v60 = "nw_protocol_common_get_output_frames";
    v61 = 2082;
    v62 = backtrace_string;
    v52 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
LABEL_103:
    _os_log_impl(&dword_181A37000, v12, v13, v52, buf, 0x16u);
    goto LABEL_104;
  }

  if (!a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v60 = "nw_protocol_common_get_output_frames";
    v11 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v11, &type, &v57))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_output_frames";
      v14 = "%{public}s called with null return_array";
      goto LABEL_56;
    }

    if (v57 != 1)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_output_frames";
      v14 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v54 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v54)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v60 = "nw_protocol_common_get_output_frames";
      v14 = "%{public}s called with null return_array, no backtrace";
      goto LABEL_56;
    }

    if (v54)
    {
      *buf = 136446466;
      v60 = "nw_protocol_common_get_output_frames";
      v61 = 2082;
      v62 = backtrace_string;
      v52 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
      goto LABEL_103;
    }

LABEL_104:
    free(backtrace_string);
    goto LABEL_58;
  }

  v6 = a1;
  v7 = a1[4];
  if (v7)
  {
    v8 = *(v7 + 40);
    v9 = a1[4];
    if (v8 == &nw_protocol_ref_counted_handle || v8 == &nw_protocol_ref_counted_additional_handle && (v9 = *(v7 + 64)) != 0)
    {
      v19 = *(v9 + 88);
      v10 = 0;
      if (v19)
      {
        *(v9 + 88) = v19 + 1;
      }
    }

    else
    {
      v10 = 1;
    }

    v20 = a1[5];
    v21 = a1;
    if (v20 == &nw_protocol_ref_counted_handle || v20 == &nw_protocol_ref_counted_additional_handle && (v21 = a1[8]) != 0)
    {
      v24 = v21[11];
      if (v24)
      {
        v22 = 0;
        v21[11] = v24 + 1;
        v23 = *(v7 + 24);
        if (!v23)
        {
          goto LABEL_64;
        }
      }

      else
      {
        v22 = 0;
        v23 = *(v7 + 24);
        if (!v23)
        {
          goto LABEL_64;
        }
      }
    }

    else
    {
      v22 = 1;
      v23 = *(v7 + 24);
      if (!v23)
      {
        goto LABEL_64;
      }
    }

    v25 = *(v23 + 88);
    if (v25)
    {
      result = v25(v7, a1);
      if (v22)
      {
LABEL_42:
        if ((v10 & 1) == 0)
        {
          v33 = *(v7 + 40);
          if (v33 == &nw_protocol_ref_counted_handle || v33 == &nw_protocol_ref_counted_additional_handle && (v7 = *(v7 + 64)) != 0)
          {
            v34 = *(v7 + 88);
            if (v34)
            {
              v35 = v34 - 1;
              *(v7 + 88) = v35;
              if (!v35)
              {
                v36 = result;
                v37 = *(v7 + 64);
                if (v37)
                {
                  *(v7 + 64) = 0;
                  v37[2](v37);
                  _Block_release(v37);
                }

                if (*(v7 + 72))
                {
                  v38 = *(v7 + 64);
                  if (v38)
                  {
                    _Block_release(v38);
                  }
                }

                free(v7);
                return v36;
              }
            }
          }
        }

        return result;
      }

LABEL_31:
      v27 = v6[5];
      if (v27 == &nw_protocol_ref_counted_handle || v27 == &nw_protocol_ref_counted_additional_handle && (v6 = v6[8]) != 0)
      {
        v28 = v6[11];
        if (v28)
        {
          v29 = v28 - 1;
          v6[11] = v29;
          if (!v29)
          {
            v30 = result;
            v31 = v6[8];
            if (v31)
            {
              v6[8] = 0;
              v31[2](v31);
              _Block_release(v31);
            }

            if (v6[9])
            {
              v32 = v6[8];
              if (v32)
              {
                _Block_release(v32);
              }
            }

            free(v6);
            result = v30;
          }
        }
      }

      goto LABEL_42;
    }

LABEL_64:
    __nwlog_obj();
    v41 = *(v7 + 16);
    *buf = 136446722;
    v60 = "__nw_protocol_get_output_frames";
    if (!v41)
    {
      v41 = "invalid";
    }

    v61 = 2082;
    v62 = v41;
    v63 = 2048;
    v64 = v7;
    v42 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (__nwlog_fault(v42, &type, &v57))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v43 = __nwlog_obj();
        v44 = type;
        if (!os_log_type_enabled(v43, type))
        {
          goto LABEL_120;
        }

        v45 = *(v7 + 16);
        if (!v45)
        {
          v45 = "invalid";
        }

        *buf = 136446722;
        v60 = "__nw_protocol_get_output_frames";
        v61 = 2082;
        v62 = v45;
        v63 = 2048;
        v64 = v7;
        v46 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback";
LABEL_119:
        _os_log_impl(&dword_181A37000, v43, v44, v46, buf, 0x20u);
        goto LABEL_120;
      }

      if (v57 != 1)
      {
        v43 = __nwlog_obj();
        v44 = type;
        if (!os_log_type_enabled(v43, type))
        {
          goto LABEL_120;
        }

        v55 = *(v7 + 16);
        if (!v55)
        {
          v55 = "invalid";
        }

        *buf = 136446722;
        v60 = "__nw_protocol_get_output_frames";
        v61 = 2082;
        v62 = v55;
        v63 = 2048;
        v64 = v7;
        v46 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, backtrace limit exceeded";
        goto LABEL_119;
      }

      v47 = __nw_create_backtrace_string();
      v43 = __nwlog_obj();
      v44 = type;
      v48 = os_log_type_enabled(v43, type);
      if (!v47)
      {
        if (!v48)
        {
          goto LABEL_120;
        }

        v56 = *(v7 + 16);
        if (!v56)
        {
          v56 = "invalid";
        }

        *buf = 136446722;
        v60 = "__nw_protocol_get_output_frames";
        v61 = 2082;
        v62 = v56;
        v63 = 2048;
        v64 = v7;
        v46 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, no backtrace";
        goto LABEL_119;
      }

      if (v48)
      {
        v49 = *(v7 + 16);
        if (!v49)
        {
          v49 = "invalid";
        }

        *buf = 136446978;
        v60 = "__nw_protocol_get_output_frames";
        v61 = 2082;
        v62 = v49;
        v63 = 2048;
        v64 = v7;
        v65 = 2082;
        v66 = v47;
        _os_log_impl(&dword_181A37000, v43, v44, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v47);
    }

LABEL_120:
    if (v42)
    {
      free(v42);
    }

    result = 0;
    if (v22)
    {
      goto LABEL_42;
    }

    goto LABEL_31;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446210;
  v60 = "nw_protocol_common_get_output_frames";
  v11 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v57 = 0;
  if (__nwlog_fault(v11, &type, &v57))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled(gLogObj, type))
      {
        *buf = 136446210;
        v60 = "nw_protocol_common_get_output_frames";
        v14 = "%{public}s get_ouput_frames requires an output handler";
LABEL_56:
        v39 = v12;
        v40 = v13;
LABEL_57:
        _os_log_impl(&dword_181A37000, v39, v40, v14, buf, 0xCu);
      }
    }

    else if (v57 == 1)
    {
      v15 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      v18 = os_log_type_enabled(gLogObj, type);
      if (v15)
      {
        if (v18)
        {
          *buf = 136446466;
          v60 = "nw_protocol_common_get_output_frames";
          v61 = 2082;
          v62 = v15;
          _os_log_impl(&dword_181A37000, v16, v17, "%{public}s get_ouput_frames requires an output handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v15);
        goto LABEL_58;
      }

      if (v18)
      {
        *buf = 136446210;
        v60 = "nw_protocol_common_get_output_frames";
        v14 = "%{public}s get_ouput_frames requires an output handler, no backtrace";
        v39 = v16;
        v40 = v17;
        goto LABEL_57;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled(gLogObj, type))
      {
        *buf = 136446210;
        v60 = "nw_protocol_common_get_output_frames";
        v14 = "%{public}s get_ouput_frames requires an output handler, backtrace limit exceeded";
        goto LABEL_56;
      }
    }
  }

LABEL_58:
  if (v11)
  {
    free(v11);
  }

  return 0;
}

uint64_t nw_protocol_common_finalize_output_frames(uint64_t a1, uint64_t a2)
{
  v51 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v44 = "nw_protocol_common_finalize_output_frames";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v7, &type, &v41))
    {
      goto LABEL_39;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_39;
      }

      *buf = 136446210;
      v44 = "nw_protocol_common_finalize_output_frames";
      v10 = "%{public}s called with null protocol";
      goto LABEL_37;
    }

    if (v41 != 1)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_39;
      }

      *buf = 136446210;
      v44 = "nw_protocol_common_finalize_output_frames";
      v10 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_37;
    }

    backtrace_string = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v36 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (!v36)
      {
        goto LABEL_39;
      }

      *buf = 136446210;
      v44 = "nw_protocol_common_finalize_output_frames";
      v10 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_37;
    }

    if (v36)
    {
      *buf = 136446466;
      v44 = "nw_protocol_common_finalize_output_frames";
      v45 = 2082;
      v46 = backtrace_string;
      v37 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_77:
      _os_log_impl(&dword_181A37000, v8, v9, v37, buf, 0x16u);
    }

LABEL_78:
    free(backtrace_string);
    goto LABEL_39;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v44 = "nw_protocol_common_finalize_output_frames";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v7, &type, &v41))
    {
      goto LABEL_39;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_39;
      }

      *buf = 136446210;
      v44 = "nw_protocol_common_finalize_output_frames";
      v10 = "%{public}s called with null frames";
      goto LABEL_37;
    }

    if (v41 != 1)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_39;
      }

      *buf = 136446210;
      v44 = "nw_protocol_common_finalize_output_frames";
      v10 = "%{public}s called with null frames, backtrace limit exceeded";
      goto LABEL_37;
    }

    backtrace_string = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v38 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (!v38)
      {
        goto LABEL_39;
      }

      *buf = 136446210;
      v44 = "nw_protocol_common_finalize_output_frames";
      v10 = "%{public}s called with null frames, no backtrace";
      goto LABEL_37;
    }

    if (v38)
    {
      *buf = 136446466;
      v44 = "nw_protocol_common_finalize_output_frames";
      v45 = 2082;
      v46 = backtrace_string;
      v37 = "%{public}s called with null frames, dumping backtrace:%{public}s";
      goto LABEL_77;
    }

    goto LABEL_78;
  }

  v2 = *(a1 + 32);
  if (v2)
  {
    v3 = *(v2 + 40);
    v4 = *(a1 + 32);
    if (v3 == &nw_protocol_ref_counted_handle || v3 == &nw_protocol_ref_counted_additional_handle && (v4 = *(v2 + 64)) != 0)
    {
      v15 = *(v4 + 88);
      if (v15)
      {
        v5 = 0;
        *(v4 + 88) = v15 + 1;
        v6 = *(v2 + 24);
        if (!v6)
        {
          goto LABEL_45;
        }
      }

      else
      {
        v5 = 0;
        v6 = *(v2 + 24);
        if (!v6)
        {
          goto LABEL_45;
        }
      }
    }

    else
    {
      v5 = 1;
      v6 = *(v2 + 24);
      if (!v6)
      {
        goto LABEL_45;
      }
    }

    v16 = *(v6 + 96);
    if (v16)
    {
      result = v16(v2);
      if (v5)
      {
        return result;
      }

      goto LABEL_24;
    }

LABEL_45:
    __nwlog_obj();
    v26 = *(v2 + 16);
    *buf = 136446722;
    v44 = "__nw_protocol_finalize_output_frames";
    if (!v26)
    {
      v26 = "invalid";
    }

    v45 = 2082;
    v46 = v26;
    v47 = 2048;
    v48 = v2;
    v27 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (__nwlog_fault(v27, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v28 = __nwlog_obj();
        v29 = type;
        if (!os_log_type_enabled(v28, type))
        {
          goto LABEL_92;
        }

        v30 = *(v2 + 16);
        if (!v30)
        {
          v30 = "invalid";
        }

        *buf = 136446722;
        v44 = "__nw_protocol_finalize_output_frames";
        v45 = 2082;
        v46 = v30;
        v47 = 2048;
        v48 = v2;
        v31 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_91:
        _os_log_impl(&dword_181A37000, v28, v29, v31, buf, 0x20u);
        goto LABEL_92;
      }

      if (v41 != 1)
      {
        v28 = __nwlog_obj();
        v29 = type;
        if (!os_log_type_enabled(v28, type))
        {
          goto LABEL_92;
        }

        v39 = *(v2 + 16);
        if (!v39)
        {
          v39 = "invalid";
        }

        *buf = 136446722;
        v44 = "__nw_protocol_finalize_output_frames";
        v45 = 2082;
        v46 = v39;
        v47 = 2048;
        v48 = v2;
        v31 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
        goto LABEL_91;
      }

      v32 = __nw_create_backtrace_string();
      v28 = __nwlog_obj();
      v29 = type;
      v33 = os_log_type_enabled(v28, type);
      if (!v32)
      {
        if (!v33)
        {
          goto LABEL_92;
        }

        v40 = *(v2 + 16);
        if (!v40)
        {
          v40 = "invalid";
        }

        *buf = 136446722;
        v44 = "__nw_protocol_finalize_output_frames";
        v45 = 2082;
        v46 = v40;
        v47 = 2048;
        v48 = v2;
        v31 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
        goto LABEL_91;
      }

      if (v33)
      {
        if (*(v2 + 16))
        {
          v34 = *(v2 + 16);
        }

        else
        {
          v34 = "invalid";
        }

        *buf = 136446978;
        v44 = "__nw_protocol_finalize_output_frames";
        v45 = 2082;
        v46 = v34;
        v47 = 2048;
        v48 = v2;
        v49 = 2082;
        v50 = v32;
        _os_log_impl(&dword_181A37000, v28, v29, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v32);
    }

LABEL_92:
    if (v27)
    {
      free(v27);
    }

    result = 0;
    if (v5)
    {
      return result;
    }

LABEL_24:
    v18 = *(v2 + 40);
    if (v18 == &nw_protocol_ref_counted_handle || v18 == &nw_protocol_ref_counted_additional_handle && (v2 = *(v2 + 64)) != 0)
    {
      v19 = *(v2 + 88);
      if (v19)
      {
        v20 = v19 - 1;
        *(v2 + 88) = v20;
        if (!v20)
        {
          v21 = result;
          v22 = *(v2 + 64);
          if (v22)
          {
            *(v2 + 64) = 0;
            v22[2](v22);
            _Block_release(v22);
          }

          if (*(v2 + 72))
          {
            v23 = *(v2 + 64);
            if (v23)
            {
              _Block_release(v23);
            }
          }

          free(v2);
          return v21;
        }
      }
    }

    return result;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446210;
  v44 = "nw_protocol_common_finalize_output_frames";
  v7 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v41 = 0;
  if (__nwlog_fault(v7, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (os_log_type_enabled(gLogObj, type))
      {
        *buf = 136446210;
        v44 = "nw_protocol_common_finalize_output_frames";
        v10 = "%{public}s finalize_output_frames requires an output handler";
LABEL_37:
        v24 = v8;
        v25 = v9;
LABEL_38:
        _os_log_impl(&dword_181A37000, v24, v25, v10, buf, 0xCu);
      }
    }

    else if (v41 == 1)
    {
      v11 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      v14 = os_log_type_enabled(gLogObj, type);
      if (v11)
      {
        if (v14)
        {
          *buf = 136446466;
          v44 = "nw_protocol_common_finalize_output_frames";
          v45 = 2082;
          v46 = v11;
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s finalize_output_frames requires an output handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v11);
        goto LABEL_39;
      }

      if (v14)
      {
        *buf = 136446210;
        v44 = "nw_protocol_common_finalize_output_frames";
        v10 = "%{public}s finalize_output_frames requires an output handler, no backtrace";
        v24 = v12;
        v25 = v13;
        goto LABEL_38;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (os_log_type_enabled(gLogObj, type))
      {
        *buf = 136446210;
        v44 = "nw_protocol_common_finalize_output_frames";
        v10 = "%{public}s finalize_output_frames requires an output handler, backtrace limit exceeded";
        goto LABEL_37;
      }
    }
  }

LABEL_39:
  if (v7)
  {
    free(v7);
  }

  return 0;
}

uint64_t nw_protocol_common_get_output_local_endpoint(uint64_t a1)
{
  v48 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v1 = *(a1 + 32);
    if (v1)
    {
      v2 = *(v1 + 40);
      v3 = *(a1 + 32);
      if (v2 == &nw_protocol_ref_counted_handle || v2 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v1 + 64)) != 0)
      {
        v14 = *(v3 + 88);
        if (v14)
        {
          v4 = 0;
          *(v3 + 88) = v14 + 1;
          v5 = *(v1 + 24);
          if (!v5)
          {
            goto LABEL_44;
          }
        }

        else
        {
          v4 = 0;
          v5 = *(v1 + 24);
          if (!v5)
          {
            goto LABEL_44;
          }
        }
      }

      else
      {
        v4 = 1;
        v5 = *(v1 + 24);
        if (!v5)
        {
          goto LABEL_44;
        }
      }

      v15 = *(v5 + 200);
      if (v15)
      {
        result = v15(v1);
        if (v4)
        {
          return result;
        }

        goto LABEL_23;
      }

LABEL_44:
      __nwlog_obj();
      v25 = *(v1 + 16);
      *buf = 136446722;
      v41 = "__nw_protocol_get_output_local_endpoint";
      if (!v25)
      {
        v25 = "invalid";
      }

      v42 = 2082;
      v43 = v25;
      v44 = 2048;
      v45 = v1;
      v26 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v38 = 0;
      if (__nwlog_fault(v26, &type, &v38))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v27 = __nwlog_obj();
          v28 = type;
          if (!os_log_type_enabled(v27, type))
          {
            goto LABEL_80;
          }

          v29 = *(v1 + 16);
          if (!v29)
          {
            v29 = "invalid";
          }

          *buf = 136446722;
          v41 = "__nw_protocol_get_output_local_endpoint";
          v42 = 2082;
          v43 = v29;
          v44 = 2048;
          v45 = v1;
          v30 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback";
LABEL_79:
          _os_log_impl(&dword_181A37000, v27, v28, v30, buf, 0x20u);
          goto LABEL_80;
        }

        if (v38 != 1)
        {
          v27 = __nwlog_obj();
          v28 = type;
          if (!os_log_type_enabled(v27, type))
          {
            goto LABEL_80;
          }

          v36 = *(v1 + 16);
          if (!v36)
          {
            v36 = "invalid";
          }

          *buf = 136446722;
          v41 = "__nw_protocol_get_output_local_endpoint";
          v42 = 2082;
          v43 = v36;
          v44 = 2048;
          v45 = v1;
          v30 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, backtrace limit exceeded";
          goto LABEL_79;
        }

        backtrace_string = __nw_create_backtrace_string();
        v27 = __nwlog_obj();
        v28 = type;
        v32 = os_log_type_enabled(v27, type);
        if (!backtrace_string)
        {
          if (!v32)
          {
            goto LABEL_80;
          }

          v37 = *(v1 + 16);
          if (!v37)
          {
            v37 = "invalid";
          }

          *buf = 136446722;
          v41 = "__nw_protocol_get_output_local_endpoint";
          v42 = 2082;
          v43 = v37;
          v44 = 2048;
          v45 = v1;
          v30 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, no backtrace";
          goto LABEL_79;
        }

        if (v32)
        {
          if (*(v1 + 16))
          {
            v33 = *(v1 + 16);
          }

          else
          {
            v33 = "invalid";
          }

          *buf = 136446978;
          v41 = "__nw_protocol_get_output_local_endpoint";
          v42 = 2082;
          v43 = v33;
          v44 = 2048;
          v45 = v1;
          v46 = 2082;
          v47 = backtrace_string;
          _os_log_impl(&dword_181A37000, v27, v28, "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(backtrace_string);
      }

LABEL_80:
      if (v26)
      {
        free(v26);
      }

      result = 0;
      if (v4)
      {
        return result;
      }

LABEL_23:
      v17 = *(v1 + 40);
      if (v17 == &nw_protocol_ref_counted_handle || v17 == &nw_protocol_ref_counted_additional_handle && (v1 = *(v1 + 64)) != 0)
      {
        v18 = *(v1 + 88);
        if (v18)
        {
          v19 = v18 - 1;
          *(v1 + 88) = v19;
          if (!v19)
          {
            v20 = result;
            v21 = *(v1 + 64);
            if (v21)
            {
              *(v1 + 64) = 0;
              v21[2](v21);
              _Block_release(v21);
            }

            if (*(v1 + 72))
            {
              v22 = *(v1 + 64);
              if (v22)
              {
                _Block_release(v22);
              }
            }

            free(v1);
            return v20;
          }
        }
      }

      return result;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v41 = "nw_protocol_common_get_output_local_endpoint";
    v6 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v6, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (os_log_type_enabled(gLogObj, type))
        {
          *buf = 136446210;
          v41 = "nw_protocol_common_get_output_local_endpoint";
          v9 = "%{public}s get_output_local_endpoint requires an output handler";
LABEL_36:
          v23 = v7;
          v24 = v8;
LABEL_37:
          _os_log_impl(&dword_181A37000, v23, v24, v9, buf, 0xCu);
        }
      }

      else if (v38 == 1)
      {
        v10 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v12 = type;
        v13 = os_log_type_enabled(gLogObj, type);
        if (v10)
        {
          if (v13)
          {
            *buf = 136446466;
            v41 = "nw_protocol_common_get_output_local_endpoint";
            v42 = 2082;
            v43 = v10;
            _os_log_impl(&dword_181A37000, v11, v12, "%{public}s get_output_local_endpoint requires an output handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v10);
          goto LABEL_38;
        }

        if (v13)
        {
          *buf = 136446210;
          v41 = "nw_protocol_common_get_output_local_endpoint";
          v9 = "%{public}s get_output_local_endpoint requires an output handler, no backtrace";
          v23 = v11;
          v24 = v12;
          goto LABEL_37;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (os_log_type_enabled(gLogObj, type))
        {
          *buf = 136446210;
          v41 = "nw_protocol_common_get_output_local_endpoint";
          v9 = "%{public}s get_output_local_endpoint requires an output handler, backtrace limit exceeded";
          goto LABEL_36;
        }
      }
    }
  }

  else
  {
    __nwlog_obj();
    *buf = 136446210;
    v41 = "nw_protocol_common_get_output_local_endpoint";
    v6 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v6, &type, &v38))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_38;
      }

      *buf = 136446210;
      v41 = "nw_protocol_common_get_output_local_endpoint";
      v9 = "%{public}s called with null protocol";
      goto LABEL_36;
    }

    if (v38 != 1)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_38;
      }

      *buf = 136446210;
      v41 = "nw_protocol_common_get_output_local_endpoint";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_36;
    }

    v34 = __nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v35 = os_log_type_enabled(v7, type);
    if (v34)
    {
      if (v35)
      {
        *buf = 136446466;
        v41 = "nw_protocol_common_get_output_local_endpoint";
        v42 = 2082;
        v43 = v34;
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v34);
      goto LABEL_38;
    }

    if (v35)
    {
      *buf = 136446210;
      v41 = "nw_protocol_common_get_output_local_endpoint";
      v9 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_36;
    }
  }

LABEL_38:
  if (v6)
  {
    free(v6);
  }

  return 0;
}

uint64_t nw_protocol_common_get_output_interface(uint64_t a1)
{
  v48 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v1 = *(a1 + 32);
    if (v1)
    {
      v2 = *(v1 + 40);
      v3 = *(a1 + 32);
      if (v2 == &nw_protocol_ref_counted_handle || v2 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v1 + 64)) != 0)
      {
        v14 = *(v3 + 88);
        if (v14)
        {
          v4 = 0;
          *(v3 + 88) = v14 + 1;
          v5 = *(v1 + 24);
          if (!v5)
          {
            goto LABEL_44;
          }
        }

        else
        {
          v4 = 0;
          v5 = *(v1 + 24);
          if (!v5)
          {
            goto LABEL_44;
          }
        }
      }

      else
      {
        v4 = 1;
        v5 = *(v1 + 24);
        if (!v5)
        {
          goto LABEL_44;
        }
      }

      v15 = *(v5 + 208);
      if (v15)
      {
        result = v15(v1);
        if (v4)
        {
          return result;
        }

        goto LABEL_23;
      }

LABEL_44:
      __nwlog_obj();
      v25 = *(v1 + 16);
      *buf = 136446722;
      v41 = "__nw_protocol_get_output_interface";
      if (!v25)
      {
        v25 = "invalid";
      }

      v42 = 2082;
      v43 = v25;
      v44 = 2048;
      v45 = v1;
      v26 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v38 = 0;
      if (__nwlog_fault(v26, &type, &v38))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v27 = __nwlog_obj();
          v28 = type;
          if (!os_log_type_enabled(v27, type))
          {
            goto LABEL_80;
          }

          v29 = *(v1 + 16);
          if (!v29)
          {
            v29 = "invalid";
          }

          *buf = 136446722;
          v41 = "__nw_protocol_get_output_interface";
          v42 = 2082;
          v43 = v29;
          v44 = 2048;
          v45 = v1;
          v30 = "%{public}s protocol %{public}s (%p) has invalid get_output_interface callback";
LABEL_79:
          _os_log_impl(&dword_181A37000, v27, v28, v30, buf, 0x20u);
          goto LABEL_80;
        }

        if (v38 != 1)
        {
          v27 = __nwlog_obj();
          v28 = type;
          if (!os_log_type_enabled(v27, type))
          {
            goto LABEL_80;
          }

          v36 = *(v1 + 16);
          if (!v36)
          {
            v36 = "invalid";
          }

          *buf = 136446722;
          v41 = "__nw_protocol_get_output_interface";
          v42 = 2082;
          v43 = v36;
          v44 = 2048;
          v45 = v1;
          v30 = "%{public}s protocol %{public}s (%p) has invalid get_output_interface callback, backtrace limit exceeded";
          goto LABEL_79;
        }

        backtrace_string = __nw_create_backtrace_string();
        v27 = __nwlog_obj();
        v28 = type;
        v32 = os_log_type_enabled(v27, type);
        if (!backtrace_string)
        {
          if (!v32)
          {
            goto LABEL_80;
          }

          v37 = *(v1 + 16);
          if (!v37)
          {
            v37 = "invalid";
          }

          *buf = 136446722;
          v41 = "__nw_protocol_get_output_interface";
          v42 = 2082;
          v43 = v37;
          v44 = 2048;
          v45 = v1;
          v30 = "%{public}s protocol %{public}s (%p) has invalid get_output_interface callback, no backtrace";
          goto LABEL_79;
        }

        if (v32)
        {
          if (*(v1 + 16))
          {
            v33 = *(v1 + 16);
          }

          else
          {
            v33 = "invalid";
          }

          *buf = 136446978;
          v41 = "__nw_protocol_get_output_interface";
          v42 = 2082;
          v43 = v33;
          v44 = 2048;
          v45 = v1;
          v46 = 2082;
          v47 = backtrace_string;
          _os_log_impl(&dword_181A37000, v27, v28, "%{public}s protocol %{public}s (%p) has invalid get_output_interface callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(backtrace_string);
      }

LABEL_80:
      if (v26)
      {
        free(v26);
      }

      result = 0;
      if (v4)
      {
        return result;
      }

LABEL_23:
      v17 = *(v1 + 40);
      if (v17 == &nw_protocol_ref_counted_handle || v17 == &nw_protocol_ref_counted_additional_handle && (v1 = *(v1 + 64)) != 0)
      {
        v18 = *(v1 + 88);
        if (v18)
        {
          v19 = v18 - 1;
          *(v1 + 88) = v19;
          if (!v19)
          {
            v20 = result;
            v21 = *(v1 + 64);
            if (v21)
            {
              *(v1 + 64) = 0;
              v21[2](v21);
              _Block_release(v21);
            }

            if (*(v1 + 72))
            {
              v22 = *(v1 + 64);
              if (v22)
              {
                _Block_release(v22);
              }
            }

            free(v1);
            return v20;
          }
        }
      }

      return result;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v41 = "nw_protocol_common_get_output_interface";
    v6 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v6, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (os_log_type_enabled(gLogObj, type))
        {
          *buf = 136446210;
          v41 = "nw_protocol_common_get_output_interface";
          v9 = "%{public}s get_output_interface requires an output handler";
LABEL_36:
          v23 = v7;
          v24 = v8;
LABEL_37:
          _os_log_impl(&dword_181A37000, v23, v24, v9, buf, 0xCu);
        }
      }

      else if (v38 == 1)
      {
        v10 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v12 = type;
        v13 = os_log_type_enabled(gLogObj, type);
        if (v10)
        {
          if (v13)
          {
            *buf = 136446466;
            v41 = "nw_protocol_common_get_output_interface";
            v42 = 2082;
            v43 = v10;
            _os_log_impl(&dword_181A37000, v11, v12, "%{public}s get_output_interface requires an output handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v10);
          goto LABEL_38;
        }

        if (v13)
        {
          *buf = 136446210;
          v41 = "nw_protocol_common_get_output_interface";
          v9 = "%{public}s get_output_interface requires an output handler, no backtrace";
          v23 = v11;
          v24 = v12;
          goto LABEL_37;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (os_log_type_enabled(gLogObj, type))
        {
          *buf = 136446210;
          v41 = "nw_protocol_common_get_output_interface";
          v9 = "%{public}s get_output_interface requires an output handler, backtrace limit exceeded";
          goto LABEL_36;
        }
      }
    }
  }

  else
  {
    __nwlog_obj();
    *buf = 136446210;
    v41 = "nw_protocol_common_get_output_interface";
    v6 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v6, &type, &v38))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_38;
      }

      *buf = 136446210;
      v41 = "nw_protocol_common_get_output_interface";
      v9 = "%{public}s called with null protocol";
      goto LABEL_36;
    }

    if (v38 != 1)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_38;
      }

      *buf = 136446210;
      v41 = "nw_protocol_common_get_output_interface";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_36;
    }

    v34 = __nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v35 = os_log_type_enabled(v7, type);
    if (v34)
    {
      if (v35)
      {
        *buf = 136446466;
        v41 = "nw_protocol_common_get_output_interface";
        v42 = 2082;
        v43 = v34;
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v34);
      goto LABEL_38;
    }

    if (v35)
    {
      *buf = 136446210;
      v41 = "nw_protocol_common_get_output_interface";
      v9 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_36;
    }
  }

LABEL_38:
  if (v6)
  {
    free(v6);
  }

  return 0;
}

uint64_t nw_protocol_common_reset(void *a1, uint64_t a2)
{
  v62 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v55 = "nw_protocol_common_reset";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (!__nwlog_fault(v7, &type, &v52))
    {
      goto LABEL_57;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_57;
      }

      *buf = 136446210;
      v55 = "nw_protocol_common_reset";
      v10 = "%{public}s called with null protocol";
      goto LABEL_55;
    }

    if (v52 != 1)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_57;
      }

      *buf = 136446210;
      v55 = "nw_protocol_common_reset";
      v10 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_55;
    }

    backtrace_string = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v47 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (!v47)
      {
        goto LABEL_57;
      }

      *buf = 136446210;
      v55 = "nw_protocol_common_reset";
      v10 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_55;
    }

    if (v47)
    {
      *buf = 136446466;
      v55 = "nw_protocol_common_reset";
      v56 = 2082;
      v57 = backtrace_string;
      v48 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_94:
      _os_log_impl(&dword_181A37000, v8, v9, v48, buf, 0x16u);
    }

LABEL_95:
    free(backtrace_string);
    goto LABEL_57;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v55 = "nw_protocol_common_reset";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (!__nwlog_fault(v7, &type, &v52))
    {
      goto LABEL_57;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_57;
      }

      *buf = 136446210;
      v55 = "nw_protocol_common_reset";
      v10 = "%{public}s called with null other_protocol";
      goto LABEL_55;
    }

    if (v52 != 1)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_57;
      }

      *buf = 136446210;
      v55 = "nw_protocol_common_reset";
      v10 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_55;
    }

    backtrace_string = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v49 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (!v49)
      {
        goto LABEL_57;
      }

      *buf = 136446210;
      v55 = "nw_protocol_common_reset";
      v10 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_55;
    }

    if (v49)
    {
      *buf = 136446466;
      v55 = "nw_protocol_common_reset";
      v56 = 2082;
      v57 = backtrace_string;
      v48 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_94;
    }

    goto LABEL_95;
  }

  v2 = a1;
  v3 = a1[4];
  if (v3)
  {
    v4 = *(v3 + 40);
    v5 = a1[4];
    if (v4 == &nw_protocol_ref_counted_handle || v4 == &nw_protocol_ref_counted_additional_handle && (v5 = *(v3 + 64)) != 0)
    {
      v15 = *(v5 + 88);
      v6 = 0;
      if (v15)
      {
        *(v5 + 88) = v15 + 1;
      }
    }

    else
    {
      v6 = 1;
    }

    v16 = a1[5];
    v17 = a1;
    if (v16 == &nw_protocol_ref_counted_handle || v16 == &nw_protocol_ref_counted_additional_handle && (v17 = a1[8]) != 0)
    {
      v20 = v17[11];
      if (v20)
      {
        v18 = 0;
        v17[11] = v20 + 1;
        v19 = *(v3 + 24);
        if (!v19)
        {
          goto LABEL_63;
        }
      }

      else
      {
        v18 = 0;
        v19 = *(v3 + 24);
        if (!v19)
        {
          goto LABEL_63;
        }
      }
    }

    else
    {
      v18 = 1;
      v19 = *(v3 + 24);
      if (!v19)
      {
        goto LABEL_63;
      }
    }

    v21 = *(v19 + 256);
    if (v21)
    {
      result = v21(v3, a1);
      if (v18)
      {
LABEL_41:
        if ((v6 & 1) == 0)
        {
          v29 = *(v3 + 40);
          if (v29 == &nw_protocol_ref_counted_handle || v29 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
          {
            v30 = *(v3 + 88);
            if (v30)
            {
              v31 = v30 - 1;
              *(v3 + 88) = v31;
              if (!v31)
              {
                v32 = result;
                v33 = *(v3 + 64);
                if (v33)
                {
                  *(v3 + 64) = 0;
                  v33[2](v33);
                  _Block_release(v33);
                }

                if (*(v3 + 72))
                {
                  v34 = *(v3 + 64);
                  if (v34)
                  {
                    _Block_release(v34);
                  }
                }

                free(v3);
                return v32;
              }
            }
          }
        }

        return result;
      }

LABEL_30:
      v23 = v2[5];
      if (v23 == &nw_protocol_ref_counted_handle || v23 == &nw_protocol_ref_counted_additional_handle && (v2 = v2[8]) != 0)
      {
        v24 = v2[11];
        if (v24)
        {
          v25 = v24 - 1;
          v2[11] = v25;
          if (!v25)
          {
            v26 = result;
            v27 = v2[8];
            if (v27)
            {
              v2[8] = 0;
              v27[2](v27);
              _Block_release(v27);
            }

            if (v2[9])
            {
              v28 = v2[8];
              if (v28)
              {
                _Block_release(v28);
              }
            }

            free(v2);
            result = v26;
          }
        }
      }

      goto LABEL_41;
    }

LABEL_63:
    __nwlog_obj();
    v37 = *(v3 + 16);
    *buf = 136446722;
    v55 = "__nw_protocol_reset";
    if (!v37)
    {
      v37 = "invalid";
    }

    v56 = 2082;
    v57 = v37;
    v58 = 2048;
    v59 = v3;
    v38 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (__nwlog_fault(v38, &type, &v52))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v39 = __nwlog_obj();
        v40 = type;
        if (!os_log_type_enabled(v39, type))
        {
          goto LABEL_109;
        }

        v41 = *(v3 + 16);
        if (!v41)
        {
          v41 = "invalid";
        }

        *buf = 136446722;
        v55 = "__nw_protocol_reset";
        v56 = 2082;
        v57 = v41;
        v58 = 2048;
        v59 = v3;
        v42 = "%{public}s protocol %{public}s (%p) has invalid reset callback";
LABEL_108:
        _os_log_impl(&dword_181A37000, v39, v40, v42, buf, 0x20u);
        goto LABEL_109;
      }

      if (v52 != 1)
      {
        v39 = __nwlog_obj();
        v40 = type;
        if (!os_log_type_enabled(v39, type))
        {
          goto LABEL_109;
        }

        v50 = *(v3 + 16);
        if (!v50)
        {
          v50 = "invalid";
        }

        *buf = 136446722;
        v55 = "__nw_protocol_reset";
        v56 = 2082;
        v57 = v50;
        v58 = 2048;
        v59 = v3;
        v42 = "%{public}s protocol %{public}s (%p) has invalid reset callback, backtrace limit exceeded";
        goto LABEL_108;
      }

      v43 = __nw_create_backtrace_string();
      v39 = __nwlog_obj();
      v40 = type;
      v44 = os_log_type_enabled(v39, type);
      if (!v43)
      {
        if (!v44)
        {
          goto LABEL_109;
        }

        v51 = *(v3 + 16);
        if (!v51)
        {
          v51 = "invalid";
        }

        *buf = 136446722;
        v55 = "__nw_protocol_reset";
        v56 = 2082;
        v57 = v51;
        v58 = 2048;
        v59 = v3;
        v42 = "%{public}s protocol %{public}s (%p) has invalid reset callback, no backtrace";
        goto LABEL_108;
      }

      if (v44)
      {
        v45 = *(v3 + 16);
        if (!v45)
        {
          v45 = "invalid";
        }

        *buf = 136446978;
        v55 = "__nw_protocol_reset";
        v56 = 2082;
        v57 = v45;
        v58 = 2048;
        v59 = v3;
        v60 = 2082;
        v61 = v43;
        _os_log_impl(&dword_181A37000, v39, v40, "%{public}s protocol %{public}s (%p) has invalid reset callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v43);
    }

LABEL_109:
    if (v38)
    {
      free(v38);
    }

    result = 0;
    if (v18)
    {
      goto LABEL_41;
    }

    goto LABEL_30;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446210;
  v55 = "nw_protocol_common_reset";
  v7 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v52 = 0;
  if (__nwlog_fault(v7, &type, &v52))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (os_log_type_enabled(gLogObj, type))
      {
        *buf = 136446210;
        v55 = "nw_protocol_common_reset";
        v10 = "%{public}s reset requires an output handler";
LABEL_55:
        v35 = v8;
        v36 = v9;
LABEL_56:
        _os_log_impl(&dword_181A37000, v35, v36, v10, buf, 0xCu);
      }
    }

    else if (v52 == 1)
    {
      v11 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      v14 = os_log_type_enabled(gLogObj, type);
      if (v11)
      {
        if (v14)
        {
          *buf = 136446466;
          v55 = "nw_protocol_common_reset";
          v56 = 2082;
          v57 = v11;
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s reset requires an output handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v11);
        goto LABEL_57;
      }

      if (v14)
      {
        *buf = 136446210;
        v55 = "nw_protocol_common_reset";
        v10 = "%{public}s reset requires an output handler, no backtrace";
        v35 = v12;
        v36 = v13;
        goto LABEL_56;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (os_log_type_enabled(gLogObj, type))
      {
        *buf = 136446210;
        v55 = "nw_protocol_common_reset";
        v10 = "%{public}s reset requires an output handler, backtrace limit exceeded";
        goto LABEL_55;
      }
    }
  }

LABEL_57:
  if (v7)
  {
    free(v7);
  }

  return 0;
}

void nw_protocol_common_disconnect(void *a1, uint64_t a2)
{
  v58 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v51 = "nw_protocol_common_disconnect";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v3, &type, &v48))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_disconnect";
      v9 = "%{public}s called with null protocol";
      goto LABEL_56;
    }

    if (v48 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v43 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (!v43)
        {
          goto LABEL_95;
        }

        *buf = 136446466;
        v51 = "nw_protocol_common_disconnect";
        v52 = 2082;
        v53 = backtrace_string;
        v44 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_94;
      }

      if (!v43)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_disconnect";
      v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_disconnect";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_56:
    v31 = v7;
    v32 = v8;
LABEL_57:
    _os_log_impl(&dword_181A37000, v31, v32, v9, buf, 0xCu);
    goto LABEL_58;
  }

  if (a2)
  {
    v2 = a1;
    v3 = a1[4];
    if (v3)
    {
      v4 = *(v3 + 40);
      v5 = a1[4];
      if (v4 == &nw_protocol_ref_counted_handle || v4 == &nw_protocol_ref_counted_additional_handle && (v5 = *(v3 + 64)) != 0)
      {
        v14 = *(v5 + 88);
        v6 = 0;
        if (v14)
        {
          *(v5 + 88) = v14 + 1;
        }
      }

      else
      {
        v6 = 1;
      }

      v15 = a1[5];
      v16 = a1;
      if (v15 == &nw_protocol_ref_counted_handle || v15 == &nw_protocol_ref_counted_additional_handle && (v16 = a1[8]) != 0)
      {
        v19 = v16[11];
        if (v19)
        {
          v17 = 0;
          v16[11] = v19 + 1;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }

        else
        {
          v17 = 0;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }
      }

      else
      {
        v17 = 1;
        v18 = *(v3 + 24);
        if (!v18)
        {
          goto LABEL_63;
        }
      }

      v20 = *(v18 + 32);
      if (v20)
      {
        v20(v3, a1);
        goto LABEL_31;
      }

LABEL_63:
      __nwlog_obj();
      v33 = *(v3 + 16);
      *buf = 136446722;
      v51 = "__nw_protocol_disconnect";
      if (!v33)
      {
        v33 = "invalid";
      }

      v52 = 2082;
      v53 = v33;
      v54 = 2048;
      v55 = v3;
      v34 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v48 = 0;
      if (!__nwlog_fault(v34, &type, &v48))
      {
        goto LABEL_110;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v37 = *(v3 + 16);
        if (!v37)
        {
          v37 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_disconnect";
        v52 = 2082;
        v53 = v37;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback";
      }

      else if (v48 == 1)
      {
        v39 = __nw_create_backtrace_string();
        v35 = __nwlog_obj();
        v36 = type;
        v40 = os_log_type_enabled(v35, type);
        if (v39)
        {
          if (v40)
          {
            v41 = *(v3 + 16);
            if (!v41)
            {
              v41 = "invalid";
            }

            *buf = 136446978;
            v51 = "__nw_protocol_disconnect";
            v52 = 2082;
            v53 = v41;
            v54 = 2048;
            v55 = v3;
            v56 = 2082;
            v57 = v39;
            _os_log_impl(&dword_181A37000, v35, v36, "%{public}s protocol %{public}s (%p) has invalid disconnect callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v39);
          goto LABEL_110;
        }

        if (!v40)
        {
LABEL_110:
          if (v34)
          {
            free(v34);
          }

LABEL_31:
          if ((v17 & 1) == 0)
          {
            v21 = v2[5];
            if (v21 == &nw_protocol_ref_counted_handle || v21 == &nw_protocol_ref_counted_additional_handle && (v2 = v2[8]) != 0)
            {
              v22 = v2[11];
              if (v22)
              {
                v23 = v22 - 1;
                v2[11] = v23;
                if (!v23)
                {
                  v24 = v2[8];
                  if (v24)
                  {
                    v2[8] = 0;
                    v24[2](v24);
                    _Block_release(v24);
                  }

                  if (v2[9])
                  {
                    v25 = v2[8];
                    if (v25)
                    {
                      _Block_release(v25);
                    }
                  }

                  free(v2);
                }
              }
            }
          }

          if ((v6 & 1) == 0)
          {
            v26 = *(v3 + 40);
            if (v26 == &nw_protocol_ref_counted_handle || v26 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
            {
              v27 = *(v3 + 88);
              if (v27)
              {
                v28 = v27 - 1;
                *(v3 + 88) = v28;
                if (!v28)
                {
                  v29 = *(v3 + 64);
                  if (v29)
                  {
                    *(v3 + 64) = 0;
                    v29[2](v29);
                    _Block_release(v29);
                  }

                  if (*(v3 + 72))
                  {
                    v30 = *(v3 + 64);
                    if (v30)
                    {
                      _Block_release(v30);
                    }
                  }

                  goto LABEL_59;
                }
              }
            }
          }

          return;
        }

        v47 = *(v3 + 16);
        if (!v47)
        {
          v47 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_disconnect";
        v52 = 2082;
        v53 = v47;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, no backtrace";
      }

      else
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v46 = *(v3 + 16);
        if (!v46)
        {
          v46 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_disconnect";
        v52 = 2082;
        v53 = v46;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A37000, v35, v36, v38, buf, 0x20u);
      goto LABEL_110;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v51 = "nw_protocol_common_disconnect";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (__nwlog_fault(v3, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_disconnect";
        v9 = "%{public}s disconnect requires an output handler";
        goto LABEL_56;
      }

      if (v48 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_disconnect";
        v9 = "%{public}s disconnect requires an output handler, backtrace limit exceeded";
        goto LABEL_56;
      }

      v10 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(gLogObj, type);
      if (v10)
      {
        if (v13)
        {
          *buf = 136446466;
          v51 = "nw_protocol_common_disconnect";
          v52 = 2082;
          v53 = v10;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s disconnect requires an output handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v10);
        if (v3)
        {
          goto LABEL_59;
        }

        return;
      }

      if (v13)
      {
        *buf = 136446210;
        v51 = "nw_protocol_common_disconnect";
        v9 = "%{public}s disconnect requires an output handler, no backtrace";
        v31 = v11;
        v32 = v12;
        goto LABEL_57;
      }
    }

LABEL_58:
    if (!v3)
    {
      return;
    }

    goto LABEL_59;
  }

  __nwlog_obj();
  *buf = 136446210;
  v51 = "nw_protocol_common_disconnect";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (!__nwlog_fault(v3, &type, &v48))
  {
    goto LABEL_58;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_disconnect";
    v9 = "%{public}s called with null other_protocol";
    goto LABEL_56;
  }

  if (v48 != 1)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_disconnect";
    v9 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_56;
  }

  backtrace_string = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v45 = os_log_type_enabled(v7, type);
  if (!backtrace_string)
  {
    if (!v45)
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_disconnect";
    v9 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_56;
  }

  if (!v45)
  {
    goto LABEL_95;
  }

  *buf = 136446466;
  v51 = "nw_protocol_common_disconnect";
  v52 = 2082;
  v53 = backtrace_string;
  v44 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_94:
  _os_log_impl(&dword_181A37000, v7, v8, v44, buf, 0x16u);
LABEL_95:
  free(backtrace_string);
  if (v3)
  {
LABEL_59:
    free(v3);
  }
}

void nw_protocol_common_input_available(void *a1, uint64_t a2)
{
  v58 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v51 = "nw_protocol_common_input_available";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v3, &type, &v48))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_input_available";
      v9 = "%{public}s called with null protocol";
      goto LABEL_56;
    }

    if (v48 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v43 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (!v43)
        {
          goto LABEL_95;
        }

        *buf = 136446466;
        v51 = "nw_protocol_common_input_available";
        v52 = 2082;
        v53 = backtrace_string;
        v44 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_94;
      }

      if (!v43)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_input_available";
      v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_input_available";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_56:
    v31 = v7;
    v32 = v8;
LABEL_57:
    _os_log_impl(&dword_181A37000, v31, v32, v9, buf, 0xCu);
    goto LABEL_58;
  }

  if (a2)
  {
    v2 = a1;
    v3 = a1[6];
    if (v3)
    {
      v4 = *(v3 + 40);
      v5 = a1[6];
      if (v4 == &nw_protocol_ref_counted_handle || v4 == &nw_protocol_ref_counted_additional_handle && (v5 = *(v3 + 64)) != 0)
      {
        v14 = *(v5 + 88);
        v6 = 0;
        if (v14)
        {
          *(v5 + 88) = v14 + 1;
        }
      }

      else
      {
        v6 = 1;
      }

      v15 = a1[5];
      v16 = a1;
      if (v15 == &nw_protocol_ref_counted_handle || v15 == &nw_protocol_ref_counted_additional_handle && (v16 = a1[8]) != 0)
      {
        v19 = v16[11];
        if (v19)
        {
          v17 = 0;
          v16[11] = v19 + 1;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }

        else
        {
          v17 = 0;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }
      }

      else
      {
        v17 = 1;
        v18 = *(v3 + 24);
        if (!v18)
        {
          goto LABEL_63;
        }
      }

      v20 = *(v18 + 64);
      if (v20)
      {
        v20(v3, a1);
        goto LABEL_31;
      }

LABEL_63:
      __nwlog_obj();
      v33 = *(v3 + 16);
      *buf = 136446722;
      v51 = "__nw_protocol_input_available";
      if (!v33)
      {
        v33 = "invalid";
      }

      v52 = 2082;
      v53 = v33;
      v54 = 2048;
      v55 = v3;
      v34 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v48 = 0;
      if (!__nwlog_fault(v34, &type, &v48))
      {
        goto LABEL_110;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v37 = *(v3 + 16);
        if (!v37)
        {
          v37 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_input_available";
        v52 = 2082;
        v53 = v37;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid input_available callback";
      }

      else if (v48 == 1)
      {
        v39 = __nw_create_backtrace_string();
        v35 = __nwlog_obj();
        v36 = type;
        v40 = os_log_type_enabled(v35, type);
        if (v39)
        {
          if (v40)
          {
            v41 = *(v3 + 16);
            if (!v41)
            {
              v41 = "invalid";
            }

            *buf = 136446978;
            v51 = "__nw_protocol_input_available";
            v52 = 2082;
            v53 = v41;
            v54 = 2048;
            v55 = v3;
            v56 = 2082;
            v57 = v39;
            _os_log_impl(&dword_181A37000, v35, v36, "%{public}s protocol %{public}s (%p) has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v39);
          goto LABEL_110;
        }

        if (!v40)
        {
LABEL_110:
          if (v34)
          {
            free(v34);
          }

LABEL_31:
          if ((v17 & 1) == 0)
          {
            v21 = v2[5];
            if (v21 == &nw_protocol_ref_counted_handle || v21 == &nw_protocol_ref_counted_additional_handle && (v2 = v2[8]) != 0)
            {
              v22 = v2[11];
              if (v22)
              {
                v23 = v22 - 1;
                v2[11] = v23;
                if (!v23)
                {
                  v24 = v2[8];
                  if (v24)
                  {
                    v2[8] = 0;
                    v24[2](v24);
                    _Block_release(v24);
                  }

                  if (v2[9])
                  {
                    v25 = v2[8];
                    if (v25)
                    {
                      _Block_release(v25);
                    }
                  }

                  free(v2);
                }
              }
            }
          }

          if ((v6 & 1) == 0)
          {
            v26 = *(v3 + 40);
            if (v26 == &nw_protocol_ref_counted_handle || v26 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
            {
              v27 = *(v3 + 88);
              if (v27)
              {
                v28 = v27 - 1;
                *(v3 + 88) = v28;
                if (!v28)
                {
                  v29 = *(v3 + 64);
                  if (v29)
                  {
                    *(v3 + 64) = 0;
                    v29[2](v29);
                    _Block_release(v29);
                  }

                  if (*(v3 + 72))
                  {
                    v30 = *(v3 + 64);
                    if (v30)
                    {
                      _Block_release(v30);
                    }
                  }

                  goto LABEL_59;
                }
              }
            }
          }

          return;
        }

        v47 = *(v3 + 16);
        if (!v47)
        {
          v47 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_input_available";
        v52 = 2082;
        v53 = v47;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, no backtrace";
      }

      else
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v46 = *(v3 + 16);
        if (!v46)
        {
          v46 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_input_available";
        v52 = 2082;
        v53 = v46;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A37000, v35, v36, v38, buf, 0x20u);
      goto LABEL_110;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v51 = "nw_protocol_common_input_available";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (__nwlog_fault(v3, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_input_available";
        v9 = "%{public}s input_available requires a default input handler";
        goto LABEL_56;
      }

      if (v48 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_input_available";
        v9 = "%{public}s input_available requires a default input handler, backtrace limit exceeded";
        goto LABEL_56;
      }

      v10 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(gLogObj, type);
      if (v10)
      {
        if (v13)
        {
          *buf = 136446466;
          v51 = "nw_protocol_common_input_available";
          v52 = 2082;
          v53 = v10;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s input_available requires a default input handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v10);
        if (v3)
        {
          goto LABEL_59;
        }

        return;
      }

      if (v13)
      {
        *buf = 136446210;
        v51 = "nw_protocol_common_input_available";
        v9 = "%{public}s input_available requires a default input handler, no backtrace";
        v31 = v11;
        v32 = v12;
        goto LABEL_57;
      }
    }

LABEL_58:
    if (!v3)
    {
      return;
    }

    goto LABEL_59;
  }

  __nwlog_obj();
  *buf = 136446210;
  v51 = "nw_protocol_common_input_available";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (!__nwlog_fault(v3, &type, &v48))
  {
    goto LABEL_58;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_input_available";
    v9 = "%{public}s called with null other_protocol";
    goto LABEL_56;
  }

  if (v48 != 1)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_input_available";
    v9 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_56;
  }

  backtrace_string = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v45 = os_log_type_enabled(v7, type);
  if (!backtrace_string)
  {
    if (!v45)
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_input_available";
    v9 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_56;
  }

  if (!v45)
  {
    goto LABEL_95;
  }

  *buf = 136446466;
  v51 = "nw_protocol_common_input_available";
  v52 = 2082;
  v53 = backtrace_string;
  v44 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_94:
  _os_log_impl(&dword_181A37000, v7, v8, v44, buf, 0x16u);
LABEL_95:
  free(backtrace_string);
  if (v3)
  {
LABEL_59:
    free(v3);
  }
}

void nw_protocol_common_output_available(uint64_t a1, uint64_t a2)
{
  v58 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v51 = "nw_protocol_common_output_available";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v3, &type, &v48))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_output_available";
      v9 = "%{public}s called with null protocol";
      goto LABEL_56;
    }

    if (v48 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v43 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (!v43)
        {
          goto LABEL_95;
        }

        *buf = 136446466;
        v51 = "nw_protocol_common_output_available";
        v52 = 2082;
        v53 = backtrace_string;
        v44 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_94;
      }

      if (!v43)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_output_available";
      v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_output_available";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_56:
    v31 = v7;
    v32 = v8;
LABEL_57:
    _os_log_impl(&dword_181A37000, v31, v32, v9, buf, 0xCu);
    goto LABEL_58;
  }

  v2 = a2;
  if (a2)
  {
    v3 = *(a1 + 48);
    if (v3)
    {
      v4 = *(v3 + 40);
      v5 = *(a1 + 48);
      if (v4 == &nw_protocol_ref_counted_handle || v4 == &nw_protocol_ref_counted_additional_handle && (v5 = *(v3 + 64)) != 0)
      {
        v14 = *(v5 + 88);
        v6 = 0;
        if (v14)
        {
          *(v5 + 88) = v14 + 1;
        }
      }

      else
      {
        v6 = 1;
      }

      v15 = *(a2 + 40);
      v16 = a2;
      if (v15 == &nw_protocol_ref_counted_handle || v15 == &nw_protocol_ref_counted_additional_handle && (v16 = *(a2 + 64)) != 0)
      {
        v19 = *(v16 + 88);
        if (v19)
        {
          v17 = 0;
          *(v16 + 88) = v19 + 1;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }

        else
        {
          v17 = 0;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }
      }

      else
      {
        v17 = 1;
        v18 = *(v3 + 24);
        if (!v18)
        {
          goto LABEL_63;
        }
      }

      v20 = *(v18 + 72);
      if (v20)
      {
        v20(v3, a2);
        goto LABEL_31;
      }

LABEL_63:
      __nwlog_obj();
      v33 = *(v3 + 16);
      *buf = 136446722;
      v51 = "__nw_protocol_output_available";
      if (!v33)
      {
        v33 = "invalid";
      }

      v52 = 2082;
      v53 = v33;
      v54 = 2048;
      v55 = v3;
      v34 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v48 = 0;
      if (!__nwlog_fault(v34, &type, &v48))
      {
        goto LABEL_110;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v37 = *(v3 + 16);
        if (!v37)
        {
          v37 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_output_available";
        v52 = 2082;
        v53 = v37;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid output_available callback";
      }

      else if (v48 == 1)
      {
        v39 = __nw_create_backtrace_string();
        v35 = __nwlog_obj();
        v36 = type;
        v40 = os_log_type_enabled(v35, type);
        if (v39)
        {
          if (v40)
          {
            v41 = *(v3 + 16);
            if (!v41)
            {
              v41 = "invalid";
            }

            *buf = 136446978;
            v51 = "__nw_protocol_output_available";
            v52 = 2082;
            v53 = v41;
            v54 = 2048;
            v55 = v3;
            v56 = 2082;
            v57 = v39;
            _os_log_impl(&dword_181A37000, v35, v36, "%{public}s protocol %{public}s (%p) has invalid output_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v39);
          goto LABEL_110;
        }

        if (!v40)
        {
LABEL_110:
          if (v34)
          {
            free(v34);
          }

LABEL_31:
          if ((v17 & 1) == 0)
          {
            v21 = *(v2 + 40);
            if (v21 == &nw_protocol_ref_counted_handle || v21 == &nw_protocol_ref_counted_additional_handle && (v2 = *(v2 + 64)) != 0)
            {
              v22 = *(v2 + 88);
              if (v22)
              {
                v23 = v22 - 1;
                *(v2 + 88) = v23;
                if (!v23)
                {
                  v24 = *(v2 + 64);
                  if (v24)
                  {
                    *(v2 + 64) = 0;
                    v24[2](v24);
                    _Block_release(v24);
                  }

                  if (*(v2 + 72))
                  {
                    v25 = *(v2 + 64);
                    if (v25)
                    {
                      _Block_release(v25);
                    }
                  }

                  free(v2);
                }
              }
            }
          }

          if ((v6 & 1) == 0)
          {
            v26 = *(v3 + 40);
            if (v26 == &nw_protocol_ref_counted_handle || v26 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
            {
              v27 = *(v3 + 88);
              if (v27)
              {
                v28 = v27 - 1;
                *(v3 + 88) = v28;
                if (!v28)
                {
                  v29 = *(v3 + 64);
                  if (v29)
                  {
                    *(v3 + 64) = 0;
                    v29[2](v29);
                    _Block_release(v29);
                  }

                  if (*(v3 + 72))
                  {
                    v30 = *(v3 + 64);
                    if (v30)
                    {
                      _Block_release(v30);
                    }
                  }

                  goto LABEL_59;
                }
              }
            }
          }

          return;
        }

        v47 = *(v3 + 16);
        if (!v47)
        {
          v47 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_output_available";
        v52 = 2082;
        v53 = v47;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, no backtrace";
      }

      else
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v46 = *(v3 + 16);
        if (!v46)
        {
          v46 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_output_available";
        v52 = 2082;
        v53 = v46;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A37000, v35, v36, v38, buf, 0x20u);
      goto LABEL_110;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v51 = "nw_protocol_common_output_available";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (__nwlog_fault(v3, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_output_available";
        v9 = "%{public}s output_available requires a default input handler";
        goto LABEL_56;
      }

      if (v48 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_output_available";
        v9 = "%{public}s output_available requires a default input handler, backtrace limit exceeded";
        goto LABEL_56;
      }

      v10 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(gLogObj, type);
      if (v10)
      {
        if (v13)
        {
          *buf = 136446466;
          v51 = "nw_protocol_common_output_available";
          v52 = 2082;
          v53 = v10;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s output_available requires a default input handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v10);
        if (v3)
        {
          goto LABEL_59;
        }

        return;
      }

      if (v13)
      {
        *buf = 136446210;
        v51 = "nw_protocol_common_output_available";
        v9 = "%{public}s output_available requires a default input handler, no backtrace";
        v31 = v11;
        v32 = v12;
        goto LABEL_57;
      }
    }

LABEL_58:
    if (!v3)
    {
      return;
    }

    goto LABEL_59;
  }

  __nwlog_obj();
  *buf = 136446210;
  v51 = "nw_protocol_common_output_available";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (!__nwlog_fault(v3, &type, &v48))
  {
    goto LABEL_58;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_output_available";
    v9 = "%{public}s called with null other_protocol";
    goto LABEL_56;
  }

  if (v48 != 1)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_output_available";
    v9 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_56;
  }

  backtrace_string = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v45 = os_log_type_enabled(v7, type);
  if (!backtrace_string)
  {
    if (!v45)
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_output_available";
    v9 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_56;
  }

  if (!v45)
  {
    goto LABEL_95;
  }

  *buf = 136446466;
  v51 = "nw_protocol_common_output_available";
  v52 = 2082;
  v53 = backtrace_string;
  v44 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_94:
  _os_log_impl(&dword_181A37000, v7, v8, v44, buf, 0x16u);
LABEL_95:
  free(backtrace_string);
  if (v3)
  {
LABEL_59:
    free(v3);
  }
}

void nw_protocol_common_input_finished(uint64_t a1, uint64_t a2)
{
  v58 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v51 = "nw_protocol_common_input_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v3, &type, &v48))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_input_finished";
      v9 = "%{public}s called with null protocol";
      goto LABEL_56;
    }

    if (v48 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v43 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (!v43)
        {
          goto LABEL_95;
        }

        *buf = 136446466;
        v51 = "nw_protocol_common_input_finished";
        v52 = 2082;
        v53 = backtrace_string;
        v44 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_94;
      }

      if (!v43)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_input_finished";
      v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_input_finished";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_56:
    v31 = v7;
    v32 = v8;
LABEL_57:
    _os_log_impl(&dword_181A37000, v31, v32, v9, buf, 0xCu);
    goto LABEL_58;
  }

  v2 = a2;
  if (a2)
  {
    v3 = *(a1 + 48);
    if (v3)
    {
      v4 = *(v3 + 40);
      v5 = *(a1 + 48);
      if (v4 == &nw_protocol_ref_counted_handle || v4 == &nw_protocol_ref_counted_additional_handle && (v5 = *(v3 + 64)) != 0)
      {
        v14 = *(v5 + 88);
        v6 = 0;
        if (v14)
        {
          *(v5 + 88) = v14 + 1;
        }
      }

      else
      {
        v6 = 1;
      }

      v15 = *(a2 + 40);
      v16 = a2;
      if (v15 == &nw_protocol_ref_counted_handle || v15 == &nw_protocol_ref_counted_additional_handle && (v16 = *(a2 + 64)) != 0)
      {
        v19 = *(v16 + 88);
        if (v19)
        {
          v17 = 0;
          *(v16 + 88) = v19 + 1;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }

        else
        {
          v17 = 0;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }
      }

      else
      {
        v17 = 1;
        v18 = *(v3 + 24);
        if (!v18)
        {
          goto LABEL_63;
        }
      }

      v20 = *(v18 + 184);
      if (v20)
      {
        v20(v3, a2);
        goto LABEL_31;
      }

LABEL_63:
      __nwlog_obj();
      v33 = *(v3 + 16);
      *buf = 136446722;
      v51 = "__nw_protocol_input_finished";
      if (!v33)
      {
        v33 = "invalid";
      }

      v52 = 2082;
      v53 = v33;
      v54 = 2048;
      v55 = v3;
      v34 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v48 = 0;
      if (!__nwlog_fault(v34, &type, &v48))
      {
        goto LABEL_110;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v37 = *(v3 + 16);
        if (!v37)
        {
          v37 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_input_finished";
        v52 = 2082;
        v53 = v37;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback";
      }

      else if (v48 == 1)
      {
        v39 = __nw_create_backtrace_string();
        v35 = __nwlog_obj();
        v36 = type;
        v40 = os_log_type_enabled(v35, type);
        if (v39)
        {
          if (v40)
          {
            v41 = *(v3 + 16);
            if (!v41)
            {
              v41 = "invalid";
            }

            *buf = 136446978;
            v51 = "__nw_protocol_input_finished";
            v52 = 2082;
            v53 = v41;
            v54 = 2048;
            v55 = v3;
            v56 = 2082;
            v57 = v39;
            _os_log_impl(&dword_181A37000, v35, v36, "%{public}s protocol %{public}s (%p) has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v39);
          goto LABEL_110;
        }

        if (!v40)
        {
LABEL_110:
          if (v34)
          {
            free(v34);
          }

LABEL_31:
          if ((v17 & 1) == 0)
          {
            v21 = *(v2 + 40);
            if (v21 == &nw_protocol_ref_counted_handle || v21 == &nw_protocol_ref_counted_additional_handle && (v2 = *(v2 + 64)) != 0)
            {
              v22 = *(v2 + 88);
              if (v22)
              {
                v23 = v22 - 1;
                *(v2 + 88) = v23;
                if (!v23)
                {
                  v24 = *(v2 + 64);
                  if (v24)
                  {
                    *(v2 + 64) = 0;
                    v24[2](v24);
                    _Block_release(v24);
                  }

                  if (*(v2 + 72))
                  {
                    v25 = *(v2 + 64);
                    if (v25)
                    {
                      _Block_release(v25);
                    }
                  }

                  free(v2);
                }
              }
            }
          }

          if ((v6 & 1) == 0)
          {
            v26 = *(v3 + 40);
            if (v26 == &nw_protocol_ref_counted_handle || v26 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
            {
              v27 = *(v3 + 88);
              if (v27)
              {
                v28 = v27 - 1;
                *(v3 + 88) = v28;
                if (!v28)
                {
                  v29 = *(v3 + 64);
                  if (v29)
                  {
                    *(v3 + 64) = 0;
                    v29[2](v29);
                    _Block_release(v29);
                  }

                  if (*(v3 + 72))
                  {
                    v30 = *(v3 + 64);
                    if (v30)
                    {
                      _Block_release(v30);
                    }
                  }

                  goto LABEL_59;
                }
              }
            }
          }

          return;
        }

        v47 = *(v3 + 16);
        if (!v47)
        {
          v47 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_input_finished";
        v52 = 2082;
        v53 = v47;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, no backtrace";
      }

      else
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v46 = *(v3 + 16);
        if (!v46)
        {
          v46 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_input_finished";
        v52 = 2082;
        v53 = v46;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A37000, v35, v36, v38, buf, 0x20u);
      goto LABEL_110;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v51 = "nw_protocol_common_input_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (__nwlog_fault(v3, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_input_finished";
        v9 = "%{public}s input_finished requires a default input handler";
        goto LABEL_56;
      }

      if (v48 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_input_finished";
        v9 = "%{public}s input_finished requires a default input handler, backtrace limit exceeded";
        goto LABEL_56;
      }

      v10 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(gLogObj, type);
      if (v10)
      {
        if (v13)
        {
          *buf = 136446466;
          v51 = "nw_protocol_common_input_finished";
          v52 = 2082;
          v53 = v10;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s input_finished requires a default input handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v10);
        if (v3)
        {
          goto LABEL_59;
        }

        return;
      }

      if (v13)
      {
        *buf = 136446210;
        v51 = "nw_protocol_common_input_finished";
        v9 = "%{public}s input_finished requires a default input handler, no backtrace";
        v31 = v11;
        v32 = v12;
        goto LABEL_57;
      }
    }

LABEL_58:
    if (!v3)
    {
      return;
    }

    goto LABEL_59;
  }

  __nwlog_obj();
  *buf = 136446210;
  v51 = "nw_protocol_common_input_finished";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (!__nwlog_fault(v3, &type, &v48))
  {
    goto LABEL_58;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_input_finished";
    v9 = "%{public}s called with null other_protocol";
    goto LABEL_56;
  }

  if (v48 != 1)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_input_finished";
    v9 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_56;
  }

  backtrace_string = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v45 = os_log_type_enabled(v7, type);
  if (!backtrace_string)
  {
    if (!v45)
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_input_finished";
    v9 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_56;
  }

  if (!v45)
  {
    goto LABEL_95;
  }

  *buf = 136446466;
  v51 = "nw_protocol_common_input_finished";
  v52 = 2082;
  v53 = backtrace_string;
  v44 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_94:
  _os_log_impl(&dword_181A37000, v7, v8, v44, buf, 0x16u);
LABEL_95:
  free(backtrace_string);
  if (v3)
  {
LABEL_59:
    free(v3);
  }
}

void nw_protocol_common_output_finished(uint64_t a1, uint64_t a2)
{
  v58 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v51 = "nw_protocol_common_output_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v3, &type, &v48))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_output_finished";
      v9 = "%{public}s called with null protocol";
      goto LABEL_56;
    }

    if (v48 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v43 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (!v43)
        {
          goto LABEL_95;
        }

        *buf = 136446466;
        v51 = "nw_protocol_common_output_finished";
        v52 = 2082;
        v53 = backtrace_string;
        v44 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_94;
      }

      if (!v43)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_output_finished";
      v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_output_finished";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_56:
    v31 = v7;
    v32 = v8;
LABEL_57:
    _os_log_impl(&dword_181A37000, v31, v32, v9, buf, 0xCu);
    goto LABEL_58;
  }

  v2 = a2;
  if (a2)
  {
    v3 = *(a1 + 32);
    if (v3)
    {
      v4 = *(v3 + 40);
      v5 = *(a1 + 32);
      if (v4 == &nw_protocol_ref_counted_handle || v4 == &nw_protocol_ref_counted_additional_handle && (v5 = *(v3 + 64)) != 0)
      {
        v14 = *(v5 + 88);
        v6 = 0;
        if (v14)
        {
          *(v5 + 88) = v14 + 1;
        }
      }

      else
      {
        v6 = 1;
      }

      v15 = *(a2 + 40);
      v16 = a2;
      if (v15 == &nw_protocol_ref_counted_handle || v15 == &nw_protocol_ref_counted_additional_handle && (v16 = *(a2 + 64)) != 0)
      {
        v19 = *(v16 + 88);
        if (v19)
        {
          v17 = 0;
          *(v16 + 88) = v19 + 1;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }

        else
        {
          v17 = 0;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }
      }

      else
      {
        v17 = 1;
        v18 = *(v3 + 24);
        if (!v18)
        {
          goto LABEL_63;
        }
      }

      v20 = *(v18 + 192);
      if (v20)
      {
        v20(v3, a2);
        goto LABEL_31;
      }

LABEL_63:
      __nwlog_obj();
      v33 = *(v3 + 16);
      *buf = 136446722;
      v51 = "__nw_protocol_output_finished";
      if (!v33)
      {
        v33 = "invalid";
      }

      v52 = 2082;
      v53 = v33;
      v54 = 2048;
      v55 = v3;
      v34 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v48 = 0;
      if (!__nwlog_fault(v34, &type, &v48))
      {
        goto LABEL_110;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v37 = *(v3 + 16);
        if (!v37)
        {
          v37 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_output_finished";
        v52 = 2082;
        v53 = v37;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback";
      }

      else if (v48 == 1)
      {
        v39 = __nw_create_backtrace_string();
        v35 = __nwlog_obj();
        v36 = type;
        v40 = os_log_type_enabled(v35, type);
        if (v39)
        {
          if (v40)
          {
            v41 = *(v3 + 16);
            if (!v41)
            {
              v41 = "invalid";
            }

            *buf = 136446978;
            v51 = "__nw_protocol_output_finished";
            v52 = 2082;
            v53 = v41;
            v54 = 2048;
            v55 = v3;
            v56 = 2082;
            v57 = v39;
            _os_log_impl(&dword_181A37000, v35, v36, "%{public}s protocol %{public}s (%p) has invalid output_finished callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v39);
          goto LABEL_110;
        }

        if (!v40)
        {
LABEL_110:
          if (v34)
          {
            free(v34);
          }

LABEL_31:
          if ((v17 & 1) == 0)
          {
            v21 = *(v2 + 40);
            if (v21 == &nw_protocol_ref_counted_handle || v21 == &nw_protocol_ref_counted_additional_handle && (v2 = *(v2 + 64)) != 0)
            {
              v22 = *(v2 + 88);
              if (v22)
              {
                v23 = v22 - 1;
                *(v2 + 88) = v23;
                if (!v23)
                {
                  v24 = *(v2 + 64);
                  if (v24)
                  {
                    *(v2 + 64) = 0;
                    v24[2](v24);
                    _Block_release(v24);
                  }

                  if (*(v2 + 72))
                  {
                    v25 = *(v2 + 64);
                    if (v25)
                    {
                      _Block_release(v25);
                    }
                  }

                  free(v2);
                }
              }
            }
          }

          if ((v6 & 1) == 0)
          {
            v26 = *(v3 + 40);
            if (v26 == &nw_protocol_ref_counted_handle || v26 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
            {
              v27 = *(v3 + 88);
              if (v27)
              {
                v28 = v27 - 1;
                *(v3 + 88) = v28;
                if (!v28)
                {
                  v29 = *(v3 + 64);
                  if (v29)
                  {
                    *(v3 + 64) = 0;
                    v29[2](v29);
                    _Block_release(v29);
                  }

                  if (*(v3 + 72))
                  {
                    v30 = *(v3 + 64);
                    if (v30)
                    {
                      _Block_release(v30);
                    }
                  }

                  goto LABEL_59;
                }
              }
            }
          }

          return;
        }

        v47 = *(v3 + 16);
        if (!v47)
        {
          v47 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_output_finished";
        v52 = 2082;
        v53 = v47;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, no backtrace";
      }

      else
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v46 = *(v3 + 16);
        if (!v46)
        {
          v46 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_output_finished";
        v52 = 2082;
        v53 = v46;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A37000, v35, v36, v38, buf, 0x20u);
      goto LABEL_110;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v51 = "nw_protocol_common_output_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (__nwlog_fault(v3, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_output_finished";
        v9 = "%{public}s output_finished requires an output handler";
        goto LABEL_56;
      }

      if (v48 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_output_finished";
        v9 = "%{public}s output_finished requires an output handler, backtrace limit exceeded";
        goto LABEL_56;
      }

      v10 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(gLogObj, type);
      if (v10)
      {
        if (v13)
        {
          *buf = 136446466;
          v51 = "nw_protocol_common_output_finished";
          v52 = 2082;
          v53 = v10;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s output_finished requires an output handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v10);
        if (v3)
        {
          goto LABEL_59;
        }

        return;
      }

      if (v13)
      {
        *buf = 136446210;
        v51 = "nw_protocol_common_output_finished";
        v9 = "%{public}s output_finished requires an output handler, no backtrace";
        v31 = v11;
        v32 = v12;
        goto LABEL_57;
      }
    }

LABEL_58:
    if (!v3)
    {
      return;
    }

    goto LABEL_59;
  }

  __nwlog_obj();
  *buf = 136446210;
  v51 = "nw_protocol_common_output_finished";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (!__nwlog_fault(v3, &type, &v48))
  {
    goto LABEL_58;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_output_finished";
    v9 = "%{public}s called with null other_protocol";
    goto LABEL_56;
  }

  if (v48 != 1)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_output_finished";
    v9 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_56;
  }

  backtrace_string = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v45 = os_log_type_enabled(v7, type);
  if (!backtrace_string)
  {
    if (!v45)
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_output_finished";
    v9 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_56;
  }

  if (!v45)
  {
    goto LABEL_95;
  }

  *buf = 136446466;
  v51 = "nw_protocol_common_output_finished";
  v52 = 2082;
  v53 = backtrace_string;
  v44 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_94:
  _os_log_impl(&dword_181A37000, v7, v8, v44, buf, 0x16u);
LABEL_95:
  free(backtrace_string);
  if (v3)
  {
LABEL_59:
    free(v3);
  }
}

void nw_protocol_common_input_flush(uint64_t a1, uint64_t a2)
{
  v58 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v51 = "nw_protocol_common_input_flush";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v3, &type, &v48))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_input_flush";
      v9 = "%{public}s called with null protocol";
      goto LABEL_56;
    }

    if (v48 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v43 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (!v43)
        {
          goto LABEL_95;
        }

        *buf = 136446466;
        v51 = "nw_protocol_common_input_flush";
        v52 = 2082;
        v53 = backtrace_string;
        v44 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_94;
      }

      if (!v43)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_input_flush";
      v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_input_flush";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_56:
    v31 = v7;
    v32 = v8;
LABEL_57:
    _os_log_impl(&dword_181A37000, v31, v32, v9, buf, 0xCu);
    goto LABEL_58;
  }

  v2 = a2;
  if (a2)
  {
    v3 = *(a1 + 48);
    if (v3)
    {
      v4 = *(v3 + 40);
      v5 = *(a1 + 48);
      if (v4 == &nw_protocol_ref_counted_handle || v4 == &nw_protocol_ref_counted_additional_handle && (v5 = *(v3 + 64)) != 0)
      {
        v14 = *(v5 + 88);
        v6 = 0;
        if (v14)
        {
          *(v5 + 88) = v14 + 1;
        }
      }

      else
      {
        v6 = 1;
      }

      v15 = *(a2 + 40);
      v16 = a2;
      if (v15 == &nw_protocol_ref_counted_handle || v15 == &nw_protocol_ref_counted_additional_handle && (v16 = *(a2 + 64)) != 0)
      {
        v19 = *(v16 + 88);
        if (v19)
        {
          v17 = 0;
          *(v16 + 88) = v19 + 1;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }

        else
        {
          v17 = 0;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }
      }

      else
      {
        v17 = 1;
        v18 = *(v3 + 24);
        if (!v18)
        {
          goto LABEL_63;
        }
      }

      v20 = *(v18 + 264);
      if (v20)
      {
        v20(v3, a2);
        goto LABEL_31;
      }

LABEL_63:
      __nwlog_obj();
      v33 = *(v3 + 16);
      *buf = 136446722;
      v51 = "__nw_protocol_input_flush";
      if (!v33)
      {
        v33 = "invalid";
      }

      v52 = 2082;
      v53 = v33;
      v54 = 2048;
      v55 = v3;
      v34 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v48 = 0;
      if (!__nwlog_fault(v34, &type, &v48))
      {
        goto LABEL_110;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v37 = *(v3 + 16);
        if (!v37)
        {
          v37 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_input_flush";
        v52 = 2082;
        v53 = v37;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid input_flush callback";
      }

      else if (v48 == 1)
      {
        v39 = __nw_create_backtrace_string();
        v35 = __nwlog_obj();
        v36 = type;
        v40 = os_log_type_enabled(v35, type);
        if (v39)
        {
          if (v40)
          {
            v41 = *(v3 + 16);
            if (!v41)
            {
              v41 = "invalid";
            }

            *buf = 136446978;
            v51 = "__nw_protocol_input_flush";
            v52 = 2082;
            v53 = v41;
            v54 = 2048;
            v55 = v3;
            v56 = 2082;
            v57 = v39;
            _os_log_impl(&dword_181A37000, v35, v36, "%{public}s protocol %{public}s (%p) has invalid input_flush callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v39);
          goto LABEL_110;
        }

        if (!v40)
        {
LABEL_110:
          if (v34)
          {
            free(v34);
          }

LABEL_31:
          if ((v17 & 1) == 0)
          {
            v21 = *(v2 + 40);
            if (v21 == &nw_protocol_ref_counted_handle || v21 == &nw_protocol_ref_counted_additional_handle && (v2 = *(v2 + 64)) != 0)
            {
              v22 = *(v2 + 88);
              if (v22)
              {
                v23 = v22 - 1;
                *(v2 + 88) = v23;
                if (!v23)
                {
                  v24 = *(v2 + 64);
                  if (v24)
                  {
                    *(v2 + 64) = 0;
                    v24[2](v24);
                    _Block_release(v24);
                  }

                  if (*(v2 + 72))
                  {
                    v25 = *(v2 + 64);
                    if (v25)
                    {
                      _Block_release(v25);
                    }
                  }

                  free(v2);
                }
              }
            }
          }

          if ((v6 & 1) == 0)
          {
            v26 = *(v3 + 40);
            if (v26 == &nw_protocol_ref_counted_handle || v26 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
            {
              v27 = *(v3 + 88);
              if (v27)
              {
                v28 = v27 - 1;
                *(v3 + 88) = v28;
                if (!v28)
                {
                  v29 = *(v3 + 64);
                  if (v29)
                  {
                    *(v3 + 64) = 0;
                    v29[2](v29);
                    _Block_release(v29);
                  }

                  if (*(v3 + 72))
                  {
                    v30 = *(v3 + 64);
                    if (v30)
                    {
                      _Block_release(v30);
                    }
                  }

                  goto LABEL_59;
                }
              }
            }
          }

          return;
        }

        v47 = *(v3 + 16);
        if (!v47)
        {
          v47 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_input_flush";
        v52 = 2082;
        v53 = v47;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid input_flush callback, no backtrace";
      }

      else
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v46 = *(v3 + 16);
        if (!v46)
        {
          v46 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_input_flush";
        v52 = 2082;
        v53 = v46;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid input_flush callback, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A37000, v35, v36, v38, buf, 0x20u);
      goto LABEL_110;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v51 = "nw_protocol_common_input_flush";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (__nwlog_fault(v3, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_input_flush";
        v9 = "%{public}s input_flush requires a default input handler";
        goto LABEL_56;
      }

      if (v48 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_input_flush";
        v9 = "%{public}s input_flush requires a default input handler, backtrace limit exceeded";
        goto LABEL_56;
      }

      v10 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(gLogObj, type);
      if (v10)
      {
        if (v13)
        {
          *buf = 136446466;
          v51 = "nw_protocol_common_input_flush";
          v52 = 2082;
          v53 = v10;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s input_flush requires a default input handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v10);
        if (v3)
        {
          goto LABEL_59;
        }

        return;
      }

      if (v13)
      {
        *buf = 136446210;
        v51 = "nw_protocol_common_input_flush";
        v9 = "%{public}s input_flush requires a default input handler, no backtrace";
        v31 = v11;
        v32 = v12;
        goto LABEL_57;
      }
    }

LABEL_58:
    if (!v3)
    {
      return;
    }

    goto LABEL_59;
  }

  __nwlog_obj();
  *buf = 136446210;
  v51 = "nw_protocol_common_input_flush";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (!__nwlog_fault(v3, &type, &v48))
  {
    goto LABEL_58;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_input_flush";
    v9 = "%{public}s called with null other_protocol";
    goto LABEL_56;
  }

  if (v48 != 1)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_input_flush";
    v9 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_56;
  }

  backtrace_string = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v45 = os_log_type_enabled(v7, type);
  if (!backtrace_string)
  {
    if (!v45)
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_input_flush";
    v9 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_56;
  }

  if (!v45)
  {
    goto LABEL_95;
  }

  *buf = 136446466;
  v51 = "nw_protocol_common_input_flush";
  v52 = 2082;
  v53 = backtrace_string;
  v44 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_94:
  _os_log_impl(&dword_181A37000, v7, v8, v44, buf, 0x16u);
LABEL_95:
  free(backtrace_string);
  if (v3)
  {
LABEL_59:
    free(v3);
  }
}

void nw_protocol_common_error(uint64_t a1, uint64_t a2)
{
  v58 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v51 = "nw_protocol_common_error";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v3, &type, &v48))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_error";
      v9 = "%{public}s called with null protocol";
      goto LABEL_56;
    }

    if (v48 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v43 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (!v43)
        {
          goto LABEL_95;
        }

        *buf = 136446466;
        v51 = "nw_protocol_common_error";
        v52 = 2082;
        v53 = backtrace_string;
        v44 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_94;
      }

      if (!v43)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_error";
      v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v51 = "nw_protocol_common_error";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_56:
    v31 = v7;
    v32 = v8;
LABEL_57:
    _os_log_impl(&dword_181A37000, v31, v32, v9, buf, 0xCu);
    goto LABEL_58;
  }

  v2 = a2;
  if (a2)
  {
    v3 = *(a1 + 48);
    if (v3)
    {
      v4 = *(v3 + 40);
      v5 = *(a1 + 48);
      if (v4 == &nw_protocol_ref_counted_handle || v4 == &nw_protocol_ref_counted_additional_handle && (v5 = *(v3 + 64)) != 0)
      {
        v14 = *(v5 + 88);
        v6 = 0;
        if (v14)
        {
          *(v5 + 88) = v14 + 1;
        }
      }

      else
      {
        v6 = 1;
      }

      v15 = *(a2 + 40);
      v16 = a2;
      if (v15 == &nw_protocol_ref_counted_handle || v15 == &nw_protocol_ref_counted_additional_handle && (v16 = *(a2 + 64)) != 0)
      {
        v19 = *(v16 + 88);
        if (v19)
        {
          v17 = 0;
          *(v16 + 88) = v19 + 1;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }

        else
        {
          v17 = 0;
          v18 = *(v3 + 24);
          if (!v18)
          {
            goto LABEL_63;
          }
        }
      }

      else
      {
        v17 = 1;
        v18 = *(v3 + 24);
        if (!v18)
        {
          goto LABEL_63;
        }
      }

      v20 = *(v18 + 56);
      if (v20)
      {
        v20(v3, a2);
        goto LABEL_31;
      }

LABEL_63:
      __nwlog_obj();
      v33 = *(v3 + 16);
      *buf = 136446722;
      v51 = "__nw_protocol_error";
      if (!v33)
      {
        v33 = "invalid";
      }

      v52 = 2082;
      v53 = v33;
      v54 = 2048;
      v55 = v3;
      v34 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v48 = 0;
      if (!__nwlog_fault(v34, &type, &v48))
      {
        goto LABEL_110;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v37 = *(v3 + 16);
        if (!v37)
        {
          v37 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_error";
        v52 = 2082;
        v53 = v37;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid error callback";
      }

      else if (v48 == 1)
      {
        v39 = __nw_create_backtrace_string();
        v35 = __nwlog_obj();
        v36 = type;
        v40 = os_log_type_enabled(v35, type);
        if (v39)
        {
          if (v40)
          {
            v41 = *(v3 + 16);
            if (!v41)
            {
              v41 = "invalid";
            }

            *buf = 136446978;
            v51 = "__nw_protocol_error";
            v52 = 2082;
            v53 = v41;
            v54 = 2048;
            v55 = v3;
            v56 = 2082;
            v57 = v39;
            _os_log_impl(&dword_181A37000, v35, v36, "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v39);
          goto LABEL_110;
        }

        if (!v40)
        {
LABEL_110:
          if (v34)
          {
            free(v34);
          }

LABEL_31:
          if ((v17 & 1) == 0)
          {
            v21 = *(v2 + 40);
            if (v21 == &nw_protocol_ref_counted_handle || v21 == &nw_protocol_ref_counted_additional_handle && (v2 = *(v2 + 64)) != 0)
            {
              v22 = *(v2 + 88);
              if (v22)
              {
                v23 = v22 - 1;
                *(v2 + 88) = v23;
                if (!v23)
                {
                  v24 = *(v2 + 64);
                  if (v24)
                  {
                    *(v2 + 64) = 0;
                    v24[2](v24);
                    _Block_release(v24);
                  }

                  if (*(v2 + 72))
                  {
                    v25 = *(v2 + 64);
                    if (v25)
                    {
                      _Block_release(v25);
                    }
                  }

                  free(v2);
                }
              }
            }
          }

          if ((v6 & 1) == 0)
          {
            v26 = *(v3 + 40);
            if (v26 == &nw_protocol_ref_counted_handle || v26 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
            {
              v27 = *(v3 + 88);
              if (v27)
              {
                v28 = v27 - 1;
                *(v3 + 88) = v28;
                if (!v28)
                {
                  v29 = *(v3 + 64);
                  if (v29)
                  {
                    *(v3 + 64) = 0;
                    v29[2](v29);
                    _Block_release(v29);
                  }

                  if (*(v3 + 72))
                  {
                    v30 = *(v3 + 64);
                    if (v30)
                    {
                      _Block_release(v30);
                    }
                  }

                  goto LABEL_59;
                }
              }
            }
          }

          return;
        }

        v47 = *(v3 + 16);
        if (!v47)
        {
          v47 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_error";
        v52 = 2082;
        v53 = v47;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace";
      }

      else
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_110;
        }

        v46 = *(v3 + 16);
        if (!v46)
        {
          v46 = "invalid";
        }

        *buf = 136446722;
        v51 = "__nw_protocol_error";
        v52 = 2082;
        v53 = v46;
        v54 = 2048;
        v55 = v3;
        v38 = "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A37000, v35, v36, v38, buf, 0x20u);
      goto LABEL_110;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v51 = "nw_protocol_common_error";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (__nwlog_fault(v3, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_error";
        v9 = "%{public}s error requires a default input handler";
        goto LABEL_56;
      }

      if (v48 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v51 = "nw_protocol_common_error";
        v9 = "%{public}s error requires a default input handler, backtrace limit exceeded";
        goto LABEL_56;
      }

      v10 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(gLogObj, type);
      if (v10)
      {
        if (v13)
        {
          *buf = 136446466;
          v51 = "nw_protocol_common_error";
          v52 = 2082;
          v53 = v10;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s error requires a default input handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v10);
        if (v3)
        {
          goto LABEL_59;
        }

        return;
      }

      if (v13)
      {
        *buf = 136446210;
        v51 = "nw_protocol_common_error";
        v9 = "%{public}s error requires a default input handler, no backtrace";
        v31 = v11;
        v32 = v12;
        goto LABEL_57;
      }
    }

LABEL_58:
    if (!v3)
    {
      return;
    }

    goto LABEL_59;
  }

  __nwlog_obj();
  *buf = 136446210;
  v51 = "nw_protocol_common_error";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (!__nwlog_fault(v3, &type, &v48))
  {
    goto LABEL_58;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_error";
    v9 = "%{public}s called with null other_protocol";
    goto LABEL_56;
  }

  if (v48 != 1)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_error";
    v9 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_56;
  }

  backtrace_string = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v45 = os_log_type_enabled(v7, type);
  if (!backtrace_string)
  {
    if (!v45)
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v51 = "nw_protocol_common_error";
    v9 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_56;
  }

  if (!v45)
  {
    goto LABEL_95;
  }

  *buf = 136446466;
  v51 = "nw_protocol_common_error";
  v52 = 2082;
  v53 = backtrace_string;
  v44 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_94:
  _os_log_impl(&dword_181A37000, v7, v8, v44, buf, 0x16u);
LABEL_95:
  free(backtrace_string);
  if (v3)
  {
LABEL_59:
    free(v3);
  }
}

uint64_t nw_protocol_common_register_notification(uint64_t a1, uint64_t a2, int a3)
{
  v64 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v57 = "nw_protocol_common_register_notification";
    v8 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v8, &type, &v54))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_register_notification";
      v11 = "%{public}s called with null protocol";
      goto LABEL_56;
    }

    if (v54 != 1)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_register_notification";
      v11 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v48 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (!v48)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_register_notification";
      v11 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_56;
    }

    if (!v48)
    {
      goto LABEL_104;
    }

    *buf = 136446466;
    v57 = "nw_protocol_common_register_notification";
    v58 = 2082;
    v59 = backtrace_string;
    v49 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_103;
  }

  v3 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v57 = "nw_protocol_common_register_notification";
    v8 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v8, &type, &v54))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_register_notification";
      v11 = "%{public}s called with null other_protocol";
      goto LABEL_56;
    }

    if (v54 != 1)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_register_notification";
      v11 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v50 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (!v50)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_register_notification";
      v11 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_56;
    }

    if (!v50)
    {
      goto LABEL_104;
    }

    *buf = 136446466;
    v57 = "nw_protocol_common_register_notification";
    v58 = 2082;
    v59 = backtrace_string;
    v49 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_103:
    _os_log_impl(&dword_181A37000, v9, v10, v49, buf, 0x16u);
    goto LABEL_104;
  }

  if (!a3)
  {
    __nwlog_obj();
    *buf = 136446210;
    v57 = "nw_protocol_common_register_notification";
    v8 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v8, &type, &v54))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_register_notification";
      v11 = "%{public}s called with null type";
      goto LABEL_56;
    }

    if (v54 != 1)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_register_notification";
      v11 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v51 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (!v51)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_register_notification";
      v11 = "%{public}s called with null type, no backtrace";
      goto LABEL_56;
    }

    if (v51)
    {
      *buf = 136446466;
      v57 = "nw_protocol_common_register_notification";
      v58 = 2082;
      v59 = backtrace_string;
      v49 = "%{public}s called with null type, dumping backtrace:%{public}s";
      goto LABEL_103;
    }

LABEL_104:
    free(backtrace_string);
    goto LABEL_58;
  }

  v4 = *(a1 + 32);
  if (v4)
  {
    v5 = *(v4 + 40);
    v6 = *(a1 + 32);
    if (v5 == &nw_protocol_ref_counted_handle || v5 == &nw_protocol_ref_counted_additional_handle && (v6 = *(v4 + 64)) != 0)
    {
      v16 = *(v6 + 88);
      v7 = 0;
      if (v16)
      {
        *(v6 + 88) = v16 + 1;
      }
    }

    else
    {
      v7 = 1;
    }

    v17 = *(a2 + 40);
    v18 = a2;
    if (v17 == &nw_protocol_ref_counted_handle || v17 == &nw_protocol_ref_counted_additional_handle && (v18 = *(a2 + 64)) != 0)
    {
      v21 = *(v18 + 88);
      if (v21)
      {
        v19 = 0;
        *(v18 + 88) = v21 + 1;
        v20 = *(v4 + 24);
        if (!v20)
        {
          goto LABEL_64;
        }
      }

      else
      {
        v19 = 0;
        v20 = *(v4 + 24);
        if (!v20)
        {
          goto LABEL_64;
        }
      }
    }

    else
    {
      v19 = 1;
      v20 = *(v4 + 24);
      if (!v20)
      {
        goto LABEL_64;
      }
    }

    v22 = *(v20 + 144);
    if (v22)
    {
      result = v22(v4, a2);
      if (v19)
      {
LABEL_42:
        if ((v7 & 1) == 0)
        {
          v30 = *(v4 + 40);
          if (v30 == &nw_protocol_ref_counted_handle || v30 == &nw_protocol_ref_counted_additional_handle && (v4 = *(v4 + 64)) != 0)
          {
            v31 = *(v4 + 88);
            if (v31)
            {
              v32 = v31 - 1;
              *(v4 + 88) = v32;
              if (!v32)
              {
                v33 = result;
                v34 = *(v4 + 64);
                if (v34)
                {
                  *(v4 + 64) = 0;
                  v34[2](v34);
                  _Block_release(v34);
                }

                if (*(v4 + 72))
                {
                  v35 = *(v4 + 64);
                  if (v35)
                  {
                    _Block_release(v35);
                  }
                }

                free(v4);
                return v33;
              }
            }
          }
        }

        return result;
      }

LABEL_31:
      v24 = *(v3 + 40);
      if (v24 == &nw_protocol_ref_counted_handle || v24 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
      {
        v25 = *(v3 + 88);
        if (v25)
        {
          v26 = v25 - 1;
          *(v3 + 88) = v26;
          if (!v26)
          {
            v27 = result;
            v28 = *(v3 + 64);
            if (v28)
            {
              *(v3 + 64) = 0;
              v28[2](v28);
              _Block_release(v28);
            }

            if (*(v3 + 72))
            {
              v29 = *(v3 + 64);
              if (v29)
              {
                _Block_release(v29);
              }
            }

            free(v3);
            result = v27;
          }
        }
      }

      goto LABEL_42;
    }

LABEL_64:
    __nwlog_obj();
    v38 = *(v4 + 16);
    *buf = 136446722;
    v57 = "__nw_protocol_register_notification";
    if (!v38)
    {
      v38 = "invalid";
    }

    v58 = 2082;
    v59 = v38;
    v60 = 2048;
    v61 = v4;
    v39 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (__nwlog_fault(v39, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v40 = __nwlog_obj();
        v41 = type;
        if (!os_log_type_enabled(v40, type))
        {
          goto LABEL_120;
        }

        v42 = *(v4 + 16);
        if (!v42)
        {
          v42 = "invalid";
        }

        *buf = 136446722;
        v57 = "__nw_protocol_register_notification";
        v58 = 2082;
        v59 = v42;
        v60 = 2048;
        v61 = v4;
        v43 = "%{public}s protocol %{public}s (%p) has invalid register_notification callback";
LABEL_119:
        _os_log_impl(&dword_181A37000, v40, v41, v43, buf, 0x20u);
        goto LABEL_120;
      }

      if (v54 != 1)
      {
        v40 = __nwlog_obj();
        v41 = type;
        if (!os_log_type_enabled(v40, type))
        {
          goto LABEL_120;
        }

        v52 = *(v4 + 16);
        if (!v52)
        {
          v52 = "invalid";
        }

        *buf = 136446722;
        v57 = "__nw_protocol_register_notification";
        v58 = 2082;
        v59 = v52;
        v60 = 2048;
        v61 = v4;
        v43 = "%{public}s protocol %{public}s (%p) has invalid register_notification callback, backtrace limit exceeded";
        goto LABEL_119;
      }

      v44 = __nw_create_backtrace_string();
      v40 = __nwlog_obj();
      v41 = type;
      v45 = os_log_type_enabled(v40, type);
      if (!v44)
      {
        if (!v45)
        {
          goto LABEL_120;
        }

        v53 = *(v4 + 16);
        if (!v53)
        {
          v53 = "invalid";
        }

        *buf = 136446722;
        v57 = "__nw_protocol_register_notification";
        v58 = 2082;
        v59 = v53;
        v60 = 2048;
        v61 = v4;
        v43 = "%{public}s protocol %{public}s (%p) has invalid register_notification callback, no backtrace";
        goto LABEL_119;
      }

      if (v45)
      {
        v46 = *(v4 + 16);
        if (!v46)
        {
          v46 = "invalid";
        }

        *buf = 136446978;
        v57 = "__nw_protocol_register_notification";
        v58 = 2082;
        v59 = v46;
        v60 = 2048;
        v61 = v4;
        v62 = 2082;
        v63 = v44;
        _os_log_impl(&dword_181A37000, v40, v41, "%{public}s protocol %{public}s (%p) has invalid register_notification callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v44);
    }

LABEL_120:
    if (v39)
    {
      free(v39);
    }

    result = 0;
    if (v19)
    {
      goto LABEL_42;
    }

    goto LABEL_31;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446210;
  v57 = "nw_protocol_common_register_notification";
  v8 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v54 = 0;
  if (__nwlog_fault(v8, &type, &v54))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type;
      if (os_log_type_enabled(gLogObj, type))
      {
        *buf = 136446210;
        v57 = "nw_protocol_common_register_notification";
        v11 = "%{public}s register_notification requires an output handler";
LABEL_56:
        v36 = v9;
        v37 = v10;
LABEL_57:
        _os_log_impl(&dword_181A37000, v36, v37, v11, buf, 0xCu);
      }
    }

    else if (v54 == 1)
    {
      v12 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      v15 = os_log_type_enabled(gLogObj, type);
      if (v12)
      {
        if (v15)
        {
          *buf = 136446466;
          v57 = "nw_protocol_common_register_notification";
          v58 = 2082;
          v59 = v12;
          _os_log_impl(&dword_181A37000, v13, v14, "%{public}s register_notification requires an output handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v12);
        goto LABEL_58;
      }

      if (v15)
      {
        *buf = 136446210;
        v57 = "nw_protocol_common_register_notification";
        v11 = "%{public}s register_notification requires an output handler, no backtrace";
        v36 = v13;
        v37 = v14;
        goto LABEL_57;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type;
      if (os_log_type_enabled(gLogObj, type))
      {
        *buf = 136446210;
        v57 = "nw_protocol_common_register_notification";
        v11 = "%{public}s register_notification requires an output handler, backtrace limit exceeded";
        goto LABEL_56;
      }
    }
  }

LABEL_58:
  if (v8)
  {
    free(v8);
  }

  return 0;
}

uint64_t nw_protocol_common_unregister_notification(uint64_t a1, uint64_t a2, int a3)
{
  v64 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v57 = "nw_protocol_common_unregister_notification";
    v8 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v8, &type, &v54))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_unregister_notification";
      v11 = "%{public}s called with null protocol";
      goto LABEL_56;
    }

    if (v54 != 1)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_unregister_notification";
      v11 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v48 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (!v48)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_unregister_notification";
      v11 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_56;
    }

    if (!v48)
    {
      goto LABEL_104;
    }

    *buf = 136446466;
    v57 = "nw_protocol_common_unregister_notification";
    v58 = 2082;
    v59 = backtrace_string;
    v49 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_103;
  }

  v3 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v57 = "nw_protocol_common_unregister_notification";
    v8 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v8, &type, &v54))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_unregister_notification";
      v11 = "%{public}s called with null other_protocol";
      goto LABEL_56;
    }

    if (v54 != 1)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_unregister_notification";
      v11 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v50 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (!v50)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_unregister_notification";
      v11 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_56;
    }

    if (!v50)
    {
      goto LABEL_104;
    }

    *buf = 136446466;
    v57 = "nw_protocol_common_unregister_notification";
    v58 = 2082;
    v59 = backtrace_string;
    v49 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_103:
    _os_log_impl(&dword_181A37000, v9, v10, v49, buf, 0x16u);
    goto LABEL_104;
  }

  if (!a3)
  {
    __nwlog_obj();
    *buf = 136446210;
    v57 = "nw_protocol_common_unregister_notification";
    v8 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v8, &type, &v54))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_unregister_notification";
      v11 = "%{public}s called with null type";
      goto LABEL_56;
    }

    if (v54 != 1)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_unregister_notification";
      v11 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v51 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (!v51)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v57 = "nw_protocol_common_unregister_notification";
      v11 = "%{public}s called with null type, no backtrace";
      goto LABEL_56;
    }

    if (v51)
    {
      *buf = 136446466;
      v57 = "nw_protocol_common_unregister_notification";
      v58 = 2082;
      v59 = backtrace_string;
      v49 = "%{public}s called with null type, dumping backtrace:%{public}s";
      goto LABEL_103;
    }

LABEL_104:
    free(backtrace_string);
    goto LABEL_58;
  }

  v4 = *(a1 + 32);
  if (v4)
  {
    v5 = *(v4 + 40);
    v6 = *(a1 + 32);
    if (v5 == &nw_protocol_ref_counted_handle || v5 == &nw_protocol_ref_counted_additional_handle && (v6 = *(v4 + 64)) != 0)
    {
      v16 = *(v6 + 88);
      v7 = 0;
      if (v16)
      {
        *(v6 + 88) = v16 + 1;
      }
    }

    else
    {
      v7 = 1;
    }

    v17 = *(a2 + 40);
    v18 = a2;
    if (v17 == &nw_protocol_ref_counted_handle || v17 == &nw_protocol_ref_counted_additional_handle && (v18 = *(a2 + 64)) != 0)
    {
      v21 = *(v18 + 88);
      if (v21)
      {
        v19 = 0;
        *(v18 + 88) = v21 + 1;
        v20 = *(v4 + 24);
        if (!v20)
        {
          goto LABEL_64;
        }
      }

      else
      {
        v19 = 0;
        v20 = *(v4 + 24);
        if (!v20)
        {
          goto LABEL_64;
        }
      }
    }

    else
    {
      v19 = 1;
      v20 = *(v4 + 24);
      if (!v20)
      {
        goto LABEL_64;
      }
    }

    v22 = *(v20 + 152);
    if (v22)
    {
      result = v22(v4, a2);
      if (v19)
      {
LABEL_42:
        if ((v7 & 1) == 0)
        {
          v30 = *(v4 + 40);
          if (v30 == &nw_protocol_ref_counted_handle || v30 == &nw_protocol_ref_counted_additional_handle && (v4 = *(v4 + 64)) != 0)
          {
            v31 = *(v4 + 88);
            if (v31)
            {
              v32 = v31 - 1;
              *(v4 + 88) = v32;
              if (!v32)
              {
                v33 = result;
                v34 = *(v4 + 64);
                if (v34)
                {
                  *(v4 + 64) = 0;
                  v34[2](v34);
                  _Block_release(v34);
                }

                if (*(v4 + 72))
                {
                  v35 = *(v4 + 64);
                  if (v35)
                  {
                    _Block_release(v35);
                  }
                }

                free(v4);
                return v33;
              }
            }
          }
        }

        return result;
      }

LABEL_31:
      v24 = *(v3 + 40);
      if (v24 == &nw_protocol_ref_counted_handle || v24 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
      {
        v25 = *(v3 + 88);
        if (v25)
        {
          v26 = v25 - 1;
          *(v3 + 88) = v26;
          if (!v26)
          {
            v27 = result;
            v28 = *(v3 + 64);
            if (v28)
            {
              *(v3 + 64) = 0;
              v28[2](v28);
              _Block_release(v28);
            }

            if (*(v3 + 72))
            {
              v29 = *(v3 + 64);
              if (v29)
              {
                _Block_release(v29);
              }
            }

            free(v3);
            result = v27;
          }
        }
      }

      goto LABEL_42;
    }

LABEL_64:
    __nwlog_obj();
    v38 = *(v4 + 16);
    *buf = 136446722;
    v57 = "__nw_protocol_unregister_notification";
    if (!v38)
    {
      v38 = "invalid";
    }

    v58 = 2082;
    v59 = v38;
    v60 = 2048;
    v61 = v4;
    v39 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (__nwlog_fault(v39, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v40 = __nwlog_obj();
        v41 = type;
        if (!os_log_type_enabled(v40, type))
        {
          goto LABEL_120;
        }

        v42 = *(v4 + 16);
        if (!v42)
        {
          v42 = "invalid";
        }

        *buf = 136446722;
        v57 = "__nw_protocol_unregister_notification";
        v58 = 2082;
        v59 = v42;
        v60 = 2048;
        v61 = v4;
        v43 = "%{public}s protocol %{public}s (%p) has invalid unregister_notification callback";
LABEL_119:
        _os_log_impl(&dword_181A37000, v40, v41, v43, buf, 0x20u);
        goto LABEL_120;
      }

      if (v54 != 1)
      {
        v40 = __nwlog_obj();
        v41 = type;
        if (!os_log_type_enabled(v40, type))
        {
          goto LABEL_120;
        }

        v52 = *(v4 + 16);
        if (!v52)
        {
          v52 = "invalid";
        }

        *buf = 136446722;
        v57 = "__nw_protocol_unregister_notification";
        v58 = 2082;
        v59 = v52;
        v60 = 2048;
        v61 = v4;
        v43 = "%{public}s protocol %{public}s (%p) has invalid unregister_notification callback, backtrace limit exceeded";
        goto LABEL_119;
      }

      v44 = __nw_create_backtrace_string();
      v40 = __nwlog_obj();
      v41 = type;
      v45 = os_log_type_enabled(v40, type);
      if (!v44)
      {
        if (!v45)
        {
          goto LABEL_120;
        }

        v53 = *(v4 + 16);
        if (!v53)
        {
          v53 = "invalid";
        }

        *buf = 136446722;
        v57 = "__nw_protocol_unregister_notification";
        v58 = 2082;
        v59 = v53;
        v60 = 2048;
        v61 = v4;
        v43 = "%{public}s protocol %{public}s (%p) has invalid unregister_notification callback, no backtrace";
        goto LABEL_119;
      }

      if (v45)
      {
        v46 = *(v4 + 16);
        if (!v46)
        {
          v46 = "invalid";
        }

        *buf = 136446978;
        v57 = "__nw_protocol_unregister_notification";
        v58 = 2082;
        v59 = v46;
        v60 = 2048;
        v61 = v4;
        v62 = 2082;
        v63 = v44;
        _os_log_impl(&dword_181A37000, v40, v41, "%{public}s protocol %{public}s (%p) has invalid unregister_notification callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v44);
    }

LABEL_120:
    if (v39)
    {
      free(v39);
    }

    result = 0;
    if (v19)
    {
      goto LABEL_42;
    }

    goto LABEL_31;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446210;
  v57 = "nw_protocol_common_unregister_notification";
  v8 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v54 = 0;
  if (__nwlog_fault(v8, &type, &v54))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type;
      if (os_log_type_enabled(gLogObj, type))
      {
        *buf = 136446210;
        v57 = "nw_protocol_common_unregister_notification";
        v11 = "%{public}s unregister_notification requires an output handler";
LABEL_56:
        v36 = v9;
        v37 = v10;
LABEL_57:
        _os_log_impl(&dword_181A37000, v36, v37, v11, buf, 0xCu);
      }
    }

    else if (v54 == 1)
    {
      v12 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      v15 = os_log_type_enabled(gLogObj, type);
      if (v12)
      {
        if (v15)
        {
          *buf = 136446466;
          v57 = "nw_protocol_common_unregister_notification";
          v58 = 2082;
          v59 = v12;
          _os_log_impl(&dword_181A37000, v13, v14, "%{public}s unregister_notification requires an output handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v12);
        goto LABEL_58;
      }

      if (v15)
      {
        *buf = 136446210;
        v57 = "nw_protocol_common_unregister_notification";
        v11 = "%{public}s unregister_notification requires an output handler, no backtrace";
        v36 = v13;
        v37 = v14;
        goto LABEL_57;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type;
      if (os_log_type_enabled(gLogObj, type))
      {
        *buf = 136446210;
        v57 = "nw_protocol_common_unregister_notification";
        v11 = "%{public}s unregister_notification requires an output handler, backtrace limit exceeded";
        goto LABEL_56;
      }
    }
  }

LABEL_58:
  if (v8)
  {
    free(v8);
  }

  return 0;
}

uint64_t nw_protocol_common_updated_path(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v59 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v52 = "nw_protocol_common_updated_path";
    v35 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v49 = 0;
    if (!__nwlog_fault(v35, &type, &v49))
    {
      goto LABEL_115;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v36 = __nwlog_obj();
      v37 = type;
      if (!os_log_type_enabled(v36, type))
      {
        goto LABEL_115;
      }

      *buf = 136446210;
      v52 = "nw_protocol_common_updated_path";
      v38 = "%{public}s called with null protocol";
LABEL_114:
      _os_log_impl(&dword_181A37000, v36, v37, v38, buf, 0xCu);
      goto LABEL_115;
    }

    if (v49 != 1)
    {
      v36 = __nwlog_obj();
      v37 = type;
      if (os_log_type_enabled(v36, type))
      {
        *buf = 136446210;
        v52 = "nw_protocol_common_updated_path";
        v38 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_114;
      }

      goto LABEL_115;
    }

    backtrace_string = __nw_create_backtrace_string();
    v36 = __nwlog_obj();
    v37 = type;
    v43 = os_log_type_enabled(v36, type);
    if (!backtrace_string)
    {
      if (v43)
      {
        *buf = 136446210;
        v52 = "nw_protocol_common_updated_path";
        v38 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_114;
      }

      goto LABEL_115;
    }

    if (!v43)
    {
      goto LABEL_88;
    }

    *buf = 136446466;
    v52 = "nw_protocol_common_updated_path";
    v53 = 2082;
    v54 = backtrace_string;
    v44 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_87:
    _os_log_impl(&dword_181A37000, v36, v37, v44, buf, 0x16u);
    goto LABEL_88;
  }

  v3 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v52 = "nw_protocol_common_updated_path";
    v35 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v49 = 0;
    if (!__nwlog_fault(v35, &type, &v49))
    {
      goto LABEL_115;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v36 = __nwlog_obj();
      v37 = type;
      if (!os_log_type_enabled(v36, type))
      {
        goto LABEL_115;
      }

      *buf = 136446210;
      v52 = "nw_protocol_common_updated_path";
      v38 = "%{public}s called with null other_protocol";
      goto LABEL_114;
    }

    if (v49 != 1)
    {
      v36 = __nwlog_obj();
      v37 = type;
      if (os_log_type_enabled(v36, type))
      {
        *buf = 136446210;
        v52 = "nw_protocol_common_updated_path";
        v38 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_114;
      }

      goto LABEL_115;
    }

    backtrace_string = __nw_create_backtrace_string();
    v36 = __nwlog_obj();
    v37 = type;
    v45 = os_log_type_enabled(v36, type);
    if (!backtrace_string)
    {
      if (v45)
      {
        *buf = 136446210;
        v52 = "nw_protocol_common_updated_path";
        v38 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_114;
      }

      goto LABEL_115;
    }

    if (!v45)
    {
      goto LABEL_88;
    }

    *buf = 136446466;
    v52 = "nw_protocol_common_updated_path";
    v53 = 2082;
    v54 = backtrace_string;
    v44 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_87;
  }

  if (!a3)
  {
    __nwlog_obj();
    *buf = 136446210;
    v52 = "nw_protocol_common_updated_path";
    v35 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v49 = 0;
    if (!__nwlog_fault(v35, &type, &v49))
    {
      goto LABEL_115;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v36 = __nwlog_obj();
      v37 = type;
      if (os_log_type_enabled(v36, type))
      {
        *buf = 136446210;
        v52 = "nw_protocol_common_updated_path";
        v38 = "%{public}s called with null path";
        goto LABEL_114;
      }

LABEL_115:
      if (v35)
      {
        free(v35);
      }

      return 0;
    }

    if (v49 != 1)
    {
      v36 = __nwlog_obj();
      v37 = type;
      if (os_log_type_enabled(v36, type))
      {
        *buf = 136446210;
        v52 = "nw_protocol_common_updated_path";
        v38 = "%{public}s called with null path, backtrace limit exceeded";
        goto LABEL_114;
      }

      goto LABEL_115;
    }

    backtrace_string = __nw_create_backtrace_string();
    v36 = __nwlog_obj();
    v37 = type;
    v46 = os_log_type_enabled(v36, type);
    if (!backtrace_string)
    {
      if (v46)
      {
        *buf = 136446210;
        v52 = "nw_protocol_common_updated_path";
        v38 = "%{public}s called with null path, no backtrace";
        goto LABEL_114;
      }

      goto LABEL_115;
    }

    if (v46)
    {
      *buf = 136446466;
      v52 = "nw_protocol_common_updated_path";
      v53 = 2082;
      v54 = backtrace_string;
      v44 = "%{public}s called with null path, dumping backtrace:%{public}s";
      goto LABEL_87;
    }

LABEL_88:
    free(backtrace_string);
    goto LABEL_115;
  }

  v4 = *(a1 + 32);
  if (v4)
  {
    v5 = *(v4 + 40);
    v6 = *(a1 + 32);
    if (v5 == &nw_protocol_ref_counted_handle || v5 == &nw_protocol_ref_counted_additional_handle && (v6 = *(v4 + 64)) != 0)
    {
      v10 = *(v6 + 88);
      v7 = 0;
      if (v10)
      {
        *(v6 + 88) = v10 + 1;
      }
    }

    else
    {
      v7 = 1;
    }

    v11 = *(a2 + 40);
    v12 = a2;
    if (v11 == &nw_protocol_ref_counted_handle || v11 == &nw_protocol_ref_counted_additional_handle && (v12 = *(a2 + 64)) != 0)
    {
      v15 = *(v12 + 88);
      if (v15)
      {
        v13 = 0;
        *(v12 + 88) = v15 + 1;
        v14 = *(v4 + 24);
        if (!v14)
        {
          goto LABEL_48;
        }
      }

      else
      {
        v13 = 0;
        v14 = *(v4 + 24);
        if (!v14)
        {
          goto LABEL_48;
        }
      }
    }

    else
    {
      v13 = 1;
      v14 = *(v4 + 24);
      if (!v14)
      {
        goto LABEL_48;
      }
    }

    v16 = *(v14 + 168);
    if (v16)
    {
      result = v16(v4, a2);
      if (v13)
      {
LABEL_35:
        if ((v7 & 1) == 0)
        {
          v23 = *(v4 + 40);
          if (v23 == &nw_protocol_ref_counted_handle || v23 == &nw_protocol_ref_counted_additional_handle && (v4 = *(v4 + 64)) != 0)
          {
            v24 = *(v4 + 88);
            if (v24)
            {
              v25 = v24 - 1;
              *(v4 + 88) = v25;
              if (!v25)
              {
                v26 = result;
                v27 = *(v4 + 64);
                if (v27)
                {
                  *(v4 + 64) = 0;
                  v27[2](v27);
                  _Block_release(v27);
                }

                if (*(v4 + 72))
                {
                  v28 = *(v4 + 64);
                  if (v28)
                  {
                    _Block_release(v28);
                  }
                }

                free(v4);
                return v26;
              }
            }
          }
        }

        return result;
      }

LABEL_24:
      v17 = *(v3 + 40);
      if (v17 == &nw_protocol_ref_counted_handle || v17 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
      {
        v18 = *(v3 + 88);
        if (v18)
        {
          v19 = v18 - 1;
          *(v3 + 88) = v19;
          if (!v19)
          {
            v20 = result;
            v21 = *(v3 + 64);
            if (v21)
            {
              *(v3 + 64) = 0;
              v21[2](v21);
              _Block_release(v21);
            }

            if (*(v3 + 72))
            {
              v22 = *(v3 + 64);
              if (v22)
              {
                _Block_release(v22);
              }
            }

            free(v3);
            result = v20;
          }
        }
      }

      goto LABEL_35;
    }

LABEL_48:
    __nwlog_obj();
    v29 = *(v4 + 16);
    *buf = 136446722;
    v52 = "__nw_protocol_updated_path";
    if (!v29)
    {
      v29 = "invalid";
    }

    v53 = 2082;
    v54 = v29;
    v55 = 2048;
    v56 = v4;
    v30 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v49 = 0;
    if (__nwlog_fault(v30, &type, &v49))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v31 = __nwlog_obj();
        v32 = type;
        if (!os_log_type_enabled(v31, type))
        {
          goto LABEL_104;
        }

        v33 = *(v4 + 16);
        if (!v33)
        {
          v33 = "invalid";
        }

        *buf = 136446722;
        v52 = "__nw_protocol_updated_path";
        v53 = 2082;
        v54 = v33;
        v55 = 2048;
        v56 = v4;
        v34 = "%{public}s protocol %{public}s (%p) has invalid updated_path callback";
LABEL_103:
        _os_log_impl(&dword_181A37000, v31, v32, v34, buf, 0x20u);
        goto LABEL_104;
      }

      if (v49 != 1)
      {
        v31 = __nwlog_obj();
        v32 = type;
        if (!os_log_type_enabled(v31, type))
        {
          goto LABEL_104;
        }

        v47 = *(v4 + 16);
        if (!v47)
        {
          v47 = "invalid";
        }

        *buf = 136446722;
        v52 = "__nw_protocol_updated_path";
        v53 = 2082;
        v54 = v47;
        v55 = 2048;
        v56 = v4;
        v34 = "%{public}s protocol %{public}s (%p) has invalid updated_path callback, backtrace limit exceeded";
        goto LABEL_103;
      }

      v39 = __nw_create_backtrace_string();
      v31 = __nwlog_obj();
      v32 = type;
      v40 = os_log_type_enabled(v31, type);
      if (!v39)
      {
        if (!v40)
        {
          goto LABEL_104;
        }

        v48 = *(v4 + 16);
        if (!v48)
        {
          v48 = "invalid";
        }

        *buf = 136446722;
        v52 = "__nw_protocol_updated_path";
        v53 = 2082;
        v54 = v48;
        v55 = 2048;
        v56 = v4;
        v34 = "%{public}s protocol %{public}s (%p) has invalid updated_path callback, no backtrace";
        goto LABEL_103;
      }

      if (v40)
      {
        v41 = *(v4 + 16);
        if (!v41)
        {
          v41 = "invalid";
        }

        *buf = 136446978;
        v52 = "__nw_protocol_updated_path";
        v53 = 2082;
        v54 = v41;
        v55 = 2048;
        v56 = v4;
        v57 = 2082;
        v58 = v39;
        _os_log_impl(&dword_181A37000, v31, v32, "%{public}s protocol %{public}s (%p) has invalid updated_path callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v39);
    }

LABEL_104:
    if (v30)
    {
      free(v30);
    }

    result = 0;
    if (v13)
    {
      goto LABEL_35;
    }

    goto LABEL_24;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = gLogObj;
  result = os_log_type_enabled(gLogObj, OS_LOG_TYPE_INFO);
  if (result)
  {
    *buf = 136446210;
    v52 = "nw_protocol_common_updated_path";
    _os_log_impl(&dword_181A37000, v8, OS_LOG_TYPE_INFO, "%{public}s updated_path requires an output handler", buf, 0xCu);
    return 0;
  }

  return result;
}

void nw_protocol_common_link_state(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v60 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v53 = "nw_protocol_common_link_state";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v4, &type, &v50))
    {
      goto LABEL_59;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_59;
      }

      *buf = 136446210;
      v53 = "nw_protocol_common_link_state";
      v10 = "%{public}s called with null protocol";
      goto LABEL_57;
    }

    if (v50 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v44 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (!v44)
        {
          goto LABEL_104;
        }

        *buf = 136446466;
        v53 = "nw_protocol_common_link_state";
        v54 = 2082;
        v55 = backtrace_string;
        v45 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_103;
      }

      if (!v44)
      {
        goto LABEL_59;
      }

      *buf = 136446210;
      v53 = "nw_protocol_common_link_state";
      v10 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_59;
      }

      *buf = 136446210;
      v53 = "nw_protocol_common_link_state";
      v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_57:
    v32 = v8;
    v33 = v9;
LABEL_58:
    _os_log_impl(&dword_181A37000, v32, v33, v10, buf, 0xCu);
    goto LABEL_59;
  }

  v3 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v53 = "nw_protocol_common_link_state";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v4, &type, &v50))
    {
      goto LABEL_59;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_59;
      }

      *buf = 136446210;
      v53 = "nw_protocol_common_link_state";
      v10 = "%{public}s called with null other_protocol";
      goto LABEL_57;
    }

    if (v50 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v46 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (!v46)
        {
          goto LABEL_104;
        }

        *buf = 136446466;
        v53 = "nw_protocol_common_link_state";
        v54 = 2082;
        v55 = backtrace_string;
        v45 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
        goto LABEL_103;
      }

      if (!v46)
      {
        goto LABEL_59;
      }

      *buf = 136446210;
      v53 = "nw_protocol_common_link_state";
      v10 = "%{public}s called with null other_protocol, no backtrace";
    }

    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_59;
      }

      *buf = 136446210;
      v53 = "nw_protocol_common_link_state";
      v10 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    }

    goto LABEL_57;
  }

  if (a3)
  {
    v4 = *(a1 + 48);
    if (v4)
    {
      v5 = *(v4 + 40);
      v6 = *(a1 + 48);
      if (v5 == &nw_protocol_ref_counted_handle || v5 == &nw_protocol_ref_counted_additional_handle && (v6 = *(v4 + 64)) != 0)
      {
        v15 = *(v6 + 88);
        v7 = 0;
        if (v15)
        {
          *(v6 + 88) = v15 + 1;
        }
      }

      else
      {
        v7 = 1;
      }

      v16 = *(a2 + 40);
      v17 = a2;
      if (v16 == &nw_protocol_ref_counted_handle || v16 == &nw_protocol_ref_counted_additional_handle && (v17 = *(a2 + 64)) != 0)
      {
        v20 = *(v17 + 88);
        if (v20)
        {
          v18 = 0;
          *(v17 + 88) = v20 + 1;
          v19 = *(v4 + 24);
          if (!v19)
          {
            goto LABEL_64;
          }
        }

        else
        {
          v18 = 0;
          v19 = *(v4 + 24);
          if (!v19)
          {
            goto LABEL_64;
          }
        }
      }

      else
      {
        v18 = 1;
        v19 = *(v4 + 24);
        if (!v19)
        {
          goto LABEL_64;
        }
      }

      v21 = *(v19 + 104);
      if (v21)
      {
        v21(v4, a2);
        goto LABEL_32;
      }

LABEL_64:
      __nwlog_obj();
      v34 = *(v4 + 16);
      *buf = 136446722;
      v53 = "__nw_protocol_link_state";
      if (!v34)
      {
        v34 = "invalid";
      }

      v54 = 2082;
      v55 = v34;
      v56 = 2048;
      v57 = v4;
      v35 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v50 = 0;
      if (!__nwlog_fault(v35, &type, &v50))
      {
        goto LABEL_121;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v36 = __nwlog_obj();
        v37 = type;
        if (!os_log_type_enabled(v36, type))
        {
          goto LABEL_121;
        }

        v38 = *(v4 + 16);
        if (!v38)
        {
          v38 = "invalid";
        }

        *buf = 136446722;
        v53 = "__nw_protocol_link_state";
        v54 = 2082;
        v55 = v38;
        v56 = 2048;
        v57 = v4;
        v39 = "%{public}s protocol %{public}s (%p) has invalid link_state callback";
      }

      else if (v50 == 1)
      {
        v40 = __nw_create_backtrace_string();
        v36 = __nwlog_obj();
        v37 = type;
        v41 = os_log_type_enabled(v36, type);
        if (v40)
        {
          if (v41)
          {
            v42 = *(v4 + 16);
            if (!v42)
            {
              v42 = "invalid";
            }

            *buf = 136446978;
            v53 = "__nw_protocol_link_state";
            v54 = 2082;
            v55 = v42;
            v56 = 2048;
            v57 = v4;
            v58 = 2082;
            v59 = v40;
            _os_log_impl(&dword_181A37000, v36, v37, "%{public}s protocol %{public}s (%p) has invalid link_state callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v40);
          goto LABEL_121;
        }

        if (!v41)
        {
LABEL_121:
          if (v35)
          {
            free(v35);
          }

LABEL_32:
          if ((v18 & 1) == 0)
          {
            v22 = *(v3 + 40);
            if (v22 == &nw_protocol_ref_counted_handle || v22 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
            {
              v23 = *(v3 + 88);
              if (v23)
              {
                v24 = v23 - 1;
                *(v3 + 88) = v24;
                if (!v24)
                {
                  v25 = *(v3 + 64);
                  if (v25)
                  {
                    *(v3 + 64) = 0;
                    v25[2](v25);
                    _Block_release(v25);
                  }

                  if (*(v3 + 72))
                  {
                    v26 = *(v3 + 64);
                    if (v26)
                    {
                      _Block_release(v26);
                    }
                  }

                  free(v3);
                }
              }
            }
          }

          if ((v7 & 1) == 0)
          {
            v27 = *(v4 + 40);
            if (v27 == &nw_protocol_ref_counted_handle || v27 == &nw_protocol_ref_counted_additional_handle && (v4 = *(v4 + 64)) != 0)
            {
              v28 = *(v4 + 88);
              if (v28)
              {
                v29 = v28 - 1;
                *(v4 + 88) = v29;
                if (!v29)
                {
                  v30 = *(v4 + 64);
                  if (v30)
                  {
                    *(v4 + 64) = 0;
                    v30[2](v30);
                    _Block_release(v30);
                  }

                  if (*(v4 + 72))
                  {
                    v31 = *(v4 + 64);
                    if (v31)
                    {
                      _Block_release(v31);
                    }
                  }

                  goto LABEL_60;
                }
              }
            }
          }

          return;
        }

        v49 = *(v4 + 16);
        if (!v49)
        {
          v49 = "invalid";
        }

        *buf = 136446722;
        v53 = "__nw_protocol_link_state";
        v54 = 2082;
        v55 = v49;
        v56 = 2048;
        v57 = v4;
        v39 = "%{public}s protocol %{public}s (%p) has invalid link_state callback, no backtrace";
      }

      else
      {
        v36 = __nwlog_obj();
        v37 = type;
        if (!os_log_type_enabled(v36, type))
        {
          goto LABEL_121;
        }

        v48 = *(v4 + 16);
        if (!v48)
        {
          v48 = "invalid";
        }

        *buf = 136446722;
        v53 = "__nw_protocol_link_state";
        v54 = 2082;
        v55 = v48;
        v56 = 2048;
        v57 = v4;
        v39 = "%{public}s protocol %{public}s (%p) has invalid link_state callback, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A37000, v36, v37, v39, buf, 0x20u);
      goto LABEL_121;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v53 = "nw_protocol_common_link_state";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (__nwlog_fault(v4, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_59;
        }

        *buf = 136446210;
        v53 = "nw_protocol_common_link_state";
        v10 = "%{public}s link_state requires a default input handler";
        goto LABEL_57;
      }

      if (v50 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_59;
        }

        *buf = 136446210;
        v53 = "nw_protocol_common_link_state";
        v10 = "%{public}s link_state requires a default input handler, backtrace limit exceeded";
        goto LABEL_57;
      }

      v11 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      v14 = os_log_type_enabled(gLogObj, type);
      if (v11)
      {
        if (v14)
        {
          *buf = 136446466;
          v53 = "nw_protocol_common_link_state";
          v54 = 2082;
          v55 = v11;
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s link_state requires a default input handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v11);
        if (v4)
        {
          goto LABEL_60;
        }

        return;
      }

      if (v14)
      {
        *buf = 136446210;
        v53 = "nw_protocol_common_link_state";
        v10 = "%{public}s link_state requires a default input handler, no backtrace";
        v32 = v12;
        v33 = v13;
        goto LABEL_58;
      }
    }

LABEL_59:
    if (!v4)
    {
      return;
    }

    goto LABEL_60;
  }

  __nwlog_obj();
  *buf = 136446210;
  v53 = "nw_protocol_common_link_state";
  v4 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v50 = 0;
  if (!__nwlog_fault(v4, &type, &v50))
  {
    goto LABEL_59;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
    {
      goto LABEL_59;
    }

    *buf = 136446210;
    v53 = "nw_protocol_common_link_state";
    v10 = "%{public}s called with null link_info";
    goto LABEL_57;
  }

  if (v50 != 1)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
    {
      goto LABEL_59;
    }

    *buf = 136446210;
    v53 = "nw_protocol_common_link_state";
    v10 = "%{public}s called with null link_info, backtrace limit exceeded";
    goto LABEL_57;
  }

  backtrace_string = __nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v9 = type;
  v47 = os_log_type_enabled(v8, type);
  if (!backtrace_string)
  {
    if (!v47)
    {
      goto LABEL_59;
    }

    *buf = 136446210;
    v53 = "nw_protocol_common_link_state";
    v10 = "%{public}s called with null link_info, no backtrace";
    goto LABEL_57;
  }

  if (!v47)
  {
    goto LABEL_104;
  }

  *buf = 136446466;
  v53 = "nw_protocol_common_link_state";
  v54 = 2082;
  v55 = backtrace_string;
  v45 = "%{public}s called with null link_info, dumping backtrace:%{public}s";
LABEL_103:
  _os_log_impl(&dword_181A37000, v8, v9, v45, buf, 0x16u);
LABEL_104:
  free(backtrace_string);
  if (v4)
  {
LABEL_60:
    free(v4);
  }
}

uint64_t (**nw_protocol_set_common_callbacks(uint64_t (**result)(uint64_t a1, uint64_t a2)))(uint64_t a1, uint64_t a2)
{
  *result = nw_protocol_common_add_input_handler;
  result[2] = nw_protocol_common_replace_input_handler;
  result[1] = nw_protocol_common_remove_input_handler;
  result[10] = nw_protocol_common_get_input_frames;
  result[11] = nw_protocol_common_get_output_frames;
  result[12] = nw_protocol_common_finalize_output_frames;
  result[14] = nw_protocol_common_get_parameters;
  result[15] = nw_protocol_common_get_path;
  result[17] = nw_protocol_common_get_remote_endpoint;
  result[16] = nw_protocol_common_get_local_endpoint;
  result[25] = nw_protocol_common_get_output_local_endpoint;
  result[26] = nw_protocol_common_get_output_interface;
  result[3] = nw_protocol_common_connect;
  result[5] = nw_protocol_common_connected;
  result[4] = nw_protocol_common_disconnect;
  result[6] = nw_protocol_common_disconnected;
  result[8] = nw_protocol_common_input_available;
  result[9] = nw_protocol_common_output_available;
  result[23] = nw_protocol_common_input_finished;
  result[24] = nw_protocol_common_output_finished;
  result[33] = nw_protocol_common_input_flush;
  result[7] = nw_protocol_common_error;
  result[32] = nw_protocol_common_reset;
  result[31] = nw_protocol_common_get_message_properties;
  result[28] = nw_protocol_common_copy_info;
  result[22] = nw_protocol_common_supports_external_data;
  result[27] = nw_protocol_common_waiting_for_output;
  result[18] = nw_protocol_common_register_notification;
  result[19] = nw_protocol_common_unregister_notification;
  result[20] = nw_protocol_common_notify;
  result[21] = nw_protocol_common_updated_path;
  result[13] = nw_protocol_common_link_state;
  return result;
}

void sub_18287BF28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, objc_super a13)
{
  a13.super_class = NWConcrete_nw_nat64_prefixes_resolver;
  [(_Unwind_Exception *)&a13 dealloc];
  _Unwind_Resume(a1);
}

BOOL nw_nat64_can_v4_address_be_synthesized(unsigned int *a1)
{
  v22 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v1 = bswap32(*a1);
    v2 = v1 & 0xFF000000;
    v4 = *a1 != -1 && v1 >> 28 != 14;
    if (v1 >> 8 == 12605539 || (v1 & 0xFFFF0000) == -1442971648 || (v1 & 0xFFFFFFF8) == -1073741824)
    {
      v4 = 0;
    }

    if (v2)
    {
      v7 = v2 == 2130706432;
    }

    else
    {
      v7 = 1;
    }

    return !v7 && v4;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v19 = "nw_nat64_can_v4_address_be_synthesized";
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v10, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_nat64_can_v4_address_be_synthesized";
        v13 = "%{public}s called with null ipv4_addr";
LABEL_36:
        _os_log_impl(&dword_181A37000, v11, v12, v13, buf, 0xCu);
      }
    }

    else
    {
      if (v16 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v11 = __nwlog_obj();
        v12 = type;
        v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *buf = 136446466;
            v19 = "nw_nat64_can_v4_address_be_synthesized";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null ipv4_addr, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_38;
        }

        if (!v15)
        {
          goto LABEL_37;
        }

        *buf = 136446210;
        v19 = "nw_nat64_can_v4_address_be_synthesized";
        v13 = "%{public}s called with null ipv4_addr, no backtrace";
        goto LABEL_36;
      }

      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_nat64_can_v4_address_be_synthesized";
        v13 = "%{public}s called with null ipv4_addr, backtrace limit exceeded";
        goto LABEL_36;
      }
    }

LABEL_37:
  }

LABEL_38:
  if (v10)
  {
    free(v10);
  }

  return 0;
}

uint64_t nw_nat64_v4_address_requires_synthesis(unsigned int *a1)
{
  v29 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v17 = __nwlog_obj();
    *buf = 136446210;
    *v28 = "nw_nat64_v4_address_requires_synthesis";
    v18 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v18, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v19 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *buf = 136446210;
          *v28 = "nw_nat64_v4_address_requires_synthesis";
          _os_log_impl(&dword_181A37000, v19, v20, "%{public}s called with null ipv4_addr", buf, 0xCu);
        }
      }

      else if (v25 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v19 = __nwlog_obj();
        v22 = type;
        v23 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *buf = 136446466;
            *v28 = "nw_nat64_v4_address_requires_synthesis";
            *&v28[8] = 2082;
            *&v28[10] = backtrace_string;
            _os_log_impl(&dword_181A37000, v19, v22, "%{public}s called with null ipv4_addr, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_43;
        }

        if (v23)
        {
          *buf = 136446210;
          *v28 = "nw_nat64_v4_address_requires_synthesis";
          _os_log_impl(&dword_181A37000, v19, v22, "%{public}s called with null ipv4_addr, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v19 = __nwlog_obj();
        v24 = type;
        if (os_log_type_enabled(v19, type))
        {
          *buf = 136446210;
          *v28 = "nw_nat64_v4_address_requires_synthesis";
          _os_log_impl(&dword_181A37000, v19, v24, "%{public}s called with null ipv4_addr, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_43:
    if (v18)
    {
      free(v18);
    }

    return 0;
  }

  v1 = *a1;
  v2 = bswap32(*a1);
  if ((v2 & 0xFF000000) == 0 || (v2 & 0xFF000000) == 2130706432)
  {
    return 0;
  }

  v6 = v2 >> 8 == 12605539 || (v2 & 0xFFFF0000) == -1442971648;
  is_eligible_for_CrazyIvan46 = 0;
  v7 = v6 || (v2 & 0xFFFFFFF8) == -1073741824;
  if (!v7 && v1 != -1 && (v2 & 0xF0000000) != 0xE0000000)
  {
    *buf = 528;
    *v28 = v1;
    *&v28[4] = 0;
    address = _nw_endpoint_create_address(buf);
    v9 = address;
    if (address && (v10 = nw_path_create_evaluator_for_endpoint(address, 0)) != 0)
    {
      v11 = v10;
      v12 = v10;
      os_unfair_lock_lock(v11 + 24);
      v13 = v12[6];
      os_unfair_lock_unlock(v11 + 24);

      if (v13 && (v13 = v13, status = _nw_path_get_status(v13), v13, status == 2))
      {
        evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0, 0);

        v16 = nw_path_evaluator_copy_path(evaluator_for_endpoint);
        is_eligible_for_CrazyIvan46 = nw_path_is_eligible_for_CrazyIvan46(v16);
        v12 = evaluator_for_endpoint;
        v13 = v16;
      }

      else
      {
        is_eligible_for_CrazyIvan46 = 0;
      }
    }

    else
    {
      is_eligible_for_CrazyIvan46 = 0;
    }
  }

  return is_eligible_for_CrazyIvan46;
}

unint64_t nw_nat64_synthesize_v6(int *__src, __int16 *a2, char *__dst)
{
  *&v47[13] = *MEMORY[0x1E69E9840];
  if (!__src)
  {
    v35 = __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_nat64_synthesize_v6";
    v17 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v17, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v18 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v18, type))
        {
          goto LABEL_55;
        }

        *buf = 136446210;
        v45 = "nw_nat64_synthesize_v6";
        v21 = "%{public}s called with null prefix";
        goto LABEL_95;
      }

      if (v42 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v18 = __nwlog_obj();
        v36 = type;
        v39 = os_log_type_enabled(v18, type);
        if (backtrace_string)
        {
          if (!v39)
          {
            goto LABEL_48;
          }

          *buf = 136446466;
          v45 = "nw_nat64_synthesize_v6";
          v46 = 2082;
          *v47 = backtrace_string;
          v26 = "%{public}s called with null prefix, dumping backtrace:%{public}s";
          goto LABEL_82;
        }

        if (!v39)
        {
          goto LABEL_55;
        }

        *buf = 136446210;
        v45 = "nw_nat64_synthesize_v6";
        v21 = "%{public}s called with null prefix, no backtrace";
      }

      else
      {
        v18 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v18, type))
        {
          goto LABEL_55;
        }

        *buf = 136446210;
        v45 = "nw_nat64_synthesize_v6";
        v21 = "%{public}s called with null prefix, backtrace limit exceeded";
      }

      goto LABEL_95;
    }

    goto LABEL_56;
  }

  if (!a2)
  {
    v37 = __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_nat64_synthesize_v6";
    v17 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v17, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v18 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v18, type))
        {
          goto LABEL_55;
        }

        *buf = 136446210;
        v45 = "nw_nat64_synthesize_v6";
        v21 = "%{public}s called with null ipv4_addr";
        goto LABEL_95;
      }

      if (v42 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v18 = __nwlog_obj();
        v36 = type;
        v40 = os_log_type_enabled(v18, type);
        if (backtrace_string)
        {
          if (!v40)
          {
            goto LABEL_48;
          }

          *buf = 136446466;
          v45 = "nw_nat64_synthesize_v6";
          v46 = 2082;
          *v47 = backtrace_string;
          v26 = "%{public}s called with null ipv4_addr, dumping backtrace:%{public}s";
          goto LABEL_82;
        }

        if (!v40)
        {
          goto LABEL_55;
        }

        *buf = 136446210;
        v45 = "nw_nat64_synthesize_v6";
        v21 = "%{public}s called with null ipv4_addr, no backtrace";
      }

      else
      {
        v18 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v18, type))
        {
          goto LABEL_55;
        }

        *buf = 136446210;
        v45 = "nw_nat64_synthesize_v6";
        v21 = "%{public}s called with null ipv4_addr, backtrace limit exceeded";
      }

LABEL_95:
      v32 = v18;
      v33 = v36;
      v34 = 12;
      goto LABEL_54;
    }

LABEL_56:
    if (v17)
    {
      free(v17);
    }

    return 0;
  }

  if (!__dst)
  {
    v38 = __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_nat64_synthesize_v6";
    v17 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v17, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v18 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v18, type))
        {
          goto LABEL_55;
        }

        *buf = 136446210;
        v45 = "nw_nat64_synthesize_v6";
        v21 = "%{public}s called with null out_ipv6_addr";
        goto LABEL_95;
      }

      if (v42 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v18 = __nwlog_obj();
        v36 = type;
        v41 = os_log_type_enabled(v18, type);
        if (backtrace_string)
        {
          if (!v41)
          {
            goto LABEL_48;
          }

          *buf = 136446466;
          v45 = "nw_nat64_synthesize_v6";
          v46 = 2082;
          *v47 = backtrace_string;
          v26 = "%{public}s called with null out_ipv6_addr, dumping backtrace:%{public}s";
LABEL_82:
          v27 = v18;
          v28 = v36;
          v29 = 22;
          goto LABEL_47;
        }

        if (!v41)
        {
          goto LABEL_55;
        }

        *buf = 136446210;
        v45 = "nw_nat64_synthesize_v6";
        v21 = "%{public}s called with null out_ipv6_addr, no backtrace";
      }

      else
      {
        v18 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v18, type))
        {
          goto LABEL_55;
        }

        *buf = 136446210;
        v45 = "nw_nat64_synthesize_v6";
        v21 = "%{public}s called with null out_ipv6_addr, backtrace limit exceeded";
      }

      goto LABEL_95;
    }

    goto LABEL_56;
  }

  v3 = bswap32(*a2);
  v4 = v3 & 0xFF000000;
  if ((v3 & 0xFF000000) == 0 || v4 == 2130706432)
  {
    return 0;
  }

  v8 = v3 & 0xFFFF0000;
  v9 = v3 >> 8 == 12605539 || v8 == -1442971648;
  if (v9 || (v3 & 0xFFFFFFF8) == -1073741824)
  {
    return 0;
  }

  v6 = 0;
  if (*a2 != -1 && (v3 & 0xF0000000) != 0xE0000000)
  {
    v6 = *__src ^ 0x9BFF64000000000CLL | *(__src + 1);
    if (v6 || v3 >> 22 != 401 && v8 != -1062731776 && v4 != 167772160 && (v3 & 0xFFF00000) != 0xAC100000)
    {
      *__dst = 0;
      *(__dst + 1) = 0;
      v11 = *__src;
      if (*__src > 6)
      {
        switch(v11)
        {
          case 7:
            __dst[7] = *a2;
            v12 = *(a2 + 1);
            __dst[11] = *(a2 + 3);
            *(__dst + 9) = v12;
            goto LABEL_42;
          case 8:
            *(__dst + 9) = *a2;
            goto LABEL_42;
          case 12:
            *(__dst + 3) = *a2;
            goto LABEL_42;
        }
      }

      else
      {
        switch(v11)
        {
          case 4:
            *(__dst + 1) = *a2;
            goto LABEL_42;
          case 5:
            v22 = *a2;
            __dst[7] = *(a2 + 2);
            *(__dst + 5) = v22;
            __dst[9] = *(a2 + 3);
            goto LABEL_42;
          case 6:
            *(__dst + 3) = *a2;
            *(__dst + 9) = a2[1];
LABEL_42:
            memcpy(__dst, __src + 1, *__src);
            return 1;
        }
      }

      v14 = __nwlog_obj();
      v15 = __src;
      v16 = *__src;
      *buf = 136446466;
      v45 = "nw_nat64_synthesize_v6";
      v46 = 1024;
      *v47 = v16;
      v17 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v42 = 0;
      if (!__nwlog_fault(v17, &type, &v42))
      {
        goto LABEL_56;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v18 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          v20 = *v15;
          *buf = 136446466;
          v45 = "nw_nat64_synthesize_v6";
          v46 = 1024;
          *v47 = v20;
          v21 = "%{public}s invalid prefix length %d";
LABEL_53:
          v32 = v18;
          v33 = v19;
          v34 = 18;
LABEL_54:
          _os_log_impl(&dword_181A37000, v32, v33, v21, buf, v34);
          goto LABEL_55;
        }

        goto LABEL_55;
      }

      if (v42 != 1)
      {
        v18 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          v30 = *v15;
          *buf = 136446466;
          v45 = "nw_nat64_synthesize_v6";
          v46 = 1024;
          *v47 = v30;
          v21 = "%{public}s invalid prefix length %d, backtrace limit exceeded";
          goto LABEL_53;
        }

LABEL_55:

        goto LABEL_56;
      }

      backtrace_string = __nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v19 = type;
      v24 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v24)
        {
          v31 = *v15;
          *buf = 136446466;
          v45 = "nw_nat64_synthesize_v6";
          v46 = 1024;
          *v47 = v31;
          v21 = "%{public}s invalid prefix length %d, no backtrace";
          goto LABEL_53;
        }

        goto LABEL_55;
      }

      if (!v24)
      {
LABEL_48:

        free(backtrace_string);
        goto LABEL_56;
      }

      v25 = *v15;
      *buf = 136446722;
      v45 = "nw_nat64_synthesize_v6";
      v46 = 1024;
      *v47 = v25;
      v47[2] = 2082;
      *&v47[3] = backtrace_string;
      v26 = "%{public}s invalid prefix length %d, dumping backtrace:%{public}s";
      v27 = v18;
      v28 = v19;
      v29 = 28;
LABEL_47:
      _os_log_impl(&dword_181A37000, v27, v28, v26, buf, v29);
      goto LABEL_48;
    }
  }

  return v6;
}

uint64_t nw_nat64_extract_v4(unsigned int *a1, char *__s1, uint64_t a3)
{
  v56 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v36 = __nwlog_obj();
    *v53 = 136446210;
    *&v53[4] = "nw_nat64_extract_v4";
    v11 = _os_log_send_and_compose_impl();

    v51[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (!__nwlog_fault(v11, v51, buf))
    {
      goto LABEL_34;
    }

    if (v51[0] == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0]))
      {
        goto LABEL_33;
      }

      *v53 = 136446210;
      *&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null prefix";
      goto LABEL_98;
    }

    if (buf[0] == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v37 = v51[0];
      v41 = os_log_type_enabled(v12, v51[0]);
      if (backtrace_string)
      {
        if (!v41)
        {
          goto LABEL_84;
        }

        *v53 = 136446466;
        *&v53[4] = "nw_nat64_extract_v4";
        *&v53[12] = 2082;
        *&v53[14] = backtrace_string;
        v42 = "%{public}s called with null prefix, dumping backtrace:%{public}s";
        goto LABEL_83;
      }

      if (!v41)
      {
        goto LABEL_33;
      }

      *v53 = 136446210;
      *&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null prefix, no backtrace";
    }

    else
    {
      v12 = __nwlog_obj();
      v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0]))
      {
        goto LABEL_33;
      }

      *v53 = 136446210;
      *&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null prefix, backtrace limit exceeded";
    }

LABEL_98:
    v19 = v53;
    v20 = v12;
    v21 = v37;
    v22 = 12;
    goto LABEL_32;
  }

  if (!__s1)
  {
    v38 = __nwlog_obj();
    *v53 = 136446210;
    *&v53[4] = "nw_nat64_extract_v4";
    v11 = _os_log_send_and_compose_impl();

    v51[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (!__nwlog_fault(v11, v51, buf))
    {
      goto LABEL_34;
    }

    if (v51[0] == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0]))
      {
        goto LABEL_33;
      }

      *v53 = 136446210;
      *&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null ipv6_addr";
      goto LABEL_98;
    }

    if (buf[0] == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v37 = v51[0];
      v43 = os_log_type_enabled(v12, v51[0]);
      if (backtrace_string)
      {
        if (!v43)
        {
          goto LABEL_84;
        }

        *v53 = 136446466;
        *&v53[4] = "nw_nat64_extract_v4";
        *&v53[12] = 2082;
        *&v53[14] = backtrace_string;
        v42 = "%{public}s called with null ipv6_addr, dumping backtrace:%{public}s";
        goto LABEL_83;
      }

      if (!v43)
      {
        goto LABEL_33;
      }

      *v53 = 136446210;
      *&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null ipv6_addr, no backtrace";
    }

    else
    {
      v12 = __nwlog_obj();
      v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0]))
      {
        goto LABEL_33;
      }

      *v53 = 136446210;
      *&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null ipv6_addr, backtrace limit exceeded";
    }

    goto LABEL_98;
  }

  if (!a3)
  {
    v39 = __nwlog_obj();
    *v53 = 136446210;
    *&v53[4] = "nw_nat64_extract_v4";
    v11 = _os_log_send_and_compose_impl();

    v51[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (!__nwlog_fault(v11, v51, buf))
    {
      goto LABEL_34;
    }

    if (v51[0] == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0]))
      {
        goto LABEL_33;
      }

      *v53 = 136446210;
      *&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null out_ipv4_addr";
      goto LABEL_98;
    }

    if (buf[0] == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v37 = v51[0];
      v44 = os_log_type_enabled(v12, v51[0]);
      if (backtrace_string)
      {
        if (!v44)
        {
          goto LABEL_84;
        }

        *v53 = 136446466;
        *&v53[4] = "nw_nat64_extract_v4";
        *&v53[12] = 2082;
        *&v53[14] = backtrace_string;
        v42 = "%{public}s called with null out_ipv4_addr, dumping backtrace:%{public}s";
LABEL_83:
        _os_log_impl(&dword_181A37000, v12, v37, v42, v53, 0x16u);
LABEL_84:

        free(backtrace_string);
        if (!v11)
        {
          return 0;
        }

        goto LABEL_35;
      }

      if (!v44)
      {
        goto LABEL_33;
      }

      *v53 = 136446210;
      *&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null out_ipv4_addr, no backtrace";
    }

    else
    {
      v12 = __nwlog_obj();
      v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0]))
      {
        goto LABEL_33;
      }

      *v53 = 136446210;
      *&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null out_ipv4_addr, backtrace limit exceeded";
    }

    goto LABEL_98;
  }

  v6 = *a1;
  if (memcmp(__s1, a1 + 1, v6))
  {
    v55 = 0;
    v54 = 0u;
    memset(v53, 0, sizeof(v53));
    nw_nat64_write_prefix_to_string(a1, v53, 0x32u);
    *v51 = 0u;
    memset(v52, 0, sizeof(v52));
    if (inet_ntop(30, __s1, v51, 0x2Eu))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446723;
        v48 = "nw_nat64_extract_v4";
        v49 = 2085;
        *v50 = v53;
        *&v50[8] = 2085;
        *&v50[10] = v51;
        _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_ERROR, "%{public}s prefix %{sensitive}s does not match address %{sensitive}s", buf, 0x20u);
      }

      return 0;
    }

    v9 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    *buf = 136446466;
    v48 = "nw_nat64_extract_v4";
    v49 = 1024;
    *v50 = v9;
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (__nwlog_fault(v11, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446466;
          v48 = "nw_nat64_extract_v4";
          v49 = 1024;
          *v50 = v9;
          v14 = "%{public}s inet_ntop failed %{darwin.errno}d";
LABEL_30:
          v19 = buf;
          v20 = v12;
          v21 = v13;
LABEL_31:
          v22 = 18;
LABEL_32:
          _os_log_impl(&dword_181A37000, v20, v21, v14, v19, v22);
        }
      }

      else
      {
        if (v45 == 1)
        {
          v16 = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = gLogObj;
          v17 = type;
          v18 = os_log_type_enabled(v12, type);
          if (v16)
          {
            if (v18)
            {
              *buf = 136446722;
              v48 = "nw_nat64_extract_v4";
              v49 = 1024;
              *v50 = v9;
              *&v50[4] = 2082;
              *&v50[6] = v16;
              _os_log_impl(&dword_181A37000, v12, v17, "%{public}s inet_ntop failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v16);
            if (!v11)
            {
              return 0;
            }

            goto LABEL_35;
          }

          if (!v18)
          {
            goto LABEL_33;
          }

          *buf = 136446466;
          v48 = "nw_nat64_extract_v4";
          v49 = 1024;
          *v50 = v9;
          v14 = "%{public}s inet_ntop failed %{darwin.errno}d, no backtrace";
          v19 = buf;
          v20 = v12;
          v21 = v17;
          goto LABEL_31;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446466;
          v48 = "nw_nat64_extract_v4";
          v49 = 1024;
          *v50 = v9;
          v14 = "%{public}s inet_ntop failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_30;
        }
      }

LABEL_33:
    }

LABEL_34:
    if (!v11)
    {
      return 0;
    }

LABEL_35:
    free(v11);
    return 0;
  }

  if (v6 > 6)
  {
    switch(v6)
    {
      case 7:
        *a3 = __s1[7];
        v23 = *(__s1 + 9);
        *(a3 + 3) = __s1[11];
        *(a3 + 1) = v23;
        return 1;
      case 8:
        v15 = *(__s1 + 9);
        break;
      case 0xC:
        v15 = *(__s1 + 3);
        break;
      default:
        goto LABEL_39;
    }

    goto LABEL_45;
  }

  if (v6 == 4)
  {
    v15 = *(__s1 + 1);
LABEL_45:
    *a3 = v15;
    return 1;
  }

  if (v6 != 5)
  {
    if (v6 == 6)
    {
      *a3 = *(__s1 + 3);
      *(a3 + 2) = *(__s1 + 9);
      return 1;
    }

LABEL_39:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = gLogObj;
    v25 = *a1;
    *v53 = 136446466;
    *&v53[4] = "nw_nat64_extract_v4";
    *&v53[12] = 1024;
    *&v53[14] = v25;
    v11 = _os_log_send_and_compose_impl();

    v51[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (!__nwlog_fault(v11, v51, buf))
    {
      goto LABEL_34;
    }

    if (v51[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = gLogObj;
      v27 = v51[0];
      if (os_log_type_enabled(v26, v51[0]))
      {
        v28 = *a1;
        *v53 = 136446466;
        *&v53[4] = "nw_nat64_extract_v4";
        *&v53[12] = 1024;
        *&v53[14] = v28;
        v29 = "%{public}s invalid prefix length %d";
LABEL_57:
        _os_log_impl(&dword_181A37000, v26, v27, v29, v53, 0x12u);
      }
    }

    else if (buf[0] == 1)
    {
      v31 = __nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = v51[0];
      v32 = os_log_type_enabled(v26, v51[0]);
      if (v31)
      {
        if (v32)
        {
          v33 = *a1;
          *v53 = 136446722;
          *&v53[4] = "nw_nat64_extract_v4";
          *&v53[12] = 1024;
          *&v53[14] = v33;
          *&v53[18] = 2082;
          *&v53[20] = v31;
          _os_log_impl(&dword_181A37000, v26, v27, "%{public}s invalid prefix length %d, dumping backtrace:%{public}s", v53, 0x1Cu);
        }

        free(v31);
        goto LABEL_34;
      }

      if (v32)
      {
        v35 = *a1;
        *v53 = 136446466;
        *&v53[4] = "nw_nat64_extract_v4";
        *&v53[12] = 1024;
        *&v53[14] = v35;
        v29 = "%{public}s invalid prefix length %d, no backtrace";
        goto LABEL_57;
      }
    }

    else
    {
      v26 = __nwlog_obj();
      v27 = v51[0];
      if (os_log_type_enabled(v26, v51[0]))
      {
        v34 = *a1;
        *v53 = 136446466;
        *&v53[4] = "nw_nat64_extract_v4";
        *&v53[12] = 1024;
        *&v53[14] = v34;
        v29 = "%{public}s invalid prefix length %d, backtrace limit exceeded";
        goto LABEL_57;
      }
    }

    goto LABEL_34;
  }

  v30 = *(__s1 + 5);
  *(a3 + 2) = __s1[7];
  *a3 = v30;
  *(a3 + 3) = __s1[9];
  return 1;
}

uint64_t nw_nat64_write_prefix_to_string(unsigned int *a1, char *a2, socklen_t a3)
{
  v76 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v57 = __nwlog_obj();
    *buf = 136446210;
    v67 = "nw_nat64_write_prefix_to_string";
    v38 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v65 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v38, type, &v65))
    {
      goto LABEL_81;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v58 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v67 = "nw_nat64_write_prefix_to_string";
      v22 = "%{public}s called with null prefix";
    }

    else if (v65 == OS_LOG_TYPE_INFO)
    {
      backtrace_string = __nw_create_backtrace_string();
      v20 = __nwlog_obj();
      v58 = type[0];
      v61 = os_log_type_enabled(v20, type[0]);
      if (backtrace_string)
      {
        if (v61)
        {
          *buf = 136446466;
          v67 = "nw_nat64_write_prefix_to_string";
          v68 = 2082;
          *v69 = backtrace_string;
          _os_log_impl(&dword_181A37000, v20, v58, "%{public}s called with null prefix, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_81;
      }

      if (!v61)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v67 = "nw_nat64_write_prefix_to_string";
      v22 = "%{public}s called with null prefix, no backtrace";
    }

    else
    {
      v20 = __nwlog_obj();
      v58 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v67 = "nw_nat64_write_prefix_to_string";
      v22 = "%{public}s called with null prefix, backtrace limit exceeded";
    }

LABEL_112:
    v47 = v20;
    v48 = v58;
    v49 = 12;
    goto LABEL_57;
  }

  if (!a2)
  {
    v59 = __nwlog_obj();
    *buf = 136446210;
    v67 = "nw_nat64_write_prefix_to_string";
    v38 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v65 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v38, type, &v65))
    {
      goto LABEL_81;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v58 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v67 = "nw_nat64_write_prefix_to_string";
      v22 = "%{public}s called with null dst";
    }

    else if (v65 == OS_LOG_TYPE_INFO)
    {
      v62 = __nw_create_backtrace_string();
      v20 = __nwlog_obj();
      v58 = type[0];
      v63 = os_log_type_enabled(v20, type[0]);
      if (v62)
      {
        if (v63)
        {
          *buf = 136446466;
          v67 = "nw_nat64_write_prefix_to_string";
          v68 = 2082;
          *v69 = v62;
          _os_log_impl(&dword_181A37000, v20, v58, "%{public}s called with null dst, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v62);
        if (!v38)
        {
          return 0;
        }

        goto LABEL_82;
      }

      if (!v63)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v67 = "nw_nat64_write_prefix_to_string";
      v22 = "%{public}s called with null dst, no backtrace";
    }

    else
    {
      v20 = __nwlog_obj();
      v58 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v67 = "nw_nat64_write_prefix_to_string";
      v22 = "%{public}s called with null dst, backtrace limit exceeded";
    }

    goto LABEL_112;
  }

  if (a3 > 0x31)
  {
    v11 = *a1;
    if ((v11 - 4) >= 5 && v11 != 12)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v36 = gLogObj;
      v37 = *a1;
      *buf = 136446466;
      v67 = "nw_nat64_write_prefix_to_string";
      v68 = 1024;
      *v69 = v37;
      v38 = _os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v65 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v38, type, &v65))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v40 = gLogObj;
          v41 = type[0];
          if (os_log_type_enabled(v40, type[0]))
          {
            v42 = *a1;
            *buf = 136446466;
            v67 = "nw_nat64_write_prefix_to_string";
            v68 = 1024;
            *v69 = v42;
            v43 = "%{public}s invalid prefix length %d";
LABEL_79:
            _os_log_impl(&dword_181A37000, v40, v41, v43, buf, 0x12u);
          }
        }

        else
        {
          if (v65 == OS_LOG_TYPE_INFO)
          {
            v50 = __nw_create_backtrace_string();
            v40 = __nwlog_obj();
            v41 = type[0];
            v51 = os_log_type_enabled(v40, type[0]);
            if (v50)
            {
              if (v51)
              {
                v52 = *a1;
                *buf = 136446722;
                v67 = "nw_nat64_write_prefix_to_string";
                v68 = 1024;
                *v69 = v52;
                *&v69[4] = 2082;
                *&v69[6] = v50;
                _os_log_impl(&dword_181A37000, v40, v41, "%{public}s invalid prefix length %d, dumping backtrace:%{public}s", buf, 0x1Cu);
              }

              free(v50);
              if (!v38)
              {
                return 0;
              }

              goto LABEL_82;
            }

            if (!v51)
            {
              goto LABEL_80;
            }

            v56 = *a1;
            *buf = 136446466;
            v67 = "nw_nat64_write_prefix_to_string";
            v68 = 1024;
            *v69 = v56;
            v43 = "%{public}s invalid prefix length %d, no backtrace";
            goto LABEL_79;
          }

          v40 = __nwlog_obj();
          v41 = type[0];
          if (os_log_type_enabled(v40, type[0]))
          {
            v54 = *a1;
            *buf = 136446466;
            v67 = "nw_nat64_write_prefix_to_string";
            v68 = 1024;
            *v69 = v54;
            v43 = "%{public}s invalid prefix length %d, backtrace limit exceeded";
            goto LABEL_79;
          }
        }

LABEL_80:
      }

LABEL_81:
      if (!v38)
      {
        return 0;
      }

LABEL_82:
      v32 = v38;
      goto LABEL_83;
    }

    *type = 0;
    v75 = 0;
    memcpy(type, a1 + 1, v11);
    if (inet_ntop(30, type, a2, a3))
    {
      v13 = strlen(a2);
      if (snprintf(&a2[v13], a3 - v13, "/%d", 8 * *a1) > 2)
      {
        return 1;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = gLogObj;
      v24 = *a1;
      *buf = 136447234;
      v67 = "nw_nat64_write_prefix_to_string";
      v68 = 1024;
      *v69 = v24;
      *&v69[4] = 1024;
      *&v69[6] = a3;
      *&v69[10] = 2048;
      *&v69[12] = v13;
      v70 = 2082;
      v71 = a2;
      v25 = _os_log_send_and_compose_impl();

      v65 = OS_LOG_TYPE_ERROR;
      v64 = 0;
      if (__nwlog_fault(v25, &v65, &v64))
      {
        if (v65 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v26 = gLogObj;
          v27 = v65;
          if (os_log_type_enabled(v26, v65))
          {
            v28 = *a1;
            *buf = 136447234;
            v67 = "nw_nat64_write_prefix_to_string";
            v68 = 1024;
            *v69 = v28;
            *&v69[4] = 1024;
            *&v69[6] = a3;
            *&v69[10] = 2048;
            *&v69[12] = v13;
            v70 = 2082;
            v71 = a2;
            v29 = "%{public}s snprintf failed: prefix->length=%d, dst_length=%u strlen_dst=%zu, dst=%{public}s";
LABEL_73:
            _os_log_impl(&dword_181A37000, v26, v27, v29, buf, 0x2Cu);
            goto LABEL_74;
          }

          goto LABEL_74;
        }

        if (v64 != 1)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v26 = gLogObj;
          v27 = v65;
          if (os_log_type_enabled(v26, v65))
          {
            v53 = *a1;
            *buf = 136447234;
            v67 = "nw_nat64_write_prefix_to_string";
            v68 = 1024;
            *v69 = v53;
            *&v69[4] = 1024;
            *&v69[6] = a3;
            *&v69[10] = 2048;
            *&v69[12] = v13;
            v70 = 2082;
            v71 = a2;
            v29 = "%{public}s snprintf failed: prefix->length=%d, dst_length=%u strlen_dst=%zu, dst=%{public}s, backtrace limit exceeded";
            goto LABEL_73;
          }

LABEL_74:

          goto LABEL_75;
        }

        v44 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v26 = gLogObj;
        v27 = v65;
        v45 = os_log_type_enabled(v26, v65);
        if (!v44)
        {
          if (v45)
          {
            v55 = *a1;
            *buf = 136447234;
            v67 = "nw_nat64_write_prefix_to_string";
            v68 = 1024;
            *v69 = v55;
            *&v69[4] = 1024;
            *&v69[6] = a3;
            *&v69[10] = 2048;
            *&v69[12] = v13;
            v70 = 2082;
            v71 = a2;
            v29 = "%{public}s snprintf failed: prefix->length=%d, dst_length=%u strlen_dst=%zu, dst=%{public}s, no backtrace";
            goto LABEL_73;
          }

          goto LABEL_74;
        }

        if (v45)
        {
          v46 = *a1;
          *buf = 136447490;
          v67 = "nw_nat64_write_prefix_to_string";
          v68 = 1024;
          *v69 = v46;
          *&v69[4] = 1024;
          *&v69[6] = a3;
          *&v69[10] = 2048;
          *&v69[12] = v13;
          v70 = 2082;
          v71 = a2;
          v72 = 2082;
          v73 = v44;
          _os_log_impl(&dword_181A37000, v26, v27, "%{public}s snprintf failed: prefix->length=%d, dst_length=%u strlen_dst=%zu, dst=%{public}s, dumping backtrace:%{public}s", buf, 0x36u);
        }

        free(v44);
      }

LABEL_75:
      if (v25)
      {
        v32 = v25;
        goto LABEL_83;
      }

      return 0;
    }

    v18 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = gLogObj;
    *buf = 136446466;
    v67 = "nw_nat64_write_prefix_to_string";
    v68 = 1024;
    *v69 = v18;
    v38 = _os_log_send_and_compose_impl();

    v65 = OS_LOG_TYPE_ERROR;
    v64 = 0;
    if (!__nwlog_fault(v38, &v65, &v64))
    {
      goto LABEL_81;
    }

    if (v65 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      v21 = v65;
      if (os_log_type_enabled(v20, v65))
      {
        *buf = 136446466;
        v67 = "nw_nat64_write_prefix_to_string";
        v68 = 1024;
        *v69 = v18;
        v22 = "%{public}s inet_ntop failed %{darwin.errno}d";
LABEL_55:
        v47 = v20;
        v48 = v21;
LABEL_56:
        v49 = 18;
LABEL_57:
        _os_log_impl(&dword_181A37000, v47, v48, v22, buf, v49);
      }
    }

    else if (v64 == 1)
    {
      v33 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      v34 = v65;
      v35 = os_log_type_enabled(v20, v65);
      if (v33)
      {
        if (v35)
        {
          *buf = 136446722;
          v67 = "nw_nat64_write_prefix_to_string";
          v68 = 1024;
          *v69 = v18;
          *&v69[4] = 2082;
          *&v69[6] = v33;
          _os_log_impl(&dword_181A37000, v20, v34, "%{public}s inet_ntop failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(v33);
        goto LABEL_81;
      }

      if (v35)
      {
        *buf = 136446466;
        v67 = "nw_nat64_write_prefix_to_string";
        v68 = 1024;
        *v69 = v18;
        v22 = "%{public}s inet_ntop failed %{darwin.errno}d, no backtrace";
        v47 = v20;
        v48 = v34;
        goto LABEL_56;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      v21 = v65;
      if (os_log_type_enabled(v20, v65))
      {
        *buf = 136446466;
        v67 = "nw_nat64_write_prefix_to_string";
        v68 = 1024;
        *v69 = v18;
        v22 = "%{public}s inet_ntop failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_55;
      }
    }

LABEL_58:

    goto LABEL_81;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = gLogObj;
  *buf = 136446722;
  v67 = "nw_nat64_write_prefix_to_string";
  v68 = 1024;
  *v69 = a3;
  *&v69[4] = 1024;
  *&v69[6] = 50;
  v6 = _os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v65 = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v6, type, &v65))
  {
    goto LABEL_21;
  }

  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    v8 = type[0];
    if (!os_log_type_enabled(v7, type[0]))
    {
      goto LABEL_35;
    }

    *buf = 136446722;
    v67 = "nw_nat64_write_prefix_to_string";
    v68 = 1024;
    *v69 = a3;
    *&v69[4] = 1024;
    *&v69[6] = 50;
    v9 = "%{public}s dst_length=%u must be >= %d";
LABEL_33:
    v30 = v7;
    v31 = v8;
LABEL_34:
    _os_log_impl(&dword_181A37000, v30, v31, v9, buf, 0x18u);
    goto LABEL_35;
  }

  if (v65 != OS_LOG_TYPE_INFO)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    v8 = type[0];
    if (!os_log_type_enabled(v7, type[0]))
    {
      goto LABEL_35;
    }

    *buf = 136446722;
    v67 = "nw_nat64_write_prefix_to_string";
    v68 = 1024;
    *v69 = a3;
    *&v69[4] = 1024;
    *&v69[6] = 50;
    v9 = "%{public}s dst_length=%u must be >= %d, backtrace limit exceeded";
    goto LABEL_33;
  }

  v15 = __nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = gLogObj;
  v16 = type[0];
  v17 = os_log_type_enabled(v7, type[0]);
  if (v15)
  {
    if (v17)
    {
      *buf = 136446978;
      v67 = "nw_nat64_write_prefix_to_string";
      v68 = 1024;
      *v69 = a3;
      *&v69[4] = 1024;
      *&v69[6] = 50;
      *&v69[10] = 2082;
      *&v69[12] = v15;
      _os_log_impl(&dword_181A37000, v7, v16, "%{public}s dst_length=%u must be >= %d, dumping backtrace:%{public}s", buf, 0x22u);
    }

    free(v15);
LABEL_21:
    if (!v6)
    {
      return 0;
    }

    goto LABEL_36;
  }

  if (v17)
  {
    *buf = 136446722;
    v67 = "nw_nat64_write_prefix_to_string";
    v68 = 1024;
    *v69 = a3;
    *&v69[4] = 1024;
    *&v69[6] = 50;
    v9 = "%{public}s dst_length=%u must be >= %d, no backtrace";
    v30 = v7;
    v31 = v16;
    goto LABEL_34;
  }

LABEL_35:

  if (v6)
  {
LABEL_36:
    v32 = v6;
LABEL_83:
    free(v32);
  }

  return 0;
}

uint64_t nw_nat64_copy_prefixes_from_ipv4only_records(uint64_t a1, int a2, void *a3)
{
  v76 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v38 = __nwlog_obj();
    *v73 = 136446210;
    *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    v39 = _os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v64) = 0;
    if (!__nwlog_fault(v39, buf, &v64))
    {
      goto LABEL_121;
    }

    if (buf[0] == 17)
    {
      v40 = __nwlog_obj();
      v41 = buf[0];
      if (!os_log_type_enabled(v40, buf[0]))
      {
        goto LABEL_120;
      }

      *v73 = 136446210;
      *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
      v42 = "%{public}s called with null ipv6_addrs";
LABEL_119:
      _os_log_impl(&dword_181A37000, v40, v41, v42, v73, 0xCu);
      goto LABEL_120;
    }

    if (v64 != 1)
    {
      v40 = __nwlog_obj();
      v41 = buf[0];
      if (os_log_type_enabled(v40, buf[0]))
      {
        *v73 = 136446210;
        *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
        v42 = "%{public}s called with null ipv6_addrs, backtrace limit exceeded";
        goto LABEL_119;
      }

      goto LABEL_120;
    }

    backtrace_string = __nw_create_backtrace_string();
    v40 = __nwlog_obj();
    v41 = buf[0];
    v51 = os_log_type_enabled(v40, buf[0]);
    if (!backtrace_string)
    {
      if (v51)
      {
        *v73 = 136446210;
        *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
        v42 = "%{public}s called with null ipv6_addrs, no backtrace";
        goto LABEL_119;
      }

      goto LABEL_120;
    }

    if (!v51)
    {
      goto LABEL_104;
    }

    *v73 = 136446466;
    *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    *&v73[12] = 2082;
    *&v73[14] = backtrace_string;
    v52 = "%{public}s called with null ipv6_addrs, dumping backtrace:%{public}s";
LABEL_103:
    _os_log_impl(&dword_181A37000, v40, v41, v52, v73, 0x16u);
LABEL_104:

    free(backtrace_string);
    goto LABEL_121;
  }

  if (!a2)
  {
    v43 = __nwlog_obj();
    *v73 = 136446210;
    *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    v39 = _os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v64) = 0;
    if (!__nwlog_fault(v39, buf, &v64))
    {
      goto LABEL_121;
    }

    if (buf[0] == 17)
    {
      v40 = __nwlog_obj();
      v41 = buf[0];
      if (!os_log_type_enabled(v40, buf[0]))
      {
        goto LABEL_120;
      }

      *v73 = 136446210;
      *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
      v42 = "%{public}s called with null num_ipv6_addrs";
      goto LABEL_119;
    }

    if (v64 != 1)
    {
      v40 = __nwlog_obj();
      v41 = buf[0];
      if (os_log_type_enabled(v40, buf[0]))
      {
        *v73 = 136446210;
        *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
        v42 = "%{public}s called with null num_ipv6_addrs, backtrace limit exceeded";
        goto LABEL_119;
      }

      goto LABEL_120;
    }

    backtrace_string = __nw_create_backtrace_string();
    v40 = __nwlog_obj();
    v41 = buf[0];
    v53 = os_log_type_enabled(v40, buf[0]);
    if (!backtrace_string)
    {
      if (v53)
      {
        *v73 = 136446210;
        *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
        v42 = "%{public}s called with null num_ipv6_addrs, no backtrace";
        goto LABEL_119;
      }

      goto LABEL_120;
    }

    if (!v53)
    {
      goto LABEL_104;
    }

    *v73 = 136446466;
    *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    *&v73[12] = 2082;
    *&v73[14] = backtrace_string;
    v52 = "%{public}s called with null num_ipv6_addrs, dumping backtrace:%{public}s";
    goto LABEL_103;
  }

  if (!a3)
  {
    v44 = __nwlog_obj();
    *v73 = 136446210;
    *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    v39 = _os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v64) = 0;
    if (__nwlog_fault(v39, buf, &v64))
    {
      if (buf[0] == 17)
      {
        v40 = __nwlog_obj();
        v41 = buf[0];
        if (os_log_type_enabled(v40, buf[0]))
        {
          *v73 = 136446210;
          *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
          v42 = "%{public}s called with null out_prefixes";
          goto LABEL_119;
        }

LABEL_120:

        goto LABEL_121;
      }

      if (v64 != 1)
      {
        v40 = __nwlog_obj();
        v41 = buf[0];
        if (os_log_type_enabled(v40, buf[0]))
        {
          *v73 = 136446210;
          *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
          v42 = "%{public}s called with null out_prefixes, backtrace limit exceeded";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      backtrace_string = __nw_create_backtrace_string();
      v40 = __nwlog_obj();
      v41 = buf[0];
      v54 = os_log_type_enabled(v40, buf[0]);
      if (!backtrace_string)
      {
        if (v54)
        {
          *v73 = 136446210;
          *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
          v42 = "%{public}s called with null out_prefixes, no backtrace";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      if (!v54)
      {
        goto LABEL_104;
      }

      *v73 = 136446466;
      *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
      *&v73[12] = 2082;
      *&v73[14] = backtrace_string;
      v52 = "%{public}s called with null out_prefixes, dumping backtrace:%{public}s";
      goto LABEL_103;
    }

LABEL_121:
    if (v39)
    {
      free(v39);
    }

    return 0xFFFFFFFFLL;
  }

  v4 = (2 * a2);
  if (!v4)
  {
    v45 = a3;
    v46 = __nwlog_obj();
    os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
    *v73 = 136446210;
    *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    v47 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v47);
    if (result)
    {
      goto LABEL_124;
    }

    free(v47);
    a3 = v45;
  }

  v57 = a3;
  v5 = malloc_type_calloc((2 * a2), 0x10uLL, 0x77653232uLL);
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    *v73 = 136446722;
    *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    *&v73[12] = 2048;
    *&v73[14] = v4;
    v74 = 2048;
    v75 = 16;
    v7 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v7);
    if (result)
    {
      goto LABEL_124;
    }

    free(v7);
  }

  if (!v4)
  {
    v48 = __nwlog_obj();
    os_log_type_enabled(v48, OS_LOG_TYPE_ERROR);
    *v73 = 136446210;
    *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    v49 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v49);
    if (result)
    {
      goto LABEL_124;
    }

    free(v49);
  }

  v9 = malloc_type_calloc((2 * a2), 0x10uLL, 0x39C56317uLL);
  if (!v9)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    *v73 = 136446722;
    *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    *&v73[12] = 2048;
    *&v73[14] = v4;
    v74 = 2048;
    v75 = 16;
    v11 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v11);
    if (!result)
    {
      free(v11);
      goto LABEL_12;
    }

LABEL_124:
    __break(1u);
    return result;
  }

LABEL_12:
  v61 = v5;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  __s2 = v4;
  do
  {
    v15 = (a1 + 16 * v12);
    if (!v15[8])
    {
      v19 = 0;
      while (1)
      {
        *v73 = nw_nat64_copy_prefixes_from_ipv4only_records::prefix_lengths[v19];
        *&v73[4] = 0;
        *&v73[12] = 0;
        memcpy(&v73[4], v15, *v73);
        v64 = 0;
        if (nw_nat64_extract_v4(v73, v15, &v64))
        {
          if (v64 == -1426063168)
          {
            if (v14 >= v4)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v4 = gLogObj;
              if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
              {
                *buf = 136446210;
                v66 = "nw_nat64_copy_prefixes_from_ipv4only_records";
                v20 = v4;
                v21 = "%{public}s too many valid prefixes for WKA2";
LABEL_33:
                _os_log_impl(&dword_181A37000, v20, OS_LOG_TYPE_ERROR, v21, buf, 0xCu);
              }

LABEL_34:

              LODWORD(v4) = __s2;
              goto LABEL_22;
            }

            *&v9[16 * v14++] = *v73;
          }

          else if (v64 == -1442840384)
          {
            if (v13 >= v4)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v4 = gLogObj;
              if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
              {
                *buf = 136446210;
                v66 = "nw_nat64_copy_prefixes_from_ipv4only_records";
                v20 = v4;
                v21 = "%{public}s too many valid prefixes for WKA1";
                goto LABEL_33;
              }

              goto LABEL_34;
            }

            v61[v13++] = *v73;
          }
        }

LABEL_22:
        if (++v19 == 6)
        {
          goto LABEL_14;
        }
      }
    }

    v16 = inet_ntop(30, (a1 + 16 * v12), v73, 0x2Eu);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v17 = v15[8];
      v18 = "?";
      if (v16)
      {
        v18 = v73;
      }

      *buf = 136446979;
      v66 = "nw_nat64_copy_prefixes_from_ipv4only_records";
      v67 = 1024;
      v68 = v12;
      v69 = 2085;
      v70 = v18;
      v71 = 1024;
      v72 = v17;
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_ERROR, "%{public}s v6res[%u] %{sensitive}s has non zero bits 64-71: 0x%x", buf, 0x22u);
    }

    LODWORD(v4) = __s2;
LABEL_14:
    ++v12;
  }

  while (v12 != a2);
  if (!(v13 | v14))
  {
    if (v61)
    {
      free(v61);
    }

    if (v9)
    {
      v22 = v9;
      goto LABEL_72;
    }

    return 0;
  }

  if (v13 <= v14)
  {
    v23 = v14;
  }

  else
  {
    v23 = v13;
  }

  if (!v23)
  {
    v55 = __nwlog_obj();
    os_log_type_enabled(v55, OS_LOG_TYPE_ERROR);
    *v73 = 136446210;
    *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    v56 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v56);
    if (!result)
    {
      free(v56);
      goto LABEL_44;
    }

    goto LABEL_124;
  }

LABEL_44:
  v24 = malloc_type_calloc(v23, 0x10uLL, 0x2D284285uLL);
  if (v24)
  {
    goto LABEL_47;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v25 = gLogObj;
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  *v73 = 136446722;
  *&v73[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
  *&v73[12] = 2048;
  *&v73[14] = v23;
  v74 = 2048;
  v75 = 16;
  v26 = _os_log_send_and_compose_impl();

  result = __nwlog_should_abort(v26);
  if (result)
  {
    goto LABEL_124;
  }

  free(v26);
LABEL_47:
  v27 = 0;
  if (v13 && v14)
  {
    v28 = 0;
    v27 = 0;
    __s2a = v24 + 4;
    v58 = v13;
    do
    {
      v29 = 0;
      v60 = v28;
      v30 = &v61[v28];
      do
      {
        v31 = &v9[16 * v29];
        v32 = *v30;
        if (v32 == *v31 && !memcmp(v30 + 4, v31 + 4, *v30))
        {
          if (v27)
          {
            v33 = v9;
            v34 = v24;
            v35 = v27;
            v36 = __s2a;
            v37 = v27;
            while (v32 != *(v36 - 1) || memcmp(v30 + 4, v36, v32))
            {
              v36 += 4;
              if (!--v37)
              {
                v24 = v34;
                v9 = v33;
                goto LABEL_53;
              }
            }

            v24 = v34;
            v9 = v33;
          }

          else
          {
            v35 = 0;
LABEL_53:
            *&v24[16 * v35] = *v30;
            v27 = (v27 + 1);
          }
        }

        ++v29;
      }

      while (v29 != v14);
      v28 = v60 + 1;
    }

    while (v60 + 1 != v58);
  }

  if (v61)
  {
    free(v61);
  }

  if (v9)
  {
    free(v9);
  }

  if (v27)
  {
    *v57 = v24;
  }

  else
  {
    if (v24)
    {
      v22 = v24;
LABEL_72:
      free(v22);
    }

    return 0;
  }

  return v27;
}

uint64_t nw_nat64_copy_prefixes(int *a1, void *a2)
{
  v22 = *MEMORY[0x1E69E9840];
  pthread_once(&nw_settings_setup_atfork::pOnce, nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec == 1 && (sNWParentAllowedDispatch & 1) != 0)
  {
    return 0;
  }

  if (sNWDispatchAllowedNow)
  {
    goto LABEL_9;
  }

  if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0 || (getpid(), sandbox_check() == 1))
  {
    sNWDispatchAllowedNow = 1;
    goto LABEL_9;
  }

  if (sNWDispatchAllowedNow != 1)
  {
    return 0;
  }

LABEL_9:
  if (a2)
  {
    if (gLogDatapath == 1)
    {
      v12 = __nwlog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        if (a1)
        {
          v13 = *a1;
        }

        else
        {
          v13 = 0;
        }

        *buf = 136446466;
        v19 = "nw_nat64_copy_prefixes";
        v20 = 1024;
        LODWORD(v21) = v13;
        _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_DEBUG, "%{public}s Start nw_nat64_copy_prefixes(%u)", buf, 0x12u);
      }
    }

    *a2 = 0;
    result = nw_nat64_copy_prefixes_internal(a1, a2, 0, 0, 0, 0);
    if (gLogDatapath == 1)
    {
      v5 = result;
      v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446466;
        v19 = "nw_nat64_copy_prefixes";
        v20 = 1024;
        LODWORD(v21) = v5;
        _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_DEBUG, "%{public}s nw_nat64_copy_prefixes returning %d", buf, 0x12u);
      }

      return v5;
    }

    return result;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  v19 = "nw_nat64_copy_prefixes";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v19 = "nw_nat64_copy_prefixes";
        v11 = "%{public}s called with null out_prefixes";
LABEL_36:
        _os_log_impl(&dword_181A37000, v9, v10, v11, buf, 0xCu);
      }
    }

    else
    {
      if (v16 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v9 = __nwlog_obj();
        v10 = type;
        v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *buf = 136446466;
            v19 = "nw_nat64_copy_prefixes";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null out_prefixes, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_38;
        }

        if (!v15)
        {
          goto LABEL_37;
        }

        *buf = 136446210;
        v19 = "nw_nat64_copy_prefixes";
        v11 = "%{public}s called with null out_prefixes, no backtrace";
        goto LABEL_36;
      }

      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v19 = "nw_nat64_copy_prefixes";
        v11 = "%{public}s called with null out_prefixes, backtrace limit exceeded";
        goto LABEL_36;
      }
    }

LABEL_37:
  }

LABEL_38:
  if (v8)
  {
    free(v8);
  }

  return 0xFFFFFFFFLL;
}

uint64_t nw_nat64_copy_prefixes_internal(int *a1, void *a2, void *a3, DNSServiceRef *a4, _DWORD *a5, void *a6)
{
  v106 = *MEMORY[0x1E69E9840];
  v11 = a3;
  v12 = a6;
  v96 = 0;
  if (a1)
  {
    v96 = *a1;
  }

  v95 = 0;
  interface_state_internal = nw_nat64_get_interface_state_internal(&v96, &v95);
  if (a1)
  {
    *a1 = v96;
  }

  if (interface_state_internal > 2)
  {
    if (interface_state_internal == 3)
    {
      v22 = 0;
    }

    else
    {
      v22 = 0xFFFFFFFFLL;
    }

    goto LABEL_95;
  }

  if (interface_state_internal != 1)
  {
    v30 = v96;
    v31 = v11;
    v32 = v12;
    v33 = v32;
    v90 = v31;
    if (a2)
    {
      v34 = malloc_type_calloc(0x10uLL, 1uLL, 0x50C2A850uLL);
      if (!v34)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = gLogObj;
        os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
        *buf = 136446722;
        *&buf[4] = "nw_nat64_copy_ipv4only_records";
        *&buf[12] = 2048;
        *&buf[14] = 16;
        *&buf[22] = 2048;
        *&buf[24] = 1;
        v36 = _os_log_send_and_compose_impl();

        result = __nwlog_should_abort(v36);
        if (result)
        {
          goto LABEL_121;
        }

        free(v36);
      }

      *sdRef = 0;
      AddrInfo = DNSServiceGetAddrInfo(sdRef, 0x40019000u, v30, 2u, "ipv4only.arpa", nw_nat64_getaddrinfo_callback_sync, v34);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v38 = gLogObj;
      v39 = v38;
      if (AddrInfo)
      {
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          string_for_dns_service_error = nwlog_get_string_for_dns_service_error(AddrInfo);
          *buf = 136447234;
          *&buf[4] = "nw_nat64_copy_ipv4only_records";
          *&buf[12] = 1024;
          *&buf[14] = v30;
          *&buf[18] = 2082;
          *&buf[20] = "ipv4only.arpa";
          *&buf[28] = 2082;
          *&buf[30] = string_for_dns_service_error;
          *&buf[38] = 1024;
          *&buf[40] = AddrInfo;
          v41 = "%{public}s starting DNS query on ifindex %u for %{public}s failed with error=%{public}s(%d)";
LABEL_65:
          _os_log_impl(&dword_181A37000, v39, OS_LOG_TYPE_ERROR, v41, buf, 0x2Cu);
        }

LABEL_66:
      }

      else
      {
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
        {
          *buf = 136446722;
          *&buf[4] = "nw_nat64_copy_ipv4only_records";
          *&buf[12] = 1024;
          *&buf[14] = v30;
          *&buf[18] = 2082;
          *&buf[20] = "ipv4only.arpa";
          _os_log_impl(&dword_181A37000, v39, OS_LOG_TYPE_DEBUG, "%{public}s started DNS query on ifindex %u for %{public}s successfully", buf, 0x1Cu);
        }

        while ((*(v34 + 12) & 1) == 0)
        {
          if (DNSServiceProcessResult(*sdRef))
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v39 = gLogObj;
            if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
            {
              goto LABEL_66;
            }

            v58 = DNSServiceErrorCodeToString();
            *buf = 136447234;
            *&buf[4] = "nw_nat64_copy_ipv4only_records";
            v59 = "NoError";
            if (v58)
            {
              v59 = v58;
            }

            *&buf[12] = 1024;
            *&buf[14] = v30;
            *&buf[18] = 2082;
            *&buf[20] = "ipv4only.arpa";
            *&buf[28] = 2082;
            *&buf[30] = v59;
            *&buf[38] = 1024;
            *&buf[40] = 0;
            v41 = "%{public}s DNSServiceProcessResult on ifindex %u for %{public}s failed with error=%{public}s(%d)";
            goto LABEL_65;
          }
        }
      }

      v22 = *(v34 + 2);
      v60 = *v34;
      free(v34);
      if (*sdRef)
      {
        DNSServiceRefDeallocate(*sdRef);
      }

      if (v22 >= 1)
      {
        v22 = nw_nat64_copy_prefixes_from_ipv4only_records(v60, v22, a2);
        if (v60)
        {
          free(v60);
        }
      }

      goto LABEL_89;
    }

    *sdRef = MEMORY[0x1E69E9820];
    *&sdRef[8] = 3221225472;
    *&sdRef[16] = ___ZL43nw_nat64_copy_prefixes_by_querying_ipv4onlyjPP17nw_nat64_prefix_tPU28objcproto17OS_dispatch_queue8NSObjectPP16_DNSServiceRef_tPKjU13block_pointerFviS0_E_block_invoke;
    v101 = &unk_1E6A35BB8;
    v102 = v32;
    queue = v31;
    v46 = sdRef;
    v47 = malloc_type_calloc(0x18uLL, 1uLL, 0x7B7BDFEFuLL);
    if (!v47)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v48 = gLogObj;
      os_log_type_enabled(v48, OS_LOG_TYPE_ERROR);
      *buf = 136446722;
      *&buf[4] = "nw_nat64_query_ipv4only_records_async";
      *&buf[12] = 2048;
      *&buf[14] = 24;
      *&buf[22] = 2048;
      *&buf[24] = 1;
      v49 = _os_log_send_and_compose_impl();

      result = __nwlog_should_abort(v49);
      if (result)
      {
        goto LABEL_121;
      }

      free(v49);
    }

    v50 = _Block_copy(v46);
    v51 = v47[1];
    v47[1] = v50;

    v52 = 1073844224;
    service = 0;
    if (a4)
    {
      p_service = a4;
    }

    else
    {
      p_service = &service;
    }

    if (a5)
    {
      v52 = *a5 | 0x40019000;
    }

    v54 = DNSServiceGetAddrInfo(p_service, v52, v30, 2u, "ipv4only.arpa", nw_nat64_getaddrinfo_callback_async, v47);
    if (v54)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v55 = gLogObj;
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
      {
        v56 = nwlog_get_string_for_dns_service_error(v54);
        *buf = 136447490;
        *&buf[4] = "nw_nat64_query_ipv4only_records_async";
        *&buf[12] = 1024;
        *&buf[14] = v52;
        *&buf[18] = 1024;
        *&buf[20] = v30;
        *&buf[24] = 2082;
        *&buf[26] = "ipv4only.arpa";
        *&buf[34] = 2082;
        *&buf[36] = v56;
        *v104 = 1024;
        *&v104[2] = v54;
        _os_log_impl(&dword_181A37000, v55, OS_LOG_TYPE_ERROR, "%{public}s starting DNS query with flags %#x on ifindex %u for %{public}s failed with error=%{public}s(%d)", buf, 0x32u);
      }

LABEL_51:
      if (service)
      {
        DNSServiceRefDeallocate(service);
      }

      v57 = v47[1];
      v47[1] = 0;

      if (*v47)
      {
        free(*v47);
      }

      free(v47);
      v22 = 0xFFFFFFFFLL;
      goto LABEL_88;
    }

    if (a4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v64 = gLogObj;
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446722;
        *&buf[4] = "nw_nat64_query_ipv4only_records_async";
        *&buf[12] = 1024;
        *&buf[14] = v30;
        *&buf[18] = 2082;
        *&buf[20] = "ipv4only.arpa";
        _os_log_impl(&dword_181A37000, v64, OS_LOG_TYPE_DEBUG, "%{public}s started DNS query with custom sdRef on ifindex %u for %{public}s successfully", buf, 0x1Cu);
      }

LABEL_87:
      v22 = 0x80000000;
LABEL_88:

LABEL_89:
      goto LABEL_95;
    }

    v66 = DNSServiceSetDispatchQueue(service, queue);
    v67 = __nwlog_obj();
    v68 = v67;
    if (!v66)
    {
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446722;
        *&buf[4] = "nw_nat64_query_ipv4only_records_async";
        *&buf[12] = 1024;
        *&buf[14] = v30;
        *&buf[18] = 2082;
        *&buf[20] = "ipv4only.arpa";
        _os_log_impl(&dword_181A37000, v68, OS_LOG_TYPE_DEBUG, "%{public}s started DNS query on ifindex %u for %{public}s successfully", buf, 0x1Cu);
      }

      goto LABEL_87;
    }

    v69 = service;
    v70 = nwlog_get_string_for_dns_service_error(v66);
    *buf = 136447234;
    *&buf[4] = "nw_nat64_query_ipv4only_records_async";
    *&buf[12] = 2048;
    *&buf[14] = v69;
    *&buf[22] = 2048;
    *&buf[24] = queue;
    *&buf[32] = 2082;
    *&buf[34] = v70;
    *&buf[42] = 1024;
    *v104 = v66;
    v71 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v97 = 0;
    if (__nwlog_fault(v71, &type, &v97))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v72 = v66;
        v73 = __nwlog_obj();
        v74 = type;
        if (os_log_type_enabled(v73, type))
        {
          v75 = service;
          v76 = nwlog_get_string_for_dns_service_error(v72);
          *buf = 136447234;
          *&buf[4] = "nw_nat64_query_ipv4only_records_async";
          *&buf[12] = 2048;
          *&buf[14] = v75;
          *&buf[22] = 2048;
          *&buf[24] = queue;
          *&buf[32] = 2082;
          *&buf[34] = v76;
          *&buf[42] = 1024;
          *v104 = v72;
          _os_log_impl(&dword_181A37000, v73, v74, "%{public}s DNSServiceSetDispatchQueue(%p,%p) error=%{public}s(%d) failed", buf, 0x30u);
        }
      }

      else
      {
        if (v97 == 1)
        {
          backtrace_string = __nw_create_backtrace_string();
          v78 = __nwlog_obj();
          v79 = type;
          v80 = os_log_type_enabled(v78, type);
          if (backtrace_string)
          {
            if (v80)
            {
              v88 = service;
              v81 = nwlog_get_string_for_dns_service_error(v66);
              *buf = 136447490;
              *&buf[4] = "nw_nat64_query_ipv4only_records_async";
              *&buf[12] = 2048;
              *&buf[14] = v88;
              *&buf[22] = 2048;
              *&buf[24] = queue;
              *&buf[32] = 2082;
              *&buf[34] = v81;
              *&buf[42] = 1024;
              *v104 = v66;
              *&v104[4] = 2082;
              v105 = backtrace_string;
              _os_log_impl(&dword_181A37000, v78, v79, "%{public}s DNSServiceSetDispatchQueue(%p,%p) error=%{public}s(%d) failed, dumping backtrace:%{public}s", buf, 0x3Au);
            }

            free(backtrace_string);
          }

          else
          {
            if (v80)
            {
              v86 = service;
              v87 = nwlog_get_string_for_dns_service_error(v66);
              *buf = 136447234;
              *&buf[4] = "nw_nat64_query_ipv4only_records_async";
              *&buf[12] = 2048;
              *&buf[14] = v86;
              *&buf[22] = 2048;
              *&buf[24] = queue;
              *&buf[32] = 2082;
              *&buf[34] = v87;
              *&buf[42] = 1024;
              *v104 = v66;
              _os_log_impl(&dword_181A37000, v78, v79, "%{public}s DNSServiceSetDispatchQueue(%p,%p) error=%{public}s(%d) failed, no backtrace", buf, 0x30u);
            }
          }

          goto LABEL_119;
        }

        v82 = v66;
        v73 = __nwlog_obj();
        v83 = type;
        if (os_log_type_enabled(v73, type))
        {
          v84 = service;
          v85 = nwlog_get_string_for_dns_service_error(v82);
          *buf = 136447234;
          *&buf[4] = "nw_nat64_query_ipv4only_records_async";
          *&buf[12] = 2048;
          *&buf[14] = v84;
          *&buf[22] = 2048;
          *&buf[24] = queue;
          *&buf[32] = 2082;
          *&buf[34] = v85;
          *&buf[42] = 1024;
          *v104 = v82;
          _os_log_impl(&dword_181A37000, v73, v83, "%{public}s DNSServiceSetDispatchQueue(%p,%p) error=%{public}s(%d) failed, backtrace limit exceeded", buf, 0x30u);
        }
      }
    }

LABEL_119:
    if (v71)
    {
      free(v71);
    }

    goto LABEL_51;
  }

  if (!v95)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v42 = gLogObj;
    *buf = 136446210;
    *&buf[4] = "nw_nat64_copy_prefixes_internal";
    v43 = _os_log_send_and_compose_impl();

    sdRef[0] = 16;
    LOBYTE(service) = 0;
    if (__nwlog_fault(v43, sdRef, &service))
    {
      if (sdRef[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v44 = gLogObj;
        v45 = sdRef[0];
        if (os_log_type_enabled(v44, sdRef[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_nat64_copy_prefixes_internal";
          _os_log_impl(&dword_181A37000, v44, v45, "%{public}s Received invalid path", buf, 0xCu);
        }
      }

      else if (service == 1)
      {
        v61 = __nw_create_backtrace_string();
        v44 = __nwlog_obj();
        v62 = sdRef[0];
        v63 = os_log_type_enabled(v44, sdRef[0]);
        if (v61)
        {
          if (v63)
          {
            *buf = 136446466;
            *&buf[4] = "nw_nat64_copy_prefixes_internal";
            *&buf[12] = 2082;
            *&buf[14] = v61;
            _os_log_impl(&dword_181A37000, v44, v62, "%{public}s Received invalid path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v61);
          if (!v43)
          {
            goto LABEL_38;
          }

          goto LABEL_37;
        }

        if (v63)
        {
          *buf = 136446210;
          *&buf[4] = "nw_nat64_copy_prefixes_internal";
          _os_log_impl(&dword_181A37000, v44, v62, "%{public}s Received invalid path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v44 = gLogObj;
        v65 = sdRef[0];
        if (os_log_type_enabled(v44, sdRef[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_nat64_copy_prefixes_internal";
          _os_log_impl(&dword_181A37000, v44, v65, "%{public}s Received invalid path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v43)
    {
LABEL_38:
      v22 = 0xFFFFFFFFLL;
LABEL_95:

      return v22;
    }

LABEL_37:
    free(v43);
    goto LABEL_38;
  }

  v14 = v95;
  v15 = _nw_path_nat64_prefixes();

  *buf = 0;
  *&buf[8] = buf;
  *&buf[16] = 0x2020000000;
  *&buf[24] = 0;
  v16 = malloc_type_calloc(4uLL, 0x10uLL, 0x863F2E6AuLL);
  if (v16)
  {
    goto LABEL_11;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v17 = gLogObj;
  os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  *sdRef = 136446722;
  *&sdRef[4] = "nw_nat64_copy_prefixes_internal";
  *&sdRef[12] = 2048;
  *&sdRef[14] = 4;
  *&sdRef[22] = 2048;
  v101 = 16;
  v18 = _os_log_send_and_compose_impl();

  result = __nwlog_should_abort(v18);
  if (!result)
  {
    free(v18);
    v16 = 0;
LABEL_11:
    v20 = *&buf[8];
    *(*&buf[8] + 24) = v16;
    v21 = v15[4];
    if (v21)
    {
      *v16 = v21;
      memcpy(v16 + 1, v15, v21);
      v22 = 1;
      v23 = v15[9];
      if (!v23)
      {
LABEL_14:
        v25 = v15[14];
        if (v25)
        {
          v26 = 16 * v22;
          *(*(*&buf[8] + 24) + v26) = v25;
          memcpy((*(*&buf[8] + 24) + v26 + 4), v15, v25);
          v22 = (v22 + 1);
        }

        v27 = v15[19];
        if (v27)
        {
          v28 = 16 * v22;
          *(*(*&buf[8] + 24) + v28) = v27;
          memcpy((*(*&buf[8] + 24) + v28 + 4), v15, v27);
          v22 = (v22 + 1);
        }

        if (a2)
        {
          v29 = *(*&buf[8] + 24);
          if (v22)
          {
            *a2 = v29;
          }

          else if (v29)
          {
            free(v29);
            v22 = 0;
            *(*&buf[8] + 24) = 0;
          }

          else
          {
            v22 = 0;
          }
        }

        else
        {
          block[0] = MEMORY[0x1E69E9820];
          block[1] = 3221225472;
          block[2] = ___ZL31nw_nat64_copy_prefixes_internalPjPP17nw_nat64_prefix_tPU28objcproto17OS_dispatch_queue8NSObjectPP16_DNSServiceRef_tPKjU13block_pointerFviS1_E_block_invoke;
          block[3] = &unk_1E6A35B90;
          v94 = v22;
          v92 = v12;
          v93 = buf;
          dispatch_async(v11, block);

          v22 = 0x80000000;
        }

        _Block_object_dispose(buf, 8);
        goto LABEL_95;
      }
    }

    else
    {
      v22 = 0;
      v23 = v15[9];
      if (!v23)
      {
        goto LABEL_14;
      }
    }

    v24 = 16 * v22;
    *(*(v20 + 24) + v24) = v23;
    memcpy((*(*&buf[8] + 24) + v24 + 4), v15, v23);
    v22 = (v22 + 1);
    goto LABEL_14;
  }

LABEL_121:
  __break(1u);
  return result;
}

uint64_t nw_nat64_get_interface_state_internal(int *a1, id *a2)
{
  *&v61[13] = *MEMORY[0x1E69E9840];
  v4 = *a1;
  if (a2)
  {
    v5 = *a2;
    *a2 = 0;
  }

  if (!v4)
  {
    evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0, 0);
    if (evaluator_for_endpoint)
    {
      goto LABEL_17;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    *buf = 136446210;
    v59 = "nw_nat64_get_interface_state_internal";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (__nwlog_fault(v9, &type, &v56))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v59 = "nw_nat64_get_interface_state_internal";
          _os_log_impl(&dword_181A37000, v10, v11, "%{public}s nw_path_create_default_evaluator failed", buf, 0xCu);
        }
      }

      else if (v56 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v10 = __nwlog_obj();
        v35 = type;
        v36 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v36)
          {
            *buf = 136446466;
            v59 = "nw_nat64_get_interface_state_internal";
            v60 = 2082;
            *v61 = backtrace_string;
            _os_log_impl(&dword_181A37000, v10, v35, "%{public}s nw_path_create_default_evaluator failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v9)
          {
            return 4;
          }

          goto LABEL_90;
        }

        if (v36)
        {
          *buf = 136446210;
          v59 = "nw_nat64_get_interface_state_internal";
          _os_log_impl(&dword_181A37000, v10, v35, "%{public}s nw_path_create_default_evaluator failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        v47 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v59 = "nw_nat64_get_interface_state_internal";
          _os_log_impl(&dword_181A37000, v10, v47, "%{public}s nw_path_create_default_evaluator failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v9)
    {
      return 4;
    }

LABEL_90:
    free(v9);
    return 4;
  }

  if (v4 != -1)
  {
    v12 = nw_interface_create_with_index(v4);
    if (!v12)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = gLogObj;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446466;
        v59 = "nw_nat64_get_interface_state_internal";
        v60 = 1024;
        *v61 = v4;
        _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_ERROR, "%{public}s nw_interface_create_with_index failed for index %u", buf, 0x12u);
      }

      return 4;
    }

    v13 = v12;
    v14 = _nw_parameters_create();
    v15 = v14;
    if (v14)
    {
      nw_parameters_require_interface(v14, v13);
      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0, v15);
      if (evaluator_for_endpoint)
      {

LABEL_17:
        v16 = evaluator_for_endpoint;
        os_unfair_lock_lock(evaluator_for_endpoint + 24);
        v17 = *(v16 + 6);
        v18 = v17;
        os_unfair_lock_unlock(evaluator_for_endpoint + 24);

        if (v18)
        {
          v19 = v18;
          if (_nw_path_network_is_satisfied(v19))
          {
            routed_interface_index = _nw_path_get_routed_interface_index(v19);
          }

          else
          {
            routed_interface_index = 0;
          }

          is_eligible_for_CrazyIvan46 = nw_path_is_eligible_for_CrazyIvan46(v19);
          if (gLogDatapath == 1)
          {
            v27 = _nw_path_copy_description(v19);
            *a1 = routed_interface_index;
            if (routed_interface_index)
            {
LABEL_31:
              if (is_eligible_for_CrazyIvan46)
              {
                v28 = v19;
                v29 = _nw_path_has_nat64_prefixes(v28);

                if (v29)
                {
                  v6 = 1;
                }

                else
                {
                  v6 = 2;
                }

                if (!a2)
                {
LABEL_114:
                  if (v27)
                  {
                    free(v27);
                  }

                  goto LABEL_116;
                }

LABEL_113:
                objc_storeStrong(a2, v17);
                goto LABEL_114;
              }

              if (gLogDatapath == 1)
              {
                v37 = __nwlog_obj();
                if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
                {
                  *buf = 136446466;
                  v59 = "nw_nat64_get_interface_state_internal";
                  v60 = 2082;
                  *v61 = v27;
                  _os_log_impl(&dword_181A37000, v37, OS_LOG_TYPE_DEBUG, "%{public}s bailing because path not eligible: %{public}s", buf, 0x16u);
                }

LABEL_51:

                goto LABEL_112;
              }

              goto LABEL_112;
            }
          }

          else
          {
            v27 = 0;
            *a1 = routed_interface_index;
            if (routed_interface_index)
            {
              goto LABEL_31;
            }
          }

          if (gLogDatapath == 1)
          {
            v37 = __nwlog_obj();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
            {
              *buf = 136446466;
              v59 = "nw_nat64_get_interface_state_internal";
              v60 = 2082;
              *v61 = v27;
              _os_log_impl(&dword_181A37000, v37, OS_LOG_TYPE_DEBUG, "%{public}s bailing because path not satisfied: %{public}s", buf, 0x16u);
            }

            goto LABEL_51;
          }

LABEL_112:
          v6 = 3;
          if (!a2)
          {
            goto LABEL_114;
          }

          goto LABEL_113;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        *buf = 136446210;
        v59 = "nw_nat64_get_interface_state_internal";
        v23 = _os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v56 = 0;
        if (__nwlog_fault(v23, &type, &v56))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = gLogObj;
            v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              *buf = 136446210;
              v59 = "nw_nat64_get_interface_state_internal";
              _os_log_impl(&dword_181A37000, v24, v25, "%{public}s nw_path_evaluator_copy_path failed", buf, 0xCu);
            }
          }

          else if (v56 == 1)
          {
            v38 = __nw_create_backtrace_string();
            v24 = __nwlog_obj();
            v39 = type;
            v40 = os_log_type_enabled(v24, type);
            if (v38)
            {
              if (v40)
              {
                *buf = 136446466;
                v59 = "nw_nat64_get_interface_state_internal";
                v60 = 2082;
                *v61 = v38;
                _os_log_impl(&dword_181A37000, v24, v39, "%{public}s nw_path_evaluator_copy_path failed, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v38);
              if (!v23)
              {
                goto LABEL_96;
              }

              goto LABEL_95;
            }

            if (v40)
            {
              *buf = 136446210;
              v59 = "nw_nat64_get_interface_state_internal";
              _os_log_impl(&dword_181A37000, v24, v39, "%{public}s nw_path_evaluator_copy_path failed, no backtrace", buf, 0xCu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = gLogObj;
            v48 = type;
            if (os_log_type_enabled(v24, type))
            {
              *buf = 136446210;
              v59 = "nw_nat64_get_interface_state_internal";
              _os_log_impl(&dword_181A37000, v24, v48, "%{public}s nw_path_evaluator_copy_path failed, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }

        if (!v23)
        {
LABEL_96:
          v6 = 4;
LABEL_116:

          return v6;
        }

LABEL_95:
        free(v23);
        goto LABEL_96;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v41 = gLogObj;
      *buf = 136446466;
      v59 = "nw_nat64_get_interface_state_internal";
      v60 = 1024;
      *v61 = v4;
      v31 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v56 = 0;
      if (__nwlog_fault(v31, &type, &v56))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v42 = gLogObj;
          v43 = type;
          if (os_log_type_enabled(v42, type))
          {
            *buf = 136446466;
            v59 = "nw_nat64_get_interface_state_internal";
            v60 = 1024;
            *v61 = v4;
            _os_log_impl(&dword_181A37000, v42, v43, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed", buf, 0x12u);
          }

LABEL_102:

          goto LABEL_103;
        }

        if (v56 != 1)
        {
          v42 = __nwlog_obj();
          v53 = type;
          if (os_log_type_enabled(v42, type))
          {
            *buf = 136446466;
            v59 = "nw_nat64_get_interface_state_internal";
            v60 = 1024;
            *v61 = v4;
            _os_log_impl(&dword_181A37000, v42, v53, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, backtrace limit exceeded", buf, 0x12u);
          }

          goto LABEL_102;
        }

        v49 = __nw_create_backtrace_string();
        v42 = __nwlog_obj();
        v50 = type;
        v51 = os_log_type_enabled(v42, type);
        if (!v49)
        {
          if (v51)
          {
            *buf = 136446466;
            v59 = "nw_nat64_get_interface_state_internal";
            v60 = 1024;
            *v61 = v4;
            _os_log_impl(&dword_181A37000, v42, v50, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, no backtrace", buf, 0x12u);
          }

          goto LABEL_102;
        }

        if (v51)
        {
          *buf = 136446722;
          v59 = "nw_nat64_get_interface_state_internal";
          v60 = 1024;
          *v61 = v4;
          v61[2] = 2082;
          *&v61[3] = v49;
          _os_log_impl(&dword_181A37000, v42, v50, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(v49);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = gLogObj;
      *buf = 136446210;
      v59 = "nw_nat64_get_interface_state_internal";
      v31 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v56 = 0;
      if (__nwlog_fault(v31, &type, &v56))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v32 = gLogObj;
          v33 = type;
          if (os_log_type_enabled(v32, type))
          {
            *buf = 136446210;
            v59 = "nw_nat64_get_interface_state_internal";
            _os_log_impl(&dword_181A37000, v32, v33, "%{public}s nw_parameters_create failed", buf, 0xCu);
          }
        }

        else if (v56 == 1)
        {
          v44 = __nw_create_backtrace_string();
          v32 = __nwlog_obj();
          v45 = type;
          v46 = os_log_type_enabled(v32, type);
          if (v44)
          {
            if (v46)
            {
              *buf = 136446466;
              v59 = "nw_nat64_get_interface_state_internal";
              v60 = 2082;
              *v61 = v44;
              _os_log_impl(&dword_181A37000, v32, v45, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v44);
            if (!v31)
            {
              goto LABEL_105;
            }

            goto LABEL_104;
          }

          if (v46)
          {
            *buf = 136446210;
            v59 = "nw_nat64_get_interface_state_internal";
            _os_log_impl(&dword_181A37000, v32, v45, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          v32 = __nwlog_obj();
          v52 = type;
          if (os_log_type_enabled(v32, type))
          {
            *buf = 136446210;
            v59 = "nw_nat64_get_interface_state_internal";
            _os_log_impl(&dword_181A37000, v32, v52, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
    }

LABEL_103:
    if (!v31)
    {
LABEL_105:

      return 4;
    }

LABEL_104:
    free(v31);
    goto LABEL_105;
  }

  if (gLogDatapath == 1)
  {
    v54 = __nwlog_obj();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
    {
      *buf = 136446210;
      v59 = "nw_nat64_get_interface_state_internal";
      _os_log_impl(&dword_181A37000, v54, OS_LOG_TYPE_DEBUG, "%{public}s bailing because local only", buf, 0xCu);
    }
  }

  return 3;
}

void ___ZL31nw_nat64_copy_prefixes_internalPjPP17nw_nat64_prefix_tPU28objcproto17OS_dispatch_queue8NSObjectPP16_DNSServiceRef_tPKjU13block_pointerFviS1_E_block_invoke(uint64_t a1)
{
  (*(*(a1 + 32) + 16))();
  v2 = *(*(*(a1 + 40) + 8) + 24);
  if (v2)
  {
    free(v2);
    *(*(*(a1 + 40) + 8) + 24) = 0;
  }
}

void ___ZL43nw_nat64_copy_prefixes_by_querying_ipv4onlyjPP17nw_nat64_prefix_tPU28objcproto17OS_dispatch_queue8NSObjectPP16_DNSServiceRef_tPKjU13block_pointerFviS0_E_block_invoke(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 <= 0)
  {
    v4 = *(*(a1 + 32) + 16);

    v4();
  }

  else
  {
    v5 = 0;
    nw_nat64_copy_prefixes_from_ipv4only_records(a3, a2, &v5);
    (*(*(a1 + 32) + 16))();
    if (v5)
    {
      free(v5);
    }
  }
}

void nw_nat64_getaddrinfo_callback_async(_DNSServiceRef_t *a1, int a2, int a3, int a4, const char *a5, const sockaddr *a6, int a7, int *a8)
{
  v47 = *MEMORY[0x1E69E9840];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v13 = gLogObj;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
  }

  else
  {
    v14 = gLogFDOverride;

    if (v14 == -1)
    {
      goto LABEL_10;
    }
  }

  v15 = nw_endpoint_create_address(a6);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v16 = gLogObj;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    string_for_dns_service_error = nwlog_get_string_for_dns_service_error(a4);
    v18 = v15;
    v19 = v18;
    if (v18)
    {
      description = _nw_endpoint_get_description(v18);
    }

    else
    {
      description = "<NULL>";
    }

    *buf = 136448002;
    v34 = "nw_nat64_getaddrinfo_callback_async";
    v35 = 1024;
    *v36 = a2;
    *&v36[4] = 1024;
    *&v36[6] = a3;
    v37 = 2082;
    v38 = string_for_dns_service_error;
    v39 = 1024;
    v40 = a4;
    v41 = 2082;
    v42 = a5;
    v43 = 2082;
    v44 = description;
    v45 = 1024;
    v46 = a7;
    _os_log_impl(&dword_181A37000, v16, OS_LOG_TYPE_DEBUG, "%{public}s flags=0x%x ifindex=%u error=%{public}s(%d) hostname=%{public}s addr=%{public}s ttl=%u", buf, 0x42u);
  }

LABEL_10:
  if (!a4 && (a2 & 2) != 0 && a6 && a6->sa_family == 30)
  {
    v23 = a8[4];
    v24 = v23 + 1;
    a8[4] = v23 + 1;
    if (v23 == -1)
    {
      v26 = __nwlog_obj();
      os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
      *buf = 136446210;
      v34 = "nw_nat64_getaddrinfo_callback_async";
      v27 = _os_log_send_and_compose_impl();

      if (__nwlog_should_abort(v27))
      {
        goto LABEL_28;
      }

      free(v27);
    }

    v25 = reallocf(*a8, 28 * v24);
    if (v25)
    {
LABEL_23:
      *a8 = v25;
      v25[a8[4] - 1] = *&a6->sa_data[6];
      goto LABEL_11;
    }

    v28 = __nwlog_obj();
    os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
    *buf = 136446466;
    v34 = "nw_nat64_getaddrinfo_callback_async";
    v35 = 2048;
    *v36 = 28 * v24;
    v29 = _os_log_send_and_compose_impl();

    if (!__nwlog_should_abort(v29))
    {
      free(v29);
      v25 = 0;
      goto LABEL_23;
    }

LABEL_28:
    __break(1u);
    return;
  }

LABEL_11:
  if ((a2 & 1) == 0)
  {
    if (a1)
    {
      DNSServiceRefDeallocate(a1);
    }

    (*(*(a8 + 1) + 16))(*(a8 + 1), a8[4]);
    v21 = *(a8 + 1);
    *(a8 + 1) = 0;

    v22 = *(a8 + 1);
    *(a8 + 1) = 0;

    if (*a8)
    {
      free(*a8);
    }

    free(a8);
  }
}

void nw_nat64_getaddrinfo_callback_sync(_DNSServiceRef_t *a1, int a2, int a3, int a4, const char *a5, const sockaddr *a6, int a7, void **a8)
{
  v46 = *MEMORY[0x1E69E9840];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v14 = gLogObj;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
  }

  else
  {
    v15 = gLogFDOverride;

    if (v15 == -1)
    {
      goto LABEL_10;
    }
  }

  address = nw_endpoint_create_address(a6);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v17 = gLogObj;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    v30 = a6;
    v18 = a8;
    string_for_dns_service_error = nwlog_get_string_for_dns_service_error(a4);
    v20 = address;
    v21 = v20;
    if (v20)
    {
      description = _nw_endpoint_get_description(v20);
    }

    else
    {
      description = "<NULL>";
    }

    *buf = 136448002;
    v33 = "nw_nat64_getaddrinfo_callback_sync";
    v34 = 1024;
    *v35 = a2;
    *&v35[4] = 1024;
    *&v35[6] = a3;
    v36 = 2082;
    v37 = string_for_dns_service_error;
    v38 = 1024;
    v39 = a4;
    v40 = 2082;
    v41 = a5;
    v42 = 2082;
    v43 = description;
    v44 = 1024;
    v45 = a7;
    _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_DEBUG, "%{public}s flags=0x%x ifindex=%u error=%{public}s(%d) hostname=%{public}s addr=%{public}s ttl=%u", buf, 0x42u);
    a8 = v18;
    a6 = v30;
  }

LABEL_10:
  if (a4 || (a2 & 2) == 0 || !a6 || a6->sa_family != 30)
  {
    goto LABEL_11;
  }

  v23 = *(a8 + 2);
  v24 = v23 + 1;
  *(a8 + 2) = v23 + 1;
  if (v23 == -1)
  {
    v26 = __nwlog_obj();
    os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v33 = "nw_nat64_getaddrinfo_callback_sync";
    v27 = _os_log_send_and_compose_impl();

    if (__nwlog_should_abort(v27))
    {
      goto LABEL_24;
    }

    free(v27);
  }

  v25 = reallocf(*a8, 28 * v24);
  if (!v25)
  {
    v28 = __nwlog_obj();
    os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
    *buf = 136446466;
    v33 = "nw_nat64_getaddrinfo_callback_sync";
    v34 = 2048;
    *v35 = 28 * v24;
    v29 = _os_log_send_and_compose_impl();

    if (!__nwlog_should_abort(v29))
    {
      free(v29);
      v25 = 0;
      goto LABEL_19;
    }

LABEL_24:
    __break(1u);
    return;
  }

LABEL_19:
  *a8 = v25;
  v25[*(a8 + 2) - 1] = *&a6->sa_data[6];
LABEL_11:
  if ((a2 & 1) == 0)
  {
    *(a8 + 12) = 1;
  }
}

uint64_t nw_nat64_synthesize(int *a1, __int16 *a2, void **a3)
{
  v40 = *MEMORY[0x1E69E9840];
  pthread_once(&nw_settings_setup_atfork::pOnce, nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec == 1 && (sNWParentAllowedDispatch & 1) != 0)
  {
    return 0;
  }

  if ((sNWDispatchAllowedNow & 1) == 0)
  {
    if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0 || (getpid(), sandbox_check() == 1))
    {
      sNWDispatchAllowedNow = 1;
    }

    else if (sNWDispatchAllowedNow != 1)
    {
      return 0;
    }
  }

  if (!a2)
  {
    v21 = __nwlog_obj();
    *buf = 136446210;
    v34 = "nw_nat64_synthesize";
    v22 = _os_log_send_and_compose_impl();

    LOBYTE(__dst[0]) = 16;
    LOBYTE(v32) = 0;
    if (__nwlog_fault(v22, __dst, &v32))
    {
      if (LOBYTE(__dst[0]) == 17)
      {
        v23 = __nwlog_obj();
        v24 = __dst[0];
        if (os_log_type_enabled(v23, __dst[0]))
        {
          *buf = 136446210;
          v34 = "nw_nat64_synthesize";
          v25 = "%{public}s called with null ipv4";
LABEL_59:
          _os_log_impl(&dword_181A37000, v23, v24, v25, buf, 0xCu);
        }

LABEL_60:

        goto LABEL_61;
      }

      if (v32 != 1)
      {
        v23 = __nwlog_obj();
        v24 = __dst[0];
        if (os_log_type_enabled(v23, __dst[0]))
        {
          *buf = 136446210;
          v34 = "nw_nat64_synthesize";
          v25 = "%{public}s called with null ipv4, backtrace limit exceeded";
          goto LABEL_59;
        }

        goto LABEL_60;
      }

      backtrace_string = __nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = __dst[0];
      v28 = os_log_type_enabled(v23, __dst[0]);
      if (!backtrace_string)
      {
        if (v28)
        {
          *buf = 136446210;
          v34 = "nw_nat64_synthesize";
          v25 = "%{public}s called with null ipv4, no backtrace";
          goto LABEL_59;
        }

        goto LABEL_60;
      }

      if (!v28)
      {
        goto LABEL_50;
      }

      *buf = 136446466;
      v34 = "nw_nat64_synthesize";
      v35 = 2082;
      *v36 = backtrace_string;
      v29 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_49;
    }

LABEL_61:
    if (v22)
    {
      free(v22);
    }

    return 0xFFFFFFFFLL;
  }

  if (!a3)
  {
    v26 = __nwlog_obj();
    *buf = 136446210;
    v34 = "nw_nat64_synthesize";
    v22 = _os_log_send_and_compose_impl();

    LOBYTE(__dst[0]) = 16;
    LOBYTE(v32) = 0;
    if (__nwlog_fault(v22, __dst, &v32))
    {
      if (LOBYTE(__dst[0]) == 17)
      {
        v23 = __nwlog_obj();
        v24 = __dst[0];
        if (os_log_type_enabled(v23, __dst[0]))
        {
          *buf = 136446210;
          v34 = "nw_nat64_synthesize";
          v25 = "%{public}s called with null out_ipv6_addrs";
          goto LABEL_59;
        }

        goto LABEL_60;
      }

      if (v32 != 1)
      {
        v23 = __nwlog_obj();
        v24 = __dst[0];
        if (os_log_type_enabled(v23, __dst[0]))
        {
          *buf = 136446210;
          v34 = "nw_nat64_synthesize";
          v25 = "%{public}s called with null out_ipv6_addrs, backtrace limit exceeded";
          goto LABEL_59;
        }

        goto LABEL_60;
      }

      backtrace_string = __nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = __dst[0];
      v30 = os_log_type_enabled(v23, __dst[0]);
      if (!backtrace_string)
      {
        if (v30)
        {
          *buf = 136446210;
          v34 = "nw_nat64_synthesize";
          v25 = "%{public}s called with null out_ipv6_addrs, no backtrace";
          goto LABEL_59;
        }

        goto LABEL_60;
      }

      if (!v30)
      {
        goto LABEL_50;
      }

      *buf = 136446466;
      v34 = "nw_nat64_synthesize";
      v35 = 2082;
      *v36 = backtrace_string;
      v29 = "%{public}s called with null out_ipv6_addrs, dumping backtrace:%{public}s";
LABEL_49:
      _os_log_impl(&dword_181A37000, v23, v24, v29, buf, 0x16u);
LABEL_50:

      free(backtrace_string);
      goto LABEL_61;
    }

    goto LABEL_61;
  }

  v32 = 0;
  v6 = nw_nat64_copy_prefixes(a1, &v32);
  v7 = v6;
  if (v6 < 1)
  {
    return v7;
  }

  v8 = v6;
  v9 = malloc_type_calloc(v6, 0x10uLL, 0x40DF7419uLL);
  if (!v9)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v34 = "nw_nat64_synthesize";
    v35 = 2048;
    *v36 = v8;
    *&v36[8] = 2048;
    *v37 = 16;
    v11 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v11);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v11);
    v9 = 0;
  }

  v13 = 0;
  v7 = 0;
  *a3 = v9;
  do
  {
    if (nw_nat64_synthesize_v6((v32 + v13), a2, *a3 + 16 * v7))
    {
      v7 = (v7 + 1);
      goto LABEL_17;
    }

    if (*(v32 + v13) > 0xCu)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v20 = *a2;
        *buf = 136446466;
        v34 = "nw_nat64_synthesize";
        v35 = 1024;
        *v36 = v20;
        v17 = v14;
        v18 = "%{public}s nw_nat64_synthesize_v6 for %{network:in_addr}u";
        v19 = 18;
        goto LABEL_24;
      }
    }

    else
    {
      __dst[0] = 0;
      __dst[1] = 0;
      memcpy(__dst, v32 + v13 + 4, *(v32 + v13));
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v15 = *a2;
        v16 = 8 * *(v32 + v13);
        *buf = 136447234;
        v34 = "nw_nat64_synthesize";
        v35 = 1024;
        *v36 = v15;
        *&v36[4] = 1040;
        *&v36[6] = 16;
        *v37 = 2096;
        *&v37[2] = __dst;
        v38 = 1024;
        v39 = v16;
        v17 = v14;
        v18 = "%{public}s nw_nat64_synthesize_v6 for %{network:in_addr}u from %{network:in6_addr}.16P/%d";
        v19 = 40;
LABEL_24:
        _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_ERROR, v18, buf, v19);
      }
    }

LABEL_17:
    v13 += 16;
    --v8;
  }

  while (v8);
  if (v32)
  {
    free(v32);
    v32 = 0;
  }

  if (!v7)
  {
    if (*a3)
    {
      free(*a3);
      v7 = 0;
      *a3 = 0;
      return v7;
    }

    return 0;
  }

  return v7;
}

uint64_t nw_nat64_copy_prefixes_async(int *a1, void *a2, void *a3)
{
  v34 = *MEMORY[0x1E69E9840];
  v5 = a2;
  v6 = a3;
  nw_allow_use_of_dispatch_internal();
  if (v5)
  {
    if (v6)
    {
      if (gLogDatapath == 1)
      {
        v16 = __nwlog_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          if (a1)
          {
            v17 = *a1;
          }

          else
          {
            v17 = 0;
          }

          *buf = 136446466;
          v31 = "nw_nat64_copy_prefixes_async";
          v32 = 1024;
          LODWORD(v33) = v17;
          _os_log_impl(&dword_181A37000, v16, OS_LOG_TYPE_DEBUG, "%{public}s Start nw_nat64_copy_prefixes_async(%u)", buf, 0x12u);
        }
      }

      v7 = nw_nat64_copy_prefixes_internal(a1, 0, v5, 0, 0, v6);
      if (v7 != 0x80000000)
      {
        block[0] = MEMORY[0x1E69E9820];
        block[1] = 3221225472;
        block[2] = __nw_nat64_copy_prefixes_async_block_invoke;
        block[3] = &unk_1E6A3CEC0;
        v27 = v7;
        v26 = v6;
        dispatch_async(v5, block);
      }

      v8 = 1;
      goto LABEL_7;
    }

    v14 = __nwlog_obj();
    *buf = 136446210;
    v31 = "nw_nat64_copy_prefixes_async";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v31 = "nw_nat64_copy_prefixes_async";
          _os_log_impl(&dword_181A37000, v12, v15, "%{public}s called with null block", buf, 0xCu);
        }

LABEL_45:

        goto LABEL_46;
      }

      if (v28 != 1)
      {
        v12 = __nwlog_obj();
        v24 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v31 = "nw_nat64_copy_prefixes_async";
          _os_log_impl(&dword_181A37000, v12, v24, "%{public}s called with null block, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_45;
      }

      backtrace_string = __nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v21 = type;
      v22 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v22)
        {
          *buf = 136446210;
          v31 = "nw_nat64_copy_prefixes_async";
          _os_log_impl(&dword_181A37000, v12, v21, "%{public}s called with null block, no backtrace", buf, 0xCu);
        }

        goto LABEL_45;
      }

      if (v22)
      {
        *buf = 136446466;
        v31 = "nw_nat64_copy_prefixes_async";
        v32 = 2082;
        v33 = backtrace_string;
        _os_log_impl(&dword_181A37000, v12, v21, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = __nwlog_obj();
    *buf = 136446210;
    v31 = "nw_nat64_copy_prefixes_async";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v31 = "nw_nat64_copy_prefixes_async";
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s called with null queue", buf, 0xCu);
        }

        goto LABEL_45;
      }

      if (v28 != 1)
      {
        v12 = __nwlog_obj();
        v23 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v31 = "nw_nat64_copy_prefixes_async";
          _os_log_impl(&dword_181A37000, v12, v23, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_45;
      }

      backtrace_string = __nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v19 = type;
      v20 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *buf = 136446210;
          v31 = "nw_nat64_copy_prefixes_async";
          _os_log_impl(&dword_181A37000, v12, v19, "%{public}s called with null queue, no backtrace", buf, 0xCu);
        }

        goto LABEL_45;
      }

      if (v20)
      {
        *buf = 136446466;
        v31 = "nw_nat64_copy_prefixes_async";
        v32 = 2082;
        v33 = backtrace_string;
        _os_log_impl(&dword_181A37000, v12, v19, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_30:

      free(backtrace_string);
    }
  }

LABEL_46:
  if (v11)
  {
    free(v11);
  }

  v8 = 0;
LABEL_7:

  return v8;
}

uint64_t __nw_nat64_copy_prefixes_async_block_invoke(uint64_t a1)
{
  v9 = *MEMORY[0x1E69E9840];
  if (gLogDatapath == 1)
  {
    v2 = a1;
    v3 = __nwlog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      v4 = *(v2 + 40);
      v5 = 136446466;
      v6 = "nw_nat64_copy_prefixes_async_block_invoke";
      v7 = 1024;
      v8 = v4;
      _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_DEBUG, "%{public}s nw_nat64_copy_prefixes_async returning %d", &v5, 0x12u);
    }

    a1 = v2;
  }

  return (*(*(a1 + 32) + 16))(*(a1 + 32), *(a1 + 40), 0);
}

uint64_t nw_nat64_copy_prefixes_async_override_dns(int *a1, void *a2, DNSServiceRef *a3, _DWORD *a4, void *a5)
{
  v38 = *MEMORY[0x1E69E9840];
  v9 = a2;
  v10 = a5;
  nw_allow_use_of_dispatch_internal();
  if (v9)
  {
    if (v10)
    {
      if (gLogDatapath == 1)
      {
        v20 = __nwlog_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          if (a1)
          {
            v21 = *a1;
          }

          else
          {
            v21 = 0;
          }

          *buf = 136446466;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          v36 = 1024;
          LODWORD(v37) = v21;
          _os_log_impl(&dword_181A37000, v20, OS_LOG_TYPE_DEBUG, "%{public}s Start nw_nat64_copy_prefixes_async_override_dns(%u)", buf, 0x12u);
        }
      }

      v11 = nw_nat64_copy_prefixes_internal(a1, 0, v9, a3, a4, v10);
      if (v11 != 0x80000000)
      {
        block[0] = MEMORY[0x1E69E9820];
        block[1] = 3221225472;
        block[2] = __nw_nat64_copy_prefixes_async_override_dns_block_invoke;
        block[3] = &unk_1E6A3CEC0;
        v30 = v10;
        v31 = v11;
        dispatch_async(v9, block);
      }

      v12 = 1;
      goto LABEL_7;
    }

    v18 = __nwlog_obj();
    *buf = 136446210;
    v35 = "nw_nat64_copy_prefixes_async_override_dns";
    v15 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (__nwlog_fault(v15, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v16 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v16, type))
        {
          *buf = 136446210;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          _os_log_impl(&dword_181A37000, v16, v19, "%{public}s called with null block", buf, 0xCu);
        }

LABEL_45:

        goto LABEL_46;
      }

      if (v32 != 1)
      {
        v16 = __nwlog_obj();
        v28 = type;
        if (os_log_type_enabled(v16, type))
        {
          *buf = 136446210;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          _os_log_impl(&dword_181A37000, v16, v28, "%{public}s called with null block, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_45;
      }

      backtrace_string = __nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v25 = type;
      v26 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *buf = 136446210;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          _os_log_impl(&dword_181A37000, v16, v25, "%{public}s called with null block, no backtrace", buf, 0xCu);
        }

        goto LABEL_45;
      }

      if (v26)
      {
        *buf = 136446466;
        v35 = "nw_nat64_copy_prefixes_async_override_dns";
        v36 = 2082;
        v37 = backtrace_string;
        _os_log_impl(&dword_181A37000, v16, v25, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_30;
    }
  }

  else
  {
    v14 = __nwlog_obj();
    *buf = 136446210;
    v35 = "nw_nat64_copy_prefixes_async_override_dns";
    v15 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (__nwlog_fault(v15, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v16 = __nwlog_obj();
        v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *buf = 136446210;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          _os_log_impl(&dword_181A37000, v16, v17, "%{public}s called with null queue", buf, 0xCu);
        }

        goto LABEL_45;
      }

      if (v32 != 1)
      {
        v16 = __nwlog_obj();
        v27 = type;
        if (os_log_type_enabled(v16, type))
        {
          *buf = 136446210;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          _os_log_impl(&dword_181A37000, v16, v27, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_45;
      }

      backtrace_string = __nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v23 = type;
      v24 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v24)
        {
          *buf = 136446210;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          _os_log_impl(&dword_181A37000, v16, v23, "%{public}s called with null queue, no backtrace", buf, 0xCu);
        }

        goto LABEL_45;
      }

      if (v24)
      {
        *buf = 136446466;
        v35 = "nw_nat64_copy_prefixes_async_override_dns";
        v36 = 2082;
        v37 = backtrace_string;
        _os_log_impl(&dword_181A37000, v16, v23, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_30:

      free(backtrace_string);
    }
  }

LABEL_46:
  if (v15)
  {
    free(v15);
  }

  v12 = 0;
LABEL_7:

  return v12;
}

NWConcrete_nw_nat64_prefixes_resolver *nw_nat64_prefixes_resolver_create(void *a1)
{
  v38 = *MEMORY[0x1E69E9840];
  v2 = a1;
  v3 = [NWConcrete_nw_nat64_prefixes_resolver alloc];
  v4 = v2;
  if (!v3)
  {
    goto LABEL_19;
  }

  v33.receiver = v3;
  v33.super_class = NWConcrete_nw_nat64_prefixes_resolver;
  v5 = objc_msgSendSuper2(&v33, sel_init);
  v6 = v5;
  if (!v5)
  {
    v23 = __nwlog_obj();
    *buf = 136446210;
    v35 = "[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
    v24 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v24, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *buf = 136446210;
          v35 = "[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_181A37000, v25, v26, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v31 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v25 = __nwlog_obj();
        v28 = type;
        v29 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *buf = 136446466;
            v35 = "[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
            v36 = 2082;
            v37 = backtrace_string;
            _os_log_impl(&dword_181A37000, v25, v28, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }

        if (v29)
        {
          *buf = 136446210;
          v35 = "[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_181A37000, v25, v28, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v25 = __nwlog_obj();
        v30 = type;
        if (os_log_type_enabled(v25, type))
        {
          *buf = 136446210;
          v35 = "[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_181A37000, v25, v30, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_48:
    if (v24)
    {
      free(v24);
    }

    goto LABEL_15;
  }

  *(v5 + 3) = 0;
  objc_storeStrong(v5 + 2, a1);
  v6[6] = 0;
  *(v6 + 26) = 0;
  v7 = v6[12];
  v6[11] = 0;
  v6[12] = 0;

  if (v4)
  {
    v8 = v4;
  }

  else
  {
    v8 = _nw_parameters_create();
  }

  v9 = v6[2];
  v6[2] = v8;

  v10 = nw_parameters_copy_context(v6[2]);
  v11 = v6[3];
  v6[3] = v10;

  if (nw_context_is_inline(v6[3]))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    *buf = 136446210;
    v35 = "[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v13, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *buf = 136446210;
          v35 = "[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_181A37000, v14, v15, "%{public}s Cannot use nw_nat64_prefixes_resolver on inline contexts", buf, 0xCu);
        }
      }

      else if (v31 == 1)
      {
        v19 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v20 = type;
        v21 = os_log_type_enabled(v14, type);
        if (v19)
        {
          if (v21)
          {
            *buf = 136446466;
            v35 = "[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
            v36 = 2082;
            v37 = v19;
            _os_log_impl(&dword_181A37000, v14, v20, "%{public}s Cannot use nw_nat64_prefixes_resolver on inline contexts, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v19);
          if (!v13)
          {
            goto LABEL_14;
          }

          goto LABEL_13;
        }

        if (v21)
        {
          *buf = 136446210;
          v35 = "[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_181A37000, v14, v20, "%{public}s Cannot use nw_nat64_prefixes_resolver on inline contexts, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v22 = type;
        if (os_log_type_enabled(v14, type))
        {
          *buf = 136446210;
          v35 = "[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_181A37000, v14, v22, "%{public}s Cannot use nw_nat64_prefixes_resolver on inline contexts, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v13)
    {
LABEL_14:

LABEL_15:
      v3 = 0;
      goto LABEL_19;
    }

LABEL_13:
    free(v13);
    goto LABEL_14;
  }

  v16 = nw_parameters_copy_required_interface(v6[2]);
  v17 = v16;
  if (v16)
  {
    *(v6 + 3) = _nw_interface_get_index(v16);
  }

  v3 = v6;

LABEL_19:
  return v3;
}

void nw_nat64_prefixes_resolver_set_queue(void *a1, void *a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    os_unfair_lock_lock(v3 + 2);
    objc_storeStrong(v3 + 10, a2);
    os_unfair_lock_unlock(v3 + 2);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_nat64_prefixes_resolver_set_queue";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_nat64_prefixes_resolver_set_queue";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_nat64_prefixes_resolver_set_queue";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_nat64_prefixes_resolver_set_queue";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_nat64_prefixes_resolver_set_queue";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

LABEL_3:
}

void nw_nat64_prefixes_resolver_set_update_handler(void *a1, void *a2, void *a3)
{
  v31 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = v7;
  if (!v5)
  {
    v11 = __nwlog_obj();
    *buf = 136446210;
    v28 = "nw_nat64_prefixes_resolver_set_update_handler";
    v12 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v12, &type, &v25))
    {
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *buf = 136446210;
        v28 = "nw_nat64_prefixes_resolver_set_update_handler";
        _os_log_impl(&dword_181A37000, v13, v14, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v25 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v18 = type;
      v19 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *buf = 136446466;
          v28 = "nw_nat64_prefixes_resolver_set_update_handler";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_181A37000, v13, v18, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v12)
        {
          goto LABEL_6;
        }

LABEL_41:
        free(v12);
        goto LABEL_6;
      }

      if (v19)
      {
        *buf = 136446210;
        v28 = "nw_nat64_prefixes_resolver_set_update_handler";
        _os_log_impl(&dword_181A37000, v13, v18, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v13 = __nwlog_obj();
      v23 = type;
      if (os_log_type_enabled(v13, type))
      {
        *buf = 136446210;
        v28 = "nw_nat64_prefixes_resolver_set_update_handler";
        _os_log_impl(&dword_181A37000, v13, v23, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_39:

    goto LABEL_40;
  }

  if (v7)
  {
    os_unfair_lock_lock(v5 + 2);
    v9 = _Block_copy(v8);
    v10 = *(v5 + 8);
    *(v5 + 8) = v9;

    if (v6)
    {
      objc_storeStrong(v5 + 10, a2);
    }

    os_unfair_lock_unlock(v5 + 2);
    goto LABEL_6;
  }

  v15 = __nwlog_obj();
  *buf = 136446210;
  v28 = "nw_nat64_prefixes_resolver_set_update_handler";
  v12 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v12, &type, &v25))
  {
    goto LABEL_40;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v13 = __nwlog_obj();
    v16 = type;
    if (os_log_type_enabled(v13, type))
    {
      *buf = 136446210;
      v28 = "nw_nat64_prefixes_resolver_set_update_handler";
      _os_log_impl(&dword_181A37000, v13, v16, "%{public}s called with null update_handler", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v25 != 1)
  {
    v13 = __nwlog_obj();
    v24 = type;
    if (os_log_type_enabled(v13, type))
    {
      *buf = 136446210;
      v28 = "nw_nat64_prefixes_resolver_set_update_handler";
      _os_log_impl(&dword_181A37000, v13, v24, "%{public}s called with null update_handler, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_39;
  }

  v20 = __nw_create_backtrace_string();
  v13 = __nwlog_obj();
  v21 = type;
  v22 = os_log_type_enabled(v13, type);
  if (!v20)
  {
    if (v22)
    {
      *buf = 136446210;
      v28 = "nw_nat64_prefixes_resolver_set_update_handler";
      _os_log_impl(&dword_181A37000, v13, v21, "%{public}s called with null update_handler, no backtrace", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v22)
  {
    *buf = 136446466;
    v28 = "nw_nat64_prefixes_resolver_set_update_handler";
    v29 = 2082;
    v30 = v20;
    _os_log_impl(&dword_181A37000, v13, v21, "%{public}s called with null update_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v20);
  if (v12)
  {
    goto LABEL_41;
  }

LABEL_6:
}

void nw_nat64_prefixes_resolver_set_cancel_handler(void *a1, void *a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    os_unfair_lock_lock(v3 + 2);
    v5 = _Block_copy(v4);
    v6 = *&v3[18]._os_unfair_lock_opaque;
    *&v3[18]._os_unfair_lock_opaque = v5;

    os_unfair_lock_unlock(v3 + 2);
    goto LABEL_3;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *buf = 136446210;
        v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v8)
  {
    free(v8);
  }

LABEL_3:
}

void nw_nat64_prefixes_resolver_start(void *a1)
{
  *&v47[13] = *MEMORY[0x1E69E9840];
  v1 = a1;
  nw_allow_use_of_dispatch_internal();
  if (v1)
  {
    os_unfair_lock_lock(v1 + 2);
    if (!*(v1 + 8))
    {
      os_unfair_lock_unlock(v1 + 2);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = gLogObj;
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446210;
        v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl(&dword_181A37000, v2, OS_LOG_TYPE_ERROR, "%{public}s The nat64 prefixes resolver's handler is not set. You must set this resolver's handler using nw_nat64_prefixes_resolver_set_update_handler() in order to successfully start it.", buf, 0xCu);
      }

      goto LABEL_13;
    }

    if (!*(v1 + 10))
    {
      os_unfair_lock_unlock(v1 + 2);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = gLogObj;
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446210;
        v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl(&dword_181A37000, v2, OS_LOG_TYPE_ERROR, "%{public}s The nat64 prefixes resolver's client_queue is not set. You must set this resolver's client_queue using nw_nat64_prefixes_resolver_set_update_handler() in order to successfully start it.", buf, 0xCu);
      }

      goto LABEL_13;
    }

    if (*(v1 + 6))
    {
      os_unfair_lock_unlock(v1 + 2);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = gLogObj;
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446210;
        v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl(&dword_181A37000, v2, OS_LOG_TYPE_ERROR, "%{public}s The nat64 prefixes resolver has already been started.", buf, 0xCu);
      }

LABEL_13:

      goto LABEL_51;
    }

    v3 = _nw_parameters_create();
    if (v3)
    {
      nw_parameters_get_required_interface_index(*(v1 + 2));
      v5 = v4;
      if (v4)
      {
        v6 = nw_interface_create_with_index(v4);
        if (!v6)
        {
          os_unfair_lock_unlock(v1 + 2);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = gLogObj;
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *buf = 136446466;
            v45 = "nw_nat64_prefixes_resolver_start";
            v46 = 1024;
            *v47 = v5;
            _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_ERROR, "%{public}s nw_interface_create_with_index failed for index %u", buf, 0x12u);
          }

          goto LABEL_50;
        }

        nw_parameters_require_interface(v3, v6);
      }

      if (nw_parameters_get_required_address_family(*(v1 + 2)))
      {
        nw_nat64_prefixes_resolver_start_dns_query_locked(v1);
LABEL_32:
        os_unfair_lock_unlock(v1 + 2);
LABEL_50:

        goto LABEL_51;
      }

      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0, v3);
      v15 = *(v1 + 12);
      *(v1 + 12) = evaluator_for_endpoint;

      v16 = *(v1 + 12);
      if (v16)
      {
        nw_path_evaluator_set_logging(v16);
        v17 = *(v1 + 12);
        v18 = *(v1 + 10);
        v40[0] = MEMORY[0x1E69E9820];
        v40[1] = 3221225472;
        v40[2] = __nw_nat64_prefixes_resolver_start_block_invoke;
        v40[3] = &unk_1E6A3CD80;
        v19 = v1;
        v41 = v19;
        nw_path_evaluator_set_update_handler(v17, v18, v40);
        v20 = nw_path_evaluator_copy_path(*(v1 + 12));
        nw_nat64_prefixes_resolver_path_update_callback_locked(v19, v20);

        goto LABEL_32;
      }

      os_unfair_lock_unlock(v1 + 2);
      v23 = __nwlog_obj();
      *buf = 136446466;
      v45 = "nw_nat64_prefixes_resolver_start";
      v46 = 1024;
      *v47 = v5;
      v24 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v42 = 0;
      if (!__nwlog_fault(v24, &type, &v42))
      {
        goto LABEL_63;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *buf = 136446466;
          v45 = "nw_nat64_prefixes_resolver_start";
          v46 = 1024;
          *v47 = v5;
          _os_log_impl(&dword_181A37000, v25, v26, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed", buf, 0x12u);
        }
      }

      else if (v42 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v25 = __nwlog_obj();
        v29 = type;
        v30 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *buf = 136446722;
            v45 = "nw_nat64_prefixes_resolver_start";
            v46 = 1024;
            *v47 = v5;
            v47[2] = 2082;
            *&v47[3] = backtrace_string;
            _os_log_impl(&dword_181A37000, v25, v29, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(backtrace_string);
          goto LABEL_63;
        }

        if (v30)
        {
          *buf = 136446466;
          v45 = "nw_nat64_prefixes_resolver_start";
          v46 = 1024;
          *v47 = v5;
          _os_log_impl(&dword_181A37000, v25, v29, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        v25 = __nwlog_obj();
        v31 = type;
        if (os_log_type_enabled(v25, type))
        {
          *buf = 136446466;
          v45 = "nw_nat64_prefixes_resolver_start";
          v46 = 1024;
          *v47 = v5;
          _os_log_impl(&dword_181A37000, v25, v31, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, backtrace limit exceeded", buf, 0x12u);
        }
      }

LABEL_63:
      if (!v24)
      {
        goto LABEL_50;
      }

      v27 = v24;
      goto LABEL_49;
    }

    os_unfair_lock_unlock(v1 + 2);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    *buf = 136446210;
    v45 = "nw_nat64_prefixes_resolver_start";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v8, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v45 = "nw_nat64_prefixes_resolver_start";
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s nw_parameters_create failed", buf, 0xCu);
        }
      }

      else if (v42 == 1)
      {
        v11 = __nw_create_backtrace_string();
        v9 = __nwlog_obj();
        v12 = type;
        v13 = os_log_type_enabled(v9, type);
        if (v11)
        {
          if (v13)
          {
            *buf = 136446466;
            v45 = "nw_nat64_prefixes_resolver_start";
            v46 = 2082;
            *v47 = v11;
            _os_log_impl(&dword_181A37000, v9, v12, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v11);
          goto LABEL_47;
        }

        if (v13)
        {
          *buf = 136446210;
          v45 = "nw_nat64_prefixes_resolver_start";
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v9 = __nwlog_obj();
        v22 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v45 = "nw_nat64_prefixes_resolver_start";
          _os_log_impl(&dword_181A37000, v9, v22, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_47:
    if (!v8)
    {
      goto LABEL_50;
    }

    v27 = v8;
LABEL_49:
    free(v27);
    goto LABEL_50;
  }

  v32 = __nwlog_obj();
  *buf = 136446210;
  v45 = "nw_nat64_prefixes_resolver_start";
  v33 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (__nwlog_fault(v33, &type, &v42))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v34 = __nwlog_obj();
      v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *buf = 136446210;
        v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl(&dword_181A37000, v34, v35, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v42 == 1)
    {
      v36 = __nw_create_backtrace_string();
      v34 = __nwlog_obj();
      v37 = type;
      v38 = os_log_type_enabled(v34, type);
      if (v36)
      {
        if (v38)
        {
          *buf = 136446466;
          v45 = "nw_nat64_prefixes_resolver_start";
          v46 = 2082;
          *v47 = v36;
          _os_log_impl(&dword_181A37000, v34, v37, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v36);
        goto LABEL_81;
      }

      if (v38)
      {
        *buf = 136446210;
        v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl(&dword_181A37000, v34, v37, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v34 = __nwlog_obj();
      v39 = type;
      if (os_log_type_enabled(v34, type))
      {
        *buf = 136446210;
        v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl(&dword_181A37000, v34, v39, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_81:
  if (v33)
  {
    free(v33);
  }

LABEL_51:
}

void __nw_nat64_prefixes_resolver_start_block_invoke(uint64_t a1, void *a2)
{
  v3 = *(a1 + 32);
  v4 = a2;
  os_unfair_lock_lock(v3 + 2);
  nw_nat64_prefixes_resolver_path_update_callback_locked(*(a1 + 32), v4);

  v5 = (*(a1 + 32) + 8);

  os_unfair_lock_unlock(v5);
}

void nw_nat64_prefixes_resolver_path_update_callback_locked(void *a1, void *a2)
{
  v33 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    v13 = __nwlog_obj();
    *buf = 136446210;
    v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
    v14 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v14, &type, &v27))
    {
      goto LABEL_49;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *buf = 136446210;
        v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        _os_log_impl(&dword_181A37000, v15, v16, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v27 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v20 = type;
      v21 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *buf = 136446466;
          v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_181A37000, v15, v20, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_49:
        if (!v14)
        {
          goto LABEL_15;
        }

LABEL_50:
        free(v14);
        goto LABEL_15;
      }

      if (v21)
      {
        *buf = 136446210;
        v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        _os_log_impl(&dword_181A37000, v15, v20, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v15 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        *buf = 136446210;
        v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        _os_log_impl(&dword_181A37000, v15, v25, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_48:

    goto LABEL_49;
  }

  if (v4)
  {
    v6 = v4;
    v7 = _nw_path_has_ipv4(v6);

    if ((v7 & 1) != 0 || (v8 = v6, v9 = _nw_path_has_ipv6(v8), v8, !v9))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446466;
        v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        v31 = 2114;
        v32 = v6;
        _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_DEBUG, "%{public}s disabling NAT64 prefix detection for path=%{public}@", buf, 0x16u);
      }

      if (*(v3 + 6))
      {
        nw_nat64_prefixes_resolver_cancel_dns_query_locked(v3);
      }

      *(v3 + 26) = 0;
      v12 = *(v3 + 11);
      if (v12)
      {
        free(v12);
        *(v3 + 11) = 0;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446466;
        v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        v31 = 2114;
        v32 = v8;
        _os_log_impl(&dword_181A37000, v10, OS_LOG_TYPE_DEBUG, "%{public}s enabling NAT64 prefix detection for path=%{public}@", buf, 0x16u);
      }

      if (!*(v3 + 6))
      {
        nw_nat64_prefixes_resolver_start_dns_query_locked(v3);
      }
    }

    goto LABEL_15;
  }

  v17 = __nwlog_obj();
  *buf = 136446210;
  v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
  v14 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (!__nwlog_fault(v14, &type, &v27))
  {
    goto LABEL_49;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v15 = __nwlog_obj();
    v18 = type;
    if (os_log_type_enabled(v15, type))
    {
      *buf = 136446210;
      v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
      _os_log_impl(&dword_181A37000, v15, v18, "%{public}s called with null path", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (v27 != 1)
  {
    v15 = __nwlog_obj();
    v26 = type;
    if (os_log_type_enabled(v15, type))
    {
      *buf = 136446210;
      v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
      _os_log_impl(&dword_181A37000, v15, v26, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_48;
  }

  v22 = __nw_create_backtrace_string();
  v15 = __nwlog_obj();
  v23 = type;
  v24 = os_log_type_enabled(v15, type);
  if (!v22)
  {
    if (v24)
    {
      *buf = 136446210;
      v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
      _os_log_impl(&dword_181A37000, v15, v23, "%{public}s called with null path, no backtrace", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (v24)
  {
    *buf = 136446466;
    v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
    v31 = 2082;
    v32 = v22;
    _os_log_impl(&dword_181A37000, v15, v23, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v22);
  if (v14)
  {
    goto LABEL_50;
  }

LABEL_15:
}

void nw_nat64_prefixes_resolver_start_dns_query_locked(NWConcrete_nw_nat64_prefixes_resolver *a1)
{
  v1 = a1;
  v2 = *(v1 + 3);
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3221225472;
  v4[2] = ___ZL49nw_nat64_prefixes_resolver_start_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke;
  v4[3] = &unk_1E6A3D868;
  v3 = v1;
  v5 = v3;
  nw_queue_context_async(v2, v4);
}

void ___ZL49nw_nat64_prefixes_resolver_start_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke(uint64_t a1)
{
  v35 = *MEMORY[0x1E69E9840];
  os_unfair_lock_lock((*(a1 + 32) + 8));
  v33 = xmmword_182BD3240;
  v34 = unk_182BD3250;
  strcpy(v32, "DNSServiceGetAddrInfo");
  HIWORD(v32[2]) = 0;
  v32[3] = 0;
  *(*(a1 + 32) + 48) = 0;
  v2 = *(a1 + 32);
  nw_parameters_get_required_interface_index(*(v2 + 16));
  AddrInfo = DNSServiceGetAddrInfo((v2 + 48), 0x9000u, v3, 2u, "ipv4only.arpa", nw_nat64_prefixes_resolver_dns_callback, *(a1 + 32));
  if (AddrInfo == -65569)
  {
    *(*(a1 + 32) + 48) = 0;
    v6 = *(a1 + 32);
    nw_parameters_get_required_interface_index(*(v6 + 16));
    v8 = DNSServiceGetAddrInfo((v6 + 48), 0x9000u, v7, 2u, "ipv4only.arpa", nw_nat64_prefixes_resolver_dns_callback, *(a1 + 32));
    v5 = v8;
    if (v8 == -65569)
    {
      goto LABEL_8;
    }

    if (v8)
    {
      goto LABEL_3;
    }
  }

  else
  {
    v5 = AddrInfo;
    if (AddrInfo)
    {
LABEL_3:
      if (!v5)
      {
        goto LABEL_15;
      }

      goto LABEL_8;
    }
  }

  strcpy(v32, "DNSServiceSetDispatchQueue");
  v9 = *(a1 + 32);
  v10 = *(v9 + 48);
  v11 = nw_context_copy_workloop(*(v9 + 24));
  v5 = DNSServiceSetDispatchQueue(v10, v11);

  if (!v5)
  {
LABEL_15:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      *buf = 136446466;
      v23 = "nw_nat64_prefixes_resolver_start_dns_query_locked_block_invoke";
      v24 = 2082;
      v25 = "ipv4only.arpa";
      _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_DEBUG, "%{public}s started DNS query for %{public}s successfully", buf, 0x16u);
    }

    v18 = *(a1 + 32);
    v19 = v18;
    v16 = v18[4];
    v18[4] = v19;
    goto LABEL_18;
  }

LABEL_8:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v12 = gLogObj;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *buf = 136447234;
    v23 = "nw_nat64_prefixes_resolver_start_dns_query_locked_block_invoke";
    v24 = 2080;
    v25 = v32;
    v26 = 2082;
    v27 = "ipv4only.arpa";
    v28 = 2082;
    string_for_dns_service_error = nwlog_get_string_for_dns_service_error(v5);
    v30 = 1024;
    v31 = v5;
    _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_ERROR, "%{public}s %s for %{public}s failed with error=%{public}s(%d)", buf, 0x30u);
  }

  v13 = *(a1 + 32);
  v14 = v13[6];
  if (v14)
  {
    DNSServiceRefDeallocate(v14);
    *(*(a1 + 32) + 48) = 0;
    v13 = *(a1 + 32);
  }

  v15 = v13[10];
  if (v15)
  {
    block[0] = MEMORY[0x1E69E9820];
    block[1] = 3221225472;
    block[2] = ___ZL49nw_nat64_prefixes_resolver_start_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke_92;
    block[3] = &unk_1E6A3D868;
    v21 = v13;
    dispatch_async(v15, block);

    v13 = *(a1 + 32);
  }

  v16 = v13[4];
  v13[4] = 0;
LABEL_18:

  os_unfair_lock_unlock((*(a1 + 32) + 8));
}

void ___ZL49nw_nat64_prefixes_resolver_start_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke_92(uint64_t a1)
{
  os_unfair_lock_lock((*(a1 + 32) + 8));
  v2 = *(a1 + 32);
  v3 = *(v2 + 64);
  if (v3)
  {
    v4 = _Block_copy(v3);
    os_unfair_lock_unlock((*(a1 + 32) + 8));
    (*(v4 + 2))(v4, 0, 0);
  }

  else
  {

    os_unfair_lock_unlock((v2 + 8));
  }
}

void nw_nat64_prefixes_resolver_dns_callback(_DNSServiceRef_t *a1, int a2, int a3, int a4, const char *a5, const sockaddr *a6, int a7, void *a8)
{
  v60 = *MEMORY[0x1E69E9840];
  nw_allow_use_of_dispatch_internal();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v14 = gLogObj;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
  }

  else
  {
    v15 = gLogFDOverride;

    if (v15 == -1)
    {
      goto LABEL_10;
    }
  }

  address = nw_endpoint_create_address(a6);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v17 = gLogObj;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    v42 = a6;
    string_for_dns_service_error = nwlog_get_string_for_dns_service_error(a4);
    v19 = address;
    v20 = v19;
    if (v19)
    {
      description = _nw_endpoint_get_description(v19);
    }

    else
    {
      description = "<NULL>";
    }

    *buf = 136448002;
    *&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
    *&buf[12] = 1024;
    *&buf[14] = a2;
    *&buf[18] = 1024;
    *&buf[20] = a3;
    *v51 = 2082;
    *&v51[2] = string_for_dns_service_error;
    v52 = 1024;
    v53 = a4;
    v54 = 2082;
    v55 = a5;
    v56 = 2082;
    v57 = description;
    v58 = 1024;
    v59 = a7;
    _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_DEBUG, "%{public}s flags=0x%x ifindex=%u error=%{public}s(%d) hostname=%{public}s addr=%{public}s ttl=%u", buf, 0x42u);
    a6 = v42;
  }

LABEL_10:
  if (a8)
  {
    v22 = a8;
    os_unfair_lock_lock(v22 + 2);
    if (!*(v22 + 8))
    {
LABEL_25:
      os_unfair_lock_unlock(v22 + 2);

      return;
    }

    if (a4 || (a2 & 2) == 0 || !a6 || a6->sa_family != 30)
    {
LABEL_13:
      if ((a2 & 1) == 0)
      {
        *buf = 0;
        *&buf[8] = buf;
        *&buf[16] = 0x2020000000;
        *v51 = 0;
        v23 = v22[26];
        if (v23 < 1)
        {
          v24 = 0;
        }

        else
        {
          v24 = nw_nat64_copy_prefixes_from_ipv4only_records(*(v22 + 11), v23, v51);
          v22[26] = 0;
          v25 = *(v22 + 11);
          if (v25)
          {
            free(v25);
            *(v22 + 11) = 0;
          }
        }

        v29 = *(v22 + 10);
        block[0] = MEMORY[0x1E69E9820];
        block[1] = 3221225472;
        block[2] = ___ZL39nw_nat64_prefixes_resolver_dns_callbackP16_DNSServiceRef_tjjiPKcPK8sockaddrjPv_block_invoke;
        block[3] = &unk_1E6A3C060;
        v47 = v24;
        v45 = v22;
        v46 = buf;
        dispatch_async(v29, block);

        _Block_object_dispose(buf, 8);
      }

      goto LABEL_25;
    }

    v26 = v22[26];
    v27 = v26 + 1;
    v22[26] = v26 + 1;
    if (v26 == -1)
    {
      v38 = __nwlog_obj();
      os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
      *buf = 136446210;
      *&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
      v39 = _os_log_send_and_compose_impl();

      if (__nwlog_should_abort(v39))
      {
        goto LABEL_49;
      }

      free(v39);
    }

    v28 = reallocf(*(v22 + 11), 28 * v27);
    if (v28)
    {
LABEL_22:
      *(v22 + 11) = v28;
      v28[v22[26] - 1] = *&a6->sa_data[6];
      goto LABEL_13;
    }

    v40 = __nwlog_obj();
    os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
    *buf = 136446466;
    *&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
    *&buf[12] = 2048;
    *&buf[14] = 28 * v27;
    v41 = _os_log_send_and_compose_impl();

    if (!__nwlog_should_abort(v41))
    {
      free(v41);
      v28 = 0;
      goto LABEL_22;
    }

LABEL_49:
    __break(1u);
    return;
  }

  v30 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
  v31 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (__nwlog_fault(v31, &type, &v48))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v32 = __nwlog_obj();
      v33 = type;
      if (os_log_type_enabled(v32, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
        _os_log_impl(&dword_181A37000, v32, v33, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v48 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v35 = type;
      v36 = os_log_type_enabled(v32, type);
      if (backtrace_string)
      {
        if (v36)
        {
          *buf = 136446466;
          *&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v32, v35, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_43;
      }

      if (v36)
      {
        *buf = 136446210;
        *&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
        _os_log_impl(&dword_181A37000, v32, v35, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v32 = __nwlog_obj();
      v37 = type;
      if (os_log_type_enabled(v32, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
        _os_log_impl(&dword_181A37000, v32, v37, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_43:
  if (v31)
  {
    free(v31);
  }
}

void sub_1828867E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void ___ZL39nw_nat64_prefixes_resolver_dns_callbackP16_DNSServiceRef_tjjiPKcPK8sockaddrjPv_block_invoke(uint64_t a1)
{
  v7[2] = *MEMORY[0x1E69E9840];
  os_unfair_lock_lock((*(a1 + 32) + 8));
  v2 = *(a1 + 32);
  v3 = *(v2 + 64);
  if (v3)
  {
    v4 = _Block_copy(v3);
    os_unfair_lock_unlock((*(a1 + 32) + 8));
    v5 = *(a1 + 48);
    if (v5)
    {
      v4[2](v4, v5, *(*(*(a1 + 40) + 8) + 24));
    }

    else
    {
      v7[0] = 0;
      v7[1] = 0;
      (v4)[2](v4, v5, v7);
    }
  }

  else
  {
    os_unfair_lock_unlock((v2 + 8));
  }

  v6 = *(*(*(a1 + 40) + 8) + 24);
  if (v6)
  {
    free(v6);
    *(*(*(a1 + 40) + 8) + 24) = 0;
  }
}

void nw_nat64_prefixes_resolver_cancel_dns_query_locked(NWConcrete_nw_nat64_prefixes_resolver *a1)
{
  v22 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  v3 = *(v1 + 6);
  if (!v3)
  {
    goto LABEL_4;
  }

  if (*(v1 + 4))
  {
    *(v1 + 6) = 0;
    v4 = *(v1 + 3);
    v13[0] = MEMORY[0x1E69E9820];
    v13[1] = 3221225472;
    v13[2] = ___ZL50nw_nat64_prefixes_resolver_cancel_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke;
    v13[3] = &unk_1E6A3AC58;
    v15 = v3;
    v14 = v1;
    nw_queue_context_async_if_needed(v4, v13);

    goto LABEL_4;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
  v6 = _os_log_send_and_compose_impl();

  v17 = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *buf = 136446210;
        v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null resolver->internally_retained_object", buf, 0xCu);
      }
    }

    else if (v16 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = v17;
      v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null resolver->internally_retained_object, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v11)
      {
        *buf = 136446210;
        v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null resolver->internally_retained_object, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *buf = 136446210;
        v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null resolver->internally_retained_object, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_21:
  if (v6)
  {
    free(v6);
  }

LABEL_4:
}

void ___ZL50nw_nat64_prefixes_resolver_cancel_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke(uint64_t a1)
{
  DNSServiceRefDeallocate(*(a1 + 40));
  v2 = *(a1 + 32);
  v3 = *(v2 + 32);
  *(v2 + 32) = 0;
}

void nw_nat64_prefixes_resolver_cancel(void *a1)
{
  v25 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 2);
    nw_nat64_prefixes_resolver_cancel_dns_query_locked(v2);
    v3 = *&v2[16]._os_unfair_lock_opaque;
    *&v2[16]._os_unfair_lock_opaque = 0;

    v4 = *&v2[24]._os_unfair_lock_opaque;
    if (v4)
    {
      nw_path_evaluator_cancel(v4);
      v5 = *&v2[24]._os_unfair_lock_opaque;
      *&v2[24]._os_unfair_lock_opaque = 0;
    }

    v6 = *&v2[22]._os_unfair_lock_opaque;
    if (v6)
    {
      free(v6);
      *&v2[22]._os_unfair_lock_opaque = 0;
    }

    v2[26]._os_unfair_lock_opaque = 0;
    v7 = *&v2[18]._os_unfair_lock_opaque;
    if (v7)
    {
      v8 = _Block_copy(v7);
      v9 = *&v2[18]._os_unfair_lock_opaque;
      *&v2[18]._os_unfair_lock_opaque = 0;

      dispatch_async(*&v2[20]._os_unfair_lock_opaque, v8);
    }

    v10 = *&v2[20]._os_unfair_lock_opaque;
    *&v2[20]._os_unfair_lock_opaque = 0;

    os_unfair_lock_unlock(v2 + 2);
    goto LABEL_9;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v22 = "nw_nat64_prefixes_resolver_cancel";
  v12 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *buf = 136446210;
        v22 = "nw_nat64_prefixes_resolver_cancel";
        _os_log_impl(&dword_181A37000, v13, v14, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v19 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *buf = 136446466;
          v22 = "nw_nat64_prefixes_resolver_cancel";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_181A37000, v13, v16, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v17)
      {
        *buf = 136446210;
        v22 = "nw_nat64_prefixes_resolver_cancel";
        _os_log_impl(&dword_181A37000, v13, v16, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v13 = __nwlog_obj();
      v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *buf = 136446210;
        v22 = "nw_nat64_prefixes_resolver_cancel";
        _os_log_impl(&dword_181A37000, v13, v18, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_26:
  if (v12)
  {
    free(v12);
  }

LABEL_9:
}

uint64_t nw_nat64_prefixes_resolver_copy_interface(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 2);
    v3 = nw_interface_create_with_index(v2[3]._os_unfair_lock_opaque);
    os_unfair_lock_unlock(v2 + 2);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_nat64_prefixes_resolver_copy_interface";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_nat64_prefixes_resolver_copy_interface";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_nat64_prefixes_resolver_copy_interface";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_nat64_prefixes_resolver_copy_interface";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_nat64_prefixes_resolver_copy_interface";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t llhttp_finish(uint64_t a1)
{
  if (*(a1 + 24))
  {
    return 0;
  }

  v2 = *(a1 + 81);
  if (!*(a1 + 81))
  {
    return 0;
  }

  if (v2 == 2)
  {
    *(a1 + 32) = "Invalid EOF state";
    return 14;
  }

  if (v2 != 1)
  {
    abort();
  }

  v3 = *(a1 + 88);
  if (!v3)
  {
    return 0;
  }

  v4 = *(v3 + 88);
  if (!v4)
  {
    return 0;
  }

  result = v4();
  if (!result)
  {
    return 0;
  }

  return result;
}

uint64_t llhttp__on_url(uint64_t a1)
{
  v1 = *(a1 + 88);
  if (!v1)
  {
    return 0;
  }

  v2 = *(v1 + 8);
  if (!v2)
  {
    return 0;
  }

  result = v2();
  if (result == -1)
  {
    *(a1 + 32) = "Span callback error in on_url";
    return 24;
  }

  return result;
}

uint64_t llhttp__on_status(uint64_t a1)
{
  v1 = *(a1 + 88);
  if (!v1)
  {
    return 0;
  }

  v2 = *(v1 + 16);
  if (!v2)
  {
    return 0;
  }

  result = v2();
  if (result == -1)
  {
    *(a1 + 32) = "Span callback error in on_status";
    return 24;
  }

  return result;
}

uint64_t llhttp__on_method(uint64_t a1)
{
  v1 = *(a1 + 88);
  if (!v1)
  {
    return 0;
  }

  v2 = *(v1 + 24);
  if (!v2)
  {
    return 0;
  }

  result = v2();
  if (result == -1)
  {
    *(a1 + 32) = "Span callback error in on_method";
    return 24;
  }

  return result;
}

uint64_t llhttp__on_version(uint64_t a1)
{
  v1 = *(a1 + 88);
  if (!v1)
  {
    return 0;
  }

  v2 = *(v1 + 32);
  if (!v2)
  {
    return 0;
  }

  result = v2();
  if (result == -1)
  {
    *(a1 + 32) = "Span callback error in on_version";
    return 24;
  }

  return result;
}

uint64_t llhttp__on_header_field(uint64_t a1)
{
  v1 = *(a1 + 88);
  if (!v1)
  {
    return 0;
  }

  v2 = *(v1 + 40);
  if (!v2)
  {
    return 0;
  }

  result = v2();
  if (result == -1)
  {
    *(a1 + 32) = "Span callback error in on_header_field";
    return 24;
  }

  return result;
}

uint64_t llhttp__on_header_value(uint64_t a1)
{
  v1 = *(a1 + 88);
  if (!v1)
  {
    return 0;
  }

  v2 = *(v1 + 48);
  if (!v2)
  {
    return 0;
  }

  result = v2();
  if (result == -1)
  {
    *(a1 + 32) = "Span callback error in on_header_value";
    return 24;
  }

  return result;
}

uint64_t llhttp__on_body(uint64_t a1)
{
  v1 = *(a1 + 88);
  if (!v1)
  {
    return 0;
  }

  v2 = *(v1 + 80);
  if (!v2)
  {
    return 0;
  }

  result = v2();
  if (result == -1)
  {
    *(a1 + 32) = "Span callback error in on_body";
    return 24;
  }

  return result;
}

uint64_t llhttp__on_chunk_extension_name(uint64_t a1)
{
  v1 = *(a1 + 88);
  if (!v1)
  {
    return 0;
  }

  v2 = *(v1 + 56);
  if (!v2)
  {
    return 0;
  }

  result = v2();
  if (result == -1)
  {
    *(a1 + 32) = "Span callback error in on_chunk_extension_name";
    return 24;
  }

  return result;
}

uint64_t llhttp__on_chunk_extension_value(uint64_t a1)
{
  v1 = *(a1 + 88);
  if (!v1)
  {
    return 0;
  }

  v2 = *(v1 + 64);
  if (!v2)
  {
    return 0;
  }

  result = v2();
  if (result == -1)
  {
    *(a1 + 32) = "Span callback error in on_chunk_extension_value";
    return 24;
  }

  return result;
}

void nw_mem_cache_stats_dump(void)
{
  v18 = *MEMORY[0x1E69E9840];
  if (nw_mem_dump_slab_stats == 1)
  {
    os_unfair_lock_lock(&nw_mem_cache_lock);
    v0 = nw_mem_cache_head;
    if (nw_mem_cache_head)
    {
      do
      {
        v1 = __nwlog_obj();
        if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
        {
          v2 = v0[4];
          v3 = v0[5];
          v4 = v0[67];
          v5 = v0[68];
          *buf = 136447490;
          v7 = "nw_mem_cache_stats_dump";
          v8 = 2082;
          v9 = v0 + 12;
          v10 = 2048;
          v11 = v2;
          v12 = 2048;
          v13 = v3;
          v14 = 2048;
          v15 = v4;
          v16 = 2048;
          v17 = v5;
          _os_log_impl(&dword_181A37000, v1, OS_LOG_TYPE_INFO, "%{public}s \n\n%{public}s: \n\tNumber of Slabs created %llu\n\tNumber of Slabs destroyed %llu\n\tNumber of Cache Allocs %llu\n\tNumber of Cache Frees %llu", buf, 0x3Eu);
        }

        v0 = v0[10];
      }

      while (v0);
    }

    os_unfair_lock_unlock(&nw_mem_cache_lock);
    nw_mem_region_stats_dump();
  }
}

void nw_mem_cache_update_set_timer()
{
  if ((nw_mem_cache_update_set_timer::cache_update_timer_set & 1) == 0)
  {
    os_unfair_lock_lock(&nw_mem_cache_lock);
    if ((nw_mem_cache_update_set_timer::cache_update_timer_set & 1) == 0)
    {
      source = nw_mem_cache_update_source;
      if (nw_mem_cache_update_source || (v1 = nw_context_copy_implicit_context(), source = nw_queue_context_create_source(v1, 2, 3, 0, &__block_literal_global_58401, 0), (nw_mem_cache_update_source = source) != 0))
      {
        v2 = dispatch_time(0x8000000000000000, 11000000000);
        nw_queue_set_timer_values(source, v2, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
        nw_queue_activate_source(nw_mem_cache_update_source, v3);
        nw_mem_cache_update_set_timer::cache_update_timer_set = 1;
      }
    }

    os_unfair_lock_unlock(&nw_mem_cache_lock);
  }
}

void __nw_mem_cache_update_set_timer_block_invoke()
{
  v25 = *MEMORY[0x1E69E9840];
  os_unfair_lock_lock(&nw_mem_cache_lock);
  v0 = nw_mem_cache_head;
  if (nw_mem_cache_head)
  {
    while (1)
    {
      v1 = *(v0 + 216);
      if (!v1)
      {
        break;
      }

      block[0] = MEMORY[0x1E69E9820];
      block[1] = 0x40000000;
      v16 = ___ZL19nw_mem_cache_updateP12nw_mem_cache_block_invoke;
      v17 = &__block_descriptor_tmp_7_58410;
      v18 = v0;
      if (*(v1 + 272))
      {
        if (dispatch_workloop_is_current())
        {
          v16(block);
        }

        else
        {
          dispatch_async(*(v1 + 272), block);
        }
      }

      else
      {
        ___ZL19nw_mem_cache_updateP12nw_mem_cache_block_invoke(block);
      }

LABEL_4:
      v0 = *(v0 + 80);
      if (!v0)
      {
        goto LABEL_26;
      }
    }

    __nwlog_obj();
    *buf = 136446210;
    v22 = "nw_mem_cache_update";
    v2 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v2, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        log = type;
        if (!os_log_type_enabled(v12, type))
        {
          goto LABEL_24;
        }

        *buf = 136446210;
        v22 = "nw_mem_cache_update";
        v3 = v12;
        v4 = log;
        v5 = "%{public}s called with null nwm->nwm_region";
        goto LABEL_23;
      }

      if (v19 != 1)
      {
        v14 = __nwlog_obj();
        logb = type;
        if (!os_log_type_enabled(v14, type))
        {
          goto LABEL_24;
        }

        *buf = 136446210;
        v22 = "nw_mem_cache_update";
        v3 = v14;
        v4 = logb;
        v5 = "%{public}s called with null nwm->nwm_region, backtrace limit exceeded";
        goto LABEL_23;
      }

      backtrace_string = __nw_create_backtrace_string();
      loga = __nwlog_obj();
      v8 = type;
      v6 = os_log_type_enabled(loga, type);
      v7 = backtrace_string;
      if (backtrace_string)
      {
        if (v6)
        {
          *buf = 136446466;
          v22 = "nw_mem_cache_update";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_181A37000, loga, v8, "%{public}s called with null nwm->nwm_region, dumping backtrace:%{public}s", buf, 0x16u);
          v7 = backtrace_string;
        }

        free(v7);
        goto LABEL_24;
      }

      if (v6)
      {
        *buf = 136446210;
        v22 = "nw_mem_cache_update";
        v3 = loga;
        v4 = v8;
        v5 = "%{public}s called with null nwm->nwm_region, no backtrace";
LABEL_23:
        _os_log_impl(&dword_181A37000, v3, v4, v5, buf, 0xCu);
      }
    }

LABEL_24:
    if (v2)
    {
      free(v2);
    }

    goto LABEL_4;
  }

LABEL_26:
  os_unfair_lock_unlock(&nw_mem_cache_lock);
  nw_mem_cache_stats_dump();
  nw_mem_cache_update_set_timer::cache_update_timer_set = 0;
  if (nw_mem_cache_operations_during_interval == 1)
  {
    nw_mem_cache_operations_during_interval = 0;

    nw_mem_cache_update_set_timer();
  }
}

void ___ZL19nw_mem_cache_updateP12nw_mem_cache_block_invoke(uint64_t a1)
{
  v67 = *MEMORY[0x1E69E9840];
  v1 = *(a1 + 32);
  v2 = (v1 + 364);
  v3 = *(v1 + 8);
  v4 = *(v1 + 280);
  v5 = (v3 <= 2 * v4 || v4 + 1 >= *(v1 + 264)) && (v3 >= v4 >> 1 || v4 <= *(v1 + 256));
  *v2 = *(v1 + 360);
  *(v1 + 396) = *(v1 + 392);
  v6 = *(v1 + 64);
  if (*(v1 + 232) >= *(*(v1 + 336) + 16))
  {
    v7 = 1;
    *(v1 + 72) = v6;
    if (v5)
    {
      goto LABEL_37;
    }
  }

  else
  {
    v7 = v6 - *(v1 + 72) < 4;
    *(v1 + 72) = v6;
    if (v5)
    {
      goto LABEL_37;
    }
  }

  v8 = *(v1 + 256);
  if (v8 <= 1 << (flsll(3 * v3 + 4) - 2))
  {
    v9 = 1 << (flsll(3 * *(v1 + 8) + 4) - 2);
  }

  else
  {
    v9 = *(v1 + 256);
  }

  if (*(v1 + 264) >= v9)
  {
    v10 = v9;
  }

  else
  {
    v10 = *(v1 + 264);
  }

  v11 = *(v1 + 280) + 1;
  if (v10 < v11 >> 1 || v10 > 2 * v11)
  {
    v13 = nw_calloc_type<nw_mem_bufctl_bkt>(v10);
    if (v10)
    {
      if (v10 >= 0xE && (v10 ? (v14 = (v10 - 1) >> 32 == 0) : (v14 = 0), v14))
      {
        v15 = v10 & 0x1FFFFFFFCLL;
        v49 = v13;
        v50 = v10 & 0x1FFFFFFFCLL;
        do
        {
          *v49 = 0uLL;
          v49[1] = 0uLL;
          v49 += 2;
          v50 -= 4;
        }

        while (v50);
        v16 = v10 & 0xFFFFFFFC;
        if (v10 == v15)
        {
          goto LABEL_31;
        }
      }

      else
      {
        v15 = 0;
        v16 = 0;
      }

      v17 = v16 + 1;
      do
      {
        *(v13 + 8 * v15) = 0;
        v15 = v17++;
      }

      while (v10 > v15);
    }

LABEL_31:
    v18 = *(v1 + 280);
    v19 = *(v1 + 288);
    *(v1 + 280) = v10 - 1;
    *(v1 + 288) = v13;
    ++*(v1 + 24);
    v20 = __CFADD__(v18, 1);
    v21 = v18 + 1;
    if (v20)
    {
      v45 = 0;
    }

    else
    {
      v44 = 0;
      v45 = 0;
      do
      {
        v46 = v19[v44];
        if (v46)
        {
          v47 = *(v1 + 272);
          do
          {
            v19[v44] = *v46;
            v48 = (v46[1] >> v47) & (v10 - 1);
            *v46 = *(v13 + 8 * v48);
            *(v13 + 8 * v48) = v46;
            ++v45;
            v46 = v19[v44];
          }

          while (v46);
        }

        ++v44;
      }

      while (v21 > v44);
    }

    if (gLogDatapath == 1)
    {
      v52 = v21;
      v53 = v45;
      v54 = __nwlog_obj();
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
      {
        *v58 = 136447234;
        *&v58[4] = "nw_mem_cache_hash_rescale";
        v59 = 2048;
        v60 = v1;
        v61 = 1024;
        v62 = v52;
        v63 = 1024;
        v64 = v10;
        v65 = 1024;
        v66 = v53;
        _os_log_impl(&dword_181A37000, v54, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p old_size %u new_size %u [%u moved]", v58, 0x28u);
      }
    }

    if (v19)
    {
      free(v19);
    }
  }

LABEL_37:
  if (!v7)
  {
    v22 = *(v1 + 336);
    if (*(v1 + 232) < *(v22 + 16))
    {
      nw_mem_cache_magazine_purge(v1);
      *(v1 + 336) = v22 + 88;
      *(v1 + 72) = *(v1 + 64) + 0x7FFFFFFFLL;
      if ((*(v1 + 176) & 1) == 0)
      {
        *(v1 + 560) = *(v22 + 88);
        if (gLogDatapath == 1)
        {
          v55 = __nwlog_obj();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
          {
            v56 = *(v1 + 232);
            v57 = *(v1 + 560);
            *v58 = 136446978;
            *&v58[4] = "nw_mem_cache_magazine_enable";
            v59 = 2048;
            v60 = v1;
            v61 = 1024;
            v62 = v56;
            v63 = 1024;
            v64 = v57;
            _os_log_impl(&dword_181A37000, v55, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p chunksize %u magsize %d", v58, 0x22u);
          }
        }
      }
    }
  }

  v23 = *(v1 + 368);
  v24 = *(v1 + 364);
  if (v23 >= v24)
  {
    v25 = v24;
  }

  else
  {
    v25 = v23;
  }

  if (v25)
  {
    do
    {
      v29 = *(v1 + 352);
      if (!v29)
      {
        break;
      }

      *(v1 + 352) = *v29;
      v30 = *(v1 + 360) - 1;
      *(v1 + 360) = v30;
      if (v30 < *(v1 + 364))
      {
        *v2 = v30;
      }

      v31 = *(v1 + 336);
      ++*(v1 + 344);
      v32 = *v31;
      if (v32 >= 1)
      {
        v33 = v29 + 1;
        do
        {
          v34 = *v33;
          v35 = *(v1 + 192);
          if (v35)
          {
            v35(*v33, *(v1 + 208));
          }

          nw_mem_slab_free(v1, v34);
          ++v33;
          --v32;
        }

        while (v32);
      }

      --v25;
      malloc_zone_free(g_slab_zone, v29);
    }

    while (v25);
  }

  v26 = *(v1 + 400);
  v27 = *(v1 + 396);
  if (v26 >= v27)
  {
    v28 = v27;
  }

  else
  {
    v28 = v26;
  }

  if (v28)
  {
    do
    {
      v36 = *(v1 + 384);
      if (!v36)
      {
        break;
      }

      *(v1 + 384) = *v36;
      v37 = *(v1 + 392) - 1;
      *(v1 + 392) = v37;
      if (v37 < *(v1 + 396))
      {
        *(v1 + 396) = v37;
      }

      ++*(v1 + 376);
      --v28;
      malloc_zone_free(g_slab_zone, v36);
    }

    while (v28);
  }

  *v58 = 0;
  if (!mach_timebase_info(v58))
  {
    v38 = mach_absolute_time() * *v58 / *&v58[4];
    v39 = v38 / 0x3B9ACA00;
    *&nw_mem_get_current_time::current_time = v38 / 0x3B9ACA00;
    *(&nw_mem_get_current_time::current_time + 1) = v38 % 0x3B9ACA00;
    v40 = *(v1 + 408);
    if (v40 >= 1 && (v39 - v40) >= 7)
    {
      nw_mem_cache_magazine_purge(v1);
      if ((*(v1 + 176) & 1) == 0)
      {
        *(v1 + 560) = **(v1 + 336);
        if (gLogDatapath == 1)
        {
          v41 = __nwlog_obj();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
          {
            v42 = *(v1 + 232);
            v43 = *(v1 + 560);
            *v58 = 136446978;
            *&v58[4] = "nw_mem_cache_magazine_enable";
            v59 = 2048;
            v60 = v1;
            v61 = 1024;
            v62 = v42;
            v63 = 1024;
            v64 = v43;
            _os_log_impl(&dword_181A37000, v41, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p chunksize %u magsize %d", v58, 0x22u);
          }
        }
      }
    }
  }

  os_unfair_lock_lock(&nw_mem_region_lock);
  if (g_process_transaction)
  {
    if ((g_transaction_touched & 1) == 0)
    {
      os_release(g_process_transaction);
      g_process_transaction = 0;
      g_transaction_touched = 0;
      if (gLogDatapath == 1)
      {
        v51 = __nwlog_obj();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
        {
          *v58 = 136446210;
          *&v58[4] = "nw_mem_region_reap_transaction";
          _os_log_impl(&dword_181A37000, v51, OS_LOG_TYPE_DEBUG, "%{public}s os transaction disabled after idle", v58, 0xCu);
        }
      }
    }
  }

  g_transaction_touched = 0;
  os_unfair_lock_unlock(&nw_mem_region_lock);
}

uint64_t nw_calloc_type<nw_mem_bufctl_bkt>(size_t count)
{
  if (!count || count >> 61)
  {
    v4 = __nwlog_obj();
    os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
    v5 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v5);
    if (result)
    {
      goto LABEL_9;
    }

    free(v5);
  }

  result = malloc_type_calloc(count, 8uLL, 0x1B7E0D9uLL);
  if (result)
  {
    return result;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
  v3 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v3);
  if (result)
  {
LABEL_9:
    __break(1u);
    return result;
  }

  free(v3);
  return 0;
}

void nw_mem_cache_magazine_purge(uint64_t a1)
{
  v30 = *MEMORY[0x1E69E9840];
  if (gLogDatapath == 1)
  {
    v25 = __nwlog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      v26 = 136446466;
      v27 = "nw_mem_cache_magazine_purge";
      v28 = 2048;
      v29 = a1;
      _os_log_impl(&dword_181A37000, v25, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p", &v26, 0x16u);
    }
  }

  v2 = *(a1 + 520);
  v3 = *(a1 + 528);
  v4 = *(a1 + 552);
  v5 = *(a1 + 556);
  *(a1 + 520) = 0u;
  *(a1 + 552) = -1;
  *(a1 + 560) = 0;
  if (v2)
  {
    if (v4 >= 1)
    {
      v6 = v2 + 1;
      do
      {
        v7 = *v6;
        v8 = *(a1 + 192);
        if (v8)
        {
          v8(*v6, *(a1 + 208));
        }

        nw_mem_slab_free(a1, v7);
        ++v6;
        --v4;
      }

      while (v4);
    }

    malloc_zone_free(g_slab_zone, v2);
  }

  if (v3)
  {
    if (v5 >= 1)
    {
      v9 = v3 + 1;
      do
      {
        v10 = *v9;
        v11 = *(a1 + 192);
        if (v11)
        {
          v11(*v9, *(a1 + 208));
        }

        nw_mem_slab_free(a1, v10);
        ++v9;
        --v5;
      }

      while (v5);
    }

    malloc_zone_free(g_slab_zone, v3);
  }

  v12 = *(a1 + 360);
  *(a1 + 368) = v12;
  *(a1 + 364) = v12;
  v13 = *(a1 + 392);
  *(a1 + 400) = v13;
  *(a1 + 396) = v13;
  if (v12)
  {
    do
    {
      v15 = *(a1 + 352);
      if (!v15)
      {
        break;
      }

      *(a1 + 352) = *v15;
      v16 = *(a1 + 360) - 1;
      *(a1 + 360) = v16;
      if (v16 < *(a1 + 364))
      {
        *(a1 + 364) = v16;
      }

      v17 = *(a1 + 336);
      ++*(a1 + 344);
      v18 = *v17;
      if (v18 >= 1)
      {
        v19 = v15 + 1;
        do
        {
          v20 = *v19;
          v21 = *(a1 + 192);
          if (v21)
          {
            v21(*v19, *(a1 + 208));
          }

          nw_mem_slab_free(a1, v20);
          ++v19;
          --v18;
        }

        while (v18);
      }

      --v12;
      malloc_zone_free(g_slab_zone, v15);
    }

    while (v12);
    v14 = *(a1 + 400);
    v13 = *(a1 + 396);
  }

  else
  {
    v14 = v13;
  }

  if (v14 >= v13)
  {
    v22 = v13;
  }

  else
  {
    v22 = v14;
  }

  if (v22)
  {
    do
    {
      v23 = *(a1 + 384);
      if (!v23)
      {
        break;
      }

      *(a1 + 384) = *v23;
      v24 = *(a1 + 392) - 1;
      *(a1 + 392) = v24;
      if (v24 < *(a1 + 396))
      {
        *(a1 + 396) = v24;
      }

      ++*(a1 + 376);
      --v22;
      malloc_zone_free(g_slab_zone, v23);
    }

    while (v22);
  }
}

void nw_mem_slab_free(uint64_t a1, unint64_t a2)
{
  v36 = *MEMORY[0x1E69E9840];
  ++*(a1 + 56);
  v4 = (*(a1 + 288) + 8 * ((a2 >> *(a1 + 272)) & *(a1 + 280)));
  v5 = v4;
  do
  {
    v5 = *v5;
    if (!v5)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
      *v35 = 136446722;
      *&v35[4] = "nw_mem_slab_free";
      *&v35[12] = 2048;
      *&v35[14] = a2;
      *&v35[22] = 2048;
      *&v35[24] = a1;
      v8 = _os_log_send_and_compose_impl();
      if (!__nwlog_should_abort(v8))
      {
        free(v8);
        v5 = 0;
        v7 = 0;
        goto LABEL_9;
      }

      goto LABEL_40;
    }
  }

  while (v5[1] != a2);
  for (i = *v4; i != v5; i = *i)
  {
    v4 = i;
  }

  *v4 = *i;
  v7 = v5[3];
LABEL_9:
  if (a2 - *(v7 + 3) >= *(*(v7 + 2) + 248))
  {
    v29 = __nwlog_obj();
    os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
    *v35 = 136446466;
    *&v35[4] = "nw_mem_slab_free";
    *&v35[12] = 2082;
    *&v35[14] = "VERIFY NW_MEM_SLAB_MEMBER(sl, buf) failed";
    v30 = _os_log_send_and_compose_impl();
    if (!__nwlog_should_abort(v30))
    {
      free(v30);
      if ((*(a1 + 176) & 2) != 0)
      {
        goto LABEL_35;
      }

      goto LABEL_11;
    }

LABEL_40:
    __break(1u);
    return;
  }

  if ((*(a1 + 176) & 2) == 0)
  {
    goto LABEL_11;
  }

LABEL_35:
  *v35 = 0;
  *&v35[8] = 0;
  gettimeofday(v35, 0);
  v5[4] = (1000 * *v35 + *&v35[8] / 1000);
  *(v5 + 11) = backtrace(v5 + 6, 16);
LABEL_11:
  v10 = (v7 + 56);
  v9 = *(v7 + 7);
  *v5 = v9;
  *(v7 + 7) = v5;
  v11 = *(v7 + 16) - 1;
  *(v7 + 16) = v11;
  if (v11)
  {
    if (!v9)
    {
      v12 = *v7;
      v13 = *(v7 + 1);
      v14 = (a1 + 320);
      if (*v7)
      {
        v14 = (*v7 + 8);
      }

      *v14 = v13;
      *v13 = v12;
      v15 = *(a1 + 296);
      *v7 = v15;
      if (v15)
      {
        v16 = (v15 + 8);
      }

      else
      {
        v16 = (a1 + 304);
      }

      *v16 = v7;
      *(a1 + 296) = v7;
      *(v7 + 1) = a1 + 296;
    }
  }

  else
  {
    v17 = *(v7 + 17);
    v18 = *v7;
    v19 = *(v7 + 1);
    v20 = (*v7 + 8);
    v21 = 304;
    if (v17 == 1)
    {
      v21 = 320;
    }

    v22 = (a1 + v21);
    if (!v18)
    {
      v20 = v22;
    }

    *v20 = v19;
    *v19 = v18;
    *(a1 + 8) -= v17;
    ++*(a1 + 40);
    v23 = *(v7 + 3);
    v24 = *(v7 + 4);
    if (gLogDatapath == 1)
    {
      v31 = __nwlog_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
      {
        *v35 = 136446722;
        *&v35[4] = "nw_mem_slab_destroy";
        *&v35[12] = 2048;
        *&v35[14] = a1;
        *&v35[22] = 2048;
        *&v35[24] = v7;
        _os_log_impl(&dword_181A37000, v31, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p sl %p", v35, 0x20u);
      }
    }

    if (gLogDatapath == 1)
    {
      v32 = __nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        v33 = *(*(v7 + 5) + 40);
        v34 = v23 + *(a1 + 240);
        *v35 = 136446978;
        *&v35[4] = "nw_mem_slab_destroy";
        *&v35[12] = 1024;
        *&v35[14] = v33;
        *&v35[18] = 2048;
        *&v35[20] = v23;
        *&v35[28] = 2048;
        *&v35[30] = v34;
        _os_log_impl(&dword_181A37000, v32, OS_LOG_TYPE_DEBUG, "%{public}s   [%u] [%p-%p)", v35, 0x26u);
      }
    }

    v25 = *v10;
    if (*v10)
    {
      do
      {
        v28 = *v10;
        if (*v10 == v25)
        {
          v26 = v7 + 56;
        }

        else
        {
          do
          {
            v26 = v28;
            v28 = *v28;
          }

          while (v28 != v25);
        }

        v27 = *v25;
        *v26 = *v28;
        malloc_zone_free(g_slab_zone, v25);
        v25 = v27;
      }

      while (v27);
    }

    malloc_zone_free(g_slab_zone, v7);
    nw_mem_region_free(*(a1 + 216), v23, v24);
  }
}

unint64_t nw_mem_cache_alloc(uint64_t a1)
{
  info[6] = *MEMORY[0x1E69E9840];
  v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  v65 = 0u;
  nw_mem_cache_operations_during_interval = 1;
  info[0] = 0;
  if (!mach_timebase_info(info))
  {
    v2 = mach_absolute_time() * info[0].numer / info[0].denom;
    *&nw_mem_get_current_time::current_time = v2 / 0x3B9ACA00;
    *(&nw_mem_get_current_time::current_time + 1) = v2 % 0x3B9ACA00;
    *(a1 + 408) = nw_mem_get_current_time::current_time;
  }

  v3 = *(a1 + 552);
  if (v3 < 1)
  {
    v7 = *(a1 + 556);
    while (1)
    {
      v8 = v3;
      if (v7 >= 1)
      {
        v4 = *(a1 + 528);
        *(a1 + 528) = *(a1 + 520);
        *(a1 + 556) = v3;
        *(a1 + 520) = v4;
        v3 = v7;
        goto LABEL_5;
      }

      v3 = *(a1 + 560);
      if (!v3)
      {
        break;
      }

      v4 = *(a1 + 352);
      if (!v4)
      {
        break;
      }

      *(a1 + 352) = *v4;
      v9 = *(a1 + 360) - 1;
      *(a1 + 360) = v9;
      if (v9 < *(a1 + 364))
      {
        *(a1 + 364) = v9;
      }

      ++*(a1 + 344);
      v10 = *(a1 + 528);
      if (v10)
      {
        *v10 = *(a1 + 384);
        *(a1 + 384) = v10;
        ++*(a1 + 392);
      }

      *(a1 + 528) = *(a1 + 520);
      *(a1 + 556) = v8;
      *(a1 + 520) = v4;
      *(a1 + 552) = v3;
      v7 = v8;
      if (v3 > 0)
      {
        goto LABEL_5;
      }
    }

    ++*(a1 + 48);
    v11 = *(a1 + 296);
    if (v11)
    {
      LODWORD(v12) = v11[17];
    }

    else
    {
      v13 = *(a1 + 216);
      v14 = *(v13 + 120);
      v15 = *(a1 + 248);
      v69 = 0;
      v70 = 0;
      v68 = 0;
      v16 = nw_mem_region_alloc(v13, &v68, &v70, &v69, 1);
      if (!v16)
      {
        if (gLogDatapath == 1)
        {
          v62 = __nwlog_obj();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
          {
            info[0].numer = 136446210;
            *&info[0].denom = "nw_mem_slab_create";
            _os_log_impl(&dword_181A37000, v62, OS_LOG_TYPE_DEBUG, "%{public}s nw mem region alloc failure", info, 0xCu);
          }
        }

        result = 0;
        ++*a1;
        return result;
      }

      v17 = v16;
      v11 = malloc_type_zone_memalign(g_slab_zone, 8uLL, 0x48uLL, 0x999AC9A2uLL);
      if (!v11)
      {
        v57 = __nwlog_obj();
        os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
        info[0].numer = 136446722;
        *&info[0].denom = "nw_mem_slab_create";
        LOWORD(info[1].denom) = 2048;
        *(&info[1].denom + 2) = 8;
        HIWORD(info[2].denom) = 2048;
        info[3] = 72;
        v58 = _os_log_send_and_compose_impl();
        result = __nwlog_should_abort(v58);
        if (result)
        {
LABEL_77:
          __break(1u);
          return result;
        }

        free(v58);
      }

      *(v11 + 8) = 0;
      *(v11 + 2) = 0u;
      *(v11 + 3) = 0u;
      *v11 = 0u;
      *(v11 + 1) = 0u;
      *(v11 + 2) = a1;
      *(v11 + 3) = v17;
      v18 = v68;
      v19 = v15 / v14;
      v11[17] = v15 / v14;
      v20 = v69;
      v21 = v70;
      *(v11 + 4) = v18;
      *(v11 + 5) = v21;
      *(v11 + 6) = v20;
      if ((nw_mem_debug & 2) != 0)
      {
        v22 = 176;
      }

      else
      {
        v22 = 40;
      }

      v23 = v19;
      if (v19)
      {
        v24 = v17;
        do
        {
          v25 = malloc_type_zone_memalign(g_slab_zone, 8uLL, v22, 0x7D9F1E0EuLL);
          if (!v25)
          {
            v26 = __nwlog_obj();
            os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
            info[0].numer = 136446722;
            *&info[0].denom = "nw_mem_slab_create";
            LOWORD(info[1].denom) = 2048;
            *(&info[1].denom + 2) = 8;
            HIWORD(info[2].denom) = 2048;
            info[3] = v22;
            v63 = _os_log_send_and_compose_impl();
            result = __nwlog_should_abort(v63);
            if (result)
            {
              goto LABEL_77;
            }

            free(v63);
          }

          bzero(v25, v22);
          v25[1] = v24;
          v25[2] = v18;
          v25[3] = v11;
          *(v25 + 8) = v11[17] - v23;
          *v25 = *(v11 + 7);
          *(v11 + 7) = v25;
          v24 += v14;
          if (v18)
          {
            v18 += v14;
          }

          else
          {
            v18 = 0;
          }

          --v23;
        }

        while (v23);
      }

      if (gLogDatapath == 1)
      {
        v59 = __nwlog_obj();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
        {
          info[0].numer = 136446722;
          *&info[0].denom = "nw_mem_slab_create";
          LOWORD(info[1].denom) = 2048;
          *(&info[1].denom + 2) = a1;
          HIWORD(info[2].denom) = 2048;
          info[3] = v11;
          _os_log_impl(&dword_181A37000, v59, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p sl %p", info, 0x20u);
        }
      }

      if (gLogDatapath == 1)
      {
        v60 = __nwlog_obj();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
        {
          v61 = *(*(v11 + 5) + 40);
          info[0].numer = 136446978;
          *&info[0].denom = "nw_mem_slab_create";
          LOWORD(info[1].denom) = 1024;
          *(&info[1].denom + 2) = v61;
          HIWORD(info[2].numer) = 2048;
          *&info[2].denom = v17;
          LOWORD(info[3].denom) = 2048;
          *(&info[3].denom + 2) = v17 + v14;
          _os_log_impl(&dword_181A37000, v60, OS_LOG_TYPE_DEBUG, "%{public}s   [%u] [%p-%p)", info, 0x26u);
        }
      }

      ++*(a1 + 32);
      v12 = v11[17];
      v27 = *(a1 + 16);
      v28 = *(a1 + 8) + v12;
      *(a1 + 8) = v28;
      if (v28 > v27)
      {
        *(a1 + 16) = v28;
      }
    }

    v29 = v11[16];
    v11[16] = v29 + 1;
    v30 = *(v11 + 7);
    v31 = *v30;
    *(v11 + 7) = *v30;
    result = v30[1];
    v32 = *(a1 + 240);
    *&v66 = result;
    *(&v66 + 1) = v32;
    v33 = *(v11 + 5);
    v34 = *(v30 + 8);
    v35 = v34 + v12 * *(v33 + 40);
    *&v67 = __PAIR64__(v34, v35);
    *(&v67 + 1) = v33;
    v64 = 0u;
    v65 = 0u;
    v36 = v30[2];
    if (v36)
    {
      *&v64 = v30[2];
      *(&v64 + 1) = v32;
      *&v65 = __PAIR64__(v34, v35);
      *(&v65 + 1) = *(v11 + 6);
    }

    v37 = *(a1 + 288);
    v38 = (result >> *(a1 + 272)) & *(a1 + 280);
    *v30 = *(v37 + 8 * v38);
    *(v37 + 8 * v38) = v30;
    if (v31)
    {
      if (v29)
      {
        if ((*(a1 + 176) & 2) == 0)
        {
          goto LABEL_43;
        }

        goto LABEL_58;
      }

      v45 = (a1 + 296);
      v46 = 304;
    }

    else
    {
      if (v29)
      {
        v42 = *v11;
        v43 = *(v11 + 1);
        v44 = (a1 + 304);
        if (*v11)
        {
          v44 = (*v11 + 8);
        }

        *v44 = v43;
        *v43 = v42;
      }

      v45 = (a1 + 312);
      v46 = 320;
    }

    v47 = *v45;
    *v11 = *v45;
    v48 = (a1 + v46);
    if (v47)
    {
      v48 = (v47 + 8);
    }

    *v48 = v11;
    *v45 = v11;
    *(v11 + 1) = v45;
    if ((*(a1 + 176) & 2) == 0)
    {
LABEL_43:
      v39 = *(a1 + 184);
      if (!v39)
      {
        return result;
      }

LABEL_44:
      v40 = result;
      if (v36)
      {
        v41 = &v64;
      }

      else
      {
        v41 = 0;
      }

      if (!v39(&v66, v41, *(a1 + 208), 1))
      {
        return v40;
      }

      ++*a1;
      nw_mem_slab_free(a1, v40);
      return 0;
    }

LABEL_58:
    info[0] = 0;
    info[1] = 0;
    v49 = result;
    gettimeofday(info, 0);
    v30[4] = 1000 * *info + info[1].numer / 1000;
    v50 = backtrace(v30 + 6, 16);
    result = v49;
    *(v30 + 11) = v50;
    v39 = *(a1 + 184);
    if (!v39)
    {
      return result;
    }

    goto LABEL_44;
  }

  v4 = *(a1 + 520);
LABEL_5:
  v5 = v3 - 1;
  *(a1 + 552) = v5;
  result = v4[v5 + 1];
  ++*(a1 + 536);
  if ((*(a1 + 176) & 2) != 0)
  {
    v51 = *(a1 + 288) + 8 * ((result >> *(a1 + 272)) & *(a1 + 280));
    while (1)
    {
      v51 = *v51;
      if (!v51)
      {
        break;
      }

      if (*(v51 + 8) == result)
      {
        info[0] = 0;
        info[1] = 0;
        v52 = result;
        gettimeofday(info, 0);
        *(v51 + 32) = 1000 * *info + info[1].numer / 1000;
        v53 = backtrace((v51 + 48), 16);
        result = v52;
        *(v51 + 44) = v53;
        return result;
      }
    }

    v54 = result;
    v55 = __nwlog_obj();
    os_log_type_enabled(v55, OS_LOG_TYPE_ERROR);
    info[0].numer = 136446722;
    *&info[0].denom = "nw_mem_audit_buf";
    LOWORD(info[1].denom) = 2082;
    *(&info[1].denom + 2) = a1 + 96;
    HIWORD(info[2].denom) = 2048;
    info[3] = v54;
    v56 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v56);
    if (!result)
    {
      free(v56);
      info[0] = 0;
      info[1] = 0;
      gettimeofday(info, 0);
      MEMORY[0x20] = 1000 * *info + info[1].numer / 1000;
      MEMORY[0x2C] = backtrace(0x30, 16);
      return v54;
    }

    goto LABEL_77;
  }

  return result;
}

uint64_t copyassocids(int a1, void *a2, _DWORD *a3)
{
  if (!a2 || !a3)
  {
    **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 0xFFFFFFFFLL;
  }

  *a2 = 0;
  *a3 = 0;
  v8 = 0;
  v9 = 0;
  if (ioctl(a1, 0xC0107396uLL, &v8))
  {
    return 0xFFFFFFFFLL;
  }

  result = v8;
  if (v8)
  {
    v7 = nw_calloc_type<unsigned int>(v8);
    v9 = v7;
    result = ioctl(a1, 0xC0107396uLL, &v8);
    if (!result)
    {
      *a2 = v7;
      *a3 = v8;
      return result;
    }

    if (v7)
    {
      free(v7);
    }

    return 0xFFFFFFFFLL;
  }

  return result;
}

uint64_t nw_calloc_type<unsigned int>(size_t a1)
{
  result = malloc_type_calloc(a1, 4uLL, 0x1B7E0D9uLL);
  if (!result)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    v2 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v2);
    if (result)
    {
      __break(1u);
    }

    else
    {
      free(v2);
      return 0;
    }
  }

  return result;
}

void freeassocids(void *a1)
{
  if (a1)
  {
    free(a1);
  }
}

uint64_t copyconnids(int a1, int a2, void *a3, unsigned int *a4)
{
  if (!a3 || !a4)
  {
    **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 0xFFFFFFFFLL;
  }

  *a3 = 0;
  *a4 = 0;
  v9 = a2;
  v10 = 0;
  v11 = 0;
  if (ioctl(a1, 0xC0107397uLL, &v9))
  {
    return 0xFFFFFFFFLL;
  }

  result = v10;
  if (v10)
  {
    v8 = nw_calloc_type<unsigned int>(v10);
    v11 = v8;
    result = ioctl(a1, 0xC0107397uLL, &v9);
    if (!result)
    {
      *a3 = v8;
      *a4 = v10;
      return result;
    }

    if (v8)
    {
      free(v8);
    }

    return 0xFFFFFFFFLL;
  }

  return result;
}

void freeconnids(void *a1)
{
  if (a1)
  {
    free(a1);
  }
}

void freeconninfo(void *a1)
{
  if (a1)
  {
    v2 = a1[1];
    if (v2)
    {
      free(v2);
      a1[1] = 0;
    }

    v3 = a1[2];
    if (v3)
    {
      free(v3);
      a1[2] = 0;
    }

    v4 = a1[4];
    if (v4)
    {
      free(v4);
    }

    free(a1);
  }
}

void __nw_protocol_swift_wrapper_setup_callbacks_block_invoke()
{
  qword_1EA842888 = nw_protocol_default_replace_input_handler;
  qword_1EA842930 = nw_protocol_default_input_finished;
  qword_1EA842938 = nw_protocol_default_output_finished;
  qword_1EA8428E8 = nw_protocol_default_get_parameters;
  qword_1EA8428F8 = nw_protocol_default_get_local;
  qword_1EA842900 = nw_protocol_default_get_remote;
  qword_1EA8428F0 = nw_protocol_default_get_path;
  qword_1EA842940 = nw_protocol_default_get_output_local;
  qword_1EA842948 = nw_protocol_default_get_output_interface;
  qword_1EA842978 = nw_protocol_default_reset;
  qword_1EA842950 = nw_protocol_default_waiting_for_output;
  qword_1EA842908 = nw_protocol_default_register_notification;
  qword_1EA842910 = nw_protocol_default_unregister_notification;
  qword_1EA842918 = nw_protocol_default_notify;
  qword_1EA842960 = nw_protocol_default_add_listen_handler;
  qword_1EA842968 = nw_protocol_default_remove_listen_handler;
  g_swift_wrapper_protocol_callbacks = nw_protocol_swift_wrapper_add_input_handler;
  qword_1EA842880 = nw_protocol_swift_wrapper_remove_input_handler;
  qword_1EA8428C8 = nw_protocol_swift_wrapper_get_input_frames;
  qword_1EA8428D0 = nw_protocol_swift_wrapper_get_output_frames;
  qword_1EA8428D8 = nw_protocol_swift_wrapper_finalize_output_frames;
  qword_1EA8428B8 = nw_protocol_swift_wrapper_input_available;
  qword_1EA842980 = nw_protocol_swift_wrapper_input_flush;
  qword_1EA8428C0 = nw_protocol_swift_wrapper_output_available;
  qword_1EA8428A0 = nw_protocol_swift_wrapper_connected;
  qword_1EA8428A8 = nw_protocol_swift_wrapper_disconnected;
  qword_1EA842890 = nw_protocol_swift_wrapper_connect;
  qword_1EA842898 = nw_protocol_swift_wrapper_disconnect;
  qword_1EA8428B0 = nw_protocol_swift_wrapper_error;
  qword_1EA842928 = nw_protocol_swift_wrapper_supports_external_data;
  qword_1EA842920 = nw_protocol_swift_wrapper_updated_path;
  qword_1EA8428E0 = nw_protocol_swift_wrapper_link_state;
  qword_1EA842970 = nw_protocol_swift_wrapper_get_message_properties;
  qword_1EA842958 = nw_protocol_swift_wrapper_copy_info;
}

uint64_t nw_protocol_swift_wrapper_copy_info(uint64_t a1)
{
  v22 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v1 = *(a1 + 40);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = gLogObj;
    v3 = v2;
    if (v1 == &nw_protocol_ref_counted_additional_handle || v1 == &nw_protocol_ref_counted_handle)
    {
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_copy_info";
        _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_ERROR, "%{public}s Swift copy info not implemented yet", buf, 0xCu);
      }

      return 0;
    }

    *buf = 136446210;
    v19 = "nw_protocol_swift_wrapper_copy_info";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v10, &type, &v16))
    {
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_copy_info";
        v9 = "%{public}s called with null wrapper";
        goto LABEL_38;
      }
    }

    else
    {
      if (v16 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v8 = type;
        v15 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *buf = 136446466;
            v19 = "nw_protocol_swift_wrapper_copy_info";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (v10)
          {
            goto LABEL_41;
          }

          return 0;
        }

        if (!v15)
        {
          goto LABEL_39;
        }

        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_copy_info";
        v9 = "%{public}s called with null wrapper, no backtrace";
        goto LABEL_38;
      }

      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_copy_info";
        v9 = "%{public}s called with null wrapper, backtrace limit exceeded";
        goto LABEL_38;
      }
    }

    goto LABEL_39;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v19 = "nw_protocol_swift_wrapper_copy_info";
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v10, &type, &v16))
  {
    goto LABEL_40;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v19 = "nw_protocol_swift_wrapper_copy_info";
      v9 = "%{public}s called with null protocol";
LABEL_38:
      _os_log_impl(&dword_181A37000, v7, v8, v9, buf, 0xCu);
    }

LABEL_39:

    goto LABEL_40;
  }

  if (v16 != 1)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v19 = "nw_protocol_swift_wrapper_copy_info";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_38;
    }

    goto LABEL_39;
  }

  v12 = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v13 = os_log_type_enabled(v7, type);
  if (!v12)
  {
    if (v13)
    {
      *buf = 136446210;
      v19 = "nw_protocol_swift_wrapper_copy_info";
      v9 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_38;
    }

    goto LABEL_39;
  }

  if (v13)
  {
    *buf = 136446466;
    v19 = "nw_protocol_swift_wrapper_copy_info";
    v20 = 2082;
    v21 = v12;
    _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v12);
LABEL_40:
  if (v10)
  {
LABEL_41:
    free(v10);
  }

  return 0;
}

void nw_protocol_swift_wrapper_get_message_properties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v27 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v14 = __nwlog_obj();
    *buf = 136446210;
    v24 = "nw_protocol_swift_wrapper_get_message_properties";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v6, &type, &v21))
    {
      goto LABEL_20;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *buf = 136446210;
        v24 = "nw_protocol_swift_wrapper_get_message_properties";
        v17 = "%{public}s called with null protocol";
LABEL_44:
        _os_log_impl(&dword_181A37000, v15, v16, v17, buf, 0xCu);
      }
    }

    else if (v21 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v16 = type;
      v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *buf = 136446466;
          v24 = "nw_protocol_swift_wrapper_get_message_properties";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_181A37000, v15, v16, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (v6)
        {
          goto LABEL_21;
        }

        return;
      }

      if (v19)
      {
        *buf = 136446210;
        v24 = "nw_protocol_swift_wrapper_get_message_properties";
        v17 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_44;
      }
    }

    else
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *buf = 136446210;
        v24 = "nw_protocol_swift_wrapper_get_message_properties";
        v17 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_44;
      }
    }

    goto LABEL_20;
  }

  v4 = *(a1 + 40);
  if (v4 != &nw_protocol_ref_counted_handle)
  {
    if (v4 != &nw_protocol_ref_counted_additional_handle)
    {
      v5 = __nwlog_obj();
      *buf = 136446210;
      v24 = "nw_protocol_swift_wrapper_get_message_properties";
      v6 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v21 = 0;
      if (__nwlog_fault(v6, &type, &v21))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v7 = __nwlog_obj();
          v8 = type;
          if (!os_log_type_enabled(v7, type))
          {
            goto LABEL_28;
          }

          *buf = 136446210;
          v24 = "nw_protocol_swift_wrapper_get_message_properties";
          v9 = "%{public}s called with null wrapper";
          goto LABEL_27;
        }

        if (v21 != 1)
        {
          v7 = __nwlog_obj();
          v8 = type;
          if (!os_log_type_enabled(v7, type))
          {
            goto LABEL_28;
          }

          *buf = 136446210;
          v24 = "nw_protocol_swift_wrapper_get_message_properties";
          v9 = "%{public}s called with null wrapper, backtrace limit exceeded";
          goto LABEL_27;
        }

        v12 = __nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v8 = type;
        v13 = os_log_type_enabled(v7, type);
        if (!v12)
        {
          if (!v13)
          {
            goto LABEL_28;
          }

          *buf = 136446210;
          v24 = "nw_protocol_swift_wrapper_get_message_properties";
          v9 = "%{public}s called with null wrapper, no backtrace";
LABEL_27:
          _os_log_impl(&dword_181A37000, v7, v8, v9, buf, 0xCu);
LABEL_28:

          if (!v6)
          {
            return;
          }

LABEL_21:
          free(v6);
          return;
        }

        if (v13)
        {
          *buf = 136446466;
          v24 = "nw_protocol_swift_wrapper_get_message_properties";
          v25 = 2082;
          v26 = v12;
          _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v12);
      }

LABEL_20:
      if (!v6)
      {
        return;
      }

      goto LABEL_21;
    }

    a1 = *(a1 + 64);
  }

  v10 = a1;
  input_linkage = nw_protocol_swift_wrapper_get_input_linkage(a1 + 96, a2);
  if (*(v10 + 96) && input_linkage)
  {
    v20 = input_linkage;
    _nw_protocol_swift_wrapper_get_message_properties(input_linkage, a3);
    input_linkage = v20;
  }
}

id nw_protocol_swift_wrapper_get_input_linkage(uint64_t a1, uint64_t a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = *(a1 + 8);
  if (!v3)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v17 = "nw_protocol_swift_wrapper_get_input_linkage";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v8, &type, &v14))
    {
      goto LABEL_25;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v17 = "nw_protocol_swift_wrapper_get_input_linkage";
        v11 = "%{public}s called with null wrapper->input_linkages";
LABEL_23:
        _os_log_impl(&dword_181A37000, v9, v10, v11, buf, 0xCu);
      }
    }

    else
    {
      if (v14 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v9 = __nwlog_obj();
        v10 = type;
        v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *buf = 136446466;
            v17 = "nw_protocol_swift_wrapper_get_input_linkage";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null wrapper->input_linkages, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (!v13)
        {
          goto LABEL_24;
        }

        *buf = 136446210;
        v17 = "nw_protocol_swift_wrapper_get_input_linkage";
        v11 = "%{public}s called with null wrapper->input_linkages, no backtrace";
        goto LABEL_23;
      }

      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v17 = "nw_protocol_swift_wrapper_get_input_linkage";
        v11 = "%{public}s called with null wrapper->input_linkages, backtrace limit exceeded";
        goto LABEL_23;
      }
    }

LABEL_24:

LABEL_25:
    if (v8)
    {
      free(v8);
    }

    return 0;
  }

  if (*(a1 + 24))
  {
    if (!a2)
    {
      return 0;
    }

    node = nw_hash_table_get_node(v3, a2, 8);
    if (!node)
    {
      return 0;
    }
  }

  else
  {
    node = nw_hash_table_get_some_node(v3);
    if (!node)
    {
      return 0;
    }
  }

  v5 = *(node + 32);

  return v5;
}

void nw_protocol_swift_wrapper_link_state(uint64_t a1, uint64_t a2, void *a3)
{
  v25 = *MEMORY[0x1E69E9840];
  v4 = a3;
  if (a1)
  {
    v5 = *(a1 + 40);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    v7 = v6;
    if (v5 == &nw_protocol_ref_counted_additional_handle || v5 == &nw_protocol_ref_counted_handle)
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446210;
        v22 = "nw_protocol_swift_wrapper_link_state";
        _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_ERROR, "%{public}s Swift link state not implemented yet", buf, 0xCu);
      }

      goto LABEL_10;
    }

    *buf = 136446210;
    v22 = "nw_protocol_swift_wrapper_link_state";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v13, &type, &v19))
    {
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v22 = "nw_protocol_swift_wrapper_link_state";
        v12 = "%{public}s called with null wrapper";
        goto LABEL_38;
      }
    }

    else
    {
      if (v19 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v10 = __nwlog_obj();
        v11 = type;
        v18 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *buf = 136446466;
            v22 = "nw_protocol_swift_wrapper_link_state";
            v23 = 2082;
            v24 = backtrace_string;
            _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (v13)
          {
            goto LABEL_41;
          }

          goto LABEL_10;
        }

        if (!v18)
        {
          goto LABEL_39;
        }

        *buf = 136446210;
        v22 = "nw_protocol_swift_wrapper_link_state";
        v12 = "%{public}s called with null wrapper, no backtrace";
        goto LABEL_38;
      }

      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v22 = "nw_protocol_swift_wrapper_link_state";
        v12 = "%{public}s called with null wrapper, backtrace limit exceeded";
        goto LABEL_38;
      }
    }

    goto LABEL_39;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v22 = "nw_protocol_swift_wrapper_link_state";
  v13 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v13, &type, &v19))
  {
    goto LABEL_40;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v10 = __nwlog_obj();
    v11 = type;
    if (os_log_type_enabled(v10, type))
    {
      *buf = 136446210;
      v22 = "nw_protocol_swift_wrapper_link_state";
      v12 = "%{public}s called with null protocol";
LABEL_38:
      _os_log_impl(&dword_181A37000, v10, v11, v12, buf, 0xCu);
    }

LABEL_39:

    goto LABEL_40;
  }

  if (v19 != 1)
  {
    v10 = __nwlog_obj();
    v11 = type;
    if (os_log_type_enabled(v10, type))
    {
      *buf = 136446210;
      v22 = "nw_protocol_swift_wrapper_link_state";
      v12 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_38;
    }

    goto LABEL_39;
  }

  v15 = __nw_create_backtrace_string();
  v10 = __nwlog_obj();
  v11 = type;
  v16 = os_log_type_enabled(v10, type);
  if (!v15)
  {
    if (v16)
    {
      *buf = 136446210;
      v22 = "nw_protocol_swift_wrapper_link_state";
      v12 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_38;
    }

    goto LABEL_39;
  }

  if (v16)
  {
    *buf = 136446466;
    v22 = "nw_protocol_swift_wrapper_link_state";
    v23 = 2082;
    v24 = v15;
    _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
LABEL_40:
  if (v13)
  {
LABEL_41:
    free(v13);
  }

LABEL_10:
}

uint64_t nw_protocol_swift_wrapper_updated_path(uint64_t a1, uint64_t a2, void *a3)
{
  v26 = *MEMORY[0x1E69E9840];
  v4 = a3;
  if (a1)
  {
    v5 = *(a1 + 40);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    v7 = v6;
    if (v5 == &nw_protocol_ref_counted_additional_handle || v5 == &nw_protocol_ref_counted_handle)
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446210;
        v23 = "nw_protocol_swift_wrapper_updated_path";
        _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_ERROR, "%{public}s Swift updated path not implemented yet", buf, 0xCu);
      }

      goto LABEL_10;
    }

    *buf = 136446210;
    v23 = "nw_protocol_swift_wrapper_updated_path";
    v14 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v14, &type, &v20))
    {
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v23 = "nw_protocol_swift_wrapper_updated_path";
        v13 = "%{public}s called with null wrapper";
        goto LABEL_38;
      }
    }

    else
    {
      if (v20 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v11 = __nwlog_obj();
        v12 = type;
        v19 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *buf = 136446466;
            v23 = "nw_protocol_swift_wrapper_updated_path";
            v24 = 2082;
            v25 = backtrace_string;
            _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (v14)
          {
            goto LABEL_41;
          }

          goto LABEL_10;
        }

        if (!v19)
        {
          goto LABEL_39;
        }

        *buf = 136446210;
        v23 = "nw_protocol_swift_wrapper_updated_path";
        v13 = "%{public}s called with null wrapper, no backtrace";
        goto LABEL_38;
      }

      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v23 = "nw_protocol_swift_wrapper_updated_path";
        v13 = "%{public}s called with null wrapper, backtrace limit exceeded";
        goto LABEL_38;
      }
    }

    goto LABEL_39;
  }

  v10 = __nwlog_obj();
  *buf = 136446210;
  v23 = "nw_protocol_swift_wrapper_updated_path";
  v14 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v14, &type, &v20))
  {
    goto LABEL_40;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v11 = __nwlog_obj();
    v12 = type;
    if (os_log_type_enabled(v11, type))
    {
      *buf = 136446210;
      v23 = "nw_protocol_swift_wrapper_updated_path";
      v13 = "%{public}s called with null protocol";
LABEL_38:
      _os_log_impl(&dword_181A37000, v11, v12, v13, buf, 0xCu);
    }

LABEL_39:

    goto LABEL_40;
  }

  if (v20 != 1)
  {
    v11 = __nwlog_obj();
    v12 = type;
    if (os_log_type_enabled(v11, type))
    {
      *buf = 136446210;
      v23 = "nw_protocol_swift_wrapper_updated_path";
      v13 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_38;
    }

    goto LABEL_39;
  }

  v16 = __nw_create_backtrace_string();
  v11 = __nwlog_obj();
  v12 = type;
  v17 = os_log_type_enabled(v11, type);
  if (!v16)
  {
    if (v17)
    {
      *buf = 136446210;
      v23 = "nw_protocol_swift_wrapper_updated_path";
      v13 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_38;
    }

    goto LABEL_39;
  }

  if (v17)
  {
    *buf = 136446466;
    v23 = "nw_protocol_swift_wrapper_updated_path";
    v24 = 2082;
    v25 = v16;
    _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
LABEL_40:
  if (v14)
  {
LABEL_41:
    free(v14);
  }

LABEL_10:

  return 0;
}

uint64_t nw_protocol_swift_wrapper_supports_external_data(uint64_t a1)
{
  v21 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v4 = __nwlog_obj();
    *buf = 136446210;
    v18 = "nw_protocol_swift_wrapper_supports_external_data";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v11, &type, &v15))
    {
      goto LABEL_37;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v18 = "nw_protocol_swift_wrapper_supports_external_data";
        v7 = "%{public}s called with null protocol";
LABEL_35:
        _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0xCu);
      }
    }

    else
    {
      if (v15 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v5 = __nwlog_obj();
        v6 = type;
        v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *buf = 136446466;
            v18 = "nw_protocol_swift_wrapper_supports_external_data";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (v11)
          {
            goto LABEL_38;
          }

          return 0;
        }

        if (!v9)
        {
          goto LABEL_36;
        }

        *buf = 136446210;
        v18 = "nw_protocol_swift_wrapper_supports_external_data";
        v7 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_35;
      }

      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v18 = "nw_protocol_swift_wrapper_supports_external_data";
        v7 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_35;
      }
    }

LABEL_36:

    goto LABEL_37;
  }

  v1 = *(a1 + 40);
  if (v1 == &nw_protocol_ref_counted_handle || v1 == &nw_protocol_ref_counted_additional_handle)
  {
    return 0;
  }

  v10 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_protocol_swift_wrapper_supports_external_data";
  v11 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v11, &type, &v15))
  {
    goto LABEL_37;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (os_log_type_enabled(v5, type))
    {
      *buf = 136446210;
      v18 = "nw_protocol_swift_wrapper_supports_external_data";
      v7 = "%{public}s called with null wrapper";
      goto LABEL_35;
    }

    goto LABEL_36;
  }

  if (v15 != 1)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (os_log_type_enabled(v5, type))
    {
      *buf = 136446210;
      v18 = "nw_protocol_swift_wrapper_supports_external_data";
      v7 = "%{public}s called with null wrapper, backtrace limit exceeded";
      goto LABEL_35;
    }

    goto LABEL_36;
  }

  v13 = __nw_create_backtrace_string();
  v5 = __nwlog_obj();
  v6 = type;
  v14 = os_log_type_enabled(v5, type);
  if (!v13)
  {
    if (v14)
    {
      *buf = 136446210;
      v18 = "nw_protocol_swift_wrapper_supports_external_data";
      v7 = "%{public}s called with null wrapper, no backtrace";
      goto LABEL_35;
    }

    goto LABEL_36;
  }

  if (v14)
  {
    *buf = 136446466;
    v18 = "nw_protocol_swift_wrapper_supports_external_data";
    v19 = 2082;
    v20 = v13;
    _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v13);
LABEL_37:
  if (v11)
  {
LABEL_38:
    free(v11);
  }

  return 0;
}

void nw_protocol_swift_wrapper_error(void *a1)
{
  v21 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v9 = __nwlog_obj();
    *buf = 136446210;
    v18 = "nw_protocol_swift_wrapper_error";
    v3 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v3, &type, &v15))
    {
      goto LABEL_19;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v18 = "nw_protocol_swift_wrapper_error";
        v12 = "%{public}s called with null protocol";
LABEL_43:
        _os_log_impl(&dword_181A37000, v10, v11, v12, buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v11 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v18 = "nw_protocol_swift_wrapper_error";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (v3)
        {
          goto LABEL_20;
        }

        return;
      }

      if (v14)
      {
        *buf = 136446210;
        v18 = "nw_protocol_swift_wrapper_error";
        v12 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_43;
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v18 = "nw_protocol_swift_wrapper_error";
        v12 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_43;
      }
    }

    goto LABEL_19;
  }

  v1 = a1[5];
  if (v1 != &nw_protocol_ref_counted_handle)
  {
    if (v1 != &nw_protocol_ref_counted_additional_handle)
    {
      v2 = __nwlog_obj();
      *buf = 136446210;
      v18 = "nw_protocol_swift_wrapper_error";
      v3 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v15 = 0;
      if (__nwlog_fault(v3, &type, &v15))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v4 = __nwlog_obj();
          v5 = type;
          if (!os_log_type_enabled(v4, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v18 = "nw_protocol_swift_wrapper_error";
          v6 = "%{public}s called with null wrapper";
          goto LABEL_26;
        }

        if (v15 != 1)
        {
          v4 = __nwlog_obj();
          v5 = type;
          if (!os_log_type_enabled(v4, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v18 = "nw_protocol_swift_wrapper_error";
          v6 = "%{public}s called with null wrapper, backtrace limit exceeded";
          goto LABEL_26;
        }

        v7 = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (!v7)
        {
          if (!v8)
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v18 = "nw_protocol_swift_wrapper_error";
          v6 = "%{public}s called with null wrapper, no backtrace";
LABEL_26:
          _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
LABEL_27:

          if (!v3)
          {
            return;
          }

LABEL_20:
          free(v3);
          return;
        }

        if (v8)
        {
          *buf = 136446466;
          v18 = "nw_protocol_swift_wrapper_error";
          v19 = 2082;
          v20 = v7;
          _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v7);
      }

LABEL_19:
      if (!v3)
      {
        return;
      }

      goto LABEL_20;
    }

    a1 = a1[8];
  }

  if (a1[12] && a1[14])
  {

    _nw_protocol_swift_wrapper_error();
  }
}

void nw_protocol_swift_wrapper_disconnect(uint64_t a1, uint64_t a2)
{
  v26 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v13 = __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_protocol_swift_wrapper_disconnect";
    v5 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v5, &type, &v20))
    {
      goto LABEL_20;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v23 = "nw_protocol_swift_wrapper_disconnect";
        v16 = "%{public}s called with null protocol";
LABEL_44:
        _os_log_impl(&dword_181A37000, v14, v15, v16, buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *buf = 136446466;
          v23 = "nw_protocol_swift_wrapper_disconnect";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (v5)
        {
          goto LABEL_21;
        }

        return;
      }

      if (v18)
      {
        *buf = 136446210;
        v23 = "nw_protocol_swift_wrapper_disconnect";
        v16 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_44;
      }
    }

    else
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v23 = "nw_protocol_swift_wrapper_disconnect";
        v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_44;
      }
    }

    goto LABEL_20;
  }

  v2 = a1;
  v3 = *(a1 + 40);
  if (v3 != &nw_protocol_ref_counted_handle)
  {
    if (v3 != &nw_protocol_ref_counted_additional_handle)
    {
      v4 = __nwlog_obj();
      *buf = 136446210;
      v23 = "nw_protocol_swift_wrapper_disconnect";
      v5 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v20 = 0;
      if (__nwlog_fault(v5, &type, &v20))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v6 = __nwlog_obj();
          v7 = type;
          if (!os_log_type_enabled(v6, type))
          {
            goto LABEL_28;
          }

          *buf = 136446210;
          v23 = "nw_protocol_swift_wrapper_disconnect";
          v8 = "%{public}s called with null wrapper";
          goto LABEL_27;
        }

        if (v20 != 1)
        {
          v6 = __nwlog_obj();
          v7 = type;
          if (!os_log_type_enabled(v6, type))
          {
            goto LABEL_28;
          }

          *buf = 136446210;
          v23 = "nw_protocol_swift_wrapper_disconnect";
          v8 = "%{public}s called with null wrapper, backtrace limit exceeded";
          goto LABEL_27;
        }

        v11 = __nw_create_backtrace_string();
        v6 = __nwlog_obj();
        v7 = type;
        v12 = os_log_type_enabled(v6, type);
        if (!v11)
        {
          if (!v12)
          {
            goto LABEL_28;
          }

          *buf = 136446210;
          v23 = "nw_protocol_swift_wrapper_disconnect";
          v8 = "%{public}s called with null wrapper, no backtrace";
LABEL_27:
          _os_log_impl(&dword_181A37000, v6, v7, v8, buf, 0xCu);
LABEL_28:

          if (!v5)
          {
            return;
          }

LABEL_21:
          free(v5);
          return;
        }

        if (v12)
        {
          *buf = 136446466;
          v23 = "nw_protocol_swift_wrapper_disconnect";
          v24 = 2082;
          v25 = v11;
          _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v11);
      }

LABEL_20:
      if (!v5)
      {
        return;
      }

      goto LABEL_21;
    }

    v2 = *(a1 + 64);
  }

  input_linkage = nw_protocol_swift_wrapper_get_input_linkage(v2 + 96, a2);
  if (a2 && *(v2 + 96))
  {
    v19 = input_linkage;
    _nw_protocol_swift_wrapper_disconnect(input_linkage);
    input_linkage = v19;
  }
}

uint64_t nw_protocol_swift_wrapper_connect(uint64_t a1, uint64_t a2)
{
  v27 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v15 = __nwlog_obj();
    *buf = 136446210;
    v24 = "nw_protocol_swift_wrapper_connect";
    v4 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v4, &type, &v21))
    {
      goto LABEL_18;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136446210;
        v24 = "nw_protocol_swift_wrapper_connect";
        v18 = "%{public}s called with null protocol";
LABEL_43:
        _os_log_impl(&dword_181A37000, v16, v17, v18, buf, 0xCu);
      }
    }

    else
    {
      if (v21 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v16 = __nwlog_obj();
        v17 = type;
        v20 = os_log_type_enabled(v16, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *buf = 136446466;
            v24 = "nw_protocol_swift_wrapper_connect";
            v25 = 2082;
            v26 = backtrace_string;
            _os_log_impl(&dword_181A37000, v16, v17, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v4)
          {
            return 0;
          }

          goto LABEL_19;
        }

        if (!v20)
        {
          goto LABEL_44;
        }

        *buf = 136446210;
        v24 = "nw_protocol_swift_wrapper_connect";
        v18 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_43;
      }

      v16 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136446210;
        v24 = "nw_protocol_swift_wrapper_connect";
        v18 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_43;
      }
    }

LABEL_44:

LABEL_18:
    if (!v4)
    {
      return 0;
    }

LABEL_19:
    free(v4);
    return 0;
  }

  v2 = *(a1 + 40);
  if (v2 != &nw_protocol_ref_counted_handle)
  {
    if (v2 != &nw_protocol_ref_counted_additional_handle)
    {
      v3 = __nwlog_obj();
      *buf = 136446210;
      v24 = "nw_protocol_swift_wrapper_connect";
      v4 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v21 = 0;
      if (__nwlog_fault(v4, &type, &v21))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v5 = __nwlog_obj();
          v6 = type;
          if (!os_log_type_enabled(v5, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v24 = "nw_protocol_swift_wrapper_connect";
          v7 = "%{public}s called with null wrapper";
          goto LABEL_26;
        }

        if (v21 != 1)
        {
          v5 = __nwlog_obj();
          v6 = type;
          if (!os_log_type_enabled(v5, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v24 = "nw_protocol_swift_wrapper_connect";
          v7 = "%{public}s called with null wrapper, backtrace limit exceeded";
          goto LABEL_26;
        }

        v12 = __nw_create_backtrace_string();
        v5 = __nwlog_obj();
        v6 = type;
        v13 = os_log_type_enabled(v5, type);
        if (!v12)
        {
          if (!v13)
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v24 = "nw_protocol_swift_wrapper_connect";
          v7 = "%{public}s called with null wrapper, no backtrace";
LABEL_26:
          _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0xCu);
LABEL_27:

          if (!v4)
          {
            return 0;
          }

          goto LABEL_19;
        }

        if (v13)
        {
          *buf = 136446466;
          v24 = "nw_protocol_swift_wrapper_connect";
          v25 = 2082;
          v26 = v12;
          _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v12);
      }

      goto LABEL_18;
    }

    a1 = *(a1 + 64);
  }

  v8 = a1;
  input_linkage = nw_protocol_swift_wrapper_get_input_linkage(a1 + 96, a2);
  v10 = input_linkage;
  v11 = 0;
  if (*(v8 + 96) && input_linkage)
  {
    v11 = _nw_protocol_swift_wrapper_connect(input_linkage);
  }

  return v11;
}

void nw_protocol_swift_wrapper_disconnected(void *a1)
{
  v22 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v10 = __nwlog_obj();
    *buf = 136446210;
    v19 = "nw_protocol_swift_wrapper_disconnected";
    v3 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v3, &type, &v16))
    {
      goto LABEL_19;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_disconnected";
        v13 = "%{public}s called with null protocol";
LABEL_43:
        _os_log_impl(&dword_181A37000, v11, v12, v13, buf, 0xCu);
      }
    }

    else if (v16 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v19 = "nw_protocol_swift_wrapper_disconnected";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (v3)
        {
          goto LABEL_20;
        }

        return;
      }

      if (v15)
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_disconnected";
        v13 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_43;
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_disconnected";
        v13 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_43;
      }
    }

    goto LABEL_19;
  }

  v1 = a1[5];
  if (v1 != &nw_protocol_ref_counted_handle)
  {
    if (v1 != &nw_protocol_ref_counted_additional_handle)
    {
      v2 = __nwlog_obj();
      *buf = 136446210;
      v19 = "nw_protocol_swift_wrapper_disconnected";
      v3 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v16 = 0;
      if (__nwlog_fault(v3, &type, &v16))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v4 = __nwlog_obj();
          v5 = type;
          if (!os_log_type_enabled(v4, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_disconnected";
          v6 = "%{public}s called with null wrapper";
          goto LABEL_26;
        }

        if (v16 != 1)
        {
          v4 = __nwlog_obj();
          v5 = type;
          if (!os_log_type_enabled(v4, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_disconnected";
          v6 = "%{public}s called with null wrapper, backtrace limit exceeded";
          goto LABEL_26;
        }

        v8 = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v9 = os_log_type_enabled(v4, type);
        if (!v8)
        {
          if (!v9)
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_disconnected";
          v6 = "%{public}s called with null wrapper, no backtrace";
LABEL_26:
          _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
LABEL_27:

          if (!v3)
          {
            return;
          }

LABEL_20:
          free(v3);
          return;
        }

        if (v9)
        {
          *buf = 136446466;
          v19 = "nw_protocol_swift_wrapper_disconnected";
          v20 = 2082;
          v21 = v8;
          _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v8);
      }

LABEL_19:
      if (!v3)
      {
        return;
      }

      goto LABEL_20;
    }

    a1 = a1[8];
  }

  if (a1[12])
  {
    v7 = a1[14];
    if (v7)
    {

      _nw_protocol_swift_wrapper_disconnected(v7);
    }
  }
}

void nw_protocol_swift_wrapper_connected(void *a1)
{
  v22 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v10 = __nwlog_obj();
    *buf = 136446210;
    v19 = "nw_protocol_swift_wrapper_connected";
    v3 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v3, &type, &v16))
    {
      goto LABEL_19;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_connected";
        v13 = "%{public}s called with null protocol";
LABEL_43:
        _os_log_impl(&dword_181A37000, v11, v12, v13, buf, 0xCu);
      }
    }

    else if (v16 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v19 = "nw_protocol_swift_wrapper_connected";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (v3)
        {
          goto LABEL_20;
        }

        return;
      }

      if (v15)
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_connected";
        v13 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_43;
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_connected";
        v13 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_43;
      }
    }

    goto LABEL_19;
  }

  v1 = a1[5];
  if (v1 != &nw_protocol_ref_counted_handle)
  {
    if (v1 != &nw_protocol_ref_counted_additional_handle)
    {
      v2 = __nwlog_obj();
      *buf = 136446210;
      v19 = "nw_protocol_swift_wrapper_connected";
      v3 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v16 = 0;
      if (__nwlog_fault(v3, &type, &v16))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v4 = __nwlog_obj();
          v5 = type;
          if (!os_log_type_enabled(v4, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_connected";
          v6 = "%{public}s called with null wrapper";
          goto LABEL_26;
        }

        if (v16 != 1)
        {
          v4 = __nwlog_obj();
          v5 = type;
          if (!os_log_type_enabled(v4, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_connected";
          v6 = "%{public}s called with null wrapper, backtrace limit exceeded";
          goto LABEL_26;
        }

        v8 = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v9 = os_log_type_enabled(v4, type);
        if (!v8)
        {
          if (!v9)
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_connected";
          v6 = "%{public}s called with null wrapper, no backtrace";
LABEL_26:
          _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
LABEL_27:

          if (!v3)
          {
            return;
          }

LABEL_20:
          free(v3);
          return;
        }

        if (v9)
        {
          *buf = 136446466;
          v19 = "nw_protocol_swift_wrapper_connected";
          v20 = 2082;
          v21 = v8;
          _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v8);
      }

LABEL_19:
      if (!v3)
      {
        return;
      }

      goto LABEL_20;
    }

    a1 = a1[8];
  }

  if (a1[12])
  {
    v7 = a1[14];
    if (v7)
    {

      _nw_protocol_swift_wrapper_connected(v7);
    }
  }
}

void nw_protocol_swift_wrapper_output_available(void *a1)
{
  v22 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v10 = __nwlog_obj();
    *buf = 136446210;
    v19 = "nw_protocol_swift_wrapper_output_available";
    v3 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v3, &type, &v16))
    {
      goto LABEL_19;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_output_available";
        v13 = "%{public}s called with null protocol";
LABEL_43:
        _os_log_impl(&dword_181A37000, v11, v12, v13, buf, 0xCu);
      }
    }

    else if (v16 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v19 = "nw_protocol_swift_wrapper_output_available";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (v3)
        {
          goto LABEL_20;
        }

        return;
      }

      if (v15)
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_output_available";
        v13 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_43;
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_output_available";
        v13 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_43;
      }
    }

    goto LABEL_19;
  }

  v1 = a1[5];
  if (v1 != &nw_protocol_ref_counted_handle)
  {
    if (v1 != &nw_protocol_ref_counted_additional_handle)
    {
      v2 = __nwlog_obj();
      *buf = 136446210;
      v19 = "nw_protocol_swift_wrapper_output_available";
      v3 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v16 = 0;
      if (__nwlog_fault(v3, &type, &v16))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v4 = __nwlog_obj();
          v5 = type;
          if (!os_log_type_enabled(v4, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_output_available";
          v6 = "%{public}s called with null wrapper";
          goto LABEL_26;
        }

        if (v16 != 1)
        {
          v4 = __nwlog_obj();
          v5 = type;
          if (!os_log_type_enabled(v4, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_output_available";
          v6 = "%{public}s called with null wrapper, backtrace limit exceeded";
          goto LABEL_26;
        }

        v8 = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v9 = os_log_type_enabled(v4, type);
        if (!v8)
        {
          if (!v9)
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_output_available";
          v6 = "%{public}s called with null wrapper, no backtrace";
LABEL_26:
          _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
LABEL_27:

          if (!v3)
          {
            return;
          }

LABEL_20:
          free(v3);
          return;
        }

        if (v9)
        {
          *buf = 136446466;
          v19 = "nw_protocol_swift_wrapper_output_available";
          v20 = 2082;
          v21 = v8;
          _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v8);
      }

LABEL_19:
      if (!v3)
      {
        return;
      }

      goto LABEL_20;
    }

    a1 = a1[8];
  }

  if (a1[12])
  {
    v7 = a1[14];
    if (v7)
    {

      _nw_protocol_swift_wrapper_output_available(v7);
    }
  }
}

void nw_protocol_swift_wrapper_input_flush(void *a1)
{
  v22 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v10 = __nwlog_obj();
    *buf = 136446210;
    v19 = "nw_protocol_swift_wrapper_input_flush";
    v3 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v3, &type, &v16))
    {
      goto LABEL_19;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_input_flush";
        v13 = "%{public}s called with null protocol";
LABEL_43:
        _os_log_impl(&dword_181A37000, v11, v12, v13, buf, 0xCu);
      }
    }

    else if (v16 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v19 = "nw_protocol_swift_wrapper_input_flush";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (v3)
        {
          goto LABEL_20;
        }

        return;
      }

      if (v15)
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_input_flush";
        v13 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_43;
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_input_flush";
        v13 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_43;
      }
    }

    goto LABEL_19;
  }

  v1 = a1[5];
  if (v1 != &nw_protocol_ref_counted_handle)
  {
    if (v1 != &nw_protocol_ref_counted_additional_handle)
    {
      v2 = __nwlog_obj();
      *buf = 136446210;
      v19 = "nw_protocol_swift_wrapper_input_flush";
      v3 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v16 = 0;
      if (__nwlog_fault(v3, &type, &v16))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v4 = __nwlog_obj();
          v5 = type;
          if (!os_log_type_enabled(v4, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_input_flush";
          v6 = "%{public}s called with null wrapper";
          goto LABEL_26;
        }

        if (v16 != 1)
        {
          v4 = __nwlog_obj();
          v5 = type;
          if (!os_log_type_enabled(v4, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_input_flush";
          v6 = "%{public}s called with null wrapper, backtrace limit exceeded";
          goto LABEL_26;
        }

        v8 = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v9 = os_log_type_enabled(v4, type);
        if (!v8)
        {
          if (!v9)
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_input_flush";
          v6 = "%{public}s called with null wrapper, no backtrace";
LABEL_26:
          _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
LABEL_27:

          if (!v3)
          {
            return;
          }

LABEL_20:
          free(v3);
          return;
        }

        if (v9)
        {
          *buf = 136446466;
          v19 = "nw_protocol_swift_wrapper_input_flush";
          v20 = 2082;
          v21 = v8;
          _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v8);
      }

LABEL_19:
      if (!v3)
      {
        return;
      }

      goto LABEL_20;
    }

    a1 = a1[8];
  }

  if (a1[12])
  {
    v7 = a1[14];
    if (v7)
    {

      _nw_protocol_swift_wrapper_input_flush(v7);
    }
  }
}

void nw_protocol_swift_wrapper_input_available(void *a1)
{
  v22 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v10 = __nwlog_obj();
    *buf = 136446210;
    v19 = "nw_protocol_swift_wrapper_input_available";
    v3 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v3, &type, &v16))
    {
      goto LABEL_19;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_input_available";
        v13 = "%{public}s called with null protocol";
LABEL_43:
        _os_log_impl(&dword_181A37000, v11, v12, v13, buf, 0xCu);
      }
    }

    else if (v16 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v19 = "nw_protocol_swift_wrapper_input_available";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (v3)
        {
          goto LABEL_20;
        }

        return;
      }

      if (v15)
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_input_available";
        v13 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_43;
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_swift_wrapper_input_available";
        v13 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_43;
      }
    }

    goto LABEL_19;
  }

  v1 = a1[5];
  if (v1 != &nw_protocol_ref_counted_handle)
  {
    if (v1 != &nw_protocol_ref_counted_additional_handle)
    {
      v2 = __nwlog_obj();
      *buf = 136446210;
      v19 = "nw_protocol_swift_wrapper_input_available";
      v3 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v16 = 0;
      if (__nwlog_fault(v3, &type, &v16))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v4 = __nwlog_obj();
          v5 = type;
          if (!os_log_type_enabled(v4, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_input_available";
          v6 = "%{public}s called with null wrapper";
          goto LABEL_26;
        }

        if (v16 != 1)
        {
          v4 = __nwlog_obj();
          v5 = type;
          if (!os_log_type_enabled(v4, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_input_available";
          v6 = "%{public}s called with null wrapper, backtrace limit exceeded";
          goto LABEL_26;
        }

        v8 = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v9 = os_log_type_enabled(v4, type);
        if (!v8)
        {
          if (!v9)
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v19 = "nw_protocol_swift_wrapper_input_available";
          v6 = "%{public}s called with null wrapper, no backtrace";
LABEL_26:
          _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
LABEL_27:

          if (!v3)
          {
            return;
          }

LABEL_20:
          free(v3);
          return;
        }

        if (v9)
        {
          *buf = 136446466;
          v19 = "nw_protocol_swift_wrapper_input_available";
          v20 = 2082;
          v21 = v8;
          _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v8);
      }

LABEL_19:
      if (!v3)
      {
        return;
      }

      goto LABEL_20;
    }

    a1 = a1[8];
  }

  if (a1[12])
  {
    v7 = a1[14];
    if (v7)
    {

      _nw_protocol_swift_wrapper_input_available(v7);
    }
  }
}

uint64_t nw_protocol_swift_wrapper_finalize_output_frames(uint64_t a1, id *a2)
{
  v28 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v19 = __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_protocol_swift_wrapper_finalize_output_frames";
    v5 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v5, &type, &v22))
    {
      goto LABEL_19;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_finalize_output_frames";
        v20 = "%{public}s called with null protocol";
LABEL_48:
        _os_log_impl(&dword_181A37000, v6, v7, v20, buf, 0xCu);
      }
    }

    else
    {
      if (v22 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v6 = __nwlog_obj();
        v7 = type;
        v21 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (!v21)
          {
            goto LABEL_18;
          }

          *buf = 136446466;
          v25 = "nw_protocol_swift_wrapper_finalize_output_frames";
          v26 = 2082;
          v27 = backtrace_string;
          v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_17:
          _os_log_impl(&dword_181A37000, v6, v7, v14, buf, 0x16u);
LABEL_18:

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v21)
        {
          goto LABEL_49;
        }

        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_finalize_output_frames";
        v20 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_48;
      }

      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_finalize_output_frames";
        v20 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_48;
      }
    }

LABEL_49:

LABEL_19:
    if (!v5)
    {
      return 0;
    }

LABEL_20:
    free(v5);
    return 0;
  }

  v2 = a1;
  v3 = *(a1 + 40);
  if (v3 != &nw_protocol_ref_counted_handle)
  {
    if (v3 != &nw_protocol_ref_counted_additional_handle)
    {
      v4 = __nwlog_obj();
      *buf = 136446210;
      v25 = "nw_protocol_swift_wrapper_finalize_output_frames";
      v5 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v22 = 0;
      if (!__nwlog_fault(v5, &type, &v22))
      {
        goto LABEL_19;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v6 = __nwlog_obj();
        v7 = type;
        if (!os_log_type_enabled(v6, type))
        {
          goto LABEL_34;
        }

        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_finalize_output_frames";
        v8 = "%{public}s called with null wrapper";
        goto LABEL_33;
      }

      if (v22 != 1)
      {
        v6 = __nwlog_obj();
        v7 = type;
        if (!os_log_type_enabled(v6, type))
        {
          goto LABEL_34;
        }

        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_finalize_output_frames";
        v8 = "%{public}s called with null wrapper, backtrace limit exceeded";
        goto LABEL_33;
      }

      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v13 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
          goto LABEL_34;
        }

        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_finalize_output_frames";
        v8 = "%{public}s called with null wrapper, no backtrace";
LABEL_33:
        _os_log_impl(&dword_181A37000, v6, v7, v8, buf, 0xCu);
LABEL_34:

        if (!v5)
        {
          return 0;
        }

        goto LABEL_20;
      }

      if (!v13)
      {
        goto LABEL_18;
      }

      *buf = 136446466;
      v25 = "nw_protocol_swift_wrapper_finalize_output_frames";
      v26 = 2082;
      v27 = backtrace_string;
      v14 = "%{public}s called with null wrapper, dumping backtrace:%{public}s";
      goto LABEL_17;
    }

    v2 = *(a1 + 64);
  }

  if (a2)
  {
    v9 = a2;
    v10 = *a2;
    if (v10)
    {
      v11 = v10[11];
    }

    else
    {
      v11 = 0;
    }
  }

  else
  {
    v9 = 0;
    v11 = 0;
  }

  input_linkage = nw_protocol_swift_wrapper_get_input_linkage(v2 + 96, v11);
  v17 = input_linkage;
  v15 = 0;
  if (*(v2 + 96) && input_linkage)
  {
    v15 = _nw_protocol_swift_wrapper_finalize_output_frames(input_linkage, v9);
  }

  return v15;
}

uint64_t nw_protocol_swift_wrapper_get_output_frames(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v36 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v24 = __nwlog_obj();
    *buf = 136446210;
    v33 = "nw_protocol_swift_wrapper_get_output_frames";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v13, &type, &v30))
    {
      goto LABEL_18;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *buf = 136446210;
        v33 = "nw_protocol_swift_wrapper_get_output_frames";
        v27 = "%{public}s called with null protocol";
LABEL_43:
        _os_log_impl(&dword_181A37000, v25, v26, v27, buf, 0xCu);
      }
    }

    else
    {
      if (v30 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v25 = __nwlog_obj();
        v26 = type;
        v29 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *buf = 136446466;
            v33 = "nw_protocol_swift_wrapper_get_output_frames";
            v34 = 2082;
            v35 = backtrace_string;
            _os_log_impl(&dword_181A37000, v25, v26, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v13)
          {
            return 0;
          }

          goto LABEL_19;
        }

        if (!v29)
        {
          goto LABEL_44;
        }

        *buf = 136446210;
        v33 = "nw_protocol_swift_wrapper_get_output_frames";
        v27 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_43;
      }

      v25 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *buf = 136446210;
        v33 = "nw_protocol_swift_wrapper_get_output_frames";
        v27 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_43;
      }
    }

LABEL_44:

LABEL_18:
    if (!v13)
    {
      return 0;
    }

LABEL_19:
    free(v13);
    return 0;
  }

  v11 = *(a1 + 40);
  if (v11 != &nw_protocol_ref_counted_handle)
  {
    if (v11 != &nw_protocol_ref_counted_additional_handle)
    {
      v12 = __nwlog_obj();
      *buf = 136446210;
      v33 = "nw_protocol_swift_wrapper_get_output_frames";
      v13 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v30 = 0;
      if (__nwlog_fault(v13, &type, &v30))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v14 = __nwlog_obj();
          v15 = type;
          if (!os_log_type_enabled(v14, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v33 = "nw_protocol_swift_wrapper_get_output_frames";
          v16 = "%{public}s called with null wrapper";
          goto LABEL_26;
        }

        if (v30 != 1)
        {
          v14 = __nwlog_obj();
          v15 = type;
          if (!os_log_type_enabled(v14, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v33 = "nw_protocol_swift_wrapper_get_output_frames";
          v16 = "%{public}s called with null wrapper, backtrace limit exceeded";
          goto LABEL_26;
        }

        v21 = __nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v22 = os_log_type_enabled(v14, type);
        if (!v21)
        {
          if (!v22)
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v33 = "nw_protocol_swift_wrapper_get_output_frames";
          v16 = "%{public}s called with null wrapper, no backtrace";
LABEL_26:
          _os_log_impl(&dword_181A37000, v14, v15, v16, buf, 0xCu);
LABEL_27:

          if (!v13)
          {
            return 0;
          }

          goto LABEL_19;
        }

        if (v22)
        {
          *buf = 136446466;
          v33 = "nw_protocol_swift_wrapper_get_output_frames";
          v34 = 2082;
          v35 = v21;
          _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v21);
      }

      goto LABEL_18;
    }

    a1 = *(a1 + 64);
  }

  v17 = a1;
  input_linkage = nw_protocol_swift_wrapper_get_input_linkage(a1 + 96, a2);
  v19 = input_linkage;
  output_frames = 0;
  if (*(v17 + 96) && input_linkage)
  {
    output_frames = _nw_protocol_swift_wrapper_get_output_frames(input_linkage, a3, a4, a5, a6, a2);
  }

  return output_frames;
}

uint64_t nw_protocol_swift_wrapper_get_input_frames(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v35 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v23 = __nwlog_obj();
    *buf = 136446210;
    v32 = "nw_protocol_swift_wrapper_get_input_frames";
    v12 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v12, &type, &v29))
    {
      goto LABEL_18;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *buf = 136446210;
        v32 = "nw_protocol_swift_wrapper_get_input_frames";
        v26 = "%{public}s called with null protocol";
LABEL_43:
        _os_log_impl(&dword_181A37000, v24, v25, v26, buf, 0xCu);
      }
    }

    else
    {
      if (v29 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v24 = __nwlog_obj();
        v25 = type;
        v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *buf = 136446466;
            v32 = "nw_protocol_swift_wrapper_get_input_frames";
            v33 = 2082;
            v34 = backtrace_string;
            _os_log_impl(&dword_181A37000, v24, v25, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v12)
          {
            return 0;
          }

          goto LABEL_19;
        }

        if (!v28)
        {
          goto LABEL_44;
        }

        *buf = 136446210;
        v32 = "nw_protocol_swift_wrapper_get_input_frames";
        v26 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_43;
      }

      v24 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *buf = 136446210;
        v32 = "nw_protocol_swift_wrapper_get_input_frames";
        v26 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_43;
      }
    }

LABEL_44:

LABEL_18:
    if (!v12)
    {
      return 0;
    }

LABEL_19:
    free(v12);
    return 0;
  }

  v10 = *(a1 + 40);
  if (v10 != &nw_protocol_ref_counted_handle)
  {
    if (v10 != &nw_protocol_ref_counted_additional_handle)
    {
      v11 = __nwlog_obj();
      *buf = 136446210;
      v32 = "nw_protocol_swift_wrapper_get_input_frames";
      v12 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v29 = 0;
      if (__nwlog_fault(v12, &type, &v29))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v13 = __nwlog_obj();
          v14 = type;
          if (!os_log_type_enabled(v13, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v32 = "nw_protocol_swift_wrapper_get_input_frames";
          v15 = "%{public}s called with null wrapper";
          goto LABEL_26;
        }

        if (v29 != 1)
        {
          v13 = __nwlog_obj();
          v14 = type;
          if (!os_log_type_enabled(v13, type))
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v32 = "nw_protocol_swift_wrapper_get_input_frames";
          v15 = "%{public}s called with null wrapper, backtrace limit exceeded";
          goto LABEL_26;
        }

        v20 = __nw_create_backtrace_string();
        v13 = __nwlog_obj();
        v14 = type;
        v21 = os_log_type_enabled(v13, type);
        if (!v20)
        {
          if (!v21)
          {
            goto LABEL_27;
          }

          *buf = 136446210;
          v32 = "nw_protocol_swift_wrapper_get_input_frames";
          v15 = "%{public}s called with null wrapper, no backtrace";
LABEL_26:
          _os_log_impl(&dword_181A37000, v13, v14, v15, buf, 0xCu);
LABEL_27:

          if (!v12)
          {
            return 0;
          }

          goto LABEL_19;
        }

        if (v21)
        {
          *buf = 136446466;
          v32 = "nw_protocol_swift_wrapper_get_input_frames";
          v33 = 2082;
          v34 = v20;
          _os_log_impl(&dword_181A37000, v13, v14, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v20);
      }

      goto LABEL_18;
    }

    a1 = *(a1 + 64);
  }

  v16 = a1;
  input_linkage = nw_protocol_swift_wrapper_get_input_linkage(a1 + 96, a2);
  v18 = input_linkage;
  input_frames = 0;
  if (*(v16 + 96) && input_linkage)
  {
    input_frames = _nw_protocol_swift_wrapper_get_input_frames(input_linkage, a3, a4, a5, a6);
  }

  return input_frames;
}

BOOL nw_protocol_swift_wrapper_remove_input_handler(void *a1, uint64_t a2, int a3)
{
  v32 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v19 = __nwlog_obj();
    *buf = 136446210;
    v29 = "nw_protocol_swift_wrapper_remove_input_handler";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v9, &type, &v26))
    {
      goto LABEL_27;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *buf = 136446210;
        v29 = "nw_protocol_swift_wrapper_remove_input_handler";
        v22 = "%{public}s called with null protocol";
LABEL_52:
        _os_log_impl(&dword_181A37000, v20, v21, v22, buf, 0xCu);
      }
    }

    else
    {
      if (v26 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v20 = __nwlog_obj();
        v21 = type;
        v24 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *buf = 136446466;
            v29 = "nw_protocol_swift_wrapper_remove_input_handler";
            v30 = 2082;
            v31 = backtrace_string;
            _os_log_impl(&dword_181A37000, v20, v21, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v9)
          {
            return 0;
          }

          goto LABEL_28;
        }

        if (!v24)
        {
          goto LABEL_53;
        }

        *buf = 136446210;
        v29 = "nw_protocol_swift_wrapper_remove_input_handler";
        v22 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_52;
      }

      v20 = __nwlog_obj();
      v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *buf = 136446210;
        v29 = "nw_protocol_swift_wrapper_remove_input_handler";
        v22 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_52;
      }
    }

LABEL_53:

LABEL_27:
    if (!v9)
    {
      return 0;
    }

LABEL_28:
    free(v9);
    return 0;
  }

  v6 = a1[5];
  v7 = a1;
  if (v6 != &nw_protocol_ref_counted_handle)
  {
    if (v6 != &nw_protocol_ref_counted_additional_handle)
    {
      v8 = __nwlog_obj();
      *buf = 136446210;
      v29 = "nw_protocol_swift_wrapper_remove_input_handler";
      v9 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v26 = 0;
      if (__nwlog_fault(v9, &type, &v26))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v10 = __nwlog_obj();
          v11 = type;
          if (!os_log_type_enabled(v10, type))
          {
            goto LABEL_36;
          }

          *buf = 136446210;
          v29 = "nw_protocol_swift_wrapper_remove_input_handler";
          v12 = "%{public}s called with null wrapper";
          goto LABEL_35;
        }

        if (v26 != 1)
        {
          v10 = __nwlog_obj();
          v11 = type;
          if (!os_log_type_enabled(v10, type))
          {
            goto LABEL_36;
          }

          *buf = 136446210;
          v29 = "nw_protocol_swift_wrapper_remove_input_handler";
          v12 = "%{public}s called with null wrapper, backtrace limit exceeded";
          goto LABEL_35;
        }

        v16 = __nw_create_backtrace_string();
        v10 = __nwlog_obj();
        v11 = type;
        v17 = os_log_type_enabled(v10, type);
        if (!v16)
        {
          if (!v17)
          {
            goto LABEL_36;
          }

          *buf = 136446210;
          v29 = "nw_protocol_swift_wrapper_remove_input_handler";
          v12 = "%{public}s called with null wrapper, no backtrace";
LABEL_35:
          _os_log_impl(&dword_181A37000, v10, v11, v12, buf, 0xCu);
LABEL_36:

          if (!v9)
          {
            return 0;
          }

          goto LABEL_28;
        }

        if (v17)
        {
          *buf = 136446466;
          v29 = "nw_protocol_swift_wrapper_remove_input_handler";
          v30 = 2082;
          v31 = v16;
          _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v16);
      }

      goto LABEL_27;
    }

    v7 = a1[8];
  }

  if (nw_protocol_get_output_handler(a2) == a1)
  {
    nw_protocol_set_output_handler(a2, 0);
  }

  input_linkage = nw_protocol_swift_wrapper_get_input_linkage((v7 + 12), a2);
  v15 = input_linkage != 0;
  if (input_linkage)
  {
    if (a1[6] == a2)
    {
      nw_protocol_set_input_handler(a1, 0);
    }

    if (v7[12])
    {
      _nw_protocol_swift_wrapper_remove_input_handler(input_linkage, a3);
      nw_protocol_destroy_input_linkage_handle(a1, input_linkage);
    }

    if (a3 && !nw_hash_table_count(v7[13], v13))
    {
      if (*(v7 + 120) == 1)
      {
        nw_protocol_remove_instance(a1);
      }

      v25[0] = MEMORY[0x1E69E9820];
      v25[1] = 3221225472;
      v25[2] = __nw_protocol_swift_wrapper_remove_input_handler_block_invoke;
      v25[3] = &__block_descriptor_40_e5_v8__0l;
      v25[4] = v7 + 12;
      nw_protocol_destroy((v7 + 12), v25);
    }
  }

  return v15;
}

void nw_protocol_destroy_input_linkage_handle(void *a1, void *a2)
{
  v29 = *MEMORY[0x1E69E9840];
  v3 = a2;
  v4 = v3;
  if (a1)
  {
    v5 = a1[5];
    if (v5 != &nw_protocol_ref_counted_handle)
    {
      if (v5 != &nw_protocol_ref_counted_additional_handle)
      {
        v6 = __nwlog_obj();
        *buf = 136446210;
        v26 = "nw_protocol_destroy_input_linkage_handle";
        v7 = _os_log_send_and_compose_impl();

        v24 = OS_LOG_TYPE_ERROR;
        v23 = 0;
        if (!__nwlog_fault(v7, &v24, &v23))
        {
          goto LABEL_24;
        }

        if (v24 == OS_LOG_TYPE_FAULT)
        {
          v8 = __nwlog_obj();
          v9 = v24;
          if (os_log_type_enabled(v8, v24))
          {
            *buf = 136446210;
            v26 = "nw_protocol_destroy_input_linkage_handle";
            v10 = "%{public}s called with null wrapper";
LABEL_22:
            _os_log_impl(&dword_181A37000, v8, v9, v10, buf, 0xCu);
            goto LABEL_23;
          }

          goto LABEL_23;
        }

        if (v23 != 1)
        {
          v8 = __nwlog_obj();
          v9 = v24;
          if (os_log_type_enabled(v8, v24))
          {
            *buf = 136446210;
            v26 = "nw_protocol_destroy_input_linkage_handle";
            v10 = "%{public}s called with null wrapper, backtrace limit exceeded";
            goto LABEL_22;
          }

LABEL_23:

          goto LABEL_24;
        }

        backtrace_string = __nw_create_backtrace_string();
        v8 = __nwlog_obj();
        v9 = v24;
        v13 = os_log_type_enabled(v8, v24);
        if (!backtrace_string)
        {
          if (v13)
          {
            *buf = 136446210;
            v26 = "nw_protocol_destroy_input_linkage_handle";
            v10 = "%{public}s called with null wrapper, no backtrace";
            goto LABEL_22;
          }

          goto LABEL_23;
        }

        if (v13)
        {
          *buf = 136446466;
          v26 = "nw_protocol_destroy_input_linkage_handle";
          v27 = 2082;
          v28 = backtrace_string;
          v14 = "%{public}s called with null wrapper, dumping backtrace:%{public}s";
LABEL_15:
          _os_log_impl(&dword_181A37000, v8, v9, v14, buf, 0x16u);
          goto LABEL_16;
        }

        goto LABEL_16;
      }

      a1 = a1[8];
    }

    v11 = a1[13];
    if (v11)
    {
      v20[0] = MEMORY[0x1E69E9820];
      v20[1] = 3221225472;
      v20[2] = __nw_protocol_destroy_input_linkage_handle_block_invoke;
      v20[3] = &unk_1E6A35D48;
      v21 = v3;
      v22 = a1 + 12;
      nw_hash_table_apply(v11, v20);

      goto LABEL_26;
    }

    v16 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_protocol_destroy_input_linkage_handle";
    v7 = _os_log_send_and_compose_impl();

    v24 = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v7, &v24, &v23))
    {
      if (v24 == OS_LOG_TYPE_FAULT)
      {
        v8 = __nwlog_obj();
        v9 = v24;
        if (!os_log_type_enabled(v8, v24))
        {
          goto LABEL_23;
        }

        *buf = 136446210;
        v26 = "nw_protocol_destroy_input_linkage_handle";
        v10 = "%{public}s called with null wrapper->input_linkages";
        goto LABEL_22;
      }

      if (v23 != 1)
      {
        v8 = __nwlog_obj();
        v9 = v24;
        if (!os_log_type_enabled(v8, v24))
        {
          goto LABEL_23;
        }

        *buf = 136446210;
        v26 = "nw_protocol_destroy_input_linkage_handle";
        v10 = "%{public}s called with null wrapper->input_linkages, backtrace limit exceeded";
        goto LABEL_22;
      }

      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = v24;
      v19 = os_log_type_enabled(v8, v24);
      if (!backtrace_string)
      {
        if (!v19)
        {
          goto LABEL_23;
        }

        *buf = 136446210;
        v26 = "nw_protocol_destroy_input_linkage_handle";
        v10 = "%{public}s called with null wrapper->input_linkages, no backtrace";
        goto LABEL_22;
      }

      if (v19)
      {
        *buf = 136446466;
        v26 = "nw_protocol_destroy_input_linkage_handle";
        v27 = 2082;
        v28 = backtrace_string;
        v14 = "%{public}s called with null wrapper->input_linkages, dumping backtrace:%{public}s";
        goto LABEL_15;
      }

LABEL_16:

      free(backtrace_string);
      if (!v7)
      {
        goto LABEL_26;
      }

      goto LABEL_25;
    }
  }

  else
  {
    v15 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_protocol_destroy_input_linkage_handle";
    v7 = _os_log_send_and_compose_impl();

    v24 = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v7, &v24, &v23))
    {
      if (v24 == OS_LOG_TYPE_FAULT)
      {
        v8 = __nwlog_obj();
        v9 = v24;
        if (!os_log_type_enabled(v8, v24))
        {
          goto LABEL_23;
        }

        *buf = 136446210;
        v26 = "nw_protocol_destroy_input_linkage_handle";
        v10 = "%{public}s called with null protocol";
        goto LABEL_22;
      }

      if (v23 != 1)
      {
        v8 = __nwlog_obj();
        v9 = v24;
        if (!os_log_type_enabled(v8, v24))
        {
          goto LABEL_23;
        }

        *buf = 136446210;
        v26 = "nw_protocol_destroy_input_linkage_handle";
        v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_22;
      }

      v17 = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = v24;
      v18 = os_log_type_enabled(v8, v24);
      if (!v17)
      {
        if (!v18)
        {
          goto LABEL_23;
        }

        *buf = 136446210;
        v26 = "nw_protocol_destroy_input_linkage_handle";
        v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_22;
      }

      if (v18)
      {
        *buf = 136446466;
        v26 = "nw_protocol_destroy_input_linkage_handle";
        v27 = 2082;
        v28 = v17;
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v17);
    }
  }

LABEL_24:
  if (v7)
  {
LABEL_25:
    free(v7);
  }

LABEL_26:
}

void __nw_protocol_swift_wrapper_remove_input_handler_block_invoke(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *v2;
  *v2 = 0;

  v4 = *(a1 + 32);
  v5 = *(v4 + 16);
  *(v4 + 16) = 0;

  v6 = *(*(a1 + 32) + 8);
  if (v6)
  {
    nw_hash_table_apply(v6, &__block_literal_global_3);
    v8 = *(*(a1 + 32) + 8);
    if (v8)
    {
      _nw_hash_table_release(v8, v7);
      *(*(a1 + 32) + 8) = 0;
    }
  }
}

uint64_t __nw_protocol_swift_wrapper_remove_input_handler_block_invoke_2(uint64_t a1, uint64_t a2)
{
  extra = nw_hash_node_get_extra(a2);
  v3 = *extra;
  *extra = 0;

  return 1;
}

BOOL __nw_protocol_destroy_input_linkage_handle_block_invoke(uint64_t a1, uint64_t a2)
{
  extra = nw_hash_node_get_extra(a2);
  v5 = *(a1 + 32);
  v6 = *extra;
  if (v5 == *extra)
  {
    v7 = extra;
    _nw_protocol_destroy_input_linkage_handle(*extra);
    v8 = *v7;
    *v7 = 0;

    nw_hash_table_remove_node(*(*(a1 + 40) + 8), a2);
  }

  return v5 != v6;
}

uint64_t nw_protocol_swift_wrapper_add_input_handler(uint64_t a1, char *a2)
{
  v84 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v50 = __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_protocol_swift_wrapper_add_input_handler";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v7, &type, &v78))
    {
      goto LABEL_31;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v81 = "nw_protocol_swift_wrapper_add_input_handler";
        v51 = "%{public}s called with null protocol";
LABEL_149:
        _os_log_impl(&dword_181A37000, v8, v9, v51, buf, 0xCu);
      }
    }

    else
    {
      if (v78 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v8 = __nwlog_obj();
        v9 = type;
        v63 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (!v63)
          {
            goto LABEL_30;
          }

          *buf = 136446466;
          v81 = "nw_protocol_swift_wrapper_add_input_handler";
          v82 = 2082;
          v83 = backtrace_string;
          v26 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_29:
          _os_log_impl(&dword_181A37000, v8, v9, v26, buf, 0x16u);
LABEL_30:

          free(backtrace_string);
          goto LABEL_31;
        }

        if (!v63)
        {
          goto LABEL_150;
        }

        *buf = 136446210;
        v81 = "nw_protocol_swift_wrapper_add_input_handler";
        v51 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_149;
      }

      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v81 = "nw_protocol_swift_wrapper_add_input_handler";
        v51 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_149;
      }
    }

LABEL_150:

    goto LABEL_31;
  }

  v3 = a1;
  v4 = *(a1 + 40);
  v5 = a1;
  if (v4 != &nw_protocol_ref_counted_handle)
  {
    if (v4 != &nw_protocol_ref_counted_additional_handle)
    {
      v6 = __nwlog_obj();
      *buf = 136446210;
      v81 = "nw_protocol_swift_wrapper_add_input_handler";
      v7 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v78 = 0;
      if (!__nwlog_fault(v7, &type, &v78))
      {
        goto LABEL_31;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v8 = __nwlog_obj();
        v9 = type;
        if (!os_log_type_enabled(v8, type))
        {
          goto LABEL_46;
        }

        *buf = 136446210;
        v81 = "nw_protocol_swift_wrapper_add_input_handler";
        v10 = "%{public}s called with null wrapper";
        goto LABEL_45;
      }

      if (v78 != 1)
      {
        v8 = __nwlog_obj();
        v9 = type;
        if (!os_log_type_enabled(v8, type))
        {
          goto LABEL_46;
        }

        *buf = 136446210;
        v81 = "nw_protocol_swift_wrapper_add_input_handler";
        v10 = "%{public}s called with null wrapper, backtrace limit exceeded";
        goto LABEL_45;
      }

      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v25 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (!v25)
        {
          goto LABEL_46;
        }

        *buf = 136446210;
        v81 = "nw_protocol_swift_wrapper_add_input_handler";
        v10 = "%{public}s called with null wrapper, no backtrace";
LABEL_45:
        _os_log_impl(&dword_181A37000, v8, v9, v10, buf, 0xCu);
LABEL_46:

        if (!v7)
        {
          return 0;
        }

        goto LABEL_32;
      }

      if (!v25)
      {
        goto LABEL_30;
      }

      *buf = 136446466;
      v81 = "nw_protocol_swift_wrapper_add_input_handler";
      v82 = 2082;
      v83 = backtrace_string;
      v26 = "%{public}s called with null wrapper, dumping backtrace:%{public}s";
      goto LABEL_29;
    }

    v5 = *(a1 + 64);
  }

  if (*(v5 + 96))
  {
    if (!*(v5 + 104))
    {
      internal = nw_hash_table_create_internal(5u, 8, nw_protocol_get_key, nw_protocol_key_hash, nw_protocol_matches_key, nw_protocol_hash_release, nw_protocol_hash_retain);
      if (internal)
      {
        *(internal + 56) &= ~2u;
      }

      *(v5 + 104) = internal;
    }

    nw_protocol_set_input_handler(v3, a2);
    nw_protocol_set_flow_id_from_protocol(v3, a2);
    if (!nw_protocol_get_output_handler(a2))
    {
      nw_protocol_set_output_handler(a2, v3);
    }

    input_linkage_handle = _nw_protocol_create_input_linkage_handle(v3);
    if (input_linkage_handle)
    {
      v13 = *(v5 + 112);
      v14 = v13;
      if (v13)
      {
        goto LABEL_57;
      }

      output_linkage_handle = _nw_protocol_create_output_linkage_handle(v3);
      if (output_linkage_handle)
      {
        v16 = output_linkage_handle;
        v14 = output_linkage_handle;
        v17 = *(v3 + 40);
        v18 = v3;
        if (v17 != &nw_protocol_ref_counted_handle)
        {
          if (v17 != &nw_protocol_ref_counted_additional_handle)
          {
            v19 = __nwlog_obj();
            *buf = 136446210;
            v81 = "nw_protocol_swift_wrapper_set_output_linkage";
            v77 = input_linkage_handle;
            v20 = _os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v78 = 0;
            if (!__nwlog_fault(v20, &type, &v78))
            {
              goto LABEL_54;
            }

            if (type == OS_LOG_TYPE_FAULT)
            {
              v21 = __nwlog_obj();
              v22 = type;
              if (os_log_type_enabled(v21, type))
              {
                *buf = 136446210;
                v81 = "nw_protocol_swift_wrapper_set_output_linkage";
                v23 = "%{public}s called with null wrapper";
LABEL_50:
                v30 = v21;
                v31 = v22;
LABEL_51:
                _os_log_impl(&dword_181A37000, v30, v31, v23, buf, 0xCu);
              }
            }

            else if (v78 == 1)
            {
              v28 = __nw_create_backtrace_string();
              v21 = __nwlog_obj();
              v76 = type;
              v29 = os_log_type_enabled(v21, type);
              if (v28)
              {
                if (v29)
                {
                  *buf = 136446466;
                  v81 = "nw_protocol_swift_wrapper_set_output_linkage";
                  v82 = 2082;
                  v83 = v28;
                  _os_log_impl(&dword_181A37000, v21, v76, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v28);
                goto LABEL_53;
              }

              if (v29)
              {
                *buf = 136446210;
                v81 = "nw_protocol_swift_wrapper_set_output_linkage";
                v23 = "%{public}s called with null wrapper, no backtrace";
                v30 = v21;
                v31 = v76;
                goto LABEL_51;
              }
            }

            else
            {
              v21 = __nwlog_obj();
              v22 = type;
              if (os_log_type_enabled(v21, type))
              {
                *buf = 136446210;
                v81 = "nw_protocol_swift_wrapper_set_output_linkage";
                v23 = "%{public}s called with null wrapper, backtrace limit exceeded";
                goto LABEL_50;
              }
            }

LABEL_53:
            input_linkage_handle = v77;
LABEL_54:
            if (v20)
            {
              free(v20);
            }

            goto LABEL_56;
          }

          v18 = *(v3 + 64);
        }

        objc_storeStrong((v18 + 112), v16);
LABEL_56:

LABEL_57:
        v32 = input_linkage_handle;
        v33 = *(v3 + 40);
        if (v33 != &nw_protocol_ref_counted_handle)
        {
          if (v33 != &nw_protocol_ref_counted_additional_handle)
          {
            v34 = __nwlog_obj();
            *buf = 136446210;
            v81 = "nw_protocol_swift_wrapper_set_input_linkage";
            v35 = _os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v78 = 0;
            if (!__nwlog_fault(v35, &type, &v78))
            {
              goto LABEL_79;
            }

            if (type == OS_LOG_TYPE_FAULT)
            {
              v36 = __nwlog_obj();
              v37 = type;
              if (os_log_type_enabled(v36, type))
              {
                *buf = 136446210;
                v81 = "nw_protocol_swift_wrapper_set_input_linkage";
                v38 = "%{public}s called with null wrapper";
LABEL_77:
                _os_log_impl(&dword_181A37000, v36, v37, v38, buf, 0xCu);
                goto LABEL_78;
              }

              goto LABEL_78;
            }

            if (v78 != 1)
            {
              v36 = __nwlog_obj();
              v37 = type;
              if (os_log_type_enabled(v36, type))
              {
                *buf = 136446210;
                v81 = "nw_protocol_swift_wrapper_set_input_linkage";
                v38 = "%{public}s called with null wrapper, backtrace limit exceeded";
                goto LABEL_77;
              }

LABEL_78:

LABEL_79:
              if (!v35)
              {
                goto LABEL_81;
              }

              goto LABEL_80;
            }

            v43 = input_linkage_handle;
            v44 = __nw_create_backtrace_string();
            v45 = __nwlog_obj();
            v46 = type;
            v47 = os_log_type_enabled(v45, type);
            if (v44)
            {
              if (v47)
              {
                *buf = 136446466;
                v81 = "nw_protocol_swift_wrapper_set_input_linkage";
                v82 = 2082;
                v83 = v44;
                _os_log_impl(&dword_181A37000, v45, v46, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v44);
              input_linkage_handle = v43;
              if (!v35)
              {
                goto LABEL_81;
              }

LABEL_80:
              free(v35);
              goto LABEL_81;
            }

            if (v47)
            {
              *buf = 136446210;
              v81 = "nw_protocol_swift_wrapper_set_input_linkage";
              _os_log_impl(&dword_181A37000, v45, v46, "%{public}s called with null wrapper, no backtrace", buf, 0xCu);
            }

            input_linkage_handle = v43;
            if (v35)
            {
              goto LABEL_80;
            }

LABEL_81:

            v48 = *(v5 + 120);
            if (_nw_protocol_swift_wrapper_add_input_handler(*(v5 + 96), v48 == 1, v32))
            {
              if (!v13)
              {
                _nw_protocol_swift_wrapper_set_output_linkage(*(v5 + 96), v48 == 1, v14);
              }

              v27 = 1;
LABEL_85:

LABEL_86:
              return v27;
            }

            v58 = __nwlog_obj();
            *buf = 136446210;
            v81 = "nw_protocol_swift_wrapper_add_input_handler";
            v59 = _os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v78 = 0;
            if (!__nwlog_fault(v59, &type, &v78))
            {
LABEL_164:
              if (v59)
              {
                free(v59);
              }

              v27 = 0;
              goto LABEL_85;
            }

            if (type == OS_LOG_TYPE_FAULT)
            {
              v60 = __nwlog_obj();
              v61 = type;
              if (os_log_type_enabled(v60, type))
              {
                *buf = 136446210;
                v81 = "nw_protocol_swift_wrapper_add_input_handler";
                v62 = "%{public}s called with null added";
LABEL_162:
                _os_log_impl(&dword_181A37000, v60, v61, v62, buf, 0xCu);
              }
            }

            else
            {
              if (v78 == 1)
              {
                v67 = __nw_create_backtrace_string();
                v60 = __nwlog_obj();
                v61 = type;
                v68 = os_log_type_enabled(v60, type);
                if (v67)
                {
                  if (v68)
                  {
                    *buf = 136446466;
                    v81 = "nw_protocol_swift_wrapper_add_input_handler";
                    v82 = 2082;
                    v83 = v67;
                    _os_log_impl(&dword_181A37000, v60, v61, "%{public}s called with null added, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v67);
                  goto LABEL_164;
                }

                if (!v68)
                {
                  goto LABEL_163;
                }

                *buf = 136446210;
                v81 = "nw_protocol_swift_wrapper_add_input_handler";
                v62 = "%{public}s called with null added, no backtrace";
                goto LABEL_162;
              }

              v60 = __nwlog_obj();
              v61 = type;
              if (os_log_type_enabled(v60, type))
              {
                *buf = 136446210;
                v81 = "nw_protocol_swift_wrapper_add_input_handler";
                v62 = "%{public}s called with null added, backtrace limit exceeded";
                goto LABEL_162;
              }
            }

LABEL_163:

            goto LABEL_164;
          }

          v3 = *(v3 + 64);
        }

        type = OS_LOG_TYPE_DEFAULT;
        v39 = nw_hash_table_add_object(*(v3 + 104), a2, &type);
        if (type)
        {
          extra = nw_hash_node_get_extra(v39);
          v41 = v32;
          v42 = *extra;
          *extra = v41;
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v42 = gLogObj;
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            *buf = 136446466;
            v81 = "nw_protocol_swift_wrapper_set_input_linkage";
            v82 = 2048;
            v83 = a2;
            _os_log_impl(&dword_181A37000, v42, OS_LOG_TYPE_ERROR, "%{public}s Input handler already registered for protocol %p", buf, 0x16u);
          }
        }

        goto LABEL_81;
      }

      v69 = __nwlog_obj();
      *buf = 136446210;
      v81 = "nw_protocol_swift_wrapper_add_input_handler";
      v70 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v78 = 0;
      if (!__nwlog_fault(v70, &type, &v78))
      {
LABEL_171:
        if (v70)
        {
          free(v70);
        }

        v14 = 0;
        v27 = 0;
        goto LABEL_85;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v71 = __nwlog_obj();
        v72 = type;
        if (os_log_type_enabled(v71, type))
        {
          *buf = 136446210;
          v81 = "nw_protocol_swift_wrapper_add_input_handler";
          v73 = "%{public}s called with null output_linkage";
LABEL_169:
          _os_log_impl(&dword_181A37000, v71, v72, v73, buf, 0xCu);
        }
      }

      else
      {
        if (v78 == 1)
        {
          v74 = __nw_create_backtrace_string();
          v71 = __nwlog_obj();
          v72 = type;
          v75 = os_log_type_enabled(v71, type);
          if (v74)
          {
            if (v75)
            {
              *buf = 136446466;
              v81 = "nw_protocol_swift_wrapper_add_input_handler";
              v82 = 2082;
              v83 = v74;
              _os_log_impl(&dword_181A37000, v71, v72, "%{public}s called with null output_linkage, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v74);
            goto LABEL_171;
          }

          if (!v75)
          {
            goto LABEL_170;
          }

          *buf = 136446210;
          v81 = "nw_protocol_swift_wrapper_add_input_handler";
          v73 = "%{public}s called with null output_linkage, no backtrace";
          goto LABEL_169;
        }

        v71 = __nwlog_obj();
        v72 = type;
        if (os_log_type_enabled(v71, type))
        {
          *buf = 136446210;
          v81 = "nw_protocol_swift_wrapper_add_input_handler";
          v73 = "%{public}s called with null output_linkage, backtrace limit exceeded";
          goto LABEL_169;
        }
      }

LABEL_170:

      goto LABEL_171;
    }

    v53 = __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_protocol_swift_wrapper_add_input_handler";
    v54 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v54, &type, &v78))
    {
LABEL_155:
      if (v54)
      {
        free(v54);
      }

      v27 = 0;
      goto LABEL_86;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v55 = __nwlog_obj();
      v56 = type;
      if (os_log_type_enabled(v55, type))
      {
        *buf = 136446210;
        v81 = "nw_protocol_swift_wrapper_add_input_handler";
        v57 = "%{public}s called with null input_linkage";
LABEL_153:
        _os_log_impl(&dword_181A37000, v55, v56, v57, buf, 0xCu);
      }
    }

    else
    {
      if (v78 == 1)
      {
        v65 = __nw_create_backtrace_string();
        v55 = __nwlog_obj();
        v56 = type;
        v66 = os_log_type_enabled(v55, type);
        if (v65)
        {
          if (v66)
          {
            *buf = 136446466;
            v81 = "nw_protocol_swift_wrapper_add_input_handler";
            v82 = 2082;
            v83 = v65;
            _os_log_impl(&dword_181A37000, v55, v56, "%{public}s called with null input_linkage, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v65);
          goto LABEL_155;
        }

        if (!v66)
        {
          goto LABEL_154;
        }

        *buf = 136446210;
        v81 = "nw_protocol_swift_wrapper_add_input_handler";
        v57 = "%{public}s called with null input_linkage, no backtrace";
        goto LABEL_153;
      }

      v55 = __nwlog_obj();
      v56 = type;
      if (os_log_type_enabled(v55, type))
      {
        *buf = 136446210;
        v81 = "nw_protocol_swift_wrapper_add_input_handler";
        v57 = "%{public}s called with null input_linkage, backtrace limit exceeded";
        goto LABEL_153;
      }
    }

LABEL_154:

    goto LABEL_155;
  }

  v52 = __nwlog_obj();
  *buf = 136446210;
  v81 = "nw_protocol_swift_wrapper_add_input_handler";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v78 = 0;
  if (__nwlog_fault(v7, &type, &v78))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v81 = "nw_protocol_swift_wrapper_add_input_handler";
        v51 = "%{public}s called with null wrapper->instance";
        goto LABEL_149;
      }
    }

    else
    {
      if (v78 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v8 = __nwlog_obj();
        v9 = type;
        v64 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (!v64)
          {
            goto LABEL_30;
          }

          *buf = 136446466;
          v81 = "nw_protocol_swift_wrapper_add_input_handler";
          v82 = 2082;
          v83 = backtrace_string;
          v26 = "%{public}s called with null wrapper->instance, dumping backtrace:%{public}s";
          goto LABEL_29;
        }

        if (!v64)
        {
          goto LABEL_150;
        }

        *buf = 136446210;
        v81 = "nw_protocol_swift_wrapper_add_input_handler";
        v51 = "%{public}s called with null wrapper->instance, no backtrace";
        goto LABEL_149;
      }

      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v81 = "nw_protocol_swift_wrapper_add_input_handler";
        v51 = "%{public}s called with null wrapper->instance, backtrace limit exceeded";
        goto LABEL_149;
      }
    }

    goto LABEL_150;
  }

LABEL_31:
  if (v7)
  {
LABEL_32:
    free(v7);
  }

  return 0;
}

BOOL nw_protocol_swift_wrapper_accept(uint64_t a1, void *a2, void *a3)
{
  v34 = *MEMORY[0x1E69E9840];
  v5 = a2;
  v6 = a3;
  v7 = v6;
  if (!a1)
  {
    v19 = __nwlog_obj();
    *buf = 136446210;
    v31 = "nw_protocol_swift_wrapper_accept";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
    {
      goto LABEL_19;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v28 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v11 = __nwlog_obj();
        v12 = type;
        v24 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (!v24)
          {
            goto LABEL_18;
          }

          *buf = 136446466;
          v31 = "nw_protocol_swift_wrapper_accept";
          v32 = 2082;
          v33 = backtrace_string;
          v17 = "%{public}s called with null many_to_one_handler, dumping backtrace:%{public}s";
LABEL_17:
          _os_log_impl(&dword_181A37000, v11, v12, v17, buf, 0x16u);
LABEL_18:

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v24)
        {
          goto LABEL_79;
        }

        *buf = 136446210;
        v31 = "nw_protocol_swift_wrapper_accept";
        v20 = "%{public}s called with null many_to_one_handler, no backtrace";
        goto LABEL_78;
      }

      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v31 = "nw_protocol_swift_wrapper_accept";
        v20 = "%{public}s called with null many_to_one_handler, backtrace limit exceeded";
        goto LABEL_78;
      }

      goto LABEL_79;
    }

    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
    {
      goto LABEL_79;
    }

    *buf = 136446210;
    v31 = "nw_protocol_swift_wrapper_accept";
    v20 = "%{public}s called with null many_to_one_handler";
LABEL_78:
    _os_log_impl(&dword_181A37000, v11, v12, v20, buf, 0xCu);
    goto LABEL_79;
  }

  v8 = *(a1 + 40);
  if (v8 != &nw_protocol_ref_counted_handle)
  {
    if (v8 != &nw_protocol_ref_counted_additional_handle)
    {
      v9 = __nwlog_obj();
      *buf = 136446210;
      v31 = "nw_protocol_swift_wrapper_accept";
      v10 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v28 = 0;
      if (!__nwlog_fault(v10, &type, &v28))
      {
        goto LABEL_19;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
        {
          goto LABEL_28;
        }

        *buf = 136446210;
        v31 = "nw_protocol_swift_wrapper_accept";
        v13 = "%{public}s called with null wrapper";
        goto LABEL_27;
      }

      if (v28 != 1)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
        {
          goto LABEL_28;
        }

        *buf = 136446210;
        v31 = "nw_protocol_swift_wrapper_accept";
        v13 = "%{public}s called with null wrapper, backtrace limit exceeded";
        goto LABEL_27;
      }

      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v16)
        {
          goto LABEL_28;
        }

        *buf = 136446210;
        v31 = "nw_protocol_swift_wrapper_accept";
        v13 = "%{public}s called with null wrapper, no backtrace";
LABEL_27:
        _os_log_impl(&dword_181A37000, v11, v12, v13, buf, 0xCu);
LABEL_28:

        if (!v10)
        {
          goto LABEL_21;
        }

        goto LABEL_20;
      }

      if (!v16)
      {
        goto LABEL_18;
      }

      *buf = 136446466;
      v31 = "nw_protocol_swift_wrapper_accept";
      v32 = 2082;
      v33 = backtrace_string;
      v17 = "%{public}s called with null wrapper, dumping backtrace:%{public}s";
      goto LABEL_17;
    }

    a1 = *(a1 + 64);
  }

  if (*(a1 + 120) != 1)
  {
    v21 = __nwlog_obj();
    *buf = 136446210;
    v31 = "nw_protocol_swift_wrapper_accept";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
    {
      goto LABEL_19;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v28 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v11 = __nwlog_obj();
        v12 = type;
        v25 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (!v25)
          {
            goto LABEL_18;
          }

          *buf = 136446466;
          v31 = "nw_protocol_swift_wrapper_accept";
          v32 = 2082;
          v33 = backtrace_string;
          v17 = "%{public}s called with null (wrapper->type == nw_swift_wrapper_type_many_to_many), dumping backtrace:%{public}s";
          goto LABEL_17;
        }

        if (!v25)
        {
          goto LABEL_79;
        }

        *buf = 136446210;
        v31 = "nw_protocol_swift_wrapper_accept";
        v20 = "%{public}s called with null (wrapper->type == nw_swift_wrapper_type_many_to_many), no backtrace";
        goto LABEL_78;
      }

      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v31 = "nw_protocol_swift_wrapper_accept";
        v20 = "%{public}s called with null (wrapper->type == nw_swift_wrapper_type_many_to_many), backtrace limit exceeded";
        goto LABEL_78;
      }

      goto LABEL_79;
    }

    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
    {
      goto LABEL_79;
    }

    *buf = 136446210;
    v31 = "nw_protocol_swift_wrapper_accept";
    v20 = "%{public}s called with null (wrapper->type == nw_swift_wrapper_type_many_to_many)";
    goto LABEL_78;
  }

  if (!v5)
  {
    v22 = __nwlog_obj();
    *buf = 136446210;
    v31 = "nw_protocol_swift_wrapper_accept";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
    {
      goto LABEL_19;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v28 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v11 = __nwlog_obj();
        v12 = type;
        v26 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (!v26)
          {
            goto LABEL_18;
          }

          *buf = 136446466;
          v31 = "nw_protocol_swift_wrapper_accept";
          v32 = 2082;
          v33 = backtrace_string;
          v17 = "%{public}s called with null endpoint, dumping backtrace:%{public}s";
          goto LABEL_17;
        }

        if (!v26)
        {
          goto LABEL_79;
        }

        *buf = 136446210;
        v31 = "nw_protocol_swift_wrapper_accept";
        v20 = "%{public}s called with null endpoint, no backtrace";
        goto LABEL_78;
      }

      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v31 = "nw_protocol_swift_wrapper_accept";
        v20 = "%{public}s called with null endpoint, backtrace limit exceeded";
        goto LABEL_78;
      }

      goto LABEL_79;
    }

    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
    {
      goto LABEL_79;
    }

    *buf = 136446210;
    v31 = "nw_protocol_swift_wrapper_accept";
    v20 = "%{public}s called with null endpoint";
    goto LABEL_78;
  }

  if (!v6)
  {
    v23 = __nwlog_obj();
    *buf = 136446210;
    v31 = "nw_protocol_swift_wrapper_accept";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
    {
      goto LABEL_19;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v31 = "nw_protocol_swift_wrapper_accept";
        v20 = "%{public}s called with null parameters";
        goto LABEL_78;
      }
    }

    else
    {
      if (v28 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v11 = __nwlog_obj();
        v12 = type;
        v27 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (!v27)
          {
            goto LABEL_18;
          }

          *buf = 136446466;
          v31 = "nw_protocol_swift_wrapper_accept";
          v32 = 2082;
          v33 = backtrace_string;
          v17 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
          goto LABEL_17;
        }

        if (!v27)
        {
          goto LABEL_79;
        }

        *buf = 136446210;
        v31 = "nw_protocol_swift_wrapper_accept";
        v20 = "%{public}s called with null parameters, no backtrace";
        goto LABEL_78;
      }

      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v31 = "nw_protocol_swift_wrapper_accept";
        v20 = "%{public}s called with null parameters, backtrace limit exceeded";
        goto LABEL_78;
      }
    }

LABEL_79:

LABEL_19:
    if (!v10)
    {
LABEL_21:
      v14 = 0;
      goto LABEL_22;
    }

LABEL_20:
    free(v10);
    goto LABEL_21;
  }

  v14 = _nw_protocol_swift_wrapper_accept(*(a1 + 96), v5, v6);
LABEL_22:

  return v14;
}

void nw_protocol_swift_wrapper_set_instance(uint64_t a1, void *a2, char a3)
{
  v21 = *MEMORY[0x1E69E9840];
  v6 = a2;
  if (a1)
  {
    v7 = *(a1 + 40);
    if (v7 != &nw_protocol_ref_counted_handle)
    {
      if (v7 != &nw_protocol_ref_counted_additional_handle)
      {
        goto LABEL_4;
      }

      a1 = *(a1 + 64);
    }

    objc_storeStrong((a1 + 96), a2);
    *(a1 + 120) = a3;
    goto LABEL_24;
  }

LABEL_4:
  v8 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_protocol_swift_wrapper_set_instance";
  v9 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v9, &type, &v15))
  {
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v10 = __nwlog_obj();
    v11 = type;
    if (!os_log_type_enabled(v10, type))
    {
      goto LABEL_22;
    }

    *buf = 136446210;
    v18 = "nw_protocol_swift_wrapper_set_instance";
    v12 = "%{public}s called with null wrapper";
    goto LABEL_21;
  }

  if (v15 != 1)
  {
    v10 = __nwlog_obj();
    v11 = type;
    if (!os_log_type_enabled(v10, type))
    {
      goto LABEL_22;
    }

    *buf = 136446210;
    v18 = "nw_protocol_swift_wrapper_set_instance";
    v12 = "%{public}s called with null wrapper, backtrace limit exceeded";
    goto LABEL_21;
  }

  backtrace_string = __nw_create_backtrace_string();
  v10 = __nwlog_obj();
  v11 = type;
  v14 = os_log_type_enabled(v10, type);
  if (backtrace_string)
  {
    if (v14)
    {
      *buf = 136446466;
      v18 = "nw_protocol_swift_wrapper_set_instance";
      v19 = 2082;
      v20 = backtrace_string;
      _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
LABEL_13:
    if (!v9)
    {
      goto LABEL_24;
    }

    goto LABEL_23;
  }

  if (!v14)
  {
    goto LABEL_22;
  }

  *buf = 136446210;
  v18 = "nw_protocol_swift_wrapper_set_instance";
  v12 = "%{public}s called with null wrapper, no backtrace";
LABEL_21:
  _os_log_impl(&dword_181A37000, v10, v11, v12, buf, 0xCu);
LABEL_22:

  if (v9)
  {
LABEL_23:
    free(v9);
  }

LABEL_24:
}

uint64_t nw_protocol_swift_wrapper_get_input_handler(void *a1, void *a2)
{
  v35 = *MEMORY[0x1E69E9840];
  v3 = a2;
  v4 = v3;
  if (!a1)
  {
    v17 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v7, &type, &v31))
    {
      goto LABEL_24;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
        _os_log_impl(&dword_181A37000, v8, v18, "%{public}s called with null protocol", buf, 0xCu);
      }

      goto LABEL_23;
    }

    if (v31 != 1)
    {
      v8 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
        _os_log_impl(&dword_181A37000, v8, v26, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_23;
    }

    backtrace_string = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v22 = type;
    v23 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *buf = 136446210;
        *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
        _os_log_impl(&dword_181A37000, v8, v22, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }

      goto LABEL_23;
    }

    if (v23)
    {
      *buf = 136446466;
      *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
      *&buf[12] = 2082;
      *&buf[14] = backtrace_string;
      _os_log_impl(&dword_181A37000, v8, v22, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_47;
  }

  v5 = a1[5];
  if (v5 != &nw_protocol_ref_counted_handle)
  {
    if (v5 != &nw_protocol_ref_counted_additional_handle)
    {
      v6 = __nwlog_obj();
      *buf = 136446210;
      *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
      v7 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v31 = 0;
      if (!__nwlog_fault(v7, &type, &v31))
      {
        goto LABEL_24;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v8 = __nwlog_obj();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
          _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null wrapper", buf, 0xCu);
        }
      }

      else if (v31 == 1)
      {
        v12 = __nw_create_backtrace_string();
        v8 = __nwlog_obj();
        v13 = type;
        v14 = os_log_type_enabled(v8, type);
        if (v12)
        {
          if (v14)
          {
            *buf = 136446466;
            *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
            *&buf[12] = 2082;
            *&buf[14] = v12;
            _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v12);
          if (!v7)
          {
            goto LABEL_26;
          }

          goto LABEL_25;
        }

        if (v14)
        {
          *buf = 136446210;
          *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
          _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null wrapper, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v8 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v8, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
          _os_log_impl(&dword_181A37000, v8, v15, "%{public}s called with null wrapper, backtrace limit exceeded", buf, 0xCu);
        }
      }

      goto LABEL_23;
    }

    a1 = a1[8];
  }

  v10 = a1[13];
  if (!v10)
  {
    v19 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v7, &type, &v31))
    {
      goto LABEL_24;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
        _os_log_impl(&dword_181A37000, v8, v20, "%{public}s called with null wrapper->input_linkages", buf, 0xCu);
      }

LABEL_23:

      goto LABEL_24;
    }

    if (v31 != 1)
    {
      v8 = __nwlog_obj();
      v27 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
        _os_log_impl(&dword_181A37000, v8, v27, "%{public}s called with null wrapper->input_linkages, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_23;
    }

    backtrace_string = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v24 = type;
    v25 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *buf = 136446210;
        *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
        _os_log_impl(&dword_181A37000, v8, v24, "%{public}s called with null wrapper->input_linkages, no backtrace", buf, 0xCu);
      }

      goto LABEL_23;
    }

    if (v25)
    {
      *buf = 136446466;
      *&buf[4] = "nw_protocol_swift_wrapper_get_input_handler";
      *&buf[12] = 2082;
      *&buf[14] = backtrace_string;
      _os_log_impl(&dword_181A37000, v8, v24, "%{public}s called with null wrapper->input_linkages, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_47:

    free(backtrace_string);
LABEL_24:
    if (!v7)
    {
LABEL_26:
      v11 = 0;
      goto LABEL_27;
    }

LABEL_25:
    free(v7);
    goto LABEL_26;
  }

  *buf = 0;
  *&buf[8] = buf;
  *&buf[16] = 0x2020000000;
  v34 = 0;
  v28[0] = MEMORY[0x1E69E9820];
  v28[1] = 3221225472;
  v28[2] = __nw_protocol_swift_wrapper_get_input_handler_block_invoke;
  v28[3] = &unk_1E6A3CD58;
  v29 = v3;
  v30 = buf;
  nw_hash_table_apply(v10, v28);
  v11 = *(*&buf[8] + 24);

  _Block_object_dispose(buf, 8);
LABEL_27:

  return v11;
}

BOOL __nw_protocol_swift_wrapper_get_input_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  extra = nw_hash_node_get_extra(a2);
  v5 = *(a1 + 32);
  v6 = *extra;
  if (v5 == *extra)
  {
    *(*(*(a1 + 40) + 8) + 24) = nw_hash_node_get_object(a2);
  }

  return v5 != v6;
}

uint64_t nw_protocol_swift_wrapper_get_output_handler(void *a1, void *a2)
{
  v28 = *MEMORY[0x1E69E9840];
  v3 = a2;
  v4 = v3;
  if (!a1)
  {
    v17 = __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_protocol_swift_wrapper_get_output_handler";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v8, &type, &v22))
    {
      goto LABEL_17;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_get_output_handler";
        v18 = "%{public}s called with null protocol";
LABEL_52:
        _os_log_impl(&dword_181A37000, v9, v10, v18, buf, 0xCu);
      }
    }

    else
    {
      if (v22 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v9 = __nwlog_obj();
        v10 = type;
        v20 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (!v20)
          {
            goto LABEL_16;
          }

          *buf = 136446466;
          v25 = "nw_protocol_swift_wrapper_get_output_handler";
          v26 = 2082;
          v27 = backtrace_string;
          v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_15:
          _os_log_impl(&dword_181A37000, v9, v10, v15, buf, 0x16u);
LABEL_16:

          free(backtrace_string);
          goto LABEL_17;
        }

        if (!v20)
        {
          goto LABEL_53;
        }

        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_get_output_handler";
        v18 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_52;
      }

      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_get_output_handler";
        v18 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_52;
      }
    }

LABEL_53:

LABEL_17:
    if (!v8)
    {
LABEL_19:
      v12 = 0;
      goto LABEL_20;
    }

LABEL_18:
    free(v8);
    goto LABEL_19;
  }

  v5 = a1[5];
  v6 = a1;
  if (v5 != &nw_protocol_ref_counted_handle)
  {
    if (v5 != &nw_protocol_ref_counted_additional_handle)
    {
      v7 = __nwlog_obj();
      *buf = 136446210;
      v25 = "nw_protocol_swift_wrapper_get_output_handler";
      v8 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v22 = 0;
      if (!__nwlog_fault(v8, &type, &v22))
      {
        goto LABEL_17;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
        {
          goto LABEL_26;
        }

        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_get_output_handler";
        v11 = "%{public}s called with null wrapper";
        goto LABEL_25;
      }

      if (v22 != 1)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
        {
          goto LABEL_26;
        }

        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_get_output_handler";
        v11 = "%{public}s called with null wrapper, backtrace limit exceeded";
        goto LABEL_25;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v14 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v14)
        {
          goto LABEL_26;
        }

        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_get_output_handler";
        v11 = "%{public}s called with null wrapper, no backtrace";
LABEL_25:
        _os_log_impl(&dword_181A37000, v9, v10, v11, buf, 0xCu);
LABEL_26:

        if (!v8)
        {
          goto LABEL_19;
        }

        goto LABEL_18;
      }

      if (!v14)
      {
        goto LABEL_16;
      }

      *buf = 136446466;
      v25 = "nw_protocol_swift_wrapper_get_output_handler";
      v26 = 2082;
      v27 = backtrace_string;
      v15 = "%{public}s called with null wrapper, dumping backtrace:%{public}s";
      goto LABEL_15;
    }

    v6 = a1[8];
  }

  if (v6[14] != v3)
  {
    v19 = __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_protocol_swift_wrapper_get_output_handler";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v8, &type, &v22))
    {
      goto LABEL_17;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_get_output_handler";
        v18 = "%{public}s called with null (wrapper->output_linkage == (nw_object_t)output_linkage)";
        goto LABEL_52;
      }
    }

    else
    {
      if (v22 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v9 = __nwlog_obj();
        v10 = type;
        v21 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (!v21)
          {
            goto LABEL_16;
          }

          *buf = 136446466;
          v25 = "nw_protocol_swift_wrapper_get_output_handler";
          v26 = 2082;
          v27 = backtrace_string;
          v15 = "%{public}s called with null (wrapper->output_linkage == (nw_object_t)output_linkage), dumping backtrace:%{public}s";
          goto LABEL_15;
        }

        if (!v21)
        {
          goto LABEL_53;
        }

        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_get_output_handler";
        v18 = "%{public}s called with null (wrapper->output_linkage == (nw_object_t)output_linkage), no backtrace";
        goto LABEL_52;
      }

      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v25 = "nw_protocol_swift_wrapper_get_output_handler";
        v18 = "%{public}s called with null (wrapper->output_linkage == (nw_object_t)output_linkage), backtrace limit exceeded";
        goto LABEL_52;
      }
    }

    goto LABEL_53;
  }

  v12 = a1[4];
LABEL_20:

  return v12;
}

void nw_protocol_destroy_output_linkage_handle(void *a1, void *a2)
{
  v26 = *MEMORY[0x1E69E9840];
  v3 = a2;
  if (a1)
  {
    v4 = a1[5];
    if (v4 != &nw_protocol_ref_counted_handle)
    {
      if (v4 != &nw_protocol_ref_counted_additional_handle)
      {
        v5 = __nwlog_obj();
        *buf = 136446210;
        v23 = "nw_protocol_destroy_output_linkage_handle";
        v6 = _os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v20 = 0;
        if (!__nwlog_fault(v6, &type, &v20))
        {
          goto LABEL_24;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          v7 = __nwlog_obj();
          v8 = type;
          if (os_log_type_enabled(v7, type))
          {
            *buf = 136446210;
            v23 = "nw_protocol_destroy_output_linkage_handle";
            v9 = "%{public}s called with null wrapper";
LABEL_22:
            _os_log_impl(&dword_181A37000, v7, v8, v9, buf, 0xCu);
            goto LABEL_23;
          }

          goto LABEL_23;
        }

        if (v20 != 1)
        {
          v7 = __nwlog_obj();
          v8 = type;
          if (os_log_type_enabled(v7, type))
          {
            *buf = 136446210;
            v23 = "nw_protocol_destroy_output_linkage_handle";
            v9 = "%{public}s called with null wrapper, backtrace limit exceeded";
            goto LABEL_22;
          }

LABEL_23:

          goto LABEL_24;
        }

        backtrace_string = __nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v8 = type;
        v13 = os_log_type_enabled(v7, type);
        if (!backtrace_string)
        {
          if (v13)
          {
            *buf = 136446210;
            v23 = "nw_protocol_destroy_output_linkage_handle";
            v9 = "%{public}s called with null wrapper, no backtrace";
            goto LABEL_22;
          }

          goto LABEL_23;
        }

        if (v13)
        {
          *buf = 136446466;
          v23 = "nw_protocol_destroy_output_linkage_handle";
          v24 = 2082;
          v25 = backtrace_string;
          v14 = "%{public}s called with null wrapper, dumping backtrace:%{public}s";
LABEL_15:
          _os_log_impl(&dword_181A37000, v7, v8, v14, buf, 0x16u);
          goto LABEL_16;
        }

        goto LABEL_16;
      }

      a1 = a1[8];
    }

    v10 = a1[14];
    if (v10 == v3)
    {
      _nw_protocol_destroy_output_linkage_handle(v10);
      v11 = a1[14];
      a1[14] = 0;

      goto LABEL_26;
    }

    v16 = __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_protocol_destroy_output_linkage_handle";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v6, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (!os_log_type_enabled(v7, type))
        {
          goto LABEL_23;
        }

        *buf = 136446210;
        v23 = "nw_protocol_destroy_output_linkage_handle";
        v9 = "%{public}s called with null (wrapper->output_linkage == (nw_object_t)output_linkage)";
        goto LABEL_22;
      }

      if (v20 != 1)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (!os_log_type_enabled(v7, type))
        {
          goto LABEL_23;
        }

        *buf = 136446210;
        v23 = "nw_protocol_destroy_output_linkage_handle";
        v9 = "%{public}s called with null (wrapper->output_linkage == (nw_object_t)output_linkage), backtrace limit exceeded";
        goto LABEL_22;
      }

      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v19 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v19)
        {
          goto LABEL_23;
        }

        *buf = 136446210;
        v23 = "nw_protocol_destroy_output_linkage_handle";
        v9 = "%{public}s called with null (wrapper->output_linkage == (nw_object_t)output_linkage), no backtrace";
        goto LABEL_22;
      }

      if (v19)
      {
        *buf = 136446466;
        v23 = "nw_protocol_destroy_output_linkage_handle";
        v24 = 2082;
        v25 = backtrace_string;
        v14 = "%{public}s called with null (wrapper->output_linkage == (nw_object_t)output_linkage), dumping backtrace:%{public}s";
        goto LABEL_15;
      }

LABEL_16:

      free(backtrace_string);
      if (!v6)
      {
        goto LABEL_26;
      }

      goto LABEL_25;
    }
  }

  else
  {
    v15 = __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_protocol_destroy_output_linkage_handle";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v6, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (!os_log_type_enabled(v7, type))
        {
          goto LABEL_23;
        }

        *buf = 136446210;
        v23 = "nw_protocol_destroy_output_linkage_handle";
        v9 = "%{public}s called with null protocol";
        goto LABEL_22;
      }

      if (v20 != 1)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (!os_log_type_enabled(v7, type))
        {
          goto LABEL_23;
        }

        *buf = 136446210;
        v23 = "nw_protocol_destroy_output_linkage_handle";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_22;
      }

      v17 = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v18 = os_log_type_enabled(v7, type);
      if (!v17)
      {
        if (!v18)
        {
          goto LABEL_23;
        }

        *buf = 136446210;
        v23 = "nw_protocol_destroy_output_linkage_handle";
        v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_22;
      }

      if (v18)
      {
        *buf = 136446466;
        v23 = "nw_protocol_destroy_output_linkage_handle";
        v24 = 2082;
        v25 = v17;
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v17);
    }
  }

LABEL_24:
  if (v6)
  {
LABEL_25:
    free(v6);
  }

LABEL_26:
}

uint64_t nw_browser_get_description(void *a1)
{
  v26 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = BYTE2(v1[49]._os_unfair_lock_opaque);
    os_unfair_lock_lock(v1 + 2);
    if (v3 == 1)
    {
      v4 = v2 + 44;
      if (!*&v2[44]._os_unfair_lock_opaque)
      {
        v5 = _nw_parameters_copy_description(*&v2[10]._os_unfair_lock_opaque);
        os_unfair_lock_opaque = v2[48]._os_unfair_lock_opaque;
        description = nw_browse_descriptor_get_description(*&v2[8]._os_unfair_lock_opaque, 1);
        asprintf(&v2[44], "[B%u %s, %s]", os_unfair_lock_opaque, description, v5);
        goto LABEL_7;
      }
    }

    else
    {
      v4 = v2 + 46;
      if (!*&v2[46]._os_unfair_lock_opaque)
      {
        v5 = _nw_parameters_copy_description(*&v2[10]._os_unfair_lock_opaque);
        v8 = v2[48]._os_unfair_lock_opaque;
        v9 = nw_browse_descriptor_get_description(*&v2[8]._os_unfair_lock_opaque, 0);
        asprintf(&v2[46], "[B%u %s, %s]", v8, v9, v5);
LABEL_7:
        if (v5)
        {
          free(v5);
        }
      }
    }

    os_unfair_lock_unlock(v2 + 2);
    v10 = *&v4->_os_unfair_lock_opaque;
    goto LABEL_10;
  }

  v12 = __nwlog_obj();
  *buf = 136446210;
  v23 = "nw_browser_get_description";
  v13 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v23 = "nw_browser_get_description";
        _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null browser", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v17 = type;
      v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *buf = 136446466;
          v23 = "nw_browser_get_description";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v14, v17, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v18)
      {
        *buf = 136446210;
        v23 = "nw_browser_get_description";
        _os_log_impl(&dword_181A37000, v14, v17, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v14 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v23 = "nw_browser_get_description";
        _os_log_impl(&dword_181A37000, v14, v19, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_27:
  if (v13)
  {
    free(v13);
  }

  v10 = 0;
LABEL_10:

  return v10;
}

void sub_182893718(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, objc_super a14)
{
  a14.super_class = NWConcrete_nw_browser;
  [(_Unwind_Exception *)&a14 dealloc];
  _Unwind_Resume(a1);
}

void ___ZL38nw_browser_start_custom_browser_lockedP21NWConcrete_nw_browser_block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = *(a1 + 40);
  v3 = v1[4];
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3221225472;
  v4[2] = ___ZL38nw_browser_start_custom_browser_lockedP21NWConcrete_nw_browser_block_invoke_2;
  v4[3] = &unk_1E6A35D90;
  v5 = v1;
  (*(v2 + 16))(v2, v3, v4);
}

BOOL nw_browser_fail_on_dns_error_locked(NWConcrete_nw_browser *a1, int a2, const char *a3)
{
  v22 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = v5;
  if (a2)
  {
    if (!nw_parameters_get_logging_disabled(*(v5 + 5)))
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v7 = gbrowserLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        v8 = *(v6 + 48);
        v12 = 136447234;
        v13 = "nw_browser_fail_on_dns_error_locked";
        v14 = 1024;
        v15 = v8;
        v16 = 2082;
        v17 = a3;
        v18 = 2082;
        string_for_dns_service_error = nwlog_get_string_for_dns_service_error(a2);
        v20 = 1024;
        v21 = a2;
        _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_ERROR, "%{public}s [B%u] %{public}s failed: %{public}s(%d)", &v12, 0x2Cu);
      }
    }

    dns_error = nw_error_create_dns_error(a2);
    if (a2 == -65570)
    {
      v10 = 4;
    }

    else
    {
      nw_browser_cancel_dns_browser_locked(v6);
      v10 = 2;
    }

    nw_browser_set_state_locked(v6, v10, dns_error);
  }

  return a2 != 0;
}

uint64_t nw_browser_derive_endpoint_flags(NWConcrete_nw_browser *a1)
{
  v1 = a1;
  traffic_class = nw_parameters_get_traffic_class(*(v1 + 5));
  prohibit_cellular = nw_parameters_get_prohibit_cellular(*(v1 + 5));
  prohibit_expensive = nw_parameters_get_prohibit_expensive(*(v1 + 5));
  prohibit_constrained = nw_parameters_get_prohibit_constrained(*(v1 + 5));
  use_awdl = nw_parameters_get_use_awdl(*(v1 + 5));
  use_p2p = nw_parameters_get_use_p2p(*(v1 + 5));
  if (traffic_class == 100)
  {
    v8 = 1074282496;
  }

  else
  {
    v8 = 1073758208;
  }

  if (prohibit_cellular)
  {
    v8 |= 0x8000000u;
  }

  if (prohibit_expensive)
  {
    v8 |= 0x20000000u;
  }

  if (prohibit_constrained)
  {
    v8 |= 0x2000u;
  }

  if (use_awdl)
  {
    v8 |= 0x100000u;
  }

  if (use_p2p)
  {
    v9 = v8 | 0x20000;
  }

  else
  {
    v9 = v8;
  }

  return v9;
}

uint64_t ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_2(uint64_t a1, const char *a2, void *a3)
{
  v15 = *MEMORY[0x1E69E9840];
  v5 = a3;
  if (!nw_parameters_get_logging_disabled(*(*(a1 + 32) + 40)))
  {
    if (__nwlog_browser_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
    }

    v6 = gbrowserLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      v7 = *(*(a1 + 32) + 192);
      v9 = 136446722;
      v10 = "nw_browser_update_path_browser_locked_block_invoke_2";
      v11 = 1024;
      v12 = v7;
      v13 = 2114;
      v14 = v5;
      _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] Removing defunct flow registration %{public}@", &v9, 0x1Cu);
    }
  }

  nw_path_flow_registration_close(v5);
  nw_dictionary_set_value(*(*(a1 + 32) + 104), a2, 0);

  return 1;
}

uint64_t __Block_byref_object_copy__59106(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

void ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_122(uint64_t a1)
{
  count = nw_parallel_array_get_count(*(a1 + 32));
  v4[0] = MEMORY[0x1E69E9820];
  v4[1] = 3221225472;
  v4[2] = ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_2_123;
  v4[3] = &unk_1E6A35F20;
  v3 = *(a1 + 32);
  v5 = *(a1 + 40);
  v6 = *(a1 + 48);
  v7 = count;
  nw_parallel_array_apply(v3, v4);
}

uint64_t ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_112(uint64_t a1, uint64_t a2, void *a3)
{
  v29 = *MEMORY[0x1E69E9840];
  v4 = a3;
  v5 = nw_endpoint_copy_interface(v4);
  v16 = 0;
  v17 = &v16;
  v18 = 0x2020000000;
  v19 = 1;
  v6 = *(*(a1 + 32) + 136);
  aBlock[0] = MEMORY[0x1E69E9820];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_2_113;
  aBlock[3] = &unk_1E6A35E30;
  v7 = v4;
  v13 = v7;
  v8 = v5;
  v14 = v8;
  v15 = &v16;
  if (!v6 || (_nw_array_apply(v6, aBlock), (v17[3] & 1) != 0))
  {
    v9 = nw_endpoint_copy(v7);
    nw_endpoint_set_interface(v9, 0);
    bzero(v28, 0x3F1uLL);
    nw_browser_copy_key_for_endpoint(v9, v28);
    if ((nw_browser_add_result_locked(*(a1 + 32), v28, v9, v8, 1) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446978;
        v21 = "nw_browser_update_path_browser_locked_block_invoke";
        v22 = 2080;
        v23 = v28;
        v24 = 2112;
        v25 = v9;
        v26 = 2112;
        v27 = v8;
        _os_log_impl(&dword_181A37000, v10, OS_LOG_TYPE_ERROR, "%{public}s Failed to add result for %s/%@ (%@)", buf, 0x2Au);
      }
    }
  }

  _Block_object_dispose(&v16, 8);
  return 1;
}

void sub_182893EE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, void *a8, uint64_t a9, ...)
{
  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_115(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  if (nw_browse_result_get_discovered_from_path(v4))
  {
    endpoint = nw_browse_result_get_endpoint(v4);
    if (nw_browse_result_get_interfaces_count(v4))
    {
      enumerator[0] = MEMORY[0x1E69E9820];
      enumerator[1] = 3221225472;
      enumerator[2] = ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_2_116;
      enumerator[3] = &unk_1E6A35E58;
      v8 = *(a1 + 32);
      v9 = *(a1 + 40);
      v10 = endpoint;
      nw_browse_result_enumerate_interfaces(v4, enumerator);
    }

    else
    {
      nw_browser_check_and_remove_endpoints_locked(*(a1 + 32), *(a1 + 40), endpoint, 0);
    }
  }

  return 1;
}

void nw_browser_notify_browse_result_changes_locked(NWConcrete_nw_browser *a1)
{
  v62 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (!*(v1 + 2))
  {
    v24 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_browser_notify_browse_result_changes_locked";
    v25 = _os_log_send_and_compose_impl();

    v59[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v25, v59, type))
    {
      if (v59[0] == 17)
      {
        v26 = __nwlog_obj();
        v27 = v59[0];
        if (os_log_type_enabled(v26, v59[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_notify_browse_result_changes_locked";
          _os_log_impl(&dword_181A37000, v26, v27, "%{public}s called with null browser->client_queue", buf, 0xCu);
        }
      }

      else if (type[0] == OS_LOG_TYPE_INFO)
      {
        backtrace_string = __nw_create_backtrace_string();
        v26 = __nwlog_obj();
        v29 = v59[0];
        v30 = os_log_type_enabled(v26, v59[0]);
        if (backtrace_string)
        {
          if (v30)
          {
            *buf = 136446466;
            *&buf[4] = "nw_browser_notify_browse_result_changes_locked";
            *&buf[12] = 2082;
            *&buf[14] = backtrace_string;
            _os_log_impl(&dword_181A37000, v26, v29, "%{public}s called with null browser->client_queue, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_45;
        }

        if (v30)
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_notify_browse_result_changes_locked";
          _os_log_impl(&dword_181A37000, v26, v29, "%{public}s called with null browser->client_queue, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v26 = __nwlog_obj();
        v31 = v59[0];
        if (os_log_type_enabled(v26, v59[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_notify_browse_result_changes_locked";
          _os_log_impl(&dword_181A37000, v26, v31, "%{public}s called with null browser->client_queue, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_45:
    if (v25)
    {
      free(v25);
    }

    goto LABEL_18;
  }

  if (*(v1 + 18) == 1)
  {
    v3 = xpc_dictionary_create(0, 0, 0);
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x3032000000;
    v56 = __Block_byref_object_copy__59106;
    v57 = __Block_byref_object_dispose__59107;
    v58 = nw_parallel_array_create();
    v4 = *(v2 + 20);
    applier[0] = MEMORY[0x1E69E9820];
    applier[1] = 3221225472;
    applier[2] = ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke;
    applier[3] = &unk_1E6A35F48;
    v5 = v3;
    v46 = v5;
    v6 = v2;
    v47 = v6;
    v48 = buf;
    xpc_dictionary_apply(v4, applier);
    v7 = *(*&buf[8] + 40);
    if (nw_browse_descriptor_get_type(*(v6 + 4)) != 2)
    {
      v15 = v7;
LABEL_14:
      v18 = _Block_copy(*(v6 + 7));
      count = nw_parallel_array_get_count(v15);
      if (v18)
      {
        v20 = count;
        if (count)
        {
          v21 = *(v2 + 2);
          block[0] = MEMORY[0x1E69E9820];
          block[1] = 3221225472;
          block[2] = ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke_127;
          block[3] = &unk_1E6A35F70;
          v41 = v15;
          v42 = v6;
          v44 = v20;
          v43 = v18;
          dispatch_async(v21, block);
        }
      }

      v22 = *(v2 + 20);
      *(v2 + 20) = v5;
      v23 = v5;

      _Block_object_dispose(buf, 8);
      goto LABEL_18;
    }

    v8 = *(*&buf[8] + 40);
    v9 = v6;
    v10 = v8;
    if (v10)
    {
      v11 = nw_parallel_array_create();
      *v59 = MEMORY[0x1E69E9820];
      *&v59[8] = 3221225472;
      *&v59[16] = ___ZL31nw_browser_create_ordered_arrayP21NWConcrete_nw_browserPU31objcproto20OS_nw_parallel_array8NSObject_block_invoke;
      v60 = &unk_1E6A35F98;
      v12 = v11;
      v61 = v12;
      nw_parallel_array_apply(v10, v59);
      *type = MEMORY[0x1E69E9820];
      v50 = 3221225472;
      v51 = ___ZL31nw_browser_create_ordered_arrayP21NWConcrete_nw_browserPU31objcproto20OS_nw_parallel_array8NSObject_block_invoke_2;
      v52 = &unk_1E6A35F98;
      v13 = v12;
      v53 = v13;
      nw_parallel_array_apply(v10, type);
      v14 = v53;
      v15 = v13;

LABEL_6:
      goto LABEL_14;
    }

    v32 = __nwlog_obj();
    *v59 = 136446210;
    *&v59[4] = "nw_browser_create_ordered_array";
    v33 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (__nwlog_fault(v33, type, &v54))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v34 = __nwlog_obj();
        v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *v59 = 136446210;
          *&v59[4] = "nw_browser_create_ordered_array";
          _os_log_impl(&dword_181A37000, v34, v35, "%{public}s called with null results", v59, 0xCu);
        }
      }

      else if (v54 == 1)
      {
        v36 = __nw_create_backtrace_string();
        v34 = __nwlog_obj();
        v39 = type[0];
        v37 = os_log_type_enabled(v34, type[0]);
        if (v36)
        {
          if (v37)
          {
            *v59 = 136446466;
            *&v59[4] = "nw_browser_create_ordered_array";
            *&v59[12] = 2082;
            *&v59[14] = v36;
            _os_log_impl(&dword_181A37000, v34, v39, "%{public}s called with null results, dumping backtrace:%{public}s", v59, 0x16u);
          }

          free(v36);
          goto LABEL_53;
        }

        if (v37)
        {
          *v59 = 136446210;
          *&v59[4] = "nw_browser_create_ordered_array";
          _os_log_impl(&dword_181A37000, v34, v39, "%{public}s called with null results, no backtrace", v59, 0xCu);
        }
      }

      else
      {
        v34 = __nwlog_obj();
        v38 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *v59 = 136446210;
          *&v59[4] = "nw_browser_create_ordered_array";
          _os_log_impl(&dword_181A37000, v34, v38, "%{public}s called with null results, backtrace limit exceeded", v59, 0xCu);
        }
      }
    }

LABEL_53:
    if (v33)
    {
      free(v33);
    }

    v15 = 0;
    goto LABEL_6;
  }

  if (!nw_parameters_get_logging_disabled(*(v1 + 5)))
  {
    if (__nwlog_browser_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
    }

    v16 = gbrowserLogObj;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      v17 = *(v2 + 48);
      *buf = 136446466;
      *&buf[4] = "nw_browser_notify_browse_result_changes_locked";
      *&buf[12] = 1024;
      *&buf[14] = v17;
      _os_log_impl(&dword_181A37000, v16, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] not in ready state", buf, 0x12u);
    }
  }

LABEL_18:
}

void sub_1828948B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, id a40)
{
  _Block_object_dispose(&a35, 8);

  _Unwind_Resume(a1);
}

uint64_t ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke(uint64_t a1, const char *a2, void *a3)
{
  v101 = *MEMORY[0x1E69E9840];
  v5 = a3;
  value = xpc_uint64_get_value(v5);
  v7 = value;
  if (value)
  {
    if ((value & 4) == 0)
    {
      xpc_dictionary_set_uint64(*(a1 + 32), a2, 1uLL);
      if (!nw_parameters_get_logging_disabled(*(*(a1 + 40) + 40)))
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v8 = gbrowserLogObj;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v9 = *(*(a1 + 40) + 192);
          *buf = 136446978;
          v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          v95 = 1024;
          *v96 = v9;
          *&v96[4] = 2080;
          *&v96[6] = a2;
          v97 = 1024;
          LODWORD(v98) = 1;
          _os_log_impl(&dword_181A37000, v8, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s = identical(%d)", buf, 0x22u);
        }
      }

      if (v7 == 1)
      {
        v10 = 1;
        goto LABEL_74;
      }
    }

    v11 = nw_browser_copy_old_result_locked(*(a1 + 40), a2);
    v12 = nw_browser_copy_new_result_locked(*(a1 + 40), a2);
    v13 = v12;
    v14 = *(a1 + 40);
    if (*(v14 + 196) == 1 && (v7 & 0x22) == 2)
    {
      xpc_dictionary_set_uint64(*(a1 + 32), a2, v7);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = gLogObj;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446466;
        v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        v95 = 2080;
        *v96 = a2;
        _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_DEBUG, "%{public}s changes_map: %s was added but delaying notify until TXT record is found", buf, 0x16u);
      }

      goto LABEL_72;
    }

    if ((~v7 & 6) == 0)
    {
      v54 = __nwlog_obj();
      *buf = 136446210;
      v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
      v55 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v91 = 0;
      if (!__nwlog_fault(v55, &type, &v91))
      {
        goto LABEL_193;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v56 = __nwlog_obj();
        v57 = type;
        if (os_log_type_enabled(v56, type))
        {
          *buf = 136446210;
          v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_181A37000, v56, v57, "%{public}s Cannot have both add and remove at the same time", buf, 0xCu);
        }

        goto LABEL_192;
      }

      if (v91 != 1)
      {
        v56 = __nwlog_obj();
        v74 = type;
        if (os_log_type_enabled(v56, type))
        {
          *buf = 136446210;
          v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_181A37000, v56, v74, "%{public}s Cannot have both add and remove at the same time, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_192;
      }

      backtrace_string = __nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v62 = type;
      v63 = os_log_type_enabled(v56, type);
      if (!backtrace_string)
      {
        if (v63)
        {
          *buf = 136446210;
          v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_181A37000, v56, v62, "%{public}s Cannot have both add and remove at the same time, no backtrace", buf, 0xCu);
        }

        goto LABEL_192;
      }

      if (v63)
      {
        *buf = 136446466;
        v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        v95 = 2082;
        *v96 = backtrace_string;
        _os_log_impl(&dword_181A37000, v56, v62, "%{public}s Cannot have both add and remove at the same time, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_159;
    }

    if ((v7 & 2) != 0)
    {
      if (!v11 && v12)
      {
        v22 = *(v14 + 136);
        if (!v22)
        {
          goto LABEL_47;
        }

        goto LABEL_45;
      }

      v64 = __nwlog_obj();
      *buf = 136446210;
      v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
      v55 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v91 = 0;
      if (!__nwlog_fault(v55, &type, &v91))
      {
        goto LABEL_193;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v56 = __nwlog_obj();
        v65 = type;
        if (os_log_type_enabled(v56, type))
        {
          *buf = 136446210;
          v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_181A37000, v56, v65, "%{public}s Unexpected result pair for add", buf, 0xCu);
        }

        goto LABEL_192;
      }

      if (v91 != 1)
      {
        v56 = __nwlog_obj();
        v87 = type;
        if (os_log_type_enabled(v56, type))
        {
          *buf = 136446210;
          v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_181A37000, v56, v87, "%{public}s Unexpected result pair for add, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_192;
      }

      backtrace_string = __nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v77 = type;
      v78 = os_log_type_enabled(v56, type);
      if (!backtrace_string)
      {
        if (v78)
        {
          *buf = 136446210;
          v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_181A37000, v56, v77, "%{public}s Unexpected result pair for add, no backtrace", buf, 0xCu);
        }

        goto LABEL_192;
      }

      if (v78)
      {
        *buf = 136446466;
        v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        v95 = 2082;
        *v96 = backtrace_string;
        _os_log_impl(&dword_181A37000, v56, v77, "%{public}s Unexpected result pair for add, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_159:

      free(backtrace_string);
      goto LABEL_193;
    }

    if ((v7 & 4) == 0)
    {
      if (!v11 || !v12)
      {
        v75 = __nwlog_obj();
        *buf = 136446210;
        v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        v55 = _os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v91 = 0;
        if (!__nwlog_fault(v55, &type, &v91))
        {
          goto LABEL_193;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          v56 = __nwlog_obj();
          v76 = type;
          if (os_log_type_enabled(v56, type))
          {
            *buf = 136446210;
            v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            _os_log_impl(&dword_181A37000, v56, v76, "%{public}s Unexpected result pair for change", buf, 0xCu);
          }

          goto LABEL_192;
        }

        if (v91 != 1)
        {
          v56 = __nwlog_obj();
          v90 = type;
          if (os_log_type_enabled(v56, type))
          {
            *buf = 136446210;
            v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            _os_log_impl(&dword_181A37000, v56, v90, "%{public}s Unexpected result pair for change, backtrace limit exceeded", buf, 0xCu);
          }

          goto LABEL_192;
        }

        backtrace_string = __nw_create_backtrace_string();
        v56 = __nwlog_obj();
        v85 = type;
        v86 = os_log_type_enabled(v56, type);
        if (!backtrace_string)
        {
          if (v86)
          {
            *buf = 136446210;
            v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            _os_log_impl(&dword_181A37000, v56, v85, "%{public}s Unexpected result pair for change, no backtrace", buf, 0xCu);
          }

          goto LABEL_192;
        }

        if (v86)
        {
          *buf = 136446466;
          v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          v95 = 2082;
          *v96 = backtrace_string;
          _os_log_impl(&dword_181A37000, v56, v85, "%{public}s Unexpected result pair for change, dumping backtrace:%{public}s", buf, 0x16u);
        }

        goto LABEL_159;
      }

      v16 = *(v14 + 136);
      if (v16)
      {
LABEL_21:
        v17 = _nw_array_get_count(v16) - 1;
        v18 = *(*(a1 + 40) + 136);
        v19 = v11;
        if (v18)
        {
          v20 = _nw_array_duplicate_array_without_object(v18, v19);
LABEL_34:
          v24 = v20;

          v25 = *(a1 + 40);
          v26 = *(v25 + 136);
          *(v25 + 136) = v24;

          if (!nw_parameters_get_logging_disabled(*(*(a1 + 40) + 40)))
          {
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v27 = gbrowserLogObj;
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
            {
              v28 = *(*(a1 + 40) + 192);
              *buf = 136446722;
              v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
              v95 = 1024;
              *v96 = v28;
              *&v96[4] = 2112;
              *&v96[6] = v11;
              _os_log_impl(&dword_181A37000, v27, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] old: removed %@ from old_results", buf, 0x1Cu);
            }
          }

          count = *(*(a1 + 40) + 136);
          if (count)
          {
            count = _nw_array_get_count(count);
          }

          if (v17 == count)
          {
            if (!v13)
            {
LABEL_61:
              if (nw_browse_result_get_changes(v11, v13) == 1)
              {
                if (!nw_parameters_get_logging_disabled(*(*(a1 + 40) + 40)))
                {
                  changes = nw_browse_result_get_changes(v11, v13);
                  v43 = nw_browse_result_get_change_description(changes);
                  if (!nw_parameters_get_logging_disabled(*(*(a1 + 40) + 40)))
                  {
                    if (__nwlog_browser_log::onceToken != -1)
                    {
                      dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
                    }

                    v44 = gbrowserLogObj;
                    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
                    {
                      v45 = *(*(a1 + 40) + 192);
                      *buf = 136447234;
                      v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
                      v95 = 1024;
                      *v96 = v45;
                      *&v96[4] = 2112;
                      *&v96[6] = v11;
                      v97 = 2112;
                      v98 = v13;
                      v99 = 2082;
                      v100 = v43;
                      _os_log_impl(&dword_181A37000, v44, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] Suppressing identical results: (%@ -> %@), %{public}s", buf, 0x30u);
                    }
                  }

                  if (v43)
                  {
                    free(v43);
                  }
                }
              }

              else
              {
                nw_parallel_array_append(*(*(*(a1 + 48) + 8) + 40), v11, v13);
              }

LABEL_72:
              v10 = 1;
LABEL_73:

              goto LABEL_74;
            }

            v14 = *(a1 + 40);
            v22 = *(v14 + 136);
            if (!v22)
            {
LABEL_47:
              v30 = *(v14 + 144);
              if (v30)
              {
                v31 = _nw_array_get_count(v30) - 1;
                v32 = *(*(a1 + 40) + 144);
                v33 = v13;
                if (v32)
                {
                  v34 = _nw_array_duplicate_array_without_object(v32, v33);
                  goto LABEL_52;
                }
              }

              else
              {
                v35 = v13;
                v32 = 0;
                v31 = -1;
              }

              v34 = _nw_array_create();
LABEL_52:
              v36 = v34;

              v37 = *(a1 + 40);
              v38 = *(v37 + 144);
              *(v37 + 144) = v36;

              v39 = *(*(a1 + 40) + 144);
              if (v39)
              {
                v39 = _nw_array_get_count(v39);
              }

              if (v31 == v39)
              {
                if (!nw_parameters_get_logging_disabled(*(*(a1 + 40) + 40)))
                {
                  if (__nwlog_browser_log::onceToken != -1)
                  {
                    dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
                  }

                  v40 = gbrowserLogObj;
                  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
                  {
                    v41 = *(*(a1 + 40) + 192);
                    *buf = 136446722;
                    v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
                    v95 = 1024;
                    *v96 = v41;
                    *&v96[4] = 2112;
                    *&v96[6] = v13;
                    _os_log_impl(&dword_181A37000, v40, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] new: moved %@ from new_results to old_results", buf, 0x1Cu);
                  }
                }

                goto LABEL_61;
              }

              v58 = __nwlog_obj();
              *buf = 136446210;
              v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
              v55 = _os_log_send_and_compose_impl();

              type = OS_LOG_TYPE_ERROR;
              v91 = 0;
              if (__nwlog_fault(v55, &type, &v91))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  v56 = __nwlog_obj();
                  v59 = type;
                  if (os_log_type_enabled(v56, type))
                  {
                    *buf = 136446210;
                    v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
                    _os_log_impl(&dword_181A37000, v56, v59, "%{public}s Should have removed from new results", buf, 0xCu);
                  }

LABEL_192:

                  goto LABEL_193;
                }

                if (v91 != 1)
                {
                  v56 = __nwlog_obj();
                  v81 = type;
                  if (os_log_type_enabled(v56, type))
                  {
                    *buf = 136446210;
                    v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
                    _os_log_impl(&dword_181A37000, v56, v81, "%{public}s Should have removed from new results, backtrace limit exceeded", buf, 0xCu);
                  }

                  goto LABEL_192;
                }

                backtrace_string = __nw_create_backtrace_string();
                v56 = __nwlog_obj();
                v68 = type;
                v69 = os_log_type_enabled(v56, type);
                if (!backtrace_string)
                {
                  if (v69)
                  {
                    *buf = 136446210;
                    v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
                    _os_log_impl(&dword_181A37000, v56, v68, "%{public}s Should have removed from new results, no backtrace", buf, 0xCu);
                  }

                  goto LABEL_192;
                }

                if (v69)
                {
                  *buf = 136446466;
                  v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
                  v95 = 2082;
                  *v96 = backtrace_string;
                  _os_log_impl(&dword_181A37000, v56, v68, "%{public}s Should have removed from new results, dumping backtrace:%{public}s", buf, 0x16u);
                }

                goto LABEL_159;
              }

LABEL_193:
              if (v55)
              {
                free(v55);
              }

              v10 = 0;
              goto LABEL_73;
            }

LABEL_45:
            if (v13)
            {
              _nw_array_append(v22, v13);
              v14 = *(a1 + 40);
            }

            goto LABEL_47;
          }

          v66 = __nwlog_obj();
          *buf = 136446210;
          v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          v55 = _os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v91 = 0;
          if (!__nwlog_fault(v55, &type, &v91))
          {
            goto LABEL_193;
          }

          if (type == OS_LOG_TYPE_FAULT)
          {
            v56 = __nwlog_obj();
            v67 = type;
            if (os_log_type_enabled(v56, type))
            {
              *buf = 136446210;
              v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
              _os_log_impl(&dword_181A37000, v56, v67, "%{public}s Should have removed old result", buf, 0xCu);
            }

            goto LABEL_192;
          }

          if (v91 != 1)
          {
            v56 = __nwlog_obj();
            v88 = type;
            if (os_log_type_enabled(v56, type))
            {
              *buf = 136446210;
              v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
              _os_log_impl(&dword_181A37000, v56, v88, "%{public}s Should have removed old result, backtrace limit exceeded", buf, 0xCu);
            }

            goto LABEL_192;
          }

          backtrace_string = __nw_create_backtrace_string();
          v56 = __nwlog_obj();
          v79 = type;
          v80 = os_log_type_enabled(v56, type);
          if (!backtrace_string)
          {
            if (v80)
            {
              *buf = 136446210;
              v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
              _os_log_impl(&dword_181A37000, v56, v79, "%{public}s Should have removed old result, no backtrace", buf, 0xCu);
            }

            goto LABEL_192;
          }

          if (v80)
          {
            *buf = 136446466;
            v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            v95 = 2082;
            *v96 = backtrace_string;
            _os_log_impl(&dword_181A37000, v56, v79, "%{public}s Should have removed old result, dumping backtrace:%{public}s", buf, 0x16u);
          }

          goto LABEL_159;
        }

LABEL_33:
        v20 = _nw_array_create();
        goto LABEL_34;
      }

LABEL_32:
      v23 = v11;
      v18 = 0;
      v17 = -1;
      goto LABEL_33;
    }

    if (v11)
    {
      v13 = 0;
      v16 = *(*(a1 + 40) + 136);
      if (v16)
      {
        goto LABEL_21;
      }

      goto LABEL_32;
    }

    v70 = __nwlog_obj();
    *buf = 136446210;
    v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
    v71 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (__nwlog_fault(v71, &type, &v91))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v72 = __nwlog_obj();
        v73 = type;
        if (os_log_type_enabled(v72, type))
        {
          *buf = 136446210;
          v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_181A37000, v72, v73, "%{public}s Unexpected result pair for remove", buf, 0xCu);
        }
      }

      else if (v91 == 1)
      {
        v82 = __nw_create_backtrace_string();
        v72 = __nwlog_obj();
        v83 = type;
        v84 = os_log_type_enabled(v72, type);
        if (v82)
        {
          if (v84)
          {
            *buf = 136446466;
            v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            v95 = 2082;
            *v96 = v82;
            _os_log_impl(&dword_181A37000, v72, v83, "%{public}s Unexpected result pair for remove, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v82);
          goto LABEL_187;
        }

        if (v84)
        {
          *buf = 136446210;
          v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_181A37000, v72, v83, "%{public}s Unexpected result pair for remove, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v72 = __nwlog_obj();
        v89 = type;
        if (os_log_type_enabled(v72, type))
        {
          *buf = 136446210;
          v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_181A37000, v72, v89, "%{public}s Unexpected result pair for remove, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_187:
    if (v71)
    {
      free(v71);
    }

    v13 = 0;
    v10 = 0;
    goto LABEL_73;
  }

  v47 = __nwlog_obj();
  *buf = 136446210;
  v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
  v48 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v91 = 0;
  if (__nwlog_fault(v48, &type, &v91))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v49 = __nwlog_obj();
      v50 = type;
      if (os_log_type_enabled(v49, type))
      {
        *buf = 136446210;
        v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        _os_log_impl(&dword_181A37000, v49, v50, "%{public}s new_results should not have invalid changes", buf, 0xCu);
      }
    }

    else if (v91 == 1)
    {
      v51 = __nw_create_backtrace_string();
      v49 = __nwlog_obj();
      v52 = type;
      v53 = os_log_type_enabled(v49, type);
      if (v51)
      {
        if (v53)
        {
          *buf = 136446466;
          v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          v95 = 2082;
          *v96 = v51;
          _os_log_impl(&dword_181A37000, v49, v52, "%{public}s new_results should not have invalid changes, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v51);
        goto LABEL_121;
      }

      if (v53)
      {
        *buf = 136446210;
        v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        _os_log_impl(&dword_181A37000, v49, v52, "%{public}s new_results should not have invalid changes, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v49 = __nwlog_obj();
      v60 = type;
      if (os_log_type_enabled(v49, type))
      {
        *buf = 136446210;
        v94 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        _os_log_impl(&dword_181A37000, v49, v60, "%{public}s new_results should not have invalid changes, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_121:
  if (v48)
  {
    free(v48);
  }

  v10 = 0;
LABEL_74:

  return v10;
}

uint64_t ___ZL31nw_browser_create_ordered_arrayP21NWConcrete_nw_browserPU31objcproto20OS_nw_parallel_array8NSObject_block_invoke(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  v6 = a3;
  v7 = a4;
  v8 = v6;
  v9 = v7;
  if ((nw_browse_result_get_changes(v8, v9) & 4) != 0)
  {
    nw_parallel_array_append(*(a1 + 32), v8, v9);
  }

  return 1;
}

uint64_t ___ZL31nw_browser_create_ordered_arrayP21NWConcrete_nw_browserPU31objcproto20OS_nw_parallel_array8NSObject_block_invoke_2(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  v6 = a3;
  v7 = a4;
  v8 = v6;
  v9 = v7;
  if ((nw_browse_result_get_changes(v8, v9) & 4) == 0)
  {
    nw_parallel_array_append(*(a1 + 32), v8, v9);
  }

  return 1;
}

void ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke_127(uint64_t a1)
{
  v6[0] = MEMORY[0x1E69E9820];
  v6[1] = 3221225472;
  v6[2] = ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke_2;
  v6[3] = &unk_1E6A35F20;
  v2 = *(a1 + 32);
  v3 = *(a1 + 40);
  v5 = *(a1 + 48);
  v4 = *(a1 + 56);
  v7 = v3;
  v9 = v4;
  v8 = v5;
  nw_parallel_array_apply(v2, v6);
}

uint64_t ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke_2(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  v39 = *MEMORY[0x1E69E9840];
  v7 = a3;
  v8 = a4;
  v9 = v7;
  v10 = v8;
  v11 = v10;
  v12 = v9;
  if (nw_browse_descriptor_get_type(*(*(a1 + 32) + 32)) == 2)
  {
    if (v9 && (mutable_copy = nw_browse_result_create_mutable_copy(v9), v9, mutable_copy))
    {
      *(mutable_copy + 52) |= 1u;
      v12 = mutable_copy;
      if (!v10)
      {
LABEL_5:
        v11 = 0;
        v14 = *(a1 + 48);
        goto LABEL_10;
      }
    }

    else
    {
      v12 = 0;
      if (!v10)
      {
        goto LABEL_5;
      }
    }

    v11 = nw_browse_result_create_mutable_copy(v10);
  }

  v14 = *(a1 + 48);
  if (v11)
  {
    *(v11 + 52) |= 1u;
  }

LABEL_10:
  v15 = v14 - 1 == a2;
  if (!nw_parameters_get_logging_disabled(*(*(a1 + 32) + 40)))
  {
    changes = nw_browse_result_get_changes(v12, v11);
    v17 = nw_browse_result_get_change_description(changes);
    if (!nw_parameters_get_logging_disabled(*(*(a1 + 32) + 40)))
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v18 = gbrowserLogObj;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        v19 = *(*(a1 + 32) + 192);
        *buf = 136447234;
        v30 = "nw_browser_notify_browse_result_changes_locked_block_invoke_2";
        v31 = 1024;
        v32 = v19;
        v33 = 2112;
        v34 = v12;
        v35 = 2112;
        v36 = v11;
        v37 = 2082;
        v38 = v17;
        _os_log_impl(&dword_181A37000, v18, OS_LOG_TYPE_INFO, "%{public}s [B%u] browse_result_changed: (%@ -> %@), %{public}s", buf, 0x30u);
      }
    }

    if (v17)
    {
      free(v17);
    }
  }

  v20 = *(*(a1 + 32) + 40);
  v24[0] = MEMORY[0x1E69E9820];
  v24[1] = 3221225472;
  v24[2] = ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke_128;
  v24[3] = &unk_1E6A39CC0;
  v27 = *(a1 + 40);
  v21 = v12;
  v25 = v21;
  v22 = v11;
  v26 = v22;
  v28 = v15;
  nw_utilities_execute_block_as_persona_from_parameters(v20, v24);

  return 1;
}

id nw_browser_copy_old_result_locked(NWConcrete_nw_browser *a1, const char *a2)
{
  v29 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
    {
      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x3032000000;
      v26 = __Block_byref_object_copy__59106;
      v27 = __Block_byref_object_dispose__59107;
      v28 = 0;
      v5 = *(v3 + 17);
      aBlock[0] = MEMORY[0x1E69E9820];
      aBlock[1] = 3221225472;
      aBlock[2] = ___ZL33nw_browser_copy_old_result_lockedP21NWConcrete_nw_browserPKc_block_invoke;
      aBlock[3] = &unk_1E6A3D890;
      aBlock[4] = buf;
      aBlock[5] = a2;
      if (v5)
      {
        _nw_array_apply(v5, aBlock);
        v6 = *(*&buf[8] + 40);
      }

      else
      {
        v6 = 0;
      }

      v7 = v6;
      _Block_object_dispose(buf, 8);

      goto LABEL_7;
    }

    v13 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_browser_copy_old_result_locked";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_copy_old_result_locked";
          _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null key_name", buf, 0xCu);
        }

LABEL_39:

        goto LABEL_40;
      }

      if (v23 != 1)
      {
        v11 = __nwlog_obj();
        v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_copy_old_result_locked";
          _os_log_impl(&dword_181A37000, v11, v21, "%{public}s called with null key_name, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_39;
      }

      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_copy_old_result_locked";
          _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null key_name, no backtrace", buf, 0xCu);
        }

        goto LABEL_39;
      }

      if (v19)
      {
        *buf = 136446466;
        *&buf[4] = "nw_browser_copy_old_result_locked";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null key_name, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_27;
    }
  }

  else
  {
    v9 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_browser_copy_old_result_locked";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_copy_old_result_locked";
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null browser", buf, 0xCu);
        }

        goto LABEL_39;
      }

      if (v23 != 1)
      {
        v11 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_copy_old_result_locked";
          _os_log_impl(&dword_181A37000, v11, v20, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_39;
      }

      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_copy_old_result_locked";
          _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null browser, no backtrace", buf, 0xCu);
        }

        goto LABEL_39;
      }

      if (v17)
      {
        *buf = 136446466;
        *&buf[4] = "nw_browser_copy_old_result_locked";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_27:

      free(backtrace_string);
    }
  }

LABEL_40:
  if (v10)
  {
    free(v10);
  }

  v7 = 0;
LABEL_7:

  return v7;
}

void sub_182896824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, id a26)
{
  _Block_object_dispose(&a21, 8);

  _Unwind_Resume(a1);
}

id nw_browser_copy_new_result_locked(NWConcrete_nw_browser *a1, const char *a2)
{
  v29 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
    {
      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x3032000000;
      v26 = __Block_byref_object_copy__59106;
      v27 = __Block_byref_object_dispose__59107;
      v28 = 0;
      v5 = *(v3 + 18);
      aBlock[0] = MEMORY[0x1E69E9820];
      aBlock[1] = 3221225472;
      aBlock[2] = ___ZL33nw_browser_copy_new_result_lockedP21NWConcrete_nw_browserPKc_block_invoke;
      aBlock[3] = &unk_1E6A3D890;
      aBlock[4] = buf;
      aBlock[5] = a2;
      if (v5)
      {
        _nw_array_apply(v5, aBlock);
        v6 = *(*&buf[8] + 40);
      }

      else
      {
        v6 = 0;
      }

      v7 = v6;
      _Block_object_dispose(buf, 8);

      goto LABEL_7;
    }

    v13 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_browser_copy_new_result_locked";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_copy_new_result_locked";
          _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null key_name", buf, 0xCu);
        }

LABEL_39:

        goto LABEL_40;
      }

      if (v23 != 1)
      {
        v11 = __nwlog_obj();
        v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_copy_new_result_locked";
          _os_log_impl(&dword_181A37000, v11, v21, "%{public}s called with null key_name, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_39;
      }

      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_copy_new_result_locked";
          _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null key_name, no backtrace", buf, 0xCu);
        }

        goto LABEL_39;
      }

      if (v19)
      {
        *buf = 136446466;
        *&buf[4] = "nw_browser_copy_new_result_locked";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null key_name, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_27;
    }
  }

  else
  {
    v9 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_browser_copy_new_result_locked";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_copy_new_result_locked";
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null browser", buf, 0xCu);
        }

        goto LABEL_39;
      }

      if (v23 != 1)
      {
        v11 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_copy_new_result_locked";
          _os_log_impl(&dword_181A37000, v11, v20, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_39;
      }

      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_copy_new_result_locked";
          _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null browser, no backtrace", buf, 0xCu);
        }

        goto LABEL_39;
      }

      if (v17)
      {
        *buf = 136446466;
        *&buf[4] = "nw_browser_copy_new_result_locked";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_27:

      free(backtrace_string);
    }
  }

LABEL_40:
  if (v10)
  {
    free(v10);
  }

  v7 = 0;
LABEL_7:

  return v7;
}

void sub_182896DB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, id a26)
{
  _Block_object_dispose(&a21, 8);

  _Unwind_Resume(a1);
}

BOOL ___ZL33nw_browser_copy_new_result_lockedP21NWConcrete_nw_browserPKc_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  v5 = a3;
  v6 = nw_browser_result_matches_key(v5, *(a1 + 40));
  if (v6)
  {
    objc_storeStrong((*(*(a1 + 32) + 8) + 40), a3);
  }

  return !v6;
}

BOOL nw_browser_result_matches_key(void *a1, const char *a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = v3;
    v6 = v5[1];

    v7 = nw_browser_endpoint_matches_key(v6, a2);
    goto LABEL_3;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_browser_result_matches_key";
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v20 = "nw_browser_result_matches_key";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null result", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v20 = "nw_browser_result_matches_key";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v15)
      {
        *buf = 136446210;
        v20 = "nw_browser_result_matches_key";
        _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null result, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v20 = "nw_browser_result_matches_key";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v10)
  {
    free(v10);
  }

  v7 = 0;
LABEL_3:

  return v7;
}

BOOL nw_browser_endpoint_matches_key(void *a1, const char *a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    bzero(buf, 0x3F1uLL);
    nw_browser_copy_key_for_endpoint(v3, buf);
    v4 = strcasecmp(a2, buf) == 0;
    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_browser_endpoint_matches_key";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_browser_endpoint_matches_key";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v17 = "nw_browser_endpoint_matches_key";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v17 = "nw_browser_endpoint_matches_key";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_browser_endpoint_matches_key";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

  v4 = 0;
LABEL_3:

  return v4;
}

void nw_browser_copy_key_for_endpoint(void *a1, char *a2)
{
  v40 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!a2)
  {
    v21 = __nwlog_obj();
    *buf = 136446210;
    v35 = "nw_browser_copy_key_for_endpoint";
    v12 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v12, &type, &v32))
    {
      goto LABEL_26;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *buf = 136446210;
        v35 = "nw_browser_copy_key_for_endpoint";
        _os_log_impl(&dword_181A37000, v22, v23, "%{public}s called with null out_key", buf, 0xCu);
      }

      goto LABEL_59;
    }

    if (v32 != 1)
    {
      v22 = __nwlog_obj();
      v30 = type;
      if (os_log_type_enabled(v22, type))
      {
        *buf = 136446210;
        v35 = "nw_browser_copy_key_for_endpoint";
        _os_log_impl(&dword_181A37000, v22, v30, "%{public}s called with null out_key, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_59;
    }

    backtrace_string = __nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v26 = type;
    v27 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (v27)
      {
        *buf = 136446210;
        v35 = "nw_browser_copy_key_for_endpoint";
        _os_log_impl(&dword_181A37000, v22, v26, "%{public}s called with null out_key, no backtrace", buf, 0xCu);
      }

      goto LABEL_59;
    }

    if (v27)
    {
      *buf = 136446466;
      v35 = "nw_browser_copy_key_for_endpoint";
      v36 = 2082;
      v37 = backtrace_string;
      _os_log_impl(&dword_181A37000, v22, v26, "%{public}s called with null out_key, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_42;
  }

  *a2 = 0;
  if (!v3)
  {
    v24 = __nwlog_obj();
    *buf = 136446210;
    v35 = "nw_browser_copy_key_for_endpoint";
    v12 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v12, &type, &v32))
    {
      goto LABEL_26;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v22, type))
      {
        *buf = 136446210;
        v35 = "nw_browser_copy_key_for_endpoint";
        _os_log_impl(&dword_181A37000, v22, v25, "%{public}s called with null endpoint", buf, 0xCu);
      }

LABEL_59:

LABEL_26:
      if (!v12)
      {
        goto LABEL_7;
      }

LABEL_27:
      free(v12);
      goto LABEL_7;
    }

    if (v32 != 1)
    {
      v22 = __nwlog_obj();
      v31 = type;
      if (os_log_type_enabled(v22, type))
      {
        *buf = 136446210;
        v35 = "nw_browser_copy_key_for_endpoint";
        _os_log_impl(&dword_181A37000, v22, v31, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_59;
    }

    backtrace_string = __nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v28 = type;
    v29 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (v29)
      {
        *buf = 136446210;
        v35 = "nw_browser_copy_key_for_endpoint";
        _os_log_impl(&dword_181A37000, v22, v28, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_59;
    }

    if (v29)
    {
      *buf = 136446466;
      v35 = "nw_browser_copy_key_for_endpoint";
      v36 = 2082;
      v37 = backtrace_string;
      _os_log_impl(&dword_181A37000, v22, v28, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_42:

    goto LABEL_18;
  }

  v5 = v3;
  domain_for_policy = _nw_endpoint_get_domain_for_policy(v5);

  if (!domain_for_policy)
  {
    v7 = v5;
    v8 = _nw_endpoint_get_type(v7);

    if (v8 == 6)
    {
      v9 = v7;
      hash = _nw_endpoint_get_hash(v9);

      snprintf(a2, 0x3F1uLL, "%016zx", hash);
      domain_for_policy = a2;
      goto LABEL_6;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = gLogObj;
    *buf = 136446466;
    v35 = "nw_browser_copy_key_for_endpoint";
    v36 = 2112;
    v37 = v7;
    v12 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v12, &type, &v32))
    {
      goto LABEL_26;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *buf = 136446466;
        v35 = "nw_browser_copy_key_for_endpoint";
        v36 = 2112;
        v37 = v7;
        _os_log_impl(&dword_181A37000, v13, v14, "%{public}s Unsupported endpoint: %@", buf, 0x16u);
      }

LABEL_25:

      goto LABEL_26;
    }

    if (v32 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v19 = type;
      if (os_log_type_enabled(v13, type))
      {
        *buf = 136446466;
        v35 = "nw_browser_copy_key_for_endpoint";
        v36 = 2112;
        v37 = v7;
        _os_log_impl(&dword_181A37000, v13, v19, "%{public}s Unsupported endpoint: %@, backtrace limit exceeded", buf, 0x16u);
      }

      goto LABEL_25;
    }

    v15 = __nw_create_backtrace_string();
    if (!v15)
    {
      v13 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v13, type))
      {
        *buf = 136446466;
        v35 = "nw_browser_copy_key_for_endpoint";
        v36 = 2112;
        v37 = v7;
        _os_log_impl(&dword_181A37000, v13, v20, "%{public}s Unsupported endpoint: %@, no backtrace", buf, 0x16u);
      }

      goto LABEL_25;
    }

    backtrace_string = v15;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    v18 = type;
    if (os_log_type_enabled(v17, type))
    {
      *buf = 136446722;
      v35 = "nw_browser_copy_key_for_endpoint";
      v36 = 2112;
      v37 = v7;
      v38 = 2082;
      v39 = backtrace_string;
      _os_log_impl(&dword_181A37000, v17, v18, "%{public}s Unsupported endpoint: %@, dumping backtrace:%{public}s", buf, 0x20u);
    }

LABEL_18:
    free(backtrace_string);
    if (!v12)
    {
      goto LABEL_7;
    }

    goto LABEL_27;
  }

LABEL_6:
  nw_browser_strict_strlcpy_tolower(a2, domain_for_policy);
LABEL_7:
}

void nw_browser_strict_strlcpy_tolower(char *a1, const char *a2)
{
  v2 = a2;
  v3 = a1;
  v34 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    if (a2)
    {
LABEL_3:
      for (i = 1009; i > 1; --i)
      {
        v5 = __tolower(*v2);
        *v3 = v5;
        if (!v5)
        {
          return;
        }

        ++v3;
        ++v2;
      }

      *v3 = 0;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      *buf = 136446210;
      v31 = "nw_browser_strict_strlcpy_tolower";
      v7 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v28 = 0;
      if (!__nwlog_fault(v7, &type, &v28))
      {
LABEL_40:
        if (v7)
        {
          free(v7);
        }

        return;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *buf = 136446210;
          v31 = "nw_browser_strict_strlcpy_tolower";
          v10 = "%{public}s dst_len too small";
LABEL_37:
          v26 = v8;
          v27 = v9;
LABEL_38:
          _os_log_impl(&dword_181A37000, v26, v27, v10, buf, 0xCu);
        }
      }

      else
      {
        if (v28 == 1)
        {
          backtrace_string = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v8 = gLogObj;
          v22 = type;
          v23 = os_log_type_enabled(v8, type);
          if (backtrace_string)
          {
            if (v23)
            {
              *buf = 136446466;
              v31 = "nw_browser_strict_strlcpy_tolower";
              v32 = 2082;
              v33 = backtrace_string;
              _os_log_impl(&dword_181A37000, v8, v22, "%{public}s dst_len too small, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_40;
          }

          if (!v23)
          {
            goto LABEL_39;
          }

          *buf = 136446210;
          v31 = "nw_browser_strict_strlcpy_tolower";
          v10 = "%{public}s dst_len too small, no backtrace";
          v26 = v8;
          v27 = v22;
          goto LABEL_38;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *buf = 136446210;
          v31 = "nw_browser_strict_strlcpy_tolower";
          v10 = "%{public}s dst_len too small, backtrace limit exceeded";
          goto LABEL_37;
        }
      }

LABEL_39:

      goto LABEL_40;
    }

LABEL_12:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = gLogObj;
    *buf = 136446210;
    v31 = "nw_browser_strict_strlcpy_tolower";
    v14 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v14, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = gLogObj;
        v16 = type;
        if (!os_log_type_enabled(v15, type))
        {
          goto LABEL_33;
        }

        *buf = 136446210;
        v31 = "nw_browser_strict_strlcpy_tolower";
        v17 = "%{public}s called with null dst";
LABEL_31:
        v24 = v15;
        v25 = v16;
        goto LABEL_32;
      }

      if (v28 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = gLogObj;
        v16 = type;
        if (!os_log_type_enabled(v15, type))
        {
          goto LABEL_33;
        }

        *buf = 136446210;
        v31 = "nw_browser_strict_strlcpy_tolower";
        v17 = "%{public}s called with null dst, backtrace limit exceeded";
        goto LABEL_31;
      }

      v18 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      v19 = type;
      v20 = os_log_type_enabled(v15, type);
      if (!v18)
      {
        if (!v20)
        {
LABEL_33:

          if (!v14)
          {
            goto LABEL_23;
          }

          goto LABEL_22;
        }

        *buf = 136446210;
        v31 = "nw_browser_strict_strlcpy_tolower";
        v17 = "%{public}s called with null dst, no backtrace";
        v24 = v15;
        v25 = v19;
LABEL_32:
        _os_log_impl(&dword_181A37000, v24, v25, v17, buf, 0xCu);
        goto LABEL_33;
      }

      if (v20)
      {
        *buf = 136446466;
        v31 = "nw_browser_strict_strlcpy_tolower";
        v32 = 2082;
        v33 = v18;
        _os_log_impl(&dword_181A37000, v15, v19, "%{public}s called with null dst, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v18);
    }

    if (!v14)
    {
LABEL_23:
      *v3 = 0;
      return;
    }

LABEL_22:
    free(v14);
    goto LABEL_23;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v11 = gLogObj;
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *buf = 136446210;
  v31 = "nw_browser_strict_strlcpy_tolower";
  v12 = _os_log_send_and_compose_impl();

  if (!__nwlog_should_abort(v12))
  {
    free(v12);
    if (v2)
    {
      goto LABEL_3;
    }

    goto LABEL_12;
  }

  __break(1u);
}

BOOL ___ZL33nw_browser_copy_old_result_lockedP21NWConcrete_nw_browserPKc_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  v5 = a3;
  v6 = nw_browser_result_matches_key(v5, *(a1 + 40));
  if (v6)
  {
    objc_storeStrong((*(*(a1 + 32) + 8) + 40), a3);
  }

  return !v6;
}

uint64_t nw_browser_check_and_remove_endpoints_locked(void *a1, void *a2, void *a3, void *a4)
{
  v44 = *MEMORY[0x1E69E9840];
  v7 = a1;
  v8 = a2;
  v9 = a3;
  v10 = a4;
  if (v7)
  {
    if (v9)
    {
      aBlock[0] = MEMORY[0x1E69E9820];
      aBlock[1] = 3221225472;
      aBlock[2] = ___ZL44nw_browser_check_and_remove_endpoints_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS1_PU26objcproto15OS_nw_interfaceS1__block_invoke;
      aBlock[3] = &unk_1E6A35E80;
      v11 = v9;
      v31 = v11;
      v12 = v10;
      v32 = v12;
      if (!v8 || _nw_array_apply(v8, aBlock))
      {
        bzero(v40, 0x3F1uLL);
        nw_browser_copy_key_for_endpoint(v11, v40);
        if ((nw_browser_remove_result_locked(v7, v40, v12) & 1) == 0 && !nw_parameters_get_logging_disabled(*(v7 + 5)))
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v13 = gbrowserLogObj;
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          {
            v14 = *(v7 + 48);
            *buf = 136446723;
            v35 = "nw_browser_check_and_remove_endpoints_locked";
            v36 = 1024;
            v37 = v14;
            v38 = 2085;
            v39 = v40;
            _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_ERROR, "%{public}s [B%u] Failed to remove result for %{sensitive}s", buf, 0x1Cu);
          }
        }
      }

      v15 = 1;
      goto LABEL_13;
    }

    v21 = __nwlog_obj();
    *v40 = 136446210;
    v41 = "nw_browser_check_and_remove_endpoints_locked";
    v18 = _os_log_send_and_compose_impl();

    buf[0] = 16;
    v33 = 0;
    if (__nwlog_fault(v18, buf, &v33))
    {
      if (buf[0] == 17)
      {
        v19 = __nwlog_obj();
        v22 = buf[0];
        if (os_log_type_enabled(v19, buf[0]))
        {
          *v40 = 136446210;
          v41 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_181A37000, v19, v22, "%{public}s called with null old_endpoint", v40, 0xCu);
        }

LABEL_45:

        goto LABEL_46;
      }

      if (v33 != 1)
      {
        v19 = __nwlog_obj();
        v29 = buf[0];
        if (os_log_type_enabled(v19, buf[0]))
        {
          *v40 = 136446210;
          v41 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_181A37000, v19, v29, "%{public}s called with null old_endpoint, backtrace limit exceeded", v40, 0xCu);
        }

        goto LABEL_45;
      }

      backtrace_string = __nw_create_backtrace_string();
      v19 = __nwlog_obj();
      v26 = buf[0];
      v27 = os_log_type_enabled(v19, buf[0]);
      if (!backtrace_string)
      {
        if (v27)
        {
          *v40 = 136446210;
          v41 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_181A37000, v19, v26, "%{public}s called with null old_endpoint, no backtrace", v40, 0xCu);
        }

        goto LABEL_45;
      }

      if (v27)
      {
        *v40 = 136446466;
        v41 = "nw_browser_check_and_remove_endpoints_locked";
        v42 = 2082;
        v43 = backtrace_string;
        _os_log_impl(&dword_181A37000, v19, v26, "%{public}s called with null old_endpoint, dumping backtrace:%{public}s", v40, 0x16u);
      }

      goto LABEL_33;
    }
  }

  else
  {
    v17 = __nwlog_obj();
    *v40 = 136446210;
    v41 = "nw_browser_check_and_remove_endpoints_locked";
    v18 = _os_log_send_and_compose_impl();

    buf[0] = 16;
    v33 = 0;
    if (__nwlog_fault(v18, buf, &v33))
    {
      if (buf[0] == 17)
      {
        v19 = __nwlog_obj();
        v20 = buf[0];
        if (os_log_type_enabled(v19, buf[0]))
        {
          *v40 = 136446210;
          v41 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_181A37000, v19, v20, "%{public}s called with null browser", v40, 0xCu);
        }

        goto LABEL_45;
      }

      if (v33 != 1)
      {
        v19 = __nwlog_obj();
        v28 = buf[0];
        if (os_log_type_enabled(v19, buf[0]))
        {
          *v40 = 136446210;
          v41 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_181A37000, v19, v28, "%{public}s called with null browser, backtrace limit exceeded", v40, 0xCu);
        }

        goto LABEL_45;
      }

      backtrace_string = __nw_create_backtrace_string();
      v19 = __nwlog_obj();
      v24 = buf[0];
      v25 = os_log_type_enabled(v19, buf[0]);
      if (!backtrace_string)
      {
        if (v25)
        {
          *v40 = 136446210;
          v41 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_181A37000, v19, v24, "%{public}s called with null browser, no backtrace", v40, 0xCu);
        }

        goto LABEL_45;
      }

      if (v25)
      {
        *v40 = 136446466;
        v41 = "nw_browser_check_and_remove_endpoints_locked";
        v42 = 2082;
        v43 = backtrace_string;
        _os_log_impl(&dword_181A37000, v19, v24, "%{public}s called with null browser, dumping backtrace:%{public}s", v40, 0x16u);
      }

LABEL_33:

      free(backtrace_string);
    }
  }

LABEL_46:
  if (v18)
  {
    free(v18);
  }

  v15 = 0;
LABEL_13:

  return v15;
}

BOOL ___ZL44nw_browser_check_and_remove_endpoints_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS1_PU26objcproto15OS_nw_interfaceS1__block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  v5 = nw_endpoint_copy_interface(v4);
  v7 = 1;
  if (nw_endpoint_is_equal(*(a1 + 32), v4, 0))
  {
    if (!v5 || (v6 = *(a1 + 40)) == 0 || (_nw_interface_shallow_compare(v5, v6) & 1) != 0)
    {
      v7 = 0;
    }
  }

  return v7;
}

uint64_t nw_browser_remove_result_locked(void *a1, const char *a2, void *a3)
{
  v110 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a3;
  uint64 = xpc_dictionary_get_uint64(*(v5 + 20), a2);
  result = nw_browser_copy_result_to_modify_locked(v5, a2, uint64);
  if (!uint64)
  {
    v17 = *(v5 + 5);
    if (!result)
    {
      if (!nw_parameters_get_logging_disabled(v17))
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v24 = gbrowserLogObj;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          v25 = *(v5 + 48);
          *buf = 136446722;
          *&buf[4] = "nw_browser_remove_result_locked";
          *&buf[12] = 1024;
          *&buf[14] = v25;
          *&buf[18] = 2080;
          *&buf[20] = a2;
          _os_log_impl(&dword_181A37000, v24, OS_LOG_TYPE_ERROR, "%{public}s [B%u] Trying to remove %s with invalid changes", buf, 0x1Cu);
        }
      }

      goto LABEL_181;
    }

    if (nw_parameters_get_logging_disabled(v17))
    {
      goto LABEL_181;
    }

    if (__nwlog_browser_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
    }

    v18 = gbrowserLogObj;
    v19 = *(v5 + 48);
    *buf = 136446722;
    *&buf[4] = "nw_browser_remove_result_locked";
    *&buf[12] = 1024;
    *&buf[14] = v19;
    *&buf[18] = 2080;
    *&buf[20] = a2;
    v20 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v106 = 0;
    if (__nwlog_fault(v20, &type, &v106))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v21 = gbrowserLogObj;
        v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          v23 = *(v5 + 48);
          *buf = 136446722;
          *&buf[4] = "nw_browser_remove_result_locked";
          *&buf[12] = 1024;
          *&buf[14] = v23;
          *&buf[18] = 2080;
          *&buf[20] = a2;
          _os_log_impl(&dword_181A37000, v21, v22, "%{public}s [B%u] Trying to remove %s with invalid changes", buf, 0x1Cu);
        }
      }

      else if (v106 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          v36 = backtrace_string;
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v37 = gbrowserLogObj;
          v38 = type;
          if (os_log_type_enabled(v37, type))
          {
            v39 = *(v5 + 48);
            *buf = 136446978;
            *&buf[4] = "nw_browser_remove_result_locked";
            *&buf[12] = 1024;
            *&buf[14] = v39;
            *&buf[18] = 2080;
            *&buf[20] = a2;
            *&buf[28] = 2082;
            *&buf[30] = v36;
            _os_log_impl(&dword_181A37000, v37, v38, "%{public}s [B%u] Trying to remove %s with invalid changes, dumping backtrace:%{public}s", buf, 0x26u);
          }

          free(v36);
          if (!v20)
          {
            goto LABEL_181;
          }

          goto LABEL_81;
        }

        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v21 = gbrowserLogObj;
        v48 = type;
        if (os_log_type_enabled(v21, type))
        {
          v49 = *(v5 + 48);
          *buf = 136446722;
          *&buf[4] = "nw_browser_remove_result_locked";
          *&buf[12] = 1024;
          *&buf[14] = v49;
          *&buf[18] = 2080;
          *&buf[20] = a2;
          _os_log_impl(&dword_181A37000, v21, v48, "%{public}s [B%u] Trying to remove %s with invalid changes, no backtrace", buf, 0x1Cu);
        }
      }

      else
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v21 = gbrowserLogObj;
        v40 = type;
        if (os_log_type_enabled(v21, type))
        {
          v41 = *(v5 + 48);
          *buf = 136446722;
          *&buf[4] = "nw_browser_remove_result_locked";
          *&buf[12] = 1024;
          *&buf[14] = v41;
          *&buf[18] = 2080;
          *&buf[20] = a2;
          _os_log_impl(&dword_181A37000, v21, v40, "%{public}s [B%u] Trying to remove %s with invalid changes, backtrace limit exceeded", buf, 0x1Cu);
        }
      }
    }

    if (!v20)
    {
      goto LABEL_181;
    }

LABEL_81:
    v50 = v20;
LABEL_180:
    free(v50);
    goto LABEL_181;
  }

  if (!v6 || (*(v5 + 196) & 1) == 0)
  {
    if (!v6)
    {
      goto LABEL_93;
    }

    goto LABEL_92;
  }

  v8 = v5;
  v9 = v6;
  if (a2)
  {
    if (!nw_parameters_get_logging_disabled(*(v8 + 5)))
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v10 = gbrowserLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v11 = *(v8 + 48);
        *buf = 136446978;
        *&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
        *&buf[12] = 1024;
        *&buf[14] = v11;
        *&buf[18] = 2080;
        *&buf[20] = a2;
        *&buf[28] = 2112;
        *&buf[30] = v9;
        _os_log_impl(&dword_181A37000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] cancel query record for %s on %@", buf, 0x26u);
      }
    }

    browser_key_for = nw_create_browser_key_for (a2, v9);
    pointer = xpc_dictionary_get_pointer();
    if (pointer)
    {
      xpc_dictionary_set_pointer();
      if (!nw_parameters_get_logging_disabled(*(v8 + 5)))
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v14 = gbrowserLogObj;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          v15 = *(v8 + 48);
          *buf = 136446722;
          *&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
          *&buf[12] = 1024;
          *&buf[14] = v15;
          *&buf[18] = 2080;
          *&buf[20] = browser_key_for;
          _os_log_impl(&dword_181A37000, v14, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] dns_ref_map: set %s to NULL", buf, 0x1Cu);
        }
      }

      if (browser_key_for)
      {
        free(browser_key_for);
      }

      v16 = nw_parameters_copy_context(*(v8 + 5));
      *buf = MEMORY[0x1E69E9820];
      *&buf[8] = 3221225472;
      *&buf[16] = ___ZL50nw_browser_cancel_query_record_for_endpoint_lockedP21NWConcrete_nw_browserPKcPU26objcproto15OS_nw_interface8NSObject_block_invoke;
      *&buf[24] = &unk_1E6A3AC58;
      *&buf[32] = v8;
      v109 = pointer;
      nw_queue_context_async(v16, buf);

      goto LABEL_91;
    }

    if (!nw_parameters_get_logging_disabled(*(v8 + 5)))
    {
      v26 = v6;
      v27 = v9;
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v28 = gbrowserLogObj;
      v29 = *(v8 + 48);
      *buf = 136446466;
      *&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
      *&buf[12] = 1024;
      *&buf[14] = v29;
      v30 = _os_log_send_and_compose_impl();

      v9 = v27;
      v6 = v26;
      type = OS_LOG_TYPE_ERROR;
      v106 = 0;
      if (!__nwlog_fault(v30, &type, &v106))
      {
        goto LABEL_87;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v31 = v9;
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v32 = gbrowserLogObj;
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          v34 = *(v8 + 48);
          *buf = 136446466;
          *&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
          *&buf[12] = 1024;
          *&buf[14] = v34;
          _os_log_impl(&dword_181A37000, v32, v33, "%{public}s [B%u] Could not find dns_ref for service", buf, 0x12u);
        }
      }

      else if (v106 == 1)
      {
        v42 = __nw_create_backtrace_string();
        if (v42)
        {
          v43 = v42;
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v44 = gbrowserLogObj;
          v104 = type;
          if (os_log_type_enabled(v44, type))
          {
            v45 = *(v8 + 48);
            *buf = 136446722;
            *&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            *&buf[12] = 1024;
            *&buf[14] = v45;
            *&buf[18] = 2082;
            *&buf[20] = v43;
            _os_log_impl(&dword_181A37000, v44, v104, "%{public}s [B%u] Could not find dns_ref for service, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v43);
          goto LABEL_87;
        }

        v31 = v9;
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v32 = gbrowserLogObj;
        v51 = type;
        if (os_log_type_enabled(v32, type))
        {
          v52 = *(v8 + 48);
          *buf = 136446466;
          *&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
          *&buf[12] = 1024;
          *&buf[14] = v52;
          _os_log_impl(&dword_181A37000, v32, v51, "%{public}s [B%u] Could not find dns_ref for service, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        v31 = v9;
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v32 = gbrowserLogObj;
        v46 = type;
        if (os_log_type_enabled(v32, type))
        {
          v47 = *(v8 + 48);
          *buf = 136446466;
          *&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
          *&buf[12] = 1024;
          *&buf[14] = v47;
          _os_log_impl(&dword_181A37000, v32, v46, "%{public}s [B%u] Could not find dns_ref for service, backtrace limit exceeded", buf, 0x12u);
        }
      }

      v9 = v31;
LABEL_87:
      if (v30)
      {
        free(v30);
      }
    }
  }

  else
  {
    __nwlog_obj();
    v97 = v96 = v9;
    *buf = 136446210;
    *&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
    browser_key_for = _os_log_send_and_compose_impl();

    v9 = v96;
    type = OS_LOG_TYPE_ERROR;
    v106 = 0;
    if (__nwlog_fault(browser_key_for, &type, &v106))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v98 = __nwlog_obj();
        v99 = type;
        if (os_log_type_enabled(v98, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
          _os_log_impl(&dword_181A37000, v98, v99, "%{public}s called with null fullname", buf, 0xCu);
        }
      }

      else if (v106 == 1)
      {
        v100 = __nw_create_backtrace_string();
        v98 = __nwlog_obj();
        v101 = type;
        v102 = os_log_type_enabled(v98, type);
        if (v100)
        {
          if (v102)
          {
            *buf = 136446466;
            *&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            *&buf[12] = 2082;
            *&buf[14] = v100;
            _os_log_impl(&dword_181A37000, v98, v101, "%{public}s called with null fullname, dumping backtrace:%{public}s", buf, 0x16u);
          }

          v9 = v96;
          free(v100);
          if (!browser_key_for)
          {
            goto LABEL_91;
          }

          goto LABEL_90;
        }

        if (v102)
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
          _os_log_impl(&dword_181A37000, v98, v101, "%{public}s called with null fullname, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v98 = __nwlog_obj();
        v103 = type;
        if (os_log_type_enabled(v98, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
          _os_log_impl(&dword_181A37000, v98, v103, "%{public}s called with null fullname, backtrace limit exceeded", buf, 0xCu);
        }
      }

      v9 = v96;
    }
  }

  if (browser_key_for)
  {
LABEL_90:
    free(browser_key_for);
  }

LABEL_91:

LABEL_92:
  if ((nw_browse_result_remove_interface(result, v6) & 1) == 0)
  {
    if (nw_parameters_get_logging_disabled(*(v5 + 5)))
    {
      goto LABEL_181;
    }

    if (__nwlog_browser_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
    }

    v56 = gbrowserLogObj;
    v57 = *(v5 + 48);
    *buf = 136446466;
    *&buf[4] = "nw_browser_remove_result_locked";
    *&buf[12] = 1024;
    *&buf[14] = v57;
    v58 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v106 = 0;
    if (!__nwlog_fault(v58, &type, &v106))
    {
      goto LABEL_178;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v59 = gbrowserLogObj;
      v60 = type;
      if (os_log_type_enabled(v59, type))
      {
        v61 = *(v5 + 48);
        *buf = 136446466;
        *&buf[4] = "nw_browser_remove_result_locked";
        *&buf[12] = 1024;
        *&buf[14] = v61;
        _os_log_impl(&dword_181A37000, v59, v60, "%{public}s [B%u] tried to remove non-existent interface", buf, 0x12u);
      }

      goto LABEL_177;
    }

    if (v106 != 1)
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v59 = gbrowserLogObj;
      v69 = type;
      if (os_log_type_enabled(v59, type))
      {
        v70 = *(v5 + 48);
        *buf = 136446466;
        *&buf[4] = "nw_browser_remove_result_locked";
        *&buf[12] = 1024;
        *&buf[14] = v70;
        _os_log_impl(&dword_181A37000, v59, v69, "%{public}s [B%u] tried to remove non-existent interface, backtrace limit exceeded", buf, 0x12u);
      }

      goto LABEL_177;
    }

    v64 = __nw_create_backtrace_string();
    if (!v64)
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v59 = gbrowserLogObj;
      v89 = type;
      if (os_log_type_enabled(v59, type))
      {
        v90 = *(v5 + 48);
        *buf = 136446466;
        *&buf[4] = "nw_browser_remove_result_locked";
        *&buf[12] = 1024;
        *&buf[14] = v90;
        _os_log_impl(&dword_181A37000, v59, v89, "%{public}s [B%u] tried to remove non-existent interface, no backtrace", buf, 0x12u);
      }

      goto LABEL_177;
    }

    v65 = v64;
    if (__nwlog_browser_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
    }

    v66 = gbrowserLogObj;
    v67 = type;
    if (os_log_type_enabled(v66, type))
    {
      v68 = *(v5 + 48);
      *buf = 136446722;
      *&buf[4] = "nw_browser_remove_result_locked";
      *&buf[12] = 1024;
      *&buf[14] = v68;
      *&buf[18] = 2082;
      *&buf[20] = v65;
      _os_log_impl(&dword_181A37000, v66, v67, "%{public}s [B%u] tried to remove non-existent interface, dumping backtrace:%{public}s", buf, 0x1Cu);
    }

    goto LABEL_161;
  }

LABEL_93:
  if (nw_browse_result_get_interfaces_count(result))
  {
    xpc_dictionary_set_uint64(*(v5 + 20), a2, uint64 | 0x10);
    if (!nw_parameters_get_logging_disabled(*(v5 + 5)))
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v53 = gbrowserLogObj;
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
      {
        v54 = *(v5 + 48);
        *buf = 136446978;
        *&buf[4] = "nw_browser_remove_result_locked";
        *&buf[12] = 1024;
        *&buf[14] = v54;
        *&buf[18] = 2080;
        *&buf[20] = a2;
        *&buf[28] = 2112;
        *&buf[30] = v6;
        _os_log_impl(&dword_181A37000, v53, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s interface_removed(%@)", buf, 0x26u);
      }
    }

    v55 = 1;
    goto LABEL_182;
  }

  v62 = *(v5 + 18);
  if (v62)
  {
    v63 = _nw_array_get_count(v62) - 1;
    v62 = *(v5 + 18);
  }

  else
  {
    v63 = -1;
  }

  v71 = nw_array_duplicate_array_without_object(v62, result);
  v72 = *(v5 + 18);
  *(v5 + 18) = v71;

  v73 = *(v5 + 18);
  if (v73)
  {
    count = _nw_array_get_count(v73);
  }

  else
  {
    count = 0;
  }

  v75 = *(v5 + 5);
  if (v63 != count)
  {
    if (nw_parameters_get_logging_disabled(v75))
    {
      goto LABEL_181;
    }

    if (__nwlog_browser_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
    }

    v82 = gbrowserLogObj;
    v83 = *(v5 + 48);
    *buf = 136446466;
    *&buf[4] = "nw_browser_remove_result_locked";
    *&buf[12] = 1024;
    *&buf[14] = v83;
    v58 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v106 = 0;
    if (!__nwlog_fault(v58, &type, &v106))
    {
      goto LABEL_178;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v59 = gbrowserLogObj;
      v84 = type;
      if (os_log_type_enabled(v59, type))
      {
        v85 = *(v5 + 48);
        *buf = 136446466;
        *&buf[4] = "nw_browser_remove_result_locked";
        *&buf[12] = 1024;
        *&buf[14] = v85;
        _os_log_impl(&dword_181A37000, v59, v84, "%{public}s [B%u] new: failed to remove from new_results", buf, 0x12u);
      }

LABEL_177:

LABEL_178:
      if (v58)
      {
LABEL_179:
        v50 = v58;
        goto LABEL_180;
      }

LABEL_181:
      v55 = 0;
      goto LABEL_182;
    }

    if (v106 != 1)
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v59 = gbrowserLogObj;
      v91 = type;
      if (os_log_type_enabled(v59, type))
      {
        v92 = *(v5 + 48);
        *buf = 136446466;
        *&buf[4] = "nw_browser_remove_result_locked";
        *&buf[12] = 1024;
        *&buf[14] = v92;
        _os_log_impl(&dword_181A37000, v59, v91, "%{public}s [B%u] new: failed to remove from new_results, backtrace limit exceeded", buf, 0x12u);
      }

      goto LABEL_177;
    }

    v86 = __nw_create_backtrace_string();
    if (!v86)
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v59 = gbrowserLogObj;
      v93 = type;
      if (os_log_type_enabled(v59, type))
      {
        v94 = *(v5 + 48);
        *buf = 136446466;
        *&buf[4] = "nw_browser_remove_result_locked";
        *&buf[12] = 1024;
        *&buf[14] = v94;
        _os_log_impl(&dword_181A37000, v59, v93, "%{public}s [B%u] new: failed to remove from new_results, no backtrace", buf, 0x12u);
      }

      goto LABEL_177;
    }

    v65 = v86;
    if (__nwlog_browser_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
    }

    v66 = gbrowserLogObj;
    v87 = type;
    if (os_log_type_enabled(v66, type))
    {
      v88 = *(v5 + 48);
      *buf = 136446722;
      *&buf[4] = "nw_browser_remove_result_locked";
      *&buf[12] = 1024;
      *&buf[14] = v88;
      *&buf[18] = 2082;
      *&buf[20] = v65;
      _os_log_impl(&dword_181A37000, v66, v87, "%{public}s [B%u] new: failed to remove from new_results, dumping backtrace:%{public}s", buf, 0x1Cu);
    }

LABEL_161:

    free(v65);
    if (!v58)
    {
      goto LABEL_181;
    }

    goto LABEL_179;
  }

  if (!nw_parameters_get_logging_disabled(v75))
  {
    if (__nwlog_browser_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
    }

    v76 = gbrowserLogObj;
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
    {
      v77 = *(v5 + 48);
      *buf = 136446722;
      *&buf[4] = "nw_browser_remove_result_locked";
      *&buf[12] = 1024;
      *&buf[14] = v77;
      *&buf[18] = 2112;
      *&buf[20] = result;
      _os_log_impl(&dword_181A37000, v76, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] new: removed %@ from new_results", buf, 0x1Cu);
    }
  }

  xpc_dictionary_set_uint64(*(v5 + 20), a2, uint64 | 4);
  if (!nw_parameters_get_logging_disabled(*(v5 + 5)))
  {
    if (__nwlog_browser_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
    }

    v78 = gbrowserLogObj;
    if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
    {
      v79 = *(v5 + 48);
      *buf = 136446978;
      *&buf[4] = "nw_browser_remove_result_locked";
      *&buf[12] = 1024;
      *&buf[14] = v79;
      *&buf[18] = 2080;
      *&buf[20] = a2;
      *&buf[28] = 2112;
      *&buf[30] = v6;
      _os_log_impl(&dword_181A37000, v78, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s result_removed(%@)", buf, 0x26u);
    }
  }

  v80 = nw_browser_copy_old_result_locked(v5, a2);
  v81 = v80 == 0;

  if (v81)
  {
    xpc_dictionary_set_value(*(v5 + 20), a2, 0);
  }

  nw_dictionary_set_value(*(v5 + 21), a2, 0);
  v55 = 1;
LABEL_182:

  return v55;
}

NWConcrete_nw_browse_result *nw_browser_copy_result_to_modify_locked(NWConcrete_nw_browser *a1, const char *a2, uint64_t a3)
{
  *&v48[13] = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = v5;
  if (!a2)
  {
    v32 = __nwlog_obj();
    *buf = 136446210;
    v46 = "nw_browser_copy_result_to_modify_locked";
    v33 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v43 = 0;
    if (__nwlog_fault(v33, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v34 = __nwlog_obj();
        v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          *buf = 136446210;
          v46 = "nw_browser_copy_result_to_modify_locked";
          _os_log_impl(&dword_181A37000, v34, v35, "%{public}s called with null key_name", buf, 0xCu);
        }
      }

      else if (v43 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v34 = __nwlog_obj();
        v37 = type;
        v38 = os_log_type_enabled(v34, type);
        if (backtrace_string)
        {
          if (v38)
          {
            *buf = 136446466;
            v46 = "nw_browser_copy_result_to_modify_locked";
            v47 = 2082;
            *v48 = backtrace_string;
            _os_log_impl(&dword_181A37000, v34, v37, "%{public}s called with null key_name, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_73;
        }

        if (v38)
        {
          *buf = 136446210;
          v46 = "nw_browser_copy_result_to_modify_locked";
          _os_log_impl(&dword_181A37000, v34, v37, "%{public}s called with null key_name, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v34 = __nwlog_obj();
        v39 = type;
        if (os_log_type_enabled(v34, type))
        {
          *buf = 136446210;
          v46 = "nw_browser_copy_result_to_modify_locked";
          _os_log_impl(&dword_181A37000, v34, v39, "%{public}s called with null key_name, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_73:
    if (v33)
    {
      free(v33);
    }

    goto LABEL_75;
  }

  if (!a3)
  {
LABEL_75:
    mutable_copy = 0;
    goto LABEL_76;
  }

  v7 = nw_browser_copy_new_result_locked(v5, a2);
  v8 = v7;
  if (v7)
  {
    mutable_copy = v7;
LABEL_36:

LABEL_76:
    return mutable_copy;
  }

  v10 = nw_browser_copy_old_result_locked(v6, a2);
  v11 = v10;
  if (!v10)
  {
    if (!nw_parameters_get_logging_disabled(*(v6 + 5)))
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v17 = gbrowserLogObj;
      v18 = *(v6 + 48);
      *buf = 136446466;
      v46 = "nw_browser_copy_result_to_modify_locked";
      v47 = 1024;
      *v48 = v18;
      v19 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v43 = 0;
      if (__nwlog_fault(v19, &type, &v43))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v20 = gbrowserLogObj;
          v21 = type;
          if (os_log_type_enabled(v20, type))
          {
            v22 = *(v6 + 48);
            *buf = 136446466;
            v46 = "nw_browser_copy_result_to_modify_locked";
            v47 = 1024;
            *v48 = v22;
            _os_log_impl(&dword_181A37000, v20, v21, "%{public}s [B%u] nw_browser_copy_old_result_locked failed", buf, 0x12u);
          }
        }

        else if (v43 == 1)
        {
          v23 = __nw_create_backtrace_string();
          if (v23)
          {
            v24 = v23;
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v25 = gbrowserLogObj;
            v26 = type;
            if (os_log_type_enabled(v25, type))
            {
              v27 = *(v6 + 48);
              *buf = 136446722;
              v46 = "nw_browser_copy_result_to_modify_locked";
              v47 = 1024;
              *v48 = v27;
              v48[2] = 2082;
              *&v48[3] = v24;
              _os_log_impl(&dword_181A37000, v25, v26, "%{public}s [B%u] nw_browser_copy_old_result_locked failed, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v24);
            if (!v19)
            {
              goto LABEL_34;
            }

            goto LABEL_33;
          }

          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v20 = gbrowserLogObj;
          v30 = type;
          if (os_log_type_enabled(v20, type))
          {
            v31 = *(v6 + 48);
            *buf = 136446466;
            v46 = "nw_browser_copy_result_to_modify_locked";
            v47 = 1024;
            *v48 = v31;
            _os_log_impl(&dword_181A37000, v20, v30, "%{public}s [B%u] nw_browser_copy_old_result_locked failed, no backtrace", buf, 0x12u);
          }
        }

        else
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v20 = gbrowserLogObj;
          v28 = type;
          if (os_log_type_enabled(v20, type))
          {
            v29 = *(v6 + 48);
            *buf = 136446466;
            v46 = "nw_browser_copy_result_to_modify_locked";
            v47 = 1024;
            *v48 = v29;
            _os_log_impl(&dword_181A37000, v20, v28, "%{public}s [B%u] nw_browser_copy_old_result_locked failed, backtrace limit exceeded", buf, 0x12u);
          }
        }
      }

      if (v19)
      {
LABEL_33:
        free(v19);
      }
    }

LABEL_34:
    mutable_copy = 0;
LABEL_35:

    goto LABEL_36;
  }

  mutable_copy = nw_browse_result_create_mutable_copy(v10);
  if (mutable_copy)
  {
LABEL_7:
    if (!nw_parameters_get_logging_disabled(*(v6 + 5)))
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v12 = gbrowserLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        v13 = *(v6 + 48);
        *buf = 136446722;
        v46 = "nw_browser_copy_result_to_modify_locked";
        v47 = 1024;
        *v48 = v13;
        v48[2] = 2112;
        *&v48[3] = mutable_copy;
        _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] copy %@", buf, 0x1Cu);
      }
    }

    v14 = *(v6 + 18);
    if (v14 && mutable_copy)
    {
      _nw_array_append(v14, mutable_copy);
    }

    if (!nw_parameters_get_logging_disabled(*(v6 + 5)))
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v15 = gbrowserLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        v16 = *(v6 + 48);
        *buf = 136446722;
        v46 = "nw_browser_copy_result_to_modify_locked";
        v47 = 1024;
        *v48 = v16;
        v48[2] = 2112;
        *&v48[3] = mutable_copy;
        _os_log_impl(&dword_181A37000, v15, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] add %@ to new_results", buf, 0x1Cu);
      }
    }

    goto LABEL_35;
  }

  v40 = __nwlog_obj();
  os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
  *buf = 136446210;
  v46 = "nw_browser_copy_result_to_modify_locked";
  v41 = _os_log_send_and_compose_impl();

  result = __nwlog_should_abort(v41);
  if (!result)
  {
    free(v41);
    goto LABEL_7;
  }

  __break(1u);
  return result;
}

uint64_t nw_create_browser_key_for (const char *a1, void *a2)
{
  v3 = a2;
  v4 = v3;
  if (v3)
  {
    name = _nw_interface_get_name(v3);
    v6 = strlen(a1);
    if (name)
    {
      v7 = strlen(name);
      v8 = 0;
      goto LABEL_6;
    }
  }

  else
  {
    v6 = strlen(a1);
    name = 0;
  }

  v7 = 0;
  v8 = 1;
LABEL_6:
  v9 = v6 + v7 + 1;
  if (!v9)
  {
    v19 = __nwlog_obj();
    os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    v20 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v20);
    if (result)
    {
      goto LABEL_28;
    }

    free(v20);
  }

  v10 = malloc_type_malloc(v9, 0x83F93C5EuLL);
  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = gLogObj;
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    v12 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v12);
    if (!result)
    {
      free(v12);
      goto LABEL_10;
    }

LABEL_28:
    __break(1u);
    return result;
  }

LABEL_10:
  *v10 = 0;
  if (v9)
  {
    v14 = v10;
    if (v9 == 1)
    {
LABEL_15:
      *v14 = 0;
    }

    else
    {
      v15 = v9;
      v14 = v10;
      while (1)
      {
        v16 = *a1;
        *v14 = v16;
        if (!v16)
        {
          break;
        }

        ++v14;
        ++a1;
        if (--v15 <= 1)
        {
          goto LABEL_15;
        }
      }
    }

    if ((v8 & 1) == 0)
    {
      v17 = v10;
      while (*v17)
      {
        ++v17;
        if (!--v9)
        {
          goto LABEL_25;
        }
      }

      if (v9 < 2)
      {
LABEL_24:
        *v17 = 0;
      }

      else
      {
        while (1)
        {
          v18 = *name;
          *v17 = v18;
          if (!v18)
          {
            break;
          }

          ++v17;
          ++name;
          if (--v9 <= 1)
          {
            goto LABEL_24;
          }
        }
      }
    }
  }

LABEL_25:

  return v10;
}

void ___ZL50nw_browser_cancel_query_record_for_endpoint_lockedP21NWConcrete_nw_browserPKcPU26objcproto15OS_nw_interface8NSObject_block_invoke(uint64_t a1)
{
  v29 = *MEMORY[0x1E69E9840];
  v2 = *(a1 + 32);
  if (!*(v2 + 120))
  {
    if (nw_parameters_get_logging_disabled(*(v2 + 40)))
    {
      return;
    }

    if (__nwlog_browser_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
    }

    v6 = gbrowserLogObj;
    v7 = *(*(a1 + 32) + 192);
    *buf = 136446466;
    v24 = "nw_browser_cancel_query_record_for_endpoint_locked_block_invoke";
    v25 = 1024;
    v26 = v7;
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v9 = gbrowserLogObj;
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          v11 = *(*(a1 + 32) + 192);
          *buf = 136446466;
          v24 = "nw_browser_cancel_query_record_for_endpoint_locked_block_invoke";
          v25 = 1024;
          v26 = v11;
          v12 = "%{public}s [B%u] main_dns_ref is already NULL";
LABEL_31:
          v18 = v9;
          v19 = v10;
LABEL_32:
          _os_log_impl(&dword_181A37000, v18, v19, v12, buf, 0x12u);
          goto LABEL_33;
        }

        goto LABEL_33;
      }

      if (v21 != 1)
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v9 = gbrowserLogObj;
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          v17 = *(*(a1 + 32) + 192);
          *buf = 136446466;
          v24 = "nw_browser_cancel_query_record_for_endpoint_locked_block_invoke";
          v25 = 1024;
          v26 = v17;
          v12 = "%{public}s [B%u] main_dns_ref is already NULL, backtrace limit exceeded";
          goto LABEL_31;
        }

LABEL_33:

        if (!v8)
        {
          return;
        }

LABEL_25:
        free(v8);
        return;
      }

      backtrace_string = __nw_create_backtrace_string();
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v9 = gbrowserLogObj;
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          v20 = *(*(a1 + 32) + 192);
          *buf = 136446466;
          v24 = "nw_browser_cancel_query_record_for_endpoint_locked_block_invoke";
          v25 = 1024;
          v26 = v20;
          v12 = "%{public}s [B%u] main_dns_ref is already NULL, no backtrace";
          v18 = v9;
          v19 = v14;
          goto LABEL_32;
        }

        goto LABEL_33;
      }

      if (v15)
      {
        v16 = *(*(a1 + 32) + 192);
        *buf = 136446722;
        v24 = "nw_browser_cancel_query_record_for_endpoint_locked_block_invoke";
        v25 = 1024;
        v26 = v16;
        v27 = 2082;
        v28 = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s [B%u] main_dns_ref is already NULL, dumping backtrace:%{public}s", buf, 0x1Cu);
      }

      free(backtrace_string);
    }

    if (!v8)
    {
      return;
    }

    goto LABEL_25;
  }

  DNSServiceRefDeallocate(*(a1 + 40));
  if (!nw_parameters_get_logging_disabled(*(*(a1 + 32) + 40)))
  {
    if (__nwlog_browser_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
    }

    v3 = gbrowserLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      v4 = *(a1 + 40);
      v5 = *(*(a1 + 32) + 192);
      *buf = 136446722;
      v24 = "nw_browser_cancel_query_record_for_endpoint_locked_block_invoke";
      v25 = 1024;
      v26 = v5;
      v27 = 2048;
      v28 = v4;
      _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] deallocate dns_ref %p", buf, 0x1Cu);
    }
  }
}

uint64_t ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_2_113(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  endpoint = nw_browse_result_get_endpoint(v4);
  is_equal = nw_endpoint_is_equal(endpoint, *(a1 + 32), 0);
  if (is_equal)
  {
    v7 = *(a1 + 40);
    if (v7)
    {
      v11[0] = MEMORY[0x1E69E9820];
      v11[1] = 3221225472;
      v11[2] = ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_3;
      v11[3] = &unk_1E6A35E08;
      v8 = v7;
      v9 = *(a1 + 48);
      v12 = v8;
      v13 = v9;
      nw_browse_result_enumerate_interfaces(v4, v11);
    }

    else
    {
      *(*(*(a1 + 48) + 8) + 24) = 0;
    }
  }

  return is_equal ^ 1u;
}

uint64_t nw_browser_add_result_locked(void *a1, const char *a2, void *a3, void *a4, int a5)
{
  v72 = *MEMORY[0x1E69E9840];
  v9 = a1;
  v10 = a3;
  v11 = a4;
  if (v9)
  {
    uint64 = xpc_dictionary_get_uint64(*(v9 + 20), a2);
    v13 = nw_browser_copy_result_to_modify_locked(v9, a2, uint64);
    v14 = v13;
    if (uint64)
    {
      if (!v11)
      {
        goto LABEL_29;
      }

      nw_browse_result_set_discovered_from_path(v13, a5);
      if (nw_browse_result_insert_interface(v14, v11))
      {
        xpc_dictionary_set_uint64(*(v9 + 20), a2, uint64 | 8);
        if (!nw_parameters_get_logging_disabled(*(v9 + 5)))
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v15 = gbrowserLogObj;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            v16 = *(v9 + 48);
            *buf = 136446978;
            v65 = "nw_browser_add_result_locked";
            v66 = 1024;
            *v67 = v16;
            *&v67[4] = 2080;
            *&v67[6] = a2;
            v68 = 2112;
            v69 = v11;
            _os_log_impl(&dword_181A37000, v15, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s interface_added(%@)", buf, 0x26u);
          }

LABEL_28:
        }

LABEL_29:
        v22 = 1;
LABEL_92:

        goto LABEL_93;
      }

      if (!nw_parameters_get_logging_disabled(*(v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v23 = gbrowserLogObj;
        v24 = *(v9 + 48);
        *buf = 136446978;
        v65 = "nw_browser_add_result_locked";
        v66 = 1024;
        *v67 = v24;
        *&v67[4] = 2112;
        *&v67[6] = v11;
        v68 = 2080;
        v69 = a2;
        v25 = _os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v62 = 0;
        if (__nwlog_fault(v25, &type, &v62))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v26 = gbrowserLogObj;
            v27 = type;
            if (os_log_type_enabled(v26, type))
            {
              v28 = *(v9 + 48);
              *buf = 136446978;
              v65 = "nw_browser_add_result_locked";
              v66 = 1024;
              *v67 = v28;
              *&v67[4] = 2112;
              *&v67[6] = v11;
              v68 = 2080;
              v69 = a2;
              _os_log_impl(&dword_181A37000, v26, v27, "%{public}s [B%u] tried to insert duplicate interface %@ for %s", buf, 0x26u);
            }
          }

          else if (v62 == 1)
          {
            backtrace_string = __nw_create_backtrace_string();
            if (backtrace_string)
            {
              v36 = backtrace_string;
              if (__nwlog_browser_log::onceToken != -1)
              {
                dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
              }

              v37 = gbrowserLogObj;
              v38 = type;
              if (os_log_type_enabled(v37, type))
              {
                v39 = *(v9 + 48);
                *buf = 136447234;
                v65 = "nw_browser_add_result_locked";
                v66 = 1024;
                *v67 = v39;
                *&v67[4] = 2112;
                *&v67[6] = v11;
                v68 = 2080;
                v69 = a2;
                v70 = 2082;
                v71 = v36;
                _os_log_impl(&dword_181A37000, v37, v38, "%{public}s [B%u] tried to insert duplicate interface %@ for %s, dumping backtrace:%{public}s", buf, 0x30u);
              }

              free(v36);
              if (!v25)
              {
                goto LABEL_91;
              }

              goto LABEL_82;
            }

            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v26 = gbrowserLogObj;
            v49 = type;
            if (os_log_type_enabled(v26, type))
            {
              v50 = *(v9 + 48);
              *buf = 136446978;
              v65 = "nw_browser_add_result_locked";
              v66 = 1024;
              *v67 = v50;
              *&v67[4] = 2112;
              *&v67[6] = v11;
              v68 = 2080;
              v69 = a2;
              _os_log_impl(&dword_181A37000, v26, v49, "%{public}s [B%u] tried to insert duplicate interface %@ for %s, no backtrace", buf, 0x26u);
            }
          }

          else
          {
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v26 = gbrowserLogObj;
            v45 = type;
            if (os_log_type_enabled(v26, type))
            {
              v46 = *(v9 + 48);
              *buf = 136446978;
              v65 = "nw_browser_add_result_locked";
              v66 = 1024;
              *v67 = v46;
              *&v67[4] = 2112;
              *&v67[6] = v11;
              v68 = 2080;
              v69 = a2;
              _os_log_impl(&dword_181A37000, v26, v45, "%{public}s [B%u] tried to insert duplicate interface %@ for %s, backtrace limit exceeded", buf, 0x26u);
            }
          }
        }

        if (v25)
        {
LABEL_82:
          free(v25);
        }
      }

LABEL_91:
      v22 = 0;
      goto LABEL_92;
    }

    v15 = nw_browse_result_create(v10);
    nw_browse_result_set_discovered_from_path(v15, a5);
    if (!v11 || (nw_browse_result_insert_interface(v15, v11) & 1) != 0)
    {
      v17 = *(v9 + 18);
      if (v17 && v15)
      {
        _nw_array_append(v17, v15);
      }

      if (!nw_parameters_get_logging_disabled(*(v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v18 = gbrowserLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          v19 = *(v9 + 48);
          *buf = 136446722;
          v65 = "nw_browser_add_result_locked";
          v66 = 1024;
          *v67 = v19;
          *&v67[4] = 2112;
          *&v67[6] = v15;
          _os_log_impl(&dword_181A37000, v18, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] new: added %@ to new_results", buf, 0x1Cu);
        }
      }

      xpc_dictionary_set_uint64(*(v9 + 20), a2, 2uLL);
      if (!nw_parameters_get_logging_disabled(*(v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v20 = gbrowserLogObj;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          v21 = *(v9 + 48);
          *buf = 136446978;
          v65 = "nw_browser_add_result_locked";
          v66 = 1024;
          *v67 = v21;
          *&v67[4] = 2080;
          *&v67[6] = a2;
          v68 = 1024;
          LODWORD(v69) = 2;
          _os_log_impl(&dword_181A37000, v20, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s = result_added(%d)", buf, 0x22u);
        }
      }

      goto LABEL_28;
    }

    if (!nw_parameters_get_logging_disabled(*(v9 + 5)))
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v29 = gbrowserLogObj;
      v30 = *(v9 + 48);
      *buf = 136446978;
      v65 = "nw_browser_add_result_locked";
      v66 = 1024;
      *v67 = v30;
      *&v67[4] = 2112;
      *&v67[6] = v11;
      v68 = 2080;
      v69 = a2;
      v31 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v62 = 0;
      if (__nwlog_fault(v31, &type, &v62))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v32 = gbrowserLogObj;
          v33 = type;
          if (os_log_type_enabled(v32, type))
          {
            v34 = *(v9 + 48);
            *buf = 136446978;
            v65 = "nw_browser_add_result_locked";
            v66 = 1024;
            *v67 = v34;
            *&v67[4] = 2112;
            *&v67[6] = v11;
            v68 = 2080;
            v69 = a2;
            _os_log_impl(&dword_181A37000, v32, v33, "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s", buf, 0x26u);
          }
        }

        else if (v62 == 1)
        {
          v40 = __nw_create_backtrace_string();
          if (v40)
          {
            v41 = v40;
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v42 = gbrowserLogObj;
            v43 = type;
            if (os_log_type_enabled(v42, type))
            {
              v44 = *(v9 + 48);
              *buf = 136447234;
              v65 = "nw_browser_add_result_locked";
              v66 = 1024;
              *v67 = v44;
              *&v67[4] = 2112;
              *&v67[6] = v11;
              v68 = 2080;
              v69 = a2;
              v70 = 2082;
              v71 = v41;
              _os_log_impl(&dword_181A37000, v42, v43, "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s, dumping backtrace:%{public}s", buf, 0x30u);
            }

            free(v41);
            if (!v31)
            {
              goto LABEL_90;
            }

            goto LABEL_89;
          }

          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v32 = gbrowserLogObj;
          v51 = type;
          if (os_log_type_enabled(v32, type))
          {
            v52 = *(v9 + 48);
            *buf = 136446978;
            v65 = "nw_browser_add_result_locked";
            v66 = 1024;
            *v67 = v52;
            *&v67[4] = 2112;
            *&v67[6] = v11;
            v68 = 2080;
            v69 = a2;
            _os_log_impl(&dword_181A37000, v32, v51, "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s, no backtrace", buf, 0x26u);
          }
        }

        else
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v32 = gbrowserLogObj;
          v47 = type;
          if (os_log_type_enabled(v32, type))
          {
            v48 = *(v9 + 48);
            *buf = 136446978;
            v65 = "nw_browser_add_result_locked";
            v66 = 1024;
            *v67 = v48;
            *&v67[4] = 2112;
            *&v67[6] = v11;
            v68 = 2080;
            v69 = a2;
            _os_log_impl(&dword_181A37000, v32, v47, "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s, backtrace limit exceeded", buf, 0x26u);
          }
        }
      }

      if (v31)
      {
LABEL_89:
        free(v31);
      }
    }

LABEL_90:

    goto LABEL_91;
  }

  v54 = __nwlog_obj();
  *buf = 136446210;
  v65 = "nw_browser_add_result_locked";
  v55 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v62 = 0;
  if (__nwlog_fault(v55, &type, &v62))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v56 = __nwlog_obj();
      v57 = type;
      if (os_log_type_enabled(v56, type))
      {
        *buf = 136446210;
        v65 = "nw_browser_add_result_locked";
        _os_log_impl(&dword_181A37000, v56, v57, "%{public}s called with null browser", buf, 0xCu);
      }
    }

    else if (v62 == 1)
    {
      v58 = __nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v59 = type;
      v60 = os_log_type_enabled(v56, type);
      if (v58)
      {
        if (v60)
        {
          *buf = 136446466;
          v65 = "nw_browser_add_result_locked";
          v66 = 2082;
          *v67 = v58;
          _os_log_impl(&dword_181A37000, v56, v59, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v58);
        goto LABEL_110;
      }

      if (v60)
      {
        *buf = 136446210;
        v65 = "nw_browser_add_result_locked";
        _os_log_impl(&dword_181A37000, v56, v59, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v56 = __nwlog_obj();
      v61 = type;
      if (os_log_type_enabled(v56, type))
      {
        *buf = 136446210;
        v65 = "nw_browser_add_result_locked";
        _os_log_impl(&dword_181A37000, v56, v61, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_110:
  if (v55)
  {
    free(v55);
  }

  v22 = 0;
LABEL_93:

  return v22;
}

uint64_t ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_3(uint64_t a1, void *a2)
{
  v3 = _nw_interface_shallow_compare(*(a1 + 32), a2);
  if (v3)
  {
    *(*(*(a1 + 40) + 8) + 24) = 0;
  }

  return v3 ^ 1u;
}

uint64_t ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_2_123(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  v7 = a3;
  v8 = a4;
  v9 = v7;
  v10 = v8;
  v11 = v10;
  if (v9)
  {
    v9[52] |= 1u;
  }

  if (v10)
  {
    *(v10 + 52) |= 1u;
  }

  v12 = *(*(a1 + 32) + 40);
  v17[0] = MEMORY[0x1E69E9820];
  v17[1] = 3221225472;
  v17[2] = ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_3;
  v17[3] = &unk_1E6A35EF8;
  v20 = *(a1 + 40);
  v13 = v9;
  v18 = v13;
  v14 = v11;
  v19 = v14;
  v15 = *(a1 + 48);
  v21 = a2;
  v22 = v15;
  nw_utilities_execute_block_as_persona_from_parameters(v12, v17);

  return 1;
}

void nw_browser_dns_service_browse_callback(_DNSServiceRef_t *a1, int a2, int a3, int a4, char *a5, const char *a6, const char *a7, void *a8)
{
  v120 = *MEMORY[0x1E69E9840];
  v13 = a8;
  v14 = v13;
  if (v13)
  {
    os_unfair_lock_lock(v13 + 2);
    os_unfair_lock_opaque = v14[18]._os_unfair_lock_opaque;
    if (os_unfair_lock_opaque != 1 && os_unfair_lock_opaque != 4)
    {
      if (!nw_parameters_get_logging_disabled(*&v14[10]._os_unfair_lock_opaque))
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v23 = gbrowserLogObj;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          v24 = v14[48]._os_unfair_lock_opaque;
          *buf = 136446466;
          v107 = "nw_browser_dns_service_browse_callback";
          v108 = 1024;
          *v109 = v24;
          _os_log_impl(&dword_181A37000, v23, OS_LOG_TYPE_ERROR, "%{public}s [B%u] not in ready or waiting state", buf, 0x12u);
        }
      }

      goto LABEL_48;
    }

    if (BYTE2(v14[49]._os_unfair_lock_opaque) != 1)
    {
      if (!nw_parameters_get_logging_disabled(*&v14[10]._os_unfair_lock_opaque))
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v21 = gbrowserLogObj;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          v22 = v14[48]._os_unfair_lock_opaque;
          *buf = 136448002;
          v107 = "nw_browser_dns_service_browse_callback";
          v108 = 1024;
          *v109 = v22;
          *&v109[4] = 2082;
          *&v109[6] = a5;
          *&v109[14] = 2082;
          *&v109[16] = a6;
          v110 = 2082;
          v111 = a7;
          v112 = 1024;
          v113 = a2;
          v114 = 1024;
          v115 = a3;
          v116 = 1024;
          v117 = a4;
          _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] dns: (%{public}s %{public}s %{public}s), flags: %u, if_index: %u, error: %d", buf, 0x42u);
        }
      }

LABEL_31:
      if (nw_browser_fail_on_dns_error_locked(v14, a4, "nw_browser_dns_service_browse_callback"))
      {
        goto LABEL_48;
      }

      v27 = v14[18]._os_unfair_lock_opaque;
      if (v27 == 4)
      {
        nw_browser_set_state_locked(v14, 1, 0);
        v27 = v14[18]._os_unfair_lock_opaque;
      }

      if (v27 != 1)
      {
        goto LABEL_48;
      }

      if (!a5 || !*a5)
      {
        if (!nw_parameters_get_logging_disabled(*&v14[10]._os_unfair_lock_opaque))
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v30 = gbrowserLogObj;
          if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
          {
            v31 = v14[48]._os_unfair_lock_opaque;
            *buf = 136446466;
            v107 = "nw_browser_dns_service_browse_callback";
            v108 = 1024;
            *v109 = v31;
            _os_log_impl(&dword_181A37000, v30, OS_LOG_TYPE_INFO, "%{public}s [B%u] Received empty result, ignoring", buf, 0x12u);
          }
        }

        goto LABEL_48;
      }

      if ((a3 - 1) > 0xFFFFFFFD)
      {
        if (a3 == -1)
        {
          v29 = _nw_interface_create_with_name("lo0");
          if (!v29)
          {
            goto LABEL_149;
          }
        }

        else
        {
          v29 = 0;
        }
      }

      else
      {
        if (nw_context_copy_implicit_context::onceToken[0] != -1)
        {
          dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
        }

        v28 = nw_context_copy_implicit_context::implicit_context;
        v29 = nw_path_copy_interface_with_generation(v28, a3, 0);

        if (!v29)
        {
LABEL_149:
          if (nw_parameters_get_logging_disabled(*&v14[10]._os_unfair_lock_opaque))
          {
LABEL_48:
            os_unfair_lock_unlock(v14 + 2);
            goto LABEL_49;
          }

          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v74 = gbrowserLogObj;
          v75 = v14[48]._os_unfair_lock_opaque;
          *buf = 136446722;
          v107 = "nw_browser_dns_service_browse_callback";
          v108 = 1024;
          *v109 = v75;
          *&v109[4] = 1024;
          *&v109[6] = a3;
          v76 = _os_log_send_and_compose_impl();

          v93[0] = 16;
          LOBYTE(v118) = 0;
          if (__nwlog_fault(v76, v93, &v118))
          {
            if (v93[0] == 17)
            {
              if (__nwlog_browser_log::onceToken != -1)
              {
                dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
              }

              v77 = gbrowserLogObj;
              v78 = v93[0];
              if (os_log_type_enabled(v77, v93[0]))
              {
                v79 = v14[48]._os_unfair_lock_opaque;
                *buf = 136446722;
                v107 = "nw_browser_dns_service_browse_callback";
                v108 = 1024;
                *v109 = v79;
                *&v109[4] = 1024;
                *&v109[6] = a3;
                _os_log_impl(&dword_181A37000, v77, v78, "%{public}s [B%u] dns: no interface found for if_index %u", buf, 0x18u);
              }
            }

            else if (v118 == 1)
            {
              backtrace_string = __nw_create_backtrace_string();
              if (backtrace_string)
              {
                v81 = backtrace_string;
                if (__nwlog_browser_log::onceToken != -1)
                {
                  dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
                }

                v82 = gbrowserLogObj;
                v83 = v93[0];
                if (os_log_type_enabled(v82, v93[0]))
                {
                  v84 = v14[48]._os_unfair_lock_opaque;
                  *buf = 136446978;
                  v107 = "nw_browser_dns_service_browse_callback";
                  v108 = 1024;
                  *v109 = v84;
                  *&v109[4] = 1024;
                  *&v109[6] = a3;
                  *&v109[10] = 2082;
                  *&v109[12] = v81;
                  _os_log_impl(&dword_181A37000, v82, v83, "%{public}s [B%u] dns: no interface found for if_index %u, dumping backtrace:%{public}s", buf, 0x22u);
                }

                free(v81);
                goto LABEL_176;
              }

              if (__nwlog_browser_log::onceToken != -1)
              {
                dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
              }

              v77 = gbrowserLogObj;
              v87 = v93[0];
              if (os_log_type_enabled(v77, v93[0]))
              {
                v88 = v14[48]._os_unfair_lock_opaque;
                *buf = 136446722;
                v107 = "nw_browser_dns_service_browse_callback";
                v108 = 1024;
                *v109 = v88;
                *&v109[4] = 1024;
                *&v109[6] = a3;
                _os_log_impl(&dword_181A37000, v77, v87, "%{public}s [B%u] dns: no interface found for if_index %u, no backtrace", buf, 0x18u);
              }
            }

            else
            {
              if (__nwlog_browser_log::onceToken != -1)
              {
                dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
              }

              v77 = gbrowserLogObj;
              v85 = v93[0];
              if (os_log_type_enabled(v77, v93[0]))
              {
                v86 = v14[48]._os_unfair_lock_opaque;
                *buf = 136446722;
                v107 = "nw_browser_dns_service_browse_callback";
                v108 = 1024;
                *v109 = v86;
                *&v109[4] = 1024;
                *&v109[6] = a3;
                _os_log_impl(&dword_181A37000, v77, v85, "%{public}s [B%u] dns: no interface found for if_index %u, backtrace limit exceeded", buf, 0x18u);
              }
            }
          }

LABEL_176:
          if (v76)
          {
            free(v76);
          }

          goto LABEL_48;
        }
      }

      bzero(buf, 0x3F1uLL);
      v32 = DNSServiceConstructFullName(buf, a5, a6, a7);
      if (v32)
      {
        dns_error = nw_error_create_dns_error(v32);
        if (nw_parameters_get_logging_disabled(*&v14[10]._os_unfair_lock_opaque))
        {
LABEL_96:
          os_unfair_lock_unlock(v14 + 2);

          goto LABEL_140;
        }

        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v34 = gbrowserLogObj;
        v35 = v14[48]._os_unfair_lock_opaque;
        *v93 = 136447491;
        *&v93[4] = "nw_browser_dns_service_browse_callback";
        v94 = 1024;
        v95 = v35;
        v96 = 2085;
        v97 = a5;
        v98 = 2082;
        v99 = a6;
        v100 = 2085;
        v101 = a7;
        v102 = 2114;
        v90 = dns_error;
        v103 = dns_error;
        v36 = _os_log_send_and_compose_impl();

        LOBYTE(v118) = 16;
        type = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v36, &v118, &type))
        {
          if (v118 == 17)
          {
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v37 = gbrowserLogObj;
            v38 = v118;
            if (os_log_type_enabled(v37, v118))
            {
              v39 = v14[48]._os_unfair_lock_opaque;
              *v93 = 136447491;
              *&v93[4] = "nw_browser_dns_service_browse_callback";
              v94 = 1024;
              v95 = v39;
              v96 = 2085;
              v97 = a5;
              v98 = 2082;
              v99 = a6;
              v100 = 2085;
              v101 = a7;
              v102 = 2114;
              v103 = v90;
              _os_log_impl(&dword_181A37000, v37, v38, "%{public}s [B%u] DNSServiceConstructFullName(..., %{sensitive}s, %{public}s, %{sensitive}s) failed: %{public}@", v93, 0x3Au);
            }
          }

          else if (type == OS_LOG_TYPE_INFO)
          {
            v42 = __nw_create_backtrace_string();
            if (v42)
            {
              v43 = v42;
              if (__nwlog_browser_log::onceToken != -1)
              {
                dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
              }

              v44 = gbrowserLogObj;
              v45 = v118;
              if (os_log_type_enabled(v44, v118))
              {
                v46 = v14[48]._os_unfair_lock_opaque;
                *v93 = 136447747;
                *&v93[4] = "nw_browser_dns_service_browse_callback";
                v94 = 1024;
                v95 = v46;
                v96 = 2085;
                v97 = a5;
                v98 = 2082;
                v99 = a6;
                v100 = 2085;
                v101 = a7;
                v102 = 2114;
                v103 = v90;
                v104 = 2082;
                v105 = v43;
                _os_log_impl(&dword_181A37000, v44, v45, "%{public}s [B%u] DNSServiceConstructFullName(..., %{sensitive}s, %{public}s, %{sensitive}s) failed: %{public}@, dumping backtrace:%{public}s", v93, 0x44u);
              }

              free(v43);
              goto LABEL_93;
            }

            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v37 = gbrowserLogObj;
            v49 = v118;
            if (os_log_type_enabled(v37, v118))
            {
              v50 = v14[48]._os_unfair_lock_opaque;
              *v93 = 136447491;
              *&v93[4] = "nw_browser_dns_service_browse_callback";
              v94 = 1024;
              v95 = v50;
              v96 = 2085;
              v97 = a5;
              v98 = 2082;
              v99 = a6;
              v100 = 2085;
              v101 = a7;
              v102 = 2114;
              v103 = v90;
              _os_log_impl(&dword_181A37000, v37, v49, "%{public}s [B%u] DNSServiceConstructFullName(..., %{sensitive}s, %{public}s, %{sensitive}s) failed: %{public}@, no backtrace", v93, 0x3Au);
            }
          }

          else
          {
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v37 = gbrowserLogObj;
            v47 = v118;
            if (os_log_type_enabled(v37, v118))
            {
              v48 = v14[48]._os_unfair_lock_opaque;
              *v93 = 136447491;
              *&v93[4] = "nw_browser_dns_service_browse_callback";
              v94 = 1024;
              v95 = v48;
              v96 = 2085;
              v97 = a5;
              v98 = 2082;
              v99 = a6;
              v100 = 2085;
              v101 = a7;
              v102 = 2114;
              v103 = v90;
              _os_log_impl(&dword_181A37000, v37, v47, "%{public}s [B%u] DNSServiceConstructFullName(..., %{sensitive}s, %{public}s, %{sensitive}s) failed: %{public}@, backtrace limit exceeded", v93, 0x3Au);
            }
          }
        }

LABEL_93:
        if (v36)
        {
          free(v36);
        }

        dns_error = v90;
        goto LABEL_96;
      }

      nw_browser_strict_strlcpy_tolower(buf, buf);
      if ((a2 & 2) == 0 || !a7)
      {
        if ((nw_browser_remove_result_locked(v14, buf, v29) & 1) == 0)
        {
LABEL_139:
          os_unfair_lock_unlock(v14 + 2);
          goto LABEL_140;
        }

LABEL_137:
        if ((a2 & 1) == 0)
        {
          nw_browser_notify_browse_result_changes_locked(v14);
        }

        goto LABEL_139;
      }

      bonjour_service = nw_endpoint_create_bonjour_service(a5, a6, a7);
      v118 = 0;
      ValidationData = DNSServiceGetValidationData();
      if (ValidationData && v118)
      {
        nw_endpoint_set_signature(bonjour_service, ValidationData, v118);
      }

      if (!nw_browser_add_result_locked(v14, buf, bonjour_service, v29, 0))
      {
        os_unfair_lock_unlock(v14 + 2);

LABEL_140:
        goto LABEL_49;
      }

      if (LOBYTE(v14[49]._os_unfair_lock_opaque) != 1)
      {
LABEL_136:

        goto LABEL_137;
      }

      if (nw_browser_endpoint_matches_key(bonjour_service, buf))
      {
        nw_browser_start_query_record_for_endpoint_locked(v14, bonjour_service, buf, v29);
        goto LABEL_136;
      }

      if (nw_parameters_get_logging_disabled(*&v14[10]._os_unfair_lock_opaque))
      {
        goto LABEL_136;
      }

      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v51 = gbrowserLogObj;
      v52 = v14[48]._os_unfair_lock_opaque;
      *v93 = 136446979;
      *&v93[4] = "nw_browser_dns_service_browse_callback";
      v94 = 1024;
      v95 = v52;
      v96 = 2085;
      v97 = buf;
      v98 = 2112;
      v99 = bonjour_service;
      v53 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v91 = 0;
      if (__nwlog_fault(v53, &type, &v91))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v54 = gbrowserLogObj;
          v55 = type;
          if (os_log_type_enabled(v54, type))
          {
            v56 = v14[48]._os_unfair_lock_opaque;
            *v93 = 136446979;
            *&v93[4] = "nw_browser_dns_service_browse_callback";
            v94 = 1024;
            v95 = v56;
            v96 = 2085;
            v97 = buf;
            v98 = 2112;
            v99 = bonjour_service;
            _os_log_impl(&dword_181A37000, v54, v55, "%{public}s [B%u] key_name %{sensitive}s does not match new_endpoint %@", v93, 0x26u);
          }
        }

        else if (v91 == 1)
        {
          v57 = __nw_create_backtrace_string();
          if (v57)
          {
            v58 = v57;
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v59 = gbrowserLogObj;
            v60 = type;
            if (os_log_type_enabled(v59, type))
            {
              v61 = v14[48]._os_unfair_lock_opaque;
              *v93 = 136447235;
              *&v93[4] = "nw_browser_dns_service_browse_callback";
              v94 = 1024;
              v95 = v61;
              v96 = 2085;
              v97 = buf;
              v98 = 2112;
              v99 = bonjour_service;
              v100 = 2082;
              v101 = v58;
              _os_log_impl(&dword_181A37000, v59, v60, "%{public}s [B%u] key_name %{sensitive}s does not match new_endpoint %@, dumping backtrace:%{public}s", v93, 0x30u);
            }

            free(v58);
            goto LABEL_134;
          }

          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v54 = gbrowserLogObj;
          v71 = type;
          if (os_log_type_enabled(v54, type))
          {
            v72 = v14[48]._os_unfair_lock_opaque;
            *v93 = 136446979;
            *&v93[4] = "nw_browser_dns_service_browse_callback";
            v94 = 1024;
            v95 = v72;
            v96 = 2085;
            v97 = buf;
            v98 = 2112;
            v99 = bonjour_service;
            _os_log_impl(&dword_181A37000, v54, v71, "%{public}s [B%u] key_name %{sensitive}s does not match new_endpoint %@, no backtrace", v93, 0x26u);
          }
        }

        else
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v54 = gbrowserLogObj;
          v66 = type;
          if (os_log_type_enabled(v54, type))
          {
            v67 = v14[48]._os_unfair_lock_opaque;
            *v93 = 136446979;
            *&v93[4] = "nw_browser_dns_service_browse_callback";
            v94 = 1024;
            v95 = v67;
            v96 = 2085;
            v97 = buf;
            v98 = 2112;
            v99 = bonjour_service;
            _os_log_impl(&dword_181A37000, v54, v66, "%{public}s [B%u] key_name %{sensitive}s does not match new_endpoint %@, backtrace limit exceeded", v93, 0x26u);
          }
        }
      }

LABEL_134:
      if (v53)
      {
        free(v53);
      }

      goto LABEL_136;
    }

    v93[8] = 0;
    *v93 = 0;
    v119 = 0;
    v118 = 0;
    if (a5)
    {
      v17 = strlen(a5);
      v18 = v93;
      __nwlog_salted_hash(a5, v17, v93);
      if (a7)
      {
LABEL_10:
        v19 = strlen(a7);
        v20 = &v118;
        __nwlog_salted_hash(a7, v19, &v118);
        goto LABEL_25;
      }
    }

    else
    {
      v18 = "<NULL>";
      if (a7)
      {
        goto LABEL_10;
      }
    }

    v20 = "<NULL>";
LABEL_25:
    if (!nw_parameters_get_logging_disabled(*&v14[10]._os_unfair_lock_opaque))
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v25 = gbrowserLogObj;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        v26 = v14[48]._os_unfair_lock_opaque;
        *buf = 136448002;
        v107 = "nw_browser_dns_service_browse_callback";
        v108 = 1024;
        *v109 = v26;
        *&v109[4] = 2082;
        *&v109[6] = v18;
        *&v109[14] = 2082;
        *&v109[16] = a6;
        v110 = 2082;
        v111 = v20;
        v112 = 1024;
        v113 = a2;
        v114 = 1024;
        v115 = a3;
        v116 = 1024;
        v117 = a4;
        _os_log_impl(&dword_181A37000, v25, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] dns: (#%{public}s %{public}s #%{public}s), flags: %u, if_index: %u, error: %d", buf, 0x42u);
      }
    }

    goto LABEL_31;
  }

  v62 = __nwlog_obj();
  *buf = 136446210;
  v107 = "nw_browser_dns_service_browse_callback";
  v63 = _os_log_send_and_compose_impl();

  v93[0] = 16;
  LOBYTE(v118) = 0;
  if (__nwlog_fault(v63, v93, &v118))
  {
    if (v93[0] == 17)
    {
      v64 = __nwlog_obj();
      v65 = v93[0];
      if (os_log_type_enabled(v64, v93[0]))
      {
        *buf = 136446210;
        v107 = "nw_browser_dns_service_browse_callback";
        _os_log_impl(&dword_181A37000, v64, v65, "%{public}s called with null browser", buf, 0xCu);
      }
    }

    else if (v118 == 1)
    {
      v68 = __nw_create_backtrace_string();
      v64 = __nwlog_obj();
      v69 = v93[0];
      v70 = os_log_type_enabled(v64, v93[0]);
      if (v68)
      {
        if (v70)
        {
          *buf = 136446466;
          v107 = "nw_browser_dns_service_browse_callback";
          v108 = 2082;
          *v109 = v68;
          _os_log_impl(&dword_181A37000, v64, v69, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v68);
        goto LABEL_147;
      }

      if (v70)
      {
        *buf = 136446210;
        v107 = "nw_browser_dns_service_browse_callback";
        _os_log_impl(&dword_181A37000, v64, v69, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v64 = __nwlog_obj();
      v73 = v93[0];
      if (os_log_type_enabled(v64, v93[0]))
      {
        *buf = 136446210;
        v107 = "nw_browser_dns_service_browse_callback";
        _os_log_impl(&dword_181A37000, v64, v73, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_147:
  if (v63)
  {
    free(v63);
  }

LABEL_49:
}

void nw_browser_start_query_record_for_endpoint_locked(void *a1, void *a2, const char *a3, void *a4)
{
  v54 = *MEMORY[0x1E69E9840];
  context = a1;
  v8 = a2;
  v9 = a4;
  if (v8)
  {
    if (a3)
    {
      v10 = *(context + 5);
      if (*(context + 18) == 1)
      {
        if (!nw_parameters_get_logging_disabled(v10))
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v11 = gbrowserLogObj;
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            v12 = *(context + 48);
            *buf = 136446978;
            v49 = "nw_browser_start_query_record_for_endpoint_locked";
            v50 = 1024;
            *v51 = v12;
            *&v51[4] = 2080;
            *&v51[6] = a3;
            v52 = 2112;
            v53 = v9;
            _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] start query record for %s on %@", buf, 0x26u);
          }
        }

        *type = *(context + 15);
        v13 = nw_browser_derive_endpoint_flags(context);
        v46 = 0;
        v14 = v8;
        signature = _nw_endpoint_get_signature(v14, &v46);

        v16 = 0;
        if (signature && v46)
        {
          v16 = DNSServiceAttributeCreate();
          DNSServiceAttrSetValidationData();
        }

        if (v9)
        {
          index = _nw_interface_get_index(v9);
        }

        else
        {
          index = 0;
        }

        RecordWithAttribute = DNSServiceQueryRecordWithAttribute(type, v13, index, a3, 0x10u, 1u, v16, nw_browser_dns_service_query_record_callback, context);
        if (v16)
        {
          DNSServiceAttributeDeallocate(v16);
        }

        if (nw_browser_fail_on_dns_error_locked(context, RecordWithAttribute, "DNSServiceQueryRecord"))
        {
          goto LABEL_55;
        }

        browser_key_for = nw_create_browser_key_for (a3, v9);
        xpc_dictionary_set_pointer();
        if (nw_parameters_get_logging_disabled(*(context + 5)))
        {
          goto LABEL_53;
        }

        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v21 = gbrowserLogObj;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          v30 = *(context + 48);
          *buf = 136446978;
          v49 = "nw_browser_start_query_record_for_endpoint_locked";
          v50 = 1024;
          *v51 = v30;
          *&v51[4] = 2080;
          *&v51[6] = browser_key_for;
          v52 = 2048;
          v53 = *type;
          _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] dns_ref_map: set %s -> %p", buf, 0x26u);
        }
      }

      else
      {
        if (nw_parameters_get_logging_disabled(v10))
        {
          goto LABEL_55;
        }

        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v18 = gbrowserLogObj;
        v19 = *(context + 48);
        *buf = 136446466;
        v49 = "nw_browser_start_query_record_for_endpoint_locked";
        v50 = 1024;
        *v51 = v19;
        browser_key_for = _os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v46) = 0;
        if (!__nwlog_fault(browser_key_for, type, &v46))
        {
          goto LABEL_53;
        }

        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v21 = gbrowserLogObj;
          v22 = type[0];
          if (os_log_type_enabled(v21, type[0]))
          {
            v23 = *(context + 48);
            *buf = 136446466;
            v49 = "nw_browser_start_query_record_for_endpoint_locked";
            v50 = 1024;
            *v51 = v23;
            _os_log_impl(&dword_181A37000, v21, v22, "%{public}s [B%u] not in ready state", buf, 0x12u);
          }
        }

        else if (v46 == 1)
        {
          backtrace_string = __nw_create_backtrace_string();
          if (backtrace_string)
          {
            v25 = backtrace_string;
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v26 = gbrowserLogObj;
            v27 = type[0];
            if (os_log_type_enabled(v26, type[0]))
            {
              v28 = *(context + 48);
              *buf = 136446722;
              v49 = "nw_browser_start_query_record_for_endpoint_locked";
              v50 = 1024;
              *v51 = v28;
              *&v51[4] = 2082;
              *&v51[6] = v25;
              _os_log_impl(&dword_181A37000, v26, v27, "%{public}s [B%u] not in ready state, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v25);
            if (browser_key_for)
            {
              goto LABEL_54;
            }

            goto LABEL_55;
          }

          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v21 = gbrowserLogObj;
          v33 = type[0];
          if (os_log_type_enabled(v21, type[0]))
          {
            v34 = *(context + 48);
            *buf = 136446466;
            v49 = "nw_browser_start_query_record_for_endpoint_locked";
            v50 = 1024;
            *v51 = v34;
            _os_log_impl(&dword_181A37000, v21, v33, "%{public}s [B%u] not in ready state, no backtrace", buf, 0x12u);
          }
        }

        else
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v21 = gbrowserLogObj;
          v31 = type[0];
          if (os_log_type_enabled(v21, type[0]))
          {
            v32 = *(context + 48);
            *buf = 136446466;
            v49 = "nw_browser_start_query_record_for_endpoint_locked";
            v50 = 1024;
            *v51 = v32;
            _os_log_impl(&dword_181A37000, v21, v31, "%{public}s [B%u] not in ready state, backtrace limit exceeded", buf, 0x12u);
          }
        }
      }

      goto LABEL_52;
    }

    v37 = __nwlog_obj();
    *buf = 136446210;
    v49 = "nw_browser_start_query_record_for_endpoint_locked";
    browser_key_for = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v46) = 0;
    if (__nwlog_fault(browser_key_for, type, &v46))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v21 = __nwlog_obj();
        v38 = type[0];
        if (os_log_type_enabled(v21, type[0]))
        {
          *buf = 136446210;
          v49 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_181A37000, v21, v38, "%{public}s called with null fullname", buf, 0xCu);
        }

LABEL_52:

        goto LABEL_53;
      }

      if (v46 != 1)
      {
        v21 = __nwlog_obj();
        v45 = type[0];
        if (os_log_type_enabled(v21, type[0]))
        {
          *buf = 136446210;
          v49 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_181A37000, v21, v45, "%{public}s called with null fullname, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_52;
      }

      v39 = __nw_create_backtrace_string();
      v21 = __nwlog_obj();
      v42 = type[0];
      v43 = os_log_type_enabled(v21, type[0]);
      if (!v39)
      {
        if (v43)
        {
          *buf = 136446210;
          v49 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_181A37000, v21, v42, "%{public}s called with null fullname, no backtrace", buf, 0xCu);
        }

        goto LABEL_52;
      }

      if (v43)
      {
        *buf = 136446466;
        v49 = "nw_browser_start_query_record_for_endpoint_locked";
        v50 = 2082;
        *v51 = v39;
        _os_log_impl(&dword_181A37000, v21, v42, "%{public}s called with null fullname, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_75:

      free(v39);
      if (!browser_key_for)
      {
        goto LABEL_55;
      }

      goto LABEL_54;
    }
  }

  else
  {
    v35 = __nwlog_obj();
    *buf = 136446210;
    v49 = "nw_browser_start_query_record_for_endpoint_locked";
    browser_key_for = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v46) = 0;
    if (__nwlog_fault(browser_key_for, type, &v46))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v21 = __nwlog_obj();
        v36 = type[0];
        if (os_log_type_enabled(v21, type[0]))
        {
          *buf = 136446210;
          v49 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_181A37000, v21, v36, "%{public}s called with null endpoint", buf, 0xCu);
        }

        goto LABEL_52;
      }

      if (v46 != 1)
      {
        v21 = __nwlog_obj();
        v44 = type[0];
        if (os_log_type_enabled(v21, type[0]))
        {
          *buf = 136446210;
          v49 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_181A37000, v21, v44, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_52;
      }

      v39 = __nw_create_backtrace_string();
      v21 = __nwlog_obj();
      v40 = type[0];
      v41 = os_log_type_enabled(v21, type[0]);
      if (!v39)
      {
        if (v41)
        {
          *buf = 136446210;
          v49 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_181A37000, v21, v40, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }

        goto LABEL_52;
      }

      if (v41)
      {
        *buf = 136446466;
        v49 = "nw_browser_start_query_record_for_endpoint_locked";
        v50 = 2082;
        *v51 = v39;
        _os_log_impl(&dword_181A37000, v21, v40, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_75;
    }
  }

LABEL_53:
  if (browser_key_for)
  {
LABEL_54:
    free(browser_key_for);
  }

LABEL_55:
}

void nw_browser_dns_service_query_record_callback(_DNSServiceRef_t *a1, char a2, unsigned int a3, int a4, const char *a5, unsigned __int16 a6, unsigned __int16 a7, unsigned int a8, const uint8_t *a9, unsigned int a10, void *a11)
{
  v156 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v15 = a11;
    v16 = v15;
    if (v15)
    {
      os_unfair_lock_lock(v15 + 2);
      if (nw_browser_fail_on_dns_error_locked(v16, a4, "nw_browser_dns_service_query_record_callback") || v16[18]._os_unfair_lock_opaque != 1)
      {
        goto LABEL_66;
      }

      bzero(key, 0x3F1uLL);
      if (strlen(a5) >= 0x3F1)
      {
        if (!nw_parameters_get_logging_disabled(*&v16[10]._os_unfair_lock_opaque))
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v17 = gbrowserLogObj;
          os_unfair_lock_opaque = v16[48]._os_unfair_lock_opaque;
          *buf = 136446466;
          *&buf[4] = "nw_browser_dns_service_query_record_callback";
          *&buf[12] = 1024;
          *&buf[14] = os_unfair_lock_opaque;
          v19 = _os_log_send_and_compose_impl();

          v151[0] = 16;
          LOBYTE(aBlock[0]) = 0;
          if (__nwlog_fault(v19, v151, aBlock))
          {
            if (v151[0] == 17)
            {
              if (__nwlog_browser_log::onceToken != -1)
              {
                dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
              }

              v20 = gbrowserLogObj;
              v21 = v151[0];
              if (os_log_type_enabled(v20, v151[0]))
              {
                v22 = v16[48]._os_unfair_lock_opaque;
                *buf = 136446466;
                *&buf[4] = "nw_browser_dns_service_query_record_callback";
                *&buf[12] = 1024;
                *&buf[14] = v22;
                _os_log_impl(&dword_181A37000, v20, v21, "%{public}s [B%u] key_name too small", buf, 0x12u);
              }
            }

            else if (LOBYTE(aBlock[0]) == 1)
            {
              backtrace_string = __nw_create_backtrace_string();
              if (backtrace_string)
              {
                v32 = backtrace_string;
                if (__nwlog_browser_log::onceToken != -1)
                {
                  dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
                }

                v33 = gbrowserLogObj;
                v34 = v151[0];
                if (os_log_type_enabled(v33, v151[0]))
                {
                  v35 = v16[48]._os_unfair_lock_opaque;
                  *buf = 136446722;
                  *&buf[4] = "nw_browser_dns_service_query_record_callback";
                  *&buf[12] = 1024;
                  *&buf[14] = v35;
                  *&buf[18] = 2082;
                  *&buf[20] = v32;
                  _os_log_impl(&dword_181A37000, v33, v34, "%{public}s [B%u] key_name too small, dumping backtrace:%{public}s", buf, 0x1Cu);
                }

                free(v32);
                if (!v19)
                {
                  goto LABEL_66;
                }

                goto LABEL_65;
              }

              if (__nwlog_browser_log::onceToken != -1)
              {
                dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
              }

              v20 = gbrowserLogObj;
              v48 = v151[0];
              if (os_log_type_enabled(v20, v151[0]))
              {
                v49 = v16[48]._os_unfair_lock_opaque;
                *buf = 136446466;
                *&buf[4] = "nw_browser_dns_service_query_record_callback";
                *&buf[12] = 1024;
                *&buf[14] = v49;
                _os_log_impl(&dword_181A37000, v20, v48, "%{public}s [B%u] key_name too small, no backtrace", buf, 0x12u);
              }
            }

            else
            {
              if (__nwlog_browser_log::onceToken != -1)
              {
                dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
              }

              v20 = gbrowserLogObj;
              v38 = v151[0];
              if (os_log_type_enabled(v20, v151[0]))
              {
                v39 = v16[48]._os_unfair_lock_opaque;
                *buf = 136446466;
                *&buf[4] = "nw_browser_dns_service_query_record_callback";
                *&buf[12] = 1024;
                *&buf[14] = v39;
                _os_log_impl(&dword_181A37000, v20, v38, "%{public}s [B%u] key_name too small, backtrace limit exceeded", buf, 0x12u);
              }
            }
          }

          if (v19)
          {
LABEL_65:
            free(v19);
          }
        }

LABEL_66:
        os_unfair_lock_unlock(v16 + 2);
LABEL_67:

        return;
      }

      nw_browser_strict_strlcpy_tolower(key, a5);
      if (!xpc_dictionary_get_uint64(*&v16[40]._os_unfair_lock_opaque, key))
      {
        if (!nw_parameters_get_logging_disabled(*&v16[10]._os_unfair_lock_opaque))
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v36 = gbrowserLogObj;
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            v37 = v16[48]._os_unfair_lock_opaque;
            *buf = 136446722;
            *&buf[4] = "nw_browser_dns_service_query_record_callback";
            *&buf[12] = 1024;
            *&buf[14] = v37;
            *&buf[18] = 2080;
            *&buf[20] = a5;
            _os_log_impl(&dword_181A37000, v36, OS_LOG_TYPE_ERROR, "%{public}s [B%u] txt: a TXT record was delivered for an unknown %s", buf, 0x1Cu);
          }
        }

        goto LABEL_66;
      }

      v132 = v16;
      v133 = nw_dictionary_copy_value(*(v132 + 21), key);
      v23 = nw_txt_record_create_with_bytes(a9, a8);
      v24 = v23;
      if (!v23)
      {
LABEL_83:

        if (v133)
        {
          if (_nw_array_get_count(v133) >= 2)
          {
            os_unfair_lock_unlock(v16 + 2);
LABEL_201:

            goto LABEL_67;
          }

          if (_nw_array_get_count(v133) == 1)
          {
            v53 = nw_array_get_object_at_index(v133, 0);
          }

          else
          {
            v53 = 0;
            _nw_array_get_count(v133);
          }

LABEL_147:
          if (!nw_parameters_get_logging_disabled(*(v132 + 5)))
          {
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v79 = gbrowserLogObj;
            if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
            {
              count = v133;
              v81 = *(v132 + 48);
              if (v133)
              {
                count = _nw_array_get_count(v133);
              }

              *buf = 136446978;
              *&buf[4] = "nw_browser_dns_service_query_record_callback";
              *&buf[12] = 1024;
              *&buf[14] = v81;
              *&buf[18] = 2080;
              *&buf[20] = key;
              *&buf[28] = 2048;
              *&buf[30] = count;
              _os_log_impl(&dword_181A37000, v79, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] txt: %s has count of %zu in txt_array,", buf, 0x26u);
            }
          }

          v82 = nw_browser_copy_old_result_locked(v132, key);
          v83 = v82;
          if (v82)
          {
            v84 = v82;
            lefta = v84[3];
          }

          else
          {
            lefta = 0;
          }

          uint64 = xpc_dictionary_get_uint64(*&v16[40]._os_unfair_lock_opaque, key);
          if ((uint64 & 4) != 0 || nw_txt_record_is_equal(lefta, v53))
          {
            goto LABEL_191;
          }

          if (!nw_parameters_get_logging_disabled(*(v132 + 5)))
          {
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v86 = gbrowserLogObj;
            if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
            {
              v87 = lefta;
              if (lefta)
              {
                isa = lefta[2].isa;
                v87 = lefta[1].isa;
              }

              else
              {
                isa = 0;
              }

              v89 = *(v132 + 48);
              if (v53)
              {
                v90 = *(v53 + 16);
                v91 = *(v53 + 8);
              }

              else
              {
                v90 = 0;
                v91 = 0;
              }

              *buf = 136447490;
              *&buf[4] = "nw_browser_dns_service_query_record_callback";
              *&buf[12] = 1024;
              *&buf[14] = v89;
              *&buf[18] = 1040;
              *&buf[20] = isa;
              *&buf[24] = 2096;
              *&buf[26] = v87;
              *&buf[34] = 1040;
              *&buf[36] = v90;
              LOWORD(v146) = 2096;
              *(&v146 + 2) = v91;
              _os_log_impl(&dword_181A37000, v86, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] txt: txt record changed from %{network:data}.*P to %{network:data}.*P", buf, 0x32u);
            }
          }

          if (uint64)
          {
            v92 = nw_browser_copy_result_to_modify_locked(v132, key, uint64);
            v93 = v92;
            if (v92)
            {
              if (v53)
              {
                if (*(v53 + 16) == 1)
                {
                  v94 = 0;
                }

                else
                {
                  v94 = v53;
                }
              }

              else
              {
                v94 = 0;
              }

              nw_browse_result_set_txt_record_object(v92, v94);
              *v151 = 0;
              ValidationData = DNSServiceGetValidationData();
              if (ValidationData && *v151)
              {
                endpoint = nw_browse_result_get_endpoint(v93);
                v97 = endpoint;
                if (endpoint)
                {
                  nw_endpoint_set_signature(endpoint, ValidationData, *v151);
                }
              }

              xpc_dictionary_set_uint64(*&v16[40]._os_unfair_lock_opaque, key, uint64 | 0x20);
              if (!nw_parameters_get_logging_disabled(*(v132 + 5)))
              {
                if (__nwlog_browser_log::onceToken != -1)
                {
                  dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
                }

                v98 = gbrowserLogObj;
                if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
                {
                  v99 = *(v132 + 48);
                  *buf = 136446978;
                  *&buf[4] = "nw_browser_dns_service_query_record_callback";
                  *&buf[12] = 1024;
                  *&buf[14] = v99;
                  *&buf[18] = 2080;
                  *&buf[20] = key;
                  *&buf[28] = 2048;
                  *&buf[30] = uint64 | 0x20;
                  _os_log_impl(&dword_181A37000, v98, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s |= txt_record_changed(%llu)", buf, 0x26u);
                }
              }

LABEL_191:
              if ((a2 & 1) == 0 && (!v133 || _nw_array_get_count(v133) <= 1))
              {
                nw_browser_notify_browse_result_changes_locked(v132);
                if (!nw_parameters_get_logging_disabled(*(v132 + 5)))
                {
                  if (__nwlog_browser_log::onceToken != -1)
                  {
                    dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
                  }

                  v100 = gbrowserLogObj;
                  if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
                  {
                    v101 = *(v132 + 48);
                    *buf = 136446722;
                    *&buf[4] = "nw_browser_dns_service_query_record_callback";
                    *&buf[12] = 1024;
                    *&buf[14] = v101;
                    *&buf[18] = 2080;
                    *&buf[20] = key;
                    _os_log_impl(&dword_181A37000, v100, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] txt: notify txt record change for %s", buf, 0x1Cu);
                  }
                }
              }

              goto LABEL_200;
            }

            if (nw_parameters_get_logging_disabled(*(v132 + 5)))
            {
              goto LABEL_200;
            }

            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v108 = gbrowserLogObj;
            v109 = *(v132 + 48);
            *buf = 136446466;
            *&buf[4] = "nw_browser_dns_service_query_record_callback";
            *&buf[12] = 1024;
            *&buf[14] = v109;
            v104 = _os_log_send_and_compose_impl();

            v151[0] = 16;
            LOBYTE(aBlock[0]) = 0;
            if (__nwlog_fault(v104, v151, aBlock))
            {
              if (v151[0] == 17)
              {
                if (__nwlog_browser_log::onceToken != -1)
                {
                  dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
                }

                v105 = gbrowserLogObj;
                v110 = v151[0];
                if (os_log_type_enabled(v105, v151[0]))
                {
                  v111 = *(v132 + 48);
                  *buf = 136446466;
                  *&buf[4] = "nw_browser_dns_service_query_record_callback";
                  *&buf[12] = 1024;
                  *&buf[14] = v111;
                  _os_log_impl(&dword_181A37000, v105, v110, "%{public}s [B%u] nw_browser_copy_result_to_modify_locked failed", buf, 0x12u);
                }
              }

              else if (LOBYTE(aBlock[0]) == 1)
              {
                v117 = __nw_create_backtrace_string();
                if (v117)
                {
                  v118 = v117;
                  if (__nwlog_browser_log::onceToken != -1)
                  {
                    dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
                  }

                  v119 = gbrowserLogObj;
                  v120 = v151[0];
                  if (os_log_type_enabled(v119, v151[0]))
                  {
                    v121 = *(v132 + 48);
                    *buf = 136446722;
                    *&buf[4] = "nw_browser_dns_service_query_record_callback";
                    *&buf[12] = 1024;
                    *&buf[14] = v121;
                    *&buf[18] = 2082;
                    *&buf[20] = v118;
                    _os_log_impl(&dword_181A37000, v119, v120, "%{public}s [B%u] nw_browser_copy_result_to_modify_locked failed, dumping backtrace:%{public}s", buf, 0x1Cu);
                  }

                  free(v118);
                  if (!v104)
                  {
                    goto LABEL_200;
                  }

                  goto LABEL_258;
                }

                if (__nwlog_browser_log::onceToken != -1)
                {
                  dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
                }

                v105 = gbrowserLogObj;
                v128 = v151[0];
                if (os_log_type_enabled(v105, v151[0]))
                {
                  v129 = *(v132 + 48);
                  *buf = 136446466;
                  *&buf[4] = "nw_browser_dns_service_query_record_callback";
                  *&buf[12] = 1024;
                  *&buf[14] = v129;
                  _os_log_impl(&dword_181A37000, v105, v128, "%{public}s [B%u] nw_browser_copy_result_to_modify_locked failed, no backtrace", buf, 0x12u);
                }
              }

              else
              {
                if (__nwlog_browser_log::onceToken != -1)
                {
                  dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
                }

                v105 = gbrowserLogObj;
                v124 = v151[0];
                if (os_log_type_enabled(v105, v151[0]))
                {
                  v125 = *(v132 + 48);
                  *buf = 136446466;
                  *&buf[4] = "nw_browser_dns_service_query_record_callback";
                  *&buf[12] = 1024;
                  *&buf[14] = v125;
                  _os_log_impl(&dword_181A37000, v105, v124, "%{public}s [B%u] nw_browser_copy_result_to_modify_locked failed, backtrace limit exceeded", buf, 0x12u);
                }
              }

              goto LABEL_256;
            }

LABEL_257:
            if (v104)
            {
LABEL_258:
              free(v104);
            }

LABEL_200:
            os_unfair_lock_unlock(v16 + 2);

            goto LABEL_201;
          }

          if (nw_parameters_get_logging_disabled(*(v132 + 5)))
          {
            goto LABEL_200;
          }

          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v102 = gbrowserLogObj;
          v103 = *(v132 + 48);
          *buf = 136446466;
          *&buf[4] = "nw_browser_dns_service_query_record_callback";
          *&buf[12] = 1024;
          *&buf[14] = v103;
          v104 = _os_log_send_and_compose_impl();

          v151[0] = 16;
          LOBYTE(aBlock[0]) = 0;
          if (!__nwlog_fault(v104, v151, aBlock))
          {
            goto LABEL_257;
          }

          if (v151[0] == 17)
          {
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v105 = gbrowserLogObj;
            v106 = v151[0];
            if (os_log_type_enabled(v105, v151[0]))
            {
              v107 = *(v132 + 48);
              *buf = 136446466;
              *&buf[4] = "nw_browser_dns_service_query_record_callback";
              *&buf[12] = 1024;
              *&buf[14] = v107;
              _os_log_impl(&dword_181A37000, v105, v106, "%{public}s [B%u] change should not be invalid", buf, 0x12u);
            }
          }

          else if (LOBYTE(aBlock[0]) == 1)
          {
            v112 = __nw_create_backtrace_string();
            if (v112)
            {
              v113 = v112;
              if (__nwlog_browser_log::onceToken != -1)
              {
                dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
              }

              v114 = gbrowserLogObj;
              v115 = v151[0];
              if (os_log_type_enabled(v114, v151[0]))
              {
                v116 = *(v132 + 48);
                *buf = 136446722;
                *&buf[4] = "nw_browser_dns_service_query_record_callback";
                *&buf[12] = 1024;
                *&buf[14] = v116;
                *&buf[18] = 2082;
                *&buf[20] = v113;
                _os_log_impl(&dword_181A37000, v114, v115, "%{public}s [B%u] change should not be invalid, dumping backtrace:%{public}s", buf, 0x1Cu);
              }

              free(v113);
              goto LABEL_257;
            }

            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v105 = gbrowserLogObj;
            v126 = v151[0];
            if (os_log_type_enabled(v105, v151[0]))
            {
              v127 = *(v132 + 48);
              *buf = 136446466;
              *&buf[4] = "nw_browser_dns_service_query_record_callback";
              *&buf[12] = 1024;
              *&buf[14] = v127;
              _os_log_impl(&dword_181A37000, v105, v126, "%{public}s [B%u] change should not be invalid, no backtrace", buf, 0x12u);
            }
          }

          else
          {
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v105 = gbrowserLogObj;
            v122 = v151[0];
            if (os_log_type_enabled(v105, v151[0]))
            {
              v123 = *(v132 + 48);
              *buf = 136446466;
              *&buf[4] = "nw_browser_dns_service_query_record_callback";
              *&buf[12] = 1024;
              *&buf[14] = v123;
              _os_log_impl(&dword_181A37000, v105, v122, "%{public}s [B%u] change should not be invalid, backtrace limit exceeded", buf, 0x12u);
            }
          }

LABEL_256:

          goto LABEL_257;
        }

LABEL_146:
        v133 = 0;
        v53 = 0;
        goto LABEL_147;
      }

      v25 = v23;
      v26 = (BYTE4(v25[4].isa) & 1) == 0;
      left = v25;

      if (v26)
      {
        v28 = __nwlog_obj();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          *v151 = 136446210;
          *&v151[4] = "nw_browser_copy_txt_array_locked";
          _os_log_impl(&dword_181A37000, v28, OS_LOG_TYPE_ERROR, "%{public}s txt: discovered non-key/value TXT record", v151, 0xCu);
        }

        goto LABEL_82;
      }

      if ((a2 & 2) == 0)
      {
        if (v133)
        {
          v27 = _nw_array_create();
          *type = 0;
          v135 = type;
          v136 = 0x2020000000;
          v137 = 0;
          *buf = MEMORY[0x1E69E9820];
          *&buf[8] = 3221225472;
          *&buf[16] = ___ZL32nw_browser_copy_txt_array_lockedP21NWConcrete_nw_browserPKcPKvtj_block_invoke_137;
          *&buf[24] = &unk_1E6A35FC0;
          v147 = type;
          *&buf[32] = left;
          v28 = v27;
          *&v146 = v28;
          v29 = v132;
          v150 = a8;
          *(&v146 + 1) = v29;
          v148 = a9;
          v149 = key;
          _nw_array_apply(v133, buf);
          if (v28)
          {
            v30 = _nw_array_get_count(v28);
          }

          else
          {
            v30 = 0;
          }

          if (v30 != _nw_array_get_count(v133) - 1 && !nw_parameters_get_logging_disabled(*(v29 + 5)))
          {
            if (__nwlog_browser_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
            }

            v50 = gbrowserLogObj;
            if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
            {
              v51 = *(v29 + 48);
              *v151 = 136447234;
              *&v151[4] = "nw_browser_copy_txt_array_locked";
              v152 = 1024;
              *v153 = v51;
              *&v153[4] = 1040;
              *&v153[6] = a8;
              *&v153[10] = 2080;
              *&v153[12] = a9;
              v154 = 2080;
              v155 = key;
              _os_log_impl(&dword_181A37000, v50, OS_LOG_TYPE_ERROR, "%{public}s [B%u] txt: failed to remove %.*s from %s", v151, 0x2Cu);
            }
          }

          nw_dictionary_set_value(*(v132 + 21), key, v28);
          if (v28 && _nw_array_get_count(v28))
          {
            v52 = v28;
          }

          else
          {
            v52 = 0;
          }

          _Block_object_dispose(type, 8);
          v133 = v52;
          goto LABEL_82;
        }

        v70 = __nwlog_obj();
        *v151 = 136446210;
        *&v151[4] = "nw_browser_copy_txt_array_locked";
        v71 = _os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v138 = 0;
        if (__nwlog_fault(v71, type, &v138))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v72 = __nwlog_obj();
            v73 = type[0];
            if (os_log_type_enabled(v72, type[0]))
            {
              *v151 = 136446210;
              *&v151[4] = "nw_browser_copy_txt_array_locked";
              _os_log_impl(&dword_181A37000, v72, v73, "%{public}s txt: got remove event for non-existent txt_array", v151, 0xCu);
            }
          }

          else
          {
            if (v138 == 1)
            {
              v74 = __nw_create_backtrace_string();
              v75 = __nwlog_obj();
              v76 = type[0];
              v77 = os_log_type_enabled(v75, type[0]);
              if (v74)
              {
                if (v77)
                {
                  *v151 = 136446466;
                  *&v151[4] = "nw_browser_copy_txt_array_locked";
                  v152 = 2082;
                  *v153 = v74;
                  _os_log_impl(&dword_181A37000, v75, v76, "%{public}s txt: got remove event for non-existent txt_array, dumping backtrace:%{public}s", v151, 0x16u);
                }

                free(v74);
              }

              else
              {
                if (v77)
                {
                  *v151 = 136446210;
                  *&v151[4] = "nw_browser_copy_txt_array_locked";
                  _os_log_impl(&dword_181A37000, v75, v76, "%{public}s txt: got remove event for non-existent txt_array, no backtrace", v151, 0xCu);
                }
              }

              goto LABEL_143;
            }

            v72 = __nwlog_obj();
            v78 = type[0];
            if (os_log_type_enabled(v72, type[0]))
            {
              *v151 = 136446210;
              *&v151[4] = "nw_browser_copy_txt_array_locked";
              _os_log_impl(&dword_181A37000, v72, v78, "%{public}s txt: got remove event for non-existent txt_array, backtrace limit exceeded", v151, 0xCu);
            }
          }
        }

LABEL_143:
        if (v71)
        {
          free(v71);
        }

        goto LABEL_146;
      }

      v40 = v133;
      if (!v133)
      {
        v41 = _nw_array_create();
        nw_dictionary_set_value(*(v132 + 21), key, v41);
        v40 = v41;
        if (!nw_parameters_get_logging_disabled(*(v132 + 5)))
        {
          if (__nwlog_browser_log::onceToken != -1)
          {
            dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
          }

          v42 = gbrowserLogObj;
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
          {
            v43 = *(v132 + 48);
            *v151 = 136446722;
            *&v151[4] = "nw_browser_copy_txt_array_locked";
            v152 = 1024;
            *v153 = v43;
            *&v153[4] = 2080;
            *&v153[6] = key;
            _os_log_impl(&dword_181A37000, v42, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] txt: create new txt_array for %s", v151, 0x1Cu);
          }
        }
      }

      aBlock[0] = MEMORY[0x1E69E9820];
      aBlock[1] = 3221225472;
      aBlock[2] = ___ZL32nw_browser_copy_txt_array_lockedP21NWConcrete_nw_browserPKcPKvtj_block_invoke;
      aBlock[3] = &unk_1E6A3CCB8;
      v44 = left;
      v140 = v44;
      v133 = v40;
      if (v40)
      {
        v45 = v44;
        if (!_nw_array_apply(v40, aBlock))
        {
LABEL_58:
          v28 = v140;
LABEL_82:

          goto LABEL_83;
        }

        _nw_array_append(v40, v45);
      }

      if (!nw_parameters_get_logging_disabled(*(v132 + 5)))
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v46 = gbrowserLogObj;
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        {
          v47 = *(v132 + 48);
          *v151 = 136447234;
          *&v151[4] = "nw_browser_copy_txt_array_locked";
          v152 = 1024;
          *v153 = v47;
          *&v153[4] = 1040;
          *&v153[6] = a8;
          *&v153[10] = 2080;
          *&v153[12] = a9;
          v154 = 2080;
          v155 = key;
          _os_log_impl(&dword_181A37000, v46, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] txt: add %.*s to %s", v151, 0x2Cu);
        }
      }

      goto LABEL_58;
    }

    v58 = __nwlog_obj();
    *key = 136446210;
    v142 = "nw_browser_dns_service_query_record_callback";
    v59 = _os_log_send_and_compose_impl();

    buf[0] = 16;
    v151[0] = 0;
    if (__nwlog_fault(v59, buf, v151))
    {
      if (buf[0] == 17)
      {
        v60 = __nwlog_obj();
        v61 = buf[0];
        if (os_log_type_enabled(v60, buf[0]))
        {
          *key = 136446210;
          v142 = "nw_browser_dns_service_query_record_callback";
          _os_log_impl(&dword_181A37000, v60, v61, "%{public}s called with null browser", key, 0xCu);
        }
      }

      else if (v151[0] == 1)
      {
        v65 = __nw_create_backtrace_string();
        v60 = __nwlog_obj();
        v66 = buf[0];
        v67 = os_log_type_enabled(v60, buf[0]);
        if (v65)
        {
          if (v67)
          {
            *key = 136446466;
            v142 = "nw_browser_dns_service_query_record_callback";
            v143 = 2082;
            v144 = v65;
            _os_log_impl(&dword_181A37000, v60, v66, "%{public}s called with null browser, dumping backtrace:%{public}s", key, 0x16u);
          }

          free(v65);
          goto LABEL_123;
        }

        if (v67)
        {
          *key = 136446210;
          v142 = "nw_browser_dns_service_query_record_callback";
          _os_log_impl(&dword_181A37000, v60, v66, "%{public}s called with null browser, no backtrace", key, 0xCu);
        }
      }

      else
      {
        v60 = __nwlog_obj();
        v69 = buf[0];
        if (os_log_type_enabled(v60, buf[0]))
        {
          *key = 136446210;
          v142 = "nw_browser_dns_service_query_record_callback";
          _os_log_impl(&dword_181A37000, v60, v69, "%{public}s called with null browser, backtrace limit exceeded", key, 0xCu);
        }
      }
    }

LABEL_123:
    if (v59)
    {
      free(v59);
    }

    goto LABEL_67;
  }

  v54 = __nwlog_obj();
  *key = 136446210;
  v142 = "nw_browser_dns_service_query_record_callback";
  v55 = _os_log_send_and_compose_impl();

  buf[0] = 16;
  v151[0] = 0;
  if (__nwlog_fault(v55, buf, v151))
  {
    if (buf[0] == 17)
    {
      v56 = __nwlog_obj();
      v57 = buf[0];
      if (os_log_type_enabled(v56, buf[0]))
      {
        *key = 136446210;
        v142 = "nw_browser_dns_service_query_record_callback";
        _os_log_impl(&dword_181A37000, v56, v57, "%{public}s called with null dns_service", key, 0xCu);
      }
    }

    else if (v151[0] == 1)
    {
      v62 = __nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v63 = buf[0];
      v64 = os_log_type_enabled(v56, buf[0]);
      if (v62)
      {
        if (v64)
        {
          *key = 136446466;
          v142 = "nw_browser_dns_service_query_record_callback";
          v143 = 2082;
          v144 = v62;
          _os_log_impl(&dword_181A37000, v56, v63, "%{public}s called with null dns_service, dumping backtrace:%{public}s", key, 0x16u);
        }

        free(v62);
        goto LABEL_118;
      }

      if (v64)
      {
        *key = 136446210;
        v142 = "nw_browser_dns_service_query_record_callback";
        _os_log_impl(&dword_181A37000, v56, v63, "%{public}s called with null dns_service, no backtrace", key, 0xCu);
      }
    }

    else
    {
      v56 = __nwlog_obj();
      v68 = buf[0];
      if (os_log_type_enabled(v56, buf[0]))
      {
        *key = 136446210;
        v142 = "nw_browser_dns_service_query_record_callback";
        _os_log_impl(&dword_181A37000, v56, v68, "%{public}s called with null dns_service, backtrace limit exceeded", key, 0xCu);
      }
    }
  }

LABEL_118:
  if (v55)
  {
    free(v55);
  }
}

uint64_t ___ZL32nw_browser_copy_txt_array_lockedP21NWConcrete_nw_browserPKcPKvtj_block_invoke_137(uint64_t a1, uint64_t a2, void *a3)
{
  v23 = *MEMORY[0x1E69E9840];
  v4 = a3;
  if ((*(*(*(a1 + 56) + 8) + 24) & 1) != 0 || !nw_txt_record_is_equal(*(a1 + 32), v4))
  {
    v10 = *(a1 + 40);
    if (v10)
    {
      v11 = v4 == 0;
    }

    else
    {
      v11 = 1;
    }

    if (!v11)
    {
      _nw_array_append(v10, v4);
    }
  }

  else
  {
    if (!nw_parameters_get_logging_disabled(*(*(a1 + 48) + 40)))
    {
      if (__nwlog_browser_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
      }

      v5 = gbrowserLogObj;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        v6 = *(*(a1 + 48) + 192);
        v7 = *(a1 + 80);
        v8 = *(a1 + 64);
        v9 = *(a1 + 72);
        v13 = 136447234;
        v14 = "nw_browser_copy_txt_array_locked_block_invoke";
        v15 = 1024;
        v16 = v6;
        v17 = 1040;
        v18 = v7;
        v19 = 2080;
        v20 = v8;
        v21 = 2080;
        v22 = v9;
        _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] txt: remove %.*s from %s", &v13, 0x2Cu);
      }
    }

    *(*(*(a1 + 56) + 8) + 24) = 1;
  }

  return 1;
}

void nw_browser_cancel_dns_browser_locked(NWConcrete_nw_browser *a1)
{
  v1 = a1;
  v2 = *(v1 + 19);
  *(v1 + 19) = 0;

  v3 = *(v1 + 21);
  *(v1 + 21) = 0;

  v4 = *(v1 + 20);
  *(v1 + 20) = 0;

  v5 = *(v1 + 15);
  if (v5)
  {
    *(v1 + 15) = 0;
    *(v1 + 16) = 0;
    v6 = nw_parameters_copy_context(*(v1 + 5));
    v7[0] = MEMORY[0x1E69E9820];
    v7[1] = 3221225472;
    v7[2] = ___ZL36nw_browser_cancel_dns_browser_lockedP21NWConcrete_nw_browser_block_invoke;
    v7[3] = &unk_1E6A3AC58;
    v9 = v5;
    v8 = v1;
    nw_queue_context_async(v6, v7);
  }
}

void ___ZL36nw_browser_cancel_dns_browser_lockedP21NWConcrete_nw_browser_block_invoke(uint64_t a1)
{
  v8 = *MEMORY[0x1E69E9840];
  DNSServiceRefDeallocate(*(a1 + 40));
  if (!nw_parameters_get_logging_disabled(*(*(a1 + 32) + 40)))
  {
    if (__nwlog_browser_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
    }

    v2 = gbrowserLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      v3 = *(*(a1 + 32) + 192);
      v4 = 136446466;
      v5 = "nw_browser_cancel_dns_browser_locked_block_invoke";
      v6 = 1024;
      v7 = v3;
      _os_log_impl(&dword_181A37000, v2, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] deallocate primary DNS ref", &v4, 0x12u);
    }
  }
}

void ___ZL38nw_browser_start_custom_browser_lockedP21NWConcrete_nw_browser_block_invoke_2(uint64_t a1)
{
  os_unfair_lock_lock((*(a1 + 32) + 8));
  v2 = (*(a1 + 32) + 8);

  os_unfair_lock_unlock(v2);
}

void nw_browser_cancel(nw_browser_t browser)
{
  v33 = *MEMORY[0x1E69E9840];
  v1 = browser;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(&v1[1]);
    if (LODWORD(v2[9].isa) == 3)
    {
      os_unfair_lock_unlock(&v2[1]);
      if (!nw_parameters_get_logging_disabled(v2[5].isa))
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v3 = gbrowserLogObj;
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        {
          isa = v2[24].isa;
          *buf = 136446466;
          v30 = "nw_browser_cancel";
          v31 = 1024;
          LODWORD(v32) = isa;
          _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_ERROR, "%{public}s [B%u] The browser has already been cancelled, ignoring nw_browser_cancel().", buf, 0x12u);
        }
      }
    }

    else
    {
      v5 = v2;
      if (!nw_parameters_get_logging_disabled(v2[5].isa))
      {
        if (__nwlog_browser_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_browser_log::onceToken, &__block_literal_global_20_47423);
        }

        v6 = gbrowserLogObj;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          v7 = v5[24].isa;
          *buf = 136446466;
          v30 = "nw_browser_cancel_path_browser_locked";
          v31 = 1024;
          LODWORD(v32) = v7;
          _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] path: cancel browse", buf, 0x12u);
        }
      }

      v8 = v5[12].isa;
      v5[12].isa = 0;

      v9 = v5[13].isa;
      v5[13].isa = 0;

      v10 = v5[11].isa;
      if (v10)
      {
        nw_path_evaluator_cancel(v10);
        v11 = v5[11].isa;
        v5[11].isa = 0;
      }

      nw_browser_cancel_dns_browser_locked(v5);
      v12 = v5[17].isa;
      v5[17].isa = 0;

      v13 = v5[18].isa;
      v5[18].isa = 0;

      v14 = v5[14].isa;
      v5[14].isa = 0;

      nw_browser_set_state_locked(v5, 3, 0);
      v15 = v5[7].isa;
      v5[7].isa = 0;

      v16 = v5[8].isa;
      v5[8].isa = 0;

      v17 = v5[2].isa;
      v5[2].isa = 0;

      v18 = v5[6].isa;
      v5[6].isa = 0;

      os_unfair_lock_unlock(&v2[1]);
    }

    goto LABEL_18;
  }

  v19 = __nwlog_obj();
  *buf = 136446210;
  v30 = "nw_browser_cancel";
  v20 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (__nwlog_fault(v20, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v21 = __nwlog_obj();
      v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *buf = 136446210;
        v30 = "nw_browser_cancel";
        _os_log_impl(&dword_181A37000, v21, v22, "%{public}s called with null browser", buf, 0xCu);
      }
    }

    else if (v27 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v21 = __nwlog_obj();
      v24 = type;
      v25 = os_log_type_enabled(v21, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *buf = 136446466;
          v30 = "nw_browser_cancel";
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_181A37000, v21, v24, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }

      if (v25)
      {
        *buf = 136446210;
        v30 = "nw_browser_cancel";
        _os_log_impl(&dword_181A37000, v21, v24, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v21 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v21, type))
      {
        *buf = 136446210;
        v30 = "nw_browser_cancel";
        _os_log_impl(&dword_181A37000, v21, v26, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_35:
  if (v20)
  {
    free(v20);
  }

LABEL_18:
}

nw_parameters_t nw_browser_copy_parameters(nw_browser_t browser)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = browser;
  v2 = v1;
  if (v1)
  {
    v3 = v1[5].isa;
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_browser_copy_parameters";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_browser_copy_parameters";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null browser", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_browser_copy_parameters";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_browser_copy_parameters";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_browser_copy_parameters";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

nw_browse_descriptor_t nw_browser_copy_browse_descriptor(nw_browser_t browser)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = browser;
  v2 = v1;
  if (v1)
  {
    v3 = v1[4].isa;
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_browser_copy_browse_descriptor";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_browser_copy_browse_descriptor";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null browser", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_browser_copy_browse_descriptor";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_browser_copy_browse_descriptor";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_browser_copy_browse_descriptor";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

id nw_browser_copy_browse_results(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 2);
    v3 = *&v2[34]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v2 + 2);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_browser_copy_browse_results";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_browser_copy_browse_results";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null browser", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_browser_copy_browse_results";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_browser_copy_browse_results";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_browser_copy_browse_results";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_browser_get_state(void *a1, uint64_t a2)
{
  v24 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v23 = 0;
    aBlock[0] = MEMORY[0x1E69E9820];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_browser_get_state_block_invoke;
    aBlock[3] = &unk_1E6A3D8B8;
    v18 = buf;
    v17 = v3;
    v19 = a2;
    v5 = _Block_copy(aBlock);
    os_unfair_lock_lock(v4 + 2);
    v5[2](v5);
    os_unfair_lock_unlock(v4 + 2);

    v6 = *(*&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_browser_get_state";
  v9 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v9, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_browser_get_state";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null browser", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          *&buf[4] = "nw_browser_get_state";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *buf = 136446210;
        *&buf[4] = "nw_browser_get_state";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_browser_get_state";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v9)
  {
    free(v9);
  }

  v6 = 0;
LABEL_3:

  return v6;
}

void sub_1828A0F7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_browser_get_state_block_invoke(uint64_t a1)
{
  *(*(*(a1 + 40) + 8) + 24) = *(*(a1 + 32) + 72);
  if (*(a1 + 48))
  {
    objc_storeStrong(*(a1 + 48), *(*(a1 + 32) + 80));
  }
}

BOOL nw_txt_record_conforms_to_rfc_1464(_BYTE *a1, uint64_t a2)
{
  result = 0;
  if (a1 && (a2 - 8901) >= 0xFFFFFFFFFFFFDD3CLL)
  {
    v4 = *a1;
    if (a2 == 1 && !*a1)
    {
      return 1;
    }

    v5 = &a1[a2];
    v6 = &a1[v4 + 1];
    if (v6 == &a1[a2])
    {
      return 1;
    }

    else
    {
      do
      {
        result = v6 <= v5;
        if (v6 > v5)
        {
          break;
        }

        v7 = a1;
        a1 = v6;
        v8 = (v7 + 1);
        v9 = memchr((v7 + 1), 61, v4);
        v10 = (v7 + v4);
        if (v9)
        {
          v10 = v9;
        }

        if (v8 < v10)
        {
          v11 = &v10[~v7];
          while (*v8 - 127 > 0xFFFFFFA0)
          {
            ++v8;
            if (!--v11)
            {
              goto LABEL_7;
            }
          }

          return 0;
        }

LABEL_7:
        v4 = *a1;
        v6 = &a1[v4 + 1];
        result = 1;
      }

      while (v6 != v5);
    }
  }

  return result;
}

BOOL nw_txt_record_is_dictionary(nw_txt_record_t txt_record)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = txt_record;
  if (v1)
  {
    v2 = BYTE4(v1[4].isa) & 1;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_txt_record_is_dictionary";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_txt_record_is_dictionary";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null txt_record", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_txt_record_is_dictionary";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_txt_record_is_dictionary";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_txt_record_is_dictionary";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
  v1 = 0;
LABEL_3:

  return v2;
}

nw_txt_record_find_key_t nw_txt_record_find_key(nw_txt_record_t txt_record, const char *key)
{
  v22 = *MEMORY[0x1E69E9840];
  v3 = txt_record;
  v4 = v3;
  if (!v3)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v19 = "nw_txt_record_find_key";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v19 = "nw_txt_record_find_key";
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null txt_record", buf, 0xCu);
        }
      }

      else if (v16 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v9 = __nwlog_obj();
        v13 = type;
        v14 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *buf = 136446466;
            v19 = "nw_txt_record_find_key";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_181A37000, v9, v13, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }

        if (v14)
        {
          *buf = 136446210;
          v19 = "nw_txt_record_find_key";
          _os_log_impl(&dword_181A37000, v9, v13, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v9 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v19 = "nw_txt_record_find_key";
          _os_log_impl(&dword_181A37000, v9, v15, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_28:
    if (v8)
    {
      free(v8);
    }

    goto LABEL_30;
  }

  if ((BYTE4(v3[4].isa) & 1) == 0)
  {
    v11 = __nwlog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v19 = "nw_txt_record_find_key";
      _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_ERROR, "%{public}s txt_record is not of type dictionary", buf, 0xCu);
    }

    goto LABEL_13;
  }

  if ((nw_txt_record_key_is_valid(key) & 1) == 0)
  {
    v11 = __nwlog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v19 = "nw_txt_record_find_key";
      _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_ERROR, "%{public}s invalid key", buf, 0xCu);
    }

LABEL_13:

LABEL_30:
    start_of_key_locked = nw_txt_record_find_key_invalid;
    goto LABEL_5;
  }

  os_unfair_lock_lock(v4 + 8);
  start_of_key_locked = nw_txt_record_find_start_of_key_locked(v4, key, 0, 0, 0, 0);
  os_unfair_lock_unlock(v4 + 8);
LABEL_5:

  return start_of_key_locked;
}

BOOL nw_txt_record_access_key(nw_txt_record_t txt_record, const char *key, nw_txt_record_access_key_t access_value)
{
  v30 = *MEMORY[0x1E69E9840];
  v5 = txt_record;
  v6 = access_value;
  v7 = v6;
  if (!v5)
  {
    v11 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_txt_record_access_key";
    v12 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v12, type, &v26))
    {
      goto LABEL_45;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_access_key";
        _os_log_impl(&dword_181A37000, v13, v14, "%{public}s called with null txt_record", buf, 0xCu);
      }

      goto LABEL_44;
    }

    if (v26 != 1)
    {
      v13 = __nwlog_obj();
      v23 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_access_key";
        _os_log_impl(&dword_181A37000, v13, v23, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_44;
    }

    backtrace_string = __nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v19 = type[0];
    v20 = os_log_type_enabled(v13, type[0]);
    if (!backtrace_string)
    {
      if (v20)
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_access_key";
        _os_log_impl(&dword_181A37000, v13, v19, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
      }

      goto LABEL_44;
    }

    if (v20)
    {
      *buf = 136446466;
      *&buf[4] = "nw_txt_record_access_key";
      v28 = 2082;
      v29 = backtrace_string;
      _os_log_impl(&dword_181A37000, v13, v19, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_32;
  }

  if (!v6)
  {
    v15 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_txt_record_access_key";
    v12 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v12, type, &v26))
    {
      goto LABEL_45;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v16 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_access_key";
        _os_log_impl(&dword_181A37000, v13, v16, "%{public}s called with null access_value", buf, 0xCu);
      }

LABEL_44:

LABEL_45:
      if (v12)
      {
        free(v12);
      }

      goto LABEL_47;
    }

    if (v26 != 1)
    {
      v13 = __nwlog_obj();
      v24 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_access_key";
        _os_log_impl(&dword_181A37000, v13, v24, "%{public}s called with null access_value, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_44;
    }

    backtrace_string = __nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v21 = type[0];
    v22 = os_log_type_enabled(v13, type[0]);
    if (!backtrace_string)
    {
      if (v22)
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_access_key";
        _os_log_impl(&dword_181A37000, v13, v21, "%{public}s called with null access_value, no backtrace", buf, 0xCu);
      }

      goto LABEL_44;
    }

    if (v22)
    {
      *buf = 136446466;
      *&buf[4] = "nw_txt_record_access_key";
      v28 = 2082;
      v29 = backtrace_string;
      _os_log_impl(&dword_181A37000, v13, v21, "%{public}s called with null access_value, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_32:

    free(backtrace_string);
    goto LABEL_45;
  }

  if ((BYTE4(v5[4].isa) & 1) == 0)
  {
    v17 = __nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      *&buf[4] = "nw_txt_record_access_key";
      _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_ERROR, "%{public}s txt_record is not of type dictionary", buf, 0xCu);
    }

    goto LABEL_19;
  }

  if ((nw_txt_record_key_is_valid(key) & 1) == 0)
  {
    v17 = __nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      *&buf[4] = "nw_txt_record_access_key";
      _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_ERROR, "%{public}s invalid key", buf, 0xCu);
    }

LABEL_19:

LABEL_47:
    v9 = 0;
    goto LABEL_6;
  }

  *buf = 0;
  *type = 0;
  os_unfair_lock_lock(&v5[4]);
  start_of_key_locked = nw_txt_record_find_start_of_key_locked(v5, key, 0, 0, buf, type);
  v9 = (v7)[2](v7, key, start_of_key_locked, *buf, *type);
  os_unfair_lock_unlock(&v5[4]);
LABEL_6:

  return v9;
}

BOOL nw_txt_record_remove_key(nw_txt_record_t txt_record, const char *key)
{
  v24 = *MEMORY[0x1E69E9840];
  v3 = txt_record;
  v4 = v3;
  if (!v3)
  {
    v10 = __nwlog_obj();
    *__dst = 136446210;
    *&__dst[4] = "nw_txt_record_remove_key";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v11, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *__dst = 136446210;
          *&__dst[4] = "nw_txt_record_remove_key";
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s called with null txt_record", __dst, 0xCu);
        }
      }

      else if (v19 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v12 = __nwlog_obj();
        v16 = type;
        v17 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *__dst = 136446466;
            *&__dst[4] = "nw_txt_record_remove_key";
            v22 = 2082;
            v23 = backtrace_string;
            _os_log_impl(&dword_181A37000, v12, v16, "%{public}s called with null txt_record, dumping backtrace:%{public}s", __dst, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_33;
        }

        if (v17)
        {
          *__dst = 136446210;
          *&__dst[4] = "nw_txt_record_remove_key";
          _os_log_impl(&dword_181A37000, v12, v16, "%{public}s called with null txt_record, no backtrace", __dst, 0xCu);
        }
      }

      else
      {
        v12 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v12, type))
        {
          *__dst = 136446210;
          *&__dst[4] = "nw_txt_record_remove_key";
          _os_log_impl(&dword_181A37000, v12, v18, "%{public}s called with null txt_record, backtrace limit exceeded", __dst, 0xCu);
        }
      }
    }

LABEL_33:
    if (v11)
    {
      free(v11);
    }

    goto LABEL_35;
  }

  if ((BYTE4(v3[4].isa) & 1) == 0)
  {
    v14 = __nwlog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *__dst = 136446210;
      *&__dst[4] = "nw_txt_record_remove_key";
      _os_log_impl(&dword_181A37000, v14, OS_LOG_TYPE_ERROR, "%{public}s txt_record is not of type dictionary", __dst, 0xCu);
    }

    goto LABEL_18;
  }

  if ((nw_txt_record_key_is_valid(key) & 1) == 0)
  {
    v14 = __nwlog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *__dst = 136446210;
      *&__dst[4] = "nw_txt_record_remove_key";
      _os_log_impl(&dword_181A37000, v14, OS_LOG_TYPE_ERROR, "%{public}s invalid key", __dst, 0xCu);
    }

LABEL_18:

LABEL_35:
    v5 = 0;
    goto LABEL_10;
  }

  os_unfair_lock_lock(&v4[4]);
  if (v4[2].isa == 1)
  {
    os_unfair_lock_unlock(&v4[4]);
    v5 = 0;
  }

  else
  {
    *__dst = 0;
    start_of_key_locked = nw_txt_record_find_start_of_key_locked(v4, key, __dst, 0, 0, 0);
    v5 = start_of_key_locked != 1;
    if (start_of_key_locked != 1)
    {
      v7 = **__dst + 1;
      memmove(*__dst, (*__dst + v7), v4[1].isa + v4[2].isa - *__dst - v7);
      v8 = v4[2].isa - v7;
      v4[2].isa = v8;
      if (!v8)
      {
        *v4[1].isa = 0;
        v4[2].isa = 1;
      }
    }

    os_unfair_lock_unlock(&v4[4]);
  }

LABEL_10:

  return v5;
}

size_t nw_txt_record_get_key_count(nw_txt_record_t txt_record)
{
  v23 = *MEMORY[0x1E69E9840];
  v1 = txt_record;
  v2 = v1;
  if (!v1)
  {
    v8 = __nwlog_obj();
    *buf = 136446210;
    v20 = "nw_txt_record_get_key_count";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v10 = __nwlog_obj();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v20 = "nw_txt_record_get_key_count";
          _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null txt_record", buf, 0xCu);
        }
      }

      else if (v17 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v10 = __nwlog_obj();
        v14 = type;
        v15 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *buf = 136446466;
            v20 = "nw_txt_record_get_key_count";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_181A37000, v10, v14, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_33;
        }

        if (v15)
        {
          *buf = 136446210;
          v20 = "nw_txt_record_get_key_count";
          _os_log_impl(&dword_181A37000, v10, v14, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v10 = __nwlog_obj();
        v16 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v20 = "nw_txt_record_get_key_count";
          _os_log_impl(&dword_181A37000, v10, v16, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_33:
    if (v9)
    {
      free(v9);
    }

    goto LABEL_5;
  }

  if ((BYTE4(v1[4].isa) & 1) == 0)
  {
    v12 = __nwlog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v20 = "nw_txt_record_get_key_count";
      _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_ERROR, "%{public}s txt_record is not of type dictionary", buf, 0xCu);
    }

    goto LABEL_5;
  }

  os_unfair_lock_lock(&v1[4]);
  isa = v2[2].isa;
  if (isa == 1)
  {
    os_unfair_lock_unlock(&v2[4]);
LABEL_5:
    v4 = 0;
    goto LABEL_13;
  }

  if (isa >= 1)
  {
    v4 = 0;
    v5 = v2[1].isa;
    v6 = &v5[isa];
    while (1)
    {
      v5 += *v5 + 1;
      if (v5 > v6)
      {
        goto LABEL_5;
      }

      ++v4;
      if (v5 >= v6)
      {
        goto LABEL_12;
      }
    }
  }

  v4 = 0;
LABEL_12:
  os_unfair_lock_unlock(&v2[4]);
LABEL_13:

  return v4;
}

BOOL nw_txt_record_access_bytes(nw_txt_record_t txt_record, nw_txt_record_access_bytes_t access_bytes)
{
  v27 = *MEMORY[0x1E69E9840];
  v3 = txt_record;
  v4 = access_bytes;
  v5 = v4;
  if (v3)
  {
    if (v4)
    {
      os_unfair_lock_lock(&v3[4]);
      v6 = (v5)[2](v5, v3[1].isa, v3[2].isa);
      os_unfair_lock_unlock(&v3[4]);
      goto LABEL_4;
    }

    v12 = __nwlog_obj();
    *buf = 136446210;
    v24 = "nw_txt_record_access_bytes";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v10 = __nwlog_obj();
        v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v24 = "nw_txt_record_access_bytes";
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null access_bytes", buf, 0xCu);
        }

LABEL_36:

        goto LABEL_37;
      }

      if (v21 != 1)
      {
        v10 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v24 = "nw_txt_record_access_bytes";
          _os_log_impl(&dword_181A37000, v10, v20, "%{public}s called with null access_bytes, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_36;
      }

      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v17 = type;
      v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *buf = 136446210;
          v24 = "nw_txt_record_access_bytes";
          _os_log_impl(&dword_181A37000, v10, v17, "%{public}s called with null access_bytes, no backtrace", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v18)
      {
        *buf = 136446466;
        v24 = "nw_txt_record_access_bytes";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_181A37000, v10, v17, "%{public}s called with null access_bytes, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_24;
    }
  }

  else
  {
    v8 = __nwlog_obj();
    *buf = 136446210;
    v24 = "nw_txt_record_access_bytes";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v10 = __nwlog_obj();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v24 = "nw_txt_record_access_bytes";
          _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null txt_record", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v21 != 1)
      {
        v10 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v24 = "nw_txt_record_access_bytes";
          _os_log_impl(&dword_181A37000, v10, v19, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_36;
      }

      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *buf = 136446210;
          v24 = "nw_txt_record_access_bytes";
          _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v16)
      {
        *buf = 136446466;
        v24 = "nw_txt_record_access_bytes";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_24:

      free(backtrace_string);
    }
  }

LABEL_37:
  if (v9)
  {
    free(v9);
  }

  v6 = 0;
LABEL_4:

  return v6;
}

uint64_t __nw_txt_record_is_equal_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = 0;
  v11[0] = MEMORY[0x1E69E9820];
  v11[1] = 3221225472;
  v11[2] = __nw_txt_record_is_equal_block_invoke_2;
  v11[3] = &unk_1E6A36030;
  v12 = a7;
  v11[6] = a2;
  v11[7] = a5;
  v11[8] = a4;
  v11[4] = &v13;
  v11[5] = a3;
  v8 = _Block_copy(v11);
  nw_txt_record_apply_internal_locked(*(a1 + 32), v8, 0);
  v9 = *(v14 + 24);
  if ((v9 & 1) == 0)
  {
    *(*(*(a1 + 40) + 8) + 24) = 0;
  }

  _Block_object_dispose(&v13, 8);
  return v9;
}

uint64_t __nw_txt_record_is_equal_block_invoke_2(uint64_t a1, const char *a2, size_t a3, const void *a4, size_t a5, uint64_t a6, int a7)
{
  if (*(a1 + 72) != a7 || *(a1 + 40) != a3)
  {
    return 1;
  }

  if (strncasecmp(*(a1 + 48), a2, a3) || a7 == 4 && (*(a1 + 56) != a5 || memcmp(*(a1 + 64), a4, a5)))
  {
    return 1;
  }

  result = 0;
  *(*(*(a1 + 32) + 8) + 24) = 1;
  return result;
}

uint64_t nw_txt_record_get_key(void *a1, const char *a2, void *a3, int *a4)
{
  v40 = *MEMORY[0x1E69E9840];
  v7 = a1;
  v8 = v7;
  if (!v7)
  {
    v12 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_txt_record_get_key";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35))
    {
      goto LABEL_74;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null txt_record", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v35 != 1)
    {
      v14 = __nwlog_obj();
      v31 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_181A37000, v14, v31, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_73;
    }

    backtrace_string = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v23 = type;
    v24 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_181A37000, v14, v23, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v24)
    {
      *buf = 136446466;
      *&buf[4] = "nw_txt_record_get_key";
      v38 = 2082;
      v39 = backtrace_string;
      _os_log_impl(&dword_181A37000, v14, v23, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_49:

    free(backtrace_string);
    goto LABEL_74;
  }

  if ((v7[9]._os_unfair_lock_opaque & 1) == 0)
  {
    v16 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_txt_record_get_key";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35))
    {
      goto LABEL_74;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_181A37000, v14, v17, "%{public}s called with null (txt_record->is_dictionary == true)", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v35 != 1)
    {
      v14 = __nwlog_obj();
      v32 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_181A37000, v14, v32, "%{public}s called with null (txt_record->is_dictionary == true), backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_73;
    }

    backtrace_string = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v25 = type;
    v26 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_181A37000, v14, v25, "%{public}s called with null (txt_record->is_dictionary == true), no backtrace", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v26)
    {
      *buf = 136446466;
      *&buf[4] = "nw_txt_record_get_key";
      v38 = 2082;
      v39 = backtrace_string;
      _os_log_impl(&dword_181A37000, v14, v25, "%{public}s called with null (txt_record->is_dictionary == true), dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_49;
  }

  if ((nw_txt_record_key_is_valid(a2) & 1) == 0)
  {
    v18 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_txt_record_get_key";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35))
    {
      goto LABEL_74;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_181A37000, v14, v19, "%{public}s called with null nw_txt_record_key_is_valid(key)", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v35 != 1)
    {
      v14 = __nwlog_obj();
      v33 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_181A37000, v14, v33, "%{public}s called with null nw_txt_record_key_is_valid(key), backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_73;
    }

    backtrace_string = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v27 = type;
    v28 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_181A37000, v14, v27, "%{public}s called with null nw_txt_record_key_is_valid(key), no backtrace", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v28)
    {
      *buf = 136446466;
      *&buf[4] = "nw_txt_record_get_key";
      v38 = 2082;
      v39 = backtrace_string;
      _os_log_impl(&dword_181A37000, v14, v27, "%{public}s called with null nw_txt_record_key_is_valid(key), dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_49;
  }

  if (a3)
  {
    os_unfair_lock_lock(v8 + 8);
    *buf = 0;
    if (*&v8[4]._os_unfair_lock_opaque == 1)
    {
      *a3 = 0;
      start_of_key_locked = 1;
    }

    else
    {
      start_of_key_locked = nw_txt_record_find_start_of_key_locked(v8, a2, 0, 0, buf, a3);
    }

    *a4 = start_of_key_locked;
    os_unfair_lock_unlock(v8 + 8);
    v10 = *buf;
    goto LABEL_9;
  }

  v20 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_txt_record_get_key";
  v13 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v35 = 0;
  if (__nwlog_fault(v13, &type, &v35))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v21 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_181A37000, v14, v21, "%{public}s called with null value_len", buf, 0xCu);
      }

LABEL_73:

      goto LABEL_74;
    }

    if (v35 != 1)
    {
      v14 = __nwlog_obj();
      v34 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_181A37000, v14, v34, "%{public}s called with null value_len, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_73;
    }

    backtrace_string = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v29 = type;
    v30 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v30)
      {
        *buf = 136446210;
        *&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_181A37000, v14, v29, "%{public}s called with null value_len, no backtrace", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v30)
    {
      *buf = 136446466;
      *&buf[4] = "nw_txt_record_get_key";
      v38 = 2082;
      v39 = backtrace_string;
      _os_log_impl(&dword_181A37000, v14, v29, "%{public}s called with null value_len, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_49;
  }

LABEL_74:
  if (v13)
  {
    free(v13);
  }

  v10 = 0;
LABEL_9:

  return v10;
}

uint64_t nw_txt_record_get_key_value_result(unsigned __int8 *a1, uint64_t a2)
{
  if (!a1)
  {
    return 1;
  }

  v2 = *a1;
  if (v2 == a2)
  {
    return 2;
  }

  if (a2 + 1 == v2)
  {
    return 3;
  }

  if (a2 + 1 >= v2)
  {
    __assert_rtn("nw_txt_record_get_key_value_result", "txt_record.cpp", 758, "false");
  }

  return 4;
}

nw_txt_record_t nw_txt_record_copy(nw_txt_record_t txt_record)
{
  if (txt_record)
  {
    return nw_txt_record_create_with_bytes(txt_record[1].isa, txt_record[2].isa);
  }

  return txt_record;
}

uint64_t nw_txt_record_get_bytes(uint64_t result)
{
  if (result)
  {
    return *(result + 8);
  }

  return result;
}

uint64_t nw_txt_record_get_length(uint64_t result)
{
  if (result)
  {
    return *(result + 16);
  }

  return result;
}

const char *nw_activity_reporting_strategy_to_string(unsigned int a1)
{
  if (a1 > 3)
  {
    return "invalid";
  }

  else
  {
    return off_1E6A361E0[a1];
  }
}

const char *nw_activity_completion_reason_to_string(int a1)
{
  if ((a1 - 1) > 3)
  {
    return "invalid";
  }

  else
  {
    return off_1E6A378D0[a1 - 1];
  }
}

const char *nw_activity_domain_and_label_to_string(int a1, int a2)
{
  switch(a1)
  {
    case 11:
      if ((a2 - 1) >= 9)
      {
        return "libnetcore:invalid";
      }

      else
      {
        return off_1E6A366E0[a2 - 1];
      }

    case 12:
      if ((a2 - 1) >= 4)
      {
        return "cfnetwork:invalid";
      }

      else
      {
        return off_1E6A36728[a2 - 1];
      }

    case 13:
      if ((a2 - 1) >= 3)
      {
        return "coremedia:invalid";
      }

      else
      {
        return off_1E6A36748[a2 - 1];
      }

    case 14:
      if ((a2 - 1) >= 0xD)
      {
        return "parsec:invalid";
      }

      else
      {
        return off_1E6A36760[a2 - 1];
      }

    case 15:
      if ((a2 - 1) >= 0xA)
      {
        return "siri:invalid";
      }

      else
      {
        return off_1E6A367C8[a2 - 1];
      }

    case 16:
      if ((a2 - 1) >= 3)
      {
        return "webkit:invalid";
      }

      else
      {
        return off_1E6A36818[a2 - 1];
      }

    case 17:
      if ((a2 - 1) >= 5)
      {
        return "coremedia_crabs:invalid";
      }

      else
      {
        return off_1E6A36830[a2 - 1];
      }

    case 18:
      if ((a2 - 1) >= 0x12)
      {
        return "coremedia_hls:invalid";
      }

      else
      {
        return off_1E6A36858[a2 - 1];
      }

    case 19:
      v5 = "cloudkit:invalid";
      v6 = "cloudkit:invalid_max";
      goto LABEL_83;
    case 20:
      v5 = "mmcs:invalid";
      v6 = "mmcs:invalid_max";
      goto LABEL_83;
    case 21:
      if ((a2 - 1) >= 0x18)
      {
        return "mail:invalid";
      }

      else
      {
        return off_1E6A368E8[a2 - 1];
      }

    case 22:
      if ((a2 - 1) >= 7)
      {
        return "facetime:invalid";
      }

      else
      {
        return off_1E6A369A8[a2 - 1];
      }

    case 23:
      if ((a2 - 1) >= 0x19)
      {
        return "adplatforms:invalid";
      }

      else
      {
        return off_1E6A369E0[a2 - 1];
      }

    case 24:
      if ((a2 - 1) >= 3)
      {
        return "corelocation:invalid";
      }

      else
      {
        return off_1E6A36AA8[a2 - 1];
      }

    case 25:
      if ((a2 - 1) >= 3)
      {
        return "airplay_sender:invalid";
      }

      else
      {
        return off_1E6A36AC0[a2 - 1];
      }

    case 26:
      if ((a2 - 1) >= 3)
      {
        return "airplay_receiver:invalid";
      }

      else
      {
        return off_1E6A36AD8[a2 - 1];
      }

    case 27:
      if ((a2 - 1) >= 0x43)
      {
        return "maps:invalid";
      }

      else
      {
        return off_1E6A36AF0[a2 - 1];
      }

    case 28:
      if ((a2 - 1) >= 0x43)
      {
        return "maps_internal:invalid";
      }

      else
      {
        return off_1E6A36D08[a2 - 1];
      }

    case 29:
      if ((a2 - 1) >= 0x43)
      {
        return "maps_external:invalid";
      }

      else
      {
        return off_1E6A36F20[a2 - 1];
      }

    case 30:
      if ((a2 - 1) >= 5)
      {
        return "network_speed_test:invalid";
      }

      else
      {
        return off_1E6A37138[a2 - 1];
      }

    case 31:
      v3 = "captive:invalid";
      if (a2 == 1)
      {
        v3 = "captive:captive_probe";
      }

      v4 = "captive:invalid_max";
      goto LABEL_99;
    case 32:
      if ((a2 - 1) >= 0xD)
      {
        return "safe_browsing:invalid";
      }

      else
      {
        return off_1E6A37160[a2 - 1];
      }

    case 33:
      if ((a2 - 1) >= 4)
      {
        return "dns:invalid";
      }

      else
      {
        return off_1E6A371C8[a2 - 1];
      }

    case 34:
      if ((a2 - 1) >= 0xC)
      {
        return "music:invalid";
      }

      else
      {
        return off_1E6A371E8[a2 - 1];
      }

    case 35:
      if ((a2 - 1) >= 3)
      {
        return "battery:invalid";
      }

      else
      {
        return off_1E6A37248[a2 - 1];
      }

    case 36:
      if ((a2 - 1) >= 0xB)
      {
        return "cloud_media_services:invalid";
      }

      else
      {
        return off_1E6A37260[a2 - 1];
      }

    case 37:
      if ((a2 - 1) >= 0xE)
      {
        return "avconference:invalid";
      }

      else
      {
        return off_1E6A372B8[a2 - 1];
      }

    case 38:
      if ((a2 - 1) >= 4)
      {
        return "appstore:invalid";
      }

      else
      {
        return off_1E6A37328[a2 - 1];
      }

    case 39:
      v3 = "telephony_service:invalid";
      if (a2 == 1)
      {
        v3 = "telephony_service:session";
      }

      v4 = "telephony_service:invalid_max";
      goto LABEL_99;
    case 40:
      if ((a2 - 1) >= 8)
      {
        return "network_experiments:invalid";
      }

      else
      {
        return off_1E6A37348[a2 - 1];
      }

    case 41:
      if ((a2 - 1) >= 7)
      {
        return "network_perf:invalid";
      }

      else
      {
        return off_1E6A37388[a2 - 1];
      }

    case 42:
      if ((a2 - 1) >= 4)
      {
        return "hotspot:invalid";
      }

      else
      {
        return off_1E6A373C0[a2 - 1];
      }

    case 43:
      if ((a2 - 1) >= 0x11)
      {
        return "weather:invalid";
      }

      else
      {
        return off_1E6A373E0[a2 - 1];
      }

    case 44:
      if ((a2 - 1) >= 8)
      {
        return "coordination:invalid";
      }

      else
      {
        return off_1E6A37468[a2 - 1];
      }

    case 45:
      if ((a2 - 1) >= 0xA)
      {
        return "appstore_jet:invalid";
      }

      else
      {
        return off_1E6A374A8[a2 - 1];
      }

    case 46:
      v3 = "soundboard:invalid";
      if (a2 == 1)
      {
        v3 = "soundboard:stereo_pair_volume_sync";
      }

      v4 = "soundboard:invalid_max";
LABEL_99:
      if (a2 == 2)
      {
        result = v4;
      }

      else
      {
        result = v3;
      }

      break;
    case 47:
      if ((a2 - 1) >= 0xE)
      {
        result = "aea:invalid";
      }

      else
      {
        result = off_1E6A374F8[a2 - 1];
      }

      break;
    case 48:
      if ((a2 - 1) >= 4)
      {
        result = "homekit:invalid";
      }

      else
      {
        result = off_1E6A37568[a2 - 1];
      }

      break;
    case 49:
      if ((a2 - 1) >= 0xB)
      {
        result = "wifi:invalid";
      }

      else
      {
        result = off_1E6A37588[a2 - 1];
      }

      break;
    case 50:
      if ((a2 - 1) >= 3)
      {
        result = "app_launch:invalid";
      }

      else
      {
        result = off_1E6A375E0[a2 - 1];
      }

      break;
    case 51:
      if ((a2 - 1) >= 0xC)
      {
        result = "ams:invalid";
      }

      else
      {
        result = off_1E6A375F8[a2 - 1];
      }

      break;
    case 52:
      if ((a2 - 1) >= 8)
      {
        result = "reve:invalid";
      }

      else
      {
        result = off_1E6A37658[a2 - 1];
      }

      break;
    case 53:
      if ((a2 - 1) >= 6)
      {
        result = "network_quality:invalid";
      }

      else
      {
        result = off_1E6A37698[a2 - 1];
      }

      break;
    case 54:
      if ((a2 - 1) >= 5)
      {
        result = "news:invalid";
      }

      else
      {
        result = off_1E6A376C8[a2 - 1];
      }

      break;
    case 55:
      if ((a2 - 1) >= 5)
      {
        result = "cloud_compute:invalid";
      }

      else
      {
        result = off_1E6A376F0[a2 - 1];
      }

      break;
    case 56:
      v5 = "push:invalid";
      v6 = "push:invalid_max";
LABEL_83:
      if (a2 == 1)
      {
        result = v6;
      }

      else
      {
        result = v5;
      }

      break;
    case 57:
      if ((a2 - 1) >= 3)
      {
        result = "nw_actor_system:invalid";
      }

      else
      {
        result = off_1E6A37718[a2 - 1];
      }

      break;
    case 58:
      if ((a2 - 1) >= 0x18)
      {
        result = "app_intents_services:invalid";
      }

      else
      {
        result = off_1E6A37730[a2 - 1];
      }

      break;
    case 59:
      if ((a2 - 1) >= 8)
      {
        result = "stocks:invalid";
      }

      else
      {
        result = off_1E6A377F0[a2 - 1];
      }

      break;
    case 60:
      if ((a2 - 1) >= 0xC)
      {
        result = "tv_app:invalid";
      }

      else
      {
        result = off_1E6A37830[a2 - 1];
      }

      break;
    case 61:
      if ((a2 - 1) >= 4)
      {
        result = "rapport:invalid";
      }

      else
      {
        result = off_1E6A37890[a2 - 1];
      }

      break;
    case 62:
      if ((a2 - 1) >= 4)
      {
        result = "mobile_asset:invalid";
      }

      else
      {
        result = off_1E6A378B0[a2 - 1];
      }

      break;
    default:
      if ((a1 - 1) >= 0xA)
      {
        v7 = "invalid:invalid";
      }

      else
      {
        v7 = "reserved:reserved";
      }

      if ((a1 - 900) >= 0x64)
      {
        result = v7;
      }

      else
      {
        result = "experimental:experimental";
      }

      break;
  }

  return result;
}

char *nw_activity_create_from_xpc_token(void *a1)
{
  v21 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if (object_getClass(v1) == MEMORY[0x1E69E9F20])
    {
      *buf = *xpc_uuid_get_bytes(v2);
      v3 = [[NWConcrete_nw_activity alloc] initWithToken:buf];
      goto LABEL_4;
    }

    v9 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_activity_create_from_xpc_token";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v6, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v7 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v7, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_activity_create_from_xpc_token";
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null (xpc_get_type(token) == (&_xpc_type_uuid))", buf, 0xCu);
        }

LABEL_36:

        goto LABEL_37;
      }

      if (v18 != 1)
      {
        v7 = __nwlog_obj();
        v17 = type;
        if (os_log_type_enabled(v7, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_activity_create_from_xpc_token";
          _os_log_impl(&dword_181A37000, v7, v17, "%{public}s called with null (xpc_get_type(token) == (&_xpc_type_uuid)), backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_36;
      }

      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *buf = 136446210;
          *&buf[4] = "nw_activity_create_from_xpc_token";
          _os_log_impl(&dword_181A37000, v7, v14, "%{public}s called with null (xpc_get_type(token) == (&_xpc_type_uuid)), no backtrace", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v15)
      {
        *buf = 136446466;
        *&buf[4] = "nw_activity_create_from_xpc_token";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v7, v14, "%{public}s called with null (xpc_get_type(token) == (&_xpc_type_uuid)), dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_24;
    }
  }

  else
  {
    v5 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_activity_create_from_xpc_token";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v6, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_activity_create_from_xpc_token";
          _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null token", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v18 != 1)
      {
        v7 = __nwlog_obj();
        v16 = type;
        if (os_log_type_enabled(v7, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_activity_create_from_xpc_token";
          _os_log_impl(&dword_181A37000, v7, v16, "%{public}s called with null token, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_36;
      }

      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (v13)
        {
          *buf = 136446210;
          *&buf[4] = "nw_activity_create_from_xpc_token";
          _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null token, no backtrace", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v13)
      {
        *buf = 136446466;
        *&buf[4] = "nw_activity_create_from_xpc_token";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null token, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_24:

      free(backtrace_string);
    }
  }

LABEL_37:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_4:

  return v3;
}

void *nw_activity_create_retry(void *a1)
{
  v58 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = [NWConcrete_nw_activity alloc];
    v3 = v1;
    if (!v2)
    {
LABEL_89:
      v29 = 0;
LABEL_44:

      goto LABEL_45;
    }

    v52.receiver = v2;
    v52.super_class = NWConcrete_nw_activity;
    v4 = objc_msgSendSuper2(&v52, sel_init);
    v5 = v4;
    if (v4)
    {
      v4[29] = *(v3 + 29);
      v4[28] = *(v3 + 28);
      v4[33] = *(v3 + 33);
      v6 = *(v4 + 140) | 1;
      *(v4 + 140) = v6;
      *(v4 + 140) = *(v3 + 140) & 2 | v6 & 0xFD;
      v7 = v3;
      v8 = v5[7];
      if ((v5[8] & 1) != 0 && v8)
      {
        v5[7] = 0;

        v8 = v5[7];
      }

      v5[7] = 0;

      v9 = v5[7];
      v5[7] = v7;

      *(v5 + 64) |= 1u;
      v10 = v7;
      v11 = (*(v3 + 140) & 4) == 0;

      if (v11)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        *buf = 136446210;
        v54 = "[NWConcrete_nw_activity initWithOriginal:]";
        v13 = _os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v50 = 0;
        if (!__nwlog_fault(v13, &type, &v50))
        {
          goto LABEL_13;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = gLogObj;
          v15 = type;
          if (os_log_type_enabled(v14, type))
          {
            *buf = 136446210;
            v54 = "[NWConcrete_nw_activity initWithOriginal:]";
            _os_log_impl(&dword_181A37000, v14, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot create retry of a non-activated activity", buf, 0xCu);
          }

LABEL_12:

LABEL_13:
          if (!v13)
          {
            goto LABEL_15;
          }

          goto LABEL_14;
        }

        if (v50 != 1)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = gLogObj;
          v33 = type;
          if (os_log_type_enabled(v14, type))
          {
            *buf = 136446210;
            v54 = "[NWConcrete_nw_activity initWithOriginal:]";
            _os_log_impl(&dword_181A37000, v14, v33, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot create retry of a non-activated activity, backtrace limit exceeded", buf, 0xCu);
          }

          goto LABEL_12;
        }

        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v23 = type;
        v24 = os_log_type_enabled(v14, type);
        if (!backtrace_string)
        {
          if (v24)
          {
            *buf = 136446210;
            v54 = "[NWConcrete_nw_activity initWithOriginal:]";
            _os_log_impl(&dword_181A37000, v14, v23, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot create retry of a non-activated activity, no backtrace", buf, 0xCu);
          }

          goto LABEL_12;
        }

        if (v24)
        {
          *buf = 136446466;
          v54 = "[NWConcrete_nw_activity initWithOriginal:]";
          v55 = 2082;
          *v56 = backtrace_string;
          _os_log_impl(&dword_181A37000, v14, v23, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot create retry of a non-activated activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (v13)
        {
LABEL_14:
          free(v13);
        }
      }

LABEL_15:
      if ((*(v3 + 140) & 8) == 0)
      {
        goto LABEL_35;
      }

      if (*(v10 + 9))
      {
        if (__nwlog_activity_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_47419);
        }

        v16 = gactivityLogObj;
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          goto LABEL_34;
        }

        v17 = *(v10 + 9);
        v18 = *(v10 + 32);
        *buf = 138412802;
        v54 = v10;
        v55 = 2080;
        *v56 = v17;
        *&v56[8] = 1024;
        v57 = v18;
        v19 = "Original activity %@ was completed, ignoring underlying error domain: %s, code: %d";
        v20 = v16;
        v21 = 28;
      }

      else
      {
        if (!*(v10 + 31) && !*(v10 + 32))
        {
          goto LABEL_35;
        }

        if (__nwlog_activity_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_47419);
        }

        v16 = gactivityLogObj;
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          goto LABEL_34;
        }

        v25 = *(v10 + 31);
        v26 = *(v10 + 32);
        *buf = 138412802;
        v54 = v10;
        v55 = 1024;
        *v56 = v25;
        *&v56[4] = 1024;
        *&v56[6] = v26;
        v19 = "Original activity %@ was completed, ignoring underlying error domain: %d, code: %d";
        v20 = v16;
        v21 = 24;
      }

      _os_log_impl(&dword_181A37000, v20, OS_LOG_TYPE_DEBUG, v19, buf, v21);
LABEL_34:

LABEL_35:
      v27 = v10;
      v28 = v27[17];

      v29 = v5;
      uuid_generate_random(v29 + 8);
      *(v29 + 17) = *(v29 + 17) & 0xFE | v28 & 1;
      os_unfair_lock_lock(v29 + 26);
      v30 = v29[11];
      if ((v29[12] & 1) != 0 && v30)
      {
        v29[11] = 0;

        v30 = v29[11];
      }

      v29[11] = 0;

      os_unfair_lock_unlock(v29 + 26);
      if (nw_activity_should_log(v29))
      {
        if (__nwlog_activity_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_47419);
        }

        v31 = gactivityLogObj;
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 138543362;
          v54 = v29;
          _os_log_impl(&dword_181A37000, v31, OS_LOG_TYPE_DEFAULT, "Create activity %{public}@", buf, 0xCu);
        }
      }

      goto LABEL_44;
    }

    v38 = __nwlog_obj();
    *buf = 136446210;
    v54 = "[NWConcrete_nw_activity initWithOriginal:]";
    v39 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (__nwlog_fault(v39, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v40 = __nwlog_obj();
        v41 = type;
        if (os_log_type_enabled(v40, type))
        {
          *buf = 136446210;
          v54 = "[NWConcrete_nw_activity initWithOriginal:]";
          _os_log_impl(&dword_181A37000, v40, v41, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v50 == 1)
      {
        v45 = __nw_create_backtrace_string();
        v40 = __nwlog_obj();
        v46 = type;
        v47 = os_log_type_enabled(v40, type);
        if (v45)
        {
          if (v47)
          {
            *buf = 136446466;
            v54 = "[NWConcrete_nw_activity initWithOriginal:]";
            v55 = 2082;
            *v56 = v45;
            _os_log_impl(&dword_181A37000, v40, v46, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v45);
          goto LABEL_87;
        }

        if (v47)
        {
          *buf = 136446210;
          v54 = "[NWConcrete_nw_activity initWithOriginal:]";
          _os_log_impl(&dword_181A37000, v40, v46, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v40 = __nwlog_obj();
        v49 = type;
        if (os_log_type_enabled(v40, type))
        {
          *buf = 136446210;
          v54 = "[NWConcrete_nw_activity initWithOriginal:]";
          _os_log_impl(&dword_181A37000, v40, v49, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_87:
    if (v39)
    {
      free(v39);
    }

    goto LABEL_89;
  }

  v34 = __nwlog_obj();
  *buf = 136446210;
  v54 = "nw_activity_create_retry";
  v35 = _os_log_send_and_compose_impl();

  LOBYTE(v52.receiver) = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v35, &v52, &type))
  {
    if (LOBYTE(v52.receiver) == 17)
    {
      v36 = __nwlog_obj();
      receiver = v52.receiver;
      if (os_log_type_enabled(v36, v52.receiver))
      {
        *buf = 136446210;
        v54 = "nw_activity_create_retry";
        _os_log_impl(&dword_181A37000, v36, receiver, "%{public}s called with null original", buf, 0xCu);
      }
    }

    else if (type == OS_LOG_TYPE_INFO)
    {
      v42 = __nw_create_backtrace_string();
      v36 = __nwlog_obj();
      v43 = v52.receiver;
      v44 = os_log_type_enabled(v36, v52.receiver);
      if (v42)
      {
        if (v44)
        {
          *buf = 136446466;
          v54 = "nw_activity_create_retry";
          v55 = 2082;
          *v56 = v42;
          _os_log_impl(&dword_181A37000, v36, v43, "%{public}s called with null original, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v42);
        goto LABEL_81;
      }

      if (v44)
      {
        *buf = 136446210;
        v54 = "nw_activity_create_retry";
        _os_log_impl(&dword_181A37000, v36, v43, "%{public}s called with null original, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v36 = __nwlog_obj();
      v48 = v52.receiver;
      if (os_log_type_enabled(v36, v52.receiver))
      {
        *buf = 136446210;
        v54 = "nw_activity_create_retry";
        _os_log_impl(&dword_181A37000, v36, v48, "%{public}s called with null original, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_81:
  if (v35)
  {
    free(v35);
  }

  v29 = 0;
LABEL_45:

  return v29;
}

uint64_t nw_activity_deep_is_equal(void *a1, void *a2)
{
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3 && v4 && !uuid_is_null(v3 + 8) && !uuid_is_null(v5 + 8))
  {
    if (*(v3 + 29) != *(v5 + 29) || *(v3 + 28) != *(v5 + 28) || *(v3 + 3) != *(v5 + 3) || *(v3 + 33) != *(v5 + 33) || *(v3 + 34) != *(v5 + 34) || ((*(v5 + 140) ^ *(v3 + 140)) & 0xD) != 0 || (v9 = *(v5 + 7), v10 = *(v3 + 7), LOBYTE(v9) = nw_activity_is_equal(v10, v9), v10, (v9 & 1) == 0) || *(v3 + 1) != *(v5 + 1) || *(v3 + 2) != *(v5 + 2))
    {
      v7 = 0;
      goto LABEL_9;
    }

    v6 = *(v3 + 4) == *(v5 + 4);
  }

  else
  {
    v6 = v3 == v5;
  }

  v7 = v6;
LABEL_9:

  return v7;
}

void sub_1828A5E68(_Unwind_Exception *a1)
{
  v4 = v3;

  _Unwind_Resume(a1);
}

uint64_t nw_activity_should_report_to_destination(int a1)
{
  v22 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v5 = __nwlog_obj();
    *buf = 136446210;
    v19 = "nw_activity_should_report_to_destination";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v6, &type, &v16))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v19 = "nw_activity_should_report_to_destination";
        v9 = "%{public}s called with null destination";
LABEL_36:
        _os_log_impl(&dword_181A37000, v7, v8, v9, buf, 0xCu);
      }
    }

    else
    {
      if (v16 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v8 = type;
        v14 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *buf = 136446466;
            v19 = "nw_activity_should_report_to_destination";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null destination, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_38;
        }

        if (!v14)
        {
          goto LABEL_37;
        }

        *buf = 136446210;
        v19 = "nw_activity_should_report_to_destination";
        v9 = "%{public}s called with null destination, no backtrace";
        goto LABEL_36;
      }

      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v19 = "nw_activity_should_report_to_destination";
        v9 = "%{public}s called with null destination, backtrace limit exceeded";
        goto LABEL_36;
      }
    }

LABEL_37:

LABEL_38:
    if (v6)
    {
      free(v6);
    }

    return 0;
  }

  int64_with_default = networkd_settings_get_int64_with_default(nw_setting_activity_report_destination, 12);
  v3 = gLogDatapath;
  if (gLogDatapath == 1)
  {
    v10 = int64_with_default;
    if (__nwlog_activity_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_47419);
    }

    v11 = gactivityLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *buf = 136446466;
      v19 = "nw_activity_should_report_to_destination";
      v20 = 2048;
      v21 = v10;
      _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_DEBUG, "%{public}s Activity destination: %llu", buf, 0x16u);
    }

    v3 = gLogDatapath;
    LODWORD(int64_with_default) = v10;
  }

  if ((int64_with_default & a1) == 0)
  {
    if (v3)
    {
      if (__nwlog_activity_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_47419);
      }

      v15 = gactivityLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446466;
        v19 = "nw_activity_should_report_to_destination";
        v20 = 1024;
        LODWORD(v21) = a1;
        _os_log_impl(&dword_181A37000, v15, OS_LOG_TYPE_DEBUG, "%{public}s Destination %u is not configured", buf, 0x12u);
      }
    }

    return 0;
  }

  if ((v3 & 1) == 0)
  {
    return 1;
  }

  if (__nwlog_activity_log::onceToken != -1)
  {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_47419);
  }

  v12 = gactivityLogObj;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    *buf = 136446466;
    v19 = "nw_activity_should_report_to_destination";
    v20 = 1024;
    LODWORD(v21) = a1;
    _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_DEBUG, "%{public}s Destination %u is configured", buf, 0x12u);
  }

  return 1;
}

const char *nw_activity_domain_to_string(int a1)
{
  if ((a1 - 11) < 0x34)
  {
    return off_1E6A36540[a1 - 11];
  }

  if ((a1 - 1) >= 0xA)
  {
    v2 = "invalid";
  }

  else
  {
    v2 = "reserved";
  }

  if ((a1 - 900) >= 0x64)
  {
    return v2;
  }

  else
  {
    return "experimental";
  }
}

os_signpost_id_t nw_activity_signpost_id_fallback(void)
{
  if (__nwlog_activity_log::onceToken != -1)
  {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_47419);
  }

  v0 = gactivityLogObj;
  v1 = os_signpost_id_generate(v0);

  return v1;
}

void *nw_activity_create_activity_dictionary(NWConcrete_nw_activity *a1, nw_activity_report_s *a2)
{
  v28 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (a2)
  {
    v4 = xpc_dictionary_create(0, 0, 0);
    v5 = v4;
    *type = v4;
    v25 = -1;
    if (v4)
    {
      xpc_dictionary_set_uint64(v4, "activityDomain", a2->domain);
      xpc_dictionary_set_uint64(v5, "activityLabel", a2->label);
      if (!uuid_is_null(a2->activity_uuid))
      {
        memset(out, 0, sizeof(out));
        uuid_unparse(a2->activity_uuid, out);
        xpc_dictionary_set_string(v5, "activityUUID", out);
      }

      if (!uuid_is_null(a2->parent_activity_uuid))
      {
        memset(out, 0, sizeof(out));
        uuid_unparse(a2->parent_activity_uuid, out);
        xpc_dictionary_set_string(v5, "parentActivityUUID", out);
      }

      xpc_dictionary_set_BOOL(v5, "isRetry", *(a2 + 304) & 1);
      if (a2->bundle_id[0])
      {
        xpc_dictionary_set_string(v5, "bundleID", a2->bundle_id);
      }

      xpc_dictionary_set_uint64(v5, "investigationID", a2->investigation_identifier);
      goto LABEL_10;
    }

    v11 = __nwlog_obj();
    *out = 136446210;
    *&out[4] = "nw_activity_create_activity_dictionary";
    v12 = _os_log_send_and_compose_impl();

    v26 = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v12, &v26, &v23))
    {
      goto LABEL_46;
    }

    if (v26 == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = v26;
      if (os_log_type_enabled(v13, v26))
      {
        *out = 136446210;
        *&out[4] = "nw_activity_create_activity_dictionary";
        _os_log_impl(&dword_181A37000, v13, v14, "%{public}s failed to allocate dictionary", out, 0xCu);
      }
    }

    else if (v23 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v19 = v26;
      v20 = os_log_type_enabled(v13, v26);
      if (backtrace_string)
      {
        if (v20)
        {
          *out = 136446466;
          *&out[4] = "nw_activity_create_activity_dictionary";
          *&out[12] = 2082;
          *&out[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v13, v19, "%{public}s failed to allocate dictionary, dumping backtrace:%{public}s", out, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_46;
      }

      if (v20)
      {
        *out = 136446210;
        *&out[4] = "nw_activity_create_activity_dictionary";
        _os_log_impl(&dword_181A37000, v13, v19, "%{public}s failed to allocate dictionary, no backtrace", out, 0xCu);
      }
    }

    else
    {
      v13 = __nwlog_obj();
      v22 = v26;
      if (os_log_type_enabled(v13, v26))
      {
        *out = 136446210;
        *&out[4] = "nw_activity_create_activity_dictionary";
        _os_log_impl(&dword_181A37000, v13, v22, "%{public}s failed to allocate dictionary, backtrace limit exceeded", out, 0xCu);
      }
    }

LABEL_46:
    if (v12)
    {
      free(v12);
    }

    goto LABEL_10;
  }

  v7 = __nwlog_obj();
  *out = 136446210;
  *&out[4] = "nw_activity_create_activity_dictionary";
  v8 = _os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v26 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v8, type, &v26))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type[0];
      if (os_log_type_enabled(v9, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_activity_create_activity_dictionary";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null activity_report", out, 0xCu);
      }
    }

    else if (v26 == OS_LOG_TYPE_INFO)
    {
      v15 = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type[0];
      v17 = os_log_type_enabled(v9, type[0]);
      if (v15)
      {
        if (v17)
        {
          *out = 136446466;
          *&out[4] = "nw_activity_create_activity_dictionary";
          *&out[12] = 2082;
          *&out[14] = v15;
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s called with null activity_report, dumping backtrace:%{public}s", out, 0x16u);
        }

        free(v15);
        goto LABEL_40;
      }

      if (v17)
      {
        *out = 136446210;
        *&out[4] = "nw_activity_create_activity_dictionary";
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s called with null activity_report, no backtrace", out, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v21 = type[0];
      if (os_log_type_enabled(v9, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_activity_create_activity_dictionary";
        _os_log_impl(&dword_181A37000, v9, v21, "%{public}s called with null activity_report, backtrace limit exceeded", out, 0xCu);
      }
    }
  }

LABEL_40:
  if (v8)
  {
    free(v8);
  }

  v5 = 0;
LABEL_10:

  return v5;
}

void sub_1828A697C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va);

  _Unwind_Resume(a1);
}

uint64_t __nw_activity_metric_object_is_valid_block_invoke_75(uint64_t a1, uint64_t a2, void *a3)
{
  v11 = *MEMORY[0x1E69E9840];
  v5 = a3;
  if (a2)
  {
    nw_append_format(*(a1 + 40), ",");
  }

  if (__nwlog_activity_log::onceToken != -1)
  {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_47419);
  }

  v6 = gactivityLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    v9 = 134217984;
    v10 = a2;
    _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_DEBUG, "Inspecting array index: %zu", &v9, 0xCu);
  }

  is_valid = nw_activity_metric_object_is_valid(v5, (*(a1 + 48) + 1), *(a1 + 40));
  if ((is_valid & 1) == 0)
  {
    *(*(*(a1 + 32) + 8) + 24) = 0;
  }

  return is_valid;
}

uint64_t nw_activity_uuid_is_selected_for_reporting(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    return *(a1 + 9) & 1;
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_activity_uuid_is_selected_for_reporting";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_activity_uuid_is_selected_for_reporting";
        v6 = "%{public}s called with null uuid";
LABEL_17:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_activity_uuid_is_selected_for_reporting";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null uuid, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v8)
        {
          goto LABEL_18;
        }

        *buf = 136446210;
        v12 = "nw_activity_uuid_is_selected_for_reporting";
        v6 = "%{public}s called with null uuid, no backtrace";
        goto LABEL_17;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_activity_uuid_is_selected_for_reporting";
        v6 = "%{public}s called with null uuid, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

LABEL_18:
  }

LABEL_19:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

uint64_t nw_activity_get_domain(void *a1)
{
  v27 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (!v1)
  {
    v4 = 0;
    v5 = __nwlog_obj();
    *buf = 136446210;
    v22 = "nw_activity_get_domain";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v22 = "nw_activity_get_domain";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }

    else if (v19 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v22 = "nw_activity_get_domain";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
        {
LABEL_40:
          v2 = 0;
          v1 = v4;
          goto LABEL_4;
        }

LABEL_39:
        free(v6);
        goto LABEL_40;
      }

      if (v13)
      {
        *buf = 136446210;
        v22 = "nw_activity_get_domain";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v22 = "nw_activity_get_domain";
        _os_log_impl(&dword_181A37000, v7, v17, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_37:

    goto LABEL_38;
  }

  if ((v1[140] & 2) != 0)
  {
    v4 = v1;
    v9 = __nwlog_obj();
    *buf = 136446466;
    v22 = "nw_activity_get_domain";
    v23 = 2082;
    v24 = "Cannot get domain from lightweight representation of an activity";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446466;
        v22 = "nw_activity_get_domain";
        v23 = 2082;
        v24 = "Cannot get domain from lightweight representation of an activity";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
      }
    }

    else if (v19 == 1)
    {
      v14 = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v15 = type;
      v16 = os_log_type_enabled(v7, type);
      if (v14)
      {
        if (v16)
        {
          *buf = 136446722;
          v22 = "nw_activity_get_domain";
          v23 = 2082;
          v24 = "Cannot get domain from lightweight representation of an activity";
          v25 = 2082;
          v26 = v14;
          _os_log_impl(&dword_181A37000, v7, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v14);
        if (!v6)
        {
          goto LABEL_40;
        }

        goto LABEL_39;
      }

      if (v16)
      {
        *buf = 136446466;
        v22 = "nw_activity_get_domain";
        v23 = 2082;
        v24 = "Cannot get domain from lightweight representation of an activity";
        _os_log_impl(&dword_181A37000, v7, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v18 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446466;
        v22 = "nw_activity_get_domain";
        v23 = 2082;
        v24 = "Cannot get domain from lightweight representation of an activity";
        _os_log_impl(&dword_181A37000, v7, v18, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
      }
    }

    goto LABEL_37;
  }

  v2 = *(v1 + 29);
LABEL_4:

  return v2;
}

uint64_t nw_activity_get_label(void *a1)
{
  v27 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (!v1)
  {
    v4 = 0;
    v5 = __nwlog_obj();
    *buf = 136446210;
    v22 = "nw_activity_get_label";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v22 = "nw_activity_get_label";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }

    else if (v19 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v22 = "nw_activity_get_label";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
        {
LABEL_40:
          v2 = 0;
          v1 = v4;
          goto LABEL_4;
        }

LABEL_39:
        free(v6);
        goto LABEL_40;
      }

      if (v13)
      {
        *buf = 136446210;
        v22 = "nw_activity_get_label";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v22 = "nw_activity_get_label";
        _os_log_impl(&dword_181A37000, v7, v17, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_37:

    goto LABEL_38;
  }

  if ((v1[140] & 2) != 0)
  {
    v4 = v1;
    v9 = __nwlog_obj();
    *buf = 136446466;
    v22 = "nw_activity_get_label";
    v23 = 2082;
    v24 = "Cannot get label from lightweight representation of an activity";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446466;
        v22 = "nw_activity_get_label";
        v23 = 2082;
        v24 = "Cannot get label from lightweight representation of an activity";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
      }
    }

    else if (v19 == 1)
    {
      v14 = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v15 = type;
      v16 = os_log_type_enabled(v7, type);
      if (v14)
      {
        if (v16)
        {
          *buf = 136446722;
          v22 = "nw_activity_get_label";
          v23 = 2082;
          v24 = "Cannot get label from lightweight representation of an activity";
          v25 = 2082;
          v26 = v14;
          _os_log_impl(&dword_181A37000, v7, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v14);
        if (!v6)
        {
          goto LABEL_40;
        }

        goto LABEL_39;
      }

      if (v16)
      {
        *buf = 136446466;
        v22 = "nw_activity_get_label";
        v23 = 2082;
        v24 = "Cannot get label from lightweight representation of an activity";
        _os_log_impl(&dword_181A37000, v7, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v18 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446466;
        v22 = "nw_activity_get_label";
        v23 = 2082;
        v24 = "Cannot get label from lightweight representation of an activity";
        _os_log_impl(&dword_181A37000, v7, v18, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
      }
    }

    goto LABEL_37;
  }

  v2 = *(v1 + 28);
LABEL_4:

  return v2;
}

void nw_activity_set_reporting_strategy(void *a1, int a2)
{
  v37 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (!v3)
  {
    v4 = 0;
    v5 = __nwlog_obj();
    *buf = 136446210;
    v32 = "nw_activity_set_reporting_strategy";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v6, &type, &v29))
    {
      goto LABEL_71;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v32 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }

      goto LABEL_70;
    }

    if (v29 != 1)
    {
      v7 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v32 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_181A37000, v7, v25, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_70;
    }

    backtrace_string = __nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v16 = type;
    v17 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *buf = 136446210;
        v32 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_181A37000, v7, v16, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }

      goto LABEL_70;
    }

    if (v17)
    {
      *buf = 136446466;
      v32 = "nw_activity_set_reporting_strategy";
      v33 = 2082;
      v34 = backtrace_string;
      _os_log_impl(&dword_181A37000, v7, v16, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_41;
  }

  if ((v3[140] & 4) != 0)
  {
    v4 = v3;
    v9 = __nwlog_obj();
    *buf = 136446210;
    v32 = "nw_activity_set_reporting_strategy";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v6, &type, &v29))
    {
      goto LABEL_71;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v32 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation", buf, 0xCu);
      }

      goto LABEL_70;
    }

    if (v29 != 1)
    {
      v7 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v32 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_181A37000, v7, v26, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_70;
    }

    backtrace_string = __nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v18 = type;
    v19 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *buf = 136446210;
        v32 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_181A37000, v7, v18, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, no backtrace", buf, 0xCu);
      }

      goto LABEL_70;
    }

    if (v19)
    {
      *buf = 136446466;
      v32 = "nw_activity_set_reporting_strategy";
      v33 = 2082;
      v34 = backtrace_string;
      _os_log_impl(&dword_181A37000, v7, v18, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_41;
  }

  if ((v3[140] & 8) != 0)
  {
    v4 = v3;
    v11 = __nwlog_obj();
    *buf = 136446210;
    v32 = "nw_activity_set_reporting_strategy";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v6, &type, &v29))
    {
      goto LABEL_71;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v32 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion", buf, 0xCu);
      }

LABEL_70:

      goto LABEL_71;
    }

    if (v29 != 1)
    {
      v7 = __nwlog_obj();
      v27 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v32 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_181A37000, v7, v27, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_70;
    }

    backtrace_string = __nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v20 = type;
    v21 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *buf = 136446210;
        v32 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_181A37000, v7, v20, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, no backtrace", buf, 0xCu);
      }

      goto LABEL_70;
    }

    if (v21)
    {
      *buf = 136446466;
      v32 = "nw_activity_set_reporting_strategy";
      v33 = 2082;
      v34 = backtrace_string;
      _os_log_impl(&dword_181A37000, v7, v20, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_41:

    free(backtrace_string);
    goto LABEL_71;
  }

  if ((a2 & 0xFC) == 0)
  {
    *(v3 + 33) = a2;
    goto LABEL_6;
  }

  v4 = v3;
  v13 = __nwlog_obj();
  *buf = 136446466;
  v32 = "nw_activity_set_reporting_strategy";
  v33 = 2082;
  v34 = "Invalid reporting strategy";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v29 = 0;
  if (__nwlog_fault(v6, &type, &v29))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446466;
        v32 = "nw_activity_set_reporting_strategy";
        v33 = 2082;
        v34 = "Invalid reporting strategy";
        _os_log_impl(&dword_181A37000, v7, v14, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
      }
    }

    else if (v29 == 1)
    {
      v22 = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v23 = type;
      v24 = os_log_type_enabled(v7, type);
      if (v22)
      {
        if (v24)
        {
          *buf = 136446722;
          v32 = "nw_activity_set_reporting_strategy";
          v33 = 2082;
          v34 = "Invalid reporting strategy";
          v35 = 2082;
          v36 = v22;
          _os_log_impl(&dword_181A37000, v7, v23, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v22);
        goto LABEL_71;
      }

      if (v24)
      {
        *buf = 136446466;
        v32 = "nw_activity_set_reporting_strategy";
        v33 = 2082;
        v34 = "Invalid reporting strategy";
        _os_log_impl(&dword_181A37000, v7, v23, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v28 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446466;
        v32 = "nw_activity_set_reporting_strategy";
        v33 = 2082;
        v34 = "Invalid reporting strategy";
        _os_log_impl(&dword_181A37000, v7, v28, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
      }
    }

    goto LABEL_70;
  }

LABEL_71:
  if (v6)
  {
    free(v6);
  }

  v3 = v4;
LABEL_6:
}

uint64_t nw_activity_get_reporting_strategy(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = v1[33];
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_activity_get_reporting_strategy";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_activity_get_reporting_strategy";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null activity", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_activity_get_reporting_strategy";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_activity_get_reporting_strategy";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_activity_get_reporting_strategy";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
  v1 = 0;
LABEL_3:

  return v2;
}

uint64_t nw_activity_get_is_retry(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = v1[140] & 1;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_activity_get_is_retry";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_activity_get_is_retry";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null activity", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_activity_get_is_retry";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_activity_get_is_retry";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_activity_get_is_retry";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
  v1 = 0;
LABEL_3:

  return v2;
}

uint64_t nw_activity_has_global_parent()
{
  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  v3[0] = MEMORY[0x1E69E9820];
  v3[1] = 3221225472;
  v3[2] = __nw_activity_has_global_parent_block_invoke;
  v3[3] = &unk_1E6A360D0;
  v3[4] = &v5;
  v0 = _Block_copy(v3);
  v4 = v0;
  nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>(&global_parent_lock, &v4);

  v1 = *(v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v1;
}

void sub_1828A8640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void nw_activity_set_investigation_identifier(void *a1, uint64_t a2)
{
  v29 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (!v3)
  {
    v4 = 0;
    v5 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_activity_set_investigation_identifier";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v6, &type, &v23))
    {
      goto LABEL_54;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v26 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }

      goto LABEL_53;
    }

    if (v23 != 1)
    {
      v7 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v26 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_181A37000, v7, v20, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_53;
    }

    backtrace_string = __nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v14 = type;
    v15 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *buf = 136446210;
        v26 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_181A37000, v7, v14, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }

      goto LABEL_53;
    }

    if (v15)
    {
      *buf = 136446466;
      v26 = "nw_activity_set_investigation_identifier";
      v27 = 2082;
      v28 = backtrace_string;
      _os_log_impl(&dword_181A37000, v7, v14, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_35:

    free(backtrace_string);
    goto LABEL_54;
  }

  if ((v3[140] & 4) != 0)
  {
    v4 = v3;
    v9 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_activity_set_investigation_identifier";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v6, &type, &v23))
    {
      goto LABEL_54;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v26 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation", buf, 0xCu);
      }

      goto LABEL_53;
    }

    if (v23 != 1)
    {
      v7 = __nwlog_obj();
      v21 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v26 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_181A37000, v7, v21, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_53;
    }

    backtrace_string = __nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v16 = type;
    v17 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *buf = 136446210;
        v26 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_181A37000, v7, v16, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, no backtrace", buf, 0xCu);
      }

      goto LABEL_53;
    }

    if (v17)
    {
      *buf = 136446466;
      v26 = "nw_activity_set_investigation_identifier";
      v27 = 2082;
      v28 = backtrace_string;
      _os_log_impl(&dword_181A37000, v7, v16, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_35;
  }

  if ((v3[140] & 8) == 0)
  {
    *(v3 + 3) = a2;
    goto LABEL_5;
  }

  v4 = v3;
  v11 = __nwlog_obj();
  *buf = 136446210;
  v26 = "nw_activity_set_investigation_identifier";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (__nwlog_fault(v6, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v26 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion", buf, 0xCu);
      }

LABEL_53:

      goto LABEL_54;
    }

    if (v23 != 1)
    {
      v7 = __nwlog_obj();
      v22 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v26 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_181A37000, v7, v22, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_53;
    }

    backtrace_string = __nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v18 = type;
    v19 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *buf = 136446210;
        v26 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_181A37000, v7, v18, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, no backtrace", buf, 0xCu);
      }

      goto LABEL_53;
    }

    if (v19)
    {
      *buf = 136446466;
      v26 = "nw_activity_set_investigation_identifier";
      v27 = 2082;
      v28 = backtrace_string;
      _os_log_impl(&dword_181A37000, v7, v18, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_35;
  }

LABEL_54:
  if (v6)
  {
    free(v6);
  }

  v3 = v4;
LABEL_5:
}

uint64_t nw_activity_get_investigation_identifier(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = v1[3];
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_activity_get_investigation_identifier";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_activity_get_investigation_identifier";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null activity", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_activity_get_investigation_identifier";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_activity_get_investigation_identifier";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_activity_get_investigation_identifier";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
  v1 = 0;
LABEL_3:

  return v2;
}

BOOL nw_activity_has_investigation_identifier(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = v1[3] != 0;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_activity_has_investigation_identifier";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_activity_has_investigation_identifier";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null activity", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_activity_has_investigation_identifier";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_activity_has_investigation_identifier";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_activity_has_investigation_identifier";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
  v1 = 0;
LABEL_3:

  return v2;
}

xpc_object_t nw_activity_copy_xpc_token(void *a1)
{
  v27 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if ((v1[140] & 4) != 0)
    {
      v3 = xpc_uuid_create(v1 + 8);
      goto LABEL_4;
    }

    v9 = __nwlog_obj();
    *buf = 136446466;
    v22 = "nw_activity_copy_xpc_token";
    v23 = 2082;
    v24 = "Cannot copy xpc token before activation";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v6, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v7 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v7, type))
        {
          *buf = 136446466;
          v22 = "nw_activity_copy_xpc_token";
          v23 = 2082;
          v24 = "Cannot copy xpc token before activation";
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
        }
      }

      else if (v19 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v15 = type;
        v16 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *buf = 136446722;
            v22 = "nw_activity_copy_xpc_token";
            v23 = 2082;
            v24 = "Cannot copy xpc token before activation";
            v25 = 2082;
            v26 = backtrace_string;
            _os_log_impl(&dword_181A37000, v7, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_37;
        }

        if (v16)
        {
          *buf = 136446466;
          v22 = "nw_activity_copy_xpc_token";
          v23 = 2082;
          v24 = "Cannot copy xpc token before activation";
          _os_log_impl(&dword_181A37000, v7, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
        }
      }

      else
      {
        v7 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v7, type))
        {
          *buf = 136446466;
          v22 = "nw_activity_copy_xpc_token";
          v23 = 2082;
          v24 = "Cannot copy xpc token before activation";
          _os_log_impl(&dword_181A37000, v7, v18, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
        }
      }

      goto LABEL_36;
    }
  }

  else
  {
    v5 = __nwlog_obj();
    *buf = 136446210;
    v22 = "nw_activity_copy_xpc_token";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v6, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *buf = 136446210;
          v22 = "nw_activity_copy_xpc_token";
          _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
        }
      }

      else if (v19 == 1)
      {
        v11 = __nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v12 = type;
        v13 = os_log_type_enabled(v7, type);
        if (v11)
        {
          if (v13)
          {
            *buf = 136446466;
            v22 = "nw_activity_copy_xpc_token";
            v23 = 2082;
            v24 = v11;
            _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v11);
          goto LABEL_37;
        }

        if (v13)
        {
          *buf = 136446210;
          v22 = "nw_activity_copy_xpc_token";
          _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v7 = __nwlog_obj();
        v17 = type;
        if (os_log_type_enabled(v7, type))
        {
          *buf = 136446210;
          v22 = "nw_activity_copy_xpc_token";
          _os_log_impl(&dword_181A37000, v7, v17, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }

LABEL_36:
    }
  }

LABEL_37:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_4:

  return v3;
}

void *nw_activity_copy_xpc_object(void *a1)
{
  v33 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = xpc_dictionary_create(0, 0, 0);
    v3 = v2;
    *type = v2;
    v27 = -1;
    if (v2)
    {
      xpc_dictionary_set_uuid(v2, "token", v1 + 8);
      v4 = *(v1 + 7);
      if (v4 && !uuid_is_null((v4 + 8)))
      {
        v5 = *(v1 + 7);
        v6 = v3;
        xpc_dictionary_set_uuid(v6, "parent_token", (v5 + 8));
      }

      xpc_dictionary_set_uint64(v3, "investigation_identifier", *(v1 + 3));
      xpc_dictionary_set_uint64(v3, "start_time", *(v1 + 4));
      xpc_dictionary_set_uint64(v3, "end_time", *(v1 + 5));
      xpc_dictionary_set_uint64(v3, "fragments_quenched", v1[12]);
      xpc_dictionary_set_uint64(v3, "label", v1[28]);
      xpc_dictionary_set_uint64(v3, "domain", v1[29]);
      xpc_dictionary_set_int64(v3, "underlying_error_domain", v1[31]);
      xpc_dictionary_set_int64(v3, "underlying_error_code", v1[32]);
      xpc_dictionary_set_uint64(v3, "reporting_strategy", v1[33]);
      xpc_dictionary_set_uint64(v3, "completion_reason", v1[34]);
      xpc_dictionary_set_BOOL(v3, "is_retry", v1[35] & 1);
      xpc_dictionary_set_BOOL(v3, "is_lightweight", (v1[35] & 2) != 0);
      xpc_dictionary_set_BOOL(v3, "activated", (v1[35] & 4) != 0);
      xpc_dictionary_set_BOOL(v3, "completed", (v1[35] & 8) != 0);
      v7 = *(v1 + 9);
      if (v7)
      {
        xpc_dictionary_set_string(v3, "underlying_error_domain_string", v7);
      }

      goto LABEL_8;
    }

    v13 = __nwlog_obj();
    *buf = 136446210;
    v30 = "nw_activity_copy_xpc_object";
    v14 = _os_log_send_and_compose_impl();

    v28 = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v14, &v28, &v25))
    {
      goto LABEL_44;
    }

    if (v28 == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = v28;
      if (os_log_type_enabled(v15, v28))
      {
        *buf = 136446210;
        v30 = "nw_activity_copy_xpc_object";
        _os_log_impl(&dword_181A37000, v15, v16, "%{public}s failed to allocate dictionary", buf, 0xCu);
      }
    }

    else if (v25 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v21 = v28;
      v22 = os_log_type_enabled(v15, v28);
      if (backtrace_string)
      {
        if (v22)
        {
          *buf = 136446466;
          v30 = "nw_activity_copy_xpc_object";
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_181A37000, v15, v21, "%{public}s failed to allocate dictionary, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_44;
      }

      if (v22)
      {
        *buf = 136446210;
        v30 = "nw_activity_copy_xpc_object";
        _os_log_impl(&dword_181A37000, v15, v21, "%{public}s failed to allocate dictionary, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v15 = __nwlog_obj();
      v24 = v28;
      if (os_log_type_enabled(v15, v28))
      {
        *buf = 136446210;
        v30 = "nw_activity_copy_xpc_object";
        _os_log_impl(&dword_181A37000, v15, v24, "%{public}s failed to allocate dictionary, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_44:
    if (v14)
    {
      free(v14);
    }

    goto LABEL_8;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v30 = "nw_activity_copy_xpc_object";
  v10 = _os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v28 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v10, type, &v28))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *buf = 136446210;
        v30 = "nw_activity_copy_xpc_object";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null activity", buf, 0xCu);
      }
    }

    else if (v28 == OS_LOG_TYPE_INFO)
    {
      v17 = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v18 = type[0];
      v19 = os_log_type_enabled(v11, type[0]);
      if (v17)
      {
        if (v19)
        {
          *buf = 136446466;
          v30 = "nw_activity_copy_xpc_object";
          v31 = 2082;
          v32 = v17;
          _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v17);
        goto LABEL_38;
      }

      if (v19)
      {
        *buf = 136446210;
        v30 = "nw_activity_copy_xpc_object";
        _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v23 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *buf = 136446210;
        v30 = "nw_activity_copy_xpc_object";
        _os_log_impl(&dword_181A37000, v11, v23, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_38:
  if (v10)
  {
    free(v10);
  }

  v3 = 0;
LABEL_8:

  return v3;
}

void sub_1828A9DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);

  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va);
  _Unwind_Resume(a1);
}

uint64_t nw_activity_get_activation_time(void *a1)
{
  v32 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (!v1)
  {
    v4 = 0;
    v5 = __nwlog_obj();
    *buf = 136446210;
    v27 = "nw_activity_get_activation_time";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v6, &type, &v24))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v27 = "nw_activity_get_activation_time";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }

    else if (v24 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v27 = "nw_activity_get_activation_time";
          v28 = 2082;
          v29 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v14, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v6)
        {
LABEL_57:
          v2 = 0;
          v1 = v4;
          goto LABEL_5;
        }

LABEL_56:
        free(v6);
        goto LABEL_57;
      }

      if (v15)
      {
        *buf = 136446210;
        v27 = "nw_activity_get_activation_time";
        _os_log_impl(&dword_181A37000, v7, v14, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v21 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v27 = "nw_activity_get_activation_time";
        _os_log_impl(&dword_181A37000, v7, v21, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_54:

    goto LABEL_55;
  }

  if ((v1[140] & 4) == 0)
  {
    v4 = v1;
    v9 = __nwlog_obj();
    *buf = 136446466;
    v27 = "nw_activity_get_activation_time";
    v28 = 2082;
    v29 = "Cannot get activation time before activation";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v6, &type, &v24))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446466;
        v27 = "nw_activity_get_activation_time";
        v28 = 2082;
        v29 = "Cannot get activation time before activation";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
      }

      goto LABEL_54;
    }

    if (v24 != 1)
    {
      v7 = __nwlog_obj();
      v22 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446466;
        v27 = "nw_activity_get_activation_time";
        v28 = 2082;
        v29 = "Cannot get activation time before activation";
        _os_log_impl(&dword_181A37000, v7, v22, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
      }

      goto LABEL_54;
    }

    v16 = __nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v17 = type;
    v18 = os_log_type_enabled(v7, type);
    if (!v16)
    {
      if (v18)
      {
        *buf = 136446466;
        v27 = "nw_activity_get_activation_time";
        v28 = 2082;
        v29 = "Cannot get activation time before activation";
        _os_log_impl(&dword_181A37000, v7, v17, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
      }

      goto LABEL_54;
    }

    if (v18)
    {
      *buf = 136446722;
      v27 = "nw_activity_get_activation_time";
      v28 = 2082;
      v29 = "Cannot get activation time before activation";
      v30 = 2082;
      v31 = v16;
      _os_log_impl(&dword_181A37000, v7, v17, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
    }

    goto LABEL_35;
  }

  if ((v1[140] & 2) != 0)
  {
    v4 = v1;
    v11 = __nwlog_obj();
    *buf = 136446466;
    v27 = "nw_activity_get_activation_time";
    v28 = 2082;
    v29 = "Cannot get activation time from lightweight representation of an activity";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v6, &type, &v24))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446466;
        v27 = "nw_activity_get_activation_time";
        v28 = 2082;
        v29 = "Cannot get activation time from lightweight representation of an activity";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
      }

      goto LABEL_54;
    }

    if (v24 != 1)
    {
      v7 = __nwlog_obj();
      v23 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446466;
        v27 = "nw_activity_get_activation_time";
        v28 = 2082;
        v29 = "Cannot get activation time from lightweight representation of an activity";
        _os_log_impl(&dword_181A37000, v7, v23, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
      }

      goto LABEL_54;
    }

    v16 = __nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v19 = type;
    v20 = os_log_type_enabled(v7, type);
    if (!v16)
    {
      if (v20)
      {
        *buf = 136446466;
        v27 = "nw_activity_get_activation_time";
        v28 = 2082;
        v29 = "Cannot get activation time from lightweight representation of an activity";
        _os_log_impl(&dword_181A37000, v7, v19, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *buf = 136446722;
      v27 = "nw_activity_get_activation_time";
      v28 = 2082;
      v29 = "Cannot get activation time from lightweight representation of an activity";
      v30 = 2082;
      v31 = v16;
      _os_log_impl(&dword_181A37000, v7, v19, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
    }

LABEL_35:

    free(v16);
    if (!v6)
    {
      goto LABEL_57;
    }

    goto LABEL_56;
  }

  v2 = *(v1 + 4);
LABEL_5:

  return v2;
}

uint64_t nw_activity_get_underlying_error_code(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v6 = __nwlog_obj();
    *buf = 136446210;
    v17 = "nw_activity_get_underlying_error_code";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v7, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v8 = __nwlog_obj();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *buf = 136446210;
          v17 = "nw_activity_get_underlying_error_code";
          _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null activity", buf, 0xCu);
        }
      }

      else if (v14 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v8 = __nwlog_obj();
        v11 = type;
        v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *buf = 136446466;
            v17 = "nw_activity_get_underlying_error_code";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }

        if (v12)
        {
          *buf = 136446210;
          v17 = "nw_activity_get_underlying_error_code";
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v8 = __nwlog_obj();
        v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *buf = 136446210;
          v17 = "nw_activity_get_underlying_error_code";
          _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_27:
    if (v7)
    {
      free(v7);
    }

    goto LABEL_8;
  }

  if ((v1[35] & 8) != 0)
  {
    v4 = v1[32];
    goto LABEL_10;
  }

  if (__nwlog_activity_log::onceToken != -1)
  {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_47419);
  }

  v3 = gactivityLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *buf = 138543362;
    v17 = v2;
    _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_DEBUG, "%{public}@ not complete, returning 0 for underlying error code", buf, 0xCu);
  }

LABEL_8:
  v4 = 0;
LABEL_10:

  return v4;
}

void nw_activity_complete_with_reason_and_underlying_error_string(void *a1, uint32_t a2, uint64_t a3, int a4)
{
  v31 = *MEMORY[0x1E69E9840];
  v7 = a1;
  v8 = v7;
  if (!v7)
  {
    v9 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_activity_complete_with_reason_and_underlying_error_string";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v26 = "nw_activity_complete_with_reason_and_underlying_error_string";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null activity", buf, 0xCu);
      }
    }

    else if (v23 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *buf = 136446466;
          v26 = "nw_activity_complete_with_reason_and_underlying_error_string";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v10)
        {
          goto LABEL_4;
        }

LABEL_39:
        free(v10);
        goto LABEL_4;
      }

      if (v17)
      {
        *buf = 136446210;
        v26 = "nw_activity_complete_with_reason_and_underlying_error_string";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v26 = "nw_activity_complete_with_reason_and_underlying_error_string";
        _os_log_impl(&dword_181A37000, v11, v21, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_37:

    goto LABEL_38;
  }

  if (a3)
  {
    nw_activity_complete_with_reason_and_underlying_error_string_internal(v7, a2, a3, 0, a4);
    goto LABEL_4;
  }

  v13 = __nwlog_obj();
  *buf = 136446466;
  v26 = "nw_activity_complete_with_reason_and_underlying_error_string";
  v27 = 2082;
  v28 = "underlying_error_domain_string must not be null";
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v10, &type, &v23))
  {
    goto LABEL_38;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v11 = __nwlog_obj();
    v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *buf = 136446466;
      v26 = "nw_activity_complete_with_reason_and_underlying_error_string";
      v27 = 2082;
      v28 = "underlying_error_domain_string must not be null";
      _os_log_impl(&dword_181A37000, v11, v14, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
    }

    goto LABEL_37;
  }

  if (v23 != 1)
  {
    v11 = __nwlog_obj();
    v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *buf = 136446466;
      v26 = "nw_activity_complete_with_reason_and_underlying_error_string";
      v27 = 2082;
      v28 = "underlying_error_domain_string must not be null";
      _os_log_impl(&dword_181A37000, v11, v22, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
    }

    goto LABEL_37;
  }

  v18 = __nw_create_backtrace_string();
  v11 = __nwlog_obj();
  v19 = type;
  v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *buf = 136446466;
      v26 = "nw_activity_complete_with_reason_and_underlying_error_string";
      v27 = 2082;
      v28 = "underlying_error_domain_string must not be null";
      _os_log_impl(&dword_181A37000, v11, v19, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
    }

    goto LABEL_37;
  }

  if (v20)
  {
    *buf = 136446722;
    v26 = "nw_activity_complete_with_reason_and_underlying_error_string";
    v27 = 2082;
    v28 = "underlying_error_domain_string must not be null";
    v29 = 2082;
    v30 = v18;
    _os_log_impl(&dword_181A37000, v11, v19, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v18);
  if (v10)
  {
    goto LABEL_39;
  }

LABEL_4:
}

uint64_t __nw_activity_submit_metrics_block_invoke_87(uint64_t result)
{
  v14 = *MEMORY[0x1E69E9840];
  v1 = *(result + 32);
  v2 = *(v1 + 48) + 1;
  *(v1 + 48) = v2;
  if (v2 != v2 << 31 >> 31)
  {
    if (gLogDatapath == 1)
    {
      v3 = result;
      v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        v5 = *(*(v3 + 32) + 48);
        v6 = 136446978;
        v7 = "nw_activity_submit_metrics_block_invoke";
        v8 = 2082;
        v9 = "activity->fragments_quenched";
        v10 = 2048;
        v11 = 1;
        v12 = 2048;
        v13 = v5;
        _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", &v6, 0x2Au);
      }

      result = v3;
    }

    *(*(result + 32) + 48) = -1;
  }

  *(*(*(result + 40) + 8) + 24) = *(*(result + 32) + 48);
  return result;
}

void nw_activity_retrieve_metrics(void *a1, void *a2, void *a3)
{
  v70 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = v7;
  if (!v5)
  {
    v18 = __nwlog_obj();
    *buf = 136446210;
    v65 = "nw_activity_retrieve_metrics";
    v19 = _os_log_send_and_compose_impl();

    v63 = OS_LOG_TYPE_ERROR;
    v62 = 0;
    if (!__nwlog_fault(v19, &v63, &v62))
    {
      goto LABEL_93;
    }

    if (v63 == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = v63;
      if (os_log_type_enabled(v20, v63))
      {
        *buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_181A37000, v20, v21, "%{public}s called with null activity", buf, 0xCu);
      }
    }

    else if (v62 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v20 = __nwlog_obj();
      v27 = v63;
      v28 = os_log_type_enabled(v20, v63);
      if (backtrace_string)
      {
        if (v28)
        {
          *buf = 136446466;
          v65 = "nw_activity_retrieve_metrics";
          v66 = 2082;
          v67 = backtrace_string;
          _os_log_impl(&dword_181A37000, v20, v27, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_93:
        if (!v19)
        {
          goto LABEL_22;
        }

LABEL_94:
        free(v19);
        goto LABEL_22;
      }

      if (v28)
      {
        *buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_181A37000, v20, v27, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v20 = __nwlog_obj();
      v38 = v63;
      if (os_log_type_enabled(v20, v63))
      {
        *buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_181A37000, v20, v38, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_92:

    goto LABEL_93;
  }

  if (!v6)
  {
    v22 = __nwlog_obj();
    *buf = 136446210;
    v65 = "nw_activity_retrieve_metrics";
    v19 = _os_log_send_and_compose_impl();

    v63 = OS_LOG_TYPE_ERROR;
    v62 = 0;
    if (!__nwlog_fault(v19, &v63, &v62))
    {
      goto LABEL_93;
    }

    if (v63 == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v23 = v63;
      if (os_log_type_enabled(v20, v63))
      {
        *buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_181A37000, v20, v23, "%{public}s called with null callback_queue", buf, 0xCu);
      }

      goto LABEL_92;
    }

    if (v62 != 1)
    {
      v20 = __nwlog_obj();
      v39 = v63;
      if (os_log_type_enabled(v20, v63))
      {
        *buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_181A37000, v20, v39, "%{public}s called with null callback_queue, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_92;
    }

    v29 = __nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v30 = v63;
    v31 = os_log_type_enabled(v20, v63);
    if (!v29)
    {
      if (v31)
      {
        *buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_181A37000, v20, v30, "%{public}s called with null callback_queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_92;
    }

    if (v31)
    {
      *buf = 136446466;
      v65 = "nw_activity_retrieve_metrics";
      v66 = 2082;
      v67 = v29;
      _os_log_impl(&dword_181A37000, v20, v30, "%{public}s called with null callback_queue, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_52;
  }

  if (!v7)
  {
    v24 = __nwlog_obj();
    *buf = 136446210;
    v65 = "nw_activity_retrieve_metrics";
    v19 = _os_log_send_and_compose_impl();

    v63 = OS_LOG_TYPE_ERROR;
    v62 = 0;
    if (!__nwlog_fault(v19, &v63, &v62))
    {
      goto LABEL_93;
    }

    if (v63 == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v25 = v63;
      if (os_log_type_enabled(v20, v63))
      {
        *buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_181A37000, v20, v25, "%{public}s called with null completion", buf, 0xCu);
      }

      goto LABEL_92;
    }

    if (v62 != 1)
    {
      v20 = __nwlog_obj();
      v40 = v63;
      if (os_log_type_enabled(v20, v63))
      {
        *buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_181A37000, v20, v40, "%{public}s called with null completion, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_92;
    }

    v29 = __nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v32 = v63;
    v33 = os_log_type_enabled(v20, v63);
    if (!v29)
    {
      if (v33)
      {
        *buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_181A37000, v20, v32, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }

      goto LABEL_92;
    }

    if (v33)
    {
      *buf = 136446466;
      v65 = "nw_activity_retrieve_metrics";
      v66 = 2082;
      v67 = v29;
      _os_log_impl(&dword_181A37000, v20, v32, "%{public}s called with null completion, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_52:

    free(v29);
    if (!v19)
    {
      goto LABEL_22;
    }

    goto LABEL_94;
  }

  if (__nwlog_activity_log::onceToken != -1)
  {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_47419);
  }

  v9 = gactivityLogObj;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    *buf = 138543362;
    v65 = v5;
    _os_log_impl(&dword_181A37000, v9, OS_LOG_TYPE_DEBUG, "%{public}@ retrieving metrics", buf, 0xCu);
  }

  v10 = qos_class_self();
  if ((v5[140] & 2) != 0)
  {
    if (__nwlog_activity_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_47419);
    }

    v15 = gactivityLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      *buf = 138543362;
      v65 = v5;
      _os_log_impl(&dword_181A37000, v15, OS_LOG_TYPE_INFO, "%{public}@ speculatively retrieving metrics", buf, 0xCu);
    }

    goto LABEL_21;
  }

  if ((v5[140] & 4) != 0)
  {
    if ((v5[140] & 8) == 0)
    {
      v11 = __nwlog_obj();
      *buf = 136446466;
      v65 = "nw_activity_retrieve_metrics";
      v66 = 2082;
      v67 = "Cannot retrieve metrics before completion";
      v12 = _os_log_send_and_compose_impl();

      v63 = OS_LOG_TYPE_ERROR;
      v62 = 0;
      if (__nwlog_fault(v12, &v63, &v62))
      {
        if (v63 == OS_LOG_TYPE_FAULT)
        {
          v13 = __nwlog_obj();
          v14 = v63;
          if (os_log_type_enabled(v13, v63))
          {
            *buf = 136446466;
            v65 = "nw_activity_retrieve_metrics";
            v66 = 2082;
            v67 = "Cannot retrieve metrics before completion";
            _os_log_impl(&dword_181A37000, v13, v14, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
          }
        }

        else if (v62 == 1)
        {
          v44 = __nw_create_backtrace_string();
          v13 = __nwlog_obj();
          v45 = v63;
          v46 = os_log_type_enabled(v13, v63);
          if (v44)
          {
            if (v46)
            {
              *buf = 136446722;
              v65 = "nw_activity_retrieve_metrics";
              v66 = 2082;
              v67 = "Cannot retrieve metrics before completion";
              v68 = 2082;
              v69 = v44;
              _os_log_impl(&dword_181A37000, v13, v45, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v44);
            goto LABEL_104;
          }

          if (v46)
          {
            *buf = 136446466;
            v65 = "nw_activity_retrieve_metrics";
            v66 = 2082;
            v67 = "Cannot retrieve metrics before completion";
            _os_log_impl(&dword_181A37000, v13, v45, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
          }
        }

        else
        {
          v13 = __nwlog_obj();
          v48 = v63;
          if (os_log_type_enabled(v13, v63))
          {
            *buf = 136446466;
            v65 = "nw_activity_retrieve_metrics";
            v66 = 2082;
            v67 = "Cannot retrieve metrics before completion";
            _os_log_impl(&dword_181A37000, v13, v48, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
        }
      }

LABEL_104:
      if (v12)
      {
        free(v12);
      }

      v58[0] = MEMORY[0x1E69E9820];
      v58[1] = 3221225472;
      v58[2] = __nw_activity_retrieve_metrics_block_invoke_92;
      v58[3] = &unk_1E6A3CE48;
      v59 = v8;
      v51 = v6;
      v52 = dispatch_block_create_with_qos_class(0, v10, 0, v58);
      dispatch_async(v51, v52);

      goto LABEL_22;
    }

LABEL_21:
    block[0] = MEMORY[0x1E69E9820];
    block[1] = 3221225472;
    block[2] = __nw_activity_retrieve_metrics_block_invoke_2;
    block[3] = &unk_1E6A36198;
    v16 = v6;
    v54 = v16;
    v57 = v10;
    v56 = v8;
    v55 = v5;
    v17 = dispatch_block_create_with_qos_class(0, v10, 0, block);
    dispatch_async(v16, v17);

    goto LABEL_22;
  }

  v34 = __nwlog_obj();
  *buf = 136446466;
  v65 = "nw_activity_retrieve_metrics";
  v66 = 2082;
  v67 = "Cannot retrieve metrics before activation";
  v35 = _os_log_send_and_compose_impl();

  v63 = OS_LOG_TYPE_ERROR;
  v62 = 0;
  if (__nwlog_fault(v35, &v63, &v62))
  {
    if (v63 == OS_LOG_TYPE_FAULT)
    {
      v36 = __nwlog_obj();
      v37 = v63;
      if (os_log_type_enabled(v36, v63))
      {
        *buf = 136446466;
        v65 = "nw_activity_retrieve_metrics";
        v66 = 2082;
        v67 = "Cannot retrieve metrics before activation";
        _os_log_impl(&dword_181A37000, v36, v37, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
      }
    }

    else if (v62 == 1)
    {
      v41 = __nw_create_backtrace_string();
      v36 = __nwlog_obj();
      v42 = v63;
      v43 = os_log_type_enabled(v36, v63);
      if (v41)
      {
        if (v43)
        {
          *buf = 136446722;
          v65 = "nw_activity_retrieve_metrics";
          v66 = 2082;
          v67 = "Cannot retrieve metrics before activation";
          v68 = 2082;
          v69 = v41;
          _os_log_impl(&dword_181A37000, v36, v42, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v41);
        goto LABEL_98;
      }

      if (v43)
      {
        *buf = 136446466;
        v65 = "nw_activity_retrieve_metrics";
        v66 = 2082;
        v67 = "Cannot retrieve metrics before activation";
        _os_log_impl(&dword_181A37000, v36, v42, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
      }
    }

    else
    {
      v36 = __nwlog_obj();
      v47 = v63;
      if (os_log_type_enabled(v36, v63))
      {
        *buf = 136446466;
        v65 = "nw_activity_retrieve_metrics";
        v66 = 2082;
        v67 = "Cannot retrieve metrics before activation";
        _os_log_impl(&dword_181A37000, v36, v47, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
      }
    }
  }

LABEL_98:
  if (v35)
  {
    free(v35);
  }

  v60[0] = MEMORY[0x1E69E9820];
  v60[1] = 3221225472;
  v60[2] = __nw_activity_retrieve_metrics_block_invoke;
  v60[3] = &unk_1E6A3CE48;
  v61 = v8;
  v49 = v6;
  v50 = dispatch_block_create_with_qos_class(0, v10, 0, v60);
  dispatch_async(v49, v50);

LABEL_22:
}

void __nw_activity_retrieve_metrics_block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [[NWConcrete_nw_error alloc] initWithDomain:22 code:?];
  (*(v1 + 16))(v1, 0);
}

void __nw_activity_retrieve_metrics_block_invoke_92(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [[NWConcrete_nw_error alloc] initWithDomain:22 code:?];
  (*(v1 + 16))(v1, 0);
}

void __nw_activity_retrieve_metrics_block_invoke_2(uint64_t a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v12 = 0;
  v13 = &v12;
  v14 = 0x3032000000;
  v15 = __Block_byref_object_copy__60613;
  v16 = __Block_byref_object_dispose__60614;
  v17 = 0;
  gotLoadHelper_x20__OBJC_CLASS___NWActivityXPC(COERCE_DOUBLE(0x3032000000));
  if (objc_opt_class())
  {
    v3 = [objc_alloc(*(v1 + 328)) initWithQueue:*(a1 + 32) qosClass:*(a1 + 56)];
    v4 = v13[5];
    v13[5] = v3;
  }

  if (v13[5])
  {
    v18 = 0uLL;
    nw_activity_get_token(*(a1 + 40), &v18);
    v5 = v13[5];
    v8[0] = MEMORY[0x1E69E9820];
    v8[1] = 3221225472;
    v8[2] = __nw_activity_retrieve_metrics_block_invoke_94;
    v8[3] = &unk_1E6A36170;
    v9 = *(a1 + 40);
    v10 = *(a1 + 48);
    v11 = &v12;
    [v5 retrieveMetricsForActivity:&v18 completion:v8];
  }

  else
  {
    v6 = *(a1 + 48);
    v7 = [[NWConcrete_nw_error alloc] initWithDomain:20 code:?];
    (*(v6 + 16))(v6, 0, v7, 1);
  }

  _Block_object_dispose(&v12, 8);
}

void sub_1828AC050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, id a21)
{
  _Block_object_dispose(&a16, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__60613(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

void __nw_activity_retrieve_metrics_block_invoke_94(void *a1, void *a2, int a3)
{
  v27 = *MEMORY[0x1E69E9840];
  v5 = a2;
  v6 = v5;
  if (v5 && !a3 && [v5 count])
  {
    if (__nwlog_activity_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_47419);
    }

    v7 = gactivityLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      v8 = a1[4];
      v21 = 138412546;
      v22 = v8;
      v23 = 2112;
      v24 = v6;
      _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_DEBUG, "%@ got results: %@", &v21, 0x16u);
    }

    for (i = 0; i < [v6 count]; ++i)
    {
      [v6 count];
      v10 = [v6 objectAtIndex:i];
      v11 = _CFXPCCreateXPCObjectFromCFObject();
      (*(a1[5] + 16))();
    }

    v18 = a1[6];
    v16 = a1 + 6;
    [*(*(v18 + 8) + 40) cancel];
  }

  else
  {
    if (__nwlog_activity_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_47419);
    }

    v12 = gactivityLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      v13 = a1[4];
      v21 = 138412802;
      v22 = v13;
      v23 = 2112;
      v24 = v6;
      v25 = 1024;
      v26 = a3;
      _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_DEBUG, "%@ failed lookup, results: %@, error: %{errno}d", &v21, 0x1Cu);
    }

    v14 = a1[5];
    posix_error = nw_error_create_posix_error(a3);
    (*(v14 + 16))(v14, 0, posix_error, 1);

    v17 = a1[6];
    v16 = a1 + 6;
    [*(*(v17 + 8) + 40) cancel];
  }

  v19 = *(*v16 + 8);
  v20 = *(v19 + 40);
  *(v19 + 40) = 0;
}

uint64_t nw_activity_is_complete(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = (v1[140] >> 3) & 1;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_activity_is_complete";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_activity_is_complete";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null activity", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_activity_is_complete";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_activity_is_complete";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_activity_is_complete";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
  v1 = 0;
LABEL_3:

  return v2;
}

const char *nw_activity_label_to_string(int a1, int a2)
{
  switch(a1)
  {
    case 11:
      if ((a2 - 1) >= 9)
      {
        goto LABEL_105;
      }

      return off_1E6A378F0[a2 - 1];
    case 12:
      if ((a2 - 1) >= 4)
      {
        goto LABEL_105;
      }

      return off_1E6A37938[a2 - 1];
    case 13:
      if ((a2 - 1) >= 3)
      {
        goto LABEL_105;
      }

      return off_1E6A37958[a2 - 1];
    case 14:
      if ((a2 - 1) >= 0xD)
      {
        goto LABEL_105;
      }

      return off_1E6A37970[a2 - 1];
    case 15:
      if ((a2 - 1) >= 0xA)
      {
        goto LABEL_105;
      }

      return off_1E6A379D8[a2 - 1];
    case 16:
      if ((a2 - 1) >= 3)
      {
        goto LABEL_105;
      }

      return off_1E6A37A28[a2 - 1];
    case 17:
      if ((a2 - 1) >= 5)
      {
        goto LABEL_105;
      }

      return off_1E6A37A40[a2 - 1];
    case 18:
      if ((a2 - 1) >= 0x12)
      {
        goto LABEL_105;
      }

      return off_1E6A37A68[a2 - 1];
    case 19:
    case 20:
    case 56:
      if (a2 == 1)
      {
        return "invalid_max";
      }

      else
      {
        return "invalid";
      }

    case 21:
      if ((a2 - 1) >= 0x18)
      {
        goto LABEL_105;
      }

      return off_1E6A37AF8[a2 - 1];
    case 22:
      if ((a2 - 1) >= 7)
      {
        goto LABEL_105;
      }

      return off_1E6A37BB8[a2 - 1];
    case 23:
      if ((a2 - 1) >= 0x19)
      {
        goto LABEL_105;
      }

      return off_1E6A37BF0[a2 - 1];
    case 24:
      if ((a2 - 1) >= 3)
      {
        goto LABEL_105;
      }

      return off_1E6A37CB8[a2 - 1];
    case 25:
    case 26:
      if ((a2 - 1) >= 3)
      {
        goto LABEL_105;
      }

      return off_1E6A37CD0[a2 - 1];
    case 27:
    case 28:
    case 29:
      if ((a2 - 1) >= 0x43)
      {
        goto LABEL_105;
      }

      return off_1E6A37CE8[a2 - 1];
    case 30:
      if ((a2 - 1) >= 5)
      {
        goto LABEL_105;
      }

      return off_1E6A37F00[a2 - 1];
    case 31:
      v3 = "invalid";
      v4 = "captive_probe";
      goto LABEL_86;
    case 32:
      if ((a2 - 1) >= 0xD)
      {
        goto LABEL_105;
      }

      return off_1E6A37F28[a2 - 1];
    case 33:
      if ((a2 - 1) >= 4)
      {
        goto LABEL_105;
      }

      return off_1E6A37F90[a2 - 1];
    case 34:
      if ((a2 - 1) >= 0xC)
      {
        goto LABEL_105;
      }

      return off_1E6A37FB0[a2 - 1];
    case 35:
      if ((a2 - 1) >= 3)
      {
        goto LABEL_105;
      }

      return off_1E6A38010[a2 - 1];
    case 36:
      if ((a2 - 1) >= 0xB)
      {
        goto LABEL_105;
      }

      return off_1E6A38028[a2 - 1];
    case 37:
      if ((a2 - 1) >= 0xE)
      {
        goto LABEL_105;
      }

      return off_1E6A38080[a2 - 1];
    case 38:
      if ((a2 - 1) >= 4)
      {
        goto LABEL_105;
      }

      return off_1E6A380F0[a2 - 1];
    case 39:
      v3 = "invalid";
      v4 = "session";
      goto LABEL_86;
    case 40:
      if ((a2 - 1) >= 8)
      {
        goto LABEL_105;
      }

      return off_1E6A38110[a2 - 1];
    case 41:
      if ((a2 - 1) >= 7)
      {
        goto LABEL_105;
      }

      return off_1E6A38150[a2 - 1];
    case 42:
      if ((a2 - 1) >= 4)
      {
        goto LABEL_105;
      }

      return off_1E6A38188[a2 - 1];
    case 43:
      if ((a2 - 1) >= 0x11)
      {
        goto LABEL_105;
      }

      return off_1E6A381A8[a2 - 1];
    case 44:
      if ((a2 - 1) >= 8)
      {
        goto LABEL_105;
      }

      return off_1E6A38230[a2 - 1];
    case 45:
      if ((a2 - 1) >= 0xA)
      {
        goto LABEL_105;
      }

      return off_1E6A38270[a2 - 1];
    case 46:
      v3 = "invalid";
      v4 = "stereo_pair_volume_sync";
LABEL_86:
      if (a2 == 1)
      {
        v3 = v4;
      }

      if (a2 == 2)
      {
        return "invalid_max";
      }

      else
      {
        return v3;
      }

    case 47:
      if ((a2 - 1) >= 0xE)
      {
        goto LABEL_105;
      }

      result = off_1E6A382C0[a2 - 1];
      break;
    case 48:
      if ((a2 - 1) >= 4)
      {
        goto LABEL_105;
      }

      result = off_1E6A38330[a2 - 1];
      break;
    case 49:
      if ((a2 - 1) >= 0xB)
      {
        goto LABEL_105;
      }

      result = off_1E6A38350[a2 - 1];
      break;
    case 50:
      if ((a2 - 1) >= 3)
      {
        goto LABEL_105;
      }

      result = off_1E6A383A8[a2 - 1];
      break;
    case 51:
      if ((a2 - 1) >= 0xC)
      {
        goto LABEL_105;
      }

      result = off_1E6A383C0[a2 - 1];
      break;
    case 52:
      if ((a2 - 1) >= 8)
      {
        goto LABEL_105;
      }

      result = off_1E6A38420[a2 - 1];
      break;
    case 53:
      if ((a2 - 1) >= 6)
      {
        goto LABEL_105;
      }

      result = off_1E6A38460[a2 - 1];
      break;
    case 54:
      if ((a2 - 1) >= 5)
      {
        goto LABEL_105;
      }

      result = off_1E6A38490[a2 - 1];
      break;
    case 55:
      if ((a2 - 1) >= 5)
      {
        goto LABEL_105;
      }

      result = off_1E6A384B8[a2 - 1];
      break;
    case 57:
      if ((a2 - 1) >= 3)
      {
        goto LABEL_105;
      }

      result = off_1E6A384E0[a2 - 1];
      break;
    case 58:
      if ((a2 - 1) >= 0x18)
      {
        goto LABEL_105;
      }

      result = off_1E6A384F8[a2 - 1];
      break;
    case 59:
      if ((a2 - 1) >= 8)
      {
        goto LABEL_105;
      }

      result = off_1E6A385B8[a2 - 1];
      break;
    case 60:
      if ((a2 - 1) >= 0xC)
      {
        goto LABEL_105;
      }

      result = off_1E6A385F8[a2 - 1];
      break;
    case 61:
      if ((a2 - 1) >= 4)
      {
        goto LABEL_105;
      }

      result = off_1E6A38658[a2 - 1];
      break;
    case 62:
      if ((a2 - 1) >= 4)
      {
LABEL_105:
        result = "invalid";
      }

      else
      {
        result = off_1E6A38678[a2 - 1];
      }

      break;
    default:
      if ((a1 - 1) >= 0xA)
      {
        v5 = "invalid";
      }

      else
      {
        v5 = "reserved";
      }

      if ((a1 - 900) >= 0x64)
      {
        result = v5;
      }

      else
      {
        result = "experimental";
      }

      break;
  }

  return result;
}

uint64_t nw_activity_copy_redacted_description(void *a1)
{
  v32 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v10 = __nwlog_obj();
    *buf = 136446210;
    v27 = "nw_activity_copy_redacted_description";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v11, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v27 = "nw_activity_copy_redacted_description";
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s called with null activity", buf, 0xCu);
        }
      }

      else if (v24 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v12 = __nwlog_obj();
        v19 = type;
        v20 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *buf = 136446466;
            v27 = "nw_activity_copy_redacted_description";
            v28 = 2082;
            v29 = backtrace_string;
            _os_log_impl(&dword_181A37000, v12, v19, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }

        if (v20)
        {
          *buf = 136446210;
          v27 = "nw_activity_copy_redacted_description";
          _os_log_impl(&dword_181A37000, v12, v19, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v12 = __nwlog_obj();
        v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v27 = "nw_activity_copy_redacted_description";
          _os_log_impl(&dword_181A37000, v12, v21, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_29:
    if (v11)
    {
      free(v11);
    }

    v6 = 0;
    goto LABEL_8;
  }

  v3 = [v1 redactedDescription];
  v4 = [v3 length];
  if (!v4)
  {
    v14 = __nwlog_obj();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v27 = "nw_activity_copy_redacted_description";
    LODWORD(v23) = 12;
    v22 = buf;
    v15 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v15);
    if (result)
    {
      goto LABEL_32;
    }

    free(v15);
  }

  v5 = [v3 UTF8String];
  if (v4 == -1)
  {
    v16 = __nwlog_obj();
    os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v27 = "nw_activity_copy_redacted_description";
    v17 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v17);
    if (result)
    {
      goto LABEL_32;
    }

    free(v17);
  }

  v6 = malloc_type_calloc(1uLL, v4 + 1, 0x669F00F1uLL);
  if (v6)
  {
LABEL_7:
    memcpy(v6, v5, v4);

LABEL_8:
    return v6;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = gLogObj;
  os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v27 = "nw_activity_copy_redacted_description";
  v28 = 2048;
  v29 = 1;
  v30 = 2048;
  v31 = v4 + 1;
  v8 = _os_log_send_and_compose_impl();

  result = __nwlog_should_abort(v8);
  if (!result)
  {
    free(v8);
    goto LABEL_7;
  }

LABEL_32:
  __break(1u);
  return result;
}

uint64_t nw_path_is_endpoint_localhost(void *a1)
{
  v30 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    goto LABEL_38;
  }

  v3 = v1;
  v4 = _nw_endpoint_get_type(v3);

  if (v4 != 1)
  {
    if (v4 == 2)
    {
      v5 = v3;
      hostname = _nw_endpoint_get_hostname();

      if (!strcasecmp("localhost", hostname))
      {
        v8 = 1;
        goto LABEL_39;
      }

      v7 = strcasecmp("localhost.", hostname) == 0;
      goto LABEL_16;
    }

LABEL_38:
    v8 = 0;
    goto LABEL_39;
  }

  v22 = 0;
  v23 = 0;
  v25 = 0;
  v24 = 0;
  if ((nw_endpoint_fillout_v4v6_address(v3, &v22) & 1) == 0)
  {
    v11 = __nwlog_obj();
    *buf = 136446210;
    v27 = "nw_path_is_endpoint_localhost";
    v12 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v12, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v13 = __nwlog_obj();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *buf = 136446210;
          v27 = "nw_path_is_endpoint_localhost";
          _os_log_impl(&dword_181A37000, v13, v14, "%{public}s called with null filled_out", buf, 0xCu);
        }
      }

      else if (v20 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v13 = __nwlog_obj();
        v16 = type;
        v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *buf = 136446466;
            v27 = "nw_path_is_endpoint_localhost";
            v28 = 2082;
            v29 = backtrace_string;
            _os_log_impl(&dword_181A37000, v13, v16, "%{public}s called with null filled_out, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_36;
        }

        if (v17)
        {
          *buf = 136446210;
          v27 = "nw_path_is_endpoint_localhost";
          _os_log_impl(&dword_181A37000, v13, v16, "%{public}s called with null filled_out, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v13 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *buf = 136446210;
          v27 = "nw_path_is_endpoint_localhost";
          _os_log_impl(&dword_181A37000, v13, v18, "%{public}s called with null filled_out, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_36:
    if (v12)
    {
      free(v12);
    }

    goto LABEL_38;
  }

  if (BYTE1(v22) != 30 || v22 < 0x1Cu)
  {
    if (BYTE1(v22) != 2 || v22 < 0x10u)
    {
      goto LABEL_38;
    }

    v9 = HIDWORD(v22);
    v10 = 16777343;
LABEL_15:
    v7 = v9 == v10;
LABEL_16:
    v8 = v7;
    goto LABEL_39;
  }

  v8 = 0;
  if (!v23 && __PAIR64__(HIDWORD(v23), 0) == v24)
  {
    v9 = HIDWORD(v24);
    v10 = 0x1000000;
    goto LABEL_15;
  }

LABEL_39:

  return v8;
}

uint64_t __Block_byref_object_copy__61007(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

uint64_t nw_path_struct_size_for_advertise_descriptor(void *a1, unint64_t *a2)
{
  v3 = a1;
  type = nw_advertise_descriptor_get_type(v3);
  if (type != 2)
  {
    if (type != 1)
    {
      v16 = 28;
      goto LABEL_22;
    }

    bonjour_name = nw_advertise_descriptor_get_bonjour_name(v3);
    bonjour_type = nw_advertise_descriptor_get_bonjour_type(v3);
    bonjour_domain = nw_advertise_descriptor_get_bonjour_domain(v3);
    if (bonjour_name)
    {
      v8 = strlen(bonjour_name) + 9;
      if (bonjour_type)
      {
        goto LABEL_5;
      }
    }

    else
    {
      v8 = 9;
      if (bonjour_type)
      {
LABEL_5:
        v9 = strlen(bonjour_type) + 1;
        if (bonjour_domain)
        {
LABEL_6:
          v10 = strlen(bonjour_domain) + 1;
          goto LABEL_15;
        }

LABEL_14:
        v10 = 1;
LABEL_15:
        v20 = 0;
        txt_record = nw_advertise_descriptor_get_txt_record(v3, &v20);
        v18 = v20;
        if (!txt_record)
        {
          v18 = 0;
        }

        v15 = v9 + v8 + v10 + v18;
        if (!a2)
        {
          goto LABEL_19;
        }

        goto LABEL_18;
      }
    }

    v9 = 1;
    if (bonjour_domain)
    {
      goto LABEL_6;
    }

    goto LABEL_14;
  }

  application_service_name = nw_advertise_descriptor_get_application_service_name(v3);
  bundle_id = nw_advertise_descriptor_get_bundle_id(v3);
  v13 = bundle_id;
  if (application_service_name)
  {
    v14 = strlen(application_service_name) + 17;
    if (v13)
    {
      goto LABEL_9;
    }
  }

  else
  {
    v14 = 17;
    if (bundle_id)
    {
LABEL_9:
      v15 = v14 + strlen(v13) + 1;
      if (!a2)
      {
        goto LABEL_19;
      }

LABEL_18:
      *a2 = v15;
      goto LABEL_19;
    }
  }

  v15 = v14 + 1;
  if (a2)
  {
    goto LABEL_18;
  }

LABEL_19:
  if (v15 <= 0x1C)
  {
    v16 = 28;
  }

  else
  {
    v16 = v15;
  }

LABEL_22:

  return v16;
}

uint64_t __nw_path_create_necp_parameters_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  v62 = *MEMORY[0x1E69E9840];
  v4 = a3;
  length = xpc_data_get_length(v4);
  bytes_ptr = xpc_data_get_bytes_ptr(v4);
  v7 = *(*(*(a1 + 32) + 8) + 24);
  if (!v7)
  {
    v20 = v4;
    v21 = __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_necp_append_tlv";
    v22 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v22, &type, &v51))
    {
      goto LABEL_86;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v54 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A37000, v23, v24, "%{public}s called with null tlv_start", buf, 0xCu);
      }
    }

    else if (v51 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v32 = type;
      v33 = os_log_type_enabled(v23, type);
      if (backtrace_string)
      {
        if (v33)
        {
          *buf = 136446466;
          v54 = "nw_necp_append_tlv";
          v55 = 2082;
          *v56 = backtrace_string;
          _os_log_impl(&dword_181A37000, v23, v32, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_86:
        if (!v22)
        {
LABEL_88:
          v14 = 0;
          v4 = v20;
          goto LABEL_29;
        }

LABEL_87:
        free(v22);
        goto LABEL_88;
      }

      if (v33)
      {
        *buf = 136446210;
        v54 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A37000, v23, v32, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v23 = __nwlog_obj();
      v44 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v54 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A37000, v23, v44, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_85:

    goto LABEL_86;
  }

  v8 = *(a1 + 40);
  if (!v8)
  {
    v20 = v4;
    v25 = __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_necp_append_tlv";
    v22 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v22, &type, &v51))
    {
      goto LABEL_86;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v54 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A37000, v23, v26, "%{public}s called with null beyond", buf, 0xCu);
      }
    }

    else if (v51 == 1)
    {
      v34 = __nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v35 = type;
      v36 = os_log_type_enabled(v23, type);
      if (v34)
      {
        if (v36)
        {
          *buf = 136446466;
          v54 = "nw_necp_append_tlv";
          v55 = 2082;
          *v56 = v34;
          _os_log_impl(&dword_181A37000, v23, v35, "%{public}s called with null beyond, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v34);
        if (!v22)
        {
          goto LABEL_88;
        }

        goto LABEL_87;
      }

      if (v36)
      {
        *buf = 136446210;
        v54 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A37000, v23, v35, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v23 = __nwlog_obj();
      v45 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v54 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A37000, v23, v45, "%{public}s called with null beyond, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_85;
  }

  if (v7 < v8)
  {
    v9 = length + 5;
    if (v8 - v7 < v9)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      *buf = 136447490;
      v54 = "nw_necp_append_tlv";
      v55 = 2048;
      *v56 = v7;
      *&v56[8] = 2048;
      *v57 = length + 5;
      *&v57[8] = 2048;
      *v58 = v8;
      *&v58[8] = 1024;
      *v59 = 222;
      *&v59[4] = 1024;
      *&v59[6] = length;
      v11 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v51 = 0;
      if (__nwlog_fault(v11, &type, &v51))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = gLogObj;
          v13 = type;
          if (os_log_type_enabled(v12, type))
          {
            *buf = 136447490;
            v54 = "nw_necp_append_tlv";
            v55 = 2048;
            *v56 = v7;
            *&v56[8] = 2048;
            *v57 = length + 5;
            *&v57[8] = 2048;
            *v58 = v8;
            *&v58[8] = 1024;
            *v59 = 222;
            *&v59[4] = 1024;
            *&v59[6] = length;
            _os_log_impl(&dword_181A37000, v12, v13, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
          }
        }

        else if (v51 == 1)
        {
          v15 = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = gLogObj;
          v16 = type;
          v17 = os_log_type_enabled(v12, type);
          if (v15)
          {
            if (v17)
            {
              *buf = 136447746;
              v54 = "nw_necp_append_tlv";
              v55 = 2048;
              *v56 = v7;
              *&v56[8] = 2048;
              *v57 = length + 5;
              *&v57[8] = 2048;
              *v58 = v8;
              *&v58[8] = 1024;
              *v59 = 222;
              *&v59[4] = 1024;
              *&v59[6] = length;
              v60 = 2082;
              v61 = v15;
              _os_log_impl(&dword_181A37000, v12, v16, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
            }

            free(v15);
            if (!v11)
            {
              goto LABEL_28;
            }

            goto LABEL_27;
          }

          if (v17)
          {
            *buf = 136447490;
            v54 = "nw_necp_append_tlv";
            v55 = 2048;
            *v56 = v7;
            *&v56[8] = 2048;
            *v57 = length + 5;
            *&v57[8] = 2048;
            *v58 = v8;
            *&v58[8] = 1024;
            *v59 = 222;
            *&v59[4] = 1024;
            *&v59[6] = length;
            _os_log_impl(&dword_181A37000, v12, v16, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = gLogObj;
          v18 = type;
          if (os_log_type_enabled(v12, type))
          {
            *buf = 136447490;
            v54 = "nw_necp_append_tlv";
            v55 = 2048;
            *v56 = v7;
            *&v56[8] = 2048;
            *v57 = length + 5;
            *&v57[8] = 2048;
            *v58 = v8;
            *&v58[8] = 1024;
            *v59 = 222;
            *&v59[4] = 1024;
            *&v59[6] = length;
            _os_log_impl(&dword_181A37000, v12, v18, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
          }
        }
      }

      if (!v11)
      {
LABEL_28:
        v14 = 0;
        goto LABEL_29;
      }

LABEL_27:
      free(v11);
      goto LABEL_28;
    }

    *v7 = -34;
    *(v7 + 1) = length;
    if (!length)
    {
      goto LABEL_13;
    }

    if (bytes_ptr)
    {
      memcpy((v7 + 5), bytes_ptr, length);
LABEL_13:
      v14 = v7 + v9;
      goto LABEL_29;
    }

    v40 = __nwlog_obj();
    *buf = 136446722;
    v54 = "nw_necp_append_tlv";
    v55 = 1024;
    *v56 = 222;
    *&v56[4] = 1024;
    *&v56[6] = length;
    v41 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v41, &type, &v51))
    {
      goto LABEL_101;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v42 = __nwlog_obj();
      v43 = type;
      if (os_log_type_enabled(v42, type))
      {
        *buf = 136446722;
        v54 = "nw_necp_append_tlv";
        v55 = 1024;
        *v56 = 222;
        *&v56[4] = 1024;
        *&v56[6] = length;
        _os_log_impl(&dword_181A37000, v42, v43, "%{public}s type=%u length=%u but value is NULL", buf, 0x18u);
      }
    }

    else if (v51 == 1)
    {
      v47 = __nw_create_backtrace_string();
      v42 = __nwlog_obj();
      v48 = type;
      v49 = os_log_type_enabled(v42, type);
      if (v47)
      {
        if (v49)
        {
          *buf = 136446978;
          v54 = "nw_necp_append_tlv";
          v55 = 1024;
          *v56 = 222;
          *&v56[4] = 1024;
          *&v56[6] = length;
          *v57 = 2082;
          *&v57[2] = v47;
          _os_log_impl(&dword_181A37000, v42, v48, "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s", buf, 0x22u);
        }

        free(v47);
        goto LABEL_101;
      }

      if (v49)
      {
        *buf = 136446722;
        v54 = "nw_necp_append_tlv";
        v55 = 1024;
        *v56 = 222;
        *&v56[4] = 1024;
        *&v56[6] = length;
        _os_log_impl(&dword_181A37000, v42, v48, "%{public}s type=%u length=%u but value is NULL, no backtrace", buf, 0x18u);
      }
    }

    else
    {
      v42 = __nwlog_obj();
      v50 = type;
      if (os_log_type_enabled(v42, type))
      {
        *buf = 136446722;
        v54 = "nw_necp_append_tlv";
        v55 = 1024;
        *v56 = 222;
        *&v56[4] = 1024;
        *&v56[6] = length;
        _os_log_impl(&dword_181A37000, v42, v50, "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded", buf, 0x18u);
      }
    }

LABEL_101:
    if (v41)
    {
      free(v41);
    }

    v14 = 0;
    goto LABEL_29;
  }

  v27 = __nwlog_obj();
  *buf = 136447234;
  v54 = "nw_necp_append_tlv";
  v55 = 2048;
  *v56 = v7;
  *&v56[8] = 2048;
  *v57 = v8;
  *&v57[8] = 1024;
  *v58 = 222;
  *&v58[4] = 1024;
  *&v58[6] = length;
  v28 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v51 = 0;
  if (__nwlog_fault(v28, &type, &v51))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v29 = __nwlog_obj();
      v30 = type;
      if (os_log_type_enabled(v29, type))
      {
        *buf = 136447234;
        v54 = "nw_necp_append_tlv";
        v55 = 2048;
        *v56 = v7;
        *&v56[8] = 2048;
        *v57 = v8;
        *&v57[8] = 1024;
        *v58 = 222;
        *&v58[4] = 1024;
        *&v58[6] = length;
        _os_log_impl(&dword_181A37000, v29, v30, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
      }
    }

    else if (v51 == 1)
    {
      v37 = __nw_create_backtrace_string();
      v29 = __nwlog_obj();
      v38 = type;
      v39 = os_log_type_enabled(v29, type);
      if (v37)
      {
        if (v39)
        {
          *buf = 136447490;
          v54 = "nw_necp_append_tlv";
          v55 = 2048;
          *v56 = v7;
          *&v56[8] = 2048;
          *v57 = v8;
          *&v57[8] = 1024;
          *v58 = 222;
          *&v58[4] = 1024;
          *&v58[6] = length;
          *v59 = 2082;
          *&v59[2] = v37;
          _os_log_impl(&dword_181A37000, v29, v38, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
        }

        free(v37);
        goto LABEL_92;
      }

      if (v39)
      {
        *buf = 136447234;
        v54 = "nw_necp_append_tlv";
        v55 = 2048;
        *v56 = v7;
        *&v56[8] = 2048;
        *v57 = v8;
        *&v57[8] = 1024;
        *v58 = 222;
        *&v58[4] = 1024;
        *&v58[6] = length;
        _os_log_impl(&dword_181A37000, v29, v38, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
      }
    }

    else
    {
      v29 = __nwlog_obj();
      v46 = type;
      if (os_log_type_enabled(v29, type))
      {
        *buf = 136447234;
        v54 = "nw_necp_append_tlv";
        v55 = 2048;
        *v56 = v7;
        *&v56[8] = 2048;
        *v57 = v8;
        *&v57[8] = 1024;
        *v58 = 222;
        *&v58[4] = 1024;
        *&v58[6] = length;
        _os_log_impl(&dword_181A37000, v29, v46, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
      }
    }
  }

LABEL_92:
  if (v28)
  {
    free(v28);
  }

  v14 = 0;
LABEL_29:
  *(*(*(a1 + 32) + 8) + 24) = v14;

  return 1;
}

uint64_t ___ZL55nw_path_evaluator_add_browse_descriptor_to_necp_messagePU34objcproto23OS_nw_browse_descriptor8NSObjecthPhPKh_block_invoke(uint64_t a1, char *__s)
{
  v4 = strlen(__s) + 1;
  memcpy((*(a1 + 40) + *(*(*(a1 + 32) + 8) + 24) + 8), __s, v4);
  *(*(*(a1 + 32) + 8) + 24) += v4;
  return 1;
}

uint64_t ___ZL55nw_path_evaluator_add_browse_descriptor_to_necp_messagePU34objcproto23OS_nw_browse_descriptor8NSObjecthPhPKh_block_invoke_32(uint64_t a1, int a2, uint64_t a3, void *__src, size_t a5)
{
  v5 = *(a1 + 40) - a3 - 8;
  v6 = v5 > a5;
  if (v5 >= a5)
  {
    v5 = a5;
  }

  v7 = !v6;
  memcpy((*(a1 + 32) + a3 + 8), __src, v5);
  return v7;
}

BOOL __nw_path_create_necp_parameters_block_invoke_15(uint64_t a1, size_t __n, __int16 a3, void *__src, const void *a5)
{
  v7 = __n;
  v56 = *MEMORY[0x1E69E9840];
  v43 = 0u;
  v44 = 0u;
  __dst = 0u;
  v42 = 0u;
  v9 = __n;
  memcpy(&v43, __src, __n);
  memcpy(&__dst, a5, v9);
  v10 = *(*(*(a1 + 32) + 8) + 24);
  if (!v10)
  {
    v27 = __nwlog_obj();
    *buf = 136446210;
    v46 = "nw_necp_append_tlv";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v13, &type, &v39))
    {
      goto LABEL_16;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v14, type))
      {
        goto LABEL_67;
      }

      *buf = 136446210;
      v46 = "nw_necp_append_tlv";
      v29 = "%{public}s called with null tlv_start";
LABEL_62:
      v36 = v14;
      v37 = v28;
      v38 = 12;
LABEL_66:
      _os_log_impl(&dword_181A37000, v36, v37, v29, buf, v38);
      goto LABEL_67;
    }

    if (v39 != 1)
    {
      v14 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v14, type))
      {
        goto LABEL_67;
      }

      *buf = 136446210;
      v46 = "nw_necp_append_tlv";
      v29 = "%{public}s called with null tlv_start, backtrace limit exceeded";
      goto LABEL_62;
    }

    backtrace_string = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v28 = type;
    v33 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v33)
      {
        goto LABEL_67;
      }

      *buf = 136446210;
      v46 = "nw_necp_append_tlv";
      v29 = "%{public}s called with null tlv_start, no backtrace";
      goto LABEL_62;
    }

    if (!v33)
    {
      goto LABEL_15;
    }

    *buf = 136446466;
    v46 = "nw_necp_append_tlv";
    v47 = 2082;
    v48 = backtrace_string;
    v22 = "%{public}s called with null tlv_start, dumping backtrace:%{public}s";
LABEL_47:
    v23 = v14;
    v24 = v28;
    v25 = 22;
LABEL_14:
    _os_log_impl(&dword_181A37000, v23, v24, v22, buf, v25);
LABEL_15:

    free(backtrace_string);
    goto LABEL_16;
  }

  v11 = *(a1 + 40);
  if (!v11)
  {
    v30 = __nwlog_obj();
    *buf = 136446210;
    v46 = "nw_necp_append_tlv";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v13, &type, &v39))
    {
      goto LABEL_16;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v14, type))
      {
        goto LABEL_67;
      }

      *buf = 136446210;
      v46 = "nw_necp_append_tlv";
      v29 = "%{public}s called with null beyond";
      goto LABEL_62;
    }

    if (v39 != 1)
    {
      v14 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v14, type))
      {
        goto LABEL_67;
      }

      *buf = 136446210;
      v46 = "nw_necp_append_tlv";
      v29 = "%{public}s called with null beyond, backtrace limit exceeded";
      goto LABEL_62;
    }

    backtrace_string = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v28 = type;
    v34 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v34)
      {
        goto LABEL_67;
      }

      *buf = 136446210;
      v46 = "nw_necp_append_tlv";
      v29 = "%{public}s called with null beyond, no backtrace";
      goto LABEL_62;
    }

    if (!v34)
    {
      goto LABEL_15;
    }

    *buf = 136446466;
    v46 = "nw_necp_append_tlv";
    v47 = 2082;
    v48 = backtrace_string;
    v22 = "%{public}s called with null beyond, dumping backtrace:%{public}s";
    goto LABEL_47;
  }

  if (v10 >= v11)
  {
    v31 = __nwlog_obj();
    *buf = 136447234;
    v46 = "nw_necp_append_tlv";
    v47 = 2048;
    v48 = v10;
    v49 = 2048;
    v50 = v11;
    v51 = 1024;
    *v52 = 251;
    *&v52[4] = 1024;
    *&v52[6] = 68;
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v13, &type, &v39))
    {
      goto LABEL_16;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v32 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136447234;
        v46 = "nw_necp_append_tlv";
        v47 = 2048;
        v48 = v10;
        v49 = 2048;
        v50 = v11;
        v51 = 1024;
        *v52 = 251;
        *&v52[4] = 1024;
        *&v52[6] = 68;
        v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u";
LABEL_65:
        v36 = v14;
        v37 = v32;
        v38 = 44;
        goto LABEL_66;
      }
    }

    else
    {
      if (v39 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v32 = type;
        v35 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (!v35)
          {
            goto LABEL_15;
          }

          *buf = 136447490;
          v46 = "nw_necp_append_tlv";
          v47 = 2048;
          v48 = v10;
          v49 = 2048;
          v50 = v11;
          v51 = 1024;
          *v52 = 251;
          *&v52[4] = 1024;
          *&v52[6] = 68;
          *v53 = 2082;
          *&v53[2] = backtrace_string;
          v22 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s";
          v23 = v14;
          v24 = v32;
          v25 = 54;
          goto LABEL_14;
        }

        if (!v35)
        {
          goto LABEL_67;
        }

        *buf = 136447234;
        v46 = "nw_necp_append_tlv";
        v47 = 2048;
        v48 = v10;
        v49 = 2048;
        v50 = v11;
        v51 = 1024;
        *v52 = 251;
        *&v52[4] = 1024;
        *&v52[6] = 68;
        v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace";
        goto LABEL_65;
      }

      v14 = __nwlog_obj();
      v32 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136447234;
        v46 = "nw_necp_append_tlv";
        v47 = 2048;
        v48 = v10;
        v49 = 2048;
        v50 = v11;
        v51 = 1024;
        *v52 = 251;
        *&v52[4] = 1024;
        *&v52[6] = 68;
        v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded";
        goto LABEL_65;
      }
    }

LABEL_67:

LABEL_16:
    if (!v13)
    {
LABEL_18:
      v19 = 0;
      goto LABEL_19;
    }

LABEL_17:
    free(v13);
    goto LABEL_18;
  }

  if (v11 - v10 <= 0x48)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    *buf = 136447490;
    v46 = "nw_necp_append_tlv";
    v47 = 2048;
    v48 = v10;
    v49 = 2048;
    v50 = 73;
    v51 = 2048;
    *v52 = v11;
    *&v52[8] = 1024;
    *v53 = 251;
    *&v53[4] = 1024;
    *&v53[6] = 68;
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v13, &type, &v39))
    {
      goto LABEL_16;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled(v14, type))
      {
        goto LABEL_25;
      }

      *buf = 136447490;
      v46 = "nw_necp_append_tlv";
      v47 = 2048;
      v48 = v10;
      v49 = 2048;
      v50 = 73;
      v51 = 2048;
      *v52 = v11;
      *&v52[8] = 1024;
      *v53 = 251;
      *&v53[4] = 1024;
      *&v53[6] = 68;
      v16 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
      goto LABEL_24;
    }

    if (v39 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled(v14, type))
      {
        goto LABEL_25;
      }

      *buf = 136447490;
      v46 = "nw_necp_append_tlv";
      v47 = 2048;
      v48 = v10;
      v49 = 2048;
      v50 = 73;
      v51 = 2048;
      *v52 = v11;
      *&v52[8] = 1024;
      *v53 = 251;
      *&v53[4] = 1024;
      *&v53[6] = 68;
      v16 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
      goto LABEL_24;
    }

    backtrace_string = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = gLogObj;
    v15 = type;
    v21 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v21)
      {
        goto LABEL_25;
      }

      *buf = 136447490;
      v46 = "nw_necp_append_tlv";
      v47 = 2048;
      v48 = v10;
      v49 = 2048;
      v50 = 73;
      v51 = 2048;
      *v52 = v11;
      *&v52[8] = 1024;
      *v53 = 251;
      *&v53[4] = 1024;
      *&v53[6] = 68;
      v16 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
LABEL_24:
      _os_log_impl(&dword_181A37000, v14, v15, v16, buf, 0x36u);
LABEL_25:

      if (!v13)
      {
        goto LABEL_18;
      }

      goto LABEL_17;
    }

    if (!v21)
    {
      goto LABEL_15;
    }

    *buf = 136447746;
    v46 = "nw_necp_append_tlv";
    v47 = 2048;
    v48 = v10;
    v49 = 2048;
    v50 = 73;
    v51 = 2048;
    *v52 = v11;
    *&v52[8] = 1024;
    *v53 = 251;
    *&v53[4] = 1024;
    *&v53[6] = 68;
    v54 = 2082;
    v55 = backtrace_string;
    v22 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s";
    v23 = v14;
    v24 = v15;
    v25 = 64;
    goto LABEL_14;
  }

  v17 = v42;
  *(v10 + 9) = __dst;
  *(v10 + 25) = v17;
  v18 = v44;
  *(v10 + 41) = v43;
  *v10 = -5;
  *(v10 + 1) = 68;
  *(v10 + 5) = a3;
  *(v10 + 7) = v7;
  v19 = v10 + 73;
  *(v10 + 57) = v18;
LABEL_19:
  *(*(*(a1 + 32) + 8) + 24) = v19;
  return *(*(*(a1 + 32) + 8) + 24) != 0;
}

uint64_t nw_path_set_agent_identifier_on_endpoint(void *a1, int a2, int a3, unsigned __int8 *a4)
{
  v34 = *MEMORY[0x1E69E9840];
  v7 = a1;
  v8 = v7;
  if (a3 != 17)
  {
    if (a3 == 16)
    {
      goto LABEL_5;
    }

    v12 = __nwlog_obj();
    *buf = 136447234;
    v23 = "nw_path_set_agent_identifier_on_endpoint";
    v24 = 1024;
    v25 = a2;
    v26 = 1024;
    v27 = a3;
    v28 = 2080;
    v29 = "nw_path_set_agent_identifier_on_endpoint";
    v30 = 1024;
    v31 = 2351;
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v13, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *buf = 136447234;
          v23 = "nw_path_set_agent_identifier_on_endpoint";
          v24 = 1024;
          v25 = a2;
          v26 = 1024;
          v27 = a3;
          v28 = 2080;
          v29 = "nw_path_set_agent_identifier_on_endpoint";
          v30 = 1024;
          v31 = 2351;
          _os_log_impl(&dword_181A37000, v14, v15, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
        }
      }

      else if (v20 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v17 = type;
        v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *buf = 136447490;
            v23 = "nw_path_set_agent_identifier_on_endpoint";
            v24 = 1024;
            v25 = a2;
            v26 = 1024;
            v27 = a3;
            v28 = 2080;
            v29 = "nw_path_set_agent_identifier_on_endpoint";
            v30 = 1024;
            v31 = 2351;
            v32 = 2082;
            v33 = backtrace_string;
            _os_log_impl(&dword_181A37000, v14, v17, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }

        if (v18)
        {
          *buf = 136447234;
          v23 = "nw_path_set_agent_identifier_on_endpoint";
          v24 = 1024;
          v25 = a2;
          v26 = 1024;
          v27 = a3;
          v28 = 2080;
          v29 = "nw_path_set_agent_identifier_on_endpoint";
          v30 = 1024;
          v31 = 2351;
          _os_log_impl(&dword_181A37000, v14, v17, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
        }
      }

      else
      {
        v14 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *buf = 136447234;
          v23 = "nw_path_set_agent_identifier_on_endpoint";
          v24 = 1024;
          v25 = a2;
          v26 = 1024;
          v27 = a3;
          v28 = 2080;
          v29 = "nw_path_set_agent_identifier_on_endpoint";
          v30 = 1024;
          v31 = 2351;
          _os_log_impl(&dword_181A37000, v14, v19, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
        }
      }
    }

LABEL_24:
    if (v13)
    {
      free(v13);
    }

    goto LABEL_4;
  }

  if (!*a4++)
  {
LABEL_5:
    nw_endpoint_set_agent_identifier(v7, a4);
    v10 = 1;
    goto LABEL_6;
  }

  nw_endpoint_set_preferred_agent_identifier(v7, a4);
LABEL_4:
  v10 = 0;
LABEL_6:

  return v10;
}

void nw_path_flow_load_protocols_internal(void *a1, double a2)
{
  v9 = *MEMORY[0x1E69E9840];
  Helper_x8__nwrapport_copy_protocol_definition = gotLoadHelper_x8__nwrapport_copy_protocol_definition(a2);
  if (*(v3 + 3088))
  {
    inited = nwrapport_copy_protocol_definition_delayInitStub(Helper_x8__nwrapport_copy_protocol_definition);
    if (inited)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        v7 = 136446210;
        v8 = "nw_path_flow_load_protocols_internal";
        _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_DEBUG, "%{public}s registering rapport protocol", &v7, 0xCu);
      }

      v6 = inited;
      nw_protocol_register_handle(v6 + 8, v6, nw_protocol_implementation_create, nw_protocol_implementation_accept);
    }
  }
}

uint64_t *nw_path_copy_group_descriptor_from_tlv(unsigned int a1, uint64_t a2, const unsigned __int8 *a3)
{
  v23 = *MEMORY[0x1E69E9840];
  if (a1 >= 0x14)
  {
    *buf = *a2;
    *&buf[16] = *(a2 + 16);
    return nw_group_descriptor_create_with_type(*buf, &buf[4]);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = gLogObj;
  *buf = 136447234;
  *&buf[4] = "nw_path_copy_group_descriptor_from_tlv";
  *&buf[12] = 1024;
  *&buf[14] = 205;
  *&buf[18] = 1024;
  v16 = a1;
  v17 = 2080;
  v18 = "nw_path_copy_group_descriptor_from_tlv";
  v19 = 1024;
  v20 = 2227;
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136447234;
        *&buf[4] = "nw_path_copy_group_descriptor_from_tlv";
        *&buf[12] = 1024;
        *&buf[14] = 205;
        *&buf[18] = 1024;
        v16 = a1;
        v17 = 2080;
        v18 = "nw_path_copy_group_descriptor_from_tlv";
        v19 = 1024;
        v20 = 2227;
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136447490;
          *&buf[4] = "nw_path_copy_group_descriptor_from_tlv";
          *&buf[12] = 1024;
          *&buf[14] = 205;
          *&buf[18] = 1024;
          v16 = a1;
          v17 = 2080;
          v18 = "nw_path_copy_group_descriptor_from_tlv";
          v19 = 1024;
          v20 = 2227;
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
        }

        free(backtrace_string);
        if (!v6)
        {
          return 0;
        }

        goto LABEL_9;
      }

      if (v11)
      {
        *buf = 136447234;
        *&buf[4] = "nw_path_copy_group_descriptor_from_tlv";
        *&buf[12] = 1024;
        *&buf[14] = 205;
        *&buf[18] = 1024;
        v16 = a1;
        v17 = 2080;
        v18 = "nw_path_copy_group_descriptor_from_tlv";
        v19 = 1024;
        v20 = 2227;
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136447234;
        *&buf[4] = "nw_path_copy_group_descriptor_from_tlv";
        *&buf[12] = 1024;
        *&buf[14] = 205;
        *&buf[18] = 1024;
        v16 = a1;
        v17 = 2080;
        v18 = "nw_path_copy_group_descriptor_from_tlv";
        v19 = 1024;
        v20 = 2227;
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }
    }
  }

  if (v6)
  {
LABEL_9:
    free(v6);
  }

  return 0;
}

NSObject *nw_path_copy_advertise_descriptor_from_tlv(unsigned int a1, uint64_t a2, const unsigned __int8 *a3)
{
  v69 = *MEMORY[0x1E69E9840];
  if (a1 < 0x1C)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = gLogObj;
    *buf = 136447234;
    v58 = "nw_path_copy_advertise_descriptor_from_tlv";
    v59 = 1024;
    v60 = 204;
    v61 = 1024;
    v62 = a1;
    v63 = 2080;
    v64 = "nw_path_copy_advertise_descriptor_from_tlv";
    v65 = 1024;
    v66 = 2213;
    v15 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v15, &type, &v55))
    {
      goto LABEL_111;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2213;
        _os_log_impl(&dword_181A37000, v16, v17, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }
    }

    else if (v55 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v19 = type;
      v20 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *buf = 136447490;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2213;
          v67 = 2082;
          v68 = backtrace_string;
          _os_log_impl(&dword_181A37000, v16, v19, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
        }

        free(backtrace_string);
        if (!v15)
        {
          return 0;
        }

        goto LABEL_112;
      }

      if (v20)
      {
        *buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2213;
        _os_log_impl(&dword_181A37000, v16, v19, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2213;
        _os_log_impl(&dword_181A37000, v16, v21, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }
    }

    goto LABEL_110;
  }

  if (*(a2 + 1))
  {
    return 0;
  }

  v4 = (a2 + 8);
  v5 = *(a2 + 4);
  v6 = a1 - 8;
  if (v5 == 2)
  {
    v22 = strnlen((a2 + 8), a1 - 8);
    if (v22 >= v6)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = gLogObj;
      *buf = 136447234;
      v58 = "nw_path_copy_advertise_descriptor_from_tlv";
      v59 = 1024;
      v60 = 204;
      v61 = 1024;
      v62 = a1;
      v63 = 2080;
      v64 = "nw_path_copy_advertise_descriptor_from_tlv";
      v65 = 1024;
      v66 = 2182;
      v15 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v55 = 0;
      if (!__nwlog_fault(v15, &type, &v55))
      {
        goto LABEL_111;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v16 = __nwlog_obj();
        v32 = type;
        if (os_log_type_enabled(v16, type))
        {
          *buf = 136447234;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2182;
          _os_log_impl(&dword_181A37000, v16, v32, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
        }

        goto LABEL_110;
      }

      if (v55 != 1)
      {
        v16 = __nwlog_obj();
        v49 = type;
        if (os_log_type_enabled(v16, type))
        {
          *buf = 136447234;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2182;
          _os_log_impl(&dword_181A37000, v16, v49, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
        }

        goto LABEL_110;
      }

      v37 = __nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v40 = type;
      v41 = os_log_type_enabled(v16, type);
      if (!v37)
      {
        if (v41)
        {
          *buf = 136447234;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2182;
          _os_log_impl(&dword_181A37000, v16, v40, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
        }

        goto LABEL_110;
      }

      if (v41)
      {
        *buf = 136447490;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2182;
        v67 = 2082;
        v68 = v37;
        _os_log_impl(&dword_181A37000, v16, v40, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
      }
    }

    else
    {
      v23 = v22 + 1;
      v24 = strnlen(&v4[v22 + 1], v6 - (v22 + 1)) + v22 + 1;
      if (v24 < v6)
      {
        v25 = &v4[v24];
        v26 = *(v25 + 1);
        v27 = *(v25 + 5);
        v28 = nw_advertise_descriptor_create_application_service_with_bundle_id(v4, &v4[v23]);
        nw_advertise_descriptor_set_invitation(v28, v26, v27);
        return v28;
      }

      v35 = __nwlog_obj();
      *buf = 136447234;
      v58 = "nw_path_copy_advertise_descriptor_from_tlv";
      v59 = 1024;
      v60 = 204;
      v61 = 1024;
      v62 = a1;
      v63 = 2080;
      v64 = "nw_path_copy_advertise_descriptor_from_tlv";
      v65 = 1024;
      v66 = 2189;
      v15 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v55 = 0;
      if (!__nwlog_fault(v15, &type, &v55))
      {
LABEL_111:
        if (v15)
        {
LABEL_112:
          free(v15);
        }

        return 0;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v16 = __nwlog_obj();
        v36 = type;
        if (os_log_type_enabled(v16, type))
        {
          *buf = 136447234;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2189;
          _os_log_impl(&dword_181A37000, v16, v36, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
        }

        goto LABEL_110;
      }

      if (v55 != 1)
      {
        v16 = __nwlog_obj();
        v53 = type;
        if (os_log_type_enabled(v16, type))
        {
          *buf = 136447234;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2189;
          _os_log_impl(&dword_181A37000, v16, v53, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
        }

        goto LABEL_110;
      }

      v37 = __nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v47 = type;
      v48 = os_log_type_enabled(v16, type);
      if (!v37)
      {
        if (v48)
        {
          *buf = 136447234;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2189;
          _os_log_impl(&dword_181A37000, v16, v47, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
        }

        goto LABEL_110;
      }

      if (v48)
      {
        *buf = 136447490;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2189;
        v67 = 2082;
        v68 = v37;
        _os_log_impl(&dword_181A37000, v16, v47, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
      }
    }

    goto LABEL_85;
  }

  if (v5 != 1)
  {
    return 0;
  }

  v7 = strnlen((a2 + 8), a1 - 8);
  if (v7 >= v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v29 = gLogObj;
    *buf = 136447234;
    v58 = "nw_path_copy_advertise_descriptor_from_tlv";
    v59 = 1024;
    v60 = 204;
    v61 = 1024;
    v62 = a1;
    v63 = 2080;
    v64 = "nw_path_copy_advertise_descriptor_from_tlv";
    v65 = 1024;
    v66 = 2150;
    v15 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v15, &type, &v55))
    {
      goto LABEL_111;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v30 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2150;
        _os_log_impl(&dword_181A37000, v16, v30, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }

      goto LABEL_110;
    }

    if (v55 != 1)
    {
      v16 = __nwlog_obj();
      v46 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2150;
        _os_log_impl(&dword_181A37000, v16, v46, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }

      goto LABEL_110;
    }

    v37 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v38 = type;
    v39 = os_log_type_enabled(v16, type);
    if (!v37)
    {
      if (v39)
      {
        *buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2150;
        _os_log_impl(&dword_181A37000, v16, v38, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }

      goto LABEL_110;
    }

    if (v39)
    {
      *buf = 136447490;
      v58 = "nw_path_copy_advertise_descriptor_from_tlv";
      v59 = 1024;
      v60 = 204;
      v61 = 1024;
      v62 = a1;
      v63 = 2080;
      v64 = "nw_path_copy_advertise_descriptor_from_tlv";
      v65 = 1024;
      v66 = 2150;
      v67 = 2082;
      v68 = v37;
      _os_log_impl(&dword_181A37000, v16, v38, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
    }

    goto LABEL_85;
  }

  v8 = v7 + 1;
  v9 = strnlen(&v4[v7 + 1], v6 - (v7 + 1)) + v7 + 1;
  if (v9 >= v6)
  {
    v33 = __nwlog_obj();
    *buf = 136447234;
    v58 = "nw_path_copy_advertise_descriptor_from_tlv";
    v59 = 1024;
    v60 = 204;
    v61 = 1024;
    v62 = a1;
    v63 = 2080;
    v64 = "nw_path_copy_advertise_descriptor_from_tlv";
    v65 = 1024;
    v66 = 2157;
    v15 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v15, &type, &v55))
    {
      goto LABEL_111;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v34 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2157;
        _os_log_impl(&dword_181A37000, v16, v34, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }

      goto LABEL_110;
    }

    if (v55 != 1)
    {
      v16 = __nwlog_obj();
      v52 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2157;
        _os_log_impl(&dword_181A37000, v16, v52, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }

      goto LABEL_110;
    }

    v37 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v44 = type;
    v45 = os_log_type_enabled(v16, type);
    if (!v37)
    {
      if (v45)
      {
        *buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2157;
        _os_log_impl(&dword_181A37000, v16, v44, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }

      goto LABEL_110;
    }

    if (v45)
    {
      *buf = 136447490;
      v58 = "nw_path_copy_advertise_descriptor_from_tlv";
      v59 = 1024;
      v60 = 204;
      v61 = 1024;
      v62 = a1;
      v63 = 2080;
      v64 = "nw_path_copy_advertise_descriptor_from_tlv";
      v65 = 1024;
      v66 = 2157;
      v67 = 2082;
      v68 = v37;
      _os_log_impl(&dword_181A37000, v16, v44, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
    }

    goto LABEL_85;
  }

  v10 = v9 + 1;
  v11 = strnlen(&v4[v9 + 1], v6 - (v9 + 1)) + v9 + 1;
  if (v11 >= v6)
  {
    v42 = __nwlog_obj();
    *buf = 136447234;
    v58 = "nw_path_copy_advertise_descriptor_from_tlv";
    v59 = 1024;
    v60 = 204;
    v61 = 1024;
    v62 = a1;
    v63 = 2080;
    v64 = "nw_path_copy_advertise_descriptor_from_tlv";
    v65 = 1024;
    v66 = 2164;
    v15 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v15, &type, &v55))
    {
      goto LABEL_111;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v43 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2164;
        _os_log_impl(&dword_181A37000, v16, v43, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }

LABEL_110:

      goto LABEL_111;
    }

    if (v55 != 1)
    {
      v16 = __nwlog_obj();
      v54 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2164;
        _os_log_impl(&dword_181A37000, v16, v54, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }

      goto LABEL_110;
    }

    v37 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v50 = type;
    v51 = os_log_type_enabled(v16, type);
    if (!v37)
    {
      if (v51)
      {
        *buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2164;
        _os_log_impl(&dword_181A37000, v16, v50, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }

      goto LABEL_110;
    }

    if (v51)
    {
      *buf = 136447490;
      v58 = "nw_path_copy_advertise_descriptor_from_tlv";
      v59 = 1024;
      v60 = 204;
      v61 = 1024;
      v62 = a1;
      v63 = 2080;
      v64 = "nw_path_copy_advertise_descriptor_from_tlv";
      v65 = 1024;
      v66 = 2164;
      v67 = 2082;
      v68 = v37;
      _os_log_impl(&dword_181A37000, v16, v50, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
    }

LABEL_85:

    free(v37);
    if (!v15)
    {
      return 0;
    }

    goto LABEL_112;
  }

  result = nw_advertise_descriptor_create_bonjour_service(v4, &v4[v8], &v4[v10]);
  if (v6 > v11 + 1)
  {
    v13 = result;
    nw_advertise_descriptor_set_txt_record(result, &v4[v11 + 1], v6 - (v11 + 1));
    return v13;
  }

  return result;
}

uint64_t nw_path_create_assign_message_internal(unint64_t *a1, _OWORD *a2, unsigned int a3, const void *a4, unsigned int a5, int a6, void *a7, void *a8, void *a9, size_t a10, const void *a11)
{
  v245 = *MEMORY[0x1E69E9840];
  v17 = a7;
  v18 = a8;
  v19 = a9;
  v230 = v19;
  v231 = v17;
  v229 = v18;
  if (a3 >= 0x10000)
  {
    v117 = __nwlog_obj();
    *buf = 136446466;
    v238 = "nw_path_create_assign_message_internal";
    v239 = 1024;
    *v240 = a3;
    v118 = _os_log_send_and_compose_impl();

    v234[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v118, v234, &type))
    {
      if (v234[0] == OS_LOG_TYPE_FAULT)
      {
        v119 = __nwlog_obj();
        v120 = v234[0];
        if (os_log_type_enabled(v119, v234[0]))
        {
          *buf = 136446466;
          v238 = "nw_path_create_assign_message_internal";
          v239 = 1024;
          *v240 = a3;
          _os_log_impl(&dword_181A37000, v119, v120, "%{public}s nexus_port %u > NEXUS_PORT_MAX", buf, 0x12u);
        }
      }

      else if (type == OS_LOG_TYPE_INFO)
      {
        backtrace_string = __nw_create_backtrace_string();
        v119 = __nwlog_obj();
        v142 = v234[0];
        v143 = os_log_type_enabled(v119, v234[0]);
        if (backtrace_string)
        {
          if (v143)
          {
            *buf = 136446722;
            v238 = "nw_path_create_assign_message_internal";
            v239 = 1024;
            *v240 = a3;
            *&v240[4] = 2082;
            *&v240[6] = backtrace_string;
            _os_log_impl(&dword_181A37000, v119, v142, "%{public}s nexus_port %u > NEXUS_PORT_MAX, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(backtrace_string);
          goto LABEL_442;
        }

        if (v143)
        {
          *buf = 136446466;
          v238 = "nw_path_create_assign_message_internal";
          v239 = 1024;
          *v240 = a3;
          _os_log_impl(&dword_181A37000, v119, v142, "%{public}s nexus_port %u > NEXUS_PORT_MAX, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        v119 = __nwlog_obj();
        v176 = v234[0];
        if (os_log_type_enabled(v119, v234[0]))
        {
          *buf = 136446466;
          v238 = "nw_path_create_assign_message_internal";
          v239 = 1024;
          *v240 = a3;
          _os_log_impl(&dword_181A37000, v119, v176, "%{public}s nexus_port %u > NEXUS_PORT_MAX, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }

LABEL_442:
    v116 = v19;
    if (v118)
    {
      free(v118);
    }

    v228 = 0;
    goto LABEL_239;
  }

  v236 = 0;
  *v234 = 0u;
  v235 = 0u;
  if (a1)
  {
    *a1 = 0;
  }

  v226 = a1;
  if (a4 != 0 && a5 != 0)
  {
    v20 = a5 + 33;
  }

  else
  {
    v20 = 28;
  }

  if (v17)
  {
    v20 += nw_path_struct_size_for_endpoint_and_metadata(v17, 0, 7);
  }

  if (a6)
  {
    v20 += 9;
  }

  if (v18)
  {
    v20 += nw_path_struct_size_for_endpoint_and_metadata(v18, 0, 7);
  }

  v21 = v20 + 47;
  if (!v19)
  {
    v21 = v20;
  }

  if (a10)
  {
    v22 = a11 == 0;
  }

  else
  {
    v22 = 1;
  }

  v23 = !v22;
  v224 = v23;
  if (((a10 < 0x101) & v23) != 0)
  {
    v24 = a10 + 5;
  }

  else
  {
    v24 = 0;
  }

  v25 = v21 + v24;
  if (!(v21 + v24))
  {
    v121 = __nwlog_obj();
    os_log_type_enabled(v121, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v238 = "nw_path_create_assign_message_internal";
    v122 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v122);
    if (result)
    {
      goto LABEL_513;
    }

    free(v122);
    v25 = 0;
  }

  v26 = malloc_type_calloc(1uLL, v25, 0x137859A9uLL);
  v227 = v25;
  v228 = v26;
  if (v26)
  {
    v27 = &v26[v25];
    if (v25 <= 0)
    {
      v123 = __nwlog_obj();
      *buf = 136447234;
      v238 = "nw_necp_append_tlv";
      v239 = 2048;
      *v240 = v228;
      *&v240[8] = 2048;
      *&v240[10] = v27;
      *&v240[18] = 1024;
      *v241 = 100;
      *&v241[4] = 1024;
      *&v241[6] = 16;
      v29 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v232 = 0;
      if (__nwlog_fault(v29, &type, &v232))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v30 = __nwlog_obj();
          v124 = type;
          if (os_log_type_enabled(v30, type))
          {
            *buf = 136447234;
            v238 = "nw_necp_append_tlv";
            v239 = 2048;
            *v240 = v228;
            *&v240[8] = 2048;
            *&v240[10] = v27;
            *&v240[18] = 1024;
            *v241 = 100;
            *&v241[4] = 1024;
            *&v241[6] = 16;
            _os_log_impl(&dword_181A37000, v30, v124, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
          }
        }

        else if (v232 == 1)
        {
          v154 = __nw_create_backtrace_string();
          v30 = __nwlog_obj();
          v155 = type;
          v156 = os_log_type_enabled(v30, type);
          if (v154)
          {
            if (v156)
            {
              *buf = 136447490;
              v238 = "nw_necp_append_tlv";
              v239 = 2048;
              *v240 = v228;
              *&v240[8] = 2048;
              *&v240[10] = v27;
              *&v240[18] = 1024;
              *v241 = 100;
              *&v241[4] = 1024;
              *&v241[6] = 16;
              *v242 = 2082;
              *&v242[2] = v154;
              _os_log_impl(&dword_181A37000, v30, v155, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
            }

            free(v154);
            if (!v29)
            {
              goto LABEL_86;
            }

            goto LABEL_85;
          }

          if (v156)
          {
            *buf = 136447234;
            v238 = "nw_necp_append_tlv";
            v239 = 2048;
            *v240 = v228;
            *&v240[8] = 2048;
            *&v240[10] = v27;
            *&v240[18] = 1024;
            *v241 = 100;
            *&v241[4] = 1024;
            *&v241[6] = 16;
            _os_log_impl(&dword_181A37000, v30, v155, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
          }
        }

        else
        {
          v30 = __nwlog_obj();
          v194 = type;
          if (os_log_type_enabled(v30, type))
          {
            *buf = 136447234;
            v238 = "nw_necp_append_tlv";
            v239 = 2048;
            *v240 = v228;
            *&v240[8] = 2048;
            *&v240[10] = v27;
            *&v240[18] = 1024;
            *v241 = 100;
            *&v241[4] = 1024;
            *&v241[6] = 16;
            _os_log_impl(&dword_181A37000, v30, v194, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
          }
        }

        goto LABEL_83;
      }
    }

    else
    {
      if (v25 <= 0x14)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = gLogObj;
        *buf = 136447490;
        v238 = "nw_necp_append_tlv";
        v239 = 2048;
        *v240 = v228;
        *&v240[8] = 2048;
        *&v240[10] = 21;
        *&v240[18] = 2048;
        *v241 = v27;
        *&v241[8] = 1024;
        *v242 = 100;
        *&v242[4] = 1024;
        *&v242[6] = 16;
        v29 = _os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v232 = 0;
        if (!__nwlog_fault(v29, &type, &v232))
        {
          goto LABEL_84;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v30 = gLogObj;
          v31 = type;
          if (os_log_type_enabled(v30, type))
          {
            *buf = 136447490;
            v238 = "nw_necp_append_tlv";
            v239 = 2048;
            *v240 = v228;
            *&v240[8] = 2048;
            *&v240[10] = 21;
            *&v240[18] = 2048;
            *v241 = v27;
            *&v241[8] = 1024;
            *v242 = 100;
            *&v242[4] = 1024;
            *&v242[6] = 16;
            _os_log_impl(&dword_181A37000, v30, v31, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
          }
        }

        else if (v232 == 1)
        {
          v46 = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v30 = gLogObj;
          v47 = type;
          v48 = os_log_type_enabled(v30, type);
          if (v46)
          {
            if (v48)
            {
              *buf = 136447746;
              v238 = "nw_necp_append_tlv";
              v239 = 2048;
              *v240 = v228;
              *&v240[8] = 2048;
              *&v240[10] = 21;
              *&v240[18] = 2048;
              *v241 = v27;
              *&v241[8] = 1024;
              *v242 = 100;
              *&v242[4] = 1024;
              *&v242[6] = 16;
              v243 = 2082;
              v244 = v46;
              _os_log_impl(&dword_181A37000, v30, v47, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
            }

            free(v46);
            if (!v29)
            {
              goto LABEL_86;
            }

            goto LABEL_85;
          }

          if (v48)
          {
            *buf = 136447490;
            v238 = "nw_necp_append_tlv";
            v239 = 2048;
            *v240 = v228;
            *&v240[8] = 2048;
            *&v240[10] = 21;
            *&v240[18] = 2048;
            *v241 = v27;
            *&v241[8] = 1024;
            *v242 = 100;
            *&v242[4] = 1024;
            *&v242[6] = 16;
            _os_log_impl(&dword_181A37000, v30, v47, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v30 = gLogObj;
          v51 = type;
          if (os_log_type_enabled(v30, type))
          {
            *buf = 136447490;
            v238 = "nw_necp_append_tlv";
            v239 = 2048;
            *v240 = v228;
            *&v240[8] = 2048;
            *&v240[10] = 21;
            *&v240[18] = 2048;
            *v241 = v27;
            *&v241[8] = 1024;
            *v242 = 100;
            *&v242[4] = 1024;
            *&v242[6] = 16;
            _os_log_impl(&dword_181A37000, v30, v51, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
          }
        }

        goto LABEL_83;
      }

      *v26 = 100;
      *(v26 + 1) = 16;
      if (a2)
      {
        *(v26 + 5) = *a2;
        if (v25 != 21)
        {
          if ((v25 - 21) > 6)
          {
            v26[21] = 101;
            *(v26 + 22) = 2;
            *(v26 + 13) = a3;
            v49 = (v26 + 28);
            goto LABEL_113;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v39 = gLogObj;
          *buf = 136447490;
          v238 = "nw_necp_append_tlv";
          v239 = 2048;
          *v240 = v228 + 21;
          *&v240[8] = 2048;
          *&v240[10] = 7;
          *&v240[18] = 2048;
          *v241 = v27;
          *&v241[8] = 1024;
          *v242 = 101;
          *&v242[4] = 1024;
          *&v242[6] = 2;
          v40 = _os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v232 = 0;
          if (__nwlog_fault(v40, &type, &v232))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v41 = gLogObj;
              v42 = type;
              if (os_log_type_enabled(v41, type))
              {
                *buf = 136447490;
                v238 = "nw_necp_append_tlv";
                v239 = 2048;
                *v240 = v228 + 21;
                *&v240[8] = 2048;
                *&v240[10] = 7;
                *&v240[18] = 2048;
                *v241 = v27;
                *&v241[8] = 1024;
                *v242 = 101;
                *&v242[4] = 1024;
                *&v242[6] = 2;
                _os_log_impl(&dword_181A37000, v41, v42, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
              }
            }

            else if (v232 == 1)
            {
              v52 = __nw_create_backtrace_string();
              if (v52)
              {
                v53 = v52;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v54 = gLogObj;
                v55 = type;
                if (os_log_type_enabled(v54, type))
                {
                  *buf = 136447746;
                  v238 = "nw_necp_append_tlv";
                  v239 = 2048;
                  *v240 = v228 + 21;
                  *&v240[8] = 2048;
                  *&v240[10] = 7;
                  *&v240[18] = 2048;
                  *v241 = v27;
                  *&v241[8] = 1024;
                  *v242 = 101;
                  *&v242[4] = 1024;
                  *&v242[6] = 2;
                  v243 = 2082;
                  v244 = v53;
                  _os_log_impl(&dword_181A37000, v54, v55, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                }

                free(v53);
                if (!v40)
                {
                  goto LABEL_112;
                }

                goto LABEL_111;
              }

              v41 = __nwlog_obj();
              v66 = type;
              if (os_log_type_enabled(v41, type))
              {
                *buf = 136447490;
                v238 = "nw_necp_append_tlv";
                v239 = 2048;
                *v240 = v228 + 21;
                *&v240[8] = 2048;
                *&v240[10] = 7;
                *&v240[18] = 2048;
                *v241 = v27;
                *&v241[8] = 1024;
                *v242 = 101;
                *&v242[4] = 1024;
                *&v242[6] = 2;
                _os_log_impl(&dword_181A37000, v41, v66, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
              }
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v41 = gLogObj;
              v56 = type;
              if (os_log_type_enabled(v41, type))
              {
                *buf = 136447490;
                v238 = "nw_necp_append_tlv";
                v239 = 2048;
                *v240 = v228 + 21;
                *&v240[8] = 2048;
                *&v240[10] = 7;
                *&v240[18] = 2048;
                *v241 = v27;
                *&v241[8] = 1024;
                *v242 = 101;
                *&v242[4] = 1024;
                *&v242[6] = 2;
                _os_log_impl(&dword_181A37000, v41, v56, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
              }
            }
          }

          if (!v40)
          {
LABEL_112:
            v49 = 0;
LABEL_113:
            if (a4 == 0 || a5 == 0)
            {
              goto LABEL_124;
            }

LABEL_114:
            if (v49)
            {
              if (v27)
              {
                if (v49 >= v27)
                {
                  v150 = __nwlog_obj();
                  *buf = 136447234;
                  v238 = "nw_necp_append_tlv";
                  v239 = 2048;
                  *v240 = v49;
                  *&v240[8] = 2048;
                  *&v240[10] = v27;
                  *&v240[18] = 1024;
                  *v241 = 102;
                  *&v241[4] = 1024;
                  *&v241[6] = a5;
                  v68 = _os_log_send_and_compose_impl();

                  type = OS_LOG_TYPE_ERROR;
                  v232 = 0;
                  if (__nwlog_fault(v68, &type, &v232))
                  {
                    if (type == OS_LOG_TYPE_FAULT)
                    {
                      v69 = __nwlog_obj();
                      v151 = type;
                      if (os_log_type_enabled(v69, type))
                      {
                        *buf = 136447234;
                        v238 = "nw_necp_append_tlv";
                        v239 = 2048;
                        *v240 = v49;
                        *&v240[8] = 2048;
                        *&v240[10] = v27;
                        *&v240[18] = 1024;
                        *v241 = 102;
                        *&v241[4] = 1024;
                        *&v241[6] = a5;
                        _os_log_impl(&dword_181A37000, v69, v151, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
                      }

                      goto LABEL_140;
                    }

                    if (v232 != 1)
                    {
                      v69 = __nwlog_obj();
                      v215 = type;
                      if (os_log_type_enabled(v69, type))
                      {
                        *buf = 136447234;
                        v238 = "nw_necp_append_tlv";
                        v239 = 2048;
                        *v240 = v49;
                        *&v240[8] = 2048;
                        *&v240[10] = v27;
                        *&v240[18] = 1024;
                        *v241 = 102;
                        *&v241[4] = 1024;
                        *&v241[6] = a5;
                        _os_log_impl(&dword_181A37000, v69, v215, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
                      }

                      goto LABEL_140;
                    }

                    v191 = __nw_create_backtrace_string();
                    v69 = __nwlog_obj();
                    v192 = type;
                    v193 = os_log_type_enabled(v69, type);
                    if (!v191)
                    {
                      if (v193)
                      {
                        *buf = 136447234;
                        v238 = "nw_necp_append_tlv";
                        v239 = 2048;
                        *v240 = v49;
                        *&v240[8] = 2048;
                        *&v240[10] = v27;
                        *&v240[18] = 1024;
                        *v241 = 102;
                        *&v241[4] = 1024;
                        *&v241[6] = a5;
                        _os_log_impl(&dword_181A37000, v69, v192, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
                      }

                      goto LABEL_140;
                    }

                    if (v193)
                    {
                      *buf = 136447490;
                      v238 = "nw_necp_append_tlv";
                      v239 = 2048;
                      *v240 = v49;
                      *&v240[8] = 2048;
                      *&v240[10] = v27;
                      *&v240[18] = 1024;
                      *v241 = 102;
                      *&v241[4] = 1024;
                      *&v241[6] = a5;
                      *v242 = 2082;
                      *&v242[2] = v191;
                      _os_log_impl(&dword_181A37000, v69, v192, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
                    }

                    free(v191);
                  }

LABEL_141:
                  if (!v68)
                  {
                    goto LABEL_144;
                  }

                  goto LABEL_142;
                }

                if (v27 - v49 < a5 + 5)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v67 = gLogObj;
                  *buf = 136447490;
                  v238 = "nw_necp_append_tlv";
                  v239 = 2048;
                  *v240 = v49;
                  *&v240[8] = 2048;
                  *&v240[10] = a5 + 5;
                  *&v240[18] = 2048;
                  *v241 = v27;
                  *&v241[8] = 1024;
                  *v242 = 102;
                  *&v242[4] = 1024;
                  *&v242[6] = a5;
                  v68 = _os_log_send_and_compose_impl();

                  type = OS_LOG_TYPE_ERROR;
                  v232 = 0;
                  if (!__nwlog_fault(v68, &type, &v232))
                  {
                    goto LABEL_141;
                  }

                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v69 = gLogObj;
                    v70 = type;
                    if (os_log_type_enabled(v69, type))
                    {
                      *buf = 136447490;
                      v238 = "nw_necp_append_tlv";
                      v239 = 2048;
                      *v240 = v49;
                      *&v240[8] = 2048;
                      *&v240[10] = a5 + 5;
                      *&v240[18] = 2048;
                      *v241 = v27;
                      *&v241[8] = 1024;
                      *v242 = 102;
                      *&v242[4] = 1024;
                      *&v242[6] = a5;
                      _os_log_impl(&dword_181A37000, v69, v70, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
                    }

LABEL_140:

                    goto LABEL_141;
                  }

                  if (v232 != 1)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v69 = gLogObj;
                    v77 = type;
                    if (os_log_type_enabled(v69, type))
                    {
                      *buf = 136447490;
                      v238 = "nw_necp_append_tlv";
                      v239 = 2048;
                      *v240 = v49;
                      *&v240[8] = 2048;
                      *&v240[10] = a5 + 5;
                      *&v240[18] = 2048;
                      *v241 = v27;
                      *&v241[8] = 1024;
                      *v242 = 102;
                      *&v242[4] = 1024;
                      *&v242[6] = a5;
                      _os_log_impl(&dword_181A37000, v69, v77, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
                    }

                    goto LABEL_140;
                  }

                  v74 = __nw_create_backtrace_string();
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v69 = gLogObj;
                  v75 = type;
                  v76 = os_log_type_enabled(v69, type);
                  if (!v74)
                  {
                    if (v76)
                    {
                      *buf = 136447490;
                      v238 = "nw_necp_append_tlv";
                      v239 = 2048;
                      *v240 = v49;
                      *&v240[8] = 2048;
                      *&v240[10] = a5 + 5;
                      *&v240[18] = 2048;
                      *v241 = v27;
                      *&v241[8] = 1024;
                      *v242 = 102;
                      *&v242[4] = 1024;
                      *&v242[6] = a5;
                      _os_log_impl(&dword_181A37000, v69, v75, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
                    }

                    goto LABEL_140;
                  }

                  if (v76)
                  {
                    *buf = 136447746;
                    v238 = "nw_necp_append_tlv";
                    v239 = 2048;
                    *v240 = v49;
                    *&v240[8] = 2048;
                    *&v240[10] = a5 + 5;
                    *&v240[18] = 2048;
                    *v241 = v27;
                    *&v241[8] = 1024;
                    *v242 = 102;
                    *&v242[4] = 1024;
                    *&v242[6] = a5;
                    v243 = 2082;
                    v244 = v74;
                    _os_log_impl(&dword_181A37000, v69, v75, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                  }

                  free(v74);
                  if (v68)
                  {
LABEL_142:
                    v78 = v68;
LABEL_143:
                    free(v78);
                  }

LABEL_144:
                  v49 = 0;
                  v71 = v231;
                  if (a6)
                  {
LABEL_145:
                    if (v49)
                    {
                      if (v27)
                      {
                        if (v49 < v27)
                        {
                          if (v27 - v49 > 8)
                          {
                            *v49 = 103;
                            *(v49 + 1) = 4;
                            *(v49 + 5) = a6;
                            v49 += 9;
                            goto LABEL_171;
                          }

                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          v79 = gLogObj;
                          *buf = 136447490;
                          v238 = "nw_necp_append_tlv";
                          v239 = 2048;
                          *v240 = v49;
                          *&v240[8] = 2048;
                          *&v240[10] = 9;
                          *&v240[18] = 2048;
                          *v241 = v27;
                          *&v241[8] = 1024;
                          *v242 = 103;
                          *&v242[4] = 1024;
                          *&v242[6] = 4;
                          v80 = _os_log_send_and_compose_impl();

                          type = OS_LOG_TYPE_ERROR;
                          v232 = 0;
                          if (__nwlog_fault(v80, &type, &v232))
                          {
                            if (type == OS_LOG_TYPE_FAULT)
                            {
                              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                              networkd_settings_init();
                              v81 = gLogObj;
                              v82 = type;
                              if (os_log_type_enabled(v81, type))
                              {
                                *buf = 136447490;
                                v238 = "nw_necp_append_tlv";
                                v239 = 2048;
                                *v240 = v49;
                                *&v240[8] = 2048;
                                *&v240[10] = 9;
                                *&v240[18] = 2048;
                                *v241 = v27;
                                *&v241[8] = 1024;
                                *v242 = 103;
                                *&v242[4] = 1024;
                                *&v242[6] = 4;
                                _os_log_impl(&dword_181A37000, v81, v82, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
                              }
                            }

                            else if (v232 == 1)
                            {
                              v83 = __nw_create_backtrace_string();
                              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                              networkd_settings_init();
                              v81 = gLogObj;
                              v84 = type;
                              v85 = os_log_type_enabled(v81, type);
                              if (v83)
                              {
                                if (v85)
                                {
                                  *buf = 136447746;
                                  v238 = "nw_necp_append_tlv";
                                  v239 = 2048;
                                  *v240 = v49;
                                  *&v240[8] = 2048;
                                  *&v240[10] = 9;
                                  *&v240[18] = 2048;
                                  *v241 = v27;
                                  *&v241[8] = 1024;
                                  *v242 = 103;
                                  *&v242[4] = 1024;
                                  *&v242[6] = 4;
                                  v243 = 2082;
                                  v244 = v83;
                                  _os_log_impl(&dword_181A37000, v81, v84, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                                }

                                free(v83);
                                if (!v80)
                                {
                                  goto LABEL_170;
                                }

LABEL_168:
                                v87 = v80;
LABEL_169:
                                free(v87);
                                goto LABEL_170;
                              }

                              if (v85)
                              {
                                *buf = 136447490;
                                v238 = "nw_necp_append_tlv";
                                v239 = 2048;
                                *v240 = v49;
                                *&v240[8] = 2048;
                                *&v240[10] = 9;
                                *&v240[18] = 2048;
                                *v241 = v27;
                                *&v241[8] = 1024;
                                *v242 = 103;
                                *&v242[4] = 1024;
                                *&v242[6] = 4;
                                _os_log_impl(&dword_181A37000, v81, v84, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
                              }
                            }

                            else
                            {
                              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                              networkd_settings_init();
                              v81 = gLogObj;
                              v86 = type;
                              if (os_log_type_enabled(v81, type))
                              {
                                *buf = 136447490;
                                v238 = "nw_necp_append_tlv";
                                v239 = 2048;
                                *v240 = v49;
                                *&v240[8] = 2048;
                                *&v240[10] = 9;
                                *&v240[18] = 2048;
                                *v241 = v27;
                                *&v241[8] = 1024;
                                *v242 = 103;
                                *&v242[4] = 1024;
                                *&v242[6] = 4;
                                _os_log_impl(&dword_181A37000, v81, v86, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
                              }
                            }

                            goto LABEL_166;
                          }

LABEL_167:
                          if (!v80)
                          {
LABEL_170:
                            v49 = 0;
LABEL_171:
                            v71 = v231;
                            v72 = v229;
                            if (v231)
                            {
LABEL_172:
                              v49 = nw_path_evaluator_add_endpoint_to_necp_message(v71, 200, v49, v27, 7);
                              if (v72)
                              {
LABEL_173:
                                v49 = nw_path_evaluator_add_endpoint_to_necp_message(v72, 201, v49, v27, 7);
                                v73 = v230;
                                if (!v230)
                                {
                                  goto LABEL_203;
                                }

                                goto LABEL_174;
                              }

LABEL_127:
                              v73 = v230;
                              if (!v230)
                              {
                                goto LABEL_203;
                              }

LABEL_174:
                              v88 = v73;

                              *v234 = *(v88 + 8);
                              v235 = *(v88 + 24);
                              v236 = *(v88 + 5);
                              if (v49)
                              {
                                if (v27)
                                {
                                  if (v49 < v27)
                                  {
                                    if (v27 - v49 > 0x2E)
                                    {
                                      *v49 = -34;
                                      *(v49 + 1) = 42;
                                      v93 = *v234;
                                      v94 = v235;
                                      *(v49 + 37) = v236;
                                      *(v49 + 21) = v94;
                                      *(v49 + 5) = v93;
                                      *(v49 + 45) = 0;
                                      v49 += 47;
LABEL_200:
                                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                      networkd_settings_init();
                                      v100 = gLogObj;
                                      if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
                                      {
                                        *buf = 136446466;
                                        v238 = "nw_path_create_assign_message_internal";
                                        v239 = 2112;
                                        *v240 = v88;
                                        _os_log_impl(&dword_181A37000, v100, OS_LOG_TYPE_DEBUG, "%{public}s Serialized peer protocol %@", buf, 0x16u);
                                      }

LABEL_203:
                                      v101 = v226;
                                      if (!v224)
                                      {
LABEL_236:
                                        if (v101)
                                        {
                                          *v101 = v227;
                                        }

                                        v116 = v230;
LABEL_239:

                                        return v228;
                                      }

                                      if (a10 >= 0x101)
                                      {
                                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                        networkd_settings_init();
                                        v102 = gLogObj;
                                        if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
                                        {
                                          *buf = 136446722;
                                          v238 = "nw_path_create_assign_message_internal";
                                          v239 = 2048;
                                          *v240 = a10;
                                          *&v240[8] = 1024;
                                          *&v240[10] = 256;
                                          v103 = "%{public}s Custom data (%zu bytes) exceeds maximum size %d";
                                          v104 = v102;
                                          v105 = OS_LOG_TYPE_ERROR;
                                          v106 = 28;
LABEL_234:
                                          _os_log_impl(&dword_181A37000, v104, v105, v103, buf, v106);
                                          goto LABEL_235;
                                        }

                                        goto LABEL_235;
                                      }

                                      if (v49)
                                      {
                                        if (v27)
                                        {
                                          if (v49 >= v27)
                                          {
                                            v189 = __nwlog_obj();
                                            *buf = 136447234;
                                            v238 = "nw_necp_append_tlv";
                                            v239 = 2048;
                                            *v240 = v49;
                                            *&v240[8] = 2048;
                                            *&v240[10] = v27;
                                            *&v240[18] = 1024;
                                            *v241 = 224;
                                            *&v241[4] = 1024;
                                            *&v241[6] = a10;
                                            v108 = _os_log_send_and_compose_impl();

                                            type = OS_LOG_TYPE_ERROR;
                                            v232 = 0;
                                            if (__nwlog_fault(v108, &type, &v232))
                                            {
                                              if (type == OS_LOG_TYPE_FAULT)
                                              {
                                                v109 = __nwlog_obj();
                                                v190 = type;
                                                if (os_log_type_enabled(v109, type))
                                                {
                                                  *buf = 136447234;
                                                  v238 = "nw_necp_append_tlv";
                                                  v239 = 2048;
                                                  *v240 = v49;
                                                  *&v240[8] = 2048;
                                                  *&v240[10] = v27;
                                                  *&v240[18] = 1024;
                                                  *v241 = 224;
                                                  *&v241[4] = 1024;
                                                  *&v241[6] = a10;
                                                  _os_log_impl(&dword_181A37000, v109, v190, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
                                                }

                                                goto LABEL_228;
                                              }

                                              if (v232 != 1)
                                              {
                                                v109 = __nwlog_obj();
                                                v223 = type;
                                                if (os_log_type_enabled(v109, type))
                                                {
                                                  *buf = 136447234;
                                                  v238 = "nw_necp_append_tlv";
                                                  v239 = 2048;
                                                  *v240 = v49;
                                                  *&v240[8] = 2048;
                                                  *&v240[10] = v27;
                                                  *&v240[18] = 1024;
                                                  *v241 = 224;
                                                  *&v241[4] = 1024;
                                                  *&v241[6] = a10;
                                                  _os_log_impl(&dword_181A37000, v109, v223, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
                                                }

                                                goto LABEL_228;
                                              }

                                              v216 = __nw_create_backtrace_string();
                                              v109 = __nwlog_obj();
                                              v217 = type;
                                              v218 = os_log_type_enabled(v109, type);
                                              if (!v216)
                                              {
                                                if (v218)
                                                {
                                                  *buf = 136447234;
                                                  v238 = "nw_necp_append_tlv";
                                                  v239 = 2048;
                                                  *v240 = v49;
                                                  *&v240[8] = 2048;
                                                  *&v240[10] = v27;
                                                  *&v240[18] = 1024;
                                                  *v241 = 224;
                                                  *&v241[4] = 1024;
                                                  *&v241[6] = a10;
                                                  _os_log_impl(&dword_181A37000, v109, v217, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
                                                }

                                                goto LABEL_228;
                                              }

                                              if (v218)
                                              {
                                                *buf = 136447490;
                                                v238 = "nw_necp_append_tlv";
                                                v239 = 2048;
                                                *v240 = v49;
                                                *&v240[8] = 2048;
                                                *&v240[10] = v27;
                                                *&v240[18] = 1024;
                                                *v241 = 224;
                                                *&v241[4] = 1024;
                                                *&v241[6] = a10;
                                                *v242 = 2082;
                                                *&v242[2] = v216;
                                                _os_log_impl(&dword_181A37000, v109, v217, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
                                              }

                                              free(v216);
                                            }
                                          }

                                          else
                                          {
                                            if (v27 - v49 >= a10 + 5)
                                            {
                                              *v49 = -32;
                                              *(v49 + 1) = a10;
                                              memcpy((v49 + 5), a11, a10);
                                              goto LABEL_232;
                                            }

                                            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                            networkd_settings_init();
                                            v107 = gLogObj;
                                            *buf = 136447490;
                                            v238 = "nw_necp_append_tlv";
                                            v239 = 2048;
                                            *v240 = v49;
                                            *&v240[8] = 2048;
                                            *&v240[10] = a10 + 5;
                                            *&v240[18] = 2048;
                                            *v241 = v27;
                                            *&v241[8] = 1024;
                                            *v242 = 224;
                                            *&v242[4] = 1024;
                                            *&v242[6] = a10;
                                            v108 = _os_log_send_and_compose_impl();

                                            type = OS_LOG_TYPE_ERROR;
                                            v232 = 0;
                                            if (__nwlog_fault(v108, &type, &v232))
                                            {
                                              if (type == OS_LOG_TYPE_FAULT)
                                              {
                                                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                                networkd_settings_init();
                                                v109 = gLogObj;
                                                v110 = type;
                                                if (os_log_type_enabled(v109, type))
                                                {
                                                  *buf = 136447490;
                                                  v238 = "nw_necp_append_tlv";
                                                  v239 = 2048;
                                                  *v240 = v49;
                                                  *&v240[8] = 2048;
                                                  *&v240[10] = a10 + 5;
                                                  *&v240[18] = 2048;
                                                  *v241 = v27;
                                                  *&v241[8] = 1024;
                                                  *v242 = 224;
                                                  *&v242[4] = 1024;
                                                  *&v242[6] = a10;
                                                  _os_log_impl(&dword_181A37000, v109, v110, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
                                                }

LABEL_228:

                                                goto LABEL_229;
                                              }

                                              if (v232 != 1)
                                              {
                                                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                                networkd_settings_init();
                                                v109 = gLogObj;
                                                v114 = type;
                                                if (os_log_type_enabled(v109, type))
                                                {
                                                  *buf = 136447490;
                                                  v238 = "nw_necp_append_tlv";
                                                  v239 = 2048;
                                                  *v240 = v49;
                                                  *&v240[8] = 2048;
                                                  *&v240[10] = a10 + 5;
                                                  *&v240[18] = 2048;
                                                  *v241 = v27;
                                                  *&v241[8] = 1024;
                                                  *v242 = 224;
                                                  *&v242[4] = 1024;
                                                  *&v242[6] = a10;
                                                  _os_log_impl(&dword_181A37000, v109, v114, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
                                                }

                                                goto LABEL_228;
                                              }

                                              v111 = __nw_create_backtrace_string();
                                              v109 = __nwlog_obj();
                                              v112 = type;
                                              v113 = os_log_type_enabled(v109, type);
                                              if (!v111)
                                              {
                                                if (v113)
                                                {
                                                  *buf = 136447490;
                                                  v238 = "nw_necp_append_tlv";
                                                  v239 = 2048;
                                                  *v240 = v49;
                                                  *&v240[8] = 2048;
                                                  *&v240[10] = a10 + 5;
                                                  *&v240[18] = 2048;
                                                  *v241 = v27;
                                                  *&v241[8] = 1024;
                                                  *v242 = 224;
                                                  *&v242[4] = 1024;
                                                  *&v242[6] = a10;
                                                  _os_log_impl(&dword_181A37000, v109, v112, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
                                                }

                                                goto LABEL_228;
                                              }

                                              if (v113)
                                              {
                                                *buf = 136447746;
                                                v238 = "nw_necp_append_tlv";
                                                v239 = 2048;
                                                *v240 = v49;
                                                *&v240[8] = 2048;
                                                *&v240[10] = a10 + 5;
                                                *&v240[18] = 2048;
                                                *v241 = v27;
                                                *&v241[8] = 1024;
                                                *v242 = 224;
                                                *&v242[4] = 1024;
                                                *&v242[6] = a10;
                                                v243 = 2082;
                                                v244 = v111;
                                                _os_log_impl(&dword_181A37000, v109, v112, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                                              }

                                              free(v111);
                                              if (v108)
                                              {
LABEL_230:
                                                v115 = v108;
LABEL_231:
                                                free(v115);
                                              }

LABEL_232:
                                              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                              networkd_settings_init();
                                              v102 = gLogObj;
                                              if (os_log_type_enabled(v102, OS_LOG_TYPE_INFO))
                                              {
                                                *buf = 136446466;
                                                v238 = "nw_path_create_assign_message_internal";
                                                v239 = 2048;
                                                *v240 = a10;
                                                v103 = "%{public}s Appended custom data %zu bytes";
                                                v104 = v102;
                                                v105 = OS_LOG_TYPE_INFO;
                                                v106 = 22;
                                                goto LABEL_234;
                                              }

LABEL_235:

                                              v101 = v226;
                                              goto LABEL_236;
                                            }
                                          }

LABEL_229:
                                          if (!v108)
                                          {
                                            goto LABEL_232;
                                          }

                                          goto LABEL_230;
                                        }

                                        v184 = __nwlog_obj();
                                        *buf = 136446210;
                                        v238 = "nw_necp_append_tlv";
                                        v178 = _os_log_send_and_compose_impl();

                                        type = OS_LOG_TYPE_ERROR;
                                        v232 = 0;
                                        if (!__nwlog_fault(v178, &type, &v232))
                                        {
                                          goto LABEL_508;
                                        }

                                        if (type == OS_LOG_TYPE_FAULT)
                                        {
                                          v179 = __nwlog_obj();
                                          v185 = type;
                                          if (os_log_type_enabled(v179, type))
                                          {
                                            *buf = 136446210;
                                            v238 = "nw_necp_append_tlv";
                                            _os_log_impl(&dword_181A37000, v179, v185, "%{public}s called with null beyond", buf, 0xCu);
                                          }
                                        }

                                        else if (v232 == 1)
                                        {
                                          v212 = __nw_create_backtrace_string();
                                          v179 = __nwlog_obj();
                                          v213 = type;
                                          v214 = os_log_type_enabled(v179, type);
                                          if (v212)
                                          {
                                            if (v214)
                                            {
                                              *buf = 136446466;
                                              v238 = "nw_necp_append_tlv";
                                              v239 = 2082;
                                              *v240 = v212;
                                              _os_log_impl(&dword_181A37000, v179, v213, "%{public}s called with null beyond, dumping backtrace:%{public}s", buf, 0x16u);
                                            }

                                            free(v212);
                                            if (!v178)
                                            {
                                              goto LABEL_232;
                                            }

LABEL_509:
                                            v115 = v178;
                                            goto LABEL_231;
                                          }

                                          if (v214)
                                          {
                                            *buf = 136446210;
                                            v238 = "nw_necp_append_tlv";
                                            _os_log_impl(&dword_181A37000, v179, v213, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
                                          }
                                        }

                                        else
                                        {
                                          v179 = __nwlog_obj();
                                          v222 = type;
                                          if (os_log_type_enabled(v179, type))
                                          {
                                            *buf = 136446210;
                                            v238 = "nw_necp_append_tlv";
                                            _os_log_impl(&dword_181A37000, v179, v222, "%{public}s called with null beyond, backtrace limit exceeded", buf, 0xCu);
                                          }
                                        }
                                      }

                                      else
                                      {
                                        v177 = __nwlog_obj();
                                        *buf = 136446210;
                                        v238 = "nw_necp_append_tlv";
                                        v178 = _os_log_send_and_compose_impl();

                                        type = OS_LOG_TYPE_ERROR;
                                        v232 = 0;
                                        if (!__nwlog_fault(v178, &type, &v232))
                                        {
                                          goto LABEL_508;
                                        }

                                        if (type == OS_LOG_TYPE_FAULT)
                                        {
                                          v179 = __nwlog_obj();
                                          v180 = type;
                                          if (os_log_type_enabled(v179, type))
                                          {
                                            *buf = 136446210;
                                            v238 = "nw_necp_append_tlv";
                                            _os_log_impl(&dword_181A37000, v179, v180, "%{public}s called with null tlv_start", buf, 0xCu);
                                          }
                                        }

                                        else if (v232 == 1)
                                        {
                                          v208 = __nw_create_backtrace_string();
                                          v179 = __nwlog_obj();
                                          v209 = type;
                                          v210 = os_log_type_enabled(v179, type);
                                          if (v208)
                                          {
                                            if (v210)
                                            {
                                              *buf = 136446466;
                                              v238 = "nw_necp_append_tlv";
                                              v239 = 2082;
                                              *v240 = v208;
                                              _os_log_impl(&dword_181A37000, v179, v209, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
                                            }

                                            free(v208);
LABEL_508:
                                            if (!v178)
                                            {
                                              goto LABEL_232;
                                            }

                                            goto LABEL_509;
                                          }

                                          if (v210)
                                          {
                                            *buf = 136446210;
                                            v238 = "nw_necp_append_tlv";
                                            _os_log_impl(&dword_181A37000, v179, v209, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
                                          }
                                        }

                                        else
                                        {
                                          v179 = __nwlog_obj();
                                          v221 = type;
                                          if (os_log_type_enabled(v179, type))
                                          {
                                            *buf = 136446210;
                                            v238 = "nw_necp_append_tlv";
                                            _os_log_impl(&dword_181A37000, v179, v221, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
                                          }
                                        }
                                      }

                                      goto LABEL_508;
                                    }

                                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                    networkd_settings_init();
                                    v89 = gLogObj;
                                    *buf = 136447490;
                                    v238 = "nw_necp_append_tlv";
                                    v239 = 2048;
                                    *v240 = v49;
                                    *&v240[8] = 2048;
                                    *&v240[10] = 47;
                                    *&v240[18] = 2048;
                                    *v241 = v27;
                                    *&v241[8] = 1024;
                                    *v242 = 222;
                                    *&v242[4] = 1024;
                                    *&v242[6] = 42;
                                    v90 = _os_log_send_and_compose_impl();

                                    type = OS_LOG_TYPE_ERROR;
                                    v232 = 0;
                                    if (__nwlog_fault(v90, &type, &v232))
                                    {
                                      if (type == OS_LOG_TYPE_FAULT)
                                      {
                                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                        networkd_settings_init();
                                        v91 = gLogObj;
                                        v92 = type;
                                        if (os_log_type_enabled(v91, type))
                                        {
                                          *buf = 136447490;
                                          v238 = "nw_necp_append_tlv";
                                          v239 = 2048;
                                          *v240 = v49;
                                          *&v240[8] = 2048;
                                          *&v240[10] = 47;
                                          *&v240[18] = 2048;
                                          *v241 = v27;
                                          *&v241[8] = 1024;
                                          *v242 = 222;
                                          *&v242[4] = 1024;
                                          *&v242[6] = 42;
                                          _os_log_impl(&dword_181A37000, v91, v92, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
                                        }
                                      }

                                      else if (v232 == 1)
                                      {
                                        v95 = __nw_create_backtrace_string();
                                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                        networkd_settings_init();
                                        v91 = gLogObj;
                                        v96 = type;
                                        v97 = os_log_type_enabled(v91, type);
                                        if (v95)
                                        {
                                          if (v97)
                                          {
                                            *buf = 136447746;
                                            v238 = "nw_necp_append_tlv";
                                            v239 = 2048;
                                            *v240 = v49;
                                            *&v240[8] = 2048;
                                            *&v240[10] = 47;
                                            *&v240[18] = 2048;
                                            *v241 = v27;
                                            *&v241[8] = 1024;
                                            *v242 = 222;
                                            *&v242[4] = 1024;
                                            *&v242[6] = 42;
                                            v243 = 2082;
                                            v244 = v95;
                                            _os_log_impl(&dword_181A37000, v91, v96, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                                          }

                                          free(v95);
                                          if (!v90)
                                          {
                                            goto LABEL_199;
                                          }

LABEL_197:
                                          v99 = v90;
LABEL_198:
                                          free(v99);
                                          goto LABEL_199;
                                        }

                                        if (v97)
                                        {
                                          *buf = 136447490;
                                          v238 = "nw_necp_append_tlv";
                                          v239 = 2048;
                                          *v240 = v49;
                                          *&v240[8] = 2048;
                                          *&v240[10] = 47;
                                          *&v240[18] = 2048;
                                          *v241 = v27;
                                          *&v241[8] = 1024;
                                          *v242 = 222;
                                          *&v242[4] = 1024;
                                          *&v242[6] = 42;
                                          _os_log_impl(&dword_181A37000, v91, v96, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
                                        }
                                      }

                                      else
                                      {
                                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                        networkd_settings_init();
                                        v91 = gLogObj;
                                        v98 = type;
                                        if (os_log_type_enabled(v91, type))
                                        {
                                          *buf = 136447490;
                                          v238 = "nw_necp_append_tlv";
                                          v239 = 2048;
                                          *v240 = v49;
                                          *&v240[8] = 2048;
                                          *&v240[10] = 47;
                                          *&v240[18] = 2048;
                                          *v241 = v27;
                                          *&v241[8] = 1024;
                                          *v242 = 222;
                                          *&v242[4] = 1024;
                                          *&v242[6] = 42;
                                          _os_log_impl(&dword_181A37000, v91, v98, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
                                        }
                                      }

                                      goto LABEL_195;
                                    }

LABEL_196:
                                    if (!v90)
                                    {
LABEL_199:
                                      v49 = 0;
                                      goto LABEL_200;
                                    }

                                    goto LABEL_197;
                                  }

                                  v139 = __nwlog_obj();
                                  *buf = 136447234;
                                  v238 = "nw_necp_append_tlv";
                                  v239 = 2048;
                                  *v240 = v49;
                                  *&v240[8] = 2048;
                                  *&v240[10] = v27;
                                  *&v240[18] = 1024;
                                  *v241 = 222;
                                  *&v241[4] = 1024;
                                  *&v241[6] = 42;
                                  v90 = _os_log_send_and_compose_impl();

                                  type = OS_LOG_TYPE_ERROR;
                                  v232 = 0;
                                  if (!__nwlog_fault(v90, &type, &v232))
                                  {
                                    goto LABEL_196;
                                  }

                                  if (type == OS_LOG_TYPE_FAULT)
                                  {
                                    v91 = __nwlog_obj();
                                    v140 = type;
                                    if (os_log_type_enabled(v91, type))
                                    {
                                      *buf = 136447234;
                                      v238 = "nw_necp_append_tlv";
                                      v239 = 2048;
                                      *v240 = v49;
                                      *&v240[8] = 2048;
                                      *&v240[10] = v27;
                                      *&v240[18] = 1024;
                                      *v241 = 222;
                                      *&v241[4] = 1024;
                                      *&v241[6] = 42;
                                      _os_log_impl(&dword_181A37000, v91, v140, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
                                    }
                                  }

                                  else if (v232 == 1)
                                  {
                                    v173 = __nw_create_backtrace_string();
                                    v91 = __nwlog_obj();
                                    v174 = type;
                                    v175 = os_log_type_enabled(v91, type);
                                    if (v173)
                                    {
                                      if (v175)
                                      {
                                        *buf = 136447490;
                                        v238 = "nw_necp_append_tlv";
                                        v239 = 2048;
                                        *v240 = v49;
                                        *&v240[8] = 2048;
                                        *&v240[10] = v27;
                                        *&v240[18] = 1024;
                                        *v241 = 222;
                                        *&v241[4] = 1024;
                                        *&v241[6] = 42;
                                        *v242 = 2082;
                                        *&v242[2] = v173;
                                        _os_log_impl(&dword_181A37000, v91, v174, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
                                      }

                                      free(v173);
                                      goto LABEL_196;
                                    }

                                    if (v175)
                                    {
                                      *buf = 136447234;
                                      v238 = "nw_necp_append_tlv";
                                      v239 = 2048;
                                      *v240 = v49;
                                      *&v240[8] = 2048;
                                      *&v240[10] = v27;
                                      *&v240[18] = 1024;
                                      *v241 = 222;
                                      *&v241[4] = 1024;
                                      *&v241[6] = 42;
                                      _os_log_impl(&dword_181A37000, v91, v174, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
                                    }
                                  }

                                  else
                                  {
                                    v91 = __nwlog_obj();
                                    v206 = type;
                                    if (os_log_type_enabled(v91, type))
                                    {
                                      *buf = 136447234;
                                      v238 = "nw_necp_append_tlv";
                                      v239 = 2048;
                                      *v240 = v49;
                                      *&v240[8] = 2048;
                                      *&v240[10] = v27;
                                      *&v240[18] = 1024;
                                      *v241 = 222;
                                      *&v241[4] = 1024;
                                      *&v241[6] = 42;
                                      _os_log_impl(&dword_181A37000, v91, v206, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
                                    }
                                  }

LABEL_195:

                                  goto LABEL_196;
                                }

                                v135 = __nwlog_obj();
                                *buf = 136446210;
                                v238 = "nw_necp_append_tlv";
                                v130 = _os_log_send_and_compose_impl();

                                type = OS_LOG_TYPE_ERROR;
                                v232 = 0;
                                if (__nwlog_fault(v130, &type, &v232))
                                {
                                  if (type == OS_LOG_TYPE_FAULT)
                                  {
                                    v131 = __nwlog_obj();
                                    v136 = type;
                                    if (os_log_type_enabled(v131, type))
                                    {
                                      *buf = 136446210;
                                      v238 = "nw_necp_append_tlv";
                                      _os_log_impl(&dword_181A37000, v131, v136, "%{public}s called with null beyond", buf, 0xCu);
                                    }

LABEL_476:

                                    goto LABEL_477;
                                  }

                                  if (v232 != 1)
                                  {
                                    v131 = __nwlog_obj();
                                    v201 = type;
                                    if (os_log_type_enabled(v131, type))
                                    {
                                      *buf = 136446210;
                                      v238 = "nw_necp_append_tlv";
                                      _os_log_impl(&dword_181A37000, v131, v201, "%{public}s called with null beyond, backtrace limit exceeded", buf, 0xCu);
                                    }

                                    goto LABEL_476;
                                  }

                                  v160 = __nw_create_backtrace_string();
                                  v131 = __nwlog_obj();
                                  v168 = type;
                                  v169 = os_log_type_enabled(v131, type);
                                  if (!v160)
                                  {
                                    if (v169)
                                    {
                                      *buf = 136446210;
                                      v238 = "nw_necp_append_tlv";
                                      _os_log_impl(&dword_181A37000, v131, v168, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
                                    }

                                    goto LABEL_476;
                                  }

                                  if (v169)
                                  {
                                    *buf = 136446466;
                                    v238 = "nw_necp_append_tlv";
                                    v239 = 2082;
                                    *v240 = v160;
                                    _os_log_impl(&dword_181A37000, v131, v168, "%{public}s called with null beyond, dumping backtrace:%{public}s", buf, 0x16u);
                                  }

                                  goto LABEL_338;
                                }
                              }

                              else
                              {
                                v129 = __nwlog_obj();
                                *buf = 136446210;
                                v238 = "nw_necp_append_tlv";
                                v130 = _os_log_send_and_compose_impl();

                                type = OS_LOG_TYPE_ERROR;
                                v232 = 0;
                                if (__nwlog_fault(v130, &type, &v232))
                                {
                                  if (type == OS_LOG_TYPE_FAULT)
                                  {
                                    v131 = __nwlog_obj();
                                    v132 = type;
                                    if (os_log_type_enabled(v131, type))
                                    {
                                      *buf = 136446210;
                                      v238 = "nw_necp_append_tlv";
                                      _os_log_impl(&dword_181A37000, v131, v132, "%{public}s called with null tlv_start", buf, 0xCu);
                                    }

                                    goto LABEL_476;
                                  }

                                  if (v232 != 1)
                                  {
                                    v131 = __nwlog_obj();
                                    v196 = type;
                                    if (os_log_type_enabled(v131, type))
                                    {
                                      *buf = 136446210;
                                      v238 = "nw_necp_append_tlv";
                                      _os_log_impl(&dword_181A37000, v131, v196, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
                                    }

                                    goto LABEL_476;
                                  }

                                  v160 = __nw_create_backtrace_string();
                                  v131 = __nwlog_obj();
                                  v161 = type;
                                  v162 = os_log_type_enabled(v131, type);
                                  if (!v160)
                                  {
                                    if (v162)
                                    {
                                      *buf = 136446210;
                                      v238 = "nw_necp_append_tlv";
                                      _os_log_impl(&dword_181A37000, v131, v161, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
                                    }

                                    goto LABEL_476;
                                  }

                                  if (v162)
                                  {
                                    *buf = 136446466;
                                    v238 = "nw_necp_append_tlv";
                                    v239 = 2082;
                                    *v240 = v160;
                                    _os_log_impl(&dword_181A37000, v131, v161, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
                                  }

LABEL_338:

                                  free(v160);
                                }
                              }

LABEL_477:
                              if (!v130)
                              {
                                goto LABEL_199;
                              }

                              v99 = v130;
                              goto LABEL_198;
                            }

LABEL_126:
                            if (v72)
                            {
                              goto LABEL_173;
                            }

                            goto LABEL_127;
                          }

                          goto LABEL_168;
                        }

                        v137 = __nwlog_obj();
                        *buf = 136447234;
                        v238 = "nw_necp_append_tlv";
                        v239 = 2048;
                        *v240 = v49;
                        *&v240[8] = 2048;
                        *&v240[10] = v27;
                        *&v240[18] = 1024;
                        *v241 = 103;
                        *&v241[4] = 1024;
                        *&v241[6] = 4;
                        v80 = _os_log_send_and_compose_impl();

                        type = OS_LOG_TYPE_ERROR;
                        v232 = 0;
                        if (!__nwlog_fault(v80, &type, &v232))
                        {
                          goto LABEL_167;
                        }

                        if (type == OS_LOG_TYPE_FAULT)
                        {
                          v81 = __nwlog_obj();
                          v138 = type;
                          if (os_log_type_enabled(v81, type))
                          {
                            *buf = 136447234;
                            v238 = "nw_necp_append_tlv";
                            v239 = 2048;
                            *v240 = v49;
                            *&v240[8] = 2048;
                            *&v240[10] = v27;
                            *&v240[18] = 1024;
                            *v241 = 103;
                            *&v241[4] = 1024;
                            *&v241[6] = 4;
                            _os_log_impl(&dword_181A37000, v81, v138, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
                          }
                        }

                        else if (v232 == 1)
                        {
                          v170 = __nw_create_backtrace_string();
                          v81 = __nwlog_obj();
                          v171 = type;
                          v172 = os_log_type_enabled(v81, type);
                          if (v170)
                          {
                            if (v172)
                            {
                              *buf = 136447490;
                              v238 = "nw_necp_append_tlv";
                              v239 = 2048;
                              *v240 = v49;
                              *&v240[8] = 2048;
                              *&v240[10] = v27;
                              *&v240[18] = 1024;
                              *v241 = 103;
                              *&v241[4] = 1024;
                              *&v241[6] = 4;
                              *v242 = 2082;
                              *&v242[2] = v170;
                              _os_log_impl(&dword_181A37000, v81, v171, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
                            }

                            free(v170);
                            goto LABEL_167;
                          }

                          if (v172)
                          {
                            *buf = 136447234;
                            v238 = "nw_necp_append_tlv";
                            v239 = 2048;
                            *v240 = v49;
                            *&v240[8] = 2048;
                            *&v240[10] = v27;
                            *&v240[18] = 1024;
                            *v241 = 103;
                            *&v241[4] = 1024;
                            *&v241[6] = 4;
                            _os_log_impl(&dword_181A37000, v81, v171, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
                          }
                        }

                        else
                        {
                          v81 = __nwlog_obj();
                          v205 = type;
                          if (os_log_type_enabled(v81, type))
                          {
                            *buf = 136447234;
                            v238 = "nw_necp_append_tlv";
                            v239 = 2048;
                            *v240 = v49;
                            *&v240[8] = 2048;
                            *&v240[10] = v27;
                            *&v240[18] = 1024;
                            *v241 = 103;
                            *&v241[4] = 1024;
                            *&v241[6] = 4;
                            _os_log_impl(&dword_181A37000, v81, v205, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
                          }
                        }

LABEL_166:

                        goto LABEL_167;
                      }

                      v133 = __nwlog_obj();
                      *buf = 136446210;
                      v238 = "nw_necp_append_tlv";
                      v126 = _os_log_send_and_compose_impl();

                      type = OS_LOG_TYPE_ERROR;
                      v232 = 0;
                      if (!__nwlog_fault(v126, &type, &v232))
                      {
                        goto LABEL_472;
                      }

                      if (type == OS_LOG_TYPE_FAULT)
                      {
                        v127 = __nwlog_obj();
                        v134 = type;
                        if (os_log_type_enabled(v127, type))
                        {
                          *buf = 136446210;
                          v238 = "nw_necp_append_tlv";
                          _os_log_impl(&dword_181A37000, v127, v134, "%{public}s called with null beyond", buf, 0xCu);
                        }
                      }

                      else if (v232 == 1)
                      {
                        v165 = __nw_create_backtrace_string();
                        v127 = __nwlog_obj();
                        v166 = type;
                        v167 = os_log_type_enabled(v127, type);
                        if (v165)
                        {
                          if (v167)
                          {
                            *buf = 136446466;
                            v238 = "nw_necp_append_tlv";
                            v239 = 2082;
                            *v240 = v165;
                            _os_log_impl(&dword_181A37000, v127, v166, "%{public}s called with null beyond, dumping backtrace:%{public}s", buf, 0x16u);
                          }

                          free(v165);
                          if (!v126)
                          {
                            goto LABEL_170;
                          }

LABEL_473:
                          v87 = v126;
                          goto LABEL_169;
                        }

                        if (v167)
                        {
                          *buf = 136446210;
                          v238 = "nw_necp_append_tlv";
                          _os_log_impl(&dword_181A37000, v127, v166, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
                        }
                      }

                      else
                      {
                        v127 = __nwlog_obj();
                        v200 = type;
                        if (os_log_type_enabled(v127, type))
                        {
                          *buf = 136446210;
                          v238 = "nw_necp_append_tlv";
                          _os_log_impl(&dword_181A37000, v127, v200, "%{public}s called with null beyond, backtrace limit exceeded", buf, 0xCu);
                        }
                      }
                    }

                    else
                    {
                      v125 = __nwlog_obj();
                      *buf = 136446210;
                      v238 = "nw_necp_append_tlv";
                      v126 = _os_log_send_and_compose_impl();

                      type = OS_LOG_TYPE_ERROR;
                      v232 = 0;
                      if (!__nwlog_fault(v126, &type, &v232))
                      {
                        goto LABEL_472;
                      }

                      if (type == OS_LOG_TYPE_FAULT)
                      {
                        v127 = __nwlog_obj();
                        v128 = type;
                        if (os_log_type_enabled(v127, type))
                        {
                          *buf = 136446210;
                          v238 = "nw_necp_append_tlv";
                          _os_log_impl(&dword_181A37000, v127, v128, "%{public}s called with null tlv_start", buf, 0xCu);
                        }
                      }

                      else if (v232 == 1)
                      {
                        v157 = __nw_create_backtrace_string();
                        v127 = __nwlog_obj();
                        v158 = type;
                        v159 = os_log_type_enabled(v127, type);
                        if (v157)
                        {
                          if (v159)
                          {
                            *buf = 136446466;
                            v238 = "nw_necp_append_tlv";
                            v239 = 2082;
                            *v240 = v157;
                            _os_log_impl(&dword_181A37000, v127, v158, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
                          }

                          free(v157);
LABEL_472:
                          if (!v126)
                          {
                            goto LABEL_170;
                          }

                          goto LABEL_473;
                        }

                        if (v159)
                        {
                          *buf = 136446210;
                          v238 = "nw_necp_append_tlv";
                          _os_log_impl(&dword_181A37000, v127, v158, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
                        }
                      }

                      else
                      {
                        v127 = __nwlog_obj();
                        v195 = type;
                        if (os_log_type_enabled(v127, type))
                        {
                          *buf = 136446210;
                          v238 = "nw_necp_append_tlv";
                          _os_log_impl(&dword_181A37000, v127, v195, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
                        }
                      }
                    }

                    goto LABEL_472;
                  }

LABEL_125:
                  v72 = v229;
                  if (v71)
                  {
                    goto LABEL_172;
                  }

                  goto LABEL_126;
                }

                *v49 = 102;
                *(v49 + 1) = a5;
                memcpy((v49 + 5), a4, a5);
                v49 += a5 + 5;
LABEL_124:
                v71 = v231;
                if (a6)
                {
                  goto LABEL_145;
                }

                goto LABEL_125;
              }

              v148 = __nwlog_obj();
              *buf = 136446210;
              v238 = "nw_necp_append_tlv";
              v145 = _os_log_send_and_compose_impl();

              type = OS_LOG_TYPE_ERROR;
              v232 = 0;
              if (!__nwlog_fault(v145, &type, &v232))
              {
                goto LABEL_491;
              }

              if (type == OS_LOG_TYPE_FAULT)
              {
                v146 = __nwlog_obj();
                v149 = type;
                if (os_log_type_enabled(v146, type))
                {
                  *buf = 136446210;
                  v238 = "nw_necp_append_tlv";
                  _os_log_impl(&dword_181A37000, v146, v149, "%{public}s called with null beyond", buf, 0xCu);
                }
              }

              else if (v232 == 1)
              {
                v186 = __nw_create_backtrace_string();
                v146 = __nwlog_obj();
                v187 = type;
                v188 = os_log_type_enabled(v146, type);
                if (v186)
                {
                  if (v188)
                  {
                    *buf = 136446466;
                    v238 = "nw_necp_append_tlv";
                    v239 = 2082;
                    *v240 = v186;
                    _os_log_impl(&dword_181A37000, v146, v187, "%{public}s called with null beyond, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v186);
                  if (!v145)
                  {
                    goto LABEL_144;
                  }

LABEL_492:
                  v78 = v145;
                  goto LABEL_143;
                }

                if (v188)
                {
                  *buf = 136446210;
                  v238 = "nw_necp_append_tlv";
                  _os_log_impl(&dword_181A37000, v146, v187, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
                }
              }

              else
              {
                v146 = __nwlog_obj();
                v211 = type;
                if (os_log_type_enabled(v146, type))
                {
                  *buf = 136446210;
                  v238 = "nw_necp_append_tlv";
                  _os_log_impl(&dword_181A37000, v146, v211, "%{public}s called with null beyond, backtrace limit exceeded", buf, 0xCu);
                }
              }
            }

            else
            {
              v144 = __nwlog_obj();
              *buf = 136446210;
              v238 = "nw_necp_append_tlv";
              v145 = _os_log_send_and_compose_impl();

              type = OS_LOG_TYPE_ERROR;
              v232 = 0;
              if (!__nwlog_fault(v145, &type, &v232))
              {
                goto LABEL_491;
              }

              if (type == OS_LOG_TYPE_FAULT)
              {
                v146 = __nwlog_obj();
                v147 = type;
                if (os_log_type_enabled(v146, type))
                {
                  *buf = 136446210;
                  v238 = "nw_necp_append_tlv";
                  _os_log_impl(&dword_181A37000, v146, v147, "%{public}s called with null tlv_start", buf, 0xCu);
                }
              }

              else if (v232 == 1)
              {
                v181 = __nw_create_backtrace_string();
                v146 = __nwlog_obj();
                v182 = type;
                v183 = os_log_type_enabled(v146, type);
                if (v181)
                {
                  if (v183)
                  {
                    *buf = 136446466;
                    v238 = "nw_necp_append_tlv";
                    v239 = 2082;
                    *v240 = v181;
                    _os_log_impl(&dword_181A37000, v146, v182, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v181);
LABEL_491:
                  if (!v145)
                  {
                    goto LABEL_144;
                  }

                  goto LABEL_492;
                }

                if (v183)
                {
                  *buf = 136446210;
                  v238 = "nw_necp_append_tlv";
                  _os_log_impl(&dword_181A37000, v146, v182, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
                }
              }

              else
              {
                v146 = __nwlog_obj();
                v207 = type;
                if (os_log_type_enabled(v146, type))
                {
                  *buf = 136446210;
                  v238 = "nw_necp_append_tlv";
                  _os_log_impl(&dword_181A37000, v146, v207, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
                }
              }
            }

            goto LABEL_491;
          }

LABEL_111:
          free(v40);
          goto LABEL_112;
        }

        v163 = __nwlog_obj();
        *buf = 136447234;
        v238 = "nw_necp_append_tlv";
        v239 = 2048;
        *v240 = v228 + 21;
        *&v240[8] = 2048;
        *&v240[10] = v27;
        *&v240[18] = 1024;
        *v241 = 101;
        *&v241[4] = 1024;
        *&v241[6] = 2;
        v58 = _os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v232 = 0;
        if (__nwlog_fault(v58, &type, &v232))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v59 = __nwlog_obj();
            v164 = type;
            if (os_log_type_enabled(v59, type))
            {
              *buf = 136447234;
              v238 = "nw_necp_append_tlv";
              v239 = 2048;
              *v240 = v228 + 21;
              *&v240[8] = 2048;
              *&v240[10] = v27;
              *&v240[18] = 1024;
              *v241 = 101;
              *&v241[4] = 1024;
              *&v241[6] = 2;
              _os_log_impl(&dword_181A37000, v59, v164, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
            }

LABEL_102:

            goto LABEL_103;
          }

          if (v232 != 1)
          {
            v59 = __nwlog_obj();
            v220 = type;
            if (os_log_type_enabled(v59, type))
            {
              *buf = 136447234;
              v238 = "nw_necp_append_tlv";
              v239 = 2048;
              *v240 = v228 + 21;
              *&v240[8] = 2048;
              *&v240[10] = v27;
              *&v240[18] = 1024;
              *v241 = 101;
              *&v241[4] = 1024;
              *&v241[6] = 2;
              _os_log_impl(&dword_181A37000, v59, v220, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
            }

            goto LABEL_102;
          }

          v202 = __nw_create_backtrace_string();
          v59 = __nwlog_obj();
          v203 = type;
          v204 = os_log_type_enabled(v59, type);
          if (!v202)
          {
            if (v204)
            {
              *buf = 136447234;
              v238 = "nw_necp_append_tlv";
              v239 = 2048;
              *v240 = v228 + 21;
              *&v240[8] = 2048;
              *&v240[10] = v27;
              *&v240[18] = 1024;
              *v241 = 101;
              *&v241[4] = 1024;
              *&v241[6] = 2;
              _os_log_impl(&dword_181A37000, v59, v203, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
            }

            goto LABEL_102;
          }

          if (v204)
          {
            *buf = 136447490;
            v238 = "nw_necp_append_tlv";
            v239 = 2048;
            *v240 = v228 + 21;
            *&v240[8] = 2048;
            *&v240[10] = v27;
            *&v240[18] = 1024;
            *v241 = 101;
            *&v241[4] = 1024;
            *&v241[6] = 2;
            *v242 = 2082;
            *&v242[2] = v202;
            _os_log_impl(&dword_181A37000, v59, v203, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
          }

          free(v202);
        }

LABEL_103:
        v64 = a4 != 0 && a5 != 0;
        if (!v58)
        {
          goto LABEL_105;
        }

        goto LABEL_104;
      }

      v152 = __nwlog_obj();
      *buf = 136446722;
      v238 = "nw_necp_append_tlv";
      v239 = 1024;
      *v240 = 100;
      *&v240[4] = 1024;
      *&v240[6] = 16;
      v29 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v232 = 0;
      if (__nwlog_fault(v29, &type, &v232))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v30 = __nwlog_obj();
          v153 = type;
          if (os_log_type_enabled(v30, type))
          {
            *buf = 136446722;
            v238 = "nw_necp_append_tlv";
            v239 = 1024;
            *v240 = 100;
            *&v240[4] = 1024;
            *&v240[6] = 16;
            _os_log_impl(&dword_181A37000, v30, v153, "%{public}s type=%u length=%u but value is NULL", buf, 0x18u);
          }

LABEL_83:

          goto LABEL_84;
        }

        if (v232 != 1)
        {
          v30 = __nwlog_obj();
          v219 = type;
          if (os_log_type_enabled(v30, type))
          {
            *buf = 136446722;
            v238 = "nw_necp_append_tlv";
            v239 = 1024;
            *v240 = 100;
            *&v240[4] = 1024;
            *&v240[6] = 16;
            _os_log_impl(&dword_181A37000, v30, v219, "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded", buf, 0x18u);
          }

          goto LABEL_83;
        }

        v197 = __nw_create_backtrace_string();
        v30 = __nwlog_obj();
        v198 = type;
        v199 = os_log_type_enabled(v30, type);
        if (!v197)
        {
          if (v199)
          {
            *buf = 136446722;
            v238 = "nw_necp_append_tlv";
            v239 = 1024;
            *v240 = 100;
            *&v240[4] = 1024;
            *&v240[6] = 16;
            _os_log_impl(&dword_181A37000, v30, v198, "%{public}s type=%u length=%u but value is NULL, no backtrace", buf, 0x18u);
          }

          goto LABEL_83;
        }

        if (v199)
        {
          *buf = 136446978;
          v238 = "nw_necp_append_tlv";
          v239 = 1024;
          *v240 = 100;
          *&v240[4] = 1024;
          *&v240[6] = 16;
          *&v240[10] = 2082;
          *&v240[12] = v197;
          _os_log_impl(&dword_181A37000, v30, v198, "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s", buf, 0x22u);
        }

        free(v197);
      }
    }

LABEL_84:
    if (v29)
    {
LABEL_85:
      free(v29);
    }

LABEL_86:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v57 = gLogObj;
    *buf = 136446210;
    v238 = "nw_necp_append_tlv";
    v58 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v232 = 0;
    if (!__nwlog_fault(v58, &type, &v232))
    {
      goto LABEL_103;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v59 = gLogObj;
      v60 = type;
      if (os_log_type_enabled(v59, type))
      {
        *buf = 136446210;
        v238 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A37000, v59, v60, "%{public}s called with null tlv_start", buf, 0xCu);
      }
    }

    else if (v232 == 1)
    {
      v61 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v59 = gLogObj;
      v62 = type;
      v63 = os_log_type_enabled(v59, type);
      if (v61)
      {
        if (v63)
        {
          *buf = 136446466;
          v238 = "nw_necp_append_tlv";
          v239 = 2082;
          *v240 = v61;
          _os_log_impl(&dword_181A37000, v59, v62, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v61);
        v64 = a4 != 0 && a5 != 0;
        if (!v58)
        {
LABEL_105:
          v49 = 0;
          if (!v64)
          {
            goto LABEL_124;
          }

          goto LABEL_114;
        }

LABEL_104:
        free(v58);
        goto LABEL_105;
      }

      if (v63)
      {
        *buf = 136446210;
        v238 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A37000, v59, v62, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v59 = gLogObj;
      v65 = type;
      if (os_log_type_enabled(v59, type))
      {
        *buf = 136446210;
        v238 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A37000, v59, v65, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_102;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v32 = gLogObj;
  os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v238 = "nw_path_create_assign_message_internal";
  v239 = 2048;
  *v240 = 1;
  *&v240[8] = 2048;
  *&v240[10] = v25;
  v33 = _os_log_send_and_compose_impl();

  result = __nwlog_should_abort(v33);
  if (!result)
  {
    free(v33);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v35 = gLogObj;
    *buf = 136446210;
    v238 = "nw_necp_append_tlv";
    v36 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v232 = 0;
    if (__nwlog_fault(v36, &type, &v232))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v37 = gLogObj;
        v38 = type;
        if (os_log_type_enabled(v37, type))
        {
          *buf = 136446210;
          v238 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A37000, v37, v38, "%{public}s called with null tlv_start", buf, 0xCu);
        }
      }

      else if (v232 == 1)
      {
        v43 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v37 = gLogObj;
        v44 = type;
        v45 = os_log_type_enabled(v37, type);
        if (v43)
        {
          if (v45)
          {
            *buf = 136446466;
            v238 = "nw_necp_append_tlv";
            v239 = 2082;
            *v240 = v43;
            _os_log_impl(&dword_181A37000, v37, v44, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v43);
          if (!v36)
          {
            goto LABEL_80;
          }

          goto LABEL_79;
        }

        if (v45)
        {
          *buf = 136446210;
          v238 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A37000, v37, v44, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v37 = gLogObj;
        v50 = type;
        if (os_log_type_enabled(v37, type))
        {
          *buf = 136446210;
          v238 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A37000, v37, v50, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v36)
    {
LABEL_80:
      v27 = v227;
      goto LABEL_86;
    }

LABEL_79:
    free(v36);
    goto LABEL_80;
  }

LABEL_513:
  __break(1u);
  return result;
}

uint64_t __nw_path_create_necp_agent_group_action_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  *(*(*(a1 + 32) + 8) + 24) += nw_path_struct_size_for_endpoint_and_metadata(v4, 0, 7);
  ++*(*(*(a1 + 40) + 8) + 24);

  return 1;
}

uint64_t __nw_path_create_necp_agent_group_action_block_invoke_25(void *a1, uint64_t a2, void *a3)
{
  v4 = a3;
  *(*(a1[4] + 8) + 24) = nw_path_evaluator_add_endpoint_to_necp_message(v4, 213, *(*(a1[4] + 8) + 24), a1[6] + *(*(a1[5] + 8) + 24) + 18, 7);

  return 1;
}

uint64_t nw_protocol_create_deserialized_options(uint64_t a1, const void *a2, size_t a3)
{
  v17 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_protocol_create_deserialized_options(a1, a2, a3);
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v14 = "nw_protocol_create_deserialized_options";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v14 = "nw_protocol_create_deserialized_options";
        v8 = "%{public}s called with null definition";
LABEL_18:
        _os_log_impl(&dword_181A37000, v6, v7, v8, buf, 0xCu);
      }
    }

    else
    {
      if (v11 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v6 = __nwlog_obj();
        v7 = type;
        v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *buf = 136446466;
            v14 = "nw_protocol_create_deserialized_options";
            v15 = 2082;
            v16 = backtrace_string;
            _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v10)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v14 = "nw_protocol_create_deserialized_options";
        v8 = "%{public}s called with null definition, no backtrace";
        goto LABEL_18;
      }

      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v14 = "nw_protocol_create_deserialized_options";
        v8 = "%{public}s called with null definition, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  return 0;
}

uint64_t nw_protocol_options_get_hash(uint64_t result)
{
  if (result)
  {
    return _nw_protocol_options_get_hash();
  }

  return result;
}

uint64_t nw_protocol_options_matches_identifier(void *a1, uint64_t a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
    {
      v5 = _nw_protocol_options_matches_identifier(v3, a2);
      goto LABEL_4;
    }

    v12 = __nwlog_obj();
    *buf = 136446210;
    v20 = "nw_protocol_options_matches_identifier";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v20 = "nw_protocol_options_matches_identifier";
          v11 = "%{public}s called with null identifier";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (v17 != 1)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v20 = "nw_protocol_options_matches_identifier";
          v11 = "%{public}s called with null identifier, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v16 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *buf = 136446210;
          v20 = "nw_protocol_options_matches_identifier";
          v11 = "%{public}s called with null identifier, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16)
      {
        goto LABEL_22;
      }

      *buf = 136446466;
      v20 = "nw_protocol_options_matches_identifier";
      v21 = 2082;
      v22 = backtrace_string;
      v15 = "%{public}s called with null identifier, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A37000, v9, v10, v15, buf, 0x16u);
LABEL_22:

      free(backtrace_string);
    }
  }

  else
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v20 = "nw_protocol_options_matches_identifier";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v20 = "nw_protocol_options_matches_identifier";
          v11 = "%{public}s called with null options";
LABEL_31:
          _os_log_impl(&dword_181A37000, v9, v10, v11, buf, 0xCu);
        }

LABEL_32:

        goto LABEL_33;
      }

      if (v17 != 1)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v20 = "nw_protocol_options_matches_identifier";
          v11 = "%{public}s called with null options, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v14 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v14)
        {
          *buf = 136446210;
          v20 = "nw_protocol_options_matches_identifier";
          v11 = "%{public}s called with null options, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v14)
      {
        goto LABEL_22;
      }

      *buf = 136446466;
      v20 = "nw_protocol_options_matches_identifier";
      v21 = 2082;
      v22 = backtrace_string;
      v15 = "%{public}s called with null options, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

LABEL_33:
  if (v8)
  {
    free(v8);
  }

  v5 = 0;
LABEL_4:

  return v5;
}

void nw_protocol_options_set_instance(uint64_t a1, uint64_t a2)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_options_set_instance(a1, a2);
    return;
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_options_set_instance";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_options_set_instance";
        v6 = "%{public}s called with null options";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_options_set_instance";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_options_set_instance";
        v6 = "%{public}s called with null options, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_options_set_instance";
        v6 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }
}

void nw_protocol_options_set_log_id(void *a1, const char *a2, _BYTE *a3, unsigned __int16 a4)
{
  v21 = *MEMORY[0x1E69E9840];
  v7 = a1;
  if (v7)
  {
    if (a3 && a2 && *a3 && strlen(a2) <= 1)
    {
      _nw_protocol_options_set_log_id(v7, *a2, a3, a4);
    }

    goto LABEL_7;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_protocol_options_set_log_id";
  v9 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v9, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v18 = "nw_protocol_options_set_log_id";
        v12 = "%{public}s called with null options";
LABEL_21:
        _os_log_impl(&dword_181A37000, v10, v11, v12, buf, 0xCu);
      }
    }

    else
    {
      if (v15 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v10 = __nwlog_obj();
        v11 = type;
        v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *buf = 136446466;
            v18 = "nw_protocol_options_set_log_id";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (!v14)
        {
          goto LABEL_22;
        }

        *buf = 136446210;
        v18 = "nw_protocol_options_set_log_id";
        v12 = "%{public}s called with null options, no backtrace";
        goto LABEL_21;
      }

      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v18 = "nw_protocol_options_set_log_id";
        v12 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_21;
      }
    }

LABEL_22:
  }

LABEL_23:
  if (v9)
  {
    free(v9);
  }

LABEL_7:
}

void nw_protocol_options_set_proxy_endpoint(uint64_t a1, void *a2, char a3)
{
  v16 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_options_set_proxy_endpoint(a1, a2, a3);
    return;
  }

  v3 = __nwlog_obj();
  *buf = 136446210;
  v13 = "nw_protocol_options_set_proxy_endpoint";
  v4 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v13 = "nw_protocol_options_set_proxy_endpoint";
        v7 = "%{public}s called with null options";
LABEL_18:
        _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0xCu);
      }
    }

    else
    {
      if (v10 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v5 = __nwlog_obj();
        v6 = type;
        v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *buf = 136446466;
            v13 = "nw_protocol_options_set_proxy_endpoint";
            v14 = 2082;
            v15 = backtrace_string;
            _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v9)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v13 = "nw_protocol_options_set_proxy_endpoint";
        v7 = "%{public}s called with null options, no backtrace";
        goto LABEL_18;
      }

      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v13 = "nw_protocol_options_set_proxy_endpoint";
        v7 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v4)
  {
    free(v4);
  }
}

uint64_t nw_protocol_options_copy_proxy_endpoint_for_stack(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_protocol_options_copy_proxy_endpoint_for_stack();
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_options_copy_proxy_endpoint_for_stack";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_options_copy_proxy_endpoint_for_stack";
        v6 = "%{public}s called with null options";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_options_copy_proxy_endpoint_for_stack";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_options_copy_proxy_endpoint_for_stack";
        v6 = "%{public}s called with null options, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_options_copy_proxy_endpoint_for_stack";
        v6 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

void nw_protocol_options_add_proxy_next_hop(void *a1, void *a2)
{
  v18 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (v4)
  {
    _nw_protocol_options_add_proxy_next_hop(v3, v4);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_protocol_options_add_proxy_next_hop";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v15 = "nw_protocol_options_add_proxy_next_hop";
        v9 = "%{public}s called with null proxy_next_hop";
LABEL_17:
        _os_log_impl(&dword_181A37000, v7, v8, v9, buf, 0xCu);
      }
    }

    else
    {
      if (v12 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v8 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *buf = 136446466;
            v15 = "nw_protocol_options_add_proxy_next_hop";
            v16 = 2082;
            v17 = backtrace_string;
            _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null proxy_next_hop, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v11)
        {
          goto LABEL_18;
        }

        *buf = 136446210;
        v15 = "nw_protocol_options_add_proxy_next_hop";
        v9 = "%{public}s called with null proxy_next_hop, no backtrace";
        goto LABEL_17;
      }

      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v15 = "nw_protocol_options_add_proxy_next_hop";
        v9 = "%{public}s called with null proxy_next_hop, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

LABEL_18:
  }

LABEL_19:
  if (v6)
  {
    free(v6);
  }

LABEL_3:
}

void nw_protocol_options_enumerate_proxy_next_hops(void *a1, void *a2)
{
  v22 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    v6 = __nwlog_obj();
    *buf = 136446210;
    v19 = "nw_protocol_options_enumerate_proxy_next_hops";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v7, &type, &v16))
    {
      goto LABEL_34;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_options_enumerate_proxy_next_hops";
        v10 = "%{public}s called with null options";
LABEL_32:
        _os_log_impl(&dword_181A37000, v8, v9, v10, buf, 0xCu);
      }
    }

    else if (v16 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v13 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v19 = "nw_protocol_options_enumerate_proxy_next_hops";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v7)
        {
          goto LABEL_4;
        }

LABEL_35:
        free(v7);
        goto LABEL_4;
      }

      if (v13)
      {
        *buf = 136446210;
        v19 = "nw_protocol_options_enumerate_proxy_next_hops";
        v10 = "%{public}s called with null options, no backtrace";
        goto LABEL_32;
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_options_enumerate_proxy_next_hops";
        v10 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

LABEL_33:

    goto LABEL_34;
  }

  if (v4)
  {
    _nw_protocol_options_enumerate_proxy_next_hops(v3, v4);
    goto LABEL_4;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v19 = "nw_protocol_options_enumerate_proxy_next_hops";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v7, &type, &v16))
  {
    goto LABEL_34;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (os_log_type_enabled(v8, type))
    {
      *buf = 136446210;
      v19 = "nw_protocol_options_enumerate_proxy_next_hops";
      v10 = "%{public}s called with null enumerator";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v16 != 1)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (os_log_type_enabled(v8, type))
    {
      *buf = 136446210;
      v19 = "nw_protocol_options_enumerate_proxy_next_hops";
      v10 = "%{public}s called with null enumerator, backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  v14 = __nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v9 = type;
  v15 = os_log_type_enabled(v8, type);
  if (!v14)
  {
    if (v15)
    {
      *buf = 136446210;
      v19 = "nw_protocol_options_enumerate_proxy_next_hops";
      v10 = "%{public}s called with null enumerator, no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v15)
  {
    *buf = 136446466;
    v19 = "nw_protocol_options_enumerate_proxy_next_hops";
    v20 = 2082;
    v21 = v14;
    _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null enumerator, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v7)
  {
    goto LABEL_35;
  }

LABEL_4:
}

uint64_t nw_protocol_metadata_matches_definition(uint64_t a1, NSObject *a2)
{
  v19 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v3 = __nwlog_obj();
    *buf = 136446210;
    v16 = "nw_protocol_metadata_matches_definition";
    v4 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v4, &type, &v13))
    {
      goto LABEL_35;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v16 = "nw_protocol_metadata_matches_definition";
        v7 = "%{public}s called with null metadata";
LABEL_33:
        _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v10 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v16 = "nw_protocol_metadata_matches_definition";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_35:
        if (!v4)
        {
          return 0;
        }

LABEL_36:
        free(v4);
        return 0;
      }

      if (v10)
      {
        *buf = 136446210;
        v16 = "nw_protocol_metadata_matches_definition";
        v7 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_33;
      }
    }

    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v16 = "nw_protocol_metadata_matches_definition";
        v7 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_33;
      }
    }

LABEL_34:

    goto LABEL_35;
  }

  if (!a2)
  {
    v8 = __nwlog_obj();
    *buf = 136446210;
    v16 = "nw_protocol_metadata_matches_definition";
    v4 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v4, &type, &v13))
    {
      goto LABEL_35;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v16 = "nw_protocol_metadata_matches_definition";
        v7 = "%{public}s called with null definition";
        goto LABEL_33;
      }
    }

    else
    {
      if (v13 == 1)
      {
        v11 = __nw_create_backtrace_string();
        v5 = __nwlog_obj();
        v6 = type;
        v12 = os_log_type_enabled(v5, type);
        if (v11)
        {
          if (v12)
          {
            *buf = 136446466;
            v16 = "nw_protocol_metadata_matches_definition";
            v17 = 2082;
            v18 = v11;
            _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v11);
          if (!v4)
          {
            return 0;
          }

          goto LABEL_36;
        }

        if (!v12)
        {
          goto LABEL_34;
        }

        *buf = 136446210;
        v16 = "nw_protocol_metadata_matches_definition";
        v7 = "%{public}s called with null definition, no backtrace";
        goto LABEL_33;
      }

      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v16 = "nw_protocol_metadata_matches_definition";
        v7 = "%{public}s called with null definition, backtrace limit exceeded";
        goto LABEL_33;
      }
    }

    goto LABEL_34;
  }

  return _nw_protocol_metadata_matches_definition(a1, a2);
}

uint64_t nw_protocol_metadata_is_equal(void *a1, void *a2, unsigned int a3)
{
  v5 = a1;
  v6 = a2;
  v7 = v6;
  if (v5 == v6)
  {
    is_equal = 1;
  }

  else
  {
    is_equal = 0;
    if (v5 && v6)
    {
      is_equal = _nw_protocol_metadata_is_equal(v5, v6, a3);
    }
  }

  return is_equal;
}

uint64_t sa_dst_compare(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  v18 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v15 = "sa_dst_compare";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
    {
      goto LABEL_34;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v15 = "sa_dst_compare";
      v7 = "%{public}s called with null dst1";
      goto LABEL_33;
    }

    if (v12 != 1)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v15 = "sa_dst_compare";
      v7 = "%{public}s called with null dst1, backtrace limit exceeded";
      goto LABEL_33;
    }

    backtrace_string = __nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (!v9)
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v15 = "sa_dst_compare";
      v7 = "%{public}s called with null dst1, no backtrace";
      goto LABEL_33;
    }

    if (v9)
    {
      *buf = 136446466;
      v15 = "sa_dst_compare";
      v16 = 2082;
      v17 = backtrace_string;
      _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null dst1, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
LABEL_34:
    if (!v4)
    {
      return 0;
    }

LABEL_35:
    free(v4);
    return 0;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v15 = "sa_dst_compare";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
    {
      goto LABEL_34;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v15 = "sa_dst_compare";
      v7 = "%{public}s called with null dst2";
      goto LABEL_33;
    }

    if (v12 != 1)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v15 = "sa_dst_compare";
      v7 = "%{public}s called with null dst2, backtrace limit exceeded";
      goto LABEL_33;
    }

    v10 = __nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v11 = os_log_type_enabled(v5, type);
    if (v10)
    {
      if (v11)
      {
        *buf = 136446466;
        v15 = "sa_dst_compare";
        v16 = 2082;
        v17 = v10;
        _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null dst2, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v10);
      if (!v4)
      {
        return 0;
      }

      goto LABEL_35;
    }

    if (v11)
    {
      *buf = 136446210;
      v15 = "sa_dst_compare";
      v7 = "%{public}s called with null dst2, no backtrace";
LABEL_33:
      _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0xCu);
      goto LABEL_34;
    }

    goto LABEL_34;
  }

  return sa_dst_compare_internal(a1, a3, a2, a3, 1);
}

uint64_t sa_dst_compare_no_stats(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  v18 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v15 = "sa_dst_compare_no_stats";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
    {
      goto LABEL_34;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v15 = "sa_dst_compare_no_stats";
      v7 = "%{public}s called with null dst1";
      goto LABEL_33;
    }

    if (v12 != 1)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v15 = "sa_dst_compare_no_stats";
      v7 = "%{public}s called with null dst1, backtrace limit exceeded";
      goto LABEL_33;
    }

    backtrace_string = __nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (!v9)
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v15 = "sa_dst_compare_no_stats";
      v7 = "%{public}s called with null dst1, no backtrace";
      goto LABEL_33;
    }

    if (v9)
    {
      *buf = 136446466;
      v15 = "sa_dst_compare_no_stats";
      v16 = 2082;
      v17 = backtrace_string;
      _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null dst1, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
LABEL_34:
    if (!v4)
    {
      return 0;
    }

LABEL_35:
    free(v4);
    return 0;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v15 = "sa_dst_compare_no_stats";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
    {
      goto LABEL_34;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v15 = "sa_dst_compare_no_stats";
      v7 = "%{public}s called with null dst2";
      goto LABEL_33;
    }

    if (v12 != 1)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v15 = "sa_dst_compare_no_stats";
      v7 = "%{public}s called with null dst2, backtrace limit exceeded";
      goto LABEL_33;
    }

    v10 = __nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v11 = os_log_type_enabled(v5, type);
    if (v10)
    {
      if (v11)
      {
        *buf = 136446466;
        v15 = "sa_dst_compare_no_stats";
        v16 = 2082;
        v17 = v10;
        _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null dst2, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v10);
      if (!v4)
      {
        return 0;
      }

      goto LABEL_35;
    }

    if (v11)
    {
      *buf = 136446210;
      v15 = "sa_dst_compare_no_stats";
      v7 = "%{public}s called with null dst2, no backtrace";
LABEL_33:
      _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0xCu);
      goto LABEL_34;
    }

    goto LABEL_34;
  }

  return sa_dst_compare_internal(a1, a3, a2, a3, 0);
}

uint64_t sa_dst_compare_no_dependencies(uint64_t a1, uint64_t a2)
{
  *&v49[5] = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v47 = "sa_dst_compare_no_dependencies";
    v36 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v36, &type, &v44))
    {
      goto LABEL_143;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v44 != 1)
      {
        v37 = __nwlog_obj();
        v38 = type;
        if (!os_log_type_enabled(v37, type))
        {
          goto LABEL_143;
        }

        *buf = 136446210;
        v47 = "sa_dst_compare_no_dependencies";
        v39 = "%{public}s called with null dst1, backtrace limit exceeded";
        goto LABEL_142;
      }

      backtrace_string = __nw_create_backtrace_string();
      v37 = __nwlog_obj();
      v38 = type;
      v41 = os_log_type_enabled(v37, type);
      if (!backtrace_string)
      {
        if (!v41)
        {
          goto LABEL_143;
        }

        *buf = 136446210;
        v47 = "sa_dst_compare_no_dependencies";
        v39 = "%{public}s called with null dst1, no backtrace";
        goto LABEL_142;
      }

      if (v41)
      {
        *buf = 136446466;
        v47 = "sa_dst_compare_no_dependencies";
        v48 = 2082;
        *v49 = backtrace_string;
        v42 = "%{public}s called with null dst1, dumping backtrace:%{public}s";
LABEL_132:
        _os_log_impl(&dword_181A37000, v37, v38, v42, buf, 0x16u);
      }

LABEL_133:
      free(backtrace_string);
      goto LABEL_143;
    }

    v37 = __nwlog_obj();
    v38 = type;
    if (!os_log_type_enabled(v37, type))
    {
      goto LABEL_143;
    }

    *buf = 136446210;
    v47 = "sa_dst_compare_no_dependencies";
    v39 = "%{public}s called with null dst1";
LABEL_142:
    _os_log_impl(&dword_181A37000, v37, v38, v39, buf, 0xCu);
LABEL_143:
    if (v36)
    {
      free(v36);
    }

    return 0;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v47 = "sa_dst_compare_no_dependencies";
    v36 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v36, &type, &v44))
    {
      goto LABEL_143;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v37 = __nwlog_obj();
      v38 = type;
      if (!os_log_type_enabled(v37, type))
      {
        goto LABEL_143;
      }

      *buf = 136446210;
      v47 = "sa_dst_compare_no_dependencies";
      v39 = "%{public}s called with null dst2";
      goto LABEL_142;
    }

    if (v44 != 1)
    {
      v37 = __nwlog_obj();
      v38 = type;
      if (!os_log_type_enabled(v37, type))
      {
        goto LABEL_143;
      }

      *buf = 136446210;
      v47 = "sa_dst_compare_no_dependencies";
      v39 = "%{public}s called with null dst2, backtrace limit exceeded";
      goto LABEL_142;
    }

    backtrace_string = __nw_create_backtrace_string();
    v37 = __nwlog_obj();
    v38 = type;
    v43 = os_log_type_enabled(v37, type);
    if (backtrace_string)
    {
      if (v43)
      {
        *buf = 136446466;
        v47 = "sa_dst_compare_no_dependencies";
        v48 = 2082;
        *v49 = backtrace_string;
        v42 = "%{public}s called with null dst2, dumping backtrace:%{public}s";
        goto LABEL_132;
      }

      goto LABEL_133;
    }

    if (!v43)
    {
      goto LABEL_143;
    }

    *buf = 136446210;
    v47 = "sa_dst_compare_no_dependencies";
    v39 = "%{public}s called with null dst2, no backtrace";
    goto LABEL_142;
  }

  v2 = *(a1 + 1);
  if (v2 == 2)
  {
    goto LABEL_17;
  }

  if (v2 != 30)
  {
    v5 = 0;
    goto LABEL_26;
  }

  v3 = *(a1 + 8);
  v4 = v3;
  if (v3)
  {
    if (v3 == 544)
    {
      v5 = 30;
      goto LABEL_26;
    }

    if (v3 == 288 && v3 < 0x10000)
    {
      v5 = 5;
      goto LABEL_26;
    }

    if ((v3 & 0xFE) == 0xFC)
    {
      v5 = 3;
      goto LABEL_26;
    }

    if ((v3 & 0xC0FF) == 0xC0FE)
    {
      goto LABEL_22;
    }

    goto LABEL_23;
  }

  if (*(a1 + 12))
  {
    goto LABEL_23;
  }

  v6 = *(a1 + 16);
  if (v6 == -65536)
  {
LABEL_17:
    v5 = 35;
    goto LABEL_26;
  }

  if (!v6)
  {
    v7 = *(a1 + 20);
    if (v7)
    {
      if (v7 == 0x1000000)
      {
        v5 = 50;
        goto LABEL_26;
      }

LABEL_22:
      v5 = 1;
      goto LABEL_26;
    }
  }

LABEL_23:
  if (v4 == 65087)
  {
    v5 = 1;
  }

  else
  {
    v5 = 40;
  }

LABEL_26:
  v8 = *(a2 + 1);
  if (v8 == 2)
  {
    goto LABEL_54;
  }

  if (v8 != 30)
  {
    v11 = 0;
    if (!v5)
    {
      goto LABEL_35;
    }

    goto LABEL_55;
  }

  v9 = *(a2 + 8);
  v10 = v9;
  if (!v9)
  {
    if (*(a2 + 12))
    {
      goto LABEL_97;
    }

    v20 = *(a2 + 16);
    if (v20 != -65536)
    {
      if (!v20)
      {
        v21 = *(a2 + 20);
        if (v21)
        {
          if (v21 == 0x1000000)
          {
            v11 = 50;
            goto LABEL_35;
          }

LABEL_95:
          v11 = 1;
          if (v5 > 1)
          {
            goto LABEL_55;
          }

          goto LABEL_35;
        }
      }

LABEL_97:
      if (v10 == 65087)
      {
        v11 = 1;
      }

      else
      {
        v11 = 40;
      }

      if (v5 > v11)
      {
        goto LABEL_55;
      }

      goto LABEL_35;
    }

LABEL_54:
    v11 = 35;
    if (v5 <= 0x23)
    {
      goto LABEL_35;
    }

    goto LABEL_55;
  }

  if (v9 == 544)
  {
    v11 = 30;
    if (v5 > 0x1E)
    {
      goto LABEL_55;
    }

    goto LABEL_35;
  }

  if (v9 == 288 && v9 < 0x10000)
  {
    v11 = 5;
    if (v5 <= 5)
    {
      goto LABEL_35;
    }

LABEL_55:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v22 = gLogObj;
    if (!os_log_type_enabled(gLogObj, OS_LOG_TYPE_DEBUG))
    {
      return 1;
    }

    *buf = 136446722;
    v47 = "sa_dst_compare_no_dependencies";
    v48 = 1024;
    *v49 = v5;
    v49[2] = 1024;
    *&v49[3] = v11;
    v23 = "%{public}s ND Rule 6, prefer d1, d1 precedence %d > d2 precedence %d";
LABEL_57:
    _os_log_impl(&dword_181A37000, v22, OS_LOG_TYPE_DEBUG, v23, buf, 0x18u);
    return 1;
  }

  if ((v9 & 0xFE) != 0xFC)
  {
    if ((v9 & 0xC0FF) == 0xC0FE)
    {
      goto LABEL_95;
    }

    goto LABEL_97;
  }

  v11 = 3;
  if (v5 > 3)
  {
    goto LABEL_55;
  }

LABEL_35:
  if (v11 > v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    if (!os_log_type_enabled(gLogObj, OS_LOG_TYPE_DEBUG))
    {
      return 0xFFFFFFFFLL;
    }

    *buf = 136446722;
    v47 = "sa_dst_compare_no_dependencies";
    v48 = 1024;
    *v49 = v11;
    v49[2] = 1024;
    *&v49[3] = v5;
    v13 = "%{public}s ND Rule 6, prefer d2, d2 precedence %d > d1 precedence %d";
LABEL_38:
    _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_DEBUG, v13, buf, 0x18u);
    return 0xFFFFFFFFLL;
  }

  if (v2 == 2)
  {
    v24 = bswap32(*(a1 + 4));
    v19 = HIWORD(v24) == 43518 || HIBYTE(v24) == 127;
    v18 = 14;
    goto LABEL_66;
  }

  if (v2 != 30)
  {
    v25 = 0;
    goto LABEL_70;
  }

  v15 = *(a1 + 8);
  if (v15 == 255)
  {
    v34 = (*(a1 + 9) & 0xF) - 1;
    if (v34 >= 5)
    {
      v25 = 14;
    }

    else
    {
      v25 = dword_182BD3394[v34];
    }
  }

  else
  {
    if (v15 == 254)
    {
      v16 = *(a1 + 9);
      v17 = v16 & 0xC0;
      if (v16 <= 0xBF)
      {
        v18 = 14;
      }

      else
      {
        v18 = 5;
      }

      v19 = v17 == 128;
LABEL_66:
      if (v19)
      {
        v25 = 2;
      }

      else
      {
        v25 = v18;
      }

      goto LABEL_70;
    }

    v25 = 14;
    if (!(*(a1 + 8) | *(a1 + 15)))
    {
      if (*(a1 + 23) == 1)
      {
        v25 = 2;
      }

      else
      {
        v25 = 14;
      }
    }
  }

LABEL_70:
  v26 = *(a2 + 1);
  if (v26 == 2)
  {
    v32 = bswap32(*(a2 + 4));
    v31 = HIWORD(v32) == 43518 || HIBYTE(v32) == 127;
    v30 = 14;
LABEL_82:
    if (v31)
    {
      v33 = 2;
    }

    else
    {
      v33 = v30;
    }

    goto LABEL_86;
  }

  if (v26 == 30)
  {
    v27 = *(a2 + 8);
    if (v27 == 255)
    {
      v35 = (*(a2 + 9) & 0xF) - 1;
      if (v35 >= 5)
      {
        v33 = 14;
      }

      else
      {
        v33 = dword_182BD3394[v35];
      }

      goto LABEL_86;
    }

    if (v27 != 254)
    {
      v33 = 14;
      if (!(*(a2 + 8) | *(a2 + 15)))
      {
        if (*(a2 + 23) == 1)
        {
          v33 = 2;
        }

        else
        {
          v33 = 14;
        }
      }

      goto LABEL_86;
    }

    v28 = *(a2 + 9);
    v29 = v28 & 0xC0;
    if (v28 <= 0xBF)
    {
      v30 = 14;
    }

    else
    {
      v30 = 5;
    }

    v31 = v29 == 128;
    goto LABEL_82;
  }

  v33 = 0;
LABEL_86:
  if (v25 < v33)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v22 = gLogObj;
    if (!os_log_type_enabled(gLogObj, OS_LOG_TYPE_DEBUG))
    {
      return 1;
    }

    *buf = 136446722;
    v47 = "sa_dst_compare_no_dependencies";
    v48 = 1024;
    *v49 = v25;
    v49[2] = 1024;
    *&v49[3] = v33;
    v23 = "%{public}s ND Rule 8, prefer d1, d1 scope %d < d2 scope %d";
    goto LABEL_57;
  }

  if (v33 < v25)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    if (!os_log_type_enabled(gLogObj, OS_LOG_TYPE_DEBUG))
    {
      return 0xFFFFFFFFLL;
    }

    *buf = 136446722;
    v47 = "sa_dst_compare_no_dependencies";
    v48 = 1024;
    *v49 = v33;
    v49[2] = 1024;
    *&v49[3] = v25;
    v13 = "%{public}s ND Rule 8, prefer d2, d2 scope %d < d1 scope %d";
    goto LABEL_38;
  }

  return 0;
}

NWConcrete_nw_hsts_storage *nw_hsts_storage_create_ns(void *a1)
{
  v1 = a1;
  v2 = objc_alloc_init(NWConcrete_nw_hsts_storage);
  HSTSStorage = v2->HSTSStorage;
  v2->HSTSStorage = v1;

  return v2;
}

void nw_protocol_transform_replace_endpoint(uint64_t a1, void *a2)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_replace_endpoint(a1, a2);
    return;
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_replace_endpoint";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_replace_endpoint";
        v6 = "%{public}s called with null transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_replace_endpoint";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_replace_endpoint";
        v6 = "%{public}s called with null transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_replace_endpoint";
        v6 = "%{public}s called with null transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }
}

void nw_protocol_transform_disable_protocol(void *a1, uint64_t a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v5 = __nwlog_obj();
    *buf = 136446210;
    v18 = "nw_protocol_transform_disable_protocol";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15))
    {
      goto LABEL_34;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v18 = "nw_protocol_transform_disable_protocol";
        v9 = "%{public}s called with null transform";
LABEL_32:
        _os_log_impl(&dword_181A37000, v7, v8, v9, buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v12 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v18 = "nw_protocol_transform_disable_protocol";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v6)
        {
          goto LABEL_4;
        }

LABEL_35:
        free(v6);
        goto LABEL_4;
      }

      if (v12)
      {
        *buf = 136446210;
        v18 = "nw_protocol_transform_disable_protocol";
        v9 = "%{public}s called with null transform, no backtrace";
        goto LABEL_32;
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v18 = "nw_protocol_transform_disable_protocol";
        v9 = "%{public}s called with null transform, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

LABEL_33:

    goto LABEL_34;
  }

  if (a2)
  {
    _nw_protocol_transform_disable_protocol(v3, a2);
    goto LABEL_4;
  }

  v10 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_protocol_transform_disable_protocol";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v6, &type, &v15))
  {
    goto LABEL_34;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v18 = "nw_protocol_transform_disable_protocol";
      v9 = "%{public}s called with null protocol_identifier";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v15 != 1)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v18 = "nw_protocol_transform_disable_protocol";
      v9 = "%{public}s called with null protocol_identifier, backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  v13 = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v14 = os_log_type_enabled(v7, type);
  if (!v13)
  {
    if (v14)
    {
      *buf = 136446210;
      v18 = "nw_protocol_transform_disable_protocol";
      v9 = "%{public}s called with null protocol_identifier, no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v14)
  {
    *buf = 136446466;
    v18 = "nw_protocol_transform_disable_protocol";
    v19 = 2082;
    v20 = v13;
    _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null protocol_identifier, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v13);
  if (v6)
  {
    goto LABEL_35;
  }

LABEL_4:
}

void nw_protocol_transform_clear_protocols_at_level(uint64_t a1, uint64_t a2)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_clear_protocols_at_level(a1, a2);
    return;
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_clear_protocols_at_level";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_clear_protocols_at_level";
        v6 = "%{public}s called with null transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_clear_protocols_at_level";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_clear_protocols_at_level";
        v6 = "%{public}s called with null transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_clear_protocols_at_level";
        v6 = "%{public}s called with null transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }
}

uint64_t nw_protocol_transform_get_multipath_service(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_protocol_transform_get_multipath_service(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_get_multipath_service";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_multipath_service";
        v6 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_get_multipath_service";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_get_multipath_service";
        v6 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_multipath_service";
        v6 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

void nw_protocol_transform_set_multipath_service(uint64_t a1, int a2)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_set_multipath_service(a1, a2);
    return;
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_set_multipath_service";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_set_multipath_service";
        v6 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_set_multipath_service";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_set_multipath_service";
        v6 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_set_multipath_service";
        v6 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }
}

uint64_t nw_protocol_transform_get_no_proxy(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_protocol_transform_get_no_proxy(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_get_no_proxy";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_no_proxy";
        v6 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_get_no_proxy";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_get_no_proxy";
        v6 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_no_proxy";
        v6 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

void nw_protocol_transform_set_no_proxy(uint64_t a1)
{
  v14 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_set_no_proxy();
    return;
  }

  v1 = __nwlog_obj();
  *buf = 136446210;
  v11 = "nw_protocol_transform_set_no_proxy";
  v2 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_set_no_proxy";
        v5 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v3, v4, v5, buf, 0xCu);
      }
    }

    else
    {
      if (v8 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v3 = __nwlog_obj();
        v4 = type;
        v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *buf = 136446466;
            v11 = "nw_protocol_transform_set_no_proxy";
            v12 = 2082;
            v13 = backtrace_string;
            _os_log_impl(&dword_181A37000, v3, v4, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v7)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v11 = "nw_protocol_transform_set_no_proxy";
        v5 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_set_no_proxy";
        v5 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v2)
  {
    free(v2);
  }
}

uint64_t nw_protocol_transform_get_no_path_fallback(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_protocol_transform_get_no_path_fallback(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_get_no_path_fallback";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_no_path_fallback";
        v6 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_get_no_path_fallback";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_get_no_path_fallback";
        v6 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_no_path_fallback";
        v6 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

void nw_protocol_transform_set_no_path_fallback(uint64_t a1)
{
  v14 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_set_no_path_fallback();
    return;
  }

  v1 = __nwlog_obj();
  *buf = 136446210;
  v11 = "nw_protocol_transform_set_no_path_fallback";
  v2 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_set_no_path_fallback";
        v5 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v3, v4, v5, buf, 0xCu);
      }
    }

    else
    {
      if (v8 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v3 = __nwlog_obj();
        v4 = type;
        v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *buf = 136446466;
            v11 = "nw_protocol_transform_set_no_path_fallback";
            v12 = 2082;
            v13 = backtrace_string;
            _os_log_impl(&dword_181A37000, v3, v4, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v7)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v11 = "nw_protocol_transform_set_no_path_fallback";
        v5 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_set_no_path_fallback";
        v5 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v2)
  {
    free(v2);
  }
}

uint64_t nw_protocol_transform_get_tfo(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_protocol_transform_get_tfo(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_get_tfo";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_tfo";
        v6 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_get_tfo";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_get_tfo";
        v6 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_tfo";
        v6 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

void nw_protocol_transform_set_tfo(uint64_t a1)
{
  v14 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_set_tfo();
    return;
  }

  v1 = __nwlog_obj();
  *buf = 136446210;
  v11 = "nw_protocol_transform_set_tfo";
  v2 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_set_tfo";
        v5 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v3, v4, v5, buf, 0xCu);
      }
    }

    else
    {
      if (v8 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v3 = __nwlog_obj();
        v4 = type;
        v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *buf = 136446466;
            v11 = "nw_protocol_transform_set_tfo";
            v12 = 2082;
            v13 = backtrace_string;
            _os_log_impl(&dword_181A37000, v3, v4, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v7)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v11 = "nw_protocol_transform_set_tfo";
        v5 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_set_tfo";
        v5 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v2)
  {
    free(v2);
  }
}

uint64_t nw_protocol_transform_get_tfo_no_cookie(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_protocol_transform_get_tfo_no_cookie(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_get_tfo_no_cookie";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_tfo_no_cookie";
        v6 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_get_tfo_no_cookie";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_get_tfo_no_cookie";
        v6 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_tfo_no_cookie";
        v6 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

void nw_protocol_transform_set_tfo_no_cookie(uint64_t a1)
{
  v14 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_set_tfo_no_cookie();
    return;
  }

  v1 = __nwlog_obj();
  *buf = 136446210;
  v11 = "nw_protocol_transform_set_tfo_no_cookie";
  v2 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_set_tfo_no_cookie";
        v5 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v3, v4, v5, buf, 0xCu);
      }
    }

    else
    {
      if (v8 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v3 = __nwlog_obj();
        v4 = type;
        v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *buf = 136446466;
            v11 = "nw_protocol_transform_set_tfo_no_cookie";
            v12 = 2082;
            v13 = backtrace_string;
            _os_log_impl(&dword_181A37000, v3, v4, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v7)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v11 = "nw_protocol_transform_set_tfo_no_cookie";
        v5 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_set_tfo_no_cookie";
        v5 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v2)
  {
    free(v2);
  }
}

uint64_t nw_protocol_transform_get_fast_open_force_enable(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_protocol_transform_get_fast_open_force_enable(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_get_fast_open_force_enable";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_fast_open_force_enable";
        v6 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_get_fast_open_force_enable";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_get_fast_open_force_enable";
        v6 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_fast_open_force_enable";
        v6 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

void nw_protocol_transform_set_fast_open_force_enable(uint64_t a1)
{
  v14 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_set_fast_open_force_enable();
    return;
  }

  v1 = __nwlog_obj();
  *buf = 136446210;
  v11 = "nw_protocol_transform_set_fast_open_force_enable";
  v2 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_set_fast_open_force_enable";
        v5 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v3, v4, v5, buf, 0xCu);
      }
    }

    else
    {
      if (v8 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v3 = __nwlog_obj();
        v4 = type;
        v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *buf = 136446466;
            v11 = "nw_protocol_transform_set_fast_open_force_enable";
            v12 = 2082;
            v13 = backtrace_string;
            _os_log_impl(&dword_181A37000, v3, v4, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v7)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v11 = "nw_protocol_transform_set_fast_open_force_enable";
        v5 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_set_fast_open_force_enable";
        v5 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v2)
  {
    free(v2);
  }
}

uint64_t nw_protocol_transform_get_traffic_class(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_protocol_transform_get_traffic_class(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_get_traffic_class";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_traffic_class";
        v6 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_get_traffic_class";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_get_traffic_class";
        v6 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_traffic_class";
        v6 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

void nw_protocol_transform_set_traffic_class(uint64_t a1, int a2)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_set_traffic_class(a1, a2);
    return;
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_set_traffic_class";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_set_traffic_class";
        v6 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_set_traffic_class";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_set_traffic_class";
        v6 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_set_traffic_class";
        v6 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }
}

uint64_t nw_protocol_transform_get_data_mode(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_protocol_transform_get_data_mode(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_get_data_mode";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_data_mode";
        v6 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_get_data_mode";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_get_data_mode";
        v6 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_get_data_mode";
        v6 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

void nw_protocol_transform_set_data_mode(uint64_t a1, unsigned int a2)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_set_data_mode(a1, a2);
    return;
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_set_data_mode";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_set_data_mode";
        v6 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_set_data_mode";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_set_data_mode";
        v6 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_set_data_mode";
        v6 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }
}

void nw_protocol_transform_set_fallback_mode(uint64_t a1, unsigned int a2)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_set_fallback_mode(a1, a2);
    return;
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_set_fallback_mode";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_set_fallback_mode";
        v6 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_set_fallback_mode";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_set_fallback_mode";
        v6 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_set_fallback_mode";
        v6 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }
}

void nw_protocol_transform_set_prohibit_direct(uint64_t a1, char a2)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_set_prohibit_direct(a1, a2);
    return;
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_transform_set_prohibit_direct";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_set_prohibit_direct";
        v6 = "%{public}s called with null protocol_transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_protocol_transform_set_prohibit_direct";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol_transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_protocol_transform_set_prohibit_direct";
        v6 = "%{public}s called with null protocol_transform, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_transform_set_prohibit_direct";
        v6 = "%{public}s called with null protocol_transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }
}

uint64_t nw_protocol_transform_get_hash(uint64_t a1)
{
  if (a1)
  {
    return _nw_protocol_transform_get_hash(a1);
  }

  return a1;
}

void nw_protocol_transform_set_use_tfo_heuristics(uint64_t a1)
{
  v16 = *MEMORY[0x1E69E9840];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = gLogObj;
  v3 = v2;
  if (a1)
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *buf = 136446210;
      v13 = "nw_protocol_transform_set_use_tfo_heuristics";
      _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_INFO, "%{public}s nw_protocol_transform_set_use_tfo_heuristics is deprecated", buf, 0xCu);
    }

    return;
  }

  *buf = 136446210;
  v13 = "nw_protocol_transform_set_use_tfo_heuristics";
  v4 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v13 = "nw_protocol_transform_set_use_tfo_heuristics";
        v7 = "%{public}s called with null transform";
LABEL_19:
        _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0xCu);
      }
    }

    else
    {
      if (v10 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v5 = __nwlog_obj();
        v6 = type;
        v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *buf = 136446466;
            v13 = "nw_protocol_transform_set_use_tfo_heuristics";
            v14 = 2082;
            v15 = backtrace_string;
            _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }

        if (!v9)
        {
          goto LABEL_20;
        }

        *buf = 136446210;
        v13 = "nw_protocol_transform_set_use_tfo_heuristics";
        v7 = "%{public}s called with null transform, no backtrace";
        goto LABEL_19;
      }

      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v13 = "nw_protocol_transform_set_use_tfo_heuristics";
        v7 = "%{public}s called with null transform, backtrace limit exceeded";
        goto LABEL_19;
      }
    }

LABEL_20:
  }

LABEL_21:
  if (v4)
  {
    free(v4);
  }
}

uint64_t nw_protocol_transform_get_use_tfo_heuristics(uint64_t a1)
{
  v17 = *MEMORY[0x1E69E9840];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = gLogObj;
  v3 = v2;
  if (a1)
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *buf = 136446210;
      v14 = "nw_protocol_transform_get_use_tfo_heuristics";
      _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_INFO, "%{public}s nw_protocol_transform_set_use_tfo_heuristics is deprecated", buf, 0xCu);
    }

    return 0;
  }

  *buf = 136446210;
  v14 = "nw_protocol_transform_get_use_tfo_heuristics";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v14 = "nw_protocol_transform_get_use_tfo_heuristics";
        v8 = "%{public}s called with null transform";
LABEL_19:
        _os_log_impl(&dword_181A37000, v6, v7, v8, buf, 0xCu);
      }
    }

    else
    {
      if (v11 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v6 = __nwlog_obj();
        v7 = type;
        v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *buf = 136446466;
            v14 = "nw_protocol_transform_get_use_tfo_heuristics";
            v15 = 2082;
            v16 = backtrace_string;
            _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }

        if (!v10)
        {
          goto LABEL_20;
        }

        *buf = 136446210;
        v14 = "nw_protocol_transform_get_use_tfo_heuristics";
        v8 = "%{public}s called with null transform, no backtrace";
        goto LABEL_19;
      }

      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v14 = "nw_protocol_transform_get_use_tfo_heuristics";
        v8 = "%{public}s called with null transform, backtrace limit exceeded";
        goto LABEL_19;
      }
    }

LABEL_20:
  }

LABEL_21:
  if (v5)
  {
    free(v5);
  }

  return 0;
}

void nw_protocol_transform_add_match_url_scheme(void *a1, uint64_t a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v5 = __nwlog_obj();
    *buf = 136446210;
    v18 = "nw_protocol_transform_add_match_url_scheme";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15))
    {
      goto LABEL_34;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v18 = "nw_protocol_transform_add_match_url_scheme";
        v9 = "%{public}s called with null transform";
LABEL_32:
        _os_log_impl(&dword_181A37000, v7, v8, v9, buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v12 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v18 = "nw_protocol_transform_add_match_url_scheme";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v6)
        {
          goto LABEL_4;
        }

LABEL_35:
        free(v6);
        goto LABEL_4;
      }

      if (v12)
      {
        *buf = 136446210;
        v18 = "nw_protocol_transform_add_match_url_scheme";
        v9 = "%{public}s called with null transform, no backtrace";
        goto LABEL_32;
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v18 = "nw_protocol_transform_add_match_url_scheme";
        v9 = "%{public}s called with null transform, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

LABEL_33:

    goto LABEL_34;
  }

  if (a2)
  {
    _nw_protocol_transform_add_match_url_scheme(v3);
    goto LABEL_4;
  }

  v10 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_protocol_transform_add_match_url_scheme";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v6, &type, &v15))
  {
    goto LABEL_34;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v18 = "nw_protocol_transform_add_match_url_scheme";
      v9 = "%{public}s called with null scheme";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v15 != 1)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v18 = "nw_protocol_transform_add_match_url_scheme";
      v9 = "%{public}s called with null scheme, backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  v13 = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v14 = os_log_type_enabled(v7, type);
  if (!v13)
  {
    if (v14)
    {
      *buf = 136446210;
      v18 = "nw_protocol_transform_add_match_url_scheme";
      v9 = "%{public}s called with null scheme, no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v14)
  {
    *buf = 136446466;
    v18 = "nw_protocol_transform_add_match_url_scheme";
    v19 = 2082;
    v20 = v13;
    _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null scheme, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v13);
  if (v6)
  {
    goto LABEL_35;
  }

LABEL_4:
}

void nw_protocol_transform_clear_match_url_schemes(uint64_t a1)
{
  v14 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_clear_match_url_schemes(a1);
    return;
  }

  v1 = __nwlog_obj();
  *buf = 136446210;
  v11 = "nw_protocol_transform_clear_match_url_schemes";
  v2 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_clear_match_url_schemes";
        v5 = "%{public}s called with null transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v3, v4, v5, buf, 0xCu);
      }
    }

    else
    {
      if (v8 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v3 = __nwlog_obj();
        v4 = type;
        v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *buf = 136446466;
            v11 = "nw_protocol_transform_clear_match_url_schemes";
            v12 = 2082;
            v13 = backtrace_string;
            _os_log_impl(&dword_181A37000, v3, v4, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v7)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v11 = "nw_protocol_transform_clear_match_url_schemes";
        v5 = "%{public}s called with null transform, no backtrace";
        goto LABEL_18;
      }

      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_clear_match_url_schemes";
        v5 = "%{public}s called with null transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v2)
  {
    free(v2);
  }
}

void nw_protocol_transform_copy(uint64_t a1)
{
  v14 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    _nw_protocol_transform_copy(a1);
    return;
  }

  v1 = __nwlog_obj();
  *buf = 136446210;
  v11 = "nw_protocol_transform_copy";
  v2 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_copy";
        v5 = "%{public}s called with null transform";
LABEL_18:
        _os_log_impl(&dword_181A37000, v3, v4, v5, buf, 0xCu);
      }
    }

    else
    {
      if (v8 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v3 = __nwlog_obj();
        v4 = type;
        v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *buf = 136446466;
            v11 = "nw_protocol_transform_copy";
            v12 = 2082;
            v13 = backtrace_string;
            _os_log_impl(&dword_181A37000, v3, v4, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v7)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v11 = "nw_protocol_transform_copy";
        v5 = "%{public}s called with null transform, no backtrace";
        goto LABEL_18;
      }

      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *buf = 136446210;
        v11 = "nw_protocol_transform_copy";
        v5 = "%{public}s called with null transform, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v2)
  {
    free(v2);
  }
}

uint64_t nw_protocol_transform_compare(void *a1, void *a2, unsigned int a3)
{
  v5 = a1;
  v6 = a2;
  v7 = v6;
  if (v5 | v6)
  {
    v8 = 0;
    if (v5 && v6)
    {
      v8 = _nw_protocol_transform_compare(v5, v6, a3);
    }
  }

  else
  {
    v8 = 1;
  }

  return v8;
}

uint64_t nw_protocol_transform_is_equal(void *a1, void *a2)
{
  v3 = a1;
  v4 = a2;
  v5 = v3;
  v6 = v4;
  v7 = v6;
  if (v5 | v6)
  {
    v8 = 0;
    if (v5 && v6)
    {
      v8 = _nw_protocol_transform_compare(v5, v6, 0);
    }
  }

  else
  {
    v8 = 1;
  }

  return v8;
}

uint64_t nw_connection_multipath_get_subflow_count(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v19 = 0;
    v13[0] = MEMORY[0x1E69E9820];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_multipath_get_subflow_count_block_invoke;
    v13[3] = &unk_1E6A3D738;
    v14 = v1;
    v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_multipath_get_subflow_count_block_invoke(v13);
    os_unfair_lock_unlock(v2 + 34);
    v3 = *(*&buf[8] + 24);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_connection_multipath_get_subflow_count";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_connection_multipath_get_subflow_count";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          *&buf[4] = "nw_connection_multipath_get_subflow_count";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        *&buf[4] = "nw_connection_multipath_get_subflow_count";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_connection_multipath_get_subflow_count";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_multipath_get_subflow_count_block_invoke(uint64_t a1)
{
  v46 = *MEMORY[0x1E69E9840];
  v2 = *(a1 + 32);
  if ((*(v2 + 109) & 0x40) != 0)
  {
    v6 = *(v2 + 144);
    v7 = v6;
    if (v6)
    {
      os_unfair_lock_lock(v6 + 28);
      if (v7[29]._os_unfair_lock_opaque != 2)
      {
        v19 = 0;
LABEL_34:
        os_unfair_lock_unlock(v7 + 28);
LABEL_35:

        *(*(*(a1 + 40) + 8) + 24) = v19;
        return;
      }

      v8 = *&v7[66]._os_unfair_lock_opaque;
      v9 = v8;
      if (v8)
      {
        *type = 0;
        v39 = type;
        v40 = 0x2020000000;
        v41 = 0;
        if (!nw_endpoint_flow_is_multipath(v8))
        {
LABEL_32:
          v19 = *(v39 + 6);
          _Block_object_dispose(type, 8);
LABEL_33:

          goto LABEL_34;
        }

        v10 = nw_endpoint_flow_copy_connected_socket_wrapper(v9);
        v11 = v9[117];
        if (v11)
        {
          v12 = v11;
          v13 = v12[4];

          if (v13 && nw_parameters_get_upper_transport_protocol(v13) == 253)
          {
            if (gLogDatapath == 1)
            {
              v37 = __nwlog_obj();
              if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
              {
                *buf = 136446210;
                *&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
                _os_log_impl(&dword_181A37000, v37, OS_LOG_TYPE_DEBUG, "%{public}s Querying QUIC for subflow count", buf, 0xCu);
              }
            }

            v14 = v9[51];
            if (v14)
            {
              v15 = *(v14 + 24);
              if (v15)
              {
                v16 = *(v15 + 224);
                if (v16)
                {
                  v17 = v16();
                  v18 = v17;
                  if (v17)
                  {
                    *(v39 + 6) = *(v17 + 8);
                    nw_array_remove_all_objects(*v17);
                    if (*v18)
                    {
                      os_release(*v18);
                    }

                    free(v18);
                  }
                }
              }
            }

LABEL_31:

            goto LABEL_32;
          }
        }

        else
        {
          v13 = 0;
        }

        if (v10)
        {
          *buf = MEMORY[0x1E69E9820];
          *&buf[8] = 3221225472;
          *&buf[16] = ___Z44nw_endpoint_flow_get_multipath_subflow_countP27NWConcrete_nw_endpoint_flow_block_invoke;
          v44 = &unk_1E6A3C0D8;
          v45 = type;
          nw_fd_wrapper_get_fd(v10, buf);
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v20 = gLogObj;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            *buf = 136446210;
            *&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
            _os_log_impl(&dword_181A37000, v20, OS_LOG_TYPE_DEBUG, "%{public}s Protocol not supported", buf, 0xCu);
          }
        }

        goto LABEL_31;
      }

      v25 = __nwlog_obj();
      *buf = 136446210;
      *&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
      v26 = _os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v42 = 0;
      if (__nwlog_fault(v26, type, &v42))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v27 = __nwlog_obj();
          v28 = type[0];
          if (os_log_type_enabled(v27, type[0]))
          {
            *buf = 136446210;
            *&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
            _os_log_impl(&dword_181A37000, v27, v28, "%{public}s called with null endpoint_flow", buf, 0xCu);
          }
        }

        else if (v42 == 1)
        {
          backtrace_string = __nw_create_backtrace_string();
          v27 = __nwlog_obj();
          v34 = type[0];
          v35 = os_log_type_enabled(v27, type[0]);
          if (backtrace_string)
          {
            if (v35)
            {
              *buf = 136446466;
              *&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
              *&buf[12] = 2082;
              *&buf[14] = backtrace_string;
              _os_log_impl(&dword_181A37000, v27, v34, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_75;
          }

          if (v35)
          {
            *buf = 136446210;
            *&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
            _os_log_impl(&dword_181A37000, v27, v34, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          v27 = __nwlog_obj();
          v36 = type[0];
          if (os_log_type_enabled(v27, type[0]))
          {
            *buf = 136446210;
            *&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
            _os_log_impl(&dword_181A37000, v27, v36, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }

LABEL_75:
      if (v26)
      {
        free(v26);
      }

      v19 = 0;
      goto LABEL_33;
    }

    v21 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_endpoint_handler_get_multipath_subflow_count";
    v22 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v22, type, &v42))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v23 = __nwlog_obj();
        v24 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_endpoint_handler_get_multipath_subflow_count";
          _os_log_impl(&dword_181A37000, v23, v24, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v42 == 1)
      {
        v29 = __nw_create_backtrace_string();
        v23 = __nwlog_obj();
        v30 = type[0];
        v31 = os_log_type_enabled(v23, type[0]);
        if (v29)
        {
          if (v31)
          {
            *buf = 136446466;
            *&buf[4] = "nw_endpoint_handler_get_multipath_subflow_count";
            *&buf[12] = 2082;
            *&buf[14] = v29;
            _os_log_impl(&dword_181A37000, v23, v30, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v29);
          goto LABEL_66;
        }

        if (v31)
        {
          *buf = 136446210;
          *&buf[4] = "nw_endpoint_handler_get_multipath_subflow_count";
          _os_log_impl(&dword_181A37000, v23, v30, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v23 = __nwlog_obj();
        v32 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_endpoint_handler_get_multipath_subflow_count";
          _os_log_impl(&dword_181A37000, v23, v32, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_66:
    if (v22)
    {
      free(v22);
    }

    v19 = 0;
    goto LABEL_35;
  }

  v3 = *(v2 + 16);
  if (v3 && !_nw_parameters_get_logging_disabled(v3))
  {
    if (__nwlog_connection_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
    }

    v4 = gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      v5 = *(*(a1 + 32) + 448);
      *buf = 136446466;
      *&buf[4] = "nw_connection_multipath_get_subflow_count_block_invoke";
      *&buf[12] = 1024;
      *&buf[14] = v5;
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_INFO, "%{public}s [C%u]  has no connected handler", buf, 0x12u);
    }
  }
}

void sub_1828C3A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_connection_multipath_get_primary_subflow_interface_index(void *a1)
{
  v23 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = nw_connection_copy_connected_path(v1);
    v4 = v3;
    if (v3)
    {
      v5 = v3;
      if (_nw_path_network_is_satisfied(v5))
      {
        routed_interface_index = _nw_path_get_routed_interface_index(v5);
      }

      else
      {
        routed_interface_index = 0;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446210;
        v20 = "nw_connection_multipath_get_primary_subflow_interface_index";
        _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_ERROR, "%{public}s No connected path", buf, 0xCu);
      }

      routed_interface_index = 0;
    }

    goto LABEL_11;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_connection_multipath_get_primary_subflow_interface_index";
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v20 = "nw_connection_multipath_get_primary_subflow_interface_index";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v20 = "nw_connection_multipath_get_primary_subflow_interface_index";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }

      if (v15)
      {
        *buf = 136446210;
        v20 = "nw_connection_multipath_get_primary_subflow_interface_index";
        _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v20 = "nw_connection_multipath_get_primary_subflow_interface_index";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_28:
  if (v10)
  {
    free(v10);
  }

  routed_interface_index = 0;
LABEL_11:

  return routed_interface_index;
}

id nw_connection_multipath_copy_subflow_counts(void *a1)
{
  v22 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x3032000000;
    v19 = __Block_byref_object_copy__62924;
    v20 = __Block_byref_object_dispose__62925;
    v21 = 0;
    v13[0] = MEMORY[0x1E69E9820];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_multipath_copy_subflow_counts_block_invoke;
    v13[3] = &unk_1E6A3D738;
    v14 = v1;
    v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_multipath_copy_subflow_counts_block_invoke(v13);
    os_unfair_lock_unlock(v2 + 34);
    v3 = *(*&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_connection_multipath_copy_subflow_counts";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_connection_multipath_copy_subflow_counts";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          *&buf[4] = "nw_connection_multipath_copy_subflow_counts";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        *&buf[4] = "nw_connection_multipath_copy_subflow_counts";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_connection_multipath_copy_subflow_counts";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t __Block_byref_object_copy__62924(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

void __nw_connection_multipath_copy_subflow_counts_block_invoke(uint64_t a1)
{
  v78 = *MEMORY[0x1E69E9840];
  v2 = *(a1 + 32);
  if ((*(v2 + 109) & 0x40) == 0)
  {
    v3 = *(v2 + 16);
    if (v3 && !_nw_parameters_get_logging_disabled(v3))
    {
      if (__nwlog_connection_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
      }

      v4 = gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        v5 = *(*(a1 + 32) + 448);
        *buf = 136446466;
        *&buf[4] = "nw_connection_multipath_copy_subflow_counts_block_invoke";
        *&buf[12] = 1024;
        *&buf[14] = v5;
        _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_INFO, "%{public}s [C%u]  has no connected handler", buf, 0x12u);
      }
    }

    return;
  }

  v6 = *(v2 + 144);
  v7 = v6;
  if (!v6)
  {
    v43 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_endpoint_handler_copy_multipath_subflow_counts";
    v44 = _os_log_send_and_compose_impl();

    v64[0] = OS_LOG_TYPE_ERROR;
    v68[0] = 0;
    if (__nwlog_fault(v44, v64, v68))
    {
      if (v64[0] == OS_LOG_TYPE_FAULT)
      {
        v45 = __nwlog_obj();
        v46 = v64[0];
        if (os_log_type_enabled(v45, v64[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_endpoint_handler_copy_multipath_subflow_counts";
          _os_log_impl(&dword_181A37000, v45, v46, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v68[0] == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v45 = __nwlog_obj();
        v52 = v64[0];
        v53 = os_log_type_enabled(v45, v64[0]);
        if (backtrace_string)
        {
          if (v53)
          {
            *buf = 136446466;
            *&buf[4] = "nw_endpoint_handler_copy_multipath_subflow_counts";
            *&buf[12] = 2082;
            *&buf[14] = backtrace_string;
            _os_log_impl(&dword_181A37000, v45, v52, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_115;
        }

        if (v53)
        {
          *buf = 136446210;
          *&buf[4] = "nw_endpoint_handler_copy_multipath_subflow_counts";
          _os_log_impl(&dword_181A37000, v45, v52, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v45 = __nwlog_obj();
        v54 = v64[0];
        if (os_log_type_enabled(v45, v64[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_endpoint_handler_copy_multipath_subflow_counts";
          _os_log_impl(&dword_181A37000, v45, v54, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_115:
    if (v44)
    {
      free(v44);
    }

    v12 = 0;
    goto LABEL_65;
  }

  os_unfair_lock_lock(v6 + 28);
  if (v7[29]._os_unfair_lock_opaque == 2)
  {
    v8 = *&v7[66]._os_unfair_lock_opaque;
    v9 = v8;
    if (v8)
    {
      *v64 = 0;
      v65 = v64;
      v66 = 0x2020000000;
      v67 = 0;
      v61 = v8;
      if (nw_endpoint_flow_is_multipath(v8))
      {
        v10 = nw_endpoint_flow_copy_connected_socket_wrapper(v9);
        v11 = v10;
        if (v10)
        {
          *buf = MEMORY[0x1E69E9820];
          *&buf[8] = 3221225472;
          *&buf[16] = ___Z46nw_endpoint_flow_copy_multipath_subflow_countsP27NWConcrete_nw_endpoint_flow_block_invoke;
          v76 = &unk_1E6A3C0D8;
          v77 = v64;
          if ((nw_fd_wrapper_get_fd(v10, buf) & 1) == 0)
          {
            goto LABEL_53;
          }

          v12 = xpc_dictionary_create(0, 0, 0);
          if (v12)
          {
            v13 = (*(*(v65 + 3) + 32) + 40);
            v14 = 4;
            StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            while (1)
            {
              if (!*v13)
              {
                goto LABEL_19;
              }

              *key = 0;
              v73 = 0;
              v74 = 0;
              if (if_indextoname(*v13, key))
              {
                xpc_dictionary_set_uint64(v12, key, v13[1]);
                goto LABEL_19;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v15 = gLogObj;
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
              {
                v16 = *v13;
                *v68 = 136446466;
                v69 = "nw_endpoint_flow_copy_multipath_subflow_counts";
                v70 = 1024;
                LODWORD(v71[0]) = v16;
                _os_log_impl(&dword_181A37000, v15, OS_LOG_TYPE_ERROR, "%{public}s if_indextoname failed for outif: %d", v68, 0x12u);
              }

              v17 = **(StatusReg + 8);
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v18 = gLogObj;
              v19 = v18;
              if (v17 == 6)
              {
                if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
                {
                  *v68 = 136446466;
                  v69 = "nw_endpoint_flow_copy_multipath_subflow_counts";
                  v70 = 1024;
                  LODWORD(v71[0]) = 6;
                  _os_log_impl(&dword_181A37000, v19, OS_LOG_TYPE_ERROR, "%{public}s if_indextoname %{darwin.errno}d", v68, 0x12u);
                }

                goto LABEL_19;
              }

              *v68 = 136446466;
              v69 = "nw_endpoint_flow_copy_multipath_subflow_counts";
              v70 = 1024;
              LODWORD(v71[0]) = v17;
              v20 = _os_log_send_and_compose_impl();

              type = OS_LOG_TYPE_ERROR;
              v62 = 0;
              if (__nwlog_fault(v20, &type, &v62))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v21 = gLogObj;
                  v22 = type;
                  if (os_log_type_enabled(v21, type))
                  {
                    *v68 = 136446466;
                    v69 = "nw_endpoint_flow_copy_multipath_subflow_counts";
                    v70 = 1024;
                    LODWORD(v71[0]) = v17;
                    _os_log_impl(&dword_181A37000, v21, v22, "%{public}s if_indextoname %{darwin.errno}d", v68, 0x12u);
                  }
                }

                else
                {
                  if (v62 == 1)
                  {
                    v23 = __nw_create_backtrace_string();
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v24 = gLogObj;
                    v59 = type;
                    v25 = os_log_type_enabled(v24, type);
                    if (v23)
                    {
                      if (v25)
                      {
                        *v68 = 136446722;
                        v69 = "nw_endpoint_flow_copy_multipath_subflow_counts";
                        v70 = 1024;
                        LODWORD(v71[0]) = v17;
                        WORD2(v71[0]) = 2082;
                        *(v71 + 6) = v23;
                        _os_log_impl(&dword_181A37000, v24, v59, "%{public}s if_indextoname %{darwin.errno}d, dumping backtrace:%{public}s", v68, 0x1Cu);
                      }

                      free(v23);
                      if (!v20)
                      {
                        goto LABEL_19;
                      }

LABEL_46:
                      free(v20);
                      goto LABEL_19;
                    }

                    if (v25)
                    {
                      *v68 = 136446466;
                      v69 = "nw_endpoint_flow_copy_multipath_subflow_counts";
                      v70 = 1024;
                      LODWORD(v71[0]) = v17;
                      _os_log_impl(&dword_181A37000, v24, v59, "%{public}s if_indextoname %{darwin.errno}d, no backtrace", v68, 0x12u);
                    }

                    goto LABEL_45;
                  }

                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v21 = gLogObj;
                  v26 = type;
                  if (os_log_type_enabled(v21, type))
                  {
                    *v68 = 136446466;
                    v69 = "nw_endpoint_flow_copy_multipath_subflow_counts";
                    v70 = 1024;
                    LODWORD(v71[0]) = v17;
                    _os_log_impl(&dword_181A37000, v21, v26, "%{public}s if_indextoname %{darwin.errno}d, backtrace limit exceeded", v68, 0x12u);
                  }
                }
              }

LABEL_45:
              if (v20)
              {
                goto LABEL_46;
              }

LABEL_19:
              v13 += 36;
              if (!--v14)
              {
                goto LABEL_54;
              }
            }
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v35 = gLogObj;
          *v68 = 136446210;
          v69 = "nw_endpoint_flow_copy_multipath_subflow_counts";
          v36 = _os_log_send_and_compose_impl();

          key[0] = 16;
          type = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v36, key, &type))
          {
            goto LABEL_84;
          }

          if (key[0] == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v37 = gLogObj;
            v38 = key[0];
            if (os_log_type_enabled(v37, key[0]))
            {
              *v68 = 136446210;
              v69 = "nw_endpoint_flow_copy_multipath_subflow_counts";
              _os_log_impl(&dword_181A37000, v37, v38, "%{public}s xpc_dictionary_create failed", v68, 0xCu);
            }
          }

          else if (type == OS_LOG_TYPE_INFO)
          {
            v39 = __nw_create_backtrace_string();
            v37 = __nwlog_obj();
            v40 = key[0];
            v41 = os_log_type_enabled(v37, key[0]);
            if (v39)
            {
              if (v41)
              {
                *v68 = 136446466;
                v69 = "nw_endpoint_flow_copy_multipath_subflow_counts";
                v70 = 2082;
                v71[0] = v39;
                _os_log_impl(&dword_181A37000, v37, v40, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", v68, 0x16u);
              }

              free(v39);
              goto LABEL_84;
            }

            if (v41)
            {
              *v68 = 136446210;
              v69 = "nw_endpoint_flow_copy_multipath_subflow_counts";
              _os_log_impl(&dword_181A37000, v37, v40, "%{public}s xpc_dictionary_create failed, no backtrace", v68, 0xCu);
            }
          }

          else
          {
            v37 = __nwlog_obj();
            v42 = key[0];
            if (os_log_type_enabled(v37, key[0]))
            {
              *v68 = 136446210;
              v69 = "nw_endpoint_flow_copy_multipath_subflow_counts";
              _os_log_impl(&dword_181A37000, v37, v42, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", v68, 0xCu);
            }
          }

LABEL_84:
          if (v36)
          {
            free(v36);
          }

          goto LABEL_53;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v27 = gLogObj;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        {
          *buf = 136446210;
          *&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl(&dword_181A37000, v27, OS_LOG_TYPE_DEBUG, "%{public}s connected_fd is not yet set", buf, 0xCu);
        }

        v11 = 0;
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *buf = 136446210;
          *&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_ERROR, "%{public}s Called on non-Multipath connection", buf, 0xCu);
        }
      }

LABEL_53:
      v12 = 0;
LABEL_54:

      v28 = *(v65 + 3);
      v29 = v61;
      if (v28)
      {
        v30 = v28[1];
        if (v30)
        {
          free(v30);
          v28[1] = 0;
        }

        v31 = v28[2];
        if (v31)
        {
          free(v31);
          v28[2] = 0;
        }

        v32 = v28[4];
        if (v32)
        {
          free(v32);
        }

        free(v28);
      }

      _Block_object_dispose(v64, 8);
      goto LABEL_63;
    }

    v29 = 0;
    v47 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
    v48 = _os_log_send_and_compose_impl();

    v64[0] = OS_LOG_TYPE_ERROR;
    v68[0] = 0;
    if (__nwlog_fault(v48, v64, v68))
    {
      if (v64[0] == OS_LOG_TYPE_FAULT)
      {
        v49 = __nwlog_obj();
        v50 = v64[0];
        if (os_log_type_enabled(v49, v64[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl(&dword_181A37000, v49, v50, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }

      else if (v68[0] == 1)
      {
        v55 = __nw_create_backtrace_string();
        v49 = __nwlog_obj();
        v56 = v64[0];
        v57 = os_log_type_enabled(v49, v64[0]);
        if (v55)
        {
          if (v57)
          {
            *buf = 136446466;
            *&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
            *&buf[12] = 2082;
            *&buf[14] = v55;
            _os_log_impl(&dword_181A37000, v49, v56, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v55);
          goto LABEL_121;
        }

        if (v57)
        {
          *buf = 136446210;
          *&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl(&dword_181A37000, v49, v56, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v49 = __nwlog_obj();
        v58 = v64[0];
        if (os_log_type_enabled(v49, v64[0]))
        {
          *buf = 136446210;
          *&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl(&dword_181A37000, v49, v58, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_121:
    if (v48)
    {
      free(v48);
    }

    v12 = 0;
LABEL_63:

    goto LABEL_64;
  }

  v12 = 0;
LABEL_64:
  os_unfair_lock_unlock(v7 + 28);
LABEL_65:

  v33 = *(*(a1 + 40) + 8);
  v34 = *(v33 + 40);
  *(v33 + 40) = v12;
}

void sub_1828C5070(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_webtransport_create_options()
{
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
  }

  v1 = nw_protocol_copy_webtransport_definition::definition;

  return nw_protocol_create_options(v1);
}

uint64_t __nw_protocol_copy_webtransport_definition_block_invoke()
{
  if (nw_protocol_webtransport_identifier::onceToken != -1)
  {
    dispatch_once(&nw_protocol_webtransport_identifier::onceToken, &__block_literal_global_36405);
  }

  v0 = nw_protocol_definition_create_with_identifier(nw_protocol_webtransport_identifier::protocol_identifier);
  v1 = nw_protocol_copy_webtransport_definition::definition;
  nw_protocol_copy_webtransport_definition::definition = v0;

  nw_protocol_definition_set_options_allocator(nw_protocol_copy_webtransport_definition::definition, nw_webtransport_allocate_options, nw_webtransport_copy_options, nw_webtransport_deallocate_options);
  nw_protocol_definition_set_options_comparator(nw_protocol_copy_webtransport_definition::definition, nw_webtransport_compare_options);
  nw_protocol_definition_set_metadata_allocator(nw_protocol_copy_webtransport_definition::definition, nw_webtransport_allocate_stream_metadata, nw_webtransport_deallocate_stream_metadata);
  nw_protocol_definition_set_metadata_comparator(nw_protocol_copy_webtransport_definition::definition, nw_webtransport_compare_stream_metadata);
  v2 = nw_protocol_copy_webtransport_definition::definition;

  return nw_protocol_register_handle(nw_protocol_webtransport_identifier::protocol_identifier, v2, nw_protocol_webtransport_create, nw_protocol_webtransport_accept);
}

uint64_t nw_webtransport_compare_stream_metadata(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  v35 = *MEMORY[0x1E69E9840];
  v7 = a1;
  if (!a2)
  {
    v14 = v7;
    v15 = __nwlog_obj();
    *buf = 136446210;
    v32 = "nw_webtransport_compare_stream_metadata";
    v16 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v16, &type, &v29))
    {
      goto LABEL_50;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *buf = 136446210;
        v32 = "nw_webtransport_compare_stream_metadata";
        _os_log_impl(&dword_181A37000, v17, v18, "%{public}s called with null handle1", buf, 0xCu);
      }
    }

    else if (v29 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v17 = __nwlog_obj();
      v22 = type;
      v23 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v23)
        {
          *buf = 136446466;
          v32 = "nw_webtransport_compare_stream_metadata";
          v33 = 2082;
          v34 = backtrace_string;
          _os_log_impl(&dword_181A37000, v17, v22, "%{public}s called with null handle1, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_50:
        if (!v16)
        {
LABEL_52:
          v8 = 0;
          v7 = v14;
          goto LABEL_7;
        }

LABEL_51:
        free(v16);
        goto LABEL_52;
      }

      if (v23)
      {
        *buf = 136446210;
        v32 = "nw_webtransport_compare_stream_metadata";
        _os_log_impl(&dword_181A37000, v17, v22, "%{public}s called with null handle1, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v17 = __nwlog_obj();
      v27 = type;
      if (os_log_type_enabled(v17, type))
      {
        *buf = 136446210;
        v32 = "nw_webtransport_compare_stream_metadata";
        _os_log_impl(&dword_181A37000, v17, v27, "%{public}s called with null handle1, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_49:

    goto LABEL_50;
  }

  if (!a3)
  {
    v14 = v7;
    v19 = __nwlog_obj();
    *buf = 136446210;
    v32 = "nw_webtransport_compare_stream_metadata";
    v16 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v16, &type, &v29))
    {
      goto LABEL_50;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v17, type))
      {
        *buf = 136446210;
        v32 = "nw_webtransport_compare_stream_metadata";
        _os_log_impl(&dword_181A37000, v17, v20, "%{public}s called with null handle2", buf, 0xCu);
      }
    }

    else if (v29 == 1)
    {
      v24 = __nw_create_backtrace_string();
      v17 = __nwlog_obj();
      v25 = type;
      v26 = os_log_type_enabled(v17, type);
      if (v24)
      {
        if (v26)
        {
          *buf = 136446466;
          v32 = "nw_webtransport_compare_stream_metadata";
          v33 = 2082;
          v34 = v24;
          _os_log_impl(&dword_181A37000, v17, v25, "%{public}s called with null handle2, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v24);
        if (!v16)
        {
          goto LABEL_52;
        }

        goto LABEL_51;
      }

      if (v26)
      {
        *buf = 136446210;
        v32 = "nw_webtransport_compare_stream_metadata";
        _os_log_impl(&dword_181A37000, v17, v25, "%{public}s called with null handle2, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v17 = __nwlog_obj();
      v28 = type;
      if (os_log_type_enabled(v17, type))
      {
        *buf = 136446210;
        v32 = "nw_webtransport_compare_stream_metadata";
        _os_log_impl(&dword_181A37000, v17, v28, "%{public}s called with null handle2, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_49;
  }

  if (((*(a3 + 20) ^ *(a2 + 20)) & 7) == 0)
  {
    if (!a4)
    {
      if (*a2 != *a3 || *(a2 + 16) != *(a3 + 16))
      {
        goto LABEL_4;
      }

      v10 = *(a2 + 8);
      v11 = *(a3 + 8);
      if (v10 != v11 && v10 && v11)
      {
        v12 = v7;
        v13 = strcmp(*(a2 + 8), v11);
        v7 = v12;
        if (!v13)
        {
          goto LABEL_4;
        }
      }

      else if (v10 == v11)
      {
        goto LABEL_4;
      }
    }

    v8 = 1;
    goto LABEL_7;
  }

LABEL_4:
  v8 = 0;
LABEL_7:

  return v8;
}

void nw_webtransport_deallocate_stream_metadata(int a1, void *a2)
{
  v3 = a2[1];
  if (v3)
  {
    free(v3);
  }

  free(a2);
}

uint64_t nw_webtransport_allocate_stream_metadata(void *a1)
{
  v1 = a1;
  v2 = malloc_type_calloc(1uLL, 0x18uLL, 0xD0AA5DD2uLL);
  v3 = v2;
  if (v2)
  {
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
LABEL_6:

    return v3;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = gLogObj;
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  v5 = _os_log_send_and_compose_impl();

  result = __nwlog_should_abort(v5);
  if (!result)
  {
    free(v5);
    MEMORY[0x10] = 0;
    MEMORY[8] = 0;
    MEMORY[0] = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    v8 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v8);
    if (!result)
    {
      free(v8);
      goto LABEL_6;
    }
  }

  __break(1u);
  return result;
}

uint64_t nw_webtransport_compare_options(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  v34 = *MEMORY[0x1E69E9840];
  v7 = a1;
  if (!a2)
  {
    v14 = __nwlog_obj();
    *buf = 136446210;
    v31 = "nw_webtransport_compare_options";
    v15 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v15, &type, &v28))
    {
      goto LABEL_49;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136446210;
        v31 = "nw_webtransport_compare_options";
        _os_log_impl(&dword_181A37000, v16, v17, "%{public}s called with null handle1", buf, 0xCu);
      }

      goto LABEL_48;
    }

    if (v28 != 1)
    {
      v16 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136446210;
        v31 = "nw_webtransport_compare_options";
        _os_log_impl(&dword_181A37000, v16, v25, "%{public}s called with null handle1, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_48;
    }

    backtrace_string = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v21 = type;
    v22 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *buf = 136446210;
        v31 = "nw_webtransport_compare_options";
        _os_log_impl(&dword_181A37000, v16, v21, "%{public}s called with null handle1, no backtrace", buf, 0xCu);
      }

      goto LABEL_48;
    }

    if (v22)
    {
      *buf = 136446466;
      v31 = "nw_webtransport_compare_options";
      v32 = 2082;
      v33 = backtrace_string;
      _os_log_impl(&dword_181A37000, v16, v21, "%{public}s called with null handle1, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_36;
  }

  if (!a3)
  {
    v18 = __nwlog_obj();
    *buf = 136446210;
    v31 = "nw_webtransport_compare_options";
    v15 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v15, &type, &v28))
    {
      goto LABEL_49;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136446210;
        v31 = "nw_webtransport_compare_options";
        _os_log_impl(&dword_181A37000, v16, v19, "%{public}s called with null handle2", buf, 0xCu);
      }

LABEL_48:

LABEL_49:
      if (v15)
      {
        free(v15);
      }

      goto LABEL_51;
    }

    if (v28 != 1)
    {
      v16 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v16, type))
      {
        *buf = 136446210;
        v31 = "nw_webtransport_compare_options";
        _os_log_impl(&dword_181A37000, v16, v26, "%{public}s called with null handle2, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_48;
    }

    backtrace_string = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v23 = type;
    v24 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *buf = 136446210;
        v31 = "nw_webtransport_compare_options";
        _os_log_impl(&dword_181A37000, v16, v23, "%{public}s called with null handle2, no backtrace", buf, 0xCu);
      }

      goto LABEL_48;
    }

    if (v24)
    {
      *buf = 136446466;
      v31 = "nw_webtransport_compare_options";
      v32 = 2082;
      v33 = backtrace_string;
      _os_log_impl(&dword_181A37000, v16, v23, "%{public}s called with null handle2, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_36:

    free(backtrace_string);
    goto LABEL_49;
  }

  v8 = *(a2 + 8);
  v9 = *(a3 + 8);
  if (v8)
  {
    if (!v9)
    {
      goto LABEL_51;
    }

    v10 = v8;
    v11 = v9;
    is_equal = _nw_http_fields_is_equal(v10);

    if (!is_equal)
    {
      goto LABEL_51;
    }
  }

  else if (v9)
  {
LABEL_51:
    v13 = 0;
    goto LABEL_52;
  }

  if (*a2 != *a3 || *(a2 + 16) != *(a3 + 16) || *(a2 + 20) != *(a3 + 20) || *(a2 + 24) != *(a3 + 24) || *(a2 + 28) != *(a3 + 28) || !a4 && ((*(a3 + 32) ^ *(a2 + 32)) & 3) != 0)
  {
    goto LABEL_51;
  }

  v13 = 1;
LABEL_52:

  return v13;
}

void nw_webtransport_deallocate_options(uint64_t a1, id *a2)
{
  v3 = a2[1];
  a2[1] = 0;

  free(a2);
}

uint64_t nw_webtransport_copy_options(void *a1, uint64_t a2)
{
  v26 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (a2)
  {
    options = nw_webtransport_allocate_options(v3);
    v6 = *(a2 + 8);
    if (v6)
    {
      v7 = v6;
      v8 = _nw_http_fields_copy(v7);

      v9 = *(options + 8);
      *(options + 8) = v8;
    }

    *options = *a2;
    *(options + 16) = *(a2 + 16);
    v10 = *(options + 32) & 0xFE | *(a2 + 32) & 1;
    *(options + 32) = v10;
    *(options + 32) = v10 & 0xFD | *(a2 + 32) & 2;
    goto LABEL_5;
  }

  v12 = __nwlog_obj();
  *buf = 136446210;
  v23 = "nw_webtransport_copy_options";
  v13 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v23 = "nw_webtransport_copy_options";
        _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null existing_handle", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v17 = type;
      v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *buf = 136446466;
          v23 = "nw_webtransport_copy_options";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v14, v17, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v18)
      {
        *buf = 136446210;
        v23 = "nw_webtransport_copy_options";
        _os_log_impl(&dword_181A37000, v14, v17, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v14 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *buf = 136446210;
        v23 = "nw_webtransport_copy_options";
        _os_log_impl(&dword_181A37000, v14, v19, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v13)
  {
    free(v13);
  }

  options = 0;
LABEL_5:

  return options;
}

uint64_t nw_webtransport_allocate_options(void *a1)
{
  v1 = a1;
  v2 = malloc_type_calloc(1uLL, 0x28uLL, 0x844937BEuLL);
  v3 = v2;
  if (v2)
  {
    v2[4] = 0;
    *v2 = 0u;
    *(v2 + 1) = 0u;
LABEL_6:

    return v3;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = gLogObj;
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  v5 = _os_log_send_and_compose_impl();

  result = __nwlog_should_abort(v5);
  if (!result)
  {
    free(v5);
    MEMORY[0x20] = 0;
    MEMORY[0x10] = 0u;
    MEMORY[0] = 0u;
    MEMORY[8] = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    v8 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v8);
    if (!result)
    {
      free(v8);
      goto LABEL_6;
    }
  }

  __break(1u);
  return result;
}

id nw_protocol_copy_webtransport_definition()
{
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
  }

  v1 = nw_protocol_copy_webtransport_definition::definition;

  return v1;
}

uint64_t nw_protocol_options_is_webtransport(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    {
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
    }

    v2 = nw_protocol_options_matches_definition(v1, nw_protocol_copy_webtransport_definition::definition);
    goto LABEL_5;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_protocol_options_is_webtransport";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_protocol_options_is_webtransport";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_protocol_options_is_webtransport";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_protocol_options_is_webtransport";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_protocol_options_is_webtransport";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
LABEL_5:

  return v2;
}

uint64_t nw_webtransport_options_get_is_unidirectional(void *a1)
{
  v25 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    {
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
    }

    v4 = nw_protocol_options_matches_definition(v3, nw_protocol_copy_webtransport_definition::definition);

    if (v4)
    {
      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x2020000000;
      v24 = 0;
      v20[0] = MEMORY[0x1E69E9820];
      v20[1] = 3221225472;
      v20[2] = __nw_webtransport_options_get_is_unidirectional_block_invoke;
      v20[3] = &unk_1E6A3A858;
      v20[4] = buf;
      nw_protocol_options_access_handle(v3, v20);
      v5 = *(*&buf[8] + 24);
      _Block_object_dispose(buf, 8);
      goto LABEL_6;
    }

    v11 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_options_get_is_unidirectional";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_is_unidirectional";
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol options are not webtransport", buf, 0xCu);
        }

LABEL_38:

        goto LABEL_39;
      }

      if (v21 != 1)
      {
        v9 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_is_unidirectional";
          _os_log_impl(&dword_181A37000, v9, v19, "%{public}s protocol options are not webtransport, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_is_unidirectional";
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol options are not webtransport, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_options_get_is_unidirectional";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol options are not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_options_get_is_unidirectional";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_is_unidirectional";
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v21 != 1)
      {
        v9 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_is_unidirectional";
          _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_is_unidirectional";
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_options_get_is_unidirectional";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_26:

      free(backtrace_string);
    }
  }

LABEL_39:
  if (v8)
  {
    free(v8);
  }

  v5 = 0;
LABEL_6:

  return v5 & 1;
}

void sub_1828C6D98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void nw_webtransport_options_set_is_unidirectional(void *a1, char a2)
{
  v29 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_webtransport_options_set_is_unidirectional";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
    {
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v26 = "nw_webtransport_options_set_is_unidirectional";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v23 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v26 = "nw_webtransport_options_set_is_unidirectional";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v8)
        {
          goto LABEL_6;
        }

LABEL_41:
        free(v8);
        goto LABEL_6;
      }

      if (v15)
      {
        *buf = 136446210;
        v26 = "nw_webtransport_options_set_is_unidirectional";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v26 = "nw_webtransport_options_set_is_unidirectional";
        _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_39:

    goto LABEL_40;
  }

  v5 = v3;
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
  }

  v6 = nw_protocol_options_matches_definition(v5, nw_protocol_copy_webtransport_definition::definition);

  if (v6)
  {
    v21[0] = MEMORY[0x1E69E9820];
    v21[1] = 3221225472;
    v21[2] = __nw_webtransport_options_set_is_unidirectional_block_invoke;
    v21[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v22 = a2;
    nw_protocol_options_access_handle(v5, v21);
    goto LABEL_6;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v26 = "nw_webtransport_options_set_is_unidirectional";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v8, &type, &v23))
  {
    goto LABEL_40;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v26 = "nw_webtransport_options_set_is_unidirectional";
      _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol options are not webtransport", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v23 != 1)
  {
    v9 = __nwlog_obj();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v26 = "nw_webtransport_options_set_is_unidirectional";
      _os_log_impl(&dword_181A37000, v9, v20, "%{public}s protocol options are not webtransport, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_39;
  }

  v16 = __nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *buf = 136446210;
      v26 = "nw_webtransport_options_set_is_unidirectional";
      _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol options are not webtransport, no backtrace", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v18)
  {
    *buf = 136446466;
    v26 = "nw_webtransport_options_set_is_unidirectional";
    v27 = 2082;
    v28 = v16;
    _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol options are not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
  {
    goto LABEL_41;
  }

LABEL_6:
}

uint64_t nw_webtransport_options_get_is_datagram(void *a1)
{
  v25 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    {
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
    }

    v4 = nw_protocol_options_matches_definition(v3, nw_protocol_copy_webtransport_definition::definition);

    if (v4)
    {
      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x2020000000;
      v24 = 0;
      v20[0] = MEMORY[0x1E69E9820];
      v20[1] = 3221225472;
      v20[2] = __nw_webtransport_options_get_is_datagram_block_invoke;
      v20[3] = &unk_1E6A3A858;
      v20[4] = buf;
      nw_protocol_options_access_handle(v3, v20);
      v5 = *(*&buf[8] + 24);
      _Block_object_dispose(buf, 8);
      goto LABEL_6;
    }

    v11 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_options_get_is_datagram";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_is_datagram";
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol options are not webtransport", buf, 0xCu);
        }

LABEL_38:

        goto LABEL_39;
      }

      if (v21 != 1)
      {
        v9 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_is_datagram";
          _os_log_impl(&dword_181A37000, v9, v19, "%{public}s protocol options are not webtransport, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_is_datagram";
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol options are not webtransport, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_options_get_is_datagram";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol options are not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_options_get_is_datagram";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_is_datagram";
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v21 != 1)
      {
        v9 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_is_datagram";
          _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_is_datagram";
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_options_get_is_datagram";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_26:

      free(backtrace_string);
    }
  }

LABEL_39:
  if (v8)
  {
    free(v8);
  }

  v5 = 0;
LABEL_6:

  return v5 & 1;
}

void sub_1828C78D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void nw_webtransport_options_set_is_datagram(void *a1, char a2)
{
  v29 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_webtransport_options_set_is_datagram";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
    {
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v26 = "nw_webtransport_options_set_is_datagram";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v23 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v26 = "nw_webtransport_options_set_is_datagram";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v8)
        {
          goto LABEL_6;
        }

LABEL_41:
        free(v8);
        goto LABEL_6;
      }

      if (v15)
      {
        *buf = 136446210;
        v26 = "nw_webtransport_options_set_is_datagram";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v26 = "nw_webtransport_options_set_is_datagram";
        _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_39:

    goto LABEL_40;
  }

  v5 = v3;
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
  }

  v6 = nw_protocol_options_matches_definition(v5, nw_protocol_copy_webtransport_definition::definition);

  if (v6)
  {
    v21[0] = MEMORY[0x1E69E9820];
    v21[1] = 3221225472;
    v21[2] = __nw_webtransport_options_set_is_datagram_block_invoke;
    v21[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v22 = a2;
    nw_protocol_options_access_handle(v5, v21);
    goto LABEL_6;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v26 = "nw_webtransport_options_set_is_datagram";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v8, &type, &v23))
  {
    goto LABEL_40;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v26 = "nw_webtransport_options_set_is_datagram";
      _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol options are not webtransport", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v23 != 1)
  {
    v9 = __nwlog_obj();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v26 = "nw_webtransport_options_set_is_datagram";
      _os_log_impl(&dword_181A37000, v9, v20, "%{public}s protocol options are not webtransport, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_39;
  }

  v16 = __nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *buf = 136446210;
      v26 = "nw_webtransport_options_set_is_datagram";
      _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol options are not webtransport, no backtrace", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v18)
  {
    *buf = 136446466;
    v26 = "nw_webtransport_options_set_is_datagram";
    v27 = 2082;
    v28 = v16;
    _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol options are not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
  {
    goto LABEL_41;
  }

LABEL_6:
}

uint64_t nw_webtransport_options_get_connection_max_sessions(void *a1)
{
  v25 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    {
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
    }

    v4 = nw_protocol_options_matches_definition(v3, nw_protocol_copy_webtransport_definition::definition);

    if (v4)
    {
      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x2020000000;
      v24 = 0;
      v20[0] = MEMORY[0x1E69E9820];
      v20[1] = 3221225472;
      v20[2] = __nw_webtransport_options_get_connection_max_sessions_block_invoke;
      v20[3] = &unk_1E6A3A858;
      v20[4] = buf;
      nw_protocol_options_access_handle(v3, v20);
      v5 = *(*&buf[8] + 24);
      _Block_object_dispose(buf, 8);
      goto LABEL_6;
    }

    v11 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_options_get_connection_max_sessions";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_connection_max_sessions";
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol options are not webtransport", buf, 0xCu);
        }

LABEL_38:

        goto LABEL_39;
      }

      if (v21 != 1)
      {
        v9 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_connection_max_sessions";
          _os_log_impl(&dword_181A37000, v9, v19, "%{public}s protocol options are not webtransport, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_connection_max_sessions";
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol options are not webtransport, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_options_get_connection_max_sessions";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol options are not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_options_get_connection_max_sessions";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_connection_max_sessions";
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v21 != 1)
      {
        v9 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_connection_max_sessions";
          _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_options_get_connection_max_sessions";
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_options_get_connection_max_sessions";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_26:

      free(backtrace_string);
    }
  }

LABEL_39:
  if (v8)
  {
    free(v8);
  }

  v5 = 0;
LABEL_6:

  return v5;
}

void sub_1828C8408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void nw_webtransport_options_set_connection_max_sessions(void *a1, uint64_t a2)
{
  v28 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_webtransport_options_set_connection_max_sessions";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v8, &type, &v22))
    {
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v25 = "nw_webtransport_options_set_connection_max_sessions";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v22 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v25 = "nw_webtransport_options_set_connection_max_sessions";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v8)
        {
          goto LABEL_6;
        }

LABEL_41:
        free(v8);
        goto LABEL_6;
      }

      if (v15)
      {
        *buf = 136446210;
        v25 = "nw_webtransport_options_set_connection_max_sessions";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v25 = "nw_webtransport_options_set_connection_max_sessions";
        _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_39:

    goto LABEL_40;
  }

  v5 = v3;
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
  }

  v6 = nw_protocol_options_matches_definition(v5, nw_protocol_copy_webtransport_definition::definition);

  if (v6)
  {
    v21[0] = MEMORY[0x1E69E9820];
    v21[1] = 3221225472;
    v21[2] = __nw_webtransport_options_set_connection_max_sessions_block_invoke;
    v21[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v21[4] = a2;
    nw_protocol_options_access_handle(v5, v21);
    goto LABEL_6;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v25 = "nw_webtransport_options_set_connection_max_sessions";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (!__nwlog_fault(v8, &type, &v22))
  {
    goto LABEL_40;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v25 = "nw_webtransport_options_set_connection_max_sessions";
      _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol options are not webtransport", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v22 != 1)
  {
    v9 = __nwlog_obj();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v25 = "nw_webtransport_options_set_connection_max_sessions";
      _os_log_impl(&dword_181A37000, v9, v20, "%{public}s protocol options are not webtransport, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_39;
  }

  v16 = __nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *buf = 136446210;
      v25 = "nw_webtransport_options_set_connection_max_sessions";
      _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol options are not webtransport, no backtrace", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v18)
  {
    *buf = 136446466;
    v25 = "nw_webtransport_options_set_connection_max_sessions";
    v26 = 2082;
    v27 = v16;
    _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol options are not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
  {
    goto LABEL_41;
  }

LABEL_6:
}

void nw_webtransport_options_add_connect_request_header(void *a1, uint64_t a2, uint64_t a3)
{
  v40 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    v9 = __nwlog_obj();
    *buf = 136446210;
    v37 = "nw_webtransport_options_add_connect_request_header";
    v10 = _os_log_send_and_compose_impl();

    v35 = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v10, &v35, &v34))
    {
      goto LABEL_74;
    }

    if (v35 == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = v35;
      if (os_log_type_enabled(v11, v35))
      {
        *buf = 136446210;
        v37 = "nw_webtransport_options_add_connect_request_header";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v34 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v20 = v35;
      v21 = os_log_type_enabled(v11, v35);
      if (backtrace_string)
      {
        if (v21)
        {
          *buf = 136446466;
          v37 = "nw_webtransport_options_add_connect_request_header";
          v38 = 2082;
          v39 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v20, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_74:
        if (!v10)
        {
          goto LABEL_8;
        }

LABEL_75:
        free(v10);
        goto LABEL_8;
      }

      if (v21)
      {
        *buf = 136446210;
        v37 = "nw_webtransport_options_add_connect_request_header";
        _os_log_impl(&dword_181A37000, v11, v20, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v29 = v35;
      if (os_log_type_enabled(v11, v35))
      {
        *buf = 136446210;
        v37 = "nw_webtransport_options_add_connect_request_header";
        _os_log_impl(&dword_181A37000, v11, v29, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_73:

    goto LABEL_74;
  }

  v7 = v5;
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
  }

  v8 = nw_protocol_options_matches_definition(v7, nw_protocol_copy_webtransport_definition::definition);

  if ((v8 & 1) == 0)
  {
    v13 = __nwlog_obj();
    *buf = 136446210;
    v37 = "nw_webtransport_options_add_connect_request_header";
    v10 = _os_log_send_and_compose_impl();

    v35 = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v10, &v35, &v34))
    {
      goto LABEL_74;
    }

    if (v35 == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v14 = v35;
      if (os_log_type_enabled(v11, v35))
      {
        *buf = 136446210;
        v37 = "nw_webtransport_options_add_connect_request_header";
        _os_log_impl(&dword_181A37000, v11, v14, "%{public}s protocol options are not webtransport", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v34 != 1)
    {
      v11 = __nwlog_obj();
      v30 = v35;
      if (os_log_type_enabled(v11, v35))
      {
        *buf = 136446210;
        v37 = "nw_webtransport_options_add_connect_request_header";
        _os_log_impl(&dword_181A37000, v11, v30, "%{public}s protocol options are not webtransport, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_73;
    }

    v22 = __nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v23 = v35;
    v24 = os_log_type_enabled(v11, v35);
    if (!v22)
    {
      if (v24)
      {
        *buf = 136446210;
        v37 = "nw_webtransport_options_add_connect_request_header";
        _os_log_impl(&dword_181A37000, v11, v23, "%{public}s protocol options are not webtransport, no backtrace", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v24)
    {
      *buf = 136446466;
      v37 = "nw_webtransport_options_add_connect_request_header";
      v38 = 2082;
      v39 = v22;
      _os_log_impl(&dword_181A37000, v11, v23, "%{public}s protocol options are not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_48;
  }

  if (!a2)
  {
    v15 = __nwlog_obj();
    *buf = 136446210;
    v37 = "nw_webtransport_options_add_connect_request_header";
    v10 = _os_log_send_and_compose_impl();

    v35 = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v10, &v35, &v34))
    {
      goto LABEL_74;
    }

    if (v35 == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v16 = v35;
      if (os_log_type_enabled(v11, v35))
      {
        *buf = 136446210;
        v37 = "nw_webtransport_options_add_connect_request_header";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null name", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v34 != 1)
    {
      v11 = __nwlog_obj();
      v31 = v35;
      if (os_log_type_enabled(v11, v35))
      {
        *buf = 136446210;
        v37 = "nw_webtransport_options_add_connect_request_header";
        _os_log_impl(&dword_181A37000, v11, v31, "%{public}s called with null name, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_73;
    }

    v22 = __nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v25 = v35;
    v26 = os_log_type_enabled(v11, v35);
    if (!v22)
    {
      if (v26)
      {
        *buf = 136446210;
        v37 = "nw_webtransport_options_add_connect_request_header";
        _os_log_impl(&dword_181A37000, v11, v25, "%{public}s called with null name, no backtrace", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v26)
    {
      *buf = 136446466;
      v37 = "nw_webtransport_options_add_connect_request_header";
      v38 = 2082;
      v39 = v22;
      _os_log_impl(&dword_181A37000, v11, v25, "%{public}s called with null name, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_48;
  }

  if (!a3)
  {
    v17 = __nwlog_obj();
    *buf = 136446210;
    v37 = "nw_webtransport_options_add_connect_request_header";
    v10 = _os_log_send_and_compose_impl();

    v35 = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v10, &v35, &v34))
    {
      goto LABEL_74;
    }

    if (v35 == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v18 = v35;
      if (os_log_type_enabled(v11, v35))
      {
        *buf = 136446210;
        v37 = "nw_webtransport_options_add_connect_request_header";
        _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null value", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v34 != 1)
    {
      v11 = __nwlog_obj();
      v32 = v35;
      if (os_log_type_enabled(v11, v35))
      {
        *buf = 136446210;
        v37 = "nw_webtransport_options_add_connect_request_header";
        _os_log_impl(&dword_181A37000, v11, v32, "%{public}s called with null value, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_73;
    }

    v22 = __nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v27 = v35;
    v28 = os_log_type_enabled(v11, v35);
    if (!v22)
    {
      if (v28)
      {
        *buf = 136446210;
        v37 = "nw_webtransport_options_add_connect_request_header";
        _os_log_impl(&dword_181A37000, v11, v27, "%{public}s called with null value, no backtrace", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v28)
    {
      *buf = 136446466;
      v37 = "nw_webtransport_options_add_connect_request_header";
      v38 = 2082;
      v39 = v22;
      _os_log_impl(&dword_181A37000, v11, v27, "%{public}s called with null value, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_48:

    free(v22);
    if (!v10)
    {
      goto LABEL_8;
    }

    goto LABEL_75;
  }

  v33[0] = MEMORY[0x1E69E9820];
  v33[1] = 3221225472;
  v33[2] = __nw_webtransport_options_add_connect_request_header_block_invoke;
  v33[3] = &__block_descriptor_48_e9_B16__0_v8l;
  v33[4] = a2;
  v33[5] = a3;
  nw_protocol_options_access_handle(v7, v33);
LABEL_8:
}

uint64_t __nw_webtransport_options_add_connect_request_header_block_invoke(uint64_t a1, uint64_t a2)
{
  v21 = *MEMORY[0x1E69E9840];
  if (!*(a2 + 8))
  {
    v4 = _nw_http_fields_create();
    v5 = *(a2 + 8);
    *(a2 + 8) = v4;
  }

  v6 = *(a1 + 32);
  if (strcmp(v6, ":protocol"))
  {
    nw_http_fields_append(*(a2 + 8), v6, *(a1 + 40));
    return 1;
  }

  if (!strcmp(*(a1 + 40), "webtransport"))
  {
    return 1;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_webtransport_options_add_connect_request_header_block_invoke";
  v9 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v9, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v18 = "nw_webtransport_options_add_connect_request_header_block_invoke";
        v12 = "%{public}s invalid :protocol";
LABEL_21:
        _os_log_impl(&dword_181A37000, v10, v11, v12, buf, 0xCu);
      }
    }

    else
    {
      if (v15 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v10 = __nwlog_obj();
        v11 = type;
        v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *buf = 136446466;
            v18 = "nw_webtransport_options_add_connect_request_header_block_invoke";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_181A37000, v10, v11, "%{public}s invalid :protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (!v14)
        {
          goto LABEL_22;
        }

        *buf = 136446210;
        v18 = "nw_webtransport_options_add_connect_request_header_block_invoke";
        v12 = "%{public}s invalid :protocol, no backtrace";
        goto LABEL_21;
      }

      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v18 = "nw_webtransport_options_add_connect_request_header_block_invoke";
        v12 = "%{public}s invalid :protocol, backtrace limit exceeded";
        goto LABEL_21;
      }
    }

LABEL_22:
  }

LABEL_23:
  if (v9)
  {
    free(v9);
  }

  return 0;
}

uint64_t __Block_byref_object_copy__63087(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

uint64_t nw_webtransport_create_metadata()
{
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
  }

  return _nw_protocol_metadata_create_singleton();
}

uint64_t nw_protocol_metadata_is_webtransport(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    {
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
    }

    v2 = nw_protocol_metadata_matches_definition(v1, nw_protocol_copy_webtransport_definition::definition);
    goto LABEL_5;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_protocol_metadata_is_webtransport";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_protocol_metadata_is_webtransport";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_protocol_metadata_is_webtransport";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_protocol_metadata_is_webtransport";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_protocol_metadata_is_webtransport";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
LABEL_5:

  return v2;
}

uint64_t nw_webtransport_metadata_get_stream_id(void *a1)
{
  v28 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    {
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
    }

    v4 = nw_protocol_metadata_matches_definition(v3, nw_protocol_copy_webtransport_definition::definition);

    if (v4)
    {
      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x2020000000;
      v27 = 0;
      v20[0] = MEMORY[0x1E69E9820];
      v20[1] = 3221225472;
      v21 = __nw_webtransport_metadata_get_stream_id_block_invoke;
      v22 = &unk_1E6A3A858;
      v23 = buf;
      if (_nw_protocol_metadata_get_handle(v3))
      {
        v21(v20);
      }

      v5 = *(*&buf[8] + 24);
      _Block_object_dispose(buf, 8);
      goto LABEL_8;
    }

    v11 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_metadata_get_stream_id";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_stream_id";
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
        }

LABEL_40:

        goto LABEL_41;
      }

      if (v24 != 1)
      {
        v9 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_stream_id";
          _os_log_impl(&dword_181A37000, v9, v19, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_stream_id";
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v17)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_metadata_get_stream_id";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_28;
    }
  }

  else
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_metadata_get_stream_id";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_stream_id";
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v24 != 1)
      {
        v9 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_stream_id";
          _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_stream_id";
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v15)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_metadata_get_stream_id";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_28:

      free(backtrace_string);
    }
  }

LABEL_41:
  if (v8)
  {
    free(v8);
  }

  v5 = -1;
LABEL_8:

  return v5;
}

void nw_webtransport_metadata_set_stream_id(void *a1, uint64_t a2)
{
  v31 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v28 = "nw_webtransport_metadata_set_stream_id";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v8, &type, &v25))
    {
      goto LABEL_41;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_stream_id";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v25 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v28 = "nw_webtransport_metadata_set_stream_id";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v8)
        {
          goto LABEL_7;
        }

LABEL_42:
        free(v8);
        goto LABEL_7;
      }

      if (v15)
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_stream_id";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_stream_id";
        _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_40:

    goto LABEL_41;
  }

  v5 = v3;
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
  }

  v6 = nw_protocol_metadata_matches_definition(v5, nw_protocol_copy_webtransport_definition::definition);

  if (v6)
  {
    v21[0] = MEMORY[0x1E69E9820];
    v21[1] = 3221225472;
    v22 = __nw_webtransport_metadata_set_stream_id_block_invoke;
    v23 = &__block_descriptor_40_e9_B16__0_v8l;
    v24 = a2;
    if (_nw_protocol_metadata_get_handle(v5))
    {
      v22(v21);
    }

    goto LABEL_7;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v28 = "nw_webtransport_metadata_set_stream_id";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v8, &type, &v25))
  {
    goto LABEL_41;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_stream_id";
      _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v25 != 1)
  {
    v9 = __nwlog_obj();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_stream_id";
      _os_log_impl(&dword_181A37000, v9, v20, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_40;
  }

  v16 = __nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_stream_id";
      _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v18)
  {
    *buf = 136446466;
    v28 = "nw_webtransport_metadata_set_stream_id";
    v29 = 2082;
    v30 = v16;
    _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
  {
    goto LABEL_42;
  }

LABEL_7:
}

uint64_t nw_webtransport_metadata_get_is_unidirectional(void *a1)
{
  v28 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    {
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
    }

    v4 = nw_protocol_metadata_matches_definition(v3, nw_protocol_copy_webtransport_definition::definition);

    if (v4)
    {
      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x2020000000;
      v27 = 0;
      v20[0] = MEMORY[0x1E69E9820];
      v20[1] = 3221225472;
      v21 = __nw_webtransport_metadata_get_is_unidirectional_block_invoke;
      v22 = &unk_1E6A3A858;
      v23 = buf;
      if (_nw_protocol_metadata_get_handle(v3))
      {
        (v21)(v20);
      }

      v5 = *(*&buf[8] + 24);
      _Block_object_dispose(buf, 8);
      goto LABEL_8;
    }

    v11 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
        }

LABEL_40:

        goto LABEL_41;
      }

      if (v24 != 1)
      {
        v9 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
          _os_log_impl(&dword_181A37000, v9, v19, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v17)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_28;
    }
  }

  else
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v24 != 1)
      {
        v9 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
          _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v15)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_28:

      free(backtrace_string);
    }
  }

LABEL_41:
  if (v8)
  {
    free(v8);
  }

  v5 = 0;
LABEL_8:

  return v5 & 1;
}

void nw_webtransport_metadata_set_is_unidirectional(void *a1, char a2)
{
  v31 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v28 = "nw_webtransport_metadata_set_is_unidirectional";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v8, &type, &v25))
    {
      goto LABEL_41;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_is_unidirectional";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v25 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v28 = "nw_webtransport_metadata_set_is_unidirectional";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v8)
        {
          goto LABEL_7;
        }

LABEL_42:
        free(v8);
        goto LABEL_7;
      }

      if (v15)
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_is_unidirectional";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_is_unidirectional";
        _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_40:

    goto LABEL_41;
  }

  v5 = v3;
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
  }

  v6 = nw_protocol_metadata_matches_definition(v5, nw_protocol_copy_webtransport_definition::definition);

  if (v6)
  {
    v21[0] = MEMORY[0x1E69E9820];
    v21[1] = 3221225472;
    v22 = __nw_webtransport_metadata_set_is_unidirectional_block_invoke;
    v23 = &__block_descriptor_33_e9_B16__0_v8l;
    v24 = a2;
    if (_nw_protocol_metadata_get_handle(v5))
    {
      (v22)(v21);
    }

    goto LABEL_7;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v28 = "nw_webtransport_metadata_set_is_unidirectional";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v8, &type, &v25))
  {
    goto LABEL_41;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_is_unidirectional";
      _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v25 != 1)
  {
    v9 = __nwlog_obj();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_is_unidirectional";
      _os_log_impl(&dword_181A37000, v9, v20, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_40;
  }

  v16 = __nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_is_unidirectional";
      _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v18)
  {
    *buf = 136446466;
    v28 = "nw_webtransport_metadata_set_is_unidirectional";
    v29 = 2082;
    v30 = v16;
    _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
  {
    goto LABEL_42;
  }

LABEL_7:
}

uint64_t nw_webtransport_metadata_get_is_datagram(void *a1)
{
  v28 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    {
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
    }

    v4 = nw_protocol_metadata_matches_definition(v3, nw_protocol_copy_webtransport_definition::definition);

    if (v4)
    {
      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x2020000000;
      v27 = 0;
      v20[0] = MEMORY[0x1E69E9820];
      v20[1] = 3221225472;
      v21 = __nw_webtransport_metadata_get_is_datagram_block_invoke;
      v22 = &unk_1E6A3A858;
      v23 = buf;
      if (_nw_protocol_metadata_get_handle(v3))
      {
        (v21)(v20);
      }

      v5 = *(*&buf[8] + 24);
      _Block_object_dispose(buf, 8);
      goto LABEL_8;
    }

    v11 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_metadata_get_is_datagram";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_datagram";
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
        }

LABEL_40:

        goto LABEL_41;
      }

      if (v24 != 1)
      {
        v9 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_datagram";
          _os_log_impl(&dword_181A37000, v9, v19, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_datagram";
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v17)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_metadata_get_is_datagram";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_28;
    }
  }

  else
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_metadata_get_is_datagram";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_datagram";
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v24 != 1)
      {
        v9 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_datagram";
          _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_datagram";
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v15)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_metadata_get_is_datagram";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_28:

      free(backtrace_string);
    }
  }

LABEL_41:
  if (v8)
  {
    free(v8);
  }

  v5 = 0;
LABEL_8:

  return v5 & 1;
}

void nw_webtransport_metadata_set_is_datagram(void *a1, char a2)
{
  v31 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v28 = "nw_webtransport_metadata_set_is_datagram";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v8, &type, &v25))
    {
      goto LABEL_41;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_is_datagram";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v25 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v28 = "nw_webtransport_metadata_set_is_datagram";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v8)
        {
          goto LABEL_7;
        }

LABEL_42:
        free(v8);
        goto LABEL_7;
      }

      if (v15)
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_is_datagram";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_is_datagram";
        _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_40:

    goto LABEL_41;
  }

  v5 = v3;
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
  }

  v6 = nw_protocol_metadata_matches_definition(v5, nw_protocol_copy_webtransport_definition::definition);

  if (v6)
  {
    v21[0] = MEMORY[0x1E69E9820];
    v21[1] = 3221225472;
    v22 = __nw_webtransport_metadata_set_is_datagram_block_invoke;
    v23 = &__block_descriptor_33_e9_B16__0_v8l;
    v24 = a2;
    if (_nw_protocol_metadata_get_handle(v5))
    {
      (v22)(v21);
    }

    goto LABEL_7;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v28 = "nw_webtransport_metadata_set_is_datagram";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v8, &type, &v25))
  {
    goto LABEL_41;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_is_datagram";
      _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v25 != 1)
  {
    v9 = __nwlog_obj();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_is_datagram";
      _os_log_impl(&dword_181A37000, v9, v20, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_40;
  }

  v16 = __nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_is_datagram";
      _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v18)
  {
    *buf = 136446466;
    v28 = "nw_webtransport_metadata_set_is_datagram";
    v29 = 2082;
    v30 = v16;
    _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
  {
    goto LABEL_42;
  }

LABEL_7:
}

uint64_t nw_webtransport_metadata_get_is_peer_initiated(void *a1)
{
  v28 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    {
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
    }

    v4 = nw_protocol_metadata_matches_definition(v3, nw_protocol_copy_webtransport_definition::definition);

    if (v4)
    {
      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x2020000000;
      v27 = 0;
      v20[0] = MEMORY[0x1E69E9820];
      v20[1] = 3221225472;
      v21 = __nw_webtransport_metadata_get_is_peer_initiated_block_invoke;
      v22 = &unk_1E6A3A858;
      v23 = buf;
      if (_nw_protocol_metadata_get_handle(v3))
      {
        (v21)(v20);
      }

      v5 = *(*&buf[8] + 24);
      _Block_object_dispose(buf, 8);
      goto LABEL_8;
    }

    v11 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
        }

LABEL_40:

        goto LABEL_41;
      }

      if (v24 != 1)
      {
        v9 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
          _os_log_impl(&dword_181A37000, v9, v19, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v17)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_28;
    }
  }

  else
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v24 != 1)
      {
        v9 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
          _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v15)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_28:

      free(backtrace_string);
    }
  }

LABEL_41:
  if (v8)
  {
    free(v8);
  }

  v5 = 0;
LABEL_8:

  return v5 & 1;
}

void nw_webtransport_metadata_set_is_peer_initiated(void *a1, char a2)
{
  v31 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v28 = "nw_webtransport_metadata_set_is_peer_initiated";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v8, &type, &v25))
    {
      goto LABEL_41;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_is_peer_initiated";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v25 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v28 = "nw_webtransport_metadata_set_is_peer_initiated";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v8)
        {
          goto LABEL_7;
        }

LABEL_42:
        free(v8);
        goto LABEL_7;
      }

      if (v15)
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_is_peer_initiated";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_is_peer_initiated";
        _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_40:

    goto LABEL_41;
  }

  v5 = v3;
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
  }

  v6 = nw_protocol_metadata_matches_definition(v5, nw_protocol_copy_webtransport_definition::definition);

  if (v6)
  {
    v21[0] = MEMORY[0x1E69E9820];
    v21[1] = 3221225472;
    v22 = __nw_webtransport_metadata_set_is_peer_initiated_block_invoke;
    v23 = &__block_descriptor_33_e9_B16__0_v8l;
    v24 = a2;
    if (_nw_protocol_metadata_get_handle(v5))
    {
      (v22)(v21);
    }

    goto LABEL_7;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v28 = "nw_webtransport_metadata_set_is_peer_initiated";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v8, &type, &v25))
  {
    goto LABEL_41;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_is_peer_initiated";
      _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v25 != 1)
  {
    v9 = __nwlog_obj();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_is_peer_initiated";
      _os_log_impl(&dword_181A37000, v9, v20, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_40;
  }

  v16 = __nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_is_peer_initiated";
      _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v18)
  {
    *buf = 136446466;
    v28 = "nw_webtransport_metadata_set_is_peer_initiated";
    v29 = 2082;
    v30 = v16;
    _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
  {
    goto LABEL_42;
  }

LABEL_7:
}

uint64_t nw_webtransport_metadata_get_session_error_code(void *a1)
{
  v28 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    {
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
    }

    v4 = nw_protocol_metadata_matches_definition(v3, nw_protocol_copy_webtransport_definition::definition);

    if (v4)
    {
      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x2020000000;
      v27 = 0;
      v20[0] = MEMORY[0x1E69E9820];
      v20[1] = 3221225472;
      v21 = __nw_webtransport_metadata_get_session_error_code_block_invoke;
      v22 = &unk_1E6A3A858;
      v23 = buf;
      if (_nw_protocol_metadata_get_handle(v3))
      {
        (v21)(v20);
      }

      v5 = *(*&buf[8] + 24);
      _Block_object_dispose(buf, 8);
      goto LABEL_8;
    }

    v11 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_metadata_get_session_error_code";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_session_error_code";
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
        }

LABEL_40:

        goto LABEL_41;
      }

      if (v24 != 1)
      {
        v9 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_session_error_code";
          _os_log_impl(&dword_181A37000, v9, v19, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_session_error_code";
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v17)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_metadata_get_session_error_code";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_28;
    }
  }

  else
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_metadata_get_session_error_code";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_session_error_code";
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v24 != 1)
      {
        v9 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_session_error_code";
          _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_session_error_code";
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v15)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_metadata_get_session_error_code";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_28:

      free(backtrace_string);
    }
  }

LABEL_41:
  if (v8)
  {
    free(v8);
  }

  v5 = 0;
LABEL_8:

  return v5;
}

void nw_webtransport_metadata_set_session_error_code(void *a1, int a2)
{
  v31 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v28 = "nw_webtransport_metadata_set_session_error_code";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v8, &type, &v25))
    {
      goto LABEL_41;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_session_error_code";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v25 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v28 = "nw_webtransport_metadata_set_session_error_code";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v8)
        {
          goto LABEL_7;
        }

LABEL_42:
        free(v8);
        goto LABEL_7;
      }

      if (v15)
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_session_error_code";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_session_error_code";
        _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_40:

    goto LABEL_41;
  }

  v5 = v3;
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
  }

  v6 = nw_protocol_metadata_matches_definition(v5, nw_protocol_copy_webtransport_definition::definition);

  if (v6)
  {
    v21[0] = MEMORY[0x1E69E9820];
    v21[1] = 3221225472;
    v22 = __nw_webtransport_metadata_set_session_error_code_block_invoke;
    v23 = &__block_descriptor_36_e9_B16__0_v8l;
    v24 = a2;
    if (_nw_protocol_metadata_get_handle(v5))
    {
      (v22)(v21);
    }

    goto LABEL_7;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v28 = "nw_webtransport_metadata_set_session_error_code";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v8, &type, &v25))
  {
    goto LABEL_41;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_session_error_code";
      _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v25 != 1)
  {
    v9 = __nwlog_obj();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_session_error_code";
      _os_log_impl(&dword_181A37000, v9, v20, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_40;
  }

  v16 = __nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_session_error_code";
      _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v18)
  {
    *buf = 136446466;
    v28 = "nw_webtransport_metadata_set_session_error_code";
    v29 = 2082;
    v30 = v16;
    _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
  {
    goto LABEL_42;
  }

LABEL_7:
}

uint64_t nw_webtransport_metadata_get_session_error_message(void *a1)
{
  v28 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    {
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
    }

    v4 = nw_protocol_metadata_matches_definition(v3, nw_protocol_copy_webtransport_definition::definition);

    if (v4)
    {
      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x2020000000;
      v27 = 0;
      v20[0] = MEMORY[0x1E69E9820];
      v20[1] = 3221225472;
      v21 = __nw_webtransport_metadata_get_session_error_message_block_invoke;
      v22 = &unk_1E6A3A858;
      v23 = buf;
      if (_nw_protocol_metadata_get_handle(v3))
      {
        (v21)(v20);
      }

      v5 = *(*&buf[8] + 24);
      _Block_object_dispose(buf, 8);
      goto LABEL_8;
    }

    v11 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_metadata_get_session_error_message";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_session_error_message";
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
        }

LABEL_40:

        goto LABEL_41;
      }

      if (v24 != 1)
      {
        v9 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_session_error_message";
          _os_log_impl(&dword_181A37000, v9, v19, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_session_error_message";
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v17)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_metadata_get_session_error_message";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_28;
    }
  }

  else
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_webtransport_metadata_get_session_error_message";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_session_error_message";
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v24 != 1)
      {
        v9 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_session_error_message";
          _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *buf = 136446210;
          *&buf[4] = "nw_webtransport_metadata_get_session_error_message";
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v15)
      {
        *buf = 136446466;
        *&buf[4] = "nw_webtransport_metadata_get_session_error_message";
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_28:

      free(backtrace_string);
    }
  }

LABEL_41:
  if (v8)
  {
    free(v8);
  }

  v5 = 0;
LABEL_8:

  return v5;
}

void nw_webtransport_metadata_set_session_error_message(void *a1, uint64_t a2)
{
  v31 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v28 = "nw_webtransport_metadata_set_session_error_message";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v8, &type, &v25))
    {
      goto LABEL_41;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_session_error_message";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v25 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v28 = "nw_webtransport_metadata_set_session_error_message";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v8)
        {
          goto LABEL_7;
        }

LABEL_42:
        free(v8);
        goto LABEL_7;
      }

      if (v15)
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_session_error_message";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v28 = "nw_webtransport_metadata_set_session_error_message";
        _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_40:

    goto LABEL_41;
  }

  v5 = v3;
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
  {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_62942);
  }

  v6 = nw_protocol_metadata_matches_definition(v5, nw_protocol_copy_webtransport_definition::definition);

  if (v6)
  {
    v21[0] = MEMORY[0x1E69E9820];
    v21[1] = 3221225472;
    v22 = __nw_webtransport_metadata_set_session_error_message_block_invoke;
    v23 = &__block_descriptor_40_e9_B16__0_v8l;
    v24 = a2;
    if (_nw_protocol_metadata_get_handle(v5))
    {
      (v22)(v21);
    }

    goto LABEL_7;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v28 = "nw_webtransport_metadata_set_session_error_message";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v8, &type, &v25))
  {
    goto LABEL_41;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_session_error_message";
      _os_log_impl(&dword_181A37000, v9, v12, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v25 != 1)
  {
    v9 = __nwlog_obj();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_session_error_message";
      _os_log_impl(&dword_181A37000, v9, v20, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_40;
  }

  v16 = __nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *buf = 136446210;
      v28 = "nw_webtransport_metadata_set_session_error_message";
      _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v18)
  {
    *buf = 136446466;
    v28 = "nw_webtransport_metadata_set_session_error_message";
    v29 = 2082;
    v30 = v16;
    _os_log_impl(&dword_181A37000, v9, v17, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
  {
    goto LABEL_42;
  }

LABEL_7:
}

uint64_t __nw_webtransport_metadata_set_session_error_message_block_invoke(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 8);
  if (v4)
  {
    free(v4);
    *(a2 + 8) = 0;
  }

  v5 = *(a1 + 32);
  if (!v5)
  {
    return 1;
  }

  v6 = strdup(v5);
  if (v6)
  {
LABEL_5:
    *(a2 + 8) = v6;
    return 1;
  }

  v8 = __nwlog_obj();
  os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  v9 = _os_log_send_and_compose_impl();

  result = __nwlog_should_abort(v9);
  if (!result)
  {
    free(v9);
    v6 = 0;
    goto LABEL_5;
  }

  __break(1u);
  return result;
}

uint64_t __nw_protocol_http3_create_block_invoke(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    *(*(*(a1 + 32) + 8) + 24) = 0;
  }

  return *(*(*(a1 + 32) + 8) + 24);
}

void __nw_protocol_http3_create_block_invoke_2(uint64_t a1)
{
  v23 = *MEMORY[0x1E69E9840];
  v1 = *(a1 + 32);
  if (v1)
  {
    if ((*(v1 + 1399) & 0x20) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = gLogObj;
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        v3 = *(v1 + 1304);
        *buf = 136446978;
        v16 = "nw_http3_cancel";
        v17 = 2082;
        v18 = (v1 + 1313);
        v19 = 2080;
        v20 = " ";
        v21 = 1024;
        v22 = v3;
        _os_log_impl(&dword_181A37000, v2, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u> cancelling", buf, 0x26u);
      }
    }

    v4 = *(v1 + 888);
    if (v4)
    {
      do
      {
        callbacks = v4[8].callbacks;
        nw_protocol_http3_stream_error(v4, v1);
        v4 = callbacks;
      }

      while (callbacks);
    }

    v6 = *(v1 + 1256);
    if (v6)
    {
      nw_quic_connection_close_with_error(v6, 256);
    }

    nw_http3_async_close_connection_if_no_stream(v1);
    return;
  }

  __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_http3_cancel";
  v7 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_25;
      }

      *buf = 136446210;
      v16 = "nw_http3_cancel";
      v10 = "%{public}s called with null http3";
      goto LABEL_24;
    }

    if (v13 != 1)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_25;
      }

      *buf = 136446210;
      v16 = "nw_http3_cancel";
      v10 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_24;
    }

    backtrace_string = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v12 = os_log_type_enabled(v8, type);
    if (backtrace_string)
    {
      if (v12)
      {
        *buf = 136446466;
        v16 = "nw_http3_cancel";
        v17 = 2082;
        v18 = backtrace_string;
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
      goto LABEL_25;
    }

    if (v12)
    {
      *buf = 136446210;
      v16 = "nw_http3_cancel";
      v10 = "%{public}s called with null http3, no backtrace";
LABEL_24:
      _os_log_impl(&dword_181A37000, v8, v9, v10, buf, 0xCu);
    }
  }

LABEL_25:
  if (v7)
  {
    free(v7);
  }
}

void __nw_protocol_http3_create_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v36 = *MEMORY[0x1E69E9840];
  if (a2)
  {
    v5 = nw_quic_connection_copy_sec_protocol_metadata(*(a2 + 1256));
    if (v5)
    {
      v6 = v5;
      if (!*(a2 + 1208))
      {
        v11 = sec_protocol_metadata_copy_authenticator();
        *(a2 + 1208) = v11;
        if (v11)
        {
          v12 = *(a2 + 1056);
          v13 = *(a2 + 1272);
          *buf = MEMORY[0x1E69E9820];
          *&buf[8] = 0x40000000;
          *&buf[16] = ___ZL34nw_protocol_http3_send_certificatePvP12sec_identity_block_invoke;
          v33 = &unk_1E6A38970;
          v34 = v12;
          nw_queue_context_async(v13, buf);
        }

        else if ((*(a2 + 1399) & 0x20) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v20 = gLogObj;
          if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
          {
            v21 = *(a2 + 1304);
            *buf = 136447234;
            *&buf[4] = "nw_protocol_http3_send_certificate";
            *&buf[12] = 2082;
            *&buf[14] = a2 + 1313;
            *&buf[22] = 2080;
            v33 = " ";
            LOWORD(v34) = 1024;
            *(&v34 + 2) = v21;
            HIWORD(v34) = 2112;
            v35 = a3;
            _os_log_impl(&dword_181A37000, v20, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Failed to generate authenticator for identity %@", buf, 0x30u);
          }
        }

        goto LABEL_21;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *buf = 136446210;
      *&buf[4] = "nw_protocol_http3_send_certificate";
      v7 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v30 = 0;
      if (__nwlog_fault(v7, &type, &v30))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v8 = gLogObj;
          v9 = type;
          if (!os_log_type_enabled(gLogObj, type))
          {
            goto LABEL_19;
          }

          *buf = 136446210;
          *&buf[4] = "nw_protocol_http3_send_certificate";
          v10 = "%{public}s HTTP3 got request to send certificate while one is already being sent, ignoring";
LABEL_17:
          v18 = v8;
          v19 = v9;
LABEL_18:
          _os_log_impl(&dword_181A37000, v18, v19, v10, buf, 0xCu);
          goto LABEL_19;
        }

        if (v30 != 1)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v8 = gLogObj;
          v9 = type;
          if (!os_log_type_enabled(gLogObj, type))
          {
            goto LABEL_19;
          }

          *buf = 136446210;
          *&buf[4] = "nw_protocol_http3_send_certificate";
          v10 = "%{public}s HTTP3 got request to send certificate while one is already being sent, ignoring, backtrace limit exceeded";
          goto LABEL_17;
        }

        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = gLogObj;
        v16 = type;
        v17 = os_log_type_enabled(gLogObj, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *buf = 136446466;
            *&buf[4] = "nw_protocol_http3_send_certificate";
            *&buf[12] = 2082;
            *&buf[14] = backtrace_string;
            _os_log_impl(&dword_181A37000, v15, v16, "%{public}s HTTP3 got request to send certificate while one is already being sent, ignoring, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (v17)
        {
          *buf = 136446210;
          *&buf[4] = "nw_protocol_http3_send_certificate";
          v10 = "%{public}s HTTP3 got request to send certificate while one is already being sent, ignoring, no backtrace";
          v18 = v15;
          v19 = v16;
          goto LABEL_18;
        }
      }

LABEL_19:
      if (v7)
      {
        free(v7);
      }

LABEL_21:
      os_release(v6);
      return;
    }

    __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_protocol_http3_send_certificate";
    v22 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v22, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v23 = __nwlog_obj();
        v24 = type;
        if (!os_log_type_enabled(v23, type))
        {
          goto LABEL_56;
        }

        *buf = 136446210;
        *&buf[4] = "nw_protocol_http3_send_certificate";
        v25 = "%{public}s called with null sec_metadata";
        goto LABEL_55;
      }

      if (v30 != 1)
      {
        v23 = __nwlog_obj();
        v24 = type;
        if (!os_log_type_enabled(v23, type))
        {
          goto LABEL_56;
        }

        *buf = 136446210;
        *&buf[4] = "nw_protocol_http3_send_certificate";
        v25 = "%{public}s called with null sec_metadata, backtrace limit exceeded";
        goto LABEL_55;
      }

      v28 = __nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = type;
      v29 = os_log_type_enabled(v23, type);
      if (v28)
      {
        if (v29)
        {
          *buf = 136446466;
          *&buf[4] = "nw_protocol_http3_send_certificate";
          *&buf[12] = 2082;
          *&buf[14] = v28;
          _os_log_impl(&dword_181A37000, v23, v24, "%{public}s called with null sec_metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v28);
        if (v22)
        {
          goto LABEL_57;
        }

        return;
      }

      if (v29)
      {
        *buf = 136446210;
        *&buf[4] = "nw_protocol_http3_send_certificate";
        v25 = "%{public}s called with null sec_metadata, no backtrace";
LABEL_55:
        _os_log_impl(&dword_181A37000, v23, v24, v25, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_protocol_http3_send_certificate";
    v22 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v22, &type, &v30))
    {
      goto LABEL_56;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
      {
        goto LABEL_56;
      }

      *buf = 136446210;
      *&buf[4] = "nw_protocol_http3_send_certificate";
      v25 = "%{public}s called with null handle";
      goto LABEL_55;
    }

    if (v30 != 1)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
      {
        goto LABEL_56;
      }

      *buf = 136446210;
      *&buf[4] = "nw_protocol_http3_send_certificate";
      v25 = "%{public}s called with null handle, backtrace limit exceeded";
      goto LABEL_55;
    }

    v26 = __nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v24 = type;
    v27 = os_log_type_enabled(v23, type);
    if (!v26)
    {
      if (!v27)
      {
        goto LABEL_56;
      }

      *buf = 136446210;
      *&buf[4] = "nw_protocol_http3_send_certificate";
      v25 = "%{public}s called with null handle, no backtrace";
      goto LABEL_55;
    }

    if (v27)
    {
      *buf = 136446466;
      *&buf[4] = "nw_protocol_http3_send_certificate";
      *&buf[12] = 2082;
      *&buf[14] = v26;
      _os_log_impl(&dword_181A37000, v23, v24, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v26);
  }

LABEL_56:
  if (v22)
  {
LABEL_57:
    free(v22);
  }
}

void ___ZL34nw_protocol_http3_send_certificatePvP12sec_identity_block_invoke(uint64_t a1)
{
  v1 = (*(*(a1 + 32) + 16))();
  if (v1)
  {
    if (*(v1 + 1288) == 3 && !*(v1 + 920))
    {
      *(v1 + 1288) = 2;

      nw_http3_control_stream_process_output(v1);
    }

    else
    {
      *(v1 + 1399) |= 2u;
    }
  }
}

__n128 __Block_byref_object_copy__63268(uint64_t a1, uint64_t a2)
{
  result = *(a2 + 40);
  *(a1 + 40) = result;
  return result;
}

uint64_t ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_32(void *a1, uint64_t a2)
{
  LODWORD(__n) = 0;
  v4 = nw_frame_unclaimed_bytes(a2, &__n);
  v5 = *(*(a1[4] + 8) + 24);
  v6 = a1[5] - v5;
  v7 = (a1[6] + v5);
  if (v6 >= __n)
  {
    memcpy(v4, v7, __n);
  }

  else
  {
    memcpy(v4, v7, a1[5] - v5);
    nw_frame_claim(a2, v8, 0, __n - v6);
  }

  *(*(a1[4] + 8) + 24) += __n;
  return 1;
}

uint64_t ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_48(uint64_t a1, uint64_t a2)
{
  LODWORD(__n) = 0;
  v4 = nw_frame_unclaimed_bytes(a2, &__n);
  v5 = (a1 + 48);
  v6 = *(a1 + 48);
  v7 = v6 - *(*(*(a1 + 32) + 8) + 24);
  if (v7 >= __n)
  {
    memcpy(v4, v5, __n);
  }

  else
  {
    memcpy(v4, v5, v6 - *(*(*(a1 + 32) + 8) + 24));
    nw_frame_claim(a2, v8, 0, __n - v7);
  }

  *(*(*(a1 + 32) + 8) + 24) += __n;
  return 1;
}

uint64_t ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_2_50(uint64_t result)
{
  v1 = *(result + 40);
  v2 = *(v1 + 192);
  if (v2)
  {
    v3 = *(v2 + 24);
    if (v3)
    {
      if (*(v3 + 96))
      {
        v4 = *(result + 48);
        v5 = *(*(result + 32) + 8);
        if (v4 < 0x40)
        {
          v6 = 2;
        }

        else
        {
          v6 = 3;
        }

        nw_http3_framer_write_http3_frame_header(v1 + 160, 7uLL, v4, v6, *(v5 + 40));
        v7 = *(*(v2 + 24) + 96);

        return v7(v2, v5 + 40);
      }
    }
  }

  return result;
}

uint64_t ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_52(uint64_t a1, uint64_t a2)
{
  v9 = 0;
  v4 = nw_frame_unclaimed_bytes(a2, &v9);
  v5 = *(a1 + 48) - *(*(*(a1 + 32) + 8) + 24);
  v6 = *(*(a1 + 40) + 1208);
  if (v5 >= v9)
  {
    v21 = 0;
    v22 = &v21;
    v23 = 0x2000000000;
    v24 = 0;
    v17 = 0;
    v18 = &v17;
    v19 = 0x2000000000;
    v20 = v4;
    if (v6)
    {
      applier = MEMORY[0x1E69E9820];
      v11 = 0x40000000;
      v12 = __nw_dispatch_data_copyout_block_invoke;
      v13 = &unk_1E6A34348;
      v15 = &v17;
      v16 = v9;
      v14 = &v21;
      dispatch_data_apply(v6, &applier);
    }

    _Block_object_dispose(&v17, 8);
    _Block_object_dispose(&v21, 8);
  }

  else
  {
    v21 = 0;
    v22 = &v21;
    v23 = 0x2000000000;
    v24 = 0;
    v17 = 0;
    v18 = &v17;
    v19 = 0x2000000000;
    v20 = v4;
    if (v6)
    {
      applier = MEMORY[0x1E69E9820];
      v11 = 0x40000000;
      v12 = __nw_dispatch_data_copyout_block_invoke;
      v13 = &unk_1E6A34348;
      v15 = &v17;
      v16 = v5;
      v14 = &v21;
      dispatch_data_apply(v6, &applier);
    }

    _Block_object_dispose(&v17, 8);
    _Block_object_dispose(&v21, 8);
    nw_frame_claim(a2, v7, 0, v9 - v5);
  }

  *(*(*(a1 + 32) + 8) + 24) += v9;
  return 1;
}

void ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_2_54(uint64_t a1)
{
  v2 = *(a1 + 40);
  v3 = *(v2 + 192);
  if (v3)
  {
    v4 = *(v3 + 24);
    if (v4)
    {
      if (*(v4 + 96))
      {
        v5 = *(a1 + 48);
        v6 = *(*(a1 + 32) + 8);
        if (v5 >> 30)
        {
          v7 = 16;
        }

        else
        {
          v7 = 12;
        }

        if (v5 >= 0x4000)
        {
          v8 = v7;
        }

        else
        {
          v8 = 10;
        }

        if (v5 >= 0x40)
        {
          v9 = v8;
        }

        else
        {
          v9 = 9;
        }

        nw_http3_framer_write_http3_frame_header(v2 + 160, 0xFF8E1EB5uLL, v5, v9, *(v6 + 40));
        (*(*(v3 + 24) + 96))(v3, v6 + 40);
        v2 = *(a1 + 40);
      }
    }
  }

  v10 = *(v2 + 1208);
  if (v10)
  {
    os_release(v10);
    *(*(a1 + 40) + 1208) = 0;
  }
}

void ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_34(uint64_t a1, void *a2, int a3)
{
  v82 = *MEMORY[0x1E69E9840];
  if (a3 <= 1)
  {
    if (a3)
    {
      if (a3 != 1)
      {
        return;
      }

      outbound_body_size = nw_http_transaction_metadata_get_outbound_body_size(a2);
      v12 = *(a1 + 32);
      if (v12)
      {
        if ((*(v12 + 732) & 0x2000) != 0)
        {
          return;
        }
      }

      if (__nwlog_http_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_http_log::onceToken, &__block_literal_global_36);
      }

      v13 = ghttpLogObj;
      if (!os_log_type_enabled(ghttpLogObj, OS_LOG_TYPE_INFO))
      {
        return;
      }

      v14 = *(a1 + 32);
      v15 = (v14 + 632);
      v16 = "";
      v17 = v14 == 0;
      if (!v14)
      {
        v15 = "";
      }

      v18 = *(*(v14 + 344) + 1304);
      v19 = *(v14 + 240);
      if (!v17)
      {
        v16 = " ";
      }

      *buf = 136447490;
      v71 = "nw_http3_control_stream_process_output_block_invoke";
      v72 = 2082;
      v73 = v15;
      v74 = 2080;
      v75 = v16;
      v76 = 1024;
      v77 = v18;
      v78 = 2048;
      v79 = v19;
      v80 = 2048;
      v81 = outbound_body_size;
      v20 = "%{public}s %{public}s%s<i%u:s%llu> finished sending {body_bytes=%llu}";
      goto LABEL_45;
    }

    outbound_message = nw_http_transaction_metadata_get_outbound_message(a2);
    v22 = nw_http_metadata_copy_request(outbound_message);
    v45 = nw_http_metadata_copy_response(outbound_message);
    if (v22)
    {
      v69[0] = MEMORY[0x1E69E9820];
      v69[1] = 0x40000000;
      v69[2] = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_2_35;
      v69[3] = &__block_descriptor_tmp_37_63330;
      v69[4] = *(a1 + 32);
      v46 = v22;
      v47 = v69;
      _nw_http_request_access_method(v46, v47);
    }

    if (v45)
    {
      v26 = v45;
      status_code = _nw_http_response_get_status_code(v26);

      v49 = *(a1 + 32);
      if (v49 && (*(v49 + 732) & 0x2000) != 0)
      {
        goto LABEL_60;
      }

      if (__nwlog_http_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_http_log::onceToken, &__block_literal_global_36);
      }

      v29 = ghttpLogObj;
      if (!os_log_type_enabled(ghttpLogObj, OS_LOG_TYPE_INFO))
      {
        goto LABEL_60;
      }

      v50 = *(a1 + 32);
      v51 = (v50 + 632);
      v52 = "";
      v53 = v50 == 0;
      if (!v50)
      {
        v51 = "";
      }

      v54 = *(*(v50 + 344) + 1304);
      v55 = *(v50 + 240);
      if (!v53)
      {
        v52 = " ";
      }

      *buf = 136447490;
      v71 = "nw_http3_control_stream_process_output_block_invoke";
      v72 = 2082;
      v73 = v51;
      v74 = 2080;
      v75 = v52;
      v76 = 1024;
      v77 = v54;
      v78 = 2048;
      v79 = v55;
      v80 = 1024;
      LODWORD(v81) = status_code;
      v36 = "%{public}s %{public}s%s<i%u:s%llu> sending response header {status=%hu}";
      goto LABEL_59;
    }
  }

  else
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
        if (a3 != 4)
        {
          return;
        }

        v63[0] = MEMORY[0x1E69E9820];
        v63[1] = 0x40000000;
        v64 = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_40;
        v65 = &__block_descriptor_tmp_42_63336;
        v5 = *(a1 + 32);
        v66 = a2;
        v67 = v5;
        v6 = nw_http_transaction_metadata_get_outbound_message(a2);
        v7 = v6;
        if (v6)
        {
          v8 = nw_http_metadata_copy_request(v6);
          v9 = nw_http_metadata_copy_response(v7);
          inbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
          if (!inbound_message)
          {
            goto LABEL_69;
          }

          if (v8)
          {
            if (v9)
            {
              goto LABEL_70;
            }

LABEL_68:
            v9 = nw_http_metadata_copy_response(inbound_message);
LABEL_69:
            if (!v9)
            {
              v58 = 0;
              if (!v8)
              {
                goto LABEL_84;
              }

              goto LABEL_73;
            }

LABEL_70:
            v9 = v9;
            v58 = _nw_http_response_get_status_code(v9);

            if (!v8)
            {
LABEL_84:
              v64(v63, "", v58);
              v59 = 0;
              if (!inbound_message)
              {
LABEL_75:
                if (v7)
                {
                  os_release(v7);
                }

                if (v9)
                {
                  os_release(v9);
                }

                if (v59)
                {
                  v56 = v59;
                  goto LABEL_81;
                }

                return;
              }

LABEL_74:
              os_release(inbound_message);
              goto LABEL_75;
            }

LABEL_73:
            v61[0] = MEMORY[0x1E69E9820];
            v61[1] = 0x40000000;
            v61[2] = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_43;
            v61[3] = &unk_1E6A38A40;
            v61[4] = v63;
            v62 = v58;
            v59 = v8;
            v60 = v61;
            _nw_http_request_access_method(v59, v60);

            if (!inbound_message)
            {
              goto LABEL_75;
            }

            goto LABEL_74;
          }
        }

        else
        {
          v57 = nw_http_transaction_metadata_get_inbound_message(a2);
          v9 = 0;
          if (!v57)
          {
            v58 = 0;
            inbound_message = 0;
            goto LABEL_84;
          }

          inbound_message = v57;
        }

        v8 = nw_http_metadata_copy_request(inbound_message);
        if (v9)
        {
          goto LABEL_70;
        }

        goto LABEL_68;
      }

      inbound_body_size = nw_http_transaction_metadata_get_inbound_body_size(a2);
      v38 = *(a1 + 32);
      if (v38 && (*(v38 + 732) & 0x2000) != 0)
      {
        return;
      }

      if (__nwlog_http_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_http_log::onceToken, &__block_literal_global_36);
      }

      v13 = ghttpLogObj;
      if (!os_log_type_enabled(ghttpLogObj, OS_LOG_TYPE_INFO))
      {
        return;
      }

      v39 = *(a1 + 32);
      v40 = (v39 + 632);
      v41 = "";
      v42 = v39 == 0;
      if (!v39)
      {
        v40 = "";
      }

      v43 = *(*(v39 + 344) + 1304);
      v44 = *(v39 + 240);
      if (!v42)
      {
        v41 = " ";
      }

      *buf = 136447490;
      v71 = "nw_http3_control_stream_process_output_block_invoke";
      v72 = 2082;
      v73 = v40;
      v74 = 2080;
      v75 = v41;
      v76 = 1024;
      v77 = v43;
      v78 = 2048;
      v79 = v44;
      v80 = 2048;
      v81 = inbound_body_size;
      v20 = "%{public}s %{public}s%s<i%u:s%llu> finished receiving {body_bytes=%llu}";
LABEL_45:
      _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_INFO, v20, buf, 0x3Au);
      return;
    }

    outbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
    v22 = nw_http_metadata_copy_request(outbound_message);
    v23 = nw_http_metadata_copy_response(outbound_message);
    if (v22)
    {
      v68[0] = MEMORY[0x1E69E9820];
      v68[1] = 0x40000000;
      v68[2] = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_38;
      v68[3] = &__block_descriptor_tmp_39_63333;
      v68[4] = *(a1 + 32);
      v24 = v22;
      v25 = v68;
      _nw_http_request_access_method(v24, v25);
    }

    if (v23)
    {
      v26 = v23;
      v27 = _nw_http_response_get_status_code(v26);

      v28 = *(a1 + 32);
      if (v28 && (*(v28 + 732) & 0x2000) != 0)
      {
        goto LABEL_60;
      }

      if (__nwlog_http_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_http_log::onceToken, &__block_literal_global_36);
      }

      v29 = ghttpLogObj;
      if (!os_log_type_enabled(ghttpLogObj, OS_LOG_TYPE_INFO))
      {
        goto LABEL_60;
      }

      v30 = *(a1 + 32);
      v31 = (v30 + 632);
      v32 = "";
      v33 = v30 == 0;
      if (!v30)
      {
        v31 = "";
      }

      v34 = *(*(v30 + 344) + 1304);
      v35 = *(v30 + 240);
      if (!v33)
      {
        v32 = " ";
      }

      *buf = 136447490;
      v71 = "nw_http3_control_stream_process_output_block_invoke";
      v72 = 2082;
      v73 = v31;
      v74 = 2080;
      v75 = v32;
      v76 = 1024;
      v77 = v34;
      v78 = 2048;
      v79 = v35;
      v80 = 1024;
      LODWORD(v81) = v27;
      v36 = "%{public}s %{public}s%s<i%u:s%llu> receiving response header {status=%hu}";
LABEL_59:
      _os_log_impl(&dword_181A37000, v29, OS_LOG_TYPE_INFO, v36, buf, 0x36u);
LABEL_60:
      os_release(v26);
    }
  }

  if (v22)
  {
    os_release(v22);
  }

  if (outbound_message)
  {
    v56 = outbound_message;
LABEL_81:
    os_release(v56);
  }
}

void ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_2_35(uint64_t a1, uint64_t a2)
{
  v24 = *MEMORY[0x1E69E9840];
  v4 = *(a1 + 32);
  if (!v4 || (*(v4 + 732) & 0x2000) == 0)
  {
    if (__nwlog_http_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_http_log::onceToken, &__block_literal_global_36);
    }

    v5 = ghttpLogObj;
    if (os_log_type_enabled(ghttpLogObj, OS_LOG_TYPE_INFO))
    {
      v6 = *(a1 + 32);
      v7 = (v6 + 632);
      v8 = "";
      v9 = v6 == 0;
      if (!v6)
      {
        v7 = "";
      }

      v10 = *(*(v6 + 344) + 1304);
      v11 = *(v6 + 240);
      if (!v9)
      {
        v8 = " ";
      }

      v12 = 136447490;
      v13 = "nw_http3_control_stream_process_output_block_invoke_2";
      v14 = 2082;
      v15 = v7;
      v16 = 2080;
      v17 = v8;
      v18 = 1024;
      v19 = v10;
      v20 = 2048;
      v21 = v11;
      v22 = 2082;
      v23 = a2;
      _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> sending request header {method=%{public}s}", &v12, 0x3Au);
    }
  }
}

void ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_38(uint64_t a1, uint64_t a2)
{
  v24 = *MEMORY[0x1E69E9840];
  v4 = *(a1 + 32);
  if (!v4 || (*(v4 + 732) & 0x2000) == 0)
  {
    if (__nwlog_http_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_http_log::onceToken, &__block_literal_global_36);
    }

    v5 = ghttpLogObj;
    if (os_log_type_enabled(ghttpLogObj, OS_LOG_TYPE_INFO))
    {
      v6 = *(a1 + 32);
      v7 = (v6 + 632);
      v8 = "";
      v9 = v6 == 0;
      if (!v6)
      {
        v7 = "";
      }

      v10 = *(*(v6 + 344) + 1304);
      v11 = *(v6 + 240);
      if (!v9)
      {
        v8 = " ";
      }

      v12 = 136447490;
      v13 = "nw_http3_control_stream_process_output_block_invoke";
      v14 = 2082;
      v15 = v7;
      v16 = 2080;
      v17 = v8;
      v18 = 1024;
      v19 = v10;
      v20 = 2048;
      v21 = v11;
      v22 = 2082;
      v23 = a2;
      _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> receiving request header {method=%{public}s}", &v12, 0x3Au);
    }
  }
}

void ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_40(uint64_t a1, uint64_t a2, int a3)
{
  v66 = *MEMORY[0x1E69E9840];
  start_reason = nw_http_transaction_metadata_get_start_reason(*(a1 + 32));
  start_time = nw_http_transaction_metadata_get_start_time(*(a1 + 32));
  end_time = nw_http_transaction_metadata_get_end_time(*(a1 + 32));
  outbound_message_start_time = nw_http_transaction_metadata_get_outbound_message_start_time(*(a1 + 32));
  outbound_message_end_time = nw_http_transaction_metadata_get_outbound_message_end_time(*(a1 + 32));
  inbound_message_start_time = nw_http_transaction_metadata_get_inbound_message_start_time(*(a1 + 32));
  inbound_message_end_time = nw_http_transaction_metadata_get_inbound_message_end_time(*(a1 + 32));
  outbound_body_size = nw_http_transaction_metadata_get_outbound_body_size(*(a1 + 32));
  inbound_body_size = nw_http_transaction_metadata_get_inbound_body_size(*(a1 + 32));
  v12 = *(a1 + 40);
  if (!v12 || (*(v12 + 732) & 0x2000) == 0)
  {
    if (__nwlog_http_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_http_log::onceToken, &__block_literal_global_36);
    }

    v13 = ghttpLogObj;
    if (os_log_type_enabled(ghttpLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v14 = *(a1 + 40);
      if (v14)
      {
        v15 = (v14 + 632);
      }

      else
      {
        v15 = "";
      }

      v16 = " ";
      if (!v14)
      {
        v16 = "";
      }

      v31 = v15;
      v32 = v16;
      if ((start_reason - 1) > 3)
      {
        v17 = "initial";
      }

      else
      {
        v17 = off_1E6A3AE00[start_reason - 1];
      }

      v28 = *(*(v14 + 344) + 1304);
      v29 = *(v14 + 240);
      v30 = v17;
      v18 = -1;
      if (start_time && end_time)
      {
        v19 = nw_delta_nanos(start_time, end_time);
        if (v19 > 0xF423FFFFFFFFFLL)
        {
          v18 = -1;
        }

        else
        {
          v18 = v19 / 0xF4240;
        }
      }

      v20 = -1;
      if (start_time && outbound_message_start_time)
      {
        v21 = nw_delta_nanos(start_time, outbound_message_start_time);
        if (v21 > 0xF423FFFFFFFFFLL)
        {
          v20 = -1;
        }

        else
        {
          v20 = v21 / 0xF4240;
        }
      }

      v22 = -1;
      if (outbound_message_start_time && outbound_message_end_time)
      {
        v23 = nw_delta_nanos(outbound_message_start_time, outbound_message_end_time);
        if (v23 > 0xF423FFFFFFFFFLL)
        {
          v22 = -1;
        }

        else
        {
          v22 = v23 / 0xF4240;
        }
      }

      v24 = -1;
      if (start_time && inbound_message_start_time)
      {
        v25 = nw_delta_nanos(start_time, inbound_message_start_time);
        if (v25 > 0xF423FFFFFFFFFLL)
        {
          v24 = -1;
        }

        else
        {
          v24 = v25 / 0xF4240;
        }
      }

      LODWORD(v26) = -1;
      if (inbound_message_start_time && inbound_message_end_time)
      {
        v27 = nw_delta_nanos(inbound_message_start_time, inbound_message_end_time);
        v26 = v27 / 0xF4240;
        if (v27 > 0xF423FFFFFFFFFLL)
        {
          LODWORD(v26) = -1;
        }
      }

      *buf = 136449794;
      v37 = "nw_http3_control_stream_process_output_block_invoke";
      v38 = 2082;
      v39 = v31;
      v40 = 2080;
      v41 = v32;
      v42 = 1024;
      v43 = v28;
      v44 = 2048;
      v45 = v29;
      v46 = 2080;
      v47 = v30;
      v48 = 1024;
      v49 = v18;
      v50 = 2082;
      v51 = a2;
      v52 = 1024;
      v53 = a3;
      v54 = 1024;
      v55 = v20;
      v56 = 1024;
      v57 = v22;
      v58 = 1024;
      v59 = v24;
      v60 = 1024;
      v61 = v26;
      v62 = 2048;
      v63 = outbound_body_size;
      v64 = 2048;
      v65 = inbound_body_size;
      _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u:s%llu> transaction summary {start_reason=%s, duration_ms=%d, request_method=%{public}s, response_status=%hu, outbound_start_ms=%d, outbound_duration_ms=%d, inbound_start_ms=%d, inbound_duration_ms=%d, outbound_body_bytes=%llu, inbound_body_bytes=%llu}", buf, 0x7Cu);
    }
  }
}

void nw_protocol_http3_stream_error(nw_protocol *a1, nw_protocol *a2)
{
  v34 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_protocol_http3_stream_error";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
    {
      goto LABEL_54;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_54;
      }

      *buf = 136446210;
      v25 = "nw_protocol_http3_stream_error";
      v10 = "%{public}s called with null protocol";
    }

    else if (v22 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v17 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *buf = 136446466;
          v25 = "nw_protocol_http3_stream_error";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_54:
        if (!v7)
        {
          return;
        }

        goto LABEL_55;
      }

      if (!v17)
      {
        goto LABEL_54;
      }

      *buf = 136446210;
      v25 = "nw_protocol_http3_stream_error";
      v10 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_54;
      }

      *buf = 136446210;
      v25 = "nw_protocol_http3_stream_error";
      v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_53;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_protocol_http3_stream_error";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
    {
      goto LABEL_54;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v22 != 1)
      {
        v8 = __nwlog_obj();
        v9 = type;
        if (!os_log_type_enabled(v8, type))
        {
          goto LABEL_54;
        }

        *buf = 136446210;
        v25 = "nw_protocol_http3_stream_error";
        v10 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_53;
      }

      v18 = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v19 = os_log_type_enabled(v8, type);
      if (!v18)
      {
        if (!v19)
        {
          goto LABEL_54;
        }

        *buf = 136446210;
        v25 = "nw_protocol_http3_stream_error";
        v10 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_53;
      }

      if (v19)
      {
        *buf = 136446466;
        v25 = "nw_protocol_http3_stream_error";
        v26 = 2082;
        v27 = v18;
        v20 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_38:
        _os_log_impl(&dword_181A37000, v8, v9, v20, buf, 0x16u);
      }

LABEL_39:
      free(v18);
      if (!v7)
      {
        return;
      }

LABEL_55:
      free(v7);
      return;
    }

    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
    {
      goto LABEL_54;
    }

    *buf = 136446210;
    v25 = "nw_protocol_http3_stream_error";
    v10 = "%{public}s called with null http3_stream";
LABEL_53:
    _os_log_impl(&dword_181A37000, v8, v9, v10, buf, 0xCu);
    goto LABEL_54;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_protocol_http3_stream_error";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
    {
      goto LABEL_54;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_54;
      }

      *buf = 136446210;
      v25 = "nw_protocol_http3_stream_error";
      v10 = "%{public}s called with null other_protocol";
      goto LABEL_53;
    }

    if (v22 != 1)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_54;
      }

      *buf = 136446210;
      v25 = "nw_protocol_http3_stream_error";
      v10 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_53;
    }

    v18 = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v21 = os_log_type_enabled(v8, type);
    if (!v18)
    {
      if (!v21)
      {
        goto LABEL_54;
      }

      *buf = 136446210;
      v25 = "nw_protocol_http3_stream_error";
      v10 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_53;
    }

    if (v21)
    {
      *buf = 136446466;
      v25 = "nw_protocol_http3_stream_error";
      v26 = 2082;
      v27 = v18;
      v20 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_38;
    }

    goto LABEL_39;
  }

  if ((handle[366] & 0x2000) == 0 && gLogDatapath == 1)
  {
    v11 = handle;
    v12 = __nwlog_obj();
    v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
    handle = v11;
    if (v13)
    {
      v14 = *(v11[43] + 1304);
      v15 = v11[30];
      *buf = 136447234;
      v25 = "nw_protocol_http3_stream_error";
      v26 = 2082;
      v27 = (v11 + 79);
      v28 = 2080;
      v29 = " ";
      v30 = 1024;
      v31 = v14;
      v32 = 2048;
      v33 = v15;
      _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      handle = v11;
    }
  }

  nw_http3_stream_get_application_error(handle);
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    callbacks = default_input_handler->callbacks;
    if (callbacks)
    {
      error = callbacks->error;
      if (error)
      {
        error();
      }
    }
  }
}

void nw_http3_async_close_connection_if_no_stream(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if ((*(a1 + 1399) & 0x20) == 0 && gLogDatapath == 1)
  {
    v4 = __nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v5 = *(a1 + 1304);
      *buf = 136446978;
      v8 = "nw_http3_async_close_connection_if_no_stream";
      v9 = 2082;
      v10 = a1 + 1313;
      v11 = 2080;
      v12 = " ";
      v13 = 1024;
      v14 = v5;
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }

  *(a1 + 1397) |= 8u;
  nw_protocol_remove_instance(a1);
  if (!*(a1 + 888))
  {
    v2 = *(a1 + 1056);
    v3 = *(a1 + 1272);
    v6[0] = MEMORY[0x1E69E9820];
    v6[1] = 0x40000000;
    v6[2] = ___ZL44nw_http3_async_close_connection_if_no_streamP17nw_protocol_http3_block_invoke;
    v6[3] = &unk_1E6A38928;
    v6[4] = v2;
    nw_queue_context_async(v3, v6);
  }
}

void ___ZL44nw_http3_async_close_connection_if_no_streamP17nw_protocol_http3_block_invoke(uint64_t a1)
{
  v1 = (*(*(a1 + 32) + 16))();
  if (v1)
  {

    nw_http3_connection_destroy(v1, v2);
  }
}

void nw_http3_connection_destroy(uint64_t a1, uint64_t a2)
{
  *(&v127[1] + 6) = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v2 = a1;
    if ((*(a1 + 1399) & 0x20) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_INFO))
      {
        v4 = *(v2 + 1304);
        *buf = 136447234;
        *&buf[4] = "nw_http3_connection_destroy";
        *&buf[12] = 2082;
        *&buf[14] = v2 + 1313;
        *&buf[22] = 2080;
        v125 = " ";
        v126 = 1024;
        LODWORD(v127[0]) = v4;
        WORD2(v127[0]) = 2048;
        *(v127 + 6) = v2;
        _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> destroying %p", buf, 0x30u);
      }
    }

    v5 = *(v2 + 1280);
    if (v5)
    {
      nw_queue_cancel_source(v5, a2);
      *(v2 + 1280) = 0;
    }

    v6 = *(v2 + 1104);
    if (v6)
    {
      (*(*v6 + 8))(v6, v2, 0);
    }

    nw_http_connection_metadata_closed(*(v2 + 1264));
    v7 = *(v2 + 1256);
    if (v7)
    {
      if ((*(v2 + 1397) & 0x200) != 0 || (nw_quic_connection_close_with_error(v7, 256), (v7 = *(v2 + 1256)) != 0))
      {
        os_release(v7);
        *(v2 + 1256) = 0;
      }
    }

    v8 = *(v2 + 1264);
    if (v8)
    {
      os_release(v8);
      *(v2 + 1264) = 0;
    }

    v9 = *(v2 + 888);
    if (v9)
    {
      do
      {
        v10 = *(v9 + 536);
        if ((*(v2 + 1399) & 0x20) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v11 = gLogObj;
          if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
          {
            v12 = *(v2 + 1304);
            *buf = 136447234;
            *&buf[4] = "nw_http3_connection_destroy";
            *&buf[12] = 2082;
            *&buf[14] = v2 + 1313;
            *&buf[22] = 2080;
            v125 = " ";
            v126 = 1024;
            LODWORD(v127[0]) = v12;
            WORD2(v127[0]) = 2048;
            *(v127 + 6) = v9;
            _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> should not have stream %p left, destroying anyways", buf, 0x30u);
          }
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *buf = 136446210;
        *&buf[4] = "nw_http3_connection_destroy";
        v13 = _os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v121 = 0;
        if (!__nwlog_fault(v13, type, &v121))
        {
          goto LABEL_35;
        }

        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = gLogObj;
          v15 = type[0];
          if (os_log_type_enabled(gLogObj, type[0]))
          {
            *buf = 136446210;
            *&buf[4] = "nw_http3_connection_destroy";
            v16 = v14;
            v17 = v15;
            v18 = "%{public}s should not have streams left when destroying";
LABEL_34:
            _os_log_impl(&dword_181A37000, v16, v17, v18, buf, 0xCu);
          }
        }

        else if (v121 == 1)
        {
          backtrace_string = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v20 = gLogObj;
          v21 = type[0];
          v22 = os_log_type_enabled(gLogObj, type[0]);
          if (backtrace_string)
          {
            if (v22)
            {
              *buf = 136446466;
              *&buf[4] = "nw_http3_connection_destroy";
              *&buf[12] = 2082;
              *&buf[14] = backtrace_string;
              _os_log_impl(&dword_181A37000, v20, v21, "%{public}s should not have streams left when destroying, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_35;
          }

          if (v22)
          {
            *buf = 136446210;
            *&buf[4] = "nw_http3_connection_destroy";
            v16 = v20;
            v17 = v21;
            v18 = "%{public}s should not have streams left when destroying, no backtrace";
            goto LABEL_34;
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v23 = gLogObj;
          v24 = type[0];
          if (os_log_type_enabled(gLogObj, type[0]))
          {
            *buf = 136446210;
            *&buf[4] = "nw_http3_connection_destroy";
            v16 = v23;
            v17 = v24;
            v18 = "%{public}s should not have streams left when destroying, backtrace limit exceeded";
            goto LABEL_34;
          }
        }

LABEL_35:
        if (v13)
        {
          free(v13);
        }

        nw_protocol_http3_stream_destroy(v9);
        v9 = v10;
      }

      while (v10);
    }

    nw_http3_teardown_uni_streams(v2);
    if (!*(v2 + 1296))
    {
LABEL_55:
      v41 = *(v2 + 984);
      if (v41)
      {
        while (1)
        {
          v42 = v41[19];
          if (gLogDatapath == 1)
          {
            loga = __nwlog_obj();
            if (os_log_type_enabled(loga, OS_LOG_TYPE_DEBUG))
            {
              *buf = 136446210;
              *&buf[4] = "nw_protocol_finalize_temp_frame_array";
              _os_log_impl(&dword_181A37000, loga, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
            }
          }

          v43 = v41[8];
          if (v43)
          {
            *(v43 + 40) = type;
            v44 = v41[9];
            *type = v43;
            v123 = v44;
            v41[8] = 0;
            v41[9] = v41 + 8;
            *buf = MEMORY[0x1E69E9820];
            *&buf[8] = 0x40000000;
            *&buf[16] = ___ZL25__nw_frame_array_finalizeP16nw_frame_array_sbb_block_invoke;
            v125 = &__block_descriptor_tmp_21_49595;
            LOBYTE(v126) = 0;
            do
            {
              v45 = *type;
              if (!*type)
              {
                break;
              }

              v46 = *(*type + 32);
              v47 = *(*type + 40);
              v48 = (v46 + 40);
              if (!v46)
              {
                v48 = &v123;
              }

              *v48 = v47;
              *v47 = v46;
              *(v45 + 32) = 0;
              *(v45 + 40) = 0;
            }

            while (((*&buf[16])(buf) & 1) != 0);
          }

          v49 = v41[4];
          if (!v49)
          {
            break;
          }

          v50 = *(v49 + 24);
          if (!v50)
          {
            break;
          }

          v51 = *(v50 + 8);
          if (!v51)
          {
            break;
          }

          v51(v49, v41);
LABEL_67:
          nw_protocol_http3_untyped_stream_destroy(v41);
          v41 = v42;
          if (!v42)
          {
            goto LABEL_112;
          }
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v52 = v41[4];
        if (v52)
        {
          v53 = *(v52 + 16);
          if (!v53)
          {
            v53 = "invalid";
          }
        }

        else
        {
          v53 = "invalid";
        }

        *buf = 136446466;
        *&buf[4] = "nw_http3_connection_destroy";
        *&buf[12] = 2082;
        *&buf[14] = v53;
        v54 = _os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v121 = 0;
        log = v54;
        if (__nwlog_fault(v54, type, &v121))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v116 = __nwlog_obj();
            v113 = type[0];
            if (!os_log_type_enabled(v116, type[0]))
            {
              goto LABEL_110;
            }

            v55 = v41[4];
            if (v55)
            {
              v56 = *(v55 + 16);
              if (!v56)
              {
                v56 = "invalid";
              }
            }

            else
            {
              v56 = "invalid";
            }

            *buf = 136446466;
            *&buf[4] = "nw_http3_connection_destroy";
            *&buf[12] = 2082;
            *&buf[14] = v56;
            v63 = v116;
            v64 = v113;
            v65 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
            goto LABEL_109;
          }

          if (v121 != 1)
          {
            v118 = __nwlog_obj();
            v115 = type[0];
            if (!os_log_type_enabled(v118, type[0]))
            {
              goto LABEL_110;
            }

            v61 = v41[4];
            if (v61)
            {
              v62 = *(v61 + 16);
              if (!v62)
              {
                v62 = "invalid";
              }
            }

            else
            {
              v62 = "invalid";
            }

            *buf = 136446466;
            *&buf[4] = "nw_http3_connection_destroy";
            *&buf[12] = 2082;
            *&buf[14] = v62;
            v63 = v118;
            v64 = v115;
            v65 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
            goto LABEL_109;
          }

          v117 = __nw_create_backtrace_string();
          v114 = __nwlog_obj();
          v112 = type[0];
          v57 = os_log_type_enabled(v114, type[0]);
          v58 = v117;
          if (v117)
          {
            if (v57)
            {
              v59 = v41[4];
              if (v59)
              {
                v60 = *(v59 + 16);
                if (!v60)
                {
                  v60 = "invalid";
                }
              }

              else
              {
                v60 = "invalid";
              }

              *buf = 136446722;
              *&buf[4] = "nw_http3_connection_destroy";
              *&buf[12] = 2082;
              *&buf[14] = v60;
              *&buf[22] = 2082;
              v125 = v117;
              _os_log_impl(&dword_181A37000, v114, v112, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
              v58 = v117;
            }

            free(v58);
            goto LABEL_110;
          }

          if (v57)
          {
            v66 = v41[4];
            if (v66)
            {
              v67 = *(v66 + 16);
              if (!v67)
              {
                v67 = "invalid";
              }
            }

            else
            {
              v67 = "invalid";
            }

            v63 = v114;
            v64 = v112;
            *buf = 136446466;
            *&buf[4] = "nw_http3_connection_destroy";
            *&buf[12] = 2082;
            *&buf[14] = v67;
            v65 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
LABEL_109:
            _os_log_impl(&dword_181A37000, v63, v64, v65, buf, 0x16u);
          }
        }

LABEL_110:
        if (log)
        {
          free(log);
        }

        goto LABEL_67;
      }

LABEL_112:
      v68 = *(v2 + 304);
      if (v68)
      {
        do
        {
          v69 = v68[2];
          free(v68);
          v68 = v69;
        }

        while (v69);
      }

      v70 = *(v2 + 328);
      if (v70)
      {
        do
        {
          v71 = *v70;
          free(v70);
          v70 = v71;
        }

        while (v71);
      }

      free(*(v2 + 320));
      free(*(v2 + 464));
      v72 = *(v2 + 448);
      if (v72)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v72);
        fwrite("cleaned up", 0xAuLL, 1uLL, *(v2 + 448));
        fputc(10, *(v2 + 448));
      }

      v73 = *(v2 + 568);
      if (v73)
      {
        do
        {
          v74 = *v73;
          free(v73);
          v73 = v74;
        }

        while (v74);
      }

      v75 = *(v2 + 720);
      if ((v75 - 1) > 4)
      {
        if ((v75 - 8) > 6 || (v76 = *(v2 + 768)) == 0)
        {
LABEL_126:
          v77 = *(v2 + 548);
          v78 = *(v2 + 552);
          while (v77 != v78)
          {
            v76 = *(*(v2 + 560) + 8 * v78);
            v78 = (v78 + 1) % *(v2 + 544);
            *(v2 + 552) = v78;
            v79 = v76[2] - 1;
            v76[2] = v79;
            if (!v79)
            {
              goto LABEL_125;
            }
          }

          free(*(v2 + 560));
          *(v2 + 544) = 0;
          *(v2 + 552) = 0;
          *(v2 + 560) = 0;
          v80 = *(v2 + 536);
          if (v80)
          {
            fwrite("qdec: debug: ", 0xDuLL, 1uLL, v80);
            fwrite("cleaned up", 0xAuLL, 1uLL, *(v2 + 536));
            fputc(10, *(v2 + 536));
          }

          v81 = *(v2 + 1232);
          if (v81)
          {
            v82 = *(v2 + 1240);
            if (v82)
            {
              nw_association_unregister(v81, v82);
            }
          }

          v83 = *(v2 + 1224);
          if (v83)
          {
            os_release(v83);
            *(v2 + 1224) = 0;
          }

          v84 = *(v2 + 1232);
          if (v84)
          {
            os_release(v84);
            *(v2 + 1232) = 0;
          }

          v85 = *(v2 + 1240);
          if (v85)
          {
            os_release(v85);
            *(v2 + 1240) = 0;
          }

          v86 = *(v2 + 1248);
          if (v86)
          {
            os_release(v86);
            *(v2 + 1248) = 0;
          }

          v87 = *(v2 + 1112);
          if (v87)
          {
            os_release(v87);
            *(v2 + 1112) = 0;
          }

          v88 = *(v2 + 1120);
          if (v88)
          {
            os_release(v88);
            *(v2 + 1120) = 0;
          }

          v89 = *(v2 + 1128);
          if (v89)
          {
            os_release(v89);
            *(v2 + 1128) = 0;
          }

          v90 = *(v2 + 1136);
          if (v90)
          {
            os_release(v90);
            *(v2 + 1136) = 0;
          }

          v91 = *(v2 + 1144);
          if (v91)
          {
            os_release(v91);
            *(v2 + 1144) = 0;
          }

          v92 = *(v2 + 1272);
          if (v92)
          {
            os_release(v92);
            *(v2 + 1272) = 0;
          }

          v93 = *(v2 + 1192);
          if (v93)
          {
            dispatch_release(v93);
            *(v2 + 1192) = 0;
          }

          v94 = *(v2 + 1200);
          if (v94)
          {
            dispatch_release(v94);
            *(v2 + 1200) = 0;
          }

          v95 = *(v2 + 1208);
          if (v95)
          {
            dispatch_release(v95);
            *(v2 + 1208) = 0;
          }

          v96 = *(v2 + 1176);
          if (v96)
          {
            dispatch_release(v96);
            *(v2 + 1176) = 0;
          }

          v97 = *(v2 + 1184);
          if (v97)
          {
            dispatch_release(v97);
            *(v2 + 1184) = 0;
          }

          v98 = *(v2 + 1168);
          if (v98)
          {
            dispatch_release(v98);
            *(v2 + 1168) = 0;
          }

          v99 = *(v2 + 1152);
          if (v99)
          {
            dispatch_release(v99);
            *(v2 + 1152) = 0;
          }

          v100 = *(v2 + 1160);
          if (v100)
          {
            dispatch_release(v100);
            *(v2 + 1160) = 0;
          }

          v101 = *(v2 + 1216);
          if (v101)
          {
            dispatch_release(v101);
            *(v2 + 1216) = 0;
          }

          v102 = *(v2 + 856);
          if (v102)
          {
            _Block_release(v102);
            *(v2 + 856) = 0;
          }

          v103 = *(v2 + 864);
          if (v103)
          {
            dispatch_release(v103);
            *(v2 + 864) = 0;
          }

          v104 = *(v2 + 872);
          if (v104)
          {
            _Block_release(v104);
            *(v2 + 872) = 0;
          }

          v105 = *(v2 + 880);
          if (v105)
          {
            dispatch_release(v105);
            *(v2 + 880) = 0;
          }

          (*(*(v2 + 1056) + 16))(*(v2 + 1056), 0);
          v106 = *(v2 + 1056);
          if (v106)
          {
            _Block_release(v106);
          }

          goto LABEL_183;
        }
      }

      else
      {
        v76 = *(v2 + 776);
        if (!v76)
        {
          goto LABEL_126;
        }
      }

LABEL_125:
      free(v76);
      goto LABEL_126;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v25 = *(v2 + 1296);
    v26 = *(v25 + 80);
    *buf = 136446722;
    *&buf[4] = "nw_http3_connection_destroy";
    *&buf[12] = 2048;
    *&buf[14] = v25;
    *&buf[22] = 2048;
    v125 = v26;
    v27 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v121 = 0;
    if (__nwlog_fault(v27, type, &v121))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = gLogObj;
        v29 = type[0];
        if (os_log_type_enabled(gLogObj, type[0]))
        {
          v30 = *(v2 + 1296);
          v31 = *(v30 + 80);
          *buf = 136446722;
          *&buf[4] = "nw_http3_connection_destroy";
          *&buf[12] = 2048;
          *&buf[14] = v30;
          *&buf[22] = 2048;
          v125 = v31;
          v32 = "%{public}s untyped inbound stream %p with id %llu should not have been set when destroying";
LABEL_51:
          _os_log_impl(&dword_181A37000, v28, v29, v32, buf, 0x20u);
        }
      }

      else if (v121 == 1)
      {
        v33 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = gLogObj;
        v29 = type[0];
        v34 = os_log_type_enabled(gLogObj, type[0]);
        if (v33)
        {
          if (v34)
          {
            v35 = *(v2 + 1296);
            v36 = *(v35 + 80);
            *buf = 136446978;
            *&buf[4] = "nw_http3_connection_destroy";
            *&buf[12] = 2048;
            *&buf[14] = v35;
            *&buf[22] = 2048;
            v125 = v36;
            v126 = 2082;
            v127[0] = v33;
            _os_log_impl(&dword_181A37000, v28, v29, "%{public}s untyped inbound stream %p with id %llu should not have been set when destroying, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v33);
          goto LABEL_52;
        }

        if (v34)
        {
          v39 = *(v2 + 1296);
          v40 = *(v39 + 80);
          *buf = 136446722;
          *&buf[4] = "nw_http3_connection_destroy";
          *&buf[12] = 2048;
          *&buf[14] = v39;
          *&buf[22] = 2048;
          v125 = v40;
          v32 = "%{public}s untyped inbound stream %p with id %llu should not have been set when destroying, no backtrace";
          goto LABEL_51;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = gLogObj;
        v29 = type[0];
        if (os_log_type_enabled(gLogObj, type[0]))
        {
          v37 = *(v2 + 1296);
          v38 = *(v37 + 80);
          *buf = 136446722;
          *&buf[4] = "nw_http3_connection_destroy";
          *&buf[12] = 2048;
          *&buf[14] = v37;
          *&buf[22] = 2048;
          v125 = v38;
          v32 = "%{public}s untyped inbound stream %p with id %llu should not have been set when destroying, backtrace limit exceeded";
          goto LABEL_51;
        }
      }
    }

LABEL_52:
    if (v27)
    {
      free(v27);
    }

    *(v2 + 1296) = 0;
    goto LABEL_55;
  }

  __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_http3_connection_destroy";
  v2 = _os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v121 = 0;
  if (!__nwlog_fault(v2, type, &v121))
  {
LABEL_199:
    if (!v2)
    {
      return;
    }

LABEL_183:
    free(v2);
    return;
  }

  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    v107 = __nwlog_obj();
    v108 = type[0];
    if (!os_log_type_enabled(v107, type[0]))
    {
      goto LABEL_199;
    }

    *buf = 136446210;
    *&buf[4] = "nw_http3_connection_destroy";
    v109 = "%{public}s called with null http3";
LABEL_198:
    _os_log_impl(&dword_181A37000, v107, v108, v109, buf, 0xCu);
    goto LABEL_199;
  }

  if (v121 != 1)
  {
    v107 = __nwlog_obj();
    v108 = type[0];
    if (!os_log_type_enabled(v107, type[0]))
    {
      goto LABEL_199;
    }

    *buf = 136446210;
    *&buf[4] = "nw_http3_connection_destroy";
    v109 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_198;
  }

  v110 = __nw_create_backtrace_string();
  v107 = __nwlog_obj();
  v108 = type[0];
  v111 = os_log_type_enabled(v107, type[0]);
  if (!v110)
  {
    if (!v111)
    {
      goto LABEL_199;
    }

    *buf = 136446210;
    *&buf[4] = "nw_http3_connection_destroy";
    v109 = "%{public}s called with null http3, no backtrace";
    goto LABEL_198;
  }

  if (v111)
  {
    *buf = 136446466;
    *&buf[4] = "nw_http3_connection_destroy";
    *&buf[12] = 2082;
    *&buf[14] = v110;
    _os_log_impl(&dword_181A37000, v107, v108, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v110);
  if (v2)
  {
    goto LABEL_183;
  }
}

void nw_http3_teardown_uni_streams(uint64_t a1)
{
  v226 = *MEMORY[0x1E69E9840];
  if ((*(a1 + 1399) & 0x20) == 0 && gLogDatapath == 1)
  {
    v134 = __nwlog_obj();
    if (os_log_type_enabled(v134, OS_LOG_TYPE_DEBUG))
    {
      v135 = *(a1 + 1304);
      *buf = 136446978;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = a1 + 1313;
      *&buf[22] = 2080;
      v223 = " ";
      v224 = 1024;
      v225 = v135;
      _os_log_impl(&dword_181A37000, v134, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }

  nw_protocol_remove_instance(a1);
  if ((*(a1 + 1397) & 0x800) != 0)
  {
    if ((*(a1 + 1399) & 0x20) == 0 && gLogDatapath == 1)
    {
      v175 = __nwlog_obj();
      if (os_log_type_enabled(v175, OS_LOG_TYPE_DEBUG))
      {
        v176 = *(a1 + 1304);
        *buf = 136446978;
        *&buf[4] = "nw_http3_teardown_uni_streams";
        *&buf[12] = 2082;
        *&buf[14] = a1 + 1313;
        *&buf[22] = 2080;
        v223 = " ";
        v224 = 1024;
        v225 = v176;
        _os_log_impl(&dword_181A37000, v175, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> stopping control stream", buf, 0x26u);
      }
    }

    v2 = *(a1 + 1104);
    if (v2)
    {
      if (*v2)
      {
        v3 = *(*v2 + 8);
        if (v3)
        {
          v3();
        }
      }
    }

    v4 = *(a1 + 32);
    if (v4)
    {
      v5 = *(v4 + 24);
      if (v5)
      {
        v6 = *(v5 + 240);
        if (v6)
        {
          v6();
          goto LABEL_14;
        }
      }
    }

    __nwlog_obj();
    v114 = *(a1 + 32);
    v115 = "invalid";
    if (v114)
    {
      v116 = *(v114 + 16);
      if (v116)
      {
        v115 = v116;
      }
    }

    *buf = 136446466;
    *&buf[4] = "nw_http3_teardown_uni_streams";
    *&buf[12] = 2082;
    *&buf[14] = v115;
    v117 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v219 = 0;
    if (__nwlog_fault(v117, type, &v219))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v118 = __nwlog_obj();
        v119 = type[0];
        if (!os_log_type_enabled(v118, type[0]))
        {
          goto LABEL_299;
        }

        v120 = *(a1 + 32);
        v121 = "invalid";
        if (v120)
        {
          v122 = *(v120 + 16);
          if (v122)
          {
            v121 = v122;
          }
        }

        *buf = 136446466;
        *&buf[4] = "nw_http3_teardown_uni_streams";
        *&buf[12] = 2082;
        *&buf[14] = v121;
        v123 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback";
        goto LABEL_298;
      }

      if (v219 != 1)
      {
        v118 = __nwlog_obj();
        v119 = type[0];
        if (!os_log_type_enabled(v118, type[0]))
        {
          goto LABEL_299;
        }

        v192 = *(a1 + 32);
        v193 = "invalid";
        if (v192)
        {
          v194 = *(v192 + 16);
          if (v194)
          {
            v193 = v194;
          }
        }

        *buf = 136446466;
        *&buf[4] = "nw_http3_teardown_uni_streams";
        *&buf[12] = 2082;
        *&buf[14] = v193;
        v123 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback, backtrace limit exceeded";
        goto LABEL_298;
      }

      backtrace_string = __nw_create_backtrace_string();
      v118 = __nwlog_obj();
      v119 = type[0];
      v162 = os_log_type_enabled(v118, type[0]);
      if (backtrace_string)
      {
        if (v162)
        {
          v163 = *(a1 + 32);
          v164 = "invalid";
          if (v163)
          {
            v165 = *(v163 + 16);
            if (v165)
            {
              v164 = v165;
            }
          }

          *buf = 136446722;
          *&buf[4] = "nw_http3_teardown_uni_streams";
          *&buf[12] = 2082;
          *&buf[14] = v164;
          *&buf[22] = 2082;
          v223 = backtrace_string;
          _os_log_impl(&dword_181A37000, v118, v119, "%{public}s protocol %{public}s has invalid remove_listen_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(backtrace_string);
        goto LABEL_299;
      }

      if (v162)
      {
        v213 = *(a1 + 32);
        v214 = "invalid";
        if (v213)
        {
          v215 = *(v213 + 16);
          if (v215)
          {
            v214 = v215;
          }
        }

        *buf = 136446466;
        *&buf[4] = "nw_http3_teardown_uni_streams";
        *&buf[12] = 2082;
        *&buf[14] = v214;
        v123 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback, no backtrace";
LABEL_298:
        _os_log_impl(&dword_181A37000, v118, v119, v123, buf, 0x16u);
      }
    }

LABEL_299:
    if (v117)
    {
      free(v117);
    }

LABEL_14:
    v7 = *(a1 + 32);
    if (v7)
    {
      v8 = *(v7 + 24);
      if (v8)
      {
        v9 = *(v8 + 8);
        if (v9)
        {
          v9(v7, a1);
          goto LABEL_18;
        }
      }
    }

    __nwlog_obj();
    v124 = *(a1 + 32);
    v125 = "invalid";
    if (v124)
    {
      v126 = *(v124 + 16);
      if (v126)
      {
        v125 = v126;
      }
    }

    *buf = 136446466;
    *&buf[4] = "nw_http3_teardown_uni_streams";
    *&buf[12] = 2082;
    *&buf[14] = v125;
    v127 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v219 = 0;
    if (!__nwlog_fault(v127, type, &v219))
    {
      goto LABEL_307;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v128 = __nwlog_obj();
      v129 = type[0];
      if (!os_log_type_enabled(v128, type[0]))
      {
        goto LABEL_307;
      }

      v130 = *(a1 + 32);
      v131 = "invalid";
      if (v130)
      {
        v132 = *(v130 + 16);
        if (v132)
        {
          v131 = v132;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v131;
      v133 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
    }

    else if (v219 == 1)
    {
      v166 = __nw_create_backtrace_string();
      v128 = __nwlog_obj();
      v129 = type[0];
      v167 = os_log_type_enabled(v128, type[0]);
      if (v166)
      {
        if (v167)
        {
          v168 = *(a1 + 32);
          v169 = "invalid";
          if (v168)
          {
            v170 = *(v168 + 16);
            if (v170)
            {
              v169 = v170;
            }
          }

          *buf = 136446722;
          *&buf[4] = "nw_http3_teardown_uni_streams";
          *&buf[12] = 2082;
          *&buf[14] = v169;
          *&buf[22] = 2082;
          v223 = v166;
          _os_log_impl(&dword_181A37000, v128, v129, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v166);
        goto LABEL_307;
      }

      if (!v167)
      {
LABEL_307:
        if (v127)
        {
          free(v127);
        }

        goto LABEL_18;
      }

      v216 = *(a1 + 32);
      v217 = "invalid";
      if (v216)
      {
        v218 = *(v216 + 16);
        if (v218)
        {
          v217 = v218;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v217;
      v133 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
    }

    else
    {
      v128 = __nwlog_obj();
      v129 = type[0];
      if (!os_log_type_enabled(v128, type[0]))
      {
        goto LABEL_307;
      }

      v195 = *(a1 + 32);
      v196 = "invalid";
      if (v195)
      {
        v197 = *(v195 + 16);
        if (v197)
        {
          v196 = v197;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v196;
      v133 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v128, v129, v133, buf, 0x16u);
    goto LABEL_307;
  }

LABEL_18:
  if (!*(a1 + 1064))
  {
    goto LABEL_41;
  }

  v11 = (a1 + 208);
  v10 = *(a1 + 208);
  do
  {
    if (!v10)
    {
      break;
    }

    v12 = *(v10 + 32);
    v13 = ___ZL23nw_http3_framer_cleanupP15nw_http3_framer_block_invoke(&__block_literal_global_27_63429, v10);
    v10 = v12;
  }

  while ((v13 & 1) != 0);
  if (gLogDatapath == 1)
  {
    v171 = __nwlog_obj();
    if (os_log_type_enabled(v171, OS_LOG_TYPE_DEBUG))
    {
      *buf = 136446210;
      *&buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A37000, v171, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  v14 = *v11;
  if (*v11)
  {
    *(v14 + 40) = type;
    v15 = *(a1 + 216);
    *type = v14;
    v221 = v15;
    *(a1 + 208) = 0;
    *(a1 + 216) = v11;
    *buf = MEMORY[0x1E69E9820];
    *&buf[8] = 0x40000000;
    *&buf[16] = ___ZL25__nw_frame_array_finalizeP16nw_frame_array_sbb_block_invoke;
    v223 = &__block_descriptor_tmp_21_49595;
    LOBYTE(v224) = 0;
    do
    {
      v16 = *type;
      if (!*type)
      {
        break;
      }

      v17 = *(*type + 32);
      v18 = *(*type + 40);
      v19 = (v17 + 40);
      if (!v17)
      {
        v19 = &v221;
      }

      *v19 = v18;
      *v18 = v17;
      *(v16 + 32) = 0;
      *(v16 + 40) = 0;
    }

    while (((*&buf[16])(buf) & 1) != 0);
  }

  v20 = *(a1 + 1064);
  v21 = (v20 + 104);
  if (gLogDatapath == 1)
  {
    v172 = __nwlog_obj();
    if (os_log_type_enabled(v172, OS_LOG_TYPE_DEBUG))
    {
      *buf = 136446210;
      *&buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A37000, v172, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  v22 = *v21;
  if (*v21)
  {
    *(v22 + 40) = type;
    v23 = *(v20 + 112);
    *type = v22;
    v221 = v23;
    *(v20 + 104) = 0;
    *(v20 + 112) = v21;
    *buf = MEMORY[0x1E69E9820];
    *&buf[8] = 0x40000000;
    *&buf[16] = ___ZL25__nw_frame_array_finalizeP16nw_frame_array_sbb_block_invoke;
    v223 = &__block_descriptor_tmp_21_49595;
    LOBYTE(v224) = 0;
    do
    {
      v24 = *type;
      if (!*type)
      {
        break;
      }

      v25 = *(*type + 32);
      v26 = *(*type + 40);
      v27 = (v25 + 40);
      if (!v25)
      {
        v27 = &v221;
      }

      *v27 = v26;
      *v26 = v25;
      *(v24 + 32) = 0;
      *(v24 + 40) = 0;
    }

    while (((*&buf[16])(buf) & 1) != 0);
  }

  v28 = *(a1 + 1064);
  v29 = *(v28 + 32);
  if (!v29 || (v30 = *(v29 + 24)) == 0 || (v31 = *(v30 + 8)) == 0)
  {
    __nwlog_obj();
    v64 = *(*(a1 + 1064) + 32);
    v65 = "invalid";
    if (v64)
    {
      v66 = *(v64 + 16);
      if (v66)
      {
        v65 = v66;
      }
    }

    *buf = 136446466;
    *&buf[4] = "nw_http3_teardown_uni_streams";
    *&buf[12] = 2082;
    *&buf[14] = v65;
    v67 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v219 = 0;
    if (!__nwlog_fault(v67, type, &v219))
    {
      goto LABEL_259;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v68 = __nwlog_obj();
      v69 = type[0];
      if (!os_log_type_enabled(v68, type[0]))
      {
        goto LABEL_259;
      }

      v70 = *(*(a1 + 1064) + 32);
      v71 = "invalid";
      if (v70)
      {
        v72 = *(v70 + 16);
        if (v72)
        {
          v71 = v72;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v71;
      v73 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
    }

    else if (v219 == 1)
    {
      v136 = __nw_create_backtrace_string();
      v68 = __nwlog_obj();
      v69 = type[0];
      v137 = os_log_type_enabled(v68, type[0]);
      if (v136)
      {
        if (v137)
        {
          v138 = *(*(a1 + 1064) + 32);
          v139 = "invalid";
          if (v138)
          {
            v140 = *(v138 + 16);
            if (v140)
            {
              v139 = v140;
            }
          }

          *buf = 136446722;
          *&buf[4] = "nw_http3_teardown_uni_streams";
          *&buf[12] = 2082;
          *&buf[14] = v139;
          *&buf[22] = 2082;
          v223 = v136;
          _os_log_impl(&dword_181A37000, v68, v69, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v136);
        goto LABEL_259;
      }

      if (!v137)
      {
LABEL_259:
        if (v67)
        {
          free(v67);
        }

        goto LABEL_40;
      }

      v198 = *(*(a1 + 1064) + 32);
      v199 = "invalid";
      if (v198)
      {
        v200 = *(v198 + 16);
        if (v200)
        {
          v199 = v200;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v199;
      v73 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
    }

    else
    {
      v68 = __nwlog_obj();
      v69 = type[0];
      if (!os_log_type_enabled(v68, type[0]))
      {
        goto LABEL_259;
      }

      v177 = *(*(a1 + 1064) + 32);
      v178 = "invalid";
      if (v177)
      {
        v179 = *(v177 + 16);
        if (v179)
        {
          v178 = v179;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v178;
      v73 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v68, v69, v73, buf, 0x16u);
    goto LABEL_259;
  }

  v31(v29, v28);
LABEL_40:
  nw_protocol_http3_uni_stream_destroy(*(a1 + 1064));
  *(a1 + 1064) = 0;
LABEL_41:
  v32 = *(a1 + 1072);
  if (!v32)
  {
    goto LABEL_47;
  }

  v33 = *(v32 + 32);
  if (!v33 || (v34 = *(v33 + 24)) == 0 || (v35 = *(v34 + 8)) == 0)
  {
    __nwlog_obj();
    v74 = *(*(a1 + 1072) + 32);
    v75 = "invalid";
    if (v74)
    {
      v76 = *(v74 + 16);
      if (v76)
      {
        v75 = v76;
      }
    }

    *buf = 136446466;
    *&buf[4] = "nw_http3_teardown_uni_streams";
    *&buf[12] = 2082;
    *&buf[14] = v75;
    v77 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v219 = 0;
    if (!__nwlog_fault(v77, type, &v219))
    {
      goto LABEL_267;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v78 = __nwlog_obj();
      v79 = type[0];
      if (!os_log_type_enabled(v78, type[0]))
      {
        goto LABEL_267;
      }

      v80 = *(*(a1 + 1072) + 32);
      v81 = "invalid";
      if (v80)
      {
        v82 = *(v80 + 16);
        if (v82)
        {
          v81 = v82;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v81;
      v83 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
    }

    else if (v219 == 1)
    {
      v141 = __nw_create_backtrace_string();
      v78 = __nwlog_obj();
      v79 = type[0];
      v142 = os_log_type_enabled(v78, type[0]);
      if (v141)
      {
        if (v142)
        {
          v143 = *(*(a1 + 1072) + 32);
          v144 = "invalid";
          if (v143)
          {
            v145 = *(v143 + 16);
            if (v145)
            {
              v144 = v145;
            }
          }

          *buf = 136446722;
          *&buf[4] = "nw_http3_teardown_uni_streams";
          *&buf[12] = 2082;
          *&buf[14] = v144;
          *&buf[22] = 2082;
          v223 = v141;
          _os_log_impl(&dword_181A37000, v78, v79, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v141);
        goto LABEL_267;
      }

      if (!v142)
      {
LABEL_267:
        if (v77)
        {
          free(v77);
        }

        goto LABEL_46;
      }

      v201 = *(*(a1 + 1072) + 32);
      v202 = "invalid";
      if (v201)
      {
        v203 = *(v201 + 16);
        if (v203)
        {
          v202 = v203;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v202;
      v83 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
    }

    else
    {
      v78 = __nwlog_obj();
      v79 = type[0];
      if (!os_log_type_enabled(v78, type[0]))
      {
        goto LABEL_267;
      }

      v180 = *(*(a1 + 1072) + 32);
      v181 = "invalid";
      if (v180)
      {
        v182 = *(v180 + 16);
        if (v182)
        {
          v181 = v182;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v181;
      v83 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v78, v79, v83, buf, 0x16u);
    goto LABEL_267;
  }

  v35(v33, v32);
LABEL_46:
  nw_protocol_http3_uni_stream_destroy(*(a1 + 1072));
  *(a1 + 1072) = 0;
LABEL_47:
  v36 = *(a1 + 1080);
  if (!v36)
  {
    goto LABEL_60;
  }

  v37 = (v36 + 104);
  if (gLogDatapath == 1)
  {
    v173 = __nwlog_obj();
    if (os_log_type_enabled(v173, OS_LOG_TYPE_DEBUG))
    {
      *buf = 136446210;
      *&buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A37000, v173, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  v38 = *v37;
  if (*v37)
  {
    *(v38 + 40) = type;
    v39 = *(v36 + 112);
    *type = v38;
    v221 = v39;
    *(v36 + 104) = 0;
    *(v36 + 112) = v37;
    *buf = MEMORY[0x1E69E9820];
    *&buf[8] = 0x40000000;
    *&buf[16] = ___ZL25__nw_frame_array_finalizeP16nw_frame_array_sbb_block_invoke;
    v223 = &__block_descriptor_tmp_21_49595;
    LOBYTE(v224) = 0;
    do
    {
      v40 = *type;
      if (!*type)
      {
        break;
      }

      v41 = *(*type + 32);
      v42 = *(*type + 40);
      v43 = (v41 + 40);
      if (!v41)
      {
        v43 = &v221;
      }

      *v43 = v42;
      *v42 = v41;
      *(v40 + 32) = 0;
      *(v40 + 40) = 0;
    }

    while (((*&buf[16])(buf) & 1) != 0);
  }

  v44 = *(a1 + 1080);
  v45 = *(v44 + 32);
  if (!v45 || (v46 = *(v45 + 24)) == 0 || (v47 = *(v46 + 8)) == 0)
  {
    __nwlog_obj();
    v84 = *(*(a1 + 1080) + 32);
    v85 = "invalid";
    if (v84)
    {
      v86 = *(v84 + 16);
      if (v86)
      {
        v85 = v86;
      }
    }

    *buf = 136446466;
    *&buf[4] = "nw_http3_teardown_uni_streams";
    *&buf[12] = 2082;
    *&buf[14] = v85;
    v87 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v219 = 0;
    if (!__nwlog_fault(v87, type, &v219))
    {
      goto LABEL_275;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v88 = __nwlog_obj();
      v89 = type[0];
      if (!os_log_type_enabled(v88, type[0]))
      {
        goto LABEL_275;
      }

      v90 = *(*(a1 + 1080) + 32);
      v91 = "invalid";
      if (v90)
      {
        v92 = *(v90 + 16);
        if (v92)
        {
          v91 = v92;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v91;
      v93 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
    }

    else if (v219 == 1)
    {
      v146 = __nw_create_backtrace_string();
      v88 = __nwlog_obj();
      v89 = type[0];
      v147 = os_log_type_enabled(v88, type[0]);
      if (v146)
      {
        if (v147)
        {
          v148 = *(*(a1 + 1080) + 32);
          v149 = "invalid";
          if (v148)
          {
            v150 = *(v148 + 16);
            if (v150)
            {
              v149 = v150;
            }
          }

          *buf = 136446722;
          *&buf[4] = "nw_http3_teardown_uni_streams";
          *&buf[12] = 2082;
          *&buf[14] = v149;
          *&buf[22] = 2082;
          v223 = v146;
          _os_log_impl(&dword_181A37000, v88, v89, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v146);
        goto LABEL_275;
      }

      if (!v147)
      {
LABEL_275:
        if (v87)
        {
          free(v87);
        }

        goto LABEL_59;
      }

      v204 = *(*(a1 + 1080) + 32);
      v205 = "invalid";
      if (v204)
      {
        v206 = *(v204 + 16);
        if (v206)
        {
          v205 = v206;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v205;
      v93 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
    }

    else
    {
      v88 = __nwlog_obj();
      v89 = type[0];
      if (!os_log_type_enabled(v88, type[0]))
      {
        goto LABEL_275;
      }

      v183 = *(*(a1 + 1080) + 32);
      v184 = "invalid";
      if (v183)
      {
        v185 = *(v183 + 16);
        if (v185)
        {
          v184 = v185;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v184;
      v93 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v88, v89, v93, buf, 0x16u);
    goto LABEL_275;
  }

  v47(v45, v44);
LABEL_59:
  nw_protocol_http3_uni_stream_destroy(*(a1 + 1080));
  *(a1 + 1080) = 0;
LABEL_60:
  v48 = *(a1 + 1088);
  if (!v48)
  {
    goto LABEL_66;
  }

  v49 = *(v48 + 32);
  if (!v49 || (v50 = *(v49 + 24)) == 0 || (v51 = *(v50 + 8)) == 0)
  {
    __nwlog_obj();
    v94 = *(*(a1 + 1088) + 32);
    v95 = "invalid";
    if (v94)
    {
      v96 = *(v94 + 16);
      if (v96)
      {
        v95 = v96;
      }
    }

    *buf = 136446466;
    *&buf[4] = "nw_http3_teardown_uni_streams";
    *&buf[12] = 2082;
    *&buf[14] = v95;
    v97 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v219 = 0;
    if (!__nwlog_fault(v97, type, &v219))
    {
      goto LABEL_283;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v98 = __nwlog_obj();
      v99 = type[0];
      if (!os_log_type_enabled(v98, type[0]))
      {
        goto LABEL_283;
      }

      v100 = *(*(a1 + 1088) + 32);
      v101 = "invalid";
      if (v100)
      {
        v102 = *(v100 + 16);
        if (v102)
        {
          v101 = v102;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v101;
      v103 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
    }

    else if (v219 == 1)
    {
      v151 = __nw_create_backtrace_string();
      v98 = __nwlog_obj();
      v99 = type[0];
      v152 = os_log_type_enabled(v98, type[0]);
      if (v151)
      {
        if (v152)
        {
          v153 = *(*(a1 + 1088) + 32);
          v154 = "invalid";
          if (v153)
          {
            v155 = *(v153 + 16);
            if (v155)
            {
              v154 = v155;
            }
          }

          *buf = 136446722;
          *&buf[4] = "nw_http3_teardown_uni_streams";
          *&buf[12] = 2082;
          *&buf[14] = v154;
          *&buf[22] = 2082;
          v223 = v151;
          _os_log_impl(&dword_181A37000, v98, v99, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v151);
        goto LABEL_283;
      }

      if (!v152)
      {
LABEL_283:
        if (v97)
        {
          free(v97);
        }

        goto LABEL_65;
      }

      v207 = *(*(a1 + 1088) + 32);
      v208 = "invalid";
      if (v207)
      {
        v209 = *(v207 + 16);
        if (v209)
        {
          v208 = v209;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v208;
      v103 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
    }

    else
    {
      v98 = __nwlog_obj();
      v99 = type[0];
      if (!os_log_type_enabled(v98, type[0]))
      {
        goto LABEL_283;
      }

      v186 = *(*(a1 + 1088) + 32);
      v187 = "invalid";
      if (v186)
      {
        v188 = *(v186 + 16);
        if (v188)
        {
          v187 = v188;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v187;
      v103 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v98, v99, v103, buf, 0x16u);
    goto LABEL_283;
  }

  v51(v49, v48);
LABEL_65:
  nw_protocol_http3_uni_stream_destroy(*(a1 + 1088));
  *(a1 + 1088) = 0;
LABEL_66:
  v52 = *(a1 + 1096);
  if (!v52)
  {
    return;
  }

  v53 = (v52 + 104);
  if (gLogDatapath == 1)
  {
    v174 = __nwlog_obj();
    if (os_log_type_enabled(v174, OS_LOG_TYPE_DEBUG))
    {
      *buf = 136446210;
      *&buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A37000, v174, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  v54 = *v53;
  if (*v53)
  {
    *(v54 + 40) = type;
    v55 = *(v52 + 112);
    *type = v54;
    v221 = v55;
    *(v52 + 104) = 0;
    *(v52 + 112) = v53;
    *buf = MEMORY[0x1E69E9820];
    *&buf[8] = 0x40000000;
    *&buf[16] = ___ZL25__nw_frame_array_finalizeP16nw_frame_array_sbb_block_invoke;
    v223 = &__block_descriptor_tmp_21_49595;
    LOBYTE(v224) = 0;
    do
    {
      v56 = *type;
      if (!*type)
      {
        break;
      }

      v57 = *(*type + 32);
      v58 = *(*type + 40);
      v59 = (v57 + 40);
      if (!v57)
      {
        v59 = &v221;
      }

      *v59 = v58;
      *v58 = v57;
      *(v56 + 32) = 0;
      *(v56 + 40) = 0;
    }

    while (((*&buf[16])(buf) & 1) != 0);
  }

  v60 = *(a1 + 1096);
  v61 = *(v60 + 32);
  if (!v61 || (v62 = *(v61 + 24)) == 0 || (v63 = *(v62 + 8)) == 0)
  {
    __nwlog_obj();
    v104 = *(*(a1 + 1096) + 32);
    v105 = "invalid";
    if (v104)
    {
      v106 = *(v104 + 16);
      if (v106)
      {
        v105 = v106;
      }
    }

    *buf = 136446466;
    *&buf[4] = "nw_http3_teardown_uni_streams";
    *&buf[12] = 2082;
    *&buf[14] = v105;
    v107 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v219 = 0;
    if (!__nwlog_fault(v107, type, &v219))
    {
      goto LABEL_291;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v108 = __nwlog_obj();
      v109 = type[0];
      if (!os_log_type_enabled(v108, type[0]))
      {
        goto LABEL_291;
      }

      v110 = *(*(a1 + 1096) + 32);
      v111 = "invalid";
      if (v110)
      {
        v112 = *(v110 + 16);
        if (v112)
        {
          v111 = v112;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v111;
      v113 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
    }

    else if (v219 == 1)
    {
      v156 = __nw_create_backtrace_string();
      v108 = __nwlog_obj();
      v109 = type[0];
      v157 = os_log_type_enabled(v108, type[0]);
      if (v156)
      {
        if (v157)
        {
          v158 = *(*(a1 + 1096) + 32);
          v159 = "invalid";
          if (v158)
          {
            v160 = *(v158 + 16);
            if (v160)
            {
              v159 = v160;
            }
          }

          *buf = 136446722;
          *&buf[4] = "nw_http3_teardown_uni_streams";
          *&buf[12] = 2082;
          *&buf[14] = v159;
          *&buf[22] = 2082;
          v223 = v156;
          _os_log_impl(&dword_181A37000, v108, v109, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v156);
        goto LABEL_291;
      }

      if (!v157)
      {
LABEL_291:
        if (v107)
        {
          free(v107);
        }

        goto LABEL_78;
      }

      v210 = *(*(a1 + 1096) + 32);
      v211 = "invalid";
      if (v210)
      {
        v212 = *(v210 + 16);
        if (v212)
        {
          v211 = v212;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v211;
      v113 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
    }

    else
    {
      v108 = __nwlog_obj();
      v109 = type[0];
      if (!os_log_type_enabled(v108, type[0]))
      {
        goto LABEL_291;
      }

      v189 = *(*(a1 + 1096) + 32);
      v190 = "invalid";
      if (v189)
      {
        v191 = *(v189 + 16);
        if (v191)
        {
          v190 = v191;
        }
      }

      *buf = 136446466;
      *&buf[4] = "nw_http3_teardown_uni_streams";
      *&buf[12] = 2082;
      *&buf[14] = v190;
      v113 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v108, v109, v113, buf, 0x16u);
    goto LABEL_291;
  }

  v63(v61, v60);
LABEL_78:
  nw_protocol_http3_uni_stream_destroy(*(a1 + 1096));
  *(a1 + 1096) = 0;
}

void nw_protocol_http3_uni_stream_destroy(uint64_t a1)
{
  v23 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v1 = a1;
    if (gLogDatapath == 1)
    {
      v12 = __nwlog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446466;
        v18 = "nw_protocol_http3_uni_stream_destroy";
        v19 = 2048;
        v20 = v1;
        _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
      }
    }

    if (!*(v1 + 104))
    {
      goto LABEL_20;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446466;
    v18 = "nw_protocol_http3_uni_stream_destroy";
    v19 = 2048;
    v20 = v1;
    v2 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v2, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v3 = gLogObj;
        v4 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_18;
        }

        *buf = 136446466;
        v18 = "nw_protocol_http3_uni_stream_destroy";
        v19 = 2048;
        v20 = v1;
        v5 = "%{public}s unistream %p input_frames_unprocessed is not empty";
        goto LABEL_17;
      }

      if (v15 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v3 = gLogObj;
        v4 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_18;
        }

        *buf = 136446466;
        v18 = "nw_protocol_http3_uni_stream_destroy";
        v19 = 2048;
        v20 = v1;
        v5 = "%{public}s unistream %p input_frames_unprocessed is not empty, backtrace limit exceeded";
        goto LABEL_17;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      v7 = os_log_type_enabled(gLogObj, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *buf = 136446722;
          v18 = "nw_protocol_http3_uni_stream_destroy";
          v19 = 2048;
          v20 = v1;
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v3, v4, "%{public}s unistream %p input_frames_unprocessed is not empty, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *buf = 136446466;
        v18 = "nw_protocol_http3_uni_stream_destroy";
        v19 = 2048;
        v20 = v1;
        v5 = "%{public}s unistream %p input_frames_unprocessed is not empty, no backtrace";
LABEL_17:
        _os_log_impl(&dword_181A37000, v3, v4, v5, buf, 0x16u);
      }
    }

LABEL_18:
    if (v2)
    {
      free(v2);
    }

LABEL_20:
    (*(*(v1 + 96) + 16))(*(v1 + 96), 0);
    v8 = *(v1 + 96);
    if (v8)
    {
      _Block_release(v8);
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_protocol_http3_uni_stream_destroy";
  v1 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v1, &type, &v15))
  {
    goto LABEL_40;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
    {
      goto LABEL_40;
    }

    *buf = 136446210;
    v18 = "nw_protocol_http3_uni_stream_destroy";
    v11 = "%{public}s called with null http3_stream";
    goto LABEL_39;
  }

  if (v15 != 1)
  {
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
    {
      goto LABEL_40;
    }

    *buf = 136446210;
    v18 = "nw_protocol_http3_uni_stream_destroy";
    v11 = "%{public}s called with null http3_stream, backtrace limit exceeded";
    goto LABEL_39;
  }

  v13 = __nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v10 = type;
  v14 = os_log_type_enabled(v9, type);
  if (v13)
  {
    if (v14)
    {
      *buf = 136446466;
      v18 = "nw_protocol_http3_uni_stream_destroy";
      v19 = 2082;
      v20 = v13;
      _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v13);
    if (v1)
    {
      goto LABEL_22;
    }

    return;
  }

  if (v14)
  {
    *buf = 136446210;
    v18 = "nw_protocol_http3_uni_stream_destroy";
    v11 = "%{public}s called with null http3_stream, no backtrace";
LABEL_39:
    _os_log_impl(&dword_181A37000, v9, v10, v11, buf, 0xCu);
  }

LABEL_40:
  if (v1)
  {
LABEL_22:
    free(v1);
  }
}

uint64_t ___ZL23nw_http3_framer_cleanupP15nw_http3_framer_block_invoke(uint64_t a1, _DWORD *a2)
{
  v11 = *MEMORY[0x1E69E9840];
  if (gLogDatapath == 1)
  {
    v4 = __nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v5 = 136446722;
      v6 = "nw_http3_framer_cleanup_block_invoke";
      v7 = 2048;
      v8 = a2;
      v9 = 1024;
      v10 = nw_frame_unclaimed_length(a2);
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_DEBUG, "%{public}s input frames unprocessed still has frames in it: frame %p (%u bytes)", &v5, 0x1Cu);
    }
  }

  return 1;
}

uint64_t nw_http3_stream_fields_unblocked(uint64_t result)
{
  v20 = *MEMORY[0x1E69E9840];
  if ((!result || (*(result + 732) & 0x2000) == 0) && gLogDatapath == 1)
  {
    v3 = result;
    v4 = __nwlog_obj();
    v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
    result = v3;
    if (v5)
    {
      v6 = (v3 + 632);
      v7 = " ";
      v8 = *(*(v3 + 344) + 1304);
      v9 = *(v3 + 240);
      if (!v3)
      {
        v7 = "";
        v6 = "";
      }

      v10 = 136447234;
      v11 = "nw_http3_stream_fields_unblocked";
      v12 = 2082;
      v13 = v6;
      v14 = 2080;
      v15 = v7;
      v16 = 1024;
      v17 = v8;
      v18 = 2048;
      v19 = v9;
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> qpack unblocked", &v10, 0x30u);
      result = v3;
    }
  }

  *(result + 600) = 0;
  v1 = *(result + 344);
  v2 = *(v1 + 976);
  *(result + 608) = v2;
  *v2 = result;
  *(v1 + 976) = result + 600;
  return result;
}

void nw_protocol_http3_listen_protocol_disconnected(nw_listen_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  v45 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v38 = "nw_protocol_http3_listen_protocol_disconnected";
    v13 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35))
    {
      goto LABEL_85;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
      {
        goto LABEL_85;
      }

      *buf = 136446210;
      v38 = "nw_protocol_http3_listen_protocol_disconnected";
      v16 = "%{public}s called with null listener";
    }

    else if (v35 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v29 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v29)
        {
          *buf = 136446466;
          v38 = "nw_protocol_http3_listen_protocol_disconnected";
          v39 = 2082;
          v40 = backtrace_string;
          _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_85:
        if (!v13)
        {
          return;
        }

LABEL_86:
        free(v13);
        return;
      }

      if (!v29)
      {
        goto LABEL_85;
      }

      *buf = 136446210;
      v38 = "nw_protocol_http3_listen_protocol_disconnected";
      v16 = "%{public}s called with null listener, no backtrace";
    }

    else
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
      {
        goto LABEL_85;
      }

      *buf = 136446210;
      v38 = "nw_protocol_http3_listen_protocol_disconnected";
      v16 = "%{public}s called with null listener, backtrace limit exceeded";
    }

LABEL_84:
    _os_log_impl(&dword_181A37000, v14, v15, v16, buf, 0xCu);
    goto LABEL_85;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((handle[1399] & 0x20) == 0 && gLogDatapath == 1)
    {
      v25 = __nwlog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        v26 = *(handle + 326);
        *buf = 136446978;
        v38 = "nw_protocol_http3_listen_protocol_disconnected";
        v39 = 2082;
        v40 = (handle + 1313);
        v41 = 2080;
        v42 = " ";
        v43 = 1024;
        v44 = v26;
        _os_log_impl(&dword_181A37000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> listen protocol is disconnected", buf, 0x26u);
      }
    }

    if (a2)
    {
      callbacks = a2->callbacks;
      if (callbacks)
      {
        remove_listen_handler = callbacks->remove_listen_handler;
        if (remove_listen_handler)
        {
          remove_listen_handler(a2, handle + 128);
LABEL_9:
          nw_http3_async_close_connection_if_no_stream(handle);
          v8 = (handle + 1397);
          v9 = *(handle + 1397);
          if ((v9 & 0x800) == 0)
          {
            nw_protocol_set_output_handler(handle, 0);
            v9 = *v8;
          }

          if (a3 == 35 && (v9 & 0x100) != 0)
          {
            if ((handle[1399] & 0x20) == 0 && gLogDatapath == 1)
            {
              v32 = __nwlog_obj();
              if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
              {
                v33 = *(handle + 326);
                *buf = 136446978;
                v38 = "nw_protocol_http3_listen_protocol_disconnected";
                v39 = 2082;
                v40 = (handle + 1313);
                v41 = 2080;
                v42 = " ";
                v43 = 1024;
                v44 = v33;
                _os_log_impl(&dword_181A37000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> early data rejected", buf, 0x26u);
              }
            }

            *v8 |= 0x200u;
            if (!uuid_is_null(handle + 840))
            {
              v10 = *(handle + 141);
              if (v10)
              {
                nw_path_report_error_to_agent(v10, handle + 840, 35);
              }
            }
          }

          v11 = *(handle + 138);
          if (v11)
          {
            (*(*v11 + 8))(v11, handle, a3);
          }

          return;
        }
      }

      __nwlog_obj();
      identifier = a2->identifier;
      if (!identifier)
      {
        identifier = "invalid";
      }
    }

    else
    {
      __nwlog_obj();
      identifier = "invalid";
    }

    *buf = 136446466;
    v38 = "nw_protocol_http3_listen_protocol_disconnected";
    v39 = 2082;
    v40 = identifier;
    v17 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v17, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v18 = __nwlog_obj();
        v19 = type;
        if (!os_log_type_enabled(v18, type))
        {
          goto LABEL_74;
        }

        v20 = "invalid";
        if (a2 && a2->identifier)
        {
          v20 = a2->identifier;
        }

        *buf = 136446466;
        v38 = "nw_protocol_http3_listen_protocol_disconnected";
        v39 = 2082;
        v40 = v20;
        v21 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback";
        goto LABEL_73;
      }

      if (v35 != 1)
      {
        v18 = __nwlog_obj();
        v19 = type;
        if (!os_log_type_enabled(v18, type))
        {
          goto LABEL_74;
        }

        v27 = "invalid";
        if (a2 && a2->identifier)
        {
          v27 = a2->identifier;
        }

        *buf = 136446466;
        v38 = "nw_protocol_http3_listen_protocol_disconnected";
        v39 = 2082;
        v40 = v27;
        v21 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback, backtrace limit exceeded";
        goto LABEL_73;
      }

      v22 = __nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v19 = type;
      v23 = os_log_type_enabled(v18, type);
      if (v22)
      {
        if (v23)
        {
          v24 = "invalid";
          if (a2 && a2->identifier)
          {
            v24 = a2->identifier;
          }

          *buf = 136446722;
          v38 = "nw_protocol_http3_listen_protocol_disconnected";
          v39 = 2082;
          v40 = v24;
          v41 = 2082;
          v42 = v22;
          _os_log_impl(&dword_181A37000, v18, v19, "%{public}s protocol %{public}s has invalid remove_listen_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v22);
        goto LABEL_74;
      }

      if (v23)
      {
        v34 = "invalid";
        if (a2 && a2->identifier)
        {
          v34 = a2->identifier;
        }

        *buf = 136446466;
        v38 = "nw_protocol_http3_listen_protocol_disconnected";
        v39 = 2082;
        v40 = v34;
        v21 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback, no backtrace";
LABEL_73:
        _os_log_impl(&dword_181A37000, v18, v19, v21, buf, 0x16u);
      }
    }

LABEL_74:
    if (v17)
    {
      free(v17);
    }

    goto LABEL_9;
  }

  __nwlog_obj();
  *buf = 136446210;
  v38 = "nw_protocol_http3_listen_protocol_disconnected";
  v13 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v35 = 0;
  if (!__nwlog_fault(v13, &type, &v35))
  {
    goto LABEL_85;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v14 = __nwlog_obj();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
    {
      goto LABEL_85;
    }

    *buf = 136446210;
    v38 = "nw_protocol_http3_listen_protocol_disconnected";
    v16 = "%{public}s called with null http3";
    goto LABEL_84;
  }

  if (v35 != 1)
  {
    v14 = __nwlog_obj();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
    {
      goto LABEL_85;
    }

    *buf = 136446210;
    v38 = "nw_protocol_http3_listen_protocol_disconnected";
    v16 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_84;
  }

  v30 = __nw_create_backtrace_string();
  v14 = __nwlog_obj();
  v15 = type;
  v31 = os_log_type_enabled(v14, type);
  if (!v30)
  {
    if (!v31)
    {
      goto LABEL_85;
    }

    *buf = 136446210;
    v38 = "nw_protocol_http3_listen_protocol_disconnected";
    v16 = "%{public}s called with null http3, no backtrace";
    goto LABEL_84;
  }

  if (v31)
  {
    *buf = 136446466;
    v38 = "nw_protocol_http3_listen_protocol_disconnected";
    v39 = 2082;
    v40 = v30;
    _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v30);
  if (v13)
  {
    goto LABEL_86;
  }
}

uint64_t ___ZL42nw_protocol_http3_listen_protocol_new_flowP18nw_listen_protocolP11nw_endpointP13nw_parameters_block_invoke_182(uint64_t a1)
{
  result = (*(*(a1 + 32) + 16))();
  if (result)
  {
    v2 = result;
    v3 = *(result + 32);

    return nw_protocol_connect_quiet(v3, v2);
  }

  return result;
}

double ___ZL46nw_protocol_http3_untyped_stream_get_callbacksv_block_invoke()
{
  dword_1EA83FBD4 = 0;
  unk_1EA83FBCD = 0;
  strcpy(&g_http3_untyped_stream_protocol_identifier, "http3-untyped-stream");
  *&result = 0x100000004;
  qword_1EA83FBD8 = 0x100000004;
  nw_protocol_http3_untyped_stream_get_callbacks(void)::protocol_callbacks = nw_protocol_default_add_input_handler;
  qword_1EA83FA40 = nw_protocol_default_replace_input_handler;
  qword_1EA83FA38 = nw_protocol_default_remove_input_handler;
  qword_1EA83FA78 = nw_protocol_default_output_available;
  qword_1EA83FAF0 = nw_protocol_default_output_finished;
  qword_1EA83FB38 = nw_protocol_default_input_flush;
  qword_1EA83FB28 = nw_protocol_default_get_message_properties;
  qword_1EA83FA98 = nw_protocol_default_link_state;
  qword_1EA83FAA0 = nw_protocol_default_get_parameters;
  qword_1EA83FAB0 = nw_protocol_default_get_local;
  qword_1EA83FAB8 = nw_protocol_default_get_remote;
  qword_1EA83FAA8 = nw_protocol_default_get_path;
  qword_1EA83FAD8 = nw_protocol_default_updated_path;
  qword_1EA83FAF8 = nw_protocol_default_get_output_local;
  qword_1EA83FB00 = nw_protocol_default_get_output_interface;
  qword_1EA83FA48 = nw_protocol_default_connect;
  qword_1EA83FA50 = nw_protocol_default_disconnect;
  qword_1EA83FB30 = nw_protocol_default_reset;
  qword_1EA83FAE0 = nw_protocol_default_supports_external_data;
  qword_1EA83FB08 = nw_protocol_default_waiting_for_output;
  qword_1EA83FB10 = nw_protocol_default_copy_info;
  qword_1EA83FAC0 = nw_protocol_default_register_notification;
  qword_1EA83FAC8 = nw_protocol_default_unregister_notification;
  qword_1EA83FAD0 = nw_protocol_default_notify;
  qword_1EA83FB18 = nw_protocol_default_add_listen_handler;
  qword_1EA83FB20 = nw_protocol_default_remove_listen_handler;
  qword_1EA83FA58 = nw_protocol_http3_untyped_stream_connected;
  qword_1EA83FA60 = nw_protocol_http3_untyped_stream_disconnected;
  qword_1EA83FA68 = nw_protocol_http3_untyped_stream_error;
  qword_1EA83FAE8 = nw_protocol_http3_untyped_stream_input_finished;
  qword_1EA83FA70 = nw_protocol_http3_untyped_stream_input_available;
  qword_1EA83FA80 = nw_protocol_http3_untyped_stream_get_input_frames;
  qword_1EA83FA88 = nw_protocol_http3_untyped_stream_get_output_frames;
  qword_1EA83FA90 = nw_protocol_http3_untyped_stream_finalize_output_frames;
  return result;
}

uint64_t nw_protocol_http3_untyped_stream_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  v27 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v3, &type, &v19))
    {
      goto LABEL_18;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
      v6 = "%{public}s called with null protocol";
      goto LABEL_48;
    }

    if (v19 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type;
      v16 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (!v16)
        {
          goto LABEL_38;
        }

        *buf = 136446466;
        v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
        v23 = 2082;
        v24 = backtrace_string;
        v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_37;
      }

      if (!v16)
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
      v6 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
      v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_48:
    v9 = v13;
    v10 = v14;
    v11 = 12;
    goto LABEL_17;
  }

  handle = a1->handle;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!handle)
  {
    *buf = 136446210;
    v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v3, &type, &v19))
    {
      goto LABEL_18;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
      v6 = "%{public}s called with null http3_stream";
      goto LABEL_48;
    }

    if (v19 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type;
      v18 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (!v18)
        {
          goto LABEL_38;
        }

        *buf = 136446466;
        v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
        v23 = 2082;
        v24 = backtrace_string;
        v17 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_37:
        _os_log_impl(&dword_181A37000, v13, v14, v17, buf, 0x16u);
LABEL_38:
        free(backtrace_string);
        if (!v3)
        {
          return 0;
        }

        goto LABEL_19;
      }

      if (!v18)
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
      v6 = "%{public}s called with null http3_stream, no backtrace";
    }

    else
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
      v6 = "%{public}s called with null http3_stream, backtrace limit exceeded";
    }

    goto LABEL_48;
  }

  *buf = 136446466;
  v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
  v23 = 2048;
  v24 = handle;
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v3, &type, &v19))
  {
    goto LABEL_18;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    v5 = type;
    if (!os_log_type_enabled(gLogObj, type))
    {
      goto LABEL_18;
    }

    *buf = 136446466;
    v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
    v23 = 2048;
    v24 = handle;
    v6 = "%{public}s called on http3_untyped_stream %p";
LABEL_16:
    v9 = v4;
    v10 = v5;
    v11 = 22;
LABEL_17:
    _os_log_impl(&dword_181A37000, v9, v10, v6, buf, v11);
    goto LABEL_18;
  }

  if (v19 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    v5 = type;
    if (!os_log_type_enabled(gLogObj, type))
    {
      goto LABEL_18;
    }

    *buf = 136446466;
    v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
    v23 = 2048;
    v24 = handle;
    v6 = "%{public}s called on http3_untyped_stream %p, backtrace limit exceeded";
    goto LABEL_16;
  }

  v7 = __nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = gLogObj;
  v5 = type;
  v8 = os_log_type_enabled(gLogObj, type);
  if (!v7)
  {
    if (!v8)
    {
      goto LABEL_18;
    }

    *buf = 136446466;
    v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
    v23 = 2048;
    v24 = handle;
    v6 = "%{public}s called on http3_untyped_stream %p, no backtrace";
    goto LABEL_16;
  }

  if (v8)
  {
    *buf = 136446722;
    v22 = "nw_protocol_http3_untyped_stream_finalize_output_frames";
    v23 = 2048;
    v24 = handle;
    v25 = 2082;
    v26 = v7;
    _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called on http3_untyped_stream %p, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v7);
LABEL_18:
  if (v3)
  {
LABEL_19:
    free(v3);
  }

  return 0;
}

uint64_t nw_protocol_http3_untyped_stream_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  v31 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v7, &type, &v23))
    {
      goto LABEL_18;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
      v10 = "%{public}s called with null protocol";
      goto LABEL_48;
    }

    if (v23 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v17 = __nwlog_obj();
      v18 = type;
      v20 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (!v20)
        {
          goto LABEL_38;
        }

        *buf = 136446466;
        v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
        v27 = 2082;
        v28 = backtrace_string;
        v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_37;
      }

      if (!v20)
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
      v10 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
      v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_48:
    v13 = v17;
    v14 = v18;
    v15 = 12;
    goto LABEL_17;
  }

  handle = a1->handle;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!handle)
  {
    *buf = 136446210;
    v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v7, &type, &v23))
    {
      goto LABEL_18;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
      v10 = "%{public}s called with null http3_stream";
      goto LABEL_48;
    }

    if (v23 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v17 = __nwlog_obj();
      v18 = type;
      v22 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (!v22)
        {
          goto LABEL_38;
        }

        *buf = 136446466;
        v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
        v27 = 2082;
        v28 = backtrace_string;
        v21 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_37:
        _os_log_impl(&dword_181A37000, v17, v18, v21, buf, 0x16u);
LABEL_38:
        free(backtrace_string);
        if (!v7)
        {
          return 0;
        }

        goto LABEL_19;
      }

      if (!v22)
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
      v10 = "%{public}s called with null http3_stream, no backtrace";
    }

    else
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
      v10 = "%{public}s called with null http3_stream, backtrace limit exceeded";
    }

    goto LABEL_48;
  }

  *buf = 136446466;
  v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
  v27 = 2048;
  v28 = handle;
  v7 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v7, &type, &v23))
  {
    goto LABEL_18;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    v9 = type;
    if (!os_log_type_enabled(gLogObj, type))
    {
      goto LABEL_18;
    }

    *buf = 136446466;
    v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
    v27 = 2048;
    v28 = handle;
    v10 = "%{public}s called on http3_untyped_stream %p";
LABEL_16:
    v13 = v8;
    v14 = v9;
    v15 = 22;
LABEL_17:
    _os_log_impl(&dword_181A37000, v13, v14, v10, buf, v15);
    goto LABEL_18;
  }

  if (v23 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    v9 = type;
    if (!os_log_type_enabled(gLogObj, type))
    {
      goto LABEL_18;
    }

    *buf = 136446466;
    v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
    v27 = 2048;
    v28 = handle;
    v10 = "%{public}s called on http3_untyped_stream %p, backtrace limit exceeded";
    goto LABEL_16;
  }

  v11 = __nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = gLogObj;
  v9 = type;
  v12 = os_log_type_enabled(gLogObj, type);
  if (!v11)
  {
    if (!v12)
    {
      goto LABEL_18;
    }

    *buf = 136446466;
    v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
    v27 = 2048;
    v28 = handle;
    v10 = "%{public}s called on http3_untyped_stream %p, no backtrace";
    goto LABEL_16;
  }

  if (v12)
  {
    *buf = 136446722;
    v26 = "nw_protocol_http3_untyped_stream_get_output_frames";
    v27 = 2048;
    v28 = handle;
    v29 = 2082;
    v30 = v11;
    _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called on http3_untyped_stream %p, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v11);
LABEL_18:
  if (v7)
  {
LABEL_19:
    free(v7);
  }

  return 0;
}

void nw_http3_untyped_stream_configure_for_webtransport(uint64_t *a1)
{
  v47 = *MEMORY[0x1E69E9840];
  v2 = a1[13];
  v3 = a1[11];
  if (v3 != 84 && v3 != 65)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = a1[11];
    *buf = 136446466;
    v36 = "nw_http3_untyped_stream_configure_for_webtransport";
    v37 = 2048;
    v38 = v6;
    v7 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v7, type, &v33))
    {
      goto LABEL_45;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type[0];
      if (!os_log_type_enabled(gLogObj, type[0]))
      {
        goto LABEL_45;
      }

      v10 = a1[11];
      *buf = 136446466;
      v36 = "nw_http3_untyped_stream_configure_for_webtransport";
      v37 = 2048;
      v38 = v10;
      v11 = "%{public}s received invalid type %llu";
    }

    else if (v33 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type[0];
      v17 = os_log_type_enabled(gLogObj, type[0]);
      if (backtrace_string)
      {
        if (v17)
        {
          v18 = a1[11];
          *buf = 136446722;
          v36 = "nw_http3_untyped_stream_configure_for_webtransport";
          v37 = 2048;
          v38 = v18;
          v39 = 2082;
          v40 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v9, "%{public}s received invalid type %llu, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(backtrace_string);
        goto LABEL_45;
      }

      if (!v17)
      {
LABEL_45:
        if (v7)
        {
          free(v7);
        }

        return;
      }

      v24 = a1[11];
      *buf = 136446466;
      v36 = "nw_http3_untyped_stream_configure_for_webtransport";
      v37 = 2048;
      v38 = v24;
      v11 = "%{public}s received invalid type %llu, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type[0];
      if (!os_log_type_enabled(gLogObj, type[0]))
      {
        goto LABEL_45;
      }

      v19 = a1[11];
      *buf = 136446466;
      v36 = "nw_http3_untyped_stream_configure_for_webtransport";
      v37 = 2048;
      v38 = v19;
      v11 = "%{public}s received invalid type %llu, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v8, v9, v11, buf, 0x16u);
    goto LABEL_45;
  }

  v4 = a1[12];
  if (v4 != -1)
  {
    goto LABEL_64;
  }

  *type = -1;
  v33 = 0;
  if (nw_http_vle_decode_from_frames((a1 + 22), a1, a1 + 8, type, &v33, 0))
  {
    a1[12] = *type;
    if ((!v2 || (*(v2 + 1399) & 0x20) == 0) && gLogDatapath == 1)
    {
      v29 = __nwlog_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        v30 = *(v2 + 1304);
        v31 = " ";
        v36 = "nw_http3_untyped_stream_configure_for_webtransport";
        v37 = 2082;
        v32 = "";
        if (!v2)
        {
          v31 = "";
        }

        *buf = 136447490;
        if (v2)
        {
          v32 = (v2 + 1313);
        }

        v38 = v32;
        v39 = 2080;
        v40 = v31;
        v41 = 1024;
        v42 = v30;
        v43 = 2048;
        v44 = a1;
        v45 = 2048;
        v46 = *type;
        _os_log_impl(&dword_181A37000, v29, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> untyped stream %p got webtransport session id %llu", buf, 0x3Au);
      }
    }
  }

  v4 = a1[12];
  if (v4 != -1)
  {
LABEL_64:
    v5 = *(v2 + 888);
    if (v5)
    {
      while (v5[30] != v4)
      {
        v5 = v5[67];
        if (!v5)
        {
          return;
        }
      }

      if (v2 && (*(v2 + 1399) & 0x20) != 0)
      {
        listen_protocol = nw_protocol_webtransport_get_listen_protocol(v5[6]);
        if (listen_protocol)
        {
LABEL_21:
          *(v2 + 1296) = a1;
          (**listen_protocol)(listen_protocol, a1[17], a1[15]);
          if (*(v2 + 1296))
          {
            if ((*(v2 + 1399) & 0x20) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v13 = gLogObj;
              if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
              {
                v14 = *(v2 + 1304);
                v15 = a1[10];
                *buf = 136447490;
                v36 = "nw_http3_untyped_stream_configure_for_webtransport";
                v37 = 2082;
                v38 = (v2 + 1313);
                v39 = 2080;
                v40 = " ";
                v41 = 1024;
                v42 = v14;
                v43 = 2048;
                v44 = a1;
                v45 = 2048;
                v46 = v15;
                _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> New flow failed for untyped stream %p with id %llu", buf, 0x3Au);
              }
            }

            *(v2 + 1296) = 0;
          }

          return;
        }
      }

      else
      {
        if (gLogDatapath == 1)
        {
          v25 = __nwlog_obj();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
          {
            v26 = *(v2 + 1304);
            v27 = (v2 + 1313);
            v36 = "nw_http3_untyped_stream_configure_for_webtransport";
            v28 = " ";
            v37 = 2082;
            *buf = 136447490;
            if (!v2)
            {
              v27 = "";
            }

            v38 = v27;
            if (!v2)
            {
              v28 = "";
            }

            v39 = 2080;
            v40 = v28;
            v41 = 1024;
            v42 = v26;
            v43 = 2048;
            v44 = v5;
            v45 = 2048;
            v46 = a1;
            _os_log_impl(&dword_181A37000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Found webtransport sessions stream %p for uni stream %p", buf, 0x3Au);
          }
        }

        listen_protocol = nw_protocol_webtransport_get_listen_protocol(v5[6]);
        if (listen_protocol)
        {
          goto LABEL_21;
        }

        if (!v2)
        {
          goto LABEL_35;
        }
      }

      if ((*(v2 + 1399) & 0x20) != 0)
      {
LABEL_41:
        nw_protocol_disconnect(a1, v2);
        return;
      }

LABEL_35:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        v21 = " ";
        v22 = *(v2 + 1304);
        v36 = "nw_http3_untyped_stream_configure_for_webtransport";
        v37 = 2082;
        v23 = (v2 + 1313);
        *buf = 136446978;
        if (!v2)
        {
          v23 = "";
        }

        v38 = v23;
        if (!v2)
        {
          v21 = "";
        }

        v39 = 2080;
        v40 = v21;
        v41 = 1024;
        v42 = v22;
        _os_log_impl(&dword_181A37000, v20, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> No listen handler found for inbound stream", buf, 0x26u);
      }

      goto LABEL_41;
    }
  }
}

void nw_http3_fail_all_streams(uint64_t a1, uint64_t a2)
{
  v26 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v4 = *(a1 + 1399);
    if ((v4 & 0x20) == 0)
    {
      if (gLogDatapath == 1)
      {
        v12 = __nwlog_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          v13 = *(a1 + 1304);
          *buf = 136446978;
          v19 = "nw_http3_fail_all_streams";
          v20 = 2082;
          v21 = (a1 + 1313);
          v22 = 2080;
          v23 = " ";
          v24 = 1024;
          v25 = v13;
          _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }

      v4 = *(a1 + 1399);
    }

    if ((v4 & 0x80) == 0)
    {
      *(a1 + 1399) = v4 | 0x80;
      nw_http3_async_close_connection_if_no_stream(a1);
      v5 = *(a1 + 888);
      if (v5)
      {
        do
        {
          callbacks = v5[8].callbacks;
          nw_protocol_http3_stream_error(v5, a1);
          v5 = callbacks;
        }

        while (callbacks);
      }

      v7 = *(a1 + 1256);
      if (v7)
      {
        nw_quic_connection_close_with_error(v7, a2);
      }
    }

    return;
  }

  __nwlog_obj();
  *buf = 136446210;
  v19 = "nw_http3_fail_all_streams";
  v8 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_27;
      }

      *buf = 136446210;
      v19 = "nw_http3_fail_all_streams";
      v11 = "%{public}s called with null http3";
      goto LABEL_26;
    }

    if (v16 != 1)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_27;
      }

      *buf = 136446210;
      v19 = "nw_http3_fail_all_streams";
      v11 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_26;
    }

    backtrace_string = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v15 = os_log_type_enabled(v9, type);
    if (backtrace_string)
    {
      if (v15)
      {
        *buf = 136446466;
        v19 = "nw_http3_fail_all_streams";
        v20 = 2082;
        v21 = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
      goto LABEL_27;
    }

    if (v15)
    {
      *buf = 136446210;
      v19 = "nw_http3_fail_all_streams";
      v11 = "%{public}s called with null http3, no backtrace";
LABEL_26:
      _os_log_impl(&dword_181A37000, v9, v10, v11, buf, 0xCu);
    }
  }

LABEL_27:
  if (v8)
  {
    free(v8);
  }
}

uint64_t ___ZL37nw_http3_decoder_stream_process_inputP17nw_protocol_http3_block_invoke(uint64_t a1, uint64_t a2)
{
  v29 = 0;
  v4 = nw_frame_unclaimed_bytes(a2, &v29);
  v5 = *(a1 + 40);
  v6 = v29;
  v7 = *(v5 + 448);
  if (v7)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v7);
    fprintf(*(v5 + 448), "got %zu bytes of decoder stream", v6);
    fputc(10, *(v5 + 448));
  }

  if (v6)
  {
    v8 = &v4[v6];
    v9 = *(v5 + 408);
    do
    {
      while (v9 == 1)
      {
        v17 = 0;
        v18 = *(v5 + 424);
        v16 = *(v5 + 412);
        v14 = v4;
        while (1)
        {
          v20 = *v14++;
          v19 = v20;
          v18 += (v20 & 0x7F) << v16;
          v16 += 7;
          if ((v20 & 0x80) == 0)
          {
            break;
          }

LABEL_28:
          if (v14 >= v8)
          {
            if (v17)
            {
              v22 = 0;
            }

            else
            {
              v22 = *(v5 + 416);
            }

            v27 = v22 + v14 - v4;
            if (v27 < 0xB)
            {
              *(v5 + 424) = v18;
              *(v5 + 412) = v16;
              *(v5 + 416) = v27;
              *(v5 + 408) = 1;
              goto LABEL_32;
            }

            goto LABEL_38;
          }
        }

        if (v16 >= 0x40)
        {
          v21 = v16 != 70 || v19 > 1;
          if (v21 || (v18 & 0x8000000000000000) == 0)
          {
            goto LABEL_38;
          }
        }

LABEL_25:
        if ((*(v5 + 432))(v5 + 248))
        {
LABEL_38:
          nw_http3_fail_all_streams(*(a1 + 40), 514);
          return 0;
        }

        v9 = 0;
        *(v5 + 408) = 0;
        v4 = v14;
        if (v14 >= v8)
        {
          goto LABEL_31;
        }
      }

      if (!v9)
      {
        v10 = *v4;
        v11 = v10;
        v12 = v10 >= 0x40;
        v13 = enc_proc_stream_cancel;
        if (!v12)
        {
          v13 = enc_proc_ici;
        }

        if (v11 < 0)
        {
          v13 = enc_proc_header_ack;
        }

        *(v5 + 432) = v13;
        v14 = v4 + 1;
        if (v11 < 0)
        {
          v15 = 127;
        }

        else
        {
          v15 = 63;
        }

        if ((v15 & *v4) == v15)
        {
          v16 = 0;
          v17 = 1;
          v18 = v15;
          goto LABEL_28;
        }

        goto LABEL_25;
      }
    }

    while (v4 < v8);
  }

LABEL_31:
  *(v5 + 444) += v6;
LABEL_32:
  v23 = (*(*(a1 + 32) + 8) + 48);
  v24 = *(a2 + 32);
  v25 = *(a2 + 40);
  if (v24)
  {
    v23 = (v24 + 40);
  }

  *v23 = v25;
  *v25 = v24;
  *(a2 + 32) = 0;
  *(a2 + 40) = 0;
  v26 = 1;
  nw_frame_finalize(a2);
  return v26;
}

uint64_t ___ZL25__nw_frame_array_finalizeP16nw_frame_array_sbb_block_invoke_63620(uint64_t a1, uint64_t a2)
{
  v20 = *MEMORY[0x1E69E9840];
  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v17 = "__nw_frame_finalize";
    v6 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
    {
      goto LABEL_33;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_33;
      }

      *buf = 136446210;
      v17 = "__nw_frame_finalize";
      v9 = "%{public}s called with null frame";
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v17 = "__nw_frame_finalize";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_33:
        if (!v6)
        {
          return 1;
        }

LABEL_34:
        free(v6);
        return 1;
      }

      if (!v11)
      {
        goto LABEL_33;
      }

      *buf = 136446210;
      v17 = "__nw_frame_finalize";
      v9 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_33;
      }

      *buf = 136446210;
      v17 = "__nw_frame_finalize";
      v9 = "%{public}s called with null frame, backtrace limit exceeded";
    }

LABEL_32:
    _os_log_impl(&dword_181A37000, v7, v8, v9, buf, 0xCu);
    goto LABEL_33;
  }

  v2 = *(a2 + 80);
  if (v2)
  {
    v3 = *(a1 + 32);
    v4 = *(a2 + 88);
    *(a2 + 80) = 0;
    *(a2 + 88) = 0;
    v2(a2, v3, v4);
    return 1;
  }

  __nwlog_obj();
  *buf = 136446210;
  v17 = "__nw_frame_finalize";
  v6 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (!__nwlog_fault(v6, &type, &v14))
  {
    goto LABEL_33;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_33;
    }

    *buf = 136446210;
    v17 = "__nw_frame_finalize";
    v9 = "%{public}s called with null frame->finalizer";
    goto LABEL_32;
  }

  if (v14 != 1)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_33;
    }

    *buf = 136446210;
    v17 = "__nw_frame_finalize";
    v9 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
    goto LABEL_32;
  }

  v12 = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v13 = os_log_type_enabled(v7, type);
  if (!v12)
  {
    if (!v13)
    {
      goto LABEL_33;
    }

    *buf = 136446210;
    v17 = "__nw_frame_finalize";
    v9 = "%{public}s called with null frame->finalizer, no backtrace";
    goto LABEL_32;
  }

  if (v13)
  {
    *buf = 136446466;
    v17 = "__nw_frame_finalize";
    v18 = 2082;
    v19 = v12;
    _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v12);
  if (v6)
  {
    goto LABEL_34;
  }

  return 1;
}

uint64_t ___ZL37nw_http3_encoder_stream_process_inputP17nw_protocol_http3_block_invoke(uint64_t a1, uint64_t a2)
{
  v160 = *MEMORY[0x1E69E9840];
  v143 = 0;
  v4 = nw_frame_unclaimed_bytes(a2, &v143);
  v5 = v143;
  v141 = a1;
  v6 = *(a1 + 40);
  *(v6 + 1048) += v143;
  v7 = *(v6 + 536);
  if (v7)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v7);
    fprintf(*(v6 + 536), "got %zu bytes of encoder stream", v5);
    fputc(10, *(v6 + 536));
  }

  *(v6 + 512) += v5;
  if (v5)
  {
    v8 = &v4[v5];
    v9 = (v6 + 780);
    v10 = (v6 + 768);
    v142 = (v6 + 760);
    v11 = -1;
    while (2)
    {
      switch(*(v6 + 720))
      {
        case 0:
          v13 = *v4;
          if ((*v4 & 0x80000000) == 0)
          {
            if (v13 < 0x40)
            {
              *(v6 + 728) = 0;
              if (v13 >= 0x20)
              {
                *(v6 + 720) = 7;
                v11 = 5;
LABEL_105:
                v24 = v4 + 1;
                v26 = ~(-1 << v11);
                if ((*v4 & v26) == v26)
                {
                  v27 = 0;
                  v25 = 1;
                  do
                  {
                    if (v24 >= v8)
                    {
                      goto LABEL_213;
                    }

LABEL_182:
                    v99 = *v24++;
                    v98 = v99;
                    v26 += (v99 & 0x7F) << v27;
                    v27 += 7;
                  }

                  while ((v99 & 0x80) != 0);
                  if (v27 >= 0x40)
                  {
                    v100 = v27 != 70 || v98 > 1;
                    if (v100 || (v26 & 0x8000000000000000) == 0)
                    {
                      goto LABEL_233;
                    }
                  }
                }

                else
                {
                  v26 &= *v4;
                }

                *(v6 + 752) = v26;
                if (v26 > *(v6 + 492))
                {
                  goto LABEL_233;
                }

                *(v6 + 720) = 0;
                v101 = *(v6 + 536);
                if (v101)
                {
                  fwrite("qdec: debug: ", 0xDuLL, 1uLL, v101);
                  fprintf(*(v6 + 536), "got TSU=%llu", *(v6 + 752));
                  fputc(10, *(v6 + 536));
                  v26 = *(v6 + 752);
                }

                *(v6 + 496) = v26;
                v102 = *(v6 + 508);
                v103 = v26 >> 5;
                *(v6 + 508) = v103;
                if (v102 != v103)
                {
                  v104 = *(v6 + 520);
                  if (v104 == *(v6 + 524) && v104 == 2 * v102 - 1)
                  {
                    v105 = 2 * v103 - 1;
                    *(v6 + 520) = v105;
                    *(v6 + 524) = v105;
                  }
                }

                qdec_remove_overflow_entries(v6 + 488);
                goto LABEL_7;
              }

              *(v6 + 720) = 6;
              v11 = 5;
LABEL_76:
              v24 = v4 + 1;
              v26 = ~(-1 << v11);
              if ((*v4 & v26) == v26)
              {
                v27 = 0;
                v25 = 1;
                do
                {
                  if (v24 >= v8)
                  {
                    goto LABEL_213;
                  }

LABEL_198:
                  v106 = *v24++;
                  v26 += (v106 & 0x7F) << v27;
                  v27 += 7;
                }

                while (v106 < 0);
                if (v27 > 0x3F || v26 >> 24 != 0)
                {
                  goto LABEL_233;
                }
              }

              else
              {
                LODWORD(v26) = *v4 & v26;
              }

              *(v6 + 752) = v26;
              v108 = *(v6 + 544);
              if (!v108)
              {
                goto LABEL_233;
              }

              v109 = *(v6 + 548);
              v110 = *(v6 + 552);
              v111 = v109 >= v110 ? 0 : *(v6 + 544);
              if (v109 + v111 - v110 <= v26)
              {
                goto LABEL_233;
              }

              v112 = *(*(v6 + 560) + 8 * ((v108 + v109 + ~v26) % v108));
              if (!v112)
              {
                goto LABEL_233;
              }

              v113 = *v112 + v112[1];
              v114 = malloc_type_malloc(v113 + 28, 0x9E340883uLL);
              if (!v114)
              {
                goto LABEL_233;
              }

              v115 = v114;
              memcpy(v114, v112, v113 + 28);
              *(v115 + 2) = 1;
              if (!lsqpack_dec_push_entry(v6 + 488, v115))
              {
                *(v6 + 720) = 0;
                goto LABEL_7;
              }

              v127 = *(v115 + 2) - 1;
              *(v115 + 2) = v127;
              if (!v127)
              {
                free(v115);
              }

              goto LABEL_233;
            }

            *(v6 + 788) = (v13 & 0x20) != 0;
            *(v6 + 728) = 0;
            *(v6 + 768) = 0;
            *(v6 + 720) = 8;
            v11 = 5;
LABEL_100:
            v24 = v4 + 1;
            v26 = ~(-1 << v11);
            if ((*v4 & v26) == v26)
            {
              v27 = 0;
              v25 = 1;
              do
              {
                if (v24 >= v8)
                {
                  goto LABEL_213;
                }

LABEL_167:
                v94 = *v24++;
                v26 += (v94 & 0x7F) << v27;
                v27 += 7;
              }

              while (v94 < 0);
              if (v27 > 0x3F || v26 >> 24 != 0)
              {
                goto LABEL_233;
              }
            }

            else
            {
              v26 &= *v4;
            }

            *(v6 + 760) = v26;
            if (*(v6 + 496) << (2 * *(v6 + 788)) < v26)
            {
              goto LABEL_233;
            }

            v96 = v26 ? v26 + (v26 >> 1) : 16;
            *(v6 + 776) = v96;
            v97 = malloc_type_malloc(v96 + 28, 0xEB71E7E8uLL);
            *(v6 + 768) = v97;
            if (!v97)
            {
              goto LABEL_233;
            }

            v97[6] = 0;
            *v9 = 0;
            if (!*(v6 + 788))
            {
              v12 = 10;
              goto LABEL_6;
            }

            v84 = 9;
LABEL_180:
            *(v6 + 720) = v84;
            *(v6 + 752) = 0;
            goto LABEL_7;
          }

          *(v6 + 809) = (v13 & 0x40) != 0;
          *(v6 + 728) = 0;
          *v10 = 0;
          *(v6 + 776) = 0;
          v11 = 6;
          *(v6 + 720) = 1;
LABEL_85:
          v24 = v4 + 1;
          v26 = ~(-1 << v11);
          if ((*v4 & v26) != v26)
          {
            v26 &= *v4;
            goto LABEL_156;
          }

          v27 = 0;
          v36 = 1;
          while (v24 < v8)
          {
LABEL_150:
            v87 = *v24++;
            v26 += (v87 & 0x7F) << v27;
            v27 += 7;
            if ((v87 & 0x80) == 0)
            {
              if (v27 > 0x3F || v26 >> 24 != 0)
              {
                goto LABEL_233;
              }

LABEL_156:
              *(v6 + 760) = v26;
              if (*(v6 + 809))
              {
                if (v26 > 0x62)
                {
                  goto LABEL_233;
                }

                *v10 = 0;
                v12 = 2;
                goto LABEL_6;
              }

              v89 = *(v6 + 544);
              if (v89)
              {
                v90 = *(v6 + 548);
                v91 = *(v6 + 552);
                v92 = v90 >= v91 ? 0 : *(v6 + 544);
                if (v90 + v92 - v91 > v26)
                {
                  v93 = *(*(v6 + 560) + 8 * ((v89 + v90 + ~v26) % v89));
                  *(v6 + 768) = v93;
                  if (!v93)
                  {
                    goto LABEL_233;
                  }

                  ++*(v93 + 8);
                  v12 = 2;
                  goto LABEL_6;
                }
              }

LABEL_225:
              *v10 = 0;
              goto LABEL_233;
            }
          }

          if (v36)
          {
            v122 = 0;
          }

          else
          {
            v122 = *(v6 + 736);
          }

          v117 = v122 + v24 - v4;
          if (v117 >= 0xB)
          {
            goto LABEL_233;
          }

LABEL_217:
          *(v6 + 744) = v26;
          *(v6 + 732) = v27;
          *(v6 + 736) = v117;
          *(v6 + 728) = 1;
          break;
        case 1:
          if (!*(v6 + 728))
          {
            goto LABEL_85;
          }

          v36 = 0;
          v26 = *(v6 + 744);
          v27 = *(v6 + 732);
          v24 = v4;
          goto LABEL_150;
        case 2:
          *(v6 + 808) = *v4 >> 7;
          *(v6 + 728) = 0;
          *(v6 + 720) = 3;
          v11 = 7;
          goto LABEL_37;
        case 3:
          if (*(v6 + 728))
          {
            v25 = 0;
            v26 = *(v6 + 744);
            v27 = *(v6 + 732);
            v24 = v4;
            goto LABEL_123;
          }

LABEL_37:
          v24 = v4 + 1;
          v26 = ~(-1 << v11);
          if ((*v4 & v26) == v26)
          {
            v27 = 0;
            v25 = 1;
            do
            {
              if (v24 >= v8)
              {
                goto LABEL_213;
              }

LABEL_123:
              v73 = *v24++;
              v26 += (v73 & 0x7F) << v27;
              v27 += 7;
            }

            while (v73 < 0);
            if (v27 > 0x3F || v26 >> 24 != 0)
            {
              goto LABEL_233;
            }
          }

          else
          {
            LODWORD(v26) = *v4 & v26;
          }

          *(v6 + 764) = v26;
          if (*(v6 + 809))
          {
            v75 = &(&static_table)[3 * *v142];
            v78 = *v75;
            v76 = (v75 + 2);
            v77 = v78;
          }

          else
          {
            v76 = *v10;
            v77 = (*v10 + 28);
          }

          v79 = *v76;
          *(v6 + 804) = v79;
          *(v6 + 784) = v77;
          if ((*(v6 + 496) - v79) << (2 * *(v6 + 808)) < v26)
          {
            goto LABEL_233;
          }

          v80 = v26 >> 1;
          if (!*(v6 + 808))
          {
            v80 = 0;
          }

          v81 = v80 + v26;
          *(v6 + 792) = v81;
          v82 = malloc_type_malloc(v79 + v81 + 28, 0x100004027586B93uLL);
          *(v6 + 776) = v82;
          if (!v82)
          {
            goto LABEL_233;
          }

          if (*(v6 + 809))
          {
            v82[6] = 5;
            *(*(v6 + 776) + 12) = name_hashes[*(v6 + 760)];
            v83 = (v6 + 760);
          }

          else
          {
            v82[6] = *(*(v6 + 768) + 24) & 5;
            *(*(v6 + 776) + 12) = *(*(v6 + 768) + 12);
            v83 = (*(v6 + 768) + 20);
          }

          *(*(v6 + 776) + 20) = *v83;
          **(v6 + 776) = *(v6 + 804);
          *(v6 + 796) = 0;
          v23 = *(v6 + 764);
          if (v23)
          {
            if (!*(v6 + 808))
            {
              v12 = 4;
              goto LABEL_6;
            }

            v84 = 5;
            goto LABEL_180;
          }

LABEL_142:
          *(*(v6 + 776) + 4) = v23;
          *(*(v6 + 776) + 8) = 1;
          memcpy((*(v6 + 776) + 28), *(v6 + 784), *(v6 + 804));
          v85 = *(v6 + 768);
          if (v85)
          {
            v86 = v85[2] - 1;
            v85[2] = v86;
            if (!v86)
            {
              free(v85);
            }

            *v10 = 0;
          }

          if (!lsqpack_dec_push_entry(v6 + 488, *(v6 + 776)))
          {
            goto LABEL_147;
          }

          goto LABEL_226;
        case 4:
          v19 = *(v6 + 764);
          if (*(v6 + 792) < v19)
          {
            __assert_rtn("lsqpack_dec_enc_in", "lsqpack.c", 4753, "WINR.alloced_val_len >= WINR.val_len");
          }

          v20 = *(v6 + 796);
          v21 = v19 - v20;
          if (v21 >= v8 - v4)
          {
            v22 = (v8 - v4);
          }

          else
          {
            v22 = v21;
          }

          memcpy((*(v6 + 776) + v20 + **(v6 + 776) + 28), v4, v22);
          v23 = *(v6 + 796) + v22;
          *(v6 + 796) = v23;
          v24 = &v4[v22];
          if (v23 == *(v6 + 764))
          {
            goto LABEL_142;
          }

          goto LABEL_7;
        case 5:
          v37 = *(v6 + 764);
          v38 = *(v6 + 800);
          if (v37 - v38 >= (v8 - v4))
          {
            v39 = (v8 - v4);
          }

          else
          {
            v39 = (v37 - v38);
          }

          v40 = lsqpack_huff_decode(v4, v39, (*(v6 + 776) + *(v6 + 796) + **(v6 + 776) + 28), (*(v6 + 792) - *(v6 + 796)), (v6 + 752), v39 + v38 == v37);
          v42 = v41;
          v43 = HIDWORD(v40);
          if (v40 == 2)
          {
            v65 = (2 * *(v6 + 792));
            *(v6 + 792) = v65;
            v66 = malloc_type_realloc(*(v6 + 776), v65 + *(v6 + 804) + 28, 0x100004027586B93uLL);
            if (!v66)
            {
              goto LABEL_233;
            }

            *(v6 + 776) = v66;
          }

          else if (v40 != 1)
          {
            if (v40)
            {
              goto LABEL_233;
            }

            *(*(v6 + 776) + 4) = *(v6 + 796) + HIDWORD(v40);
            *(*(v6 + 776) + 8) = 1;
            memcpy((*(v6 + 776) + 28), *(v6 + 784), *(v6 + 804));
            v44 = *(v6 + 768);
            if (v44)
            {
              v45 = v44[2] - 1;
              v44[2] = v45;
              if (!v45)
              {
                free(v44);
              }

              *v10 = 0;
            }

            if (!lsqpack_dec_push_entry(v6 + 488, *(v6 + 776)))
            {
              v24 = &v4[v42];
LABEL_147:
              *(v6 + 720) = 0;
              *(v6 + 776) = 0;
              goto LABEL_7;
            }

LABEL_226:
            v125 = *(v6 + 776);
            v126 = v125[2] - 1;
            v125[2] = v126;
            if (!v126)
            {
              free(v125);
            }

            *(v6 + 776) = 0;
LABEL_233:
            v128 = *(v141 + 40);
            if (!v128 || (*(v128 + 1399) & 0x20) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v129 = gLogObj;
              v130 = os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
              v131 = *(v141 + 40);
              if (v130)
              {
                v132 = *(v131 + 1304);
                v133 = "";
                v134 = *(v128 + 816);
                v135 = v131 == 0;
                if (v131)
                {
                  v136 = (v131 + 1313);
                }

                else
                {
                  v136 = "";
                }

                v137 = *(v128 + 820);
                v138 = *(v128 + 824);
                if (!v135)
                {
                  v133 = " ";
                }

                v139 = *(v128 + 832);
                *buf = 136448002;
                v145 = "nw_http3_encoder_stream_process_input_block_invoke";
                v146 = 2082;
                v147 = v136;
                v148 = 2080;
                v149 = v133;
                v150 = 1024;
                v151 = v132;
                v152 = 1024;
                v153 = v134;
                v154 = 1024;
                v155 = v137;
                v156 = 2048;
                v157 = v138;
                v158 = 2048;
                v159 = v139;
                _os_log_impl(&dword_181A37000, v129, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> qpack dec error type %d line %d off %llu id %llu", buf, 0x46u);
                v128 = *(v141 + 40);
              }

              else
              {
                v128 = *(v141 + 40);
              }
            }

            nw_http3_fail_all_streams(v128, 513);
            return 0;
          }

          v24 = &v4[v42];
          *(v6 + 800) += v42;
          *(v6 + 796) += v43;
          goto LABEL_7;
        case 6:
          if (!*(v6 + 728))
          {
            goto LABEL_76;
          }

          v25 = 0;
          v26 = *(v6 + 744);
          v27 = *(v6 + 732);
          v24 = v4;
          goto LABEL_198;
        case 7:
          if (!*(v6 + 728))
          {
            goto LABEL_105;
          }

          v25 = 0;
          v26 = *(v6 + 744);
          v27 = *(v6 + 732);
          v24 = v4;
          goto LABEL_182;
        case 8:
          if (!*(v6 + 728))
          {
            goto LABEL_100;
          }

          v25 = 0;
          v26 = *(v6 + 744);
          v27 = *(v6 + 732);
          v24 = v4;
          goto LABEL_167;
        case 9:
          v28 = *(v6 + 760);
          v29 = *(v6 + 784);
          if (v28 - v29 >= (v8 - v4))
          {
            v30 = (v8 - v4);
          }

          else
          {
            v30 = (v28 - v29);
          }

          v31 = lsqpack_huff_decode(v4, v30, (*(v6 + 768) + *(v6 + 780) + 28), (*(v6 + 776) - *(v6 + 780)), (v6 + 752), v30 + v29 == v28);
          v33 = HIDWORD(v31);
          if (v31 == 2)
          {
            v62 = (2 * *(v6 + 776));
            *(v6 + 776) = v62;
            v63 = v32;
            v64 = malloc_type_realloc(*(v6 + 768), v62 + 28, 0x100004027586B93uLL);
            if (!v64)
            {
              goto LABEL_233;
            }

            *(v6 + 768) = v64;
            v24 = &v4[v63];
            v61 = *(v6 + 784) + v63;
            goto LABEL_91;
          }

          if (v31 == 1)
          {
            v24 = &v4[v32];
            v61 = *(v6 + 784) + v32;
LABEL_91:
            *(v6 + 784) = v61;
            *(v6 + 780) += v33;
            goto LABEL_7;
          }

          if (v31)
          {
            goto LABEL_233;
          }

          v24 = &v4[v32];
          v34 = *(v6 + 768);
          v35 = *(v6 + 780) + HIDWORD(v31);
LABEL_71:
          *v34 = v35;
          v12 = 11;
LABEL_6:
          *(v6 + 720) = v12;
LABEL_7:
          v4 = v24;
          if (v24 >= v8)
          {
            break;
          }

          continue;
        case 0xA:
          v53 = *(v6 + 760);
          if (*(v6 + 776) < v53)
          {
            __assert_rtn("lsqpack_dec_enc_in", "lsqpack.c", 4848, "WONR.alloced_len >= WONR.str_len");
          }

          v54 = *v9;
          v55 = v53 - v54;
          if (v55 >= v8 - v4)
          {
            v56 = (v8 - v4);
          }

          else
          {
            v56 = v55;
          }

          memcpy(&(*v10)[v54 + 28], v4, v56);
          v35 = *v9 + v56;
          *v9 = v35;
          v24 = &v4[v56];
          if (v35 != *v142)
          {
            goto LABEL_7;
          }

          v34 = *(v6 + 768);
          goto LABEL_71;
        case 0xB:
          *(v6 + 788) = *v4 >> 7;
          *(v6 + 728) = 0;
          *(v6 + 720) = 12;
          v11 = 7;
          goto LABEL_25;
        case 0xC:
          if (*(v6 + 728))
          {
            v25 = 0;
            v26 = *(v6 + 744);
            v27 = *(v6 + 732);
            v24 = v4;
            goto LABEL_109;
          }

LABEL_25:
          v24 = v4 + 1;
          v26 = ~(-1 << v11);
          if ((*v4 & v26) != v26)
          {
            v26 &= *v4;
            goto LABEL_115;
          }

          v27 = 0;
          v25 = 1;
          while (v24 < v8)
          {
LABEL_109:
            v70 = *v24++;
            v26 += (v70 & 0x7F) << v27;
            v27 += 7;
            if ((v70 & 0x80) == 0)
            {
              if (v27 > 0x3F || v26 >> 24 != 0)
              {
                goto LABEL_233;
              }

LABEL_115:
              *(v6 + 760) = v26;
              v60 = *(v6 + 768);
              v72 = *(v6 + 788);
              if ((*(v6 + 496) - *v60) << (2 * v72) < v26)
              {
                goto LABEL_233;
              }

              *v9 = 0;
              if (v26)
              {
                if (!v72)
                {
                  v12 = 14;
                  goto LABEL_6;
                }

                *(v6 + 720) = 13;
                *(v6 + 752) = 0;
                goto LABEL_7;
              }

LABEL_119:
              *(v60 + 1) = v26;
              *(*v10 + 2) = 1;
              if (!lsqpack_dec_push_entry(v6 + 488, *v10))
              {
LABEL_120:
                *(v6 + 720) = 0;
                *(v6 + 768) = 0;
                goto LABEL_7;
              }

              goto LABEL_223;
            }
          }

LABEL_213:
          if (v25)
          {
            v116 = 0;
          }

          else
          {
            v116 = *(v6 + 736);
          }

          v117 = v116 + v24 - v4;
          if (v117 >= 0xB)
          {
            goto LABEL_233;
          }

          goto LABEL_217;
        case 0xD:
          v46 = *(v6 + 760);
          v47 = *(v6 + 784);
          if (v46 - v47 >= (v8 - v4))
          {
            v48 = (v8 - v4);
          }

          else
          {
            v48 = (v46 - v47);
          }

          v49 = lsqpack_huff_decode(v4, v48, (*(v6 + 768) + *(v6 + 780) + **(v6 + 768) + 28), (*(v6 + 776) - *(v6 + 780) - **(v6 + 768)), (v6 + 752), v48 + v47 == v46);
          v51 = v50;
          v52 = HIDWORD(v49);
          if (v49 == 2)
          {
            v67 = *(v6 + 776);
            if (!v67)
            {
              __assert_rtn("lsqpack_dec_enc_in", "lsqpack.c", 4924, "WONR.alloced_len");
            }

            v68 = (2 * v67);
            *(v6 + 776) = v68;
            v69 = malloc_type_realloc(*(v6 + 768), v68 + 28, 0x100004027586B93uLL);
            if (!v69)
            {
              goto LABEL_233;
            }

            *(v6 + 768) = v69;
          }

          else if (v49 != 1)
          {
            if (v49)
            {
              goto LABEL_233;
            }

            *(*v10 + 1) = *v9 + HIDWORD(v49);
            *(*v10 + 2) = 1;
            if (!lsqpack_dec_push_entry(v6 + 488, *v10))
            {
              v24 = &v4[v51];
              goto LABEL_120;
            }

LABEL_223:
            v123 = *v10;
            v124 = *(*v10 + 2) - 1;
            *(*v10 + 2) = v124;
            if (!v124)
            {
              free(v123);
            }

            goto LABEL_225;
          }

          v24 = &v4[v51];
          *(v6 + 784) += v51;
          *(v6 + 780) += v52;
          goto LABEL_7;
        case 0xE:
          v14 = *(v6 + 768);
          v15 = *v14;
          v16 = *(v6 + 760);
          v17 = v16 + *v14;
          if (*(v6 + 776) >= v17)
          {
            v18 = (v6 + 760);
          }

          else
          {
            *(v6 + 776) = v17;
            v14 = malloc_type_realloc(v14, v17 + 28, 0x100004027586B93uLL);
            if (!v14)
            {
              goto LABEL_233;
            }

            *v10 = v14;
            v18 = (v6 + 760);
            v16 = *v142;
            v15 = *v14;
          }

          v57 = *v9;
          v58 = v16 - v57;
          if (v58 >= v8 - v4)
          {
            v59 = (v8 - v4);
          }

          else
          {
            v59 = v58;
          }

          memcpy(v14 + v15 + v57 + 28, v4, v59);
          LODWORD(v26) = *v9 + v59;
          *v9 = v26;
          v24 = &v4[v59];
          if (v26 != *v18)
          {
            goto LABEL_7;
          }

          v60 = *v10;
          goto LABEL_119;
        default:
          __assert_rtn("lsqpack_dec_enc_in", "lsqpack.c", 5020, "0");
      }

      break;
    }
  }

  v118 = (*(*(v141 + 32) + 8) + 48);
  v119 = *(a2 + 32);
  v120 = *(a2 + 40);
  if (v119)
  {
    v118 = (v119 + 40);
  }

  *v118 = v120;
  *v120 = v119;
  *(a2 + 32) = 0;
  *(a2 + 40) = 0;
  v121 = 1;
  nw_frame_finalize(a2);
  return v121;
}

BOOL ___ZL40nw_http3_stream_fields_process_unblockedP24nw_protocol_http3_stream_block_invoke(uint64_t a1, void *a2)
{
  v3 = (*(a1 + 40) + 224);
  v4 = a2[4];
  v5 = a2[5];
  if (v4)
  {
    v3 = (v4 + 40);
  }

  *v3 = v5;
  *v5 = v4;
  a2[4] = 0;
  a2[5] = 0;
  *(*(*(a1 + 32) + 8) + 24) = nw_http3_stream_handle_fields(*(a1 + 40), 0, a2, (*(*(a1 + 40) + 732) >> 5) & 1);
  return *(*(*(a1 + 32) + 8) + 24) == 0;
}

void ___ZL40nw_http3_stream_fields_process_unblockedP24nw_protocol_http3_stream_block_invoke_2(uint64_t a1)
{
  v46 = *MEMORY[0x1E69E9840];
  if ((*(*(a1 + 32) + 16))())
  {
    v2 = *(a1 + 40);
    if ((*(v2 + 732) & 0x400) != 0)
    {
      if ((*(v2 + 732) & 0x2000) == 0 && gLogDatapath == 1)
      {
        v21 = __nwlog_obj();
        v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG);
        v2 = *(a1 + 40);
        if (v22)
        {
          v23 = (v2 + 632);
          v24 = "";
          v25 = *(*(v2 + 344) + 1304);
          v26 = v2 == 0;
          v27 = *(v2 + 240);
          if (v26)
          {
            v23 = "";
          }

          else
          {
            v24 = " ";
          }

          *buf = 136447234;
          v37 = "nw_http3_stream_fields_process_unblocked_block_invoke_2";
          v38 = 2082;
          v39 = v23;
          v40 = 2080;
          v41 = v24;
          v42 = 1024;
          v43 = v25;
          v44 = 2048;
          v45 = v27;
          _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> delivering deferred input finished", buf, 0x30u);
          v2 = *(a1 + 40);
        }
      }

      *(v2 + 732) &= ~0x400u;
      v3 = *(*(a1 + 40) + 48);
      if (v3)
      {
        v4 = *(v3 + 24);
        if (v4)
        {
          v5 = *(v4 + 184);
          if (v5)
          {
            v5();
            return;
          }
        }
      }

      __nwlog_obj();
      v6 = *(*(a1 + 40) + 48);
      v7 = "invalid";
      if (v6)
      {
        v8 = *(v6 + 16);
        if (v8)
        {
          v7 = v8;
        }
      }

      *buf = 136446466;
      v37 = "nw_http3_stream_fields_process_unblocked_block_invoke";
      v38 = 2082;
      v39 = v7;
      v9 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v34 = 0;
      if (!__nwlog_fault(v9, &type, &v34))
      {
        goto LABEL_44;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v10 = __nwlog_obj();
        v11 = type;
        if (!os_log_type_enabled(v10, type))
        {
          goto LABEL_44;
        }

        v12 = *(*(a1 + 40) + 48);
        v13 = "invalid";
        if (v12)
        {
          v14 = *(v12 + 16);
          if (v14)
          {
            v13 = v14;
          }
        }

        *buf = 136446466;
        v37 = "nw_http3_stream_fields_process_unblocked_block_invoke";
        v38 = 2082;
        v39 = v13;
        v15 = "%{public}s protocol %{public}s has invalid input_finished callback";
      }

      else if (v34 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v10 = __nwlog_obj();
        v11 = type;
        v17 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v17)
          {
            v18 = *(*(a1 + 40) + 48);
            v19 = "invalid";
            if (v18)
            {
              v20 = *(v18 + 16);
              if (v20)
              {
                v19 = v20;
              }
            }

            *buf = 136446722;
            v37 = "nw_http3_stream_fields_process_unblocked_block_invoke";
            v38 = 2082;
            v39 = v19;
            v40 = 2082;
            v41 = backtrace_string;
            _os_log_impl(&dword_181A37000, v10, v11, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_44;
        }

        if (!v17)
        {
LABEL_44:
          if (v9)
          {
            free(v9);
          }

          return;
        }

        v31 = *(*(a1 + 40) + 48);
        v32 = "invalid";
        if (v31)
        {
          v33 = *(v31 + 16);
          if (v33)
          {
            v32 = v33;
          }
        }

        *buf = 136446466;
        v37 = "nw_http3_stream_fields_process_unblocked_block_invoke";
        v38 = 2082;
        v39 = v32;
        v15 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
      }

      else
      {
        v10 = __nwlog_obj();
        v11 = type;
        if (!os_log_type_enabled(v10, type))
        {
          goto LABEL_44;
        }

        v28 = *(*(a1 + 40) + 48);
        v29 = "invalid";
        if (v28)
        {
          v30 = *(v28 + 16);
          if (v30)
          {
            v29 = v30;
          }
        }

        *buf = 136446466;
        v37 = "nw_http3_stream_fields_process_unblocked_block_invoke";
        v38 = 2082;
        v39 = v29;
        v15 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A37000, v10, v11, v15, buf, 0x16u);
      goto LABEL_44;
    }
  }
}

void nw_http3_start_decoder_stream_if_needed(void *a1)
{
  v38 = *MEMORY[0x1E69E9840];
  if (!a1[136])
  {
    outbound = nw_http3_uni_stream_create_outbound(a1, 3, 0);
    a1[136] = outbound;
    *outbound = *a1;
    nw_protocol_set_input_handler(a1[136], a1);
    v3 = a1[4];
    if (v3)
    {
      v4 = *(v3 + 24);
      if (v4)
      {
        v5 = *v4;
        if (v5)
        {
          v5(a1[4], a1[136]);
          goto LABEL_6;
        }
      }

      __nwlog_obj();
      v8 = *(v3 + 16);
      if (!v8)
      {
        v8 = "invalid";
      }
    }

    else
    {
      __nwlog_obj();
      v8 = "invalid";
    }

    *buf = 136446466;
    v33 = "nw_http3_start_decoder_stream_if_needed";
    v34 = 2082;
    v35 = v8;
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v10, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
        {
          goto LABEL_43;
        }

        v13 = "invalid";
        if (v3 && *(v3 + 16))
        {
          v13 = *(v3 + 16);
        }

        *buf = 136446466;
        v33 = "nw_http3_start_decoder_stream_if_needed";
        v34 = 2082;
        v35 = v13;
        v14 = "%{public}s protocol %{public}s has invalid add_input_handler callback";
LABEL_42:
        _os_log_impl(&dword_181A37000, v11, v12, v14, buf, 0x16u);
        goto LABEL_43;
      }

      if (v30 != 1)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
        {
          goto LABEL_43;
        }

        v18 = "invalid";
        if (v3 && *(v3 + 16))
        {
          v18 = *(v3 + 16);
        }

        *buf = 136446466;
        v33 = "nw_http3_start_decoder_stream_if_needed";
        v34 = 2082;
        v35 = v18;
        v14 = "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded";
        goto LABEL_42;
      }

      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v16)
        {
          goto LABEL_43;
        }

        v19 = "invalid";
        if (v3 && *(v3 + 16))
        {
          v19 = *(v3 + 16);
        }

        *buf = 136446466;
        v33 = "nw_http3_start_decoder_stream_if_needed";
        v34 = 2082;
        v35 = v19;
        v14 = "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace";
        goto LABEL_42;
      }

      if (v16)
      {
        v17 = "invalid";
        if (v3 && *(v3 + 16))
        {
          v17 = *(v3 + 16);
        }

        *buf = 136446722;
        v33 = "nw_http3_start_decoder_stream_if_needed";
        v34 = 2082;
        v35 = v17;
        v36 = 2082;
        v37 = backtrace_string;
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s protocol %{public}s has invalid add_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
      }

      free(backtrace_string);
    }

LABEL_43:
    if (v10)
    {
      free(v10);
    }

    if (!v3)
    {
      __nwlog_obj();
      v9 = "invalid";
      goto LABEL_47;
    }

LABEL_6:
    v6 = *(v3 + 24);
    if (v6)
    {
      v7 = *(v6 + 24);
      if (v7)
      {
        v7(v3, a1[136]);
        return;
      }
    }

    __nwlog_obj();
    v9 = *(v3 + 16);
    if (!v9)
    {
      v9 = "invalid";
    }

LABEL_47:
    *buf = 136446466;
    v33 = "nw_http3_start_decoder_stream_if_needed";
    v34 = 2082;
    v35 = v9;
    v20 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v20, &type, &v30))
    {
      goto LABEL_73;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v21 = __nwlog_obj();
      v22 = type;
      if (!os_log_type_enabled(v21, type))
      {
        goto LABEL_73;
      }

      v23 = "invalid";
      if (v3 && *(v3 + 16))
      {
        v23 = *(v3 + 16);
      }

      *buf = 136446466;
      v33 = "nw_http3_start_decoder_stream_if_needed";
      v34 = 2082;
      v35 = v23;
      v24 = "%{public}s protocol %{public}s has invalid connect callback";
    }

    else if (v30 == 1)
    {
      v25 = __nw_create_backtrace_string();
      v21 = __nwlog_obj();
      v22 = type;
      v26 = os_log_type_enabled(v21, type);
      if (v25)
      {
        if (v26)
        {
          v27 = "invalid";
          if (v3 && *(v3 + 16))
          {
            v27 = *(v3 + 16);
          }

          *buf = 136446722;
          v33 = "nw_http3_start_decoder_stream_if_needed";
          v34 = 2082;
          v35 = v27;
          v36 = 2082;
          v37 = v25;
          _os_log_impl(&dword_181A37000, v21, v22, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v25);
        goto LABEL_73;
      }

      if (!v26)
      {
LABEL_73:
        if (v20)
        {
          free(v20);
        }

        return;
      }

      v29 = "invalid";
      if (v3 && *(v3 + 16))
      {
        v29 = *(v3 + 16);
      }

      *buf = 136446466;
      v33 = "nw_http3_start_decoder_stream_if_needed";
      v34 = 2082;
      v35 = v29;
      v24 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
    }

    else
    {
      v21 = __nwlog_obj();
      v22 = type;
      if (!os_log_type_enabled(v21, type))
      {
        goto LABEL_73;
      }

      v28 = "invalid";
      if (v3 && *(v3 + 16))
      {
        v28 = *(v3 + 16);
      }

      *buf = 136446466;
      v33 = "nw_http3_start_decoder_stream_if_needed";
      v34 = 2082;
      v35 = v28;
      v24 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v21, v22, v24, buf, 0x16u);
    goto LABEL_73;
  }
}

void nw_http3_decoder_stream_process_output(uint64_t a1)
{
  v2 = (a1 + 1397);
  v104 = *MEMORY[0x1E69E9840];
  v3 = "nw_http3_decoder_stream_process_output";
  while ((*v2 & 0x4000) == 0)
  {
    if (*(a1 + 520) == *(a1 + 524))
    {
      goto LABEL_49;
    }

    v101[0] = 0;
    v101[1] = v101;
    v4 = *(a1 + 1088);
    if (!v4)
    {
      return;
    }

    v5 = *(v4 + 24);
    if (!v5)
    {
      return;
    }

    v6 = *(v5 + 88);
    if (!v6 || !v6(*(a1 + 1088), a1, 6, 6, 0xFFFFFFFFLL, v101))
    {
      return;
    }

    v7 = *(a1 + 520);
    v8 = v7 - *(a1 + 524);
    if (!v8)
    {
      v9 = *(a1 + 536);
      if (v9)
      {
        fwrite("qdec: debug: ", 0xDuLL, 1uLL, v9);
        fwrite("no ICI instruction necessary: emitting zero bytes", 0x31uLL, 1uLL, *(a1 + 536));
        fputc(10, *(a1 + 536));
      }

      goto LABEL_13;
    }

    v16 = *(a1 + 508);
    if (v16)
    {
      v17 = (v8 + 2 * v16) % (2 * v16);
      if (v17 > 0x3E)
      {
        v96 = 63;
        v18 = v17 - 63;
        if ((v17 - 63) < 0x80)
        {
          v20 = &v96;
          v19 = 1;
        }

        else
        {
          v97 = v18 | 0x80;
          if (v18 < 0x4000)
          {
            v18 >>= 7;
            v19 = 2;
            v20 = &v97;
          }

          else
          {
            v98 = (v18 >> 7) | 0x80;
            if (v18 < 0x200000)
            {
              v18 >>= 14;
              v19 = 3;
              v20 = &v98;
            }

            else
            {
              v99 = (v18 >> 14) | 0x80;
              if (v18 >> 28)
              {
                v100 = (v18 >> 21) | 0x80;
                v19 = 5;
                v20 = &v100;
                v18 >>= 28;
              }

              else
              {
                v18 >>= 21;
                v19 = 4;
                v20 = &v99;
              }
            }
          }
        }

        v26 = v20 + 2;
        *(&v96 + v19) = v18;
        if (v20 + 2 <= &v96)
        {
          goto LABEL_13;
        }

        goto LABEL_31;
      }
    }

    else
    {
      LODWORD(v17) = 0;
    }

    v96 = v17;
    v26 = &v97;
LABEL_31:
    v27 = *(a1 + 536);
    if (v27)
    {
      fwrite("qdec: debug: ", 0xDuLL, 1uLL, v27);
      fprintf(*(a1 + 536), "wrote ICI: count=%u", v17);
      fputc(10, *(a1 + 536));
      v7 = *(a1 + 520);
    }

    *(a1 + 524) = v7;
    *(a1 + 512) += v26 - &v96;
    if (v26 - &v96 >= 1)
    {
      *buf = 0;
      *&buf[8] = buf;
      *&buf[16] = 0x2000000000;
      v103 = 0;
      v89[0] = MEMORY[0x1E69E9820];
      v89[1] = 0x40000000;
      v90 = ___ZL38nw_http3_decoder_stream_process_outputP17nw_protocol_http3_block_invoke;
      v91 = &unk_1E6A393C0;
      v92 = buf;
      v93 = v26 - &v96;
      v94 = &v96;
      v95 = a1;
      v28 = v101[0];
      do
      {
        if (!v28)
        {
          break;
        }

        v29 = *(v28 + 32);
        v30 = v90(v89);
        v28 = v29;
      }

      while ((v30 & 1) != 0);
      _Block_object_dispose(buf, 8);
      goto LABEL_46;
    }

LABEL_13:
    __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = v3;
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v87 = 0;
    if (!__nwlog_fault(v10, &type, &v87))
    {
      goto LABEL_44;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
      {
        goto LABEL_44;
      }

      *buf = 136446210;
      *&buf[4] = v3;
      v13 = v11;
      v14 = v12;
      v15 = "%{public}s Failed to generate ici";
      goto LABEL_43;
    }

    if (v87 != 1)
    {
      v31 = __nwlog_obj();
      v32 = type;
      if (!os_log_type_enabled(v31, type))
      {
        goto LABEL_44;
      }

      *buf = 136446210;
      *&buf[4] = v3;
      v13 = v31;
      v14 = v32;
      v15 = "%{public}s Failed to generate ici, backtrace limit exceeded";
      goto LABEL_43;
    }

    v21 = v3;
    backtrace_string = __nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v24 = type;
    v25 = os_log_type_enabled(v23, type);
    if (backtrace_string)
    {
      if (v25)
      {
        *buf = 136446466;
        *&buf[4] = v21;
        *&buf[12] = 2082;
        *&buf[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v23, v24, "%{public}s Failed to generate ici, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
      v3 = v21;
      goto LABEL_44;
    }

    v3 = v21;
    if (v25)
    {
      *buf = 136446210;
      *&buf[4] = v21;
      v13 = v23;
      v14 = v24;
      v15 = "%{public}s Failed to generate ici, no backtrace";
LABEL_43:
      _os_log_impl(&dword_181A37000, v13, v14, v15, buf, 0xCu);
    }

LABEL_44:
    if (v10)
    {
      free(v10);
    }

LABEL_46:
    v33 = *(v4 + 24);
    if (v33)
    {
      v34 = *(v33 + 96);
      if (v34)
      {
        v34(v4, v101);
        goto LABEL_49;
      }
    }

    __nwlog_obj();
    v42 = *(v4 + 16);
    if (!v42)
    {
      v42 = "invalid";
    }

    *buf = 136446466;
    *&buf[4] = v3;
    *&buf[12] = 2082;
    *&buf[14] = v42;
    v43 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v87 = 0;
    v85 = v43;
    if (__nwlog_fault(v43, &type, &v87))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v44 = __nwlog_obj();
        v45 = type;
        if (!os_log_type_enabled(v44, type))
        {
          goto LABEL_94;
        }

        v46 = *(v4 + 16);
        if (!v46)
        {
          v46 = "invalid";
        }

        *buf = 136446466;
        *&buf[4] = v3;
        *&buf[12] = 2082;
        *&buf[14] = v46;
        v47 = v44;
        v48 = v45;
        v49 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
        goto LABEL_93;
      }

      if (v87 != 1)
      {
        v54 = __nwlog_obj();
        v55 = type;
        if (!os_log_type_enabled(v54, type))
        {
          goto LABEL_94;
        }

        v56 = *(v4 + 16);
        if (!v56)
        {
          v56 = "invalid";
        }

        *buf = 136446466;
        *&buf[4] = v3;
        *&buf[12] = 2082;
        *&buf[14] = v56;
        v47 = v54;
        v48 = v55;
        v49 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
        goto LABEL_93;
      }

      v50 = __nw_create_backtrace_string();
      v51 = __nwlog_obj();
      v83 = type;
      v52 = os_log_type_enabled(v51, type);
      if (v50)
      {
        if (v52)
        {
          v53 = *(v4 + 16);
          if (!v53)
          {
            v53 = "invalid";
          }

          *buf = 136446722;
          *&buf[4] = v3;
          *&buf[12] = 2082;
          *&buf[14] = v53;
          *&buf[22] = 2082;
          v103 = v50;
          _os_log_impl(&dword_181A37000, v51, v83, "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v50);
        goto LABEL_94;
      }

      if (v52)
      {
        v57 = *(v4 + 16);
        if (!v57)
        {
          v57 = "invalid";
        }

        *buf = 136446466;
        *&buf[4] = v3;
        *&buf[12] = 2082;
        *&buf[14] = v57;
        v47 = v51;
        v48 = v83;
        v49 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
LABEL_93:
        _os_log_impl(&dword_181A37000, v47, v48, v49, buf, 0x16u);
      }
    }

LABEL_94:
    if (v85)
    {
      free(v85);
    }

LABEL_49:
    v35 = *(a1 + 952);
    if (!v35)
    {
      return;
    }

    if (*(v35 + 630) && nw_http3_stream_send_section_ack(*(a1 + 952)) && !nw_http3_stream_received_fields_done(v35))
    {
      nw_protocol_http3_stream_input_available(v35, v36);
    }

    nw_http3_stream_send_stream_cancellation(v35);
    if ((*(v35 + 732) & 0x1000) != 0 && !*(v35 + 520) && !*(v35 + 630) && !*(v35 + 631))
    {
      *(v35 + 732) &= ~0x1000u;
      v37 = *(v35 + 32);
      if (!v37 || (v38 = *(v37 + 24)) == 0 || (v39 = *(v38 + 32)) == 0)
      {
        __nwlog_obj();
        v40 = *(v35 + 32);
        if (v40)
        {
          v41 = *(v40 + 16);
          if (!v41)
          {
            v41 = "invalid";
          }
        }

        else
        {
          v41 = "invalid";
        }

        *buf = 136446466;
        *&buf[4] = "nw_http3_stream_decoder_stream_output_available";
        *&buf[12] = 2082;
        *&buf[14] = v41;
        v58 = _os_log_send_and_compose_impl();
        LOBYTE(v101[0]) = 16;
        v96 = 0;
        v86 = v58;
        if (!__nwlog_fault(v58, v101, &v96))
        {
          goto LABEL_131;
        }

        if (LOBYTE(v101[0]) == 17)
        {
          v59 = __nwlog_obj();
          v60 = v101[0];
          if (os_log_type_enabled(v59, v101[0]))
          {
            v61 = *(v35 + 32);
            if (v61)
            {
              v62 = *(v61 + 16);
              if (!v62)
              {
                v62 = "invalid";
              }
            }

            else
            {
              v62 = "invalid";
            }

            *buf = 136446466;
            *&buf[4] = "nw_http3_stream_decoder_stream_output_available";
            *&buf[12] = 2082;
            *&buf[14] = v62;
            v72 = v59;
            v73 = v60;
            v74 = "%{public}s protocol %{public}s has invalid disconnect callback";
            goto LABEL_130;
          }

          goto LABEL_131;
        }

        if (v96 == 1)
        {
          v63 = __nw_create_backtrace_string();
          v64 = __nwlog_obj();
          v84 = v101[0];
          v65 = os_log_type_enabled(v64, v101[0]);
          if (v63)
          {
            if (v65)
            {
              v66 = *(v35 + 32);
              if (v66)
              {
                v67 = *(v66 + 16);
                if (!v67)
                {
                  v67 = "invalid";
                }
              }

              else
              {
                v67 = "invalid";
              }

              *buf = 136446722;
              *&buf[4] = "nw_http3_stream_decoder_stream_output_available";
              *&buf[12] = 2082;
              *&buf[14] = v67;
              *&buf[22] = 2082;
              v103 = v63;
              _os_log_impl(&dword_181A37000, v64, v84, "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v63);
            goto LABEL_131;
          }

          if (!v65)
          {
LABEL_131:
            if (v86)
            {
              free(v86);
            }

            goto LABEL_3;
          }

          v75 = *(v35 + 32);
          if (v75)
          {
            v76 = *(v75 + 16);
            if (!v76)
            {
              v76 = "invalid";
            }
          }

          else
          {
            v76 = "invalid";
          }

          *buf = 136446466;
          *&buf[4] = "nw_http3_stream_decoder_stream_output_available";
          *&buf[12] = 2082;
          *&buf[14] = v76;
          v72 = v64;
          v73 = v84;
          v74 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
        }

        else
        {
          v68 = __nwlog_obj();
          v69 = v101[0];
          if (!os_log_type_enabled(v68, v101[0]))
          {
            goto LABEL_131;
          }

          v70 = *(v35 + 32);
          if (v70)
          {
            v71 = *(v70 + 16);
            if (!v71)
            {
              v71 = "invalid";
            }
          }

          else
          {
            v71 = "invalid";
          }

          *buf = 136446466;
          *&buf[4] = "nw_http3_stream_decoder_stream_output_available";
          *&buf[12] = 2082;
          *&buf[14] = v71;
          v72 = v68;
          v73 = v69;
          v74 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
        }

LABEL_130:
        _os_log_impl(&dword_181A37000, v72, v73, v74, buf, 0x16u);
        goto LABEL_131;
      }

      v39(v37, v35);
    }

LABEL_3:
    if (v35 == *(a1 + 952))
    {
      return;
    }
  }

  __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = v3;
  v77 = _os_log_send_and_compose_impl();
  LOBYTE(v101[0]) = 16;
  v96 = 0;
  if (!__nwlog_fault(v77, v101, &v96))
  {
    goto LABEL_147;
  }

  if (LOBYTE(v101[0]) == 17)
  {
    v78 = __nwlog_obj();
    v79 = v101[0];
    if (os_log_type_enabled(v78, v101[0]))
    {
      *buf = 136446210;
      *&buf[4] = v3;
      v80 = "%{public}s Must finalize output frames from decoder stream immediately";
      goto LABEL_146;
    }

    goto LABEL_147;
  }

  if (v96 != 1)
  {
    v78 = __nwlog_obj();
    v79 = v101[0];
    if (!os_log_type_enabled(v78, v101[0]))
    {
      goto LABEL_147;
    }

    *buf = 136446210;
    *&buf[4] = v3;
    v80 = "%{public}s Must finalize output frames from decoder stream immediately, backtrace limit exceeded";
    goto LABEL_146;
  }

  v81 = __nw_create_backtrace_string();
  v78 = __nwlog_obj();
  v79 = v101[0];
  v82 = os_log_type_enabled(v78, v101[0]);
  if (v81)
  {
    if (v82)
    {
      *buf = 136446466;
      *&buf[4] = v3;
      *&buf[12] = 2082;
      *&buf[14] = v81;
      _os_log_impl(&dword_181A37000, v78, v79, "%{public}s Must finalize output frames from decoder stream immediately, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v81);
    goto LABEL_147;
  }

  if (v82)
  {
    *buf = 136446210;
    *&buf[4] = v3;
    v80 = "%{public}s Must finalize output frames from decoder stream immediately, no backtrace";
LABEL_146:
    _os_log_impl(&dword_181A37000, v78, v79, v80, buf, 0xCu);
  }

LABEL_147:
  if (v77)
  {
    free(v77);
  }
}

uint64_t ___ZL38nw_http3_decoder_stream_process_outputP17nw_protocol_http3_block_invoke(void *a1, uint64_t a2)
{
  LODWORD(__n) = 0;
  v4 = nw_frame_unclaimed_bytes(a2, &__n);
  v5 = *(*(a1[4] + 8) + 24);
  v6 = a1[5] - v5;
  v7 = (a1[6] + v5);
  if (v6 >= __n)
  {
    memcpy(v4, v7, __n);
  }

  else
  {
    memcpy(v4, v7, a1[5] - v5);
    nw_frame_claim(a2, v8, 0, __n - v6);
  }

  *(*(a1[4] + 8) + 24) += __n;
  return 1;
}

uint64_t nw_http3_stream_send_section_ack(uint64_t a1)
{
  v30 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    if (*(a1 + 630))
    {
      *type = 0;
      v26 = type;
      output_frames = nw_http3_decoder_stream_get_output_frames(*(a1 + 344), a1);
      v3 = output_frames != 0;
      if (output_frames)
      {
        *buf = 0;
        *&buf[8] = buf;
        *&buf[16] = 0x2000000000;
        v29 = 0;
        v20[0] = MEMORY[0x1E69E9820];
        v20[1] = 0x40000000;
        v21 = ___ZL32nw_http3_stream_send_section_ackP24nw_protocol_http3_stream_block_invoke;
        v22 = &unk_1E6A39090;
        v23 = buf;
        v24 = a1;
        v4 = *type;
        do
        {
          if (!v4)
          {
            break;
          }

          v5 = *(v4 + 32);
          v6 = (v21)(v20);
          v4 = v5;
        }

        while ((v6 & 1) != 0);
        nw_http3_decoder_stream_finalize_output_frames(*(a1 + 344), a1);
        *(a1 + 630) = 0;
        _Block_object_dispose(buf, 8);
      }

      return v3;
    }

    __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_http3_stream_send_section_ack";
    v12 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v12, type, &v27))
    {
      goto LABEL_40;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http3_stream_send_section_ack";
        v15 = "%{public}s No section ack to send";
LABEL_39:
        _os_log_impl(&dword_181A37000, v13, v14, v15, buf, 0xCu);
      }
    }

    else if (v27 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type[0];
      v19 = os_log_type_enabled(v13, type[0]);
      if (backtrace_string)
      {
        if (v19)
        {
          *buf = 136446466;
          *&buf[4] = "nw_http3_stream_send_section_ack";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v13, v14, "%{public}s No section ack to send, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_40;
      }

      if (v19)
      {
        *buf = 136446210;
        *&buf[4] = "nw_http3_stream_send_section_ack";
        v15 = "%{public}s No section ack to send, no backtrace";
        goto LABEL_39;
      }
    }

    else
    {
      v13 = __nwlog_obj();
      v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http3_stream_send_section_ack";
        v15 = "%{public}s No section ack to send, backtrace limit exceeded";
        goto LABEL_39;
      }
    }

LABEL_40:
    if (v12)
    {
      free(v12);
    }

    return 1;
  }

  __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_http3_stream_send_section_ack";
  v8 = _os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (__nwlog_fault(v8, type, &v27))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type[0];
      if (os_log_type_enabled(v9, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http3_stream_send_section_ack";
        v11 = "%{public}s called with null http3_stream";
LABEL_33:
        _os_log_impl(&dword_181A37000, v9, v10, v11, buf, 0xCu);
      }
    }

    else if (v27 == 1)
    {
      v16 = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type[0];
      v17 = os_log_type_enabled(v9, type[0]);
      if (v16)
      {
        if (v17)
        {
          *buf = 136446466;
          *&buf[4] = "nw_http3_stream_send_section_ack";
          *&buf[12] = 2082;
          *&buf[14] = v16;
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v16);
        goto LABEL_34;
      }

      if (v17)
      {
        *buf = 136446210;
        *&buf[4] = "nw_http3_stream_send_section_ack";
        v11 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_33;
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v10 = type[0];
      if (os_log_type_enabled(v9, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http3_stream_send_section_ack";
        v11 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_33;
      }
    }
  }

LABEL_34:
  if (v8)
  {
    free(v8);
  }

  return 0;
}

uint64_t nw_http3_decoder_stream_get_output_frames(uint64_t a1, uint64_t a2)
{
  v21 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v18 = "nw_http3_decoder_stream_get_output_frames";
    v9 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v9, &type, &v15))
    {
      goto LABEL_26;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
      {
        goto LABEL_26;
      }

      *buf = 136446210;
      v18 = "nw_http3_decoder_stream_get_output_frames";
      v12 = "%{public}s called with null http3";
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v11 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v18 = "nw_http3_decoder_stream_get_output_frames";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (!v14)
      {
LABEL_26:
        if (v9)
        {
          free(v9);
        }

        return 0;
      }

      *buf = 136446210;
      v18 = "nw_http3_decoder_stream_get_output_frames";
      v12 = "%{public}s called with null http3, no backtrace";
    }

    else
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
      {
        goto LABEL_26;
      }

      *buf = 136446210;
      v18 = "nw_http3_decoder_stream_get_output_frames";
      v12 = "%{public}s called with null http3, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v10, v11, v12, buf, 0xCu);
    goto LABEL_26;
  }

  v3 = *(a1 + 952);
  if (v3)
  {
    if (v3 != a2)
    {
      result = 0;
      *(a2 + 584) = 0;
      v5 = *(a1 + 960);
      *(a2 + 592) = v5;
      *v5 = a2;
      *(a1 + 960) = a2 + 584;
      return result;
    }
  }

  else
  {
    *(a2 + 584) = 0;
    v6 = *(a1 + 960);
    *(a2 + 592) = v6;
    *v6 = a2;
    *(a1 + 960) = a2 + 584;
  }

  nw_http3_start_decoder_stream_if_needed(a1);
  result = *(a1 + 1088);
  if (result)
  {
    v7 = *(result + 24);
    if (v7)
    {
      v8 = *(v7 + 88);
      if (v8)
      {
        result = v8();
        if (result)
        {
          *(a1 + 1397) |= 0x4000u;
        }

        return result;
      }
    }

    return 0;
  }

  return result;
}

uint64_t ___ZL40nw_http3_stream_send_stream_cancellationP24nw_protocol_http3_stream_block_invoke(uint64_t a1, uint64_t a2)
{
  LODWORD(__n) = 0;
  v3 = nw_frame_unclaimed_bytes(a2, &__n);
  memcpy(v3, (*(a1 + 40) + *(*(*(a1 + 32) + 8) + 24) + 726), __n);
  *(*(*(a1 + 32) + 8) + 24) += __n;
  return 1;
}

void nw_http3_decoder_stream_finalize_output_frames(uint64_t a1, uint64_t a2)
{
  v42 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v2 = *(a1 + 952);
    if (v2 != a2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *buf = 136446210;
      v37 = "nw_http3_decoder_stream_finalize_output_frames";
      v3 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v34 = 0;
      if (!__nwlog_fault(v3, &type, &v34))
      {
        goto LABEL_26;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v4 = gLogObj;
        v5 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_26;
        }

        *buf = 136446210;
        v37 = "nw_http3_decoder_stream_finalize_output_frames";
        v6 = "%{public}s Decoder stream is not being used by current stream";
        goto LABEL_23;
      }

      if (v34 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v4 = gLogObj;
        v5 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_26;
        }

        *buf = 136446210;
        v37 = "nw_http3_decoder_stream_finalize_output_frames";
        v6 = "%{public}s Decoder stream is not being used by current stream, backtrace limit exceeded";
        goto LABEL_23;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      v16 = type;
      v17 = os_log_type_enabled(gLogObj, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *buf = 136446466;
          v37 = "nw_http3_decoder_stream_finalize_output_frames";
          v38 = 2082;
          v39 = backtrace_string;
          _os_log_impl(&dword_181A37000, v15, v16, "%{public}s Decoder stream is not being used by current stream, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v3)
        {
          return;
        }

LABEL_27:
        free(v3);
        return;
      }

      if (v17)
      {
        *buf = 136446210;
        v37 = "nw_http3_decoder_stream_finalize_output_frames";
        v6 = "%{public}s Decoder stream is not being used by current stream, no backtrace";
        v18 = v15;
        v19 = v16;
        goto LABEL_24;
      }

LABEL_26:
      if (!v3)
      {
        return;
      }

      goto LABEL_27;
    }

    v7 = (v2 + 584);
    v8 = *(v2 + 584);
    v9 = *(v2 + 592);
    v10 = (a1 + 960);
    if (v8)
    {
      v10 = (v8 + 592);
    }

    *v10 = v9;
    *v9 = v8;
    *v7 = 0u;
    *(a1 + 1397) &= ~0x4000u;
    v11 = *(a1 + 1088);
    if (v11)
    {
      v12 = *(v11 + 24);
      if (v12)
      {
        v13 = *(v12 + 96);
        if (v13)
        {

          v13();
          return;
        }
      }

      v21 = v11;
      __nwlog_obj();
      v22 = v21;
      v23 = *(v21 + 16);
      if (!v23)
      {
        v23 = "invalid";
      }
    }

    else
    {
      v22 = 0;
      __nwlog_obj();
      v23 = "invalid";
    }

    *buf = 136446466;
    v37 = "nw_http3_decoder_stream_finalize_output_frames";
    v38 = 2082;
    v39 = v23;
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v3, &type, &v34))
    {
      goto LABEL_26;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
      {
        goto LABEL_26;
      }

      v28 = "invalid";
      if (v22 && *(v22 + 16))
      {
        v28 = *(v22 + 16);
      }

      *buf = 136446466;
      v37 = "nw_http3_decoder_stream_finalize_output_frames";
      v38 = 2082;
      v39 = v28;
      v6 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
    }

    else if (v34 == 1)
    {
      v29 = __nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = type;
      v30 = os_log_type_enabled(v26, type);
      if (v29)
      {
        if (v30)
        {
          v31 = "invalid";
          if (v22 && *(v22 + 16))
          {
            v31 = *(v22 + 16);
          }

          *buf = 136446722;
          v37 = "nw_http3_decoder_stream_finalize_output_frames";
          v38 = 2082;
          v39 = v31;
          v40 = 2082;
          v41 = v29;
          _os_log_impl(&dword_181A37000, v26, v27, "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v29);
        goto LABEL_26;
      }

      if (!v30)
      {
        goto LABEL_26;
      }

      v33 = "invalid";
      if (v22 && *(v22 + 16))
      {
        v33 = *(v22 + 16);
      }

      *buf = 136446466;
      v37 = "nw_http3_decoder_stream_finalize_output_frames";
      v38 = 2082;
      v39 = v33;
      v6 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
    }

    else
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
      {
        goto LABEL_26;
      }

      v32 = "invalid";
      if (v22 && *(v22 + 16))
      {
        v32 = *(v22 + 16);
      }

      *buf = 136446466;
      v37 = "nw_http3_decoder_stream_finalize_output_frames";
      v38 = 2082;
      v39 = v32;
      v6 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
    }

    v18 = v26;
    v19 = v27;
    v20 = 22;
    goto LABEL_25;
  }

  __nwlog_obj();
  *buf = 136446210;
  v37 = "nw_http3_decoder_stream_finalize_output_frames";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v34 = 0;
  if (!__nwlog_fault(v3, &type, &v34))
  {
    goto LABEL_26;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
    {
      goto LABEL_26;
    }

    *buf = 136446210;
    v37 = "nw_http3_decoder_stream_finalize_output_frames";
    v6 = "%{public}s called with null http3";
    goto LABEL_23;
  }

  if (v34 != 1)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
    {
      goto LABEL_26;
    }

    *buf = 136446210;
    v37 = "nw_http3_decoder_stream_finalize_output_frames";
    v6 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_23;
  }

  v24 = __nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = type;
  v25 = os_log_type_enabled(v4, type);
  if (!v24)
  {
    if (!v25)
    {
      goto LABEL_26;
    }

    *buf = 136446210;
    v37 = "nw_http3_decoder_stream_finalize_output_frames";
    v6 = "%{public}s called with null http3, no backtrace";
LABEL_23:
    v18 = v4;
    v19 = v5;
LABEL_24:
    v20 = 12;
LABEL_25:
    _os_log_impl(&dword_181A37000, v18, v19, v6, buf, v20);
    goto LABEL_26;
  }

  if (v25)
  {
    *buf = 136446466;
    v37 = "nw_http3_decoder_stream_finalize_output_frames";
    v38 = 2082;
    v39 = v24;
    _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v24);
  if (v3)
  {
    goto LABEL_27;
  }
}

unint64_t ___ZL36nw_http3_stream_received_fields_doneP24nw_protocol_http3_stream_block_invoke(unint64_t result, char *__s)
{
  v24 = *MEMORY[0x1E69E9840];
  *v23 = 0;
  if (__s)
  {
    v3 = result;
    result = strlen(__s);
    if (result <= 7)
    {
      v23[0] = *__s;
      if (v23[0])
      {
        v23[1] = __s[1];
        if (v23[1])
        {
          v23[2] = __s[2];
          if (v23[2])
          {
            v23[3] = __s[3];
            if (v23[3])
            {
              v23[4] = __s[4];
              if (v23[4])
              {
                v23[5] = __s[5];
                if (v23[5])
                {
                  v23[6] = __s[6];
                  if (v23[6])
                  {
                    v23[7] = 0;
                  }
                }
              }
            }
          }
        }
      }

      v4 = *(v3 + 32);
      if ((!v4 || (*(v4 + 732) & 0x2000) == 0) && gLogDatapath == 1)
      {
        v5 = __nwlog_obj();
        v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);
        v4 = *(v3 + 32);
        if (v6)
        {
          v7 = (v4 + 632);
          v8 = "";
          v9 = *(*(v4 + 344) + 1304);
          if (!v4)
          {
            v7 = "";
          }

          v10 = *(v4 + 240);
          if (v4)
          {
            v8 = " ";
          }

          v11 = 136447490;
          v12 = "nw_http3_stream_received_fields_done_block_invoke";
          v13 = 2082;
          v14 = v7;
          v15 = 2080;
          v16 = v8;
          v17 = 1024;
          v18 = v9;
          v19 = 2048;
          v20 = v10;
          v21 = 2082;
          v22 = v23;
          _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> received CONNECT-UDP for flow ID %{public}s", &v11, 0x3Au);
          v4 = *(v3 + 32);
        }
      }

      result = atoi(v23);
      *(v4 + 248) = result;
      *(v4 + 732) |= 0x80u;
      *(*(v3 + 32) + 380) = 8;
    }
  }

  return result;
}

void ___ZL36nw_http3_stream_received_fields_doneP24nw_protocol_http3_stream_block_invoke_139(uint64_t a1, char *__s1)
{
  v36 = *MEMORY[0x1E69E9840];
  if (!__s1 || strcmp(__s1, "connect-udp") && strcmp(__s1, "connect-ip") && strcmp(__s1, "webtransport"))
  {
    return;
  }

  v4 = *(a1 + 32);
  v5 = *(v4 + 240);
  if ((v5 & 3) != 0)
  {
    if ((*(v4 + 732) & 0x2000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        v7 = *(a1 + 32);
        v8 = (v7 + 632);
        v9 = "";
        v10 = v7 == 0;
        if (!v7)
        {
          v8 = "";
        }

        v11 = *(*(v7 + 344) + 1304);
        v12 = *(v7 + 240);
        if (!v10)
        {
          v9 = " ";
        }

        v24 = 136447490;
        v25 = "nw_http3_stream_received_fields_done_block_invoke";
        v26 = 2082;
        v27 = v8;
        v28 = 2080;
        v29 = v9;
        v30 = 1024;
        v31 = v11;
        v32 = 2048;
        v33 = v12;
        v34 = 2048;
        v35 = v12;
        v13 = "%{public}s %{public}s%s<i%u:s%llu> received CONNECT(connect-udp/ip) for invalid stream ID %llu";
        v14 = v6;
        v15 = OS_LOG_TYPE_ERROR;
LABEL_13:
        _os_log_impl(&dword_181A37000, v14, v15, v13, &v24, 0x3Au);
      }
    }
  }

  else
  {
    *(v4 + 248) = v5 >> 2;
    if ((*(v4 + 732) & 0x2000) == 0 && gLogDatapath == 1)
    {
      v17 = __nwlog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        v18 = *(a1 + 32);
        v19 = (v18 + 632);
        v20 = "";
        v21 = v18 == 0;
        if (!v18)
        {
          v19 = "";
        }

        v22 = *(*(v18 + 344) + 1304);
        v23 = *(v18 + 240);
        if (!v21)
        {
          v20 = " ";
        }

        v24 = 136447490;
        v25 = "nw_http3_stream_received_fields_done_block_invoke";
        v26 = 2082;
        v27 = v19;
        v28 = 2080;
        v29 = v20;
        v30 = 1024;
        v31 = v22;
        v32 = 2048;
        v33 = v23;
        v34 = 2048;
        v35 = v23;
        v13 = "%{public}s %{public}s%s<i%u:s%llu> received CONNECT(connect-udp/ip) for stream ID %llu";
        v14 = v17;
        v15 = OS_LOG_TYPE_DEBUG;
        goto LABEL_13;
      }
    }
  }

  v16 = *(a1 + 32);
  if ((*(*(a1 + 40) + 1397) & 4) != 0)
  {
    *(v16 + 732) |= 0x80u;
  }

  else
  {
    nw_protocol_http3_stream_start_datagram_flow(v16);
  }

  *(*(a1 + 32) + 380) = 8;
}

void nw_protocol_http3_stream_start_datagram_flow(uint64_t a1)
{
  v71 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v60 = "nw_protocol_http3_stream_start_datagram_flow";
    v13 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v13, &type, &v57))
    {
      goto LABEL_53;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
      {
        goto LABEL_53;
      }

      *buf = 136446210;
      v60 = "nw_protocol_http3_stream_start_datagram_flow";
      v16 = "%{public}s called with null http3_stream";
    }

    else if (v57 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v28 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v28)
        {
          *buf = 136446466;
          v60 = "nw_protocol_http3_stream_start_datagram_flow";
          v61 = 2082;
          v62 = backtrace_string;
          _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_53;
      }

      if (!v28)
      {
LABEL_53:
        if (v13)
        {
          free(v13);
        }

        return;
      }

      *buf = 136446210;
      v60 = "nw_protocol_http3_stream_start_datagram_flow";
      v16 = "%{public}s called with null http3_stream, no backtrace";
    }

    else
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
      {
        goto LABEL_53;
      }

      *buf = 136446210;
      v60 = "nw_protocol_http3_stream_start_datagram_flow";
      v16 = "%{public}s called with null http3_stream, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v14, v15, v16, buf, 0xCu);
    goto LABEL_53;
  }

  if ((*(a1 + 732) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v17 = __nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      v18 = *(*(a1 + 344) + 1304);
      v19 = *(a1 + 240);
      *buf = 136447234;
      v60 = "nw_protocol_http3_stream_start_datagram_flow";
      v61 = 2082;
      v62 = (a1 + 632);
      v63 = 2080;
      v64 = " ";
      v65 = 1024;
      v66 = v18;
      v67 = 2048;
      v68 = v19;
      _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
    }
  }

  v2 = *(a1 + 732);
  if ((v2 & 0x40) == 0)
  {
    *(a1 + 732) = v2 | 0x40;
    nw_protocol_set_input_handler(a1 + 64, *(a1 + 48));
    *(a1 + 64) = *a1;
    v3 = *(a1 + 344);
    if (v3)
    {
      v4 = *(v3 + 32);
      if (v4)
      {
        v5 = v4[3];
        if (v5)
        {
          v6 = *v5;
          if (v6)
          {
            v6(v4, a1 + 64);
            nw_protocol_set_output_handler(a1 + 64, v4);
            goto LABEL_10;
          }
        }

        __nwlog_obj();
        v21 = 0;
        v22 = v4[2];
        if (!v22)
        {
          v22 = "invalid";
        }

LABEL_61:
        *buf = 136446466;
        v60 = "nw_protocol_http3_stream_start_datagram_flow";
        v61 = 2082;
        v62 = v22;
        v35 = _os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v57 = 0;
        if (!__nwlog_fault(v35, &type, &v57))
        {
          goto LABEL_87;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          v36 = __nwlog_obj();
          v37 = type;
          if (!os_log_type_enabled(v36, type))
          {
            goto LABEL_87;
          }

          v38 = "invalid";
          if (v4 && v4[2])
          {
            v38 = v4[2];
          }

          *buf = 136446466;
          v60 = "nw_protocol_http3_stream_start_datagram_flow";
          v61 = 2082;
          v62 = v38;
          v39 = "%{public}s protocol %{public}s has invalid add_input_handler callback";
        }

        else if (v57 == 1)
        {
          v40 = __nw_create_backtrace_string();
          v36 = __nwlog_obj();
          v37 = type;
          v41 = os_log_type_enabled(v36, type);
          if (v40)
          {
            if (v41)
            {
              v42 = "invalid";
              if (v4 && v4[2])
              {
                v42 = v4[2];
              }

              *buf = 136446722;
              v60 = "nw_protocol_http3_stream_start_datagram_flow";
              v61 = 2082;
              v62 = v42;
              v63 = 2082;
              v64 = v40;
              _os_log_impl(&dword_181A37000, v36, v37, "%{public}s protocol %{public}s has invalid add_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v40);
LABEL_87:
            if (v35)
            {
              free(v35);
            }

            nw_protocol_set_output_handler(a1 + 64, v4);
            if (v21)
            {
              __nwlog_obj();
              v20 = 1;
              if (!v4)
              {
                v45 = "invalid";
                goto LABEL_93;
              }

LABEL_91:
              v45 = v4[2];
              if (!v45)
              {
                v45 = "invalid";
              }

LABEL_93:
              *buf = 136446466;
              v60 = "nw_protocol_http3_stream_start_datagram_flow";
              v61 = 2082;
              v62 = v45;
              v46 = _os_log_send_and_compose_impl();
              type = OS_LOG_TYPE_ERROR;
              v57 = 0;
              if (!__nwlog_fault(v46, &type, &v57))
              {
                goto LABEL_120;
              }

              if (type == OS_LOG_TYPE_FAULT)
              {
                v47 = __nwlog_obj();
                v48 = type;
                if (!os_log_type_enabled(v47, type))
                {
                  goto LABEL_120;
                }

                v49 = "invalid";
                if (v4 && v4[2])
                {
                  v49 = v4[2];
                }

                *buf = 136446466;
                v60 = "nw_protocol_http3_stream_start_datagram_flow";
                v61 = 2082;
                v62 = v49;
                v50 = "%{public}s protocol %{public}s has invalid connect callback";
              }

              else if (v57 == 1)
              {
                v51 = __nw_create_backtrace_string();
                v47 = __nwlog_obj();
                v48 = type;
                v52 = os_log_type_enabled(v47, type);
                if (v51)
                {
                  if (v52)
                  {
                    v53 = "invalid";
                    if (v4 && v4[2])
                    {
                      v53 = v4[2];
                    }

                    *buf = 136446722;
                    v60 = "nw_protocol_http3_stream_start_datagram_flow";
                    v61 = 2082;
                    v62 = v53;
                    v63 = 2082;
                    v64 = v51;
                    _os_log_impl(&dword_181A37000, v47, v48, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
                  }

                  free(v51);
LABEL_120:
                  if (v46)
                  {
                    free(v46);
                  }

                  if (v20)
                  {
                    goto LABEL_17;
                  }

                  goto LABEL_13;
                }

                if (!v52)
                {
                  goto LABEL_120;
                }

                v55 = "invalid";
                if (v4 && v4[2])
                {
                  v55 = v4[2];
                }

                *buf = 136446466;
                v60 = "nw_protocol_http3_stream_start_datagram_flow";
                v61 = 2082;
                v62 = v55;
                v50 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
              }

              else
              {
                v47 = __nwlog_obj();
                v48 = type;
                if (!os_log_type_enabled(v47, type))
                {
                  goto LABEL_120;
                }

                v54 = "invalid";
                if (v4 && v4[2])
                {
                  v54 = v4[2];
                }

                *buf = 136446466;
                v60 = "nw_protocol_http3_stream_start_datagram_flow";
                v61 = 2082;
                v62 = v54;
                v50 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
              }

              _os_log_impl(&dword_181A37000, v47, v48, v50, buf, 0x16u);
              goto LABEL_120;
            }

LABEL_10:
            v7 = v4[3];
            if (v7)
            {
              v8 = *(v7 + 24);
              if (v8)
              {
                v8(v4, a1 + 64);
LABEL_13:
                v9 = v4[3];
                if (v9)
                {
                  v10 = *(v9 + 224);
                  if (v10)
                  {
                    v11 = v10(v4, 255, a1 + 64);
                    aBlock[0] = MEMORY[0x1E69E9820];
                    aBlock[1] = 0x40000000;
                    aBlock[2] = ___ZL44nw_protocol_http3_stream_start_datagram_flowP24nw_protocol_http3_stream_block_invoke;
                    aBlock[3] = &__block_descriptor_tmp_83_63738;
                    aBlock[4] = a1;
                    if (v11)
                    {
                      v12 = v11;
                      _nw_array_apply(v11, aBlock);
                      os_release(v12);
                    }
                  }
                }

LABEL_17:
                if ((*(a1 + 732) & 0x2000) == 0 && gLogDatapath == 1)
                {
                  v29 = __nwlog_obj();
                  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
                  {
                    v30 = *(*(a1 + 344) + 1304);
                    v31 = *(a1 + 240);
                    v32 = *(a1 + 248);
                    *buf = 136447490;
                    v60 = "nw_protocol_http3_stream_start_datagram_flow";
                    v61 = 2082;
                    v62 = (a1 + 632);
                    v63 = 2080;
                    v64 = " ";
                    v65 = 1024;
                    v66 = v30;
                    v67 = 2048;
                    v68 = v31;
                    v69 = 2048;
                    v70 = v32;
                    _os_log_impl(&dword_181A37000, v29, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> Opened datagram flow %llu", buf, 0x3Au);
                  }
                }

                return;
              }
            }

            __nwlog_obj();
            v20 = 0;
            goto LABEL_91;
          }

          if (!v41)
          {
            goto LABEL_87;
          }

          v44 = "invalid";
          if (v4 && v4[2])
          {
            v44 = v4[2];
          }

          *buf = 136446466;
          v60 = "nw_protocol_http3_stream_start_datagram_flow";
          v61 = 2082;
          v62 = v44;
          v39 = "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace";
        }

        else
        {
          v36 = __nwlog_obj();
          v37 = type;
          if (!os_log_type_enabled(v36, type))
          {
            goto LABEL_87;
          }

          v43 = "invalid";
          if (v4 && v4[2])
          {
            v43 = v4[2];
          }

          *buf = 136446466;
          v60 = "nw_protocol_http3_stream_start_datagram_flow";
          v61 = 2082;
          v62 = v43;
          v39 = "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded";
        }

        _os_log_impl(&dword_181A37000, v36, v37, v39, buf, 0x16u);
        goto LABEL_87;
      }

LABEL_60:
      __nwlog_obj();
      v4 = 0;
      v21 = 1;
      v22 = "invalid";
      goto LABEL_61;
    }

    __nwlog_obj();
    *buf = 136446210;
    v60 = "nw_http3_get_default_output_handler";
    v23 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (__nwlog_fault(v23, &type, &v57))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (!os_log_type_enabled(v24, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v60 = "nw_http3_get_default_output_handler";
        v26 = "%{public}s called with null http3";
        goto LABEL_57;
      }

      if (v57 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (!os_log_type_enabled(v24, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v60 = "nw_http3_get_default_output_handler";
        v26 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_57;
      }

      v33 = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v34 = os_log_type_enabled(v24, type);
      if (v33)
      {
        if (v34)
        {
          *buf = 136446466;
          v60 = "nw_http3_get_default_output_handler";
          v61 = 2082;
          v62 = v33;
          _os_log_impl(&dword_181A37000, v24, v25, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v33);
        goto LABEL_58;
      }

      if (v34)
      {
        *buf = 136446210;
        v60 = "nw_http3_get_default_output_handler";
        v26 = "%{public}s called with null http3, no backtrace";
LABEL_57:
        _os_log_impl(&dword_181A37000, v24, v25, v26, buf, 0xCu);
      }
    }

LABEL_58:
    if (v23)
    {
      free(v23);
    }

    goto LABEL_60;
  }
}

uint64_t ___ZL44nw_protocol_http3_stream_start_datagram_flowP24nw_protocol_http3_stream_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (nw_protocol_metadata_is_quic_stream(a3))
  {
    if (a3)
    {
      v5 = os_retain(a3);
    }

    else
    {
      v5 = 0;
    }

    *(*(a1 + 32) + 432) = v5;
    has_datagram_variant_flow_id = nw_quic_stream_get_has_datagram_variant_flow_id(a3);
    if (has_datagram_variant_flow_id)
    {
      *(*(a1 + 32) + 248) = nw_quic_stream_get_datagram_variant_flow_id(a3);
      has_datagram_variant_flow_id = nw_quic_stream_get_usable_datagram_frame_size(a3);
      v7 = *(a1 + 32);
    }

    else
    {
      v7 = *(a1 + 32);
      *(v7 + 248) = 0;
    }

    *(v7 + 620) = has_datagram_variant_flow_id;
  }

  return 1;
}

void ___ZN2nw4http22content_length_manager19set_inbound_messageEP20nw_protocol_metadata_block_invoke(uint64_t a1, char *__s)
{
  if (__s)
  {
    v3 = *(a1 + 32);
    v4 = strlen(__s);
    if (v4 >= 0x7FFFFFFFFFFFFFF8)
    {
      std::string::__throw_length_error[abi:nn200100]();
    }

    v5 = v4;
    if (v4 >= 0x17)
    {
      operator new();
    }

    *(&__dst.__r_.__value_.__s + 23) = v4;
    if (v4)
    {
      memcpy(&__dst, __s, v4);
    }

    __dst.__r_.__value_.__s.__data_[v5] = 0;
    *(v3 + 24) = std::stoull(&__dst, 0, 10);
    *(v3 + 32) = 1;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
}

uint64_t ___ZL32nw_http3_stream_send_section_ackP24nw_protocol_http3_stream_block_invoke(uint64_t a1, uint64_t a2)
{
  LODWORD(__n) = 0;
  v3 = nw_frame_unclaimed_bytes(a2, &__n);
  memcpy(v3, (*(a1 + 40) + *(*(*(a1 + 32) + 8) + 24) + 716), __n);
  *(*(*(a1 + 32) + 8) + 24) += __n;
  return 1;
}

uint64_t nw_http3_uni_stream_create_outbound(uint64_t a1, uint64_t a2, int a3)
{
  v17 = *MEMORY[0x1E69E9840];
  v6 = malloc_type_calloc(1uLL, 0x80uLL, 0xE7D6AC34uLL);
  v7 = v6;
  if (v6)
  {
    v6[6] = 0u;
    v6[7] = 0u;
    v6[4] = 0u;
    v6[5] = 0u;
    v6[2] = 0u;
    v6[3] = 0u;
    *v6 = 0u;
    v6[1] = 0u;
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    *&buf[4] = "nw_http3_uni_stream_create_outbound";
    *&buf[12] = 2048;
    *&buf[14] = 1;
    *&buf[22] = 2048;
    v16 = 128;
    v8 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v8);
    if (result || (free(v8), MEMORY[0x70] = 0u, MEMORY[0x60] = 0u, MEMORY[0x50] = 0u, MEMORY[0x40] = 0u, MEMORY[0x30] = 0u, MEMORY[0x20] = 0u, MEMORY[0x10] = 0u, MEMORY[0] = 0u, pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once), networkd_settings_init(), os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR), *buf = 136446210, *&buf[4] = "nw_http3_uni_stream_create_outbound", v10 = _os_log_send_and_compose_impl(), result = __nwlog_should_abort(v10), result))
    {
      __break(1u);
      return result;
    }

    free(v10);
  }

  if (gLogDatapath == 1)
  {
    v13 = __nwlog_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *buf = 136446466;
      *&buf[4] = "nw_http3_uni_stream_create_outbound";
      *&buf[12] = 2048;
      *&buf[14] = v7;
      _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_DEBUG, "%{public}s created uni_stream %p", buf, 0x16u);
    }
  }

  *buf = 0;
  *&buf[8] = buf;
  *&buf[16] = 0x2000000000;
  v16 = v7;
  aBlock[0] = MEMORY[0x1E69E9820];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZL35nw_http3_uni_stream_create_outboundP17nw_protocol_http322nw_http3_stream_type_tb_block_invoke;
  aBlock[3] = &unk_1E6A38B70;
  aBlock[4] = buf;
  *(v7 + 12) = _Block_copy(aBlock);
  _Block_object_dispose(buf, 8);
  *(v7 + 2) = &g_http3_uni_stream_protocol_identifier;
  if (nw_protocol_http3_uni_stream_get_callbacks(void)::onceToken != -1)
  {
    dispatch_once(&nw_protocol_http3_uni_stream_get_callbacks(void)::onceToken, &__block_literal_global_64_63818);
  }

  *(v7 + 3) = &nw_protocol_http3_uni_stream_get_callbacks(void)::protocol_callbacks;
  *(v7 + 5) = v7;
  v11 = *(v7 + 121);
  *(v7 + 8) = a2;
  *(v7 + 9) = a1;
  *(v7 + 120) = 0;
  if (a3)
  {
    v12 = 4;
  }

  else
  {
    v12 = 0;
  }

  *(v7 + 121) = v11 & 0xFB | v12 | 1;
  return v7;
}

uint64_t ___ZL35nw_http3_uni_stream_create_outboundP17nw_protocol_http322nw_http3_stream_type_tb_block_invoke(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    *(*(*(a1 + 32) + 8) + 24) = 0;
  }

  return *(*(*(a1 + 32) + 8) + 24);
}

double ___ZL42nw_protocol_http3_uni_stream_get_callbacksv_block_invoke()
{
  qword_1EA83FF88 = 0;
  *algn_1EA83FF81 = 0;
  strcpy(&g_http3_uni_stream_protocol_identifier, "http3-uni-stream");
  *&result = 0x100000004;
  qword_1EA83FF90 = 0x100000004;
  nw_protocol_http3_uni_stream_get_callbacks(void)::protocol_callbacks = nw_protocol_default_add_input_handler;
  qword_1EA83FE48 = nw_protocol_default_replace_input_handler;
  qword_1EA83FE40 = nw_protocol_default_remove_input_handler;
  qword_1EA83FE80 = nw_protocol_default_output_available;
  qword_1EA83FEF8 = nw_protocol_default_output_finished;
  qword_1EA83FF40 = nw_protocol_default_input_flush;
  qword_1EA83FF30 = nw_protocol_default_get_message_properties;
  qword_1EA83FEA0 = nw_protocol_default_link_state;
  qword_1EA83FEA8 = nw_protocol_default_get_parameters;
  qword_1EA83FEB8 = nw_protocol_default_get_local;
  qword_1EA83FEC0 = nw_protocol_default_get_remote;
  qword_1EA83FEB0 = nw_protocol_default_get_path;
  qword_1EA83FEE0 = nw_protocol_default_updated_path;
  qword_1EA83FF00 = nw_protocol_default_get_output_local;
  qword_1EA83FF08 = nw_protocol_default_get_output_interface;
  qword_1EA83FE50 = nw_protocol_default_connect;
  qword_1EA83FE58 = nw_protocol_default_disconnect;
  qword_1EA83FF38 = nw_protocol_default_reset;
  qword_1EA83FF10 = nw_protocol_default_waiting_for_output;
  qword_1EA83FF18 = nw_protocol_default_copy_info;
  qword_1EA83FEC8 = nw_protocol_default_register_notification;
  qword_1EA83FED0 = nw_protocol_default_unregister_notification;
  qword_1EA83FED8 = nw_protocol_default_notify;
  qword_1EA83FF20 = nw_protocol_default_add_listen_handler;
  qword_1EA83FF28 = nw_protocol_default_remove_listen_handler;
  qword_1EA83FE60 = nw_protocol_http3_uni_stream_connected;
  qword_1EA83FE68 = nw_protocol_http3_uni_stream_disconnected;
  qword_1EA83FE70 = nw_protocol_http3_uni_stream_error;
  qword_1EA83FEF0 = nw_protocol_http3_uni_stream_input_finished;
  qword_1EA83FE78 = nw_protocol_http3_uni_stream_input_available;
  qword_1EA83FE88 = nw_protocol_http3_uni_stream_get_input_frames;
  qword_1EA83FE90 = nw_protocol_http3_uni_stream_get_output_frames;
  qword_1EA83FE98 = nw_protocol_http3_uni_stream_finalize_output_frames;
  qword_1EA83FEE8 = nw_protocol_http3_uni_stream_supports_external_data;
  return result;
}

void nw_protocol_http3_uni_stream_input_available(nw_protocol *a1, nw_protocol *a2)
{
  v48 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if (gLogDatapath == 1)
      {
        v19 = a1->handle;
        v20 = __nwlog_obj();
        v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG);
        handle = v19;
        if (v21)
        {
          *buf = 136446466;
          v43 = "nw_protocol_http3_uni_stream_input_available";
          v44 = 2048;
          v45 = v19;
          _os_log_impl(&dword_181A37000, v20, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
          handle = v19;
        }
      }

      if ((handle[121] & 2) == 0)
      {
        return;
      }

      v3 = *(handle + 6);
      if (v3)
      {
        v4 = *(v3 + 24);
        if (v4)
        {
          v5 = *(v4 + 64);
          if (v5)
          {
            v5();
            return;
          }
        }
      }

      v6 = handle;
      __nwlog_obj();
      v7 = *(v6 + 6);
      v8 = "invalid";
      if (v7)
      {
        v9 = *(v7 + 16);
        if (v9)
        {
          v8 = v9;
        }
      }

      *buf = 136446466;
      v43 = "nw_protocol_http3_uni_stream_input_available";
      v44 = 2082;
      v45 = v8;
      v10 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v40 = 0;
      if (!__nwlog_fault(v10, &type, &v40))
      {
        goto LABEL_70;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
        {
          goto LABEL_70;
        }

        v13 = *(v6 + 6);
        v14 = "invalid";
        if (v13)
        {
          v15 = *(v13 + 16);
          if (v15)
          {
            v14 = v15;
          }
        }

        *buf = 136446466;
        v43 = "nw_protocol_http3_uni_stream_input_available";
        v44 = 2082;
        v45 = v14;
        v16 = "%{public}s protocol %{public}s has invalid input_available callback";
      }

      else if (v40 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v11 = __nwlog_obj();
        v12 = type;
        v23 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v23)
          {
            v24 = *(v6 + 6);
            v25 = "invalid";
            if (v24)
            {
              v26 = *(v24 + 16);
              if (v26)
              {
                v25 = v26;
              }
            }

            *buf = 136446722;
            v43 = "nw_protocol_http3_uni_stream_input_available";
            v44 = 2082;
            v45 = v25;
            v46 = 2082;
            v47 = backtrace_string;
            _os_log_impl(&dword_181A37000, v11, v12, "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
LABEL_70:
          if (v10)
          {
            goto LABEL_71;
          }

          return;
        }

        if (!v23)
        {
          goto LABEL_70;
        }

        v34 = *(v6 + 6);
        v35 = "invalid";
        if (v34)
        {
          v36 = *(v34 + 16);
          if (v36)
          {
            v35 = v36;
          }
        }

        *buf = 136446466;
        v43 = "nw_protocol_http3_uni_stream_input_available";
        v44 = 2082;
        v45 = v35;
        v16 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
      }

      else
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
        {
          goto LABEL_70;
        }

        v31 = *(v6 + 6);
        v32 = "invalid";
        if (v31)
        {
          v33 = *(v31 + 16);
          if (v33)
          {
            v32 = v33;
          }
        }

        *buf = 136446466;
        v43 = "nw_protocol_http3_uni_stream_input_available";
        v44 = 2082;
        v45 = v32;
        v16 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
      }

      v37 = v11;
      v38 = v12;
      v39 = 22;
LABEL_69:
      _os_log_impl(&dword_181A37000, v37, v38, v16, buf, v39);
      goto LABEL_70;
    }

    __nwlog_obj();
    *buf = 136446210;
    v43 = "nw_protocol_http3_uni_stream_input_available";
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v10, &type, &v40))
    {
      goto LABEL_70;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v43 = "nw_protocol_http3_uni_stream_input_available";
      v16 = "%{public}s called with null http3_stream";
      goto LABEL_68;
    }

    if (v40 != 1)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v43 = "nw_protocol_http3_uni_stream_input_available";
      v16 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_68;
    }

    v27 = __nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v30 = os_log_type_enabled(v17, type);
    if (!v27)
    {
      if (!v30)
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v43 = "nw_protocol_http3_uni_stream_input_available";
      v16 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_68;
    }

    if (v30)
    {
      *buf = 136446466;
      v43 = "nw_protocol_http3_uni_stream_input_available";
      v44 = 2082;
      v45 = v27;
      v29 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_46;
    }
  }

  else
  {
    __nwlog_obj();
    *buf = 136446210;
    v43 = "nw_protocol_http3_uni_stream_input_available";
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v10, &type, &v40))
    {
      goto LABEL_70;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v43 = "nw_protocol_http3_uni_stream_input_available";
      v16 = "%{public}s called with null protocol";
LABEL_68:
      v37 = v17;
      v38 = v18;
      v39 = 12;
      goto LABEL_69;
    }

    if (v40 != 1)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v43 = "nw_protocol_http3_uni_stream_input_available";
      v16 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_68;
    }

    v27 = __nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v28 = os_log_type_enabled(v17, type);
    if (!v27)
    {
      if (!v28)
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v43 = "nw_protocol_http3_uni_stream_input_available";
      v16 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_68;
    }

    if (v28)
    {
      *buf = 136446466;
      v43 = "nw_protocol_http3_uni_stream_input_available";
      v44 = 2082;
      v45 = v27;
      v29 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_46:
      _os_log_impl(&dword_181A37000, v17, v18, v29, buf, 0x16u);
    }
  }

  free(v27);
  if (v10)
  {
LABEL_71:
    free(v10);
  }
}

void nw_protocol_http3_uni_stream_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  v45 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if (gLogDatapath == 1)
      {
        v18 = __nwlog_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *buf = 136446466;
          v40 = "nw_protocol_http3_uni_stream_input_finished";
          v41 = 2048;
          v42 = handle;
          _os_log_impl(&dword_181A37000, v18, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
        }
      }

      if ((handle[121] & 2) == 0)
      {
        return;
      }

      v3 = *(handle + 6);
      if (v3)
      {
        v4 = *(v3 + 24);
        if (v4)
        {
          v5 = *(v4 + 184);
          if (v5)
          {
            v5();
            return;
          }
        }
      }

      __nwlog_obj();
      v6 = *(handle + 6);
      v7 = "invalid";
      if (v6)
      {
        v8 = *(v6 + 16);
        if (v8)
        {
          v7 = v8;
        }
      }

      *buf = 136446466;
      v40 = "nw_protocol_http3_uni_stream_input_finished";
      v41 = 2082;
      v42 = v7;
      v9 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v37 = 0;
      if (!__nwlog_fault(v9, &type, &v37))
      {
        goto LABEL_70;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v10 = __nwlog_obj();
        v11 = type;
        if (!os_log_type_enabled(v10, type))
        {
          goto LABEL_70;
        }

        v12 = *(handle + 6);
        v13 = "invalid";
        if (v12)
        {
          v14 = *(v12 + 16);
          if (v14)
          {
            v13 = v14;
          }
        }

        *buf = 136446466;
        v40 = "nw_protocol_http3_uni_stream_input_finished";
        v41 = 2082;
        v42 = v13;
        v15 = "%{public}s protocol %{public}s has invalid input_finished callback";
      }

      else if (v37 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v10 = __nwlog_obj();
        v11 = type;
        v20 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v20)
          {
            v21 = *(handle + 6);
            v22 = "invalid";
            if (v21)
            {
              v23 = *(v21 + 16);
              if (v23)
              {
                v22 = v23;
              }
            }

            *buf = 136446722;
            v40 = "nw_protocol_http3_uni_stream_input_finished";
            v41 = 2082;
            v42 = v22;
            v43 = 2082;
            v44 = backtrace_string;
            _os_log_impl(&dword_181A37000, v10, v11, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
LABEL_70:
          if (v9)
          {
            goto LABEL_71;
          }

          return;
        }

        if (!v20)
        {
          goto LABEL_70;
        }

        v31 = *(handle + 6);
        v32 = "invalid";
        if (v31)
        {
          v33 = *(v31 + 16);
          if (v33)
          {
            v32 = v33;
          }
        }

        *buf = 136446466;
        v40 = "nw_protocol_http3_uni_stream_input_finished";
        v41 = 2082;
        v42 = v32;
        v15 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
      }

      else
      {
        v10 = __nwlog_obj();
        v11 = type;
        if (!os_log_type_enabled(v10, type))
        {
          goto LABEL_70;
        }

        v28 = *(handle + 6);
        v29 = "invalid";
        if (v28)
        {
          v30 = *(v28 + 16);
          if (v30)
          {
            v29 = v30;
          }
        }

        *buf = 136446466;
        v40 = "nw_protocol_http3_uni_stream_input_finished";
        v41 = 2082;
        v42 = v29;
        v15 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
      }

      v34 = v10;
      v35 = v11;
      v36 = 22;
LABEL_69:
      _os_log_impl(&dword_181A37000, v34, v35, v15, buf, v36);
      goto LABEL_70;
    }

    __nwlog_obj();
    *buf = 136446210;
    v40 = "nw_protocol_http3_uni_stream_input_finished";
    v9 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v9, &type, &v37))
    {
      goto LABEL_70;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_input_finished";
      v15 = "%{public}s called with null http3_stream";
      goto LABEL_68;
    }

    if (v37 != 1)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_input_finished";
      v15 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_68;
    }

    v24 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v27 = os_log_type_enabled(v16, type);
    if (!v24)
    {
      if (!v27)
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_input_finished";
      v15 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_68;
    }

    if (v27)
    {
      *buf = 136446466;
      v40 = "nw_protocol_http3_uni_stream_input_finished";
      v41 = 2082;
      v42 = v24;
      v26 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_46;
    }
  }

  else
  {
    __nwlog_obj();
    *buf = 136446210;
    v40 = "nw_protocol_http3_uni_stream_input_finished";
    v9 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v9, &type, &v37))
    {
      goto LABEL_70;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_input_finished";
      v15 = "%{public}s called with null protocol";
LABEL_68:
      v34 = v16;
      v35 = v17;
      v36 = 12;
      goto LABEL_69;
    }

    if (v37 != 1)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_input_finished";
      v15 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_68;
    }

    v24 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v25 = os_log_type_enabled(v16, type);
    if (!v24)
    {
      if (!v25)
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_input_finished";
      v15 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_68;
    }

    if (v25)
    {
      *buf = 136446466;
      v40 = "nw_protocol_http3_uni_stream_input_finished";
      v41 = 2082;
      v42 = v24;
      v26 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_46:
      _os_log_impl(&dword_181A37000, v16, v17, v26, buf, 0x16u);
    }
  }

  free(v24);
  if (v9)
  {
LABEL_71:
    free(v9);
  }
}

void nw_protocol_http3_uni_stream_error(nw_protocol *a1, nw_protocol *a2)
{
  v45 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if (gLogDatapath == 1)
      {
        v18 = __nwlog_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *buf = 136446466;
          v40 = "nw_protocol_http3_uni_stream_error";
          v41 = 2048;
          v42 = handle;
          _os_log_impl(&dword_181A37000, v18, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
        }
      }

      if ((handle[121] & 3) == 0)
      {
        return;
      }

      v3 = *(handle + 6);
      if (v3)
      {
        v4 = *(v3 + 24);
        if (v4)
        {
          v5 = *(v4 + 56);
          if (v5)
          {
            v5();
            return;
          }
        }
      }

      __nwlog_obj();
      v6 = *(handle + 6);
      v7 = "invalid";
      if (v6)
      {
        v8 = *(v6 + 16);
        if (v8)
        {
          v7 = v8;
        }
      }

      *buf = 136446466;
      v40 = "nw_protocol_http3_uni_stream_error";
      v41 = 2082;
      v42 = v7;
      v9 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v37 = 0;
      if (!__nwlog_fault(v9, &type, &v37))
      {
        goto LABEL_70;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v10 = __nwlog_obj();
        v11 = type;
        if (!os_log_type_enabled(v10, type))
        {
          goto LABEL_70;
        }

        v12 = *(handle + 6);
        v13 = "invalid";
        if (v12)
        {
          v14 = *(v12 + 16);
          if (v14)
          {
            v13 = v14;
          }
        }

        *buf = 136446466;
        v40 = "nw_protocol_http3_uni_stream_error";
        v41 = 2082;
        v42 = v13;
        v15 = "%{public}s protocol %{public}s has invalid error callback";
      }

      else if (v37 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v10 = __nwlog_obj();
        v11 = type;
        v20 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v20)
          {
            v21 = *(handle + 6);
            v22 = "invalid";
            if (v21)
            {
              v23 = *(v21 + 16);
              if (v23)
              {
                v22 = v23;
              }
            }

            *buf = 136446722;
            v40 = "nw_protocol_http3_uni_stream_error";
            v41 = 2082;
            v42 = v22;
            v43 = 2082;
            v44 = backtrace_string;
            _os_log_impl(&dword_181A37000, v10, v11, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
LABEL_70:
          if (v9)
          {
            goto LABEL_71;
          }

          return;
        }

        if (!v20)
        {
          goto LABEL_70;
        }

        v31 = *(handle + 6);
        v32 = "invalid";
        if (v31)
        {
          v33 = *(v31 + 16);
          if (v33)
          {
            v32 = v33;
          }
        }

        *buf = 136446466;
        v40 = "nw_protocol_http3_uni_stream_error";
        v41 = 2082;
        v42 = v32;
        v15 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
      }

      else
      {
        v10 = __nwlog_obj();
        v11 = type;
        if (!os_log_type_enabled(v10, type))
        {
          goto LABEL_70;
        }

        v28 = *(handle + 6);
        v29 = "invalid";
        if (v28)
        {
          v30 = *(v28 + 16);
          if (v30)
          {
            v29 = v30;
          }
        }

        *buf = 136446466;
        v40 = "nw_protocol_http3_uni_stream_error";
        v41 = 2082;
        v42 = v29;
        v15 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
      }

      v34 = v10;
      v35 = v11;
      v36 = 22;
LABEL_69:
      _os_log_impl(&dword_181A37000, v34, v35, v15, buf, v36);
      goto LABEL_70;
    }

    __nwlog_obj();
    *buf = 136446210;
    v40 = "nw_protocol_http3_uni_stream_error";
    v9 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v9, &type, &v37))
    {
      goto LABEL_70;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_error";
      v15 = "%{public}s called with null http3_stream";
      goto LABEL_68;
    }

    if (v37 != 1)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_error";
      v15 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_68;
    }

    v24 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v27 = os_log_type_enabled(v16, type);
    if (!v24)
    {
      if (!v27)
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_error";
      v15 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_68;
    }

    if (v27)
    {
      *buf = 136446466;
      v40 = "nw_protocol_http3_uni_stream_error";
      v41 = 2082;
      v42 = v24;
      v26 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_46;
    }
  }

  else
  {
    __nwlog_obj();
    *buf = 136446210;
    v40 = "nw_protocol_http3_uni_stream_error";
    v9 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v9, &type, &v37))
    {
      goto LABEL_70;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_error";
      v15 = "%{public}s called with null protocol";
LABEL_68:
      v34 = v16;
      v35 = v17;
      v36 = 12;
      goto LABEL_69;
    }

    if (v37 != 1)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_error";
      v15 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_68;
    }

    v24 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v25 = os_log_type_enabled(v16, type);
    if (!v24)
    {
      if (!v25)
      {
        goto LABEL_70;
      }

      *buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_error";
      v15 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_68;
    }

    if (v25)
    {
      *buf = 136446466;
      v40 = "nw_protocol_http3_uni_stream_error";
      v41 = 2082;
      v42 = v24;
      v26 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_46:
      _os_log_impl(&dword_181A37000, v16, v17, v26, buf, 0x16u);
    }
  }

  free(v24);
  if (v9)
  {
LABEL_71:
    free(v9);
  }
}

void nw_protocol_http3_uni_stream_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  v49 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v44 = "nw_protocol_http3_uni_stream_disconnected";
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v10, &type, &v41))
    {
      goto LABEL_85;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
      {
        goto LABEL_85;
      }

      *buf = 136446210;
      v44 = "nw_protocol_http3_uni_stream_disconnected";
      v16 = "%{public}s called with null protocol";
LABEL_83:
      v38 = v22;
      v39 = v23;
      v40 = 12;
      goto LABEL_84;
    }

    if (v41 != 1)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
      {
        goto LABEL_85;
      }

      *buf = 136446210;
      v44 = "nw_protocol_http3_uni_stream_disconnected";
      v16 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_83;
    }

    backtrace_string = __nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type;
    v31 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (!v31)
      {
        goto LABEL_85;
      }

      *buf = 136446210;
      v44 = "nw_protocol_http3_uni_stream_disconnected";
      v16 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_83;
    }

    if (!v31)
    {
      goto LABEL_63;
    }

    *buf = 136446466;
    v44 = "nw_protocol_http3_uni_stream_disconnected";
    v45 = 2082;
    v46 = backtrace_string;
    v32 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_62:
    _os_log_impl(&dword_181A37000, v22, v23, v32, buf, 0x16u);
    goto LABEL_63;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v44 = "nw_protocol_http3_uni_stream_disconnected";
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v10, &type, &v41))
    {
      goto LABEL_85;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
      {
        goto LABEL_85;
      }

      *buf = 136446210;
      v44 = "nw_protocol_http3_uni_stream_disconnected";
      v16 = "%{public}s called with null http3_stream";
      goto LABEL_83;
    }

    if (v41 != 1)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
      {
        goto LABEL_85;
      }

      *buf = 136446210;
      v44 = "nw_protocol_http3_uni_stream_disconnected";
      v16 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_83;
    }

    backtrace_string = __nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type;
    v33 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (!v33)
      {
        goto LABEL_85;
      }

      *buf = 136446210;
      v44 = "nw_protocol_http3_uni_stream_disconnected";
      v16 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_83;
    }

    if (!v33)
    {
      goto LABEL_63;
    }

    *buf = 136446466;
    v44 = "nw_protocol_http3_uni_stream_disconnected";
    v45 = 2082;
    v46 = backtrace_string;
    v32 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
    goto LABEL_62;
  }

  if (*(handle + 9))
  {
    if (gLogDatapath == 1)
    {
      v24 = a1->handle;
      v25 = __nwlog_obj();
      v26 = os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG);
      handle = v24;
      if (v26)
      {
        *buf = 136446466;
        v44 = "nw_protocol_http3_uni_stream_disconnected";
        v45 = 2048;
        v46 = v24;
        _os_log_impl(&dword_181A37000, v25, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
        handle = v24;
      }
    }

    if ((handle[121] & 1) == 0)
    {
      if ((handle[121] & 2) == 0)
      {
        return;
      }

      handle[121] &= 0xFCu;
    }

    v3 = *(handle + 6);
    if (v3)
    {
      v4 = *(v3 + 24);
      if (v4)
      {
        v5 = *(v4 + 48);
        if (v5)
        {
          v5();
          return;
        }
      }
    }

    v6 = handle;
    __nwlog_obj();
    v7 = *(v6 + 6);
    v8 = "invalid";
    if (v7)
    {
      v9 = *(v7 + 16);
      if (v9)
      {
        v8 = v9;
      }
    }

    *buf = 136446466;
    v44 = "nw_protocol_http3_uni_stream_disconnected";
    v45 = 2082;
    v46 = v8;
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (__nwlog_fault(v10, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
        {
          goto LABEL_85;
        }

        v13 = *(v6 + 6);
        v14 = "invalid";
        if (v13)
        {
          v15 = *(v13 + 16);
          if (v15)
          {
            v14 = v15;
          }
        }

        *buf = 136446466;
        v44 = "nw_protocol_http3_uni_stream_disconnected";
        v45 = 2082;
        v46 = v14;
        v16 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_76:
        v38 = v11;
        v39 = v12;
        v40 = 22;
LABEL_84:
        _os_log_impl(&dword_181A37000, v38, v39, v16, buf, v40);
        goto LABEL_85;
      }

      if (v41 != 1)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
        {
          goto LABEL_85;
        }

        v27 = *(v6 + 6);
        v28 = "invalid";
        if (v27)
        {
          v29 = *(v27 + 16);
          if (v29)
          {
            v28 = v29;
          }
        }

        *buf = 136446466;
        v44 = "nw_protocol_http3_uni_stream_disconnected";
        v45 = 2082;
        v46 = v28;
        v16 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        goto LABEL_76;
      }

      v17 = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v18 = os_log_type_enabled(v11, type);
      if (!v17)
      {
        if (!v18)
        {
          goto LABEL_85;
        }

        v35 = *(v6 + 6);
        v36 = "invalid";
        if (v35)
        {
          v37 = *(v35 + 16);
          if (v37)
          {
            v36 = v37;
          }
        }

        *buf = 136446466;
        v44 = "nw_protocol_http3_uni_stream_disconnected";
        v45 = 2082;
        v46 = v36;
        v16 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
        goto LABEL_76;
      }

      if (v18)
      {
        v19 = *(v6 + 6);
        v20 = "invalid";
        if (v19)
        {
          v21 = *(v19 + 16);
          if (v21)
          {
            v20 = v21;
          }
        }

        *buf = 136446722;
        v44 = "nw_protocol_http3_uni_stream_disconnected";
        v45 = 2082;
        v46 = v20;
        v47 = 2082;
        v48 = v17;
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
      }

      free(v17);
    }

LABEL_85:
    if (v10)
    {
      goto LABEL_86;
    }

    return;
  }

  __nwlog_obj();
  *buf = 136446210;
  v44 = "nw_protocol_http3_uni_stream_disconnected";
  v10 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v41 = 0;
  if (!__nwlog_fault(v10, &type, &v41))
  {
    goto LABEL_85;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
    {
      goto LABEL_85;
    }

    *buf = 136446210;
    v44 = "nw_protocol_http3_uni_stream_disconnected";
    v16 = "%{public}s called with null http3_stream->http3_connection";
    goto LABEL_83;
  }

  if (v41 != 1)
  {
    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
    {
      goto LABEL_85;
    }

    *buf = 136446210;
    v44 = "nw_protocol_http3_uni_stream_disconnected";
    v16 = "%{public}s called with null http3_stream->http3_connection, backtrace limit exceeded";
    goto LABEL_83;
  }

  backtrace_string = __nw_create_backtrace_string();
  v22 = __nwlog_obj();
  v23 = type;
  v34 = os_log_type_enabled(v22, type);
  if (!backtrace_string)
  {
    if (!v34)
    {
      goto LABEL_85;
    }

    *buf = 136446210;
    v44 = "nw_protocol_http3_uni_stream_disconnected";
    v16 = "%{public}s called with null http3_stream->http3_connection, no backtrace";
    goto LABEL_83;
  }

  if (v34)
  {
    *buf = 136446466;
    v44 = "nw_protocol_http3_uni_stream_disconnected";
    v45 = 2082;
    v46 = backtrace_string;
    v32 = "%{public}s called with null http3_stream->http3_connection, dumping backtrace:%{public}s";
    goto LABEL_62;
  }

LABEL_63:
  free(backtrace_string);
  if (v10)
  {
LABEL_86:
    free(v10);
  }
}

void nw_protocol_http3_uni_stream_connected(nw_protocol *a1, nw_protocol *a2)
{
  v57 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v52 = "nw_protocol_http3_uni_stream_connected";
    v26 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v49 = 0;
    if (!__nwlog_fault(v26, &type, &v49))
    {
      goto LABEL_89;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
      {
        goto LABEL_89;
      }

      *buf = 136446210;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v29 = "%{public}s called with null protocol";
      goto LABEL_88;
    }

    if (v49 != 1)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
      {
        goto LABEL_89;
      }

      *buf = 136446210;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v29 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_88;
    }

    backtrace_string = __nw_create_backtrace_string();
    v27 = __nwlog_obj();
    v28 = type;
    v39 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (!v39)
      {
        goto LABEL_89;
      }

      *buf = 136446210;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v29 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_88;
    }

    if (v39)
    {
      *buf = 136446466;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v53 = 2082;
      v54 = backtrace_string;
      _os_log_impl(&dword_181A37000, v27, v28, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
LABEL_89:
    if (!v26)
    {
      return;
    }

    goto LABEL_90;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v52 = "nw_protocol_http3_uni_stream_connected";
    v26 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v49 = 0;
    if (!__nwlog_fault(v26, &type, &v49))
    {
      goto LABEL_89;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
      {
        goto LABEL_89;
      }

      *buf = 136446210;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v29 = "%{public}s called with null http3_stream";
      goto LABEL_88;
    }

    if (v49 != 1)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
      {
        goto LABEL_89;
      }

      *buf = 136446210;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v29 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_88;
    }

    v40 = __nw_create_backtrace_string();
    v27 = __nwlog_obj();
    v28 = type;
    v41 = os_log_type_enabled(v27, type);
    if (v40)
    {
      if (v41)
      {
        *buf = 136446466;
        v52 = "nw_protocol_http3_uni_stream_connected";
        v53 = 2082;
        v54 = v40;
        _os_log_impl(&dword_181A37000, v27, v28, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v40);
      if (!v26)
      {
        return;
      }

LABEL_90:
      v48 = v26;
      goto LABEL_91;
    }

    if (v41)
    {
      *buf = 136446210;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v29 = "%{public}s called with null http3_stream, no backtrace";
LABEL_88:
      _os_log_impl(&dword_181A37000, v27, v28, v29, buf, 0xCu);
      goto LABEL_89;
    }

    goto LABEL_89;
  }

  if (gLogDatapath == 1)
  {
    v30 = a2;
    v31 = __nwlog_obj();
    v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG);
    a2 = v30;
    if (v32)
    {
      *buf = 136446466;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v53 = 2048;
      v54 = handle;
      _os_log_impl(&dword_181A37000, v31, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
      a2 = v30;
    }
  }

  if (handle[4] != a2)
  {
    return;
  }

  if ((*(handle + 121) & 2) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v52 = "nw_protocol_http3_uni_stream_connected";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v49 = 0;
    if (!__nwlog_fault(v3, &type, &v49))
    {
      goto LABEL_19;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      v5 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_19;
      }

      *buf = 136446210;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v6 = "%{public}s Received connected on inbound uni stream";
    }

    else
    {
      if (v49 == 1)
      {
        v7 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        v10 = os_log_type_enabled(gLogObj, type);
        if (v7)
        {
          if (v10)
          {
            *buf = 136446466;
            v52 = "nw_protocol_http3_uni_stream_connected";
            v53 = 2082;
            v54 = v7;
            _os_log_impl(&dword_181A37000, v8, v9, "%{public}s Received connected on inbound uni stream, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v7);
          goto LABEL_19;
        }

        if (!v10)
        {
LABEL_19:
          if (v3)
          {
            free(v3);
          }

          goto LABEL_21;
        }

        *buf = 136446210;
        v52 = "nw_protocol_http3_uni_stream_connected";
        v6 = "%{public}s Received connected on inbound uni stream, no backtrace";
        v11 = v8;
        v12 = v9;
LABEL_18:
        _os_log_impl(&dword_181A37000, v11, v12, v6, buf, 0xCu);
        goto LABEL_19;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      v5 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_19;
      }

      *buf = 136446210;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v6 = "%{public}s Received connected on inbound uni stream, backtrace limit exceeded";
    }

    v11 = v4;
    v12 = v5;
    goto LABEL_18;
  }

LABEL_21:
  v13 = handle[6];
  if (v13)
  {
    callbacks = v13->callbacks;
    if (callbacks)
    {
      connected = callbacks->connected;
      if (connected)
      {
        connected(v13, handle);
        return;
      }
    }
  }

  __nwlog_obj();
  v16 = handle[6];
  v17 = "invalid";
  if (v16)
  {
    name = v16->identifier->name;
    if (name)
    {
      v17 = name;
    }
  }

  *buf = 136446466;
  v52 = "nw_protocol_http3_uni_stream_connected";
  v53 = 2082;
  v54 = v17;
  v19 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v49 = 0;
  if (__nwlog_fault(v19, &type, &v49))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
      {
        goto LABEL_82;
      }

      v22 = handle[6];
      v23 = "invalid";
      if (v22)
      {
        v24 = v22->identifier->name;
        if (v24)
        {
          v23 = v24;
        }
      }

      *buf = 136446466;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v53 = 2082;
      v54 = v23;
      v25 = "%{public}s protocol %{public}s has invalid connected callback";
LABEL_81:
      _os_log_impl(&dword_181A37000, v20, v21, v25, buf, 0x16u);
      goto LABEL_82;
    }

    if (v49 != 1)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
      {
        goto LABEL_82;
      }

      v42 = handle[6];
      v43 = "invalid";
      if (v42)
      {
        v44 = v42->identifier->name;
        if (v44)
        {
          v43 = v44;
        }
      }

      *buf = 136446466;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v53 = 2082;
      v54 = v43;
      v25 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
      goto LABEL_81;
    }

    v33 = __nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v21 = type;
    v34 = os_log_type_enabled(v20, type);
    if (!v33)
    {
      if (!v34)
      {
        goto LABEL_82;
      }

      v45 = handle[6];
      v46 = "invalid";
      if (v45)
      {
        v47 = v45->identifier->name;
        if (v47)
        {
          v46 = v47;
        }
      }

      *buf = 136446466;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v53 = 2082;
      v54 = v46;
      v25 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
      goto LABEL_81;
    }

    if (v34)
    {
      v35 = handle[6];
      v36 = "invalid";
      if (v35)
      {
        v37 = v35->identifier->name;
        if (v37)
        {
          v36 = v37;
        }
      }

      *buf = 136446722;
      v52 = "nw_protocol_http3_uni_stream_connected";
      v53 = 2082;
      v54 = v36;
      v55 = 2082;
      v56 = v33;
      _os_log_impl(&dword_181A37000, v20, v21, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
    }

    free(v33);
  }

LABEL_82:
  if (v19)
  {
    v48 = v19;
LABEL_91:
    free(v48);
  }
}

void ___ZL37nw_http3_control_stream_process_inputP17nw_protocol_http3_block_invoke_2(uint64_t a1)
{
  (*(*(a1 + 32) + 16))();
  v2 = *(*(*(a1 + 40) + 8) + 24);
  if (v2)
  {
    dispatch_release(v2);
    *(*(*(a1 + 40) + 8) + 24) = 0;
  }
}

void nw_http3_notify_do_not_reuse(uint64_t a1)
{
  v40 = *MEMORY[0x1E69E9840];
  v1 = *(a1 + 888);
  if (v1)
  {
    v3 = (a1 + 1313);
    do
    {
      v4 = v1;
      v1 = *(v1 + 536);
      if ((*(v4 + 734) & 2) != 0)
      {
        if ((*(a1 + 1399) & 0x20) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v5 = gLogObj;
          if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_INFO))
          {
            v6 = *(a1 + 1304);
            v7 = *(v4 + 240);
            *buf = 136447234;
            v31 = "nw_http3_notify_do_not_reuse";
            v32 = 2082;
            v33 = v3;
            v34 = 2080;
            v35 = " ";
            v36 = 1024;
            v37 = v6;
            v38 = 2048;
            v39 = v7;
            _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Notifying stream %llu to not reuse the connection", buf, 0x30u);
          }
        }

        v8 = *(v4 + 24);
        if (!v8 || (v9 = *(v8 + 160)) == 0)
        {
          __nwlog_obj();
          v10 = *(v4 + 16);
          if (!v10)
          {
            v10 = "invalid";
          }

          *buf = 136446466;
          v31 = "nw_http3_notify_do_not_reuse";
          v32 = 2082;
          v33 = v10;
          v11 = _os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v28 = 0;
          v27 = v11;
          if (!__nwlog_fault(v11, &type, &v28))
          {
            goto LABEL_35;
          }

          if (type == OS_LOG_TYPE_FAULT)
          {
            v12 = __nwlog_obj();
            v24 = type;
            if (os_log_type_enabled(v12, type))
            {
              v13 = *(v4 + 16);
              if (!v13)
              {
                v13 = "invalid";
              }

              *buf = 136446466;
              v31 = "nw_http3_notify_do_not_reuse";
              v32 = 2082;
              v33 = v13;
              v14 = v12;
              v15 = v24;
              v16 = "%{public}s protocol %{public}s has invalid notify callback";
              goto LABEL_34;
            }

            goto LABEL_35;
          }

          if (v28 == 1)
          {
            backtrace_string = __nw_create_backtrace_string();
            log = __nwlog_obj();
            v25 = type;
            v18 = os_log_type_enabled(log, type);
            if (backtrace_string)
            {
              if (v18)
              {
                v19 = *(v4 + 16);
                if (!v19)
                {
                  v19 = "invalid";
                }

                *buf = 136446722;
                v31 = "nw_http3_notify_do_not_reuse";
                v32 = 2082;
                v33 = v19;
                v34 = 2082;
                v35 = backtrace_string;
                _os_log_impl(&dword_181A37000, log, v25, "%{public}s protocol %{public}s has invalid notify callback, dumping backtrace:%{public}s", buf, 0x20u);
              }

              free(backtrace_string);
              goto LABEL_35;
            }

            if (!v18)
            {
LABEL_35:
              if (v27)
              {
                free(v27);
              }

              continue;
            }

            v22 = *(v4 + 16);
            if (!v22)
            {
              v22 = "invalid";
            }

            *buf = 136446466;
            v31 = "nw_http3_notify_do_not_reuse";
            v32 = 2082;
            v33 = v22;
            v14 = log;
            v15 = v25;
            v16 = "%{public}s protocol %{public}s has invalid notify callback, no backtrace";
          }

          else
          {
            v20 = __nwlog_obj();
            v26 = type;
            if (!os_log_type_enabled(v20, type))
            {
              goto LABEL_35;
            }

            v21 = *(v4 + 16);
            if (!v21)
            {
              v21 = "invalid";
            }

            *buf = 136446466;
            v31 = "nw_http3_notify_do_not_reuse";
            v32 = 2082;
            v33 = v21;
            v14 = v20;
            v15 = v26;
            v16 = "%{public}s protocol %{public}s has invalid notify callback, backtrace limit exceeded";
          }

LABEL_34:
          _os_log_impl(&dword_181A37000, v14, v15, v16, buf, 0x16u);
          goto LABEL_35;
        }

        v9(v4, v4, 12, 0, 0);
      }
    }

    while (v1);
  }
}

uint64_t ___ZL37nw_http3_control_stream_process_inputP17nw_protocol_http3_block_invoke_169(void *a1, uint64_t a2)
{
  v4 = (*(a1[4] + 8) + 48);
  v5 = *(a2 + 32);
  v6 = *(a2 + 40);
  if (v5)
  {
    v4 = (v5 + 40);
  }

  *v4 = v6;
  *v6 = v5;
  *(a2 + 32) = 0;
  *(a2 + 40) = 0;
  LODWORD(__n) = 0;
  v7 = nw_frame_unclaimed_bytes(a2, &__n);
  memcpy((a1[6] + *(*(a1[5] + 8) + 24)), v7, __n);
  *(*(a1[5] + 8) + 24) += __n;
  nw_frame_finalize(a2);
  return 1;
}

void nw_http3_start_encoder_stream_if_needed(void *a1)
{
  v38 = *MEMORY[0x1E69E9840];
  if (!a1[134])
  {
    outbound = nw_http3_uni_stream_create_outbound(a1, 2, 1);
    a1[134] = outbound;
    *outbound = *a1;
    nw_protocol_set_input_handler(a1[134], a1);
    v3 = a1[4];
    if (v3)
    {
      v4 = *(v3 + 24);
      if (v4)
      {
        v5 = *v4;
        if (v5)
        {
          v5(a1[4], a1[134]);
          goto LABEL_6;
        }
      }

      __nwlog_obj();
      v8 = *(v3 + 16);
      if (!v8)
      {
        v8 = "invalid";
      }
    }

    else
    {
      __nwlog_obj();
      v8 = "invalid";
    }

    *buf = 136446466;
    v33 = "nw_http3_start_encoder_stream_if_needed";
    v34 = 2082;
    v35 = v8;
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v10, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
        {
          goto LABEL_43;
        }

        v13 = "invalid";
        if (v3 && *(v3 + 16))
        {
          v13 = *(v3 + 16);
        }

        *buf = 136446466;
        v33 = "nw_http3_start_encoder_stream_if_needed";
        v34 = 2082;
        v35 = v13;
        v14 = "%{public}s protocol %{public}s has invalid add_input_handler callback";
LABEL_42:
        _os_log_impl(&dword_181A37000, v11, v12, v14, buf, 0x16u);
        goto LABEL_43;
      }

      if (v30 != 1)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
        {
          goto LABEL_43;
        }

        v18 = "invalid";
        if (v3 && *(v3 + 16))
        {
          v18 = *(v3 + 16);
        }

        *buf = 136446466;
        v33 = "nw_http3_start_encoder_stream_if_needed";
        v34 = 2082;
        v35 = v18;
        v14 = "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded";
        goto LABEL_42;
      }

      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v16)
        {
          goto LABEL_43;
        }

        v19 = "invalid";
        if (v3 && *(v3 + 16))
        {
          v19 = *(v3 + 16);
        }

        *buf = 136446466;
        v33 = "nw_http3_start_encoder_stream_if_needed";
        v34 = 2082;
        v35 = v19;
        v14 = "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace";
        goto LABEL_42;
      }

      if (v16)
      {
        v17 = "invalid";
        if (v3 && *(v3 + 16))
        {
          v17 = *(v3 + 16);
        }

        *buf = 136446722;
        v33 = "nw_http3_start_encoder_stream_if_needed";
        v34 = 2082;
        v35 = v17;
        v36 = 2082;
        v37 = backtrace_string;
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s protocol %{public}s has invalid add_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
      }

      free(backtrace_string);
    }

LABEL_43:
    if (v10)
    {
      free(v10);
    }

    if (!v3)
    {
      __nwlog_obj();
      v9 = "invalid";
      goto LABEL_47;
    }

LABEL_6:
    v6 = *(v3 + 24);
    if (v6)
    {
      v7 = *(v6 + 24);
      if (v7)
      {
        v7(v3, a1[134]);
        return;
      }
    }

    __nwlog_obj();
    v9 = *(v3 + 16);
    if (!v9)
    {
      v9 = "invalid";
    }

LABEL_47:
    *buf = 136446466;
    v33 = "nw_http3_start_encoder_stream_if_needed";
    v34 = 2082;
    v35 = v9;
    v20 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v20, &type, &v30))
    {
      goto LABEL_73;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v21 = __nwlog_obj();
      v22 = type;
      if (!os_log_type_enabled(v21, type))
      {
        goto LABEL_73;
      }

      v23 = "invalid";
      if (v3 && *(v3 + 16))
      {
        v23 = *(v3 + 16);
      }

      *buf = 136446466;
      v33 = "nw_http3_start_encoder_stream_if_needed";
      v34 = 2082;
      v35 = v23;
      v24 = "%{public}s protocol %{public}s has invalid connect callback";
    }

    else if (v30 == 1)
    {
      v25 = __nw_create_backtrace_string();
      v21 = __nwlog_obj();
      v22 = type;
      v26 = os_log_type_enabled(v21, type);
      if (v25)
      {
        if (v26)
        {
          v27 = "invalid";
          if (v3 && *(v3 + 16))
          {
            v27 = *(v3 + 16);
          }

          *buf = 136446722;
          v33 = "nw_http3_start_encoder_stream_if_needed";
          v34 = 2082;
          v35 = v27;
          v36 = 2082;
          v37 = v25;
          _os_log_impl(&dword_181A37000, v21, v22, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v25);
        goto LABEL_73;
      }

      if (!v26)
      {
LABEL_73:
        if (v20)
        {
          free(v20);
        }

        return;
      }

      v29 = "invalid";
      if (v3 && *(v3 + 16))
      {
        v29 = *(v3 + 16);
      }

      *buf = 136446466;
      v33 = "nw_http3_start_encoder_stream_if_needed";
      v34 = 2082;
      v35 = v29;
      v24 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
    }

    else
    {
      v21 = __nwlog_obj();
      v22 = type;
      if (!os_log_type_enabled(v21, type))
      {
        goto LABEL_73;
      }

      v28 = "invalid";
      if (v3 && *(v3 + 16))
      {
        v28 = *(v3 + 16);
      }

      *buf = 136446466;
      v33 = "nw_http3_start_encoder_stream_if_needed";
      v34 = 2082;
      v35 = v28;
      v24 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v21, v22, v24, buf, 0x16u);
    goto LABEL_73;
  }
}

void nw_http3_encoder_stream_process_output(uint64_t a1)
{
  v134[2] = *MEMORY[0x1E69E9840];
  v2 = (a1 + 1397);
  if ((*(a1 + 1397) & 0x2000) != 0)
  {
    goto LABEL_28;
  }

  v3 = *(a1 + 1216);
  if (v3)
  {
    *v122 = 0;
    v123 = v122;
    v124 = 0x2000000000;
    size = dispatch_data_get_size(v3);
    v125 = size;
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x3802000000;
    *&buf[24] = __Block_byref_object_copy__63268;
    v133 = __Block_byref_object_dispose__63269;
    v134[0] = 0;
    v134[1] = v134;
    v5 = *(a1 + 1072);
    if (!v5)
    {
      goto LABEL_163;
    }

    v6 = *(v5 + 24);
    if (!v6)
    {
      goto LABEL_163;
    }

    v7 = *(v6 + 88);
    if (!v7 || !v7(*(a1 + 1072), a1, size, size, 0xFFFFFFFFLL))
    {
      goto LABEL_163;
    }

    v116[0] = MEMORY[0x1E69E9820];
    v116[1] = 0x40000000;
    v117 = ___ZL38nw_http3_encoder_stream_process_outputP17nw_protocol_http3_block_invoke;
    v118 = &unk_1E6A38BE0;
    v119 = v122;
    v120 = buf;
    v121 = a1;
    v8 = *(*&buf[8] + 40);
    do
    {
      if (!v8)
      {
        break;
      }

      v9 = *(v8 + 32);
      v10 = v117(v116);
      v8 = v9;
    }

    while ((v10 & 1) != 0);
    if (*(a1 + 1216))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *v126 = 136446210;
      v127 = "nw_http3_encoder_stream_process_output";
      v11 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v114 = 0;
      if (!__nwlog_fault(v11, &type, &v114))
      {
        goto LABEL_161;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v13 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_161;
        }

        *v126 = 136446210;
        v127 = "nw_http3_encoder_stream_process_output";
        v14 = "%{public}s Not enough space for sdtc";
      }

      else
      {
        if (v114 == 1)
        {
          backtrace_string = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v94 = gLogObj;
          v95 = type;
          v96 = os_log_type_enabled(gLogObj, type);
          if (backtrace_string)
          {
            if (v96)
            {
              *v126 = 136446466;
              v127 = "nw_http3_encoder_stream_process_output";
              v128 = 2082;
              v129 = backtrace_string;
              _os_log_impl(&dword_181A37000, v94, v95, "%{public}s Not enough space for sdtc, dumping backtrace:%{public}s", v126, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_161;
          }

          if (!v96)
          {
LABEL_161:
            if (v11)
            {
              free(v11);
            }

LABEL_163:
            _Block_object_dispose(buf, 8);
            _Block_object_dispose(v122, 8);
            return;
          }

          *v126 = 136446210;
          v127 = "nw_http3_encoder_stream_process_output";
          v14 = "%{public}s Not enough space for sdtc, no backtrace";
          v99 = v94;
          v100 = v95;
LABEL_160:
          _os_log_impl(&dword_181A37000, v99, v100, v14, v126, 0xCu);
          goto LABEL_161;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v13 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_161;
        }

        *v126 = 136446210;
        v127 = "nw_http3_encoder_stream_process_output";
        v14 = "%{public}s Not enough space for sdtc, backtrace limit exceeded";
      }

      v99 = v12;
      v100 = v13;
      goto LABEL_160;
    }

    v23 = *(v5 + 24);
    if (v23)
    {
      v24 = *(v23 + 96);
      if (v24)
      {
        v24(v5, *&buf[8] + 40);
LABEL_27:
        *v2 |= 0x2000u;
        _Block_object_dispose(buf, 8);
        _Block_object_dispose(v122, 8);
LABEL_28:
        v25 = *(a1 + 936);
        while (1)
        {
          if (!v25)
          {
            return;
          }

          v27 = *(v25 + 376);
          if (v27 == 2)
          {
            break;
          }

          if (v27)
          {
            goto LABEL_57;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v28 = *(v25 + 376);
          *buf = 136446466;
          *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
          *&buf[12] = 1024;
          *&buf[14] = v28;
          v29 = _os_log_send_and_compose_impl();
          v122[0] = OS_LOG_TYPE_ERROR;
          v126[0] = 0;
          if (!__nwlog_fault(v29, v122, v126))
          {
            goto LABEL_55;
          }

          if (v122[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v30 = gLogObj;
            v31 = v122[0];
            if (os_log_type_enabled(gLogObj, v122[0]))
            {
              v32 = *(v25 + 376);
              *buf = 136446466;
              *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
              *&buf[12] = 1024;
              *&buf[14] = v32;
              v33 = v30;
              v34 = v31;
              v35 = "%{public}s Unexpected output state %d";
              goto LABEL_53;
            }

            goto LABEL_55;
          }

          if (v126[0] != 1)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v45 = gLogObj;
            v46 = v122[0];
            if (!os_log_type_enabled(gLogObj, v122[0]))
            {
              goto LABEL_55;
            }

            v47 = *(v25 + 376);
            *buf = 136446466;
            *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
            *&buf[12] = 1024;
            *&buf[14] = v47;
            v33 = v45;
            v34 = v46;
            v35 = "%{public}s Unexpected output state %d, backtrace limit exceeded";
            goto LABEL_53;
          }

          v40 = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v41 = gLogObj;
          v42 = v122[0];
          v43 = os_log_type_enabled(gLogObj, v122[0]);
          if (!v40)
          {
            if (!v43)
            {
              goto LABEL_55;
            }

            v48 = *(v25 + 376);
            *buf = 136446466;
            *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
            *&buf[12] = 1024;
            *&buf[14] = v48;
            v33 = v41;
            v34 = v42;
            v35 = "%{public}s Unexpected output state %d, no backtrace";
LABEL_53:
            v49 = 18;
LABEL_54:
            _os_log_impl(&dword_181A37000, v33, v34, v35, buf, v49);
            goto LABEL_55;
          }

          if (v43)
          {
            v44 = *(v25 + 376);
            *buf = 136446722;
            *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
            *&buf[12] = 1024;
            *&buf[14] = v44;
            *&buf[18] = 2082;
            *&buf[20] = v40;
            _os_log_impl(&dword_181A37000, v41, v42, "%{public}s Unexpected output state %d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v40);
          if (v29)
          {
LABEL_56:
            free(v29);
          }

LABEL_57:
          if ((*(v25 + 732) & 0x1000) != 0 && !*(v25 + 520) && !*(v25 + 630) && !*(v25 + 631))
          {
            *(v25 + 732) &= ~0x1000u;
            v50 = *(v25 + 32);
            if (!v50 || (v51 = *(v50 + 24)) == 0 || (v52 = *(v51 + 32)) == 0)
            {
              __nwlog_obj();
              v53 = *(v25 + 32);
              if (v53)
              {
                v54 = *(v53 + 16);
                if (!v54)
                {
                  v54 = "invalid";
                }
              }

              else
              {
                v54 = "invalid";
              }

              *buf = 136446466;
              *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
              *&buf[12] = 2082;
              *&buf[14] = v54;
              v73 = _os_log_send_and_compose_impl();
              v122[0] = OS_LOG_TYPE_ERROR;
              v126[0] = 0;
              if (!__nwlog_fault(v73, v122, v126))
              {
                goto LABEL_144;
              }

              if (v122[0] == OS_LOG_TYPE_FAULT)
              {
                v74 = __nwlog_obj();
                v75 = v122[0];
                if (os_log_type_enabled(v74, v122[0]))
                {
                  v76 = *(v25 + 32);
                  if (v76)
                  {
                    v77 = *(v76 + 16);
                    if (!v77)
                    {
                      v77 = "invalid";
                    }
                  }

                  else
                  {
                    v77 = "invalid";
                  }

                  *buf = 136446466;
                  *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
                  *&buf[12] = 2082;
                  *&buf[14] = v77;
                  v88 = v74;
                  v89 = v75;
                  v90 = "%{public}s protocol %{public}s has invalid disconnect callback";
                  goto LABEL_137;
                }
              }

              else if (v126[0] == 1)
              {
                v78 = v73;
                v79 = __nw_create_backtrace_string();
                v80 = __nwlog_obj();
                v113 = v122[0];
                v81 = os_log_type_enabled(v80, v122[0]);
                if (v79)
                {
                  if (v81)
                  {
                    v82 = *(v25 + 32);
                    if (v82)
                    {
                      v83 = *(v82 + 16);
                      if (!v83)
                      {
                        v83 = "invalid";
                      }
                    }

                    else
                    {
                      v83 = "invalid";
                    }

                    *buf = 136446722;
                    *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
                    *&buf[12] = 2082;
                    *&buf[14] = v83;
                    *&buf[22] = 2082;
                    *&buf[24] = v79;
                    _os_log_impl(&dword_181A37000, v80, v113, "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s", buf, 0x20u);
                  }

                  free(v79);
                }

                else
                {
                  v73 = v78;
                  if (!v81)
                  {
                    goto LABEL_144;
                  }

                  v91 = *(v25 + 32);
                  if (v91)
                  {
                    v92 = *(v91 + 16);
                    if (!v92)
                    {
                      v92 = "invalid";
                    }
                  }

                  else
                  {
                    v92 = "invalid";
                  }

                  *buf = 136446466;
                  *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
                  *&buf[12] = 2082;
                  *&buf[14] = v92;
                  _os_log_impl(&dword_181A37000, v80, v113, "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace", buf, 0x16u);
                }

                v73 = v78;
              }

              else
              {
                v84 = __nwlog_obj();
                v85 = v122[0];
                if (os_log_type_enabled(v84, v122[0]))
                {
                  v86 = *(v25 + 32);
                  if (v86)
                  {
                    v87 = *(v86 + 16);
                    if (!v87)
                    {
                      v87 = "invalid";
                    }
                  }

                  else
                  {
                    v87 = "invalid";
                  }

                  *buf = 136446466;
                  *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
                  *&buf[12] = 2082;
                  *&buf[14] = v87;
                  v88 = v84;
                  v89 = v85;
                  v90 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
LABEL_137:
                  _os_log_impl(&dword_181A37000, v88, v89, v90, buf, 0x16u);
                }
              }

LABEL_144:
              if (v73)
              {
                free(v73);
              }

              goto LABEL_30;
            }

            v52(v50, v25);
          }

LABEL_30:
          v26 = v25 == *(a1 + 936);
          v25 = *(a1 + 936);
          if (v26)
          {
            return;
          }
        }

        is_metadata_complete = nw_frame_is_metadata_complete(*(v25 + 392));
        if (!nw_http3_stream_send_fields(v25, is_metadata_complete))
        {
          goto LABEL_57;
        }

        v37 = *(v25 + 48);
        if (v37)
        {
          v38 = *(v37 + 24);
          if (v38)
          {
            v39 = *(v38 + 72);
            if (v39)
            {
              v39(v37, v25);
              goto LABEL_57;
            }
          }
        }

        __nwlog_obj();
        v55 = *(v25 + 48);
        if (v55)
        {
          v56 = *(v55 + 16);
          if (!v56)
          {
            v56 = "invalid";
          }
        }

        else
        {
          v56 = "invalid";
        }

        *buf = 136446466;
        *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
        *&buf[12] = 2082;
        *&buf[14] = v56;
        v29 = _os_log_send_and_compose_impl();
        v122[0] = OS_LOG_TYPE_ERROR;
        v126[0] = 0;
        if (!__nwlog_fault(v29, v122, v126))
        {
          goto LABEL_55;
        }

        if (v122[0] == OS_LOG_TYPE_FAULT)
        {
          v57 = __nwlog_obj();
          v58 = v122[0];
          if (!os_log_type_enabled(v57, v122[0]))
          {
            goto LABEL_55;
          }

          v59 = *(v25 + 48);
          if (v59)
          {
            v60 = *(v59 + 16);
            if (!v60)
            {
              v60 = "invalid";
            }
          }

          else
          {
            v60 = "invalid";
          }

          *buf = 136446466;
          *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
          *&buf[12] = 2082;
          *&buf[14] = v60;
          v33 = v57;
          v34 = v58;
          v35 = "%{public}s protocol %{public}s has invalid output_available callback";
        }

        else
        {
          if (v126[0] == 1)
          {
            *v112 = v29;
            v61 = __nw_create_backtrace_string();
            v62 = __nwlog_obj();
            v63 = v122[0];
            v64 = os_log_type_enabled(v62, v122[0]);
            if (v61)
            {
              if (v64)
              {
                v65 = *(v25 + 48);
                if (v65)
                {
                  v66 = *(v65 + 16);
                  if (!v66)
                  {
                    v66 = "invalid";
                  }
                }

                else
                {
                  v66 = "invalid";
                }

                *buf = 136446722;
                *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
                *&buf[12] = 2082;
                *&buf[14] = v66;
                *&buf[22] = 2082;
                *&buf[24] = v61;
                _os_log_impl(&dword_181A37000, v62, v63, "%{public}s protocol %{public}s has invalid output_available callback, dumping backtrace:%{public}s", buf, 0x20u);
              }

              free(v61);
            }

            else
            {
              v29 = *v112;
              if (!v64)
              {
                goto LABEL_55;
              }

              v71 = *(v25 + 48);
              if (v71)
              {
                v72 = *(v71 + 16);
                if (!v72)
                {
                  v72 = "invalid";
                }
              }

              else
              {
                v72 = "invalid";
              }

              *buf = 136446466;
              *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
              *&buf[12] = 2082;
              *&buf[14] = v72;
              _os_log_impl(&dword_181A37000, v62, v63, "%{public}s protocol %{public}s has invalid output_available callback, no backtrace", buf, 0x16u);
            }

            v29 = *v112;
LABEL_55:
            if (v29)
            {
              goto LABEL_56;
            }

            goto LABEL_57;
          }

          v67 = __nwlog_obj();
          v68 = v122[0];
          if (!os_log_type_enabled(v67, v122[0]))
          {
            goto LABEL_55;
          }

          v69 = *(v25 + 48);
          if (v69)
          {
            v70 = *(v69 + 16);
            if (!v70)
            {
              v70 = "invalid";
            }
          }

          else
          {
            v70 = "invalid";
          }

          *buf = 136446466;
          *&buf[4] = "nw_http3_stream_encoder_stream_output_available";
          *&buf[12] = 2082;
          *&buf[14] = v70;
          v33 = v67;
          v34 = v68;
          v35 = "%{public}s protocol %{public}s has invalid output_available callback, backtrace limit exceeded";
        }

        v49 = 22;
        goto LABEL_54;
      }
    }

    __nwlog_obj();
    v101 = *(v5 + 16);
    if (!v101)
    {
      v101 = "invalid";
    }

    *v126 = 136446466;
    v127 = "nw_http3_encoder_stream_process_output";
    v128 = 2082;
    v129 = v101;
    v102 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v114 = 0;
    if (__nwlog_fault(v102, &type, &v114))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v103 = __nwlog_obj();
        v104 = type;
        if (!os_log_type_enabled(v103, type))
        {
          goto LABEL_193;
        }

        v105 = *(v5 + 16);
        if (!v105)
        {
          v105 = "invalid";
        }

        *v126 = 136446466;
        v127 = "nw_http3_encoder_stream_process_output";
        v128 = 2082;
        v129 = v105;
        v106 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
        goto LABEL_192;
      }

      if (v114 != 1)
      {
        v103 = __nwlog_obj();
        v104 = type;
        if (!os_log_type_enabled(v103, type))
        {
          goto LABEL_193;
        }

        v110 = *(v5 + 16);
        if (!v110)
        {
          v110 = "invalid";
        }

        *v126 = 136446466;
        v127 = "nw_http3_encoder_stream_process_output";
        v128 = 2082;
        v129 = v110;
        v106 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
        goto LABEL_192;
      }

      v107 = __nw_create_backtrace_string();
      v103 = __nwlog_obj();
      v104 = type;
      v108 = os_log_type_enabled(v103, type);
      if (v107)
      {
        if (v108)
        {
          v109 = *(v5 + 16);
          if (!v109)
          {
            v109 = "invalid";
          }

          *v126 = 136446722;
          v127 = "nw_http3_encoder_stream_process_output";
          v128 = 2082;
          v129 = v109;
          v130 = 2082;
          v131 = v107;
          _os_log_impl(&dword_181A37000, v103, v104, "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s", v126, 0x20u);
        }

        free(v107);
        goto LABEL_193;
      }

      if (v108)
      {
        v111 = *(v5 + 16);
        if (!v111)
        {
          v111 = "invalid";
        }

        *v126 = 136446466;
        v127 = "nw_http3_encoder_stream_process_output";
        v128 = 2082;
        v129 = v111;
        v106 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
LABEL_192:
        _os_log_impl(&dword_181A37000, v103, v104, v106, v126, 0x16u);
      }
    }

LABEL_193:
    if (v102)
    {
      free(v102);
    }

    goto LABEL_27;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446210;
  *&buf[4] = "nw_http3_encoder_stream_process_output";
  v15 = _os_log_send_and_compose_impl();
  v122[0] = OS_LOG_TYPE_ERROR;
  v126[0] = 0;
  if (__nwlog_fault(v15, v122, v126))
  {
    if (v122[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = v122[0];
      if (!os_log_type_enabled(gLogObj, v122[0]))
      {
        goto LABEL_155;
      }

      *buf = 136446210;
      *&buf[4] = "nw_http3_encoder_stream_process_output";
      v18 = "%{public}s Attempting to send on encoder stream before initial sdtc";
LABEL_153:
      v97 = v16;
      v98 = v17;
LABEL_154:
      _os_log_impl(&dword_181A37000, v97, v98, v18, buf, 0xCu);
      goto LABEL_155;
    }

    if (v126[0] != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = v122[0];
      if (!os_log_type_enabled(gLogObj, v122[0]))
      {
        goto LABEL_155;
      }

      *buf = 136446210;
      *&buf[4] = "nw_http3_encoder_stream_process_output";
      v18 = "%{public}s Attempting to send on encoder stream before initial sdtc, backtrace limit exceeded";
      goto LABEL_153;
    }

    v19 = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = gLogObj;
    v21 = v122[0];
    v22 = os_log_type_enabled(gLogObj, v122[0]);
    if (v19)
    {
      if (v22)
      {
        *buf = 136446466;
        *&buf[4] = "nw_http3_encoder_stream_process_output";
        *&buf[12] = 2082;
        *&buf[14] = v19;
        _os_log_impl(&dword_181A37000, v20, v21, "%{public}s Attempting to send on encoder stream before initial sdtc, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v19);
      goto LABEL_155;
    }

    if (v22)
    {
      *buf = 136446210;
      *&buf[4] = "nw_http3_encoder_stream_process_output";
      v18 = "%{public}s Attempting to send on encoder stream before initial sdtc, no backtrace";
      v97 = v20;
      v98 = v21;
      goto LABEL_154;
    }
  }

LABEL_155:
  if (v15)
  {
    free(v15);
  }
}

BOOL ___ZL38nw_http3_encoder_stream_process_outputP17nw_protocol_http3_block_invoke(void *a1, uint64_t a2)
{
  v35 = *MEMORY[0x1E69E9840];
  if ((nw_frame_uses_external_data(a2) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v32 = "nw_http3_encoder_stream_process_output_block_invoke";
    v7 = _os_log_send_and_compose_impl();
    LOBYTE(offset) = 16;
    offset_7 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v7, &offset, &offset_7))
    {
      if (offset == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = offset;
        if (os_log_type_enabled(gLogObj, offset))
        {
          *buf = 136446210;
          v32 = "nw_http3_encoder_stream_process_output_block_invoke";
          v10 = "%{public}s Encoder stream does not support external data";
LABEL_24:
          v19 = v8;
          v20 = v9;
LABEL_25:
          _os_log_impl(&dword_181A37000, v19, v20, v10, buf, 0xCu);
        }
      }

      else if (offset_7 == OS_LOG_TYPE_INFO)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        v17 = offset;
        v18 = os_log_type_enabled(gLogObj, offset);
        if (backtrace_string)
        {
          if (v18)
          {
            *buf = 136446466;
            v32 = "nw_http3_encoder_stream_process_output_block_invoke";
            v33 = 2082;
            v34 = backtrace_string;
            _os_log_impl(&dword_181A37000, v16, v17, "%{public}s Encoder stream does not support external data, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }

        if (v18)
        {
          *buf = 136446210;
          v32 = "nw_http3_encoder_stream_process_output_block_invoke";
          v10 = "%{public}s Encoder stream does not support external data, no backtrace";
          v19 = v16;
          v20 = v17;
          goto LABEL_25;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = offset;
        if (os_log_type_enabled(gLogObj, offset))
        {
          *buf = 136446210;
          v32 = "nw_http3_encoder_stream_process_output_block_invoke";
          v10 = "%{public}s Encoder stream does not support external data, backtrace limit exceeded";
          goto LABEL_24;
        }
      }
    }

LABEL_26:
    if (v7)
    {
      free(v7);
    }

    return 0;
  }

  offset = 0;
  nw_frame_set_external_data(a2, *(a1[6] + 1216), &offset);
  v4 = *(*(a1[4] + 8) + 24);
  v5 = *(a1[6] + 1216);
  v6 = offset < v4;
  if (offset < v4)
  {
    *(a1[6] + 1216) = dispatch_data_create_subrange(*(a1[6] + 1216), offset, 0xFFFFFFFFFFFFFFFFLL);
    if (v5)
    {
      dispatch_release(v5);
    }

    *(*(a1[4] + 8) + 24) -= offset;
    return v6;
  }

  if (v5)
  {
    dispatch_release(*(a1[6] + 1216));
    *(a1[6] + 1216) = 0;
  }

  if (**(*(*(a1[5] + 8) + 48) + 8) != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v32 = "nw_http3_encoder_stream_process_output_block_invoke";
    v11 = _os_log_send_and_compose_impl();
    offset_7 = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v11, &offset_7, &v28))
    {
      goto LABEL_41;
    }

    if (offset_7 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = offset_7;
      if (!os_log_type_enabled(gLogObj, offset_7))
      {
        goto LABEL_41;
      }

      *buf = 136446210;
      v32 = "nw_http3_encoder_stream_process_output_block_invoke";
      v14 = "%{public}s Too much space for sdtc";
    }

    else
    {
      if (v28 == 1)
      {
        v22 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v24 = offset_7;
        v25 = os_log_type_enabled(gLogObj, offset_7);
        if (v22)
        {
          if (v25)
          {
            *buf = 136446466;
            v32 = "nw_http3_encoder_stream_process_output_block_invoke";
            v33 = 2082;
            v34 = v22;
            _os_log_impl(&dword_181A37000, v23, v24, "%{public}s Too much space for sdtc, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v22);
          goto LABEL_41;
        }

        if (!v25)
        {
LABEL_41:
          if (v11)
          {
            free(v11);
          }

          return v6;
        }

        *buf = 136446210;
        v32 = "nw_http3_encoder_stream_process_output_block_invoke";
        v14 = "%{public}s Too much space for sdtc, no backtrace";
        v26 = v23;
        v27 = v24;
LABEL_40:
        _os_log_impl(&dword_181A37000, v26, v27, v14, buf, 0xCu);
        goto LABEL_41;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = offset_7;
      if (!os_log_type_enabled(gLogObj, offset_7))
      {
        goto LABEL_41;
      }

      *buf = 136446210;
      v32 = "nw_http3_encoder_stream_process_output_block_invoke";
      v14 = "%{public}s Too much space for sdtc, backtrace limit exceeded";
    }

    v26 = v12;
    v27 = v13;
    goto LABEL_40;
  }

  return v6;
}

uint64_t ___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke(uint64_t result, _BYTE *a2)
{
  v2 = a2 && *a2 == 63 && a2[1] == 49 && a2[2] == 0;
  *(*(result + 32) + 734) = *(*(result + 32) + 734) & 0xFE | v2;
  return result;
}

uint64_t ___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke_2(uint64_t result, char *__s1)
{
  v2 = result;
  if (__s1)
  {
    result = strcmp(__s1, "connect-udp");
    if (result && (result = strcmp(__s1, "connect-ip"), result))
    {
      result = strcmp(__s1, "webtransport");
      v4 = result == 0;
    }

    else
    {
      v4 = 1;
    }
  }

  else
  {
    v4 = 0;
  }

  *(*(*(v2 + 32) + 8) + 24) = v4;
  return result;
}

BOOL ___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke_3(void *a1, uint64_t a2)
{
  v35 = *MEMORY[0x1E69E9840];
  if ((nw_frame_uses_external_data(a2) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v32 = "nw_http3_stream_send_fields_block_invoke_3";
    v7 = _os_log_send_and_compose_impl();
    LOBYTE(offset) = 16;
    offset_7 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v7, &offset, &offset_7))
    {
      if (offset == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = offset;
        if (os_log_type_enabled(gLogObj, offset))
        {
          *buf = 136446210;
          v32 = "nw_http3_stream_send_fields_block_invoke";
          v10 = "%{public}s Encoder stream does not support external data";
LABEL_24:
          v19 = v8;
          v20 = v9;
LABEL_25:
          _os_log_impl(&dword_181A37000, v19, v20, v10, buf, 0xCu);
        }
      }

      else if (offset_7 == OS_LOG_TYPE_INFO)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        v17 = offset;
        v18 = os_log_type_enabled(gLogObj, offset);
        if (backtrace_string)
        {
          if (v18)
          {
            *buf = 136446466;
            v32 = "nw_http3_stream_send_fields_block_invoke";
            v33 = 2082;
            v34 = backtrace_string;
            _os_log_impl(&dword_181A37000, v16, v17, "%{public}s Encoder stream does not support external data, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }

        if (v18)
        {
          *buf = 136446210;
          v32 = "nw_http3_stream_send_fields_block_invoke";
          v10 = "%{public}s Encoder stream does not support external data, no backtrace";
          v19 = v16;
          v20 = v17;
          goto LABEL_25;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = offset;
        if (os_log_type_enabled(gLogObj, offset))
        {
          *buf = 136446210;
          v32 = "nw_http3_stream_send_fields_block_invoke";
          v10 = "%{public}s Encoder stream does not support external data, backtrace limit exceeded";
          goto LABEL_24;
        }
      }
    }

LABEL_26:
    if (v7)
    {
      free(v7);
    }

    return 0;
  }

  offset = 0;
  nw_frame_set_external_data(a2, *(a1[6] + 520), &offset);
  v4 = *(*(a1[4] + 8) + 24);
  v5 = *(a1[6] + 520);
  v6 = offset < v4;
  if (offset < v4)
  {
    *(a1[6] + 520) = dispatch_data_create_subrange(*(a1[6] + 520), offset, 0xFFFFFFFFFFFFFFFFLL);
    if (v5)
    {
      dispatch_release(v5);
    }

    *(*(a1[4] + 8) + 24) -= offset;
    return v6;
  }

  if (v5)
  {
    dispatch_release(*(a1[6] + 520));
    *(a1[6] + 520) = 0;
  }

  if (**(*(*(a1[5] + 8) + 48) + 8) != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v32 = "nw_http3_stream_send_fields_block_invoke";
    v11 = _os_log_send_and_compose_impl();
    offset_7 = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v11, &offset_7, &v28))
    {
      goto LABEL_41;
    }

    if (offset_7 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = offset_7;
      if (!os_log_type_enabled(gLogObj, offset_7))
      {
        goto LABEL_41;
      }

      *buf = 136446210;
      v32 = "nw_http3_stream_send_fields_block_invoke";
      v14 = "%{public}s Too much space on encoder stream";
    }

    else
    {
      if (v28 == 1)
      {
        v22 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v24 = offset_7;
        v25 = os_log_type_enabled(gLogObj, offset_7);
        if (v22)
        {
          if (v25)
          {
            *buf = 136446466;
            v32 = "nw_http3_stream_send_fields_block_invoke";
            v33 = 2082;
            v34 = v22;
            _os_log_impl(&dword_181A37000, v23, v24, "%{public}s Too much space on encoder stream, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v22);
          goto LABEL_41;
        }

        if (!v25)
        {
LABEL_41:
          if (v11)
          {
            free(v11);
          }

          return v6;
        }

        *buf = 136446210;
        v32 = "nw_http3_stream_send_fields_block_invoke";
        v14 = "%{public}s Too much space on encoder stream, no backtrace";
        v26 = v23;
        v27 = v24;
LABEL_40:
        _os_log_impl(&dword_181A37000, v26, v27, v14, buf, 0xCu);
        goto LABEL_41;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = offset_7;
      if (!os_log_type_enabled(gLogObj, offset_7))
      {
        goto LABEL_41;
      }

      *buf = 136446210;
      v32 = "nw_http3_stream_send_fields_block_invoke";
      v14 = "%{public}s Too much space on encoder stream, backtrace limit exceeded";
    }

    v26 = v12;
    v27 = v13;
    goto LABEL_40;
  }

  return v6;
}

BOOL ___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke_78(void *a1, uint64_t a2)
{
  v35 = *MEMORY[0x1E69E9840];
  if ((nw_frame_uses_external_data(a2) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v32 = "nw_http3_stream_send_fields_block_invoke";
    v7 = _os_log_send_and_compose_impl();
    LOBYTE(offset) = 16;
    offset_7 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v7, &offset, &offset_7))
    {
      if (offset == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = offset;
        if (os_log_type_enabled(gLogObj, offset))
        {
          *buf = 136446210;
          v32 = "nw_http3_stream_send_fields_block_invoke";
          v10 = "%{public}s Fields frame does not support external data";
LABEL_24:
          v19 = v8;
          v20 = v9;
LABEL_25:
          _os_log_impl(&dword_181A37000, v19, v20, v10, buf, 0xCu);
        }
      }

      else if (offset_7 == OS_LOG_TYPE_INFO)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        v17 = offset;
        v18 = os_log_type_enabled(gLogObj, offset);
        if (backtrace_string)
        {
          if (v18)
          {
            *buf = 136446466;
            v32 = "nw_http3_stream_send_fields_block_invoke";
            v33 = 2082;
            v34 = backtrace_string;
            _os_log_impl(&dword_181A37000, v16, v17, "%{public}s Fields frame does not support external data, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }

        if (v18)
        {
          *buf = 136446210;
          v32 = "nw_http3_stream_send_fields_block_invoke";
          v10 = "%{public}s Fields frame does not support external data, no backtrace";
          v19 = v16;
          v20 = v17;
          goto LABEL_25;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = offset;
        if (os_log_type_enabled(gLogObj, offset))
        {
          *buf = 136446210;
          v32 = "nw_http3_stream_send_fields_block_invoke";
          v10 = "%{public}s Fields frame does not support external data, backtrace limit exceeded";
          goto LABEL_24;
        }
      }
    }

LABEL_26:
    if (v7)
    {
      free(v7);
    }

    return 0;
  }

  offset = 0;
  nw_frame_set_external_data(a2, *(a1[6] + 512), &offset);
  v4 = *(*(a1[4] + 8) + 24);
  v5 = *(a1[6] + 512);
  v6 = offset < v4;
  if (offset < v4)
  {
    *(a1[6] + 512) = dispatch_data_create_subrange(*(a1[6] + 512), offset, 0xFFFFFFFFFFFFFFFFLL);
    if (v5)
    {
      dispatch_release(v5);
    }

    *(*(a1[4] + 8) + 24) -= offset;
    return v6;
  }

  if (v5)
  {
    dispatch_release(*(a1[6] + 512));
    *(a1[6] + 512) = 0;
  }

  if (**(*(*(a1[5] + 8) + 48) + 8) != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v32 = "nw_http3_stream_send_fields_block_invoke";
    v11 = _os_log_send_and_compose_impl();
    offset_7 = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v11, &offset_7, &v28))
    {
      goto LABEL_41;
    }

    if (offset_7 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = offset_7;
      if (!os_log_type_enabled(gLogObj, offset_7))
      {
        goto LABEL_41;
      }

      *buf = 136446210;
      v32 = "nw_http3_stream_send_fields_block_invoke";
      v14 = "%{public}s Too much space in fields frame";
    }

    else
    {
      if (v28 == 1)
      {
        v22 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v24 = offset_7;
        v25 = os_log_type_enabled(gLogObj, offset_7);
        if (v22)
        {
          if (v25)
          {
            *buf = 136446466;
            v32 = "nw_http3_stream_send_fields_block_invoke";
            v33 = 2082;
            v34 = v22;
            _os_log_impl(&dword_181A37000, v23, v24, "%{public}s Too much space in fields frame, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v22);
          goto LABEL_41;
        }

        if (!v25)
        {
LABEL_41:
          if (v11)
          {
            free(v11);
          }

          return v6;
        }

        *buf = 136446210;
        v32 = "nw_http3_stream_send_fields_block_invoke";
        v14 = "%{public}s Too much space in fields frame, no backtrace";
        v26 = v23;
        v27 = v24;
LABEL_40:
        _os_log_impl(&dword_181A37000, v26, v27, v14, buf, 0xCu);
        goto LABEL_41;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = offset_7;
      if (!os_log_type_enabled(gLogObj, offset_7))
      {
        goto LABEL_41;
      }

      *buf = 136446210;
      v32 = "nw_http3_stream_send_fields_block_invoke";
      v14 = "%{public}s Too much space in fields frame, backtrace limit exceeded";
    }

    v26 = v12;
    v27 = v13;
    goto LABEL_40;
  }

  return v6;
}

uint64_t ___ZL40nw_http3_framer_deliver_http3_frame_bodyP15nw_http3_framerjjjP21nw_http3_frame_type_tPyPbP16nw_frame_array_s_block_invoke_133(uint64_t a1, uint64_t a2)
{
  v43 = *MEMORY[0x1E69E9840];
  v4 = (*(a1 + 48) + 56);
  v6 = (a2 + 32);
  v5 = *(a2 + 32);
  v7 = *(a2 + 40);
  if (v5)
  {
    v4 = (v5 + 40);
  }

  *v4 = v7;
  *v7 = v5;
  *(a2 + 40) = 0;
  *v6 = 0;
  v8 = nw_frame_unclaimed_length(a2);
  v9 = *(a1 + 48);
  v10 = *(v9 + 16);
  v11 = *(*(a1 + 32) + 8);
  v12 = *(v11 + 24);
  v13 = *(a1 + 72);
  v14 = v13 - v12;
  if (v13 < v12)
  {
    v14 = 0;
  }

  if (v10 + v12 <= v13)
  {
    v15 = *(v9 + 16);
  }

  else
  {
    v15 = v14;
  }

  v16 = v8;
  if (v15 < v8)
  {
    v38 = a2;
    v17 = nw_frame_split(&v38, v15);
    v18 = *(a1 + 48);
    v19 = *(v18 + 16) - v15;
    *(v18 + 16) = v19;
    if (!v19)
    {
      **(a1 + 64) = 1;
    }

    if (v17)
    {
      v20 = *(a1 + 56);
      *(v17 + 32) = 0;
      v21 = *(v20 + 8);
      *(v17 + 40) = v21;
      *v21 = v17;
      *(v20 + 8) = v17 + 32;
      ++*(*(*(a1 + 40) + 8) + 24);
      nw_frame_array_prepend((v18 + 48), 1, v38);
      return 0;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v40 = "nw_http3_framer_deliver_http3_frame_body_block_invoke";
    v26 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (__nwlog_fault(v26, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v27 = gLogObj;
        v28 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_28;
        }

        *buf = 136446210;
        v40 = "nw_http3_framer_deliver_http3_frame_body_block_invoke";
        v29 = "%{public}s nw_frame_split returned NULL frame";
LABEL_26:
        v34 = v27;
        v35 = v28;
LABEL_27:
        _os_log_impl(&dword_181A37000, v34, v35, v29, buf, 0xCu);
        goto LABEL_28;
      }

      if (v36 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v27 = gLogObj;
        v28 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_28;
        }

        *buf = 136446210;
        v40 = "nw_http3_framer_deliver_http3_frame_body_block_invoke";
        v29 = "%{public}s nw_frame_split returned NULL frame, backtrace limit exceeded";
        goto LABEL_26;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = gLogObj;
      v32 = type;
      v33 = os_log_type_enabled(gLogObj, type);
      if (backtrace_string)
      {
        if (v33)
        {
          *buf = 136446466;
          v40 = "nw_http3_framer_deliver_http3_frame_body_block_invoke";
          v41 = 2082;
          v42 = backtrace_string;
          _os_log_impl(&dword_181A37000, v31, v32, "%{public}s nw_frame_split returned NULL frame, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }

      if (v33)
      {
        *buf = 136446210;
        v40 = "nw_http3_framer_deliver_http3_frame_body_block_invoke";
        v29 = "%{public}s nw_frame_split returned NULL frame, no backtrace";
        v34 = v31;
        v35 = v32;
        goto LABEL_27;
      }
    }

LABEL_28:
    if (v26)
    {
      free(v26);
    }

    return 0;
  }

  *(v11 + 24) = v12 + v8;
  v22 = *(a1 + 56);
  *(a2 + 32) = 0;
  v23 = *(v22 + 8);
  *(a2 + 40) = v23;
  *v23 = a2;
  *(v22 + 8) = v6;
  ++*(*(*(a1 + 40) + 8) + 24);
  result = 1;
  v25 = v10 - v16;
  *(v9 + 16) = v25;
  if (v25)
  {
    return result;
  }

  **(a1 + 64) = 1;
  return 0;
}

uint64_t ___ZL34nw_http3_uni_stream_create_inboundP17nw_protocol_http3_block_invoke(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    *(*(*(a1 + 32) + 8) + 24) = 0;
  }

  return *(*(*(a1 + 32) + 8) + 24);
}

void nw_protocol_http3_untyped_stream_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  v22 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v17 = "nw_protocol_http3_untyped_stream_error";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v4, &type, &v14))
    {
      goto LABEL_35;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_35;
      }

      *buf = 136446210;
      v17 = "nw_protocol_http3_untyped_stream_error";
      v7 = "%{public}s called with null protocol";
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v11 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v17 = "nw_protocol_http3_untyped_stream_error";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_35:
        if (!v4)
        {
          return;
        }

LABEL_36:
        free(v4);
        return;
      }

      if (!v11)
      {
        goto LABEL_35;
      }

      *buf = 136446210;
      v17 = "nw_protocol_http3_untyped_stream_error";
      v7 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_35;
      }

      *buf = 136446210;
      v17 = "nw_protocol_http3_untyped_stream_error";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_34:
    _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0xCu);
    goto LABEL_35;
  }

  handle = a1->handle;
  if (handle)
  {
    if (gLogDatapath == 1)
    {
      v9 = __nwlog_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446722;
        v17 = "nw_protocol_http3_untyped_stream_error";
        v18 = 2048;
        v19 = handle;
        v20 = 1024;
        v21 = a3;
        _os_log_impl(&dword_181A37000, v9, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_untyped_stream %p with error %d", buf, 0x1Cu);
      }
    }

    return;
  }

  __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_protocol_http3_untyped_stream_error";
  v4 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (!__nwlog_fault(v4, &type, &v14))
  {
    goto LABEL_35;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
    {
      goto LABEL_35;
    }

    *buf = 136446210;
    v17 = "nw_protocol_http3_untyped_stream_error";
    v7 = "%{public}s called with null http3_stream";
    goto LABEL_34;
  }

  if (v14 != 1)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
    {
      goto LABEL_35;
    }

    *buf = 136446210;
    v17 = "nw_protocol_http3_untyped_stream_error";
    v7 = "%{public}s called with null http3_stream, backtrace limit exceeded";
    goto LABEL_34;
  }

  v12 = __nw_create_backtrace_string();
  v5 = __nwlog_obj();
  v6 = type;
  v13 = os_log_type_enabled(v5, type);
  if (!v12)
  {
    if (!v13)
    {
      goto LABEL_35;
    }

    *buf = 136446210;
    v17 = "nw_protocol_http3_untyped_stream_error";
    v7 = "%{public}s called with null http3_stream, no backtrace";
    goto LABEL_34;
  }

  if (v13)
  {
    *buf = 136446466;
    v17 = "nw_protocol_http3_untyped_stream_error";
    v18 = 2082;
    v19 = v12;
    _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v12);
  if (v4)
  {
    goto LABEL_36;
  }
}

uint64_t nw_protocol_http3_reset(nw_protocol *a1, nw_protocol *a2)
{
  v24 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_protocol_http3_reset";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v3, &type, &v18))
    {
      goto LABEL_16;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_16;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_reset";
      v6 = "%{public}s called with null protocol";
      goto LABEL_14;
    }

    if (v18 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v15 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (!v15)
        {
          goto LABEL_38;
        }

        *buf = 136446466;
        v21 = "nw_protocol_http3_reset";
        v22 = 2082;
        v23 = backtrace_string;
        v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_37;
      }

      if (!v15)
      {
        goto LABEL_16;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_reset";
      v6 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_16;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_reset";
      v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_14:
    v11 = v4;
    v12 = v5;
LABEL_15:
    _os_log_impl(&dword_181A37000, v11, v12, v6, buf, 0xCu);
    goto LABEL_16;
  }

  handle = a1->handle;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!handle)
  {
    *buf = 136446210;
    v21 = "nw_protocol_http3_reset";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v3, &type, &v18))
    {
      goto LABEL_16;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_16;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_reset";
      v6 = "%{public}s called with null http3";
      goto LABEL_14;
    }

    if (v18 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v17 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (!v17)
        {
          goto LABEL_38;
        }

        *buf = 136446466;
        v21 = "nw_protocol_http3_reset";
        v22 = 2082;
        v23 = backtrace_string;
        v16 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_37:
        _os_log_impl(&dword_181A37000, v4, v5, v16, buf, 0x16u);
LABEL_38:
        free(backtrace_string);
        if (!v3)
        {
          return 0;
        }

        goto LABEL_17;
      }

      if (!v17)
      {
        goto LABEL_16;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_reset";
      v6 = "%{public}s called with null http3, no backtrace";
    }

    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_16;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_reset";
      v6 = "%{public}s called with null http3, backtrace limit exceeded";
    }

    goto LABEL_14;
  }

  *buf = 136446210;
  v21 = "nw_protocol_http3_reset";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v3, &type, &v18))
  {
    goto LABEL_16;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    v5 = type;
    if (!os_log_type_enabled(gLogObj, type))
    {
      goto LABEL_16;
    }

    *buf = 136446210;
    v21 = "nw_protocol_http3_reset";
    v6 = "%{public}s Reset is not supported on http3 connection";
    goto LABEL_14;
  }

  if (v18 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    v5 = type;
    if (!os_log_type_enabled(gLogObj, type))
    {
      goto LABEL_16;
    }

    *buf = 136446210;
    v21 = "nw_protocol_http3_reset";
    v6 = "%{public}s Reset is not supported on http3 connection, backtrace limit exceeded";
    goto LABEL_14;
  }

  v7 = __nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = gLogObj;
  v9 = type;
  v10 = os_log_type_enabled(gLogObj, type);
  if (v7)
  {
    if (v10)
    {
      *buf = 136446466;
      v21 = "nw_protocol_http3_reset";
      v22 = 2082;
      v23 = v7;
      _os_log_impl(&dword_181A37000, v8, v9, "%{public}s Reset is not supported on http3 connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v7);
  }

  else if (v10)
  {
    *buf = 136446210;
    v21 = "nw_protocol_http3_reset";
    v6 = "%{public}s Reset is not supported on http3 connection, no backtrace";
    v11 = v8;
    v12 = v9;
    goto LABEL_15;
  }

LABEL_16:
  if (v3)
  {
LABEL_17:
    free(v3);
  }

  return 0;
}

uint64_t nw_protocol_http3_get_output_local_endpoint(nw_protocol *a1)
{
  v17 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      result = nw_protocol_get_output_local_endpoint(a1->output_handler->flow_id);
      if (!result)
      {
        return handle[140];
      }

      return result;
    }

    __nwlog_obj();
    *buf = 136446210;
    v14 = "nw_protocol_http3_get_output_local_endpoint";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11))
    {
      goto LABEL_33;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_output_local_endpoint";
        v6 = "%{public}s called with null http3";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (v11 != 1)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_output_local_endpoint";
        v6 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    backtrace_string = __nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_output_local_endpoint";
        v6 = "%{public}s called with null http3, no backtrace";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (v10)
    {
      *buf = 136446466;
      v14 = "nw_protocol_http3_get_output_local_endpoint";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null http3, dumping backtrace:%{public}s";
      goto LABEL_22;
    }

    goto LABEL_23;
  }

  __nwlog_obj();
  *buf = 136446210;
  v14 = "nw_protocol_http3_get_output_local_endpoint";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11))
  {
    goto LABEL_33;
  }

  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v11 != 1)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_output_local_endpoint";
        v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    backtrace_string = __nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_output_local_endpoint";
        v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (v8)
    {
      *buf = 136446466;
      v14 = "nw_protocol_http3_get_output_local_endpoint";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_22:
      _os_log_impl(&dword_181A37000, v4, v5, v9, buf, 0x16u);
    }

LABEL_23:
    free(backtrace_string);
    goto LABEL_33;
  }

  v4 = __nwlog_obj();
  v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *buf = 136446210;
    v14 = "nw_protocol_http3_get_output_local_endpoint";
    v6 = "%{public}s called with null protocol";
LABEL_32:
    _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
  }

LABEL_33:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

uint64_t nw_protocol_http3_get_path(nw_protocol *a1)
{
  v17 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      return handle[141];
    }

    __nwlog_obj();
    *buf = 136446210;
    v14 = "nw_protocol_http3_get_path";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11))
    {
      goto LABEL_32;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_path";
        v6 = "%{public}s called with null http3";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v11 != 1)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_path";
        v6 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = __nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_path";
        v6 = "%{public}s called with null http3, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v10)
    {
      *buf = 136446466;
      v14 = "nw_protocol_http3_get_path";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null http3, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *buf = 136446210;
  v14 = "nw_protocol_http3_get_path";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11))
  {
    goto LABEL_32;
  }

  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v11 != 1)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_path";
        v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = __nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_path";
        v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v8)
    {
      *buf = 136446466;
      v14 = "nw_protocol_http3_get_path";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A37000, v4, v5, v9, buf, 0x16u);
    }

LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }

  v4 = __nwlog_obj();
  v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *buf = 136446210;
    v14 = "nw_protocol_http3_get_path";
    v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
  }

LABEL_32:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

uint64_t nw_protocol_http3_get_local_endpoint(nw_protocol *a1)
{
  v17 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      return handle[140];
    }

    __nwlog_obj();
    *buf = 136446210;
    v14 = "nw_protocol_http3_get_local_endpoint";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11))
    {
      goto LABEL_32;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_local_endpoint";
        v6 = "%{public}s called with null http3";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v11 != 1)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_local_endpoint";
        v6 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = __nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_local_endpoint";
        v6 = "%{public}s called with null http3, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v10)
    {
      *buf = 136446466;
      v14 = "nw_protocol_http3_get_local_endpoint";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null http3, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *buf = 136446210;
  v14 = "nw_protocol_http3_get_local_endpoint";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11))
  {
    goto LABEL_32;
  }

  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v11 != 1)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_local_endpoint";
        v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = __nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *buf = 136446210;
        v14 = "nw_protocol_http3_get_local_endpoint";
        v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v8)
    {
      *buf = 136446466;
      v14 = "nw_protocol_http3_get_local_endpoint";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A37000, v4, v5, v9, buf, 0x16u);
    }

LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }

  v4 = __nwlog_obj();
  v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *buf = 136446210;
    v14 = "nw_protocol_http3_get_local_endpoint";
    v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
  }

LABEL_32:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

uint64_t nw_protocol_http3_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  v31 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if (*(handle + 138) == a2)
      {
        if ((handle[1399] & 0x20) == 0 && gLogDatapath == 1)
        {
          v15 = handle;
          v16 = a2;
          v17 = __nwlog_obj();
          v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG);
          a2 = v16;
          v19 = v18;
          handle = v15;
          if (v19)
          {
            v20 = *(v15 + 326);
            *buf = 136446978;
            v24 = "nw_protocol_http3_remove_listen_handler";
            v25 = 2082;
            v26 = v15 + 1313;
            v27 = 2080;
            v28 = " ";
            v29 = 1024;
            v30 = v20;
            _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> removing protocol listen handler", buf, 0x26u);
            a2 = v16;
            handle = v15;
          }
        }

        *(handle + 1397) |= 0x8000u;
        *(handle + 138) = 0;
        a2->protocol_handler = 0;
        if ((handle[1397] & 1) != 0 && *(handle + 24))
        {
          if (*(handle + 322) == 3 && !*(handle + 115))
          {
            *(handle + 322) = 1;
            nw_http3_control_stream_process_output(handle);
          }

          else
          {
            handle[1399] |= 1u;
          }
        }

        else
        {
          nw_http3_async_close_connection_if_no_stream(handle);
        }
      }

      else if ((handle[1399] & 0x20) == 0 && gLogDatapath == 1)
      {
        v3 = handle;
        v4 = __nwlog_obj();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          v5 = *(v3 + 326);
          *buf = 136446978;
          v24 = "nw_protocol_http3_remove_listen_handler";
          v25 = 2082;
          v26 = v3 + 1313;
          v27 = 2080;
          v28 = " ";
          v29 = 1024;
          v30 = v5;
          _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> ignoring request to remove http3 listen handler, does not match our handler", buf, 0x26u);
        }
      }

      return 1;
    }

    __nwlog_obj();
    *buf = 136446210;
    v24 = "nw_protocol_http3_remove_listen_handler";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v7, &type, &v21))
    {
      goto LABEL_48;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v24 = "nw_protocol_http3_remove_listen_handler";
        v10 = "%{public}s called with null http3";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    if (v21 != 1)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v24 = "nw_protocol_http3_remove_listen_handler";
        v10 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    backtrace_string = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v14 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *buf = 136446210;
        v24 = "nw_protocol_http3_remove_listen_handler";
        v10 = "%{public}s called with null http3, no backtrace";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    if (v14)
    {
      *buf = 136446466;
      v24 = "nw_protocol_http3_remove_listen_handler";
      v25 = 2082;
      v26 = backtrace_string;
      v13 = "%{public}s called with null http3, dumping backtrace:%{public}s";
      goto LABEL_35;
    }

    goto LABEL_36;
  }

  __nwlog_obj();
  *buf = 136446210;
  v24 = "nw_protocol_http3_remove_listen_handler";
  v7 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (!__nwlog_fault(v7, &type, &v21))
  {
    goto LABEL_48;
  }

  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v21 != 1)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v24 = "nw_protocol_http3_remove_listen_handler";
        v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    backtrace_string = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v12 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *buf = 136446210;
        v24 = "nw_protocol_http3_remove_listen_handler";
        v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    if (v12)
    {
      *buf = 136446466;
      v24 = "nw_protocol_http3_remove_listen_handler";
      v25 = 2082;
      v26 = backtrace_string;
      v13 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_35:
      _os_log_impl(&dword_181A37000, v8, v9, v13, buf, 0x16u);
    }

LABEL_36:
    free(backtrace_string);
    goto LABEL_48;
  }

  v8 = __nwlog_obj();
  v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *buf = 136446210;
    v24 = "nw_protocol_http3_remove_listen_handler";
    v10 = "%{public}s called with null protocol";
LABEL_47:
    _os_log_impl(&dword_181A37000, v8, v9, v10, buf, 0xCu);
  }

LABEL_48:
  if (v7)
  {
    free(v7);
  }

  return 0;
}

BOOL nw_protocol_http3_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2, char a3)
{
  v31 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v22 = "nw_protocol_http3_add_listen_handler";
    v8 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v8, &type, &v19))
    {
      goto LABEL_42;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v19 != 1)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
        {
          goto LABEL_42;
        }

        *buf = 136446210;
        v22 = "nw_protocol_http3_add_listen_handler";
        v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_41;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v13 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
          goto LABEL_42;
        }

        *buf = 136446210;
        v22 = "nw_protocol_http3_add_listen_handler";
        v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_41;
      }

      if (v13)
      {
        *buf = 136446466;
        v22 = "nw_protocol_http3_add_listen_handler";
        v23 = 2082;
        v24 = backtrace_string;
        v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_29:
        _os_log_impl(&dword_181A37000, v9, v10, v14, buf, 0x16u);
      }

LABEL_30:
      free(backtrace_string);
      goto LABEL_42;
    }

    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
    {
      goto LABEL_42;
    }

    *buf = 136446210;
    v22 = "nw_protocol_http3_add_listen_handler";
    v11 = "%{public}s called with null protocol";
LABEL_41:
    _os_log_impl(&dword_181A37000, v9, v10, v11, buf, 0xCu);
LABEL_42:
    if (v8)
    {
      free(v8);
    }

    return 0;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v22 = "nw_protocol_http3_add_listen_handler";
    v8 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v8, &type, &v19))
    {
      goto LABEL_42;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_42;
      }

      *buf = 136446210;
      v22 = "nw_protocol_http3_add_listen_handler";
      v11 = "%{public}s called with null http3";
      goto LABEL_41;
    }

    if (v19 != 1)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
      {
        goto LABEL_42;
      }

      *buf = 136446210;
      v22 = "nw_protocol_http3_add_listen_handler";
      v11 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_41;
    }

    backtrace_string = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v15 = os_log_type_enabled(v9, type);
    if (backtrace_string)
    {
      if (v15)
      {
        *buf = 136446466;
        v22 = "nw_protocol_http3_add_listen_handler";
        v23 = 2082;
        v24 = backtrace_string;
        v14 = "%{public}s called with null http3, dumping backtrace:%{public}s";
        goto LABEL_29;
      }

      goto LABEL_30;
    }

    if (!v15)
    {
      goto LABEL_42;
    }

    *buf = 136446210;
    v22 = "nw_protocol_http3_add_listen_handler";
    v11 = "%{public}s called with null http3, no backtrace";
    goto LABEL_41;
  }

  if (*(handle + 138))
  {
    if ((handle[1399] & 0x20) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      result = os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        v6 = *(handle + 326);
        *buf = 136446978;
        v22 = "nw_protocol_http3_add_listen_handler";
        v23 = 2082;
        v24 = handle + 1313;
        v25 = 2080;
        v26 = " ";
        v27 = 1024;
        v28 = v6;
        _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Already have a listen handler, ignoring add", buf, 0x26u);
        return 0;
      }

      return result;
    }

    return 0;
  }

  *(handle + 138) = a2;
  a2->protocol_handler = handle;
  if (a3)
  {
    *(handle + 1397) |= 0x8000u;
    v7 = a2;
    nw_protocol_remove_instance(handle);
    a2 = v7;
  }

  if ((handle[1399] & 0x20) == 0 && gLogDatapath == 1)
  {
    v16 = a2;
    v17 = __nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      v18 = *(handle + 326);
      *buf = 136447234;
      v22 = "nw_protocol_http3_add_listen_handler";
      v23 = 2082;
      v24 = handle + 1313;
      v25 = 2080;
      v26 = " ";
      v27 = 1024;
      v28 = v18;
      v29 = 2048;
      v30 = v16;
      _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> added protocol listen handler %p", buf, 0x30u);
    }
  }

  return 1;
}

uint64_t nw_protocol_http3_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  v31 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_protocol_http3_get_input_frames";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v7, &type, &v23))
    {
      goto LABEL_18;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_get_input_frames";
      v10 = "%{public}s called with null protocol";
      goto LABEL_48;
    }

    if (v23 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v17 = __nwlog_obj();
      v18 = type;
      v20 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (!v20)
        {
          goto LABEL_38;
        }

        *buf = 136446466;
        v26 = "nw_protocol_http3_get_input_frames";
        v27 = 2082;
        v28 = backtrace_string;
        v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_37;
      }

      if (!v20)
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_get_input_frames";
      v10 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_get_input_frames";
      v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_48:
    v13 = v17;
    v14 = v18;
    v15 = 12;
    goto LABEL_17;
  }

  handle = a1->handle;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!handle)
  {
    *buf = 136446210;
    v26 = "nw_protocol_http3_get_input_frames";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v7, &type, &v23))
    {
      goto LABEL_18;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_get_input_frames";
      v10 = "%{public}s called with null http3";
      goto LABEL_48;
    }

    if (v23 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v17 = __nwlog_obj();
      v18 = type;
      v22 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (!v22)
        {
          goto LABEL_38;
        }

        *buf = 136446466;
        v26 = "nw_protocol_http3_get_input_frames";
        v27 = 2082;
        v28 = backtrace_string;
        v21 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_37:
        _os_log_impl(&dword_181A37000, v17, v18, v21, buf, 0x16u);
LABEL_38:
        free(backtrace_string);
        if (!v7)
        {
          return 0;
        }

        goto LABEL_19;
      }

      if (!v22)
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_get_input_frames";
      v10 = "%{public}s called with null http3, no backtrace";
    }

    else
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_18;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_get_input_frames";
      v10 = "%{public}s called with null http3, backtrace limit exceeded";
    }

    goto LABEL_48;
  }

  *buf = 136446466;
  v26 = "nw_protocol_http3_get_input_frames";
  v27 = 2048;
  v28 = handle;
  v7 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v7, &type, &v23))
  {
    goto LABEL_18;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    v9 = type;
    if (!os_log_type_enabled(gLogObj, type))
    {
      goto LABEL_18;
    }

    *buf = 136446466;
    v26 = "nw_protocol_http3_get_input_frames";
    v27 = 2048;
    v28 = handle;
    v10 = "%{public}s http3 %p called";
LABEL_16:
    v13 = v8;
    v14 = v9;
    v15 = 22;
LABEL_17:
    _os_log_impl(&dword_181A37000, v13, v14, v10, buf, v15);
    goto LABEL_18;
  }

  if (v23 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    v9 = type;
    if (!os_log_type_enabled(gLogObj, type))
    {
      goto LABEL_18;
    }

    *buf = 136446466;
    v26 = "nw_protocol_http3_get_input_frames";
    v27 = 2048;
    v28 = handle;
    v10 = "%{public}s http3 %p called, backtrace limit exceeded";
    goto LABEL_16;
  }

  v11 = __nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = gLogObj;
  v9 = type;
  v12 = os_log_type_enabled(gLogObj, type);
  if (!v11)
  {
    if (!v12)
    {
      goto LABEL_18;
    }

    *buf = 136446466;
    v26 = "nw_protocol_http3_get_input_frames";
    v27 = 2048;
    v28 = handle;
    v10 = "%{public}s http3 %p called, no backtrace";
    goto LABEL_16;
  }

  if (v12)
  {
    *buf = 136446722;
    v26 = "nw_protocol_http3_get_input_frames";
    v27 = 2048;
    v28 = handle;
    v29 = 2082;
    v30 = v11;
    _os_log_impl(&dword_181A37000, v8, v9, "%{public}s http3 %p called, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v11);
LABEL_18:
  if (v7)
  {
LABEL_19:
    free(v7);
  }

  return 0;
}

void nw_protocol_http3_input_available(nw_protocol *a1, nw_protocol *a2)
{
  v33 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_protocol_http3_input_available";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v3, &type, &v23))
    {
      goto LABEL_24;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_24;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_input_available";
      v6 = "%{public}s called with null protocol";
      goto LABEL_22;
    }

    if (v23 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v20 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (!v20)
        {
          goto LABEL_48;
        }

        *buf = 136446466;
        v26 = "nw_protocol_http3_input_available";
        v27 = 2082;
        v28 = backtrace_string;
        v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_47;
      }

      if (!v20)
      {
        goto LABEL_24;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_input_available";
      v6 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_24;
      }

      *buf = 136446210;
      v26 = "nw_protocol_http3_input_available";
      v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_22:
    v11 = v4;
    v12 = v5;
LABEL_23:
    _os_log_impl(&dword_181A37000, v11, v12, v6, buf, 0xCu);
    goto LABEL_24;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((handle[1399] & 0x20) == 0 && gLogDatapath == 1)
    {
      v13 = handle;
      v14 = a2;
      v15 = __nwlog_obj();
      v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
      a2 = v14;
      v17 = v16;
      handle = v13;
      if (v17)
      {
        v18 = v13[326];
        *buf = 136446978;
        v26 = "nw_protocol_http3_input_available";
        v27 = 2082;
        v28 = v13 + 1313;
        v29 = 2080;
        v30 = " ";
        v31 = 1024;
        v32 = v18;
        _os_log_impl(&dword_181A37000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        a2 = v14;
        handle = v13;
      }
    }

    if (*(handle + 133) == a2)
    {
      nw_http3_control_stream_process_input(handle);
      return;
    }

    if (*(handle + 135) == a2)
    {
      nw_http3_encoder_stream_process_input(handle);
      return;
    }

    if (*(handle + 137) == a2)
    {
      nw_http3_decoder_stream_process_input(handle);
      return;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v26 = "nw_protocol_http3_input_available";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v3, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v4 = gLogObj;
        v5 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_24;
        }

        *buf = 136446210;
        v26 = "nw_protocol_http3_input_available";
        v6 = "%{public}s input_available for unknown stream";
        goto LABEL_22;
      }

      if (v23 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v4 = gLogObj;
        v5 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_24;
        }

        *buf = 136446210;
        v26 = "nw_protocol_http3_input_available";
        v6 = "%{public}s input_available for unknown stream, backtrace limit exceeded";
        goto LABEL_22;
      }

      v7 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      v10 = os_log_type_enabled(gLogObj, type);
      if (v7)
      {
        if (v10)
        {
          *buf = 136446466;
          v26 = "nw_protocol_http3_input_available";
          v27 = 2082;
          v28 = v7;
          _os_log_impl(&dword_181A37000, v8, v9, "%{public}s input_available for unknown stream, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v7);
      }

      else if (v10)
      {
        *buf = 136446210;
        v26 = "nw_protocol_http3_input_available";
        v6 = "%{public}s input_available for unknown stream, no backtrace";
        v11 = v8;
        v12 = v9;
        goto LABEL_23;
      }
    }

LABEL_24:
    if (!v3)
    {
      return;
    }

    goto LABEL_25;
  }

  __nwlog_obj();
  *buf = 136446210;
  v26 = "nw_protocol_http3_input_available";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v3, &type, &v23))
  {
    goto LABEL_24;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
    {
      goto LABEL_24;
    }

    *buf = 136446210;
    v26 = "nw_protocol_http3_input_available";
    v6 = "%{public}s called with null http3";
    goto LABEL_22;
  }

  if (v23 != 1)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
    {
      goto LABEL_24;
    }

    *buf = 136446210;
    v26 = "nw_protocol_http3_input_available";
    v6 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_22;
  }

  backtrace_string = __nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = type;
  v22 = os_log_type_enabled(v4, type);
  if (!backtrace_string)
  {
    if (!v22)
    {
      goto LABEL_24;
    }

    *buf = 136446210;
    v26 = "nw_protocol_http3_input_available";
    v6 = "%{public}s called with null http3, no backtrace";
    goto LABEL_22;
  }

  if (!v22)
  {
    goto LABEL_48;
  }

  *buf = 136446466;
  v26 = "nw_protocol_http3_input_available";
  v27 = 2082;
  v28 = backtrace_string;
  v21 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_47:
  _os_log_impl(&dword_181A37000, v4, v5, v21, buf, 0x16u);
LABEL_48:
  free(backtrace_string);
  if (v3)
  {
LABEL_25:
    free(v3);
  }
}

void ___ZL38nw_protocol_http3_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1, uint64_t a2)
{
  v18 = *MEMORY[0x1E69E9840];
  v3 = *(a1 + 32);
  if (!v3 || (*(v3 + 1399) & 0x20) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    v5 = os_log_type_enabled(gLogObj, OS_LOG_TYPE_INFO);
    v3 = *(a1 + 32);
    if (v5)
    {
      v6 = *(v3 + 1304);
      v7 = v3 == 0;
      if (v3)
      {
        v8 = (v3 + 1313);
      }

      else
      {
        v8 = "";
      }

      v10 = 136446978;
      v11 = "nw_protocol_http3_remove_input_handler_block_invoke";
      v12 = 2082;
      v13 = v8;
      if (v7)
      {
        v9 = "";
      }

      else
      {
        v9 = " ";
      }

      v14 = 2080;
      v15 = v9;
      v16 = 1024;
      v17 = v6;
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> tearing down http3 connection", &v10, 0x26u);
      v3 = *(a1 + 32);
    }
  }

  *(v3 + 1397) |= 8u;
  nw_http3_connection_destroy(*(a1 + 32), a2);
}

void ___ZL43nw_http3_stream_reinitialize_as_passthroughP24nw_protocol_http3_stream_block_invoke(uint64_t a1)
{
  v21 = *MEMORY[0x1E69E9840];
  if ((*(*(a1 + 32) + 16))())
  {
    v2 = *(a1 + 40);
    if ((*(v2 + 732) & 0x400) != 0)
    {
      if ((*(v2 + 732) & 0x2000) == 0 && gLogDatapath == 1)
      {
        v4 = __nwlog_obj();
        v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
        v2 = *(a1 + 40);
        if (v5)
        {
          v6 = (v2 + 632);
          v7 = "";
          v8 = *(*(v2 + 344) + 1304);
          v9 = v2 == 0;
          v10 = *(v2 + 240);
          if (v9)
          {
            v6 = "";
          }

          else
          {
            v7 = " ";
          }

          v11 = 136447234;
          v12 = "nw_http3_stream_reinitialize_as_passthrough_block_invoke";
          v13 = 2082;
          v14 = v6;
          v15 = 2080;
          v16 = v7;
          v17 = 1024;
          v18 = v8;
          v19 = 2048;
          v20 = v10;
          _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> delivering deferred input finished", &v11, 0x30u);
          v2 = *(a1 + 40);
        }
      }

      *(v2 + 732) &= ~0x400u;
      input_handler = nw_protocol_get_input_handler(*(a1 + 40));
      nw_protocol_input_finished(input_handler, *(a1 + 40));
    }
  }
}

void nw_http3_notify_viability_changed(uint64_t a1, int a2)
{
  v46 = *MEMORY[0x1E69E9840];
  v2 = *(a1 + 888);
  if (v2)
  {
    v3 = a2;
    v5 = (a1 + 1313);
    if (a2)
    {
      v6 = "";
    }

    else
    {
      v6 = "not ";
    }

    do
    {
      v7 = *(v2 + 536);
      if ((*(v2 + 734) & 2) != 0)
      {
        if ((*(a1 + 1399) & 0x20) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v8 = gLogObj;
          if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_INFO))
          {
            v9 = *(a1 + 1304);
            v10 = *(v2 + 240);
            *buf = 136447490;
            v35 = "nw_http3_notify_viability_changed";
            v36 = 2082;
            v37 = v5;
            v38 = 2080;
            v39 = " ";
            v40 = 1024;
            v41 = v9;
            v42 = 2048;
            v43 = v10;
            v44 = 2082;
            v45 = v6;
            _os_log_impl(&dword_181A37000, v8, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Notifying stream %llu that the connection is %{public}sviable", buf, 0x3Au);
          }
        }

        v33 = v3;
        v11 = *(v2 + 24);
        if (!v11 || (v12 = *(v11 + 160)) == 0)
        {
          __nwlog_obj();
          v13 = *(v2 + 16);
          if (!v13)
          {
            v13 = "invalid";
          }

          *buf = 136446466;
          v35 = "nw_http3_notify_viability_changed";
          v36 = 2082;
          v37 = v13;
          v14 = _os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v31 = 0;
          v30 = v14;
          if (!__nwlog_fault(v14, &type, &v31))
          {
            goto LABEL_37;
          }

          if (type == OS_LOG_TYPE_FAULT)
          {
            v15 = __nwlog_obj();
            v27 = type;
            if (os_log_type_enabled(v15, type))
            {
              v16 = *(v2 + 16);
              if (!v16)
              {
                v16 = "invalid";
              }

              *buf = 136446466;
              v35 = "nw_http3_notify_viability_changed";
              v36 = 2082;
              v37 = v16;
              v17 = v15;
              v18 = v27;
              v19 = "%{public}s protocol %{public}s has invalid notify callback";
              goto LABEL_36;
            }

            goto LABEL_37;
          }

          if (v31 == 1)
          {
            backtrace_string = __nw_create_backtrace_string();
            log = __nwlog_obj();
            v28 = type;
            v21 = os_log_type_enabled(log, type);
            if (backtrace_string)
            {
              if (v21)
              {
                v22 = *(v2 + 16);
                if (!v22)
                {
                  v22 = "invalid";
                }

                *buf = 136446722;
                v35 = "nw_http3_notify_viability_changed";
                v36 = 2082;
                v37 = v22;
                v38 = 2082;
                v39 = backtrace_string;
                _os_log_impl(&dword_181A37000, log, v28, "%{public}s protocol %{public}s has invalid notify callback, dumping backtrace:%{public}s", buf, 0x20u);
              }

              free(backtrace_string);
              goto LABEL_37;
            }

            if (!v21)
            {
LABEL_37:
              if (v30)
              {
                free(v30);
              }

              goto LABEL_6;
            }

            v25 = *(v2 + 16);
            if (!v25)
            {
              v25 = "invalid";
            }

            *buf = 136446466;
            v35 = "nw_http3_notify_viability_changed";
            v36 = 2082;
            v37 = v25;
            v17 = log;
            v18 = v28;
            v19 = "%{public}s protocol %{public}s has invalid notify callback, no backtrace";
          }

          else
          {
            v23 = __nwlog_obj();
            v29 = type;
            if (!os_log_type_enabled(v23, type))
            {
              goto LABEL_37;
            }

            v24 = *(v2 + 16);
            if (!v24)
            {
              v24 = "invalid";
            }

            *buf = 136446466;
            v35 = "nw_http3_notify_viability_changed";
            v36 = 2082;
            v37 = v24;
            v17 = v23;
            v18 = v29;
            v19 = "%{public}s protocol %{public}s has invalid notify callback, backtrace limit exceeded";
          }

LABEL_36:
          _os_log_impl(&dword_181A37000, v17, v18, v19, buf, 0x16u);
          goto LABEL_37;
        }

        v12(v2, v2, 18, &v33, 1);
      }

LABEL_6:
      v2 = v7;
    }

    while (v7);
  }
}

void ___ZL41nw_http3_passthrough_stream_get_callbacksv_block_invoke()
{
  qword_1EA842AC0 = nw_protocol_default_input_flush;
  qword_1EA842A20 = nw_protocol_default_link_state;
  qword_1EA842A38 = nw_protocol_default_get_local;
  qword_1EA842A30 = nw_protocol_default_get_path;
  qword_1EA842A60 = nw_protocol_default_updated_path;
  qword_1EA842A80 = nw_protocol_default_get_output_local;
  qword_1EA842A88 = nw_protocol_default_get_output_interface;
  qword_1EA842AB8 = nw_protocol_default_reset;
  qword_1EA842A90 = nw_protocol_default_waiting_for_output;
  qword_1EA842A48 = nw_protocol_default_register_notification;
  qword_1EA842A50 = nw_protocol_default_unregister_notification;
  qword_1EA8429D0 = nw_protocol_http3_stream_connect;
  qword_1EA8429E0 = nw_protocol_http3_stream_connected;
  qword_1EA8429D8 = nw_protocol_http3_stream_disconnect;
  qword_1EA8429E8 = nw_protocol_http3_stream_disconnected;
  qword_1EA8429F0 = nw_protocol_http3_stream_error;
  nw_http3_passthrough_stream_get_callbacks(void)::protocol_callbacks = nw_protocol_http3_stream_add_input_handler;
  qword_1EA8429C0 = nw_protocol_http3_stream_remove_input_handler;
  qword_1EA8429C8 = nw_protocol_http3_stream_replace_input_handler;
  qword_1EA842A68 = nw_protocol_http3_stream_supports_external_data;
  qword_1EA842AA0 = nw_protocol_http3_stream_add_listen_handler;
  qword_1EA842AA8 = nw_protocol_http3_stream_remove_listen_handler;
  qword_1EA842A40 = nw_protocol_http3_stream_get_remote_endpoint;
  qword_1EA842A98 = nw_protocol_http3_stream_copy_info;
  qword_1EA842A58 = nw_protocol_http3_stream_notify;
  qword_1EA842AB0 = nw_protocol_http3_stream_get_message_properties;
  qword_1EA8429F8 = nw_http3_passthrough_stream_input_available;
  qword_1EA842A00 = nw_http3_passthrough_stream_output_available;
  qword_1EA842A78 = nw_http3_passthrough_stream_output_finished;
  qword_1EA842A70 = nw_http3_passthrough_stream_input_finished;
  qword_1EA842A08 = nw_http3_passthrough_stream_get_input_frames;
  qword_1EA842A10 = nw_http3_passthrough_stream_get_output_frames;
  qword_1EA842A18 = nw_http3_passthrough_stream_finalize_output_frames;
  qword_1EA842A28 = nw_http3_passthrough_stream_get_parameters;
}

uint64_t nw_http3_passthrough_stream_get_parameters(nw_protocol *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if (handle + 64 == a1)
      {
        v3 = a1->handle;

        return nw_http3_stream_get_datagram_parameters(v3);
      }

      else
      {
        if ((*(handle + 366) & 0x4000) == 0)
        {
          if (*(handle + 4))
          {
            nw_http3_fix_quic_parameters(*(handle + 43), *(handle + 45), *(handle + 156) == 1, 0);
            *(handle + 366) |= 0x4000u;
          }
        }

        return *(handle + 45);
      }
    }

    __nwlog_obj();
    *buf = 136446210;
    v15 = "nw_http3_passthrough_stream_get_parameters";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
    {
      goto LABEL_39;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v15 = "nw_http3_passthrough_stream_get_parameters";
        v7 = "%{public}s called with null http3_stream";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (v12 != 1)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v15 = "nw_http3_passthrough_stream_get_parameters";
        v7 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    backtrace_string = __nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v11 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *buf = 136446210;
        v15 = "nw_http3_passthrough_stream_get_parameters";
        v7 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (v11)
    {
      *buf = 136446466;
      v15 = "nw_http3_passthrough_stream_get_parameters";
      v16 = 2082;
      v17 = backtrace_string;
      v10 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_28;
    }

    goto LABEL_29;
  }

  __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_http3_passthrough_stream_get_parameters";
  v4 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12))
  {
    goto LABEL_39;
  }

  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v12 != 1)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v15 = "nw_http3_passthrough_stream_get_parameters";
        v7 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    backtrace_string = __nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v9)
      {
        *buf = 136446210;
        v15 = "nw_http3_passthrough_stream_get_parameters";
        v7 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (v9)
    {
      *buf = 136446466;
      v15 = "nw_http3_passthrough_stream_get_parameters";
      v16 = 2082;
      v17 = backtrace_string;
      v10 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_28:
      _os_log_impl(&dword_181A37000, v5, v6, v10, buf, 0x16u);
    }

LABEL_29:
    free(backtrace_string);
    goto LABEL_39;
  }

  v5 = __nwlog_obj();
  v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *buf = 136446210;
    v15 = "nw_http3_passthrough_stream_get_parameters";
    v7 = "%{public}s called with null protocol";
LABEL_38:
    _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0xCu);
  }

LABEL_39:
  if (v4)
  {
    free(v4);
  }

  return 0;
}

uint64_t nw_http3_stream_get_datagram_parameters(uint64_t a1)
{
  v42 = *MEMORY[0x1E69E9840];
  if (*(a1 + 368))
  {
LABEL_2:
    if ((*(a1 + 732) & 0x2000) == 0 && gLogDatapath == 1)
    {
      v18 = __nwlog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        v19 = *(*(a1 + 344) + 1304);
        v20 = *(a1 + 240);
        v21 = *(a1 + 368);
        *buf = 136447490;
        v31 = "nw_http3_stream_get_datagram_parameters";
        v32 = 2082;
        v33 = (a1 + 632);
        v34 = 2080;
        v35 = " ";
        v36 = 1024;
        v37 = v19;
        v38 = 2048;
        v39 = v20;
        v40 = 2048;
        v41 = v21;
        _os_log_impl(&dword_181A37000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> returning datagram parameters %p", buf, 0x3Au);
      }
    }

    return *(a1 + 368);
  }

  v3 = *(a1 + 360);
  if (v3)
  {
    v4 = _nw_parameters_shallow_copy(v3, 1);
    *(a1 + 368) = v4;
    v5 = *(a1 + 32);
    if (v5)
    {
      v6 = nw_parameters_copy_protocol_options_legacy(v4, *(a1 + 32));
      if (v6)
      {
        v7 = v6;
        if (_nw_protocol_options_is_quic_stream(v6))
        {
          v8 = _nw_protocol_options_copy(v7);
          nw_quic_stream_set_is_unidirectional(v8, 0);
          nw_quic_stream_set_is_datagram(v8, 1);
          nw_quic_stream_set_associated_stream_id(v8, *(a1 + 240));
          nw_quic_stream_set_datagram_context_id(v8, *(a1 + 256));
          nw_protocol_http3_add_alpn_to_quic_options(v8);
          if (nw_protocol_copy_quic_stream_definition_onceToken != -1)
          {
            dispatch_once(&nw_protocol_copy_quic_stream_definition_onceToken, &__block_literal_global_63);
          }

          v9 = nw_protocol_copy_quic_stream_definition_quic_definition;
          nw_parameters_set_protocol_instance(v8, v10, v5);
          if (v9)
          {
            os_release(v9);
          }

          nw_protocol_options_inherit_log_id(v7, v8);
          nw_protocol_options_set_prohibit_joining(v8);
          v11 = nw_parameters_copy_default_protocol_stack(*(a1 + 368));
          nw_protocol_stack_replace_protocol_with_handle(v11, v5, v8);
          if (v11)
          {
            os_release(v11);
          }

          if (v8)
          {
            os_release(v8);
          }
        }

        os_release(v7);
      }

      goto LABEL_2;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446466;
    v31 = "nw_http3_stream_get_datagram_parameters";
    v32 = 2048;
    v33 = a1;
    v12 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v12, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v14 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_32;
        }

        *buf = 136446466;
        v31 = "nw_http3_stream_get_datagram_parameters";
        v32 = 2048;
        v33 = a1;
        v15 = "%{public}s no output handler on http3 stream %p yet, cannot create datagram parameters";
        goto LABEL_31;
      }

      if (v28 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v14 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_32;
        }

        *buf = 136446466;
        v31 = "nw_http3_stream_get_datagram_parameters";
        v32 = 2048;
        v33 = a1;
        v15 = "%{public}s no output handler on http3 stream %p yet, cannot create datagram parameters, backtrace limit exceeded";
        goto LABEL_31;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      v17 = os_log_type_enabled(gLogObj, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *buf = 136446722;
          v31 = "nw_http3_stream_get_datagram_parameters";
          v32 = 2048;
          v33 = a1;
          v34 = 2082;
          v35 = backtrace_string;
          _os_log_impl(&dword_181A37000, v13, v14, "%{public}s no output handler on http3 stream %p yet, cannot create datagram parameters, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(backtrace_string);
        goto LABEL_32;
      }

      if (v17)
      {
        *buf = 136446466;
        v31 = "nw_http3_stream_get_datagram_parameters";
        v32 = 2048;
        v33 = a1;
        v15 = "%{public}s no output handler on http3 stream %p yet, cannot create datagram parameters, no backtrace";
LABEL_31:
        _os_log_impl(&dword_181A37000, v13, v14, v15, buf, 0x16u);
      }
    }

LABEL_32:
    if (v12)
    {
      free(v12);
    }

    goto LABEL_2;
  }

  __nwlog_obj();
  *buf = 136446210;
  v31 = "nw_http3_stream_get_datagram_parameters";
  v22 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v28 = 0;
  if (__nwlog_fault(v22, &type, &v28))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v31 = "nw_http3_stream_get_datagram_parameters";
        v25 = "%{public}s called with null http3_stream->parameters";
LABEL_49:
        _os_log_impl(&dword_181A37000, v23, v24, v25, buf, 0xCu);
      }
    }

    else if (v28 == 1)
    {
      v26 = __nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = type;
      v27 = os_log_type_enabled(v23, type);
      if (v26)
      {
        if (v27)
        {
          *buf = 136446466;
          v31 = "nw_http3_stream_get_datagram_parameters";
          v32 = 2082;
          v33 = v26;
          _os_log_impl(&dword_181A37000, v23, v24, "%{public}s called with null http3_stream->parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v26);
        goto LABEL_50;
      }

      if (v27)
      {
        *buf = 136446210;
        v31 = "nw_http3_stream_get_datagram_parameters";
        v25 = "%{public}s called with null http3_stream->parameters, no backtrace";
        goto LABEL_49;
      }
    }

    else
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v31 = "nw_http3_stream_get_datagram_parameters";
        v25 = "%{public}s called with null http3_stream->parameters, backtrace limit exceeded";
        goto LABEL_49;
      }
    }
  }

LABEL_50:
  if (v22)
  {
    free(v22);
  }

  return 0;
}

void ___ZL28nw_http3_fix_quic_parametersP17nw_protocol_http3P13nw_parametersbb_block_invoke(uint64_t a1, NSObject *a2, NSObject *a3)
{
  v28 = *MEMORY[0x1E69E9840];
  v5 = (*(*(a1 + 32) + 16))();
  if (v5)
  {
    v6 = v5;
    if ((*(v5 + 1399) & 0x20) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_INFO))
      {
        v8 = *(v6 + 1304);
        *buf = 136446978;
        *&buf[4] = "nw_http3_fix_quic_parameters_block_invoke";
        *&buf[12] = 2082;
        *&buf[14] = v6 + 1313;
        *&buf[22] = 2080;
        v25 = " ";
        LOWORD(v26) = 1024;
        *(&v26 + 2) = v8;
        _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> received new TLS session ticket", buf, 0x26u);
      }
    }

    v9 = *(v6 + 1176);
    if (v9)
    {
      dispatch_release(v9);
      *(v6 + 1176) = 0;
    }

    v10 = *(v6 + 1184);
    if (v10)
    {
      dispatch_release(v10);
      *(v6 + 1184) = 0;
    }

    dispatch_retain(a2);
    dispatch_retain(a3);
    *(v6 + 1176) = a2;
    *(v6 + 1184) = a3;
    if (*(v6 + 856) && *(v6 + 864))
    {
      v11 = *(v6 + 1192);
      if (!v11)
      {
        v11 = *(v6 + 1168);
      }

      v12 = 0;
      v13 = &v20;
      v20 = 0;
      v21 = &v20;
      v22 = 0x2000000000;
      if (a3 && a2 && v11)
      {
        *buf = 0;
        alloc = dispatch_data_create_alloc();
        v15 = *buf;
        **buf = 9685181;
        v15[1] = dispatch_data_get_size(v11);
        v15[2] = dispatch_data_get_size(a2);
        v15[3] = dispatch_data_get_size(a3);
        concat = dispatch_data_create_concat(alloc, v11);
        if (alloc)
        {
          dispatch_release(alloc);
        }

        v17 = dispatch_data_create_concat(concat, a2);
        if (concat)
        {
          dispatch_release(concat);
        }

        v12 = dispatch_data_create_concat(v17, a3);
        if (v17)
        {
          dispatch_release(v17);
        }

        v13 = v21;
      }

      v23 = v12;
      if (v13[3])
      {
        *buf = 0;
        *&buf[8] = buf;
        *&buf[16] = 0x3002000000;
        v25 = __Block_byref_object_copy__97;
        v26 = __Block_byref_object_dispose__98;
        v27 = _Block_copy(*(v6 + 856));
        v18 = *(v6 + 864);
        v19[0] = MEMORY[0x1E69E9820];
        v19[1] = 0x40000000;
        v19[2] = ___ZL28nw_http3_fix_quic_parametersP17nw_protocol_http3P13nw_parametersbb_block_invoke_99;
        v19[3] = &unk_1E6A38DA8;
        v19[4] = buf;
        v19[5] = &v20;
        dispatch_async(v18, v19);
        _Block_object_dispose(buf, 8);
      }

      _Block_object_dispose(&v20, 8);
    }

    else
    {
      nw_http3_try_persist_0rtt_state(v6);
    }
  }
}

void ___ZL28nw_http3_fix_quic_parametersP17nw_protocol_http3P13nw_parametersbb_block_invoke_99(uint64_t a1)
{
  (*(*(*(*(a1 + 32) + 8) + 40) + 16))();
  v2 = *(*(*(a1 + 32) + 8) + 40);
  if (v2)
  {
    _Block_release(v2);
    *(*(*(a1 + 32) + 8) + 40) = 0;
  }

  v3 = *(*(*(a1 + 40) + 8) + 24);
  if (v3)
  {
    dispatch_release(v3);
    *(*(*(a1 + 40) + 8) + 24) = 0;
  }
}

uint64_t nw_http3_passthrough_stream_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  v76 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
    v44 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__src) = 0;
    if (!__nwlog_fault(v44, type, &__src))
    {
      goto LABEL_148;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v45 = __nwlog_obj();
      v46 = type[0];
      if (!os_log_type_enabled(v45, type[0]))
      {
        goto LABEL_148;
      }

      *buf = 136446210;
      *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
      v47 = "%{public}s called with null protocol";
      goto LABEL_147;
    }

    if (__src != 1)
    {
      v45 = __nwlog_obj();
      v46 = type[0];
      if (!os_log_type_enabled(v45, type[0]))
      {
        goto LABEL_148;
      }

      *buf = 136446210;
      *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
      v47 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_147;
    }

    backtrace_string = __nw_create_backtrace_string();
    v45 = __nwlog_obj();
    v46 = type[0];
    v52 = os_log_type_enabled(v45, type[0]);
    if (!backtrace_string)
    {
      if (!v52)
      {
        goto LABEL_148;
      }

      *buf = 136446210;
      *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
      v47 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_147;
    }

    if (!v52)
    {
      goto LABEL_108;
    }

    *buf = 136446466;
    *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
    *&buf[12] = 2082;
    *&buf[14] = backtrace_string;
    v53 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_107:
    _os_log_impl(&dword_181A37000, v45, v46, v53, buf, 0x16u);
    goto LABEL_108;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
    v44 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__src) = 0;
    if (!__nwlog_fault(v44, type, &__src))
    {
      goto LABEL_148;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v45 = __nwlog_obj();
      v46 = type[0];
      if (!os_log_type_enabled(v45, type[0]))
      {
        goto LABEL_148;
      }

      *buf = 136446210;
      *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
      v47 = "%{public}s called with null http3_stream";
      goto LABEL_147;
    }

    if (__src != 1)
    {
      v45 = __nwlog_obj();
      v46 = type[0];
      if (!os_log_type_enabled(v45, type[0]))
      {
        goto LABEL_148;
      }

      *buf = 136446210;
      *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
      v47 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_147;
    }

    backtrace_string = __nw_create_backtrace_string();
    v45 = __nwlog_obj();
    v46 = type[0];
    v54 = os_log_type_enabled(v45, type[0]);
    if (!backtrace_string)
    {
      if (!v54)
      {
        goto LABEL_148;
      }

      *buf = 136446210;
      *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
      v47 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_147;
    }

    if (!v54)
    {
      goto LABEL_108;
    }

    *buf = 136446466;
    *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
    *&buf[12] = 2082;
    *&buf[14] = backtrace_string;
    v53 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
    goto LABEL_107;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
    v44 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__src) = 0;
    if (!__nwlog_fault(v44, type, &__src))
    {
      goto LABEL_148;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v45 = __nwlog_obj();
      v46 = type[0];
      if (!os_log_type_enabled(v45, type[0]))
      {
        goto LABEL_148;
      }

      *buf = 136446210;
      *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
      v47 = "%{public}s called with null frames";
      goto LABEL_147;
    }

    if (__src != 1)
    {
      v45 = __nwlog_obj();
      v46 = type[0];
      if (!os_log_type_enabled(v45, type[0]))
      {
        goto LABEL_148;
      }

      *buf = 136446210;
      *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
      v47 = "%{public}s called with null frames, backtrace limit exceeded";
      goto LABEL_147;
    }

    backtrace_string = __nw_create_backtrace_string();
    v45 = __nwlog_obj();
    v46 = type[0];
    v55 = os_log_type_enabled(v45, type[0]);
    if (!backtrace_string)
    {
      if (!v55)
      {
        goto LABEL_148;
      }

      *buf = 136446210;
      *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
      v47 = "%{public}s called with null frames, no backtrace";
      goto LABEL_147;
    }

    if (!v55)
    {
      goto LABEL_108;
    }

    *buf = 136446466;
    *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
    *&buf[12] = 2082;
    *&buf[14] = backtrace_string;
    v53 = "%{public}s called with null frames, dumping backtrace:%{public}s";
    goto LABEL_107;
  }

  if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v48 = __nwlog_obj();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
    {
      v49 = *(*(handle + 43) + 1304);
      v50 = *(handle + 30);
      *buf = 136447234;
      *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
      *&buf[12] = 2082;
      *&buf[14] = handle + 632;
      *&buf[22] = 2080;
      *v72 = " ";
      *&v72[8] = 1024;
      v73 = v49;
      v74 = 2048;
      v75 = v50;
      _os_log_impl(&dword_181A37000, v48, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
    }
  }

  v5 = *(handle + 156);
  if (v5 == 1)
  {
    v6 = 84;
    goto LABEL_26;
  }

  if (v5 == 2)
  {
    v5 = 1;
    v6 = 65;
    goto LABEL_26;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446210;
  *&buf[4] = "nw_http3_stream_get_stream_header_type";
  v7 = _os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(__src) = 0;
  if (__nwlog_fault(v7, type, &__src))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type[0];
      if (os_log_type_enabled(gLogObj, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http3_stream_get_stream_header_type";
        v10 = "%{public}s invalid stream mode";
LABEL_21:
        v15 = v8;
        v16 = v9;
LABEL_22:
        _os_log_impl(&dword_181A37000, v15, v16, v10, buf, 0xCu);
      }
    }

    else if (__src == 1)
    {
      v11 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type[0];
      v14 = os_log_type_enabled(gLogObj, type[0]);
      if (v11)
      {
        if (v14)
        {
          *buf = 136446466;
          *&buf[4] = "nw_http3_stream_get_stream_header_type";
          *&buf[12] = 2082;
          *&buf[14] = v11;
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s invalid stream mode, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v11);
        goto LABEL_23;
      }

      if (v14)
      {
        *buf = 136446210;
        *&buf[4] = "nw_http3_stream_get_stream_header_type";
        v10 = "%{public}s invalid stream mode, no backtrace";
        v15 = v12;
        v16 = v13;
        goto LABEL_22;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type[0];
      if (os_log_type_enabled(gLogObj, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http3_stream_get_stream_header_type";
        v10 = "%{public}s invalid stream mode, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
  }

LABEL_23:
  if (v7)
  {
    free(v7);
  }

  v5 = 0;
  v6 = -1;
LABEL_26:
  if ((*(handle + 30) & 1) != (*(*(handle + 43) + 1397) & 1) || (handle[734] & 0xC0) != 0x40)
  {
LABEL_74:
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2000000000;
    v72[0] = 0;
    v59[0] = MEMORY[0x1E69E9820];
    v59[1] = 0x40000000;
    v60 = ___ZL50nw_http3_passthrough_stream_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
    v61 = &unk_1E6A39248;
    v62 = buf;
    v63 = handle;
    tqh_first = a2->tqh_first;
    do
    {
      if (!tqh_first)
      {
        break;
      }

      v41 = *(tqh_first + 4);
      v42 = (v60)(v59);
      tqh_first = v41;
    }

    while ((v42 & 1) != 0);
    v43 = nw_protocol_common_finalize_output_frames(a1, a2);
    if (*(*&buf[8] + 24) == 1)
    {
      nw_protocol_output_finished(a1->output_handler->flow_id, a1);
    }

    _Block_object_dispose(buf, 8);
    return v43;
  }

  __src = 0;
  *type = 0;
  v70 = 0;
  if (v5)
  {
    __src = bswap32(v6 | 0x4000) >> 16;
    v17 = 2;
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446466;
    *&buf[4] = "_http_vle_encode";
    *&buf[12] = 2048;
    *&buf[14] = v6;
    v18 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v18);
    if (result)
    {
      goto LABEL_151;
    }

    free(v18);
    v17 = 0;
  }

  v20 = v17;
  memcpy(type, &__src, v17);
  v21 = *(handle + 33);
  if (v21 <= 0x3F)
  {
    __src = *(handle + 33);
    v22 = 1;
LABEL_44:
    memcpy((type | v20), &__src, v22);
    v25 = v22 + v20;
    v26 = a2->tqh_first;
    if (nw_frame_uses_external_data(a2->tqh_first))
    {
      nw_frame_unclaim(v26, v27, 0, v25);
      offset = 0;
      v28 = nw_frame_copy_external_data(v26, &offset + 1, &offset);
      v29 = v28;
      if (HIDWORD(offset))
      {
        subrange = dispatch_data_create_subrange(v28, HIDWORD(offset), 0xFFFFFFFFFFFFFFFFLL);
        if (v29)
        {
          dispatch_release(v29);
        }
      }

      else
      {
        subrange = v28;
      }

      if (subrange)
      {
        v32 = dispatch_data_create(type, v25, 0, 0);
        concat = dispatch_data_create_concat(v32, subrange);
        if (v32)
        {
          dispatch_release(v32);
        }

        dispatch_release(subrange);
        *v65 = 0;
        nw_frame_set_external_data(v26, concat, v65);
        if (concat)
        {
          dispatch_release(concat);
        }

        if (*v65 == offset)
        {
          goto LABEL_73;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *buf = 136446722;
        *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
        *&buf[12] = 1024;
        *&buf[14] = *v65;
        *&buf[18] = 1024;
        *&buf[20] = offset;
        v34 = _os_log_send_and_compose_impl();
        v66 = OS_LOG_TYPE_ERROR;
        v64 = 0;
        if (!__nwlog_fault(v34, &v66, &v64))
        {
          goto LABEL_71;
        }

        if (v66 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v35 = gLogObj;
          v36 = v66;
          if (!os_log_type_enabled(gLogObj, v66))
          {
            goto LABEL_71;
          }

          *buf = 136446722;
          *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
          *&buf[12] = 1024;
          *&buf[14] = *v65;
          *&buf[18] = 1024;
          *&buf[20] = offset;
          v37 = "%{public}s Incorrect frame length set: %u != %u";
        }

        else if (v64 == 1)
        {
          v38 = __nw_create_backtrace_string();
          v35 = __nwlog_obj();
          v36 = v66;
          v39 = os_log_type_enabled(v35, v66);
          if (v38)
          {
            if (v39)
            {
              *buf = 136446978;
              *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
              *&buf[12] = 1024;
              *&buf[14] = *v65;
              *&buf[18] = 1024;
              *&buf[20] = offset;
              *v72 = 2082;
              *&v72[2] = v38;
              _os_log_impl(&dword_181A37000, v35, v36, "%{public}s Incorrect frame length set: %u != %u, dumping backtrace:%{public}s", buf, 0x22u);
            }

            free(v38);
            goto LABEL_71;
          }

          if (!v39)
          {
LABEL_71:
            if (v34)
            {
              free(v34);
            }

            goto LABEL_73;
          }

          *buf = 136446722;
          *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
          *&buf[12] = 1024;
          *&buf[14] = *v65;
          *&buf[18] = 1024;
          *&buf[20] = offset;
          v37 = "%{public}s Incorrect frame length set: %u != %u, no backtrace";
        }

        else
        {
          v35 = __nwlog_obj();
          v36 = v66;
          if (!os_log_type_enabled(v35, v66))
          {
            goto LABEL_71;
          }

          *buf = 136446722;
          *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
          *&buf[12] = 1024;
          *&buf[14] = *v65;
          *&buf[18] = 1024;
          *&buf[20] = offset;
          v37 = "%{public}s Incorrect frame length set: %u != %u, backtrace limit exceeded";
        }

        _os_log_impl(&dword_181A37000, v35, v36, v37, buf, 0x18u);
        goto LABEL_71;
      }

      __nwlog_obj();
      *buf = 136446210;
      *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
      v44 = _os_log_send_and_compose_impl();
      v65[0] = OS_LOG_TYPE_ERROR;
      v66 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v44, v65, &v66))
      {
        if (v65[0] == OS_LOG_TYPE_FAULT)
        {
          v45 = __nwlog_obj();
          v46 = v65[0];
          if (!os_log_type_enabled(v45, v65[0]))
          {
            goto LABEL_148;
          }

          *buf = 136446210;
          *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
          v47 = "%{public}s called with null external_data";
          goto LABEL_147;
        }

        if (v66 != OS_LOG_TYPE_INFO)
        {
          v45 = __nwlog_obj();
          v46 = v65[0];
          if (!os_log_type_enabled(v45, v65[0]))
          {
            goto LABEL_148;
          }

          *buf = 136446210;
          *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
          v47 = "%{public}s called with null external_data, backtrace limit exceeded";
          goto LABEL_147;
        }

        backtrace_string = __nw_create_backtrace_string();
        v45 = __nwlog_obj();
        v46 = v65[0];
        v58 = os_log_type_enabled(v45, v65[0]);
        if (!backtrace_string)
        {
          if (!v58)
          {
            goto LABEL_148;
          }

          *buf = 136446210;
          *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
          v47 = "%{public}s called with null external_data, no backtrace";
          goto LABEL_147;
        }

        if (v58)
        {
          *buf = 136446466;
          *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          v53 = "%{public}s called with null external_data, dumping backtrace:%{public}s";
          goto LABEL_107;
        }

LABEL_108:
        free(backtrace_string);
      }

LABEL_148:
      if (!v44)
      {
        return 0;
      }

LABEL_149:
      free(v44);
      return 0;
    }

    nw_frame_unclaim(v26, v27, v25, 0);
    HIDWORD(offset) = 0;
    v31 = nw_frame_unclaimed_bytes(v26, &offset + 1);
    if (v31)
    {
      memcpy(v31, type, v25);
LABEL_73:
      handle[734] |= 0x80u;
      goto LABEL_74;
    }

    __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
    v44 = _os_log_send_and_compose_impl();
    LOBYTE(offset) = 16;
    v65[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v44, &offset, v65))
    {
      goto LABEL_148;
    }

    if (offset == 17)
    {
      v45 = __nwlog_obj();
      v46 = offset;
      if (!os_log_type_enabled(v45, offset))
      {
        goto LABEL_148;
      }

      *buf = 136446210;
      *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
      v47 = "%{public}s called with null unclaimed_bytes";
    }

    else
    {
      if (v65[0] != OS_LOG_TYPE_INFO)
      {
        v45 = __nwlog_obj();
        v46 = offset;
        if (!os_log_type_enabled(v45, offset))
        {
          goto LABEL_148;
        }

        *buf = 136446210;
        *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
        v47 = "%{public}s called with null unclaimed_bytes, backtrace limit exceeded";
        goto LABEL_147;
      }

      v56 = __nw_create_backtrace_string();
      v45 = __nwlog_obj();
      v46 = offset;
      v57 = os_log_type_enabled(v45, offset);
      if (v56)
      {
        if (v57)
        {
          *buf = 136446466;
          *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
          *&buf[12] = 2082;
          *&buf[14] = v56;
          _os_log_impl(&dword_181A37000, v45, v46, "%{public}s called with null unclaimed_bytes, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v56);
        if (!v44)
        {
          return 0;
        }

        goto LABEL_149;
      }

      if (!v57)
      {
        goto LABEL_148;
      }

      *buf = 136446210;
      *&buf[4] = "nw_http3_passthrough_stream_finalize_output_frames";
      v47 = "%{public}s called with null unclaimed_bytes, no backtrace";
    }

LABEL_147:
    _os_log_impl(&dword_181A37000, v45, v46, v47, buf, 0xCu);
    goto LABEL_148;
  }

  if (!(v21 >> 14))
  {
    __src = bswap32(v21 | 0x4000) >> 16;
    v22 = 2;
    goto LABEL_44;
  }

  if (!(v21 >> 30))
  {
    __src = bswap32(v21 | 0x80000000);
    v22 = 4;
    goto LABEL_44;
  }

  if (!(v21 >> 62))
  {
    __src = bswap64(v21 | 0xC000000000000000);
    v22 = 8;
    goto LABEL_44;
  }

  v23 = __nwlog_obj();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  *buf = 136446466;
  *&buf[4] = "_http_vle_encode";
  *&buf[12] = 2048;
  *&buf[14] = v21;
  v24 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v24);
  if (!result)
  {
    free(v24);
    v22 = 0;
    goto LABEL_44;
  }

LABEL_151:
  __break(1u);
  return result;
}

uint64_t ___ZL50nw_http3_passthrough_stream_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  v28 = *MEMORY[0x1E69E9840];
  is_metadata_complete = nw_frame_is_metadata_complete(a2);
  if (is_metadata_complete)
  {
    *(a2 + 186) |= 0x80u;
    v5 = *(a1 + 40);
    if ((!v5 || (*(v5 + 732) & 0x2000) == 0) && gLogDatapath == 1)
    {
      v7 = is_metadata_complete;
      v8 = __nwlog_obj();
      v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG);
      is_metadata_complete = v7;
      if (v9)
      {
        v10 = *(a1 + 40);
        v11 = (v10 + 632);
        v12 = "";
        v13 = v10 == 0;
        if (!v10)
        {
          v11 = "";
        }

        v14 = *(*(v10 + 344) + 1304);
        v15 = *(v10 + 240);
        if (!v13)
        {
          v12 = " ";
        }

        v16 = 136447490;
        v17 = "nw_http3_passthrough_stream_finalize_output_frames_block_invoke";
        v18 = 2082;
        v19 = v11;
        v20 = 2080;
        v21 = v12;
        v22 = 1024;
        v23 = v14;
        v24 = 2048;
        v25 = v15;
        v26 = 2048;
        v27 = a2;
        _os_log_impl(&dword_181A37000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> Frame %p marked as metadata complete, sending output_finished", &v16, 0x3Au);
        is_metadata_complete = v7;
      }
    }

    *(*(*(a1 + 32) + 8) + 24) = 1;
  }

  return is_metadata_complete ^ 1u;
}

uint64_t nw_http3_passthrough_stream_get_output_frames(nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  v77 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v70 = "nw_http3_passthrough_stream_get_output_frames";
    v38 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v67 = 0;
    if (!__nwlog_fault(v38, &type, &v67))
    {
      goto LABEL_105;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
      {
        goto LABEL_105;
      }

      *buf = 136446210;
      v70 = "nw_http3_passthrough_stream_get_output_frames";
      v41 = "%{public}s called with null protocol";
      goto LABEL_104;
    }

    if (v67 != 1)
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
      {
        goto LABEL_105;
      }

      *buf = 136446210;
      v70 = "nw_http3_passthrough_stream_get_output_frames";
      v41 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_104;
    }

    backtrace_string = __nw_create_backtrace_string();
    v39 = __nwlog_obj();
    v40 = type;
    v50 = os_log_type_enabled(v39, type);
    if (!backtrace_string)
    {
      if (!v50)
      {
        goto LABEL_105;
      }

      *buf = 136446210;
      v70 = "nw_http3_passthrough_stream_get_output_frames";
      v41 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_104;
    }

    if (!v50)
    {
      goto LABEL_89;
    }

    *buf = 136446466;
    v70 = "nw_http3_passthrough_stream_get_output_frames";
    v71 = 2082;
    *v72 = backtrace_string;
    v51 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_88:
    _os_log_impl(&dword_181A37000, v39, v40, v51, buf, 0x16u);
    goto LABEL_89;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v70 = "nw_http3_passthrough_stream_get_output_frames";
    v38 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v67 = 0;
    if (!__nwlog_fault(v38, &type, &v67))
    {
      goto LABEL_105;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
      {
        goto LABEL_105;
      }

      *buf = 136446210;
      v70 = "nw_http3_passthrough_stream_get_output_frames";
      v41 = "%{public}s called with null http3_stream";
      goto LABEL_104;
    }

    if (v67 != 1)
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
      {
        goto LABEL_105;
      }

      *buf = 136446210;
      v70 = "nw_http3_passthrough_stream_get_output_frames";
      v41 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_104;
    }

    backtrace_string = __nw_create_backtrace_string();
    v39 = __nwlog_obj();
    v40 = type;
    v52 = os_log_type_enabled(v39, type);
    if (!backtrace_string)
    {
      if (!v52)
      {
        goto LABEL_105;
      }

      *buf = 136446210;
      v70 = "nw_http3_passthrough_stream_get_output_frames";
      v41 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_104;
    }

    if (!v52)
    {
      goto LABEL_89;
    }

    *buf = 136446466;
    v70 = "nw_http3_passthrough_stream_get_output_frames";
    v71 = 2082;
    *v72 = backtrace_string;
    v51 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
    goto LABEL_88;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v70 = "nw_http3_passthrough_stream_get_output_frames";
    v38 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v67 = 0;
    if (!__nwlog_fault(v38, &type, &v67))
    {
      goto LABEL_105;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
      {
        goto LABEL_105;
      }

      *buf = 136446210;
      v70 = "nw_http3_passthrough_stream_get_output_frames";
      v41 = "%{public}s called with null input_protocol";
      goto LABEL_104;
    }

    if (v67 != 1)
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
      {
        goto LABEL_105;
      }

      *buf = 136446210;
      v70 = "nw_http3_passthrough_stream_get_output_frames";
      v41 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_104;
    }

    backtrace_string = __nw_create_backtrace_string();
    v39 = __nwlog_obj();
    v40 = type;
    v53 = os_log_type_enabled(v39, type);
    if (backtrace_string)
    {
      if (v53)
      {
        *buf = 136446466;
        v70 = "nw_http3_passthrough_stream_get_output_frames";
        v71 = 2082;
        *v72 = backtrace_string;
        v51 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_88;
      }

LABEL_89:
      free(backtrace_string);
      goto LABEL_105;
    }

    if (!v53)
    {
      goto LABEL_105;
    }

    *buf = 136446210;
    v70 = "nw_http3_passthrough_stream_get_output_frames";
    v41 = "%{public}s called with null input_protocol, no backtrace";
LABEL_104:
    _os_log_impl(&dword_181A37000, v39, v40, v41, buf, 0xCu);
LABEL_105:
    if (v38)
    {
      free(v38);
    }

    return 0;
  }

  if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v42 = a5;
    v43 = a1;
    v44 = __nwlog_obj();
    v45 = os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG);
    a5 = v42;
    v46 = v45;
    a1 = v43;
    if (v46)
    {
      v47 = *(handle[43] + 1304);
      v48 = handle[30];
      *buf = 136447234;
      v70 = "nw_http3_passthrough_stream_get_output_frames";
      v71 = 2082;
      *v72 = handle + 79;
      *&v72[8] = 2080;
      *v73 = " ";
      *&v73[8] = 1024;
      *v74 = v47;
      *&v74[4] = 2048;
      *&v74[6] = v48;
      _os_log_impl(&dword_181A37000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      a1 = v43;
      a5 = v42;
    }
  }

  v10 = *(handle + 156);
  if (v10 == 1)
  {
    v11 = handle[30] & 1;
    v12 = *(handle[43] + 1397) & 1;
    if (v11 == v12)
    {
      goto LABEL_10;
    }

LABEL_14:
    if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
    {
      v54 = __nwlog_obj();
      result = os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG);
      if (!result)
      {
        return result;
      }

      v55 = *(handle[43] + 1304);
      v56 = handle[30];
      *buf = 136447490;
      v70 = "nw_http3_passthrough_stream_get_output_frames";
      v71 = 2082;
      *v72 = handle + 79;
      *&v72[8] = 2080;
      *v73 = " ";
      *&v73[8] = 1024;
      *v74 = v55;
      *&v74[4] = 2048;
      *&v74[6] = v56;
      v75 = 2048;
      v76 = v56;
      _os_log_impl(&dword_181A37000, v54, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> ignoring as stream %llu can't write", buf, 0x3Au);
    }

    return 0;
  }

  if (v10 != 2)
  {
    goto LABEL_14;
  }

  v11 = handle[30] & 1;
  v12 = *(handle[43] + 1397) & 1;
LABEL_10:
  if (v11 != v12 || (*(handle + 734) & 0x40) != 0)
  {
    v14 = 0;
    goto LABEL_18;
  }

  v13 = handle[33];
  if (v13 >= 0x40)
  {
    if (v13 >= 0x4000)
    {
      if (v13 >> 30)
      {
        if (v13 >> 62)
        {
          v33 = a1;
          v34 = a5;
          v35 = __nwlog_obj();
          os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
          *buf = 136446466;
          v70 = "_http_vle_length";
          v71 = 2048;
          *v72 = v13;
          v36 = _os_log_send_and_compose_impl();
          result = __nwlog_should_abort(v36);
          if (result)
          {
            __break(1u);
            return result;
          }

          free(v36);
          v14 = 2;
          a5 = v34;
          a1 = v33;
        }

        else
        {
          v14 = 10;
        }
      }

      else
      {
        v14 = 6;
      }
    }

    else
    {
      v14 = 4;
    }
  }

  else
  {
    v14 = 3;
  }

  v37 = __CFADD__(a3, v14);
  a3 = a3 + v14;
  if (!v37)
  {
    goto LABEL_58;
  }

  if (gLogDatapath != 1)
  {
    a3 = 0xFFFFFFFFLL;
LABEL_58:
    v37 = __CFADD__(a4, v14);
    a4 = a4 + v14;
    if (!v37)
    {
      goto LABEL_18;
    }

    goto LABEL_60;
  }

  v62 = a1;
  v57 = a5;
  v58 = __nwlog_obj();
  if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
  {
    *buf = 136446978;
    v70 = "nw_http3_passthrough_stream_get_output_frames";
    v71 = 2082;
    *v72 = "minimum_bytes";
    *&v72[8] = 2048;
    *v73 = v14;
    *&v73[8] = 2048;
    *v74 = a3;
    _os_log_impl(&dword_181A37000, v58, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
  }

  a3 = 0xFFFFFFFFLL;
  a5 = v57;
  a1 = v62;
  v37 = __CFADD__(a4, v14);
  a4 = a4 + v14;
  if (v37)
  {
LABEL_60:
    if (gLogDatapath == 1)
    {
      v59 = a1;
      v60 = a5;
      v61 = __nwlog_obj();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446978;
        v70 = "nw_http3_passthrough_stream_get_output_frames";
        v71 = 2082;
        *v72 = "maximum_bytes";
        *&v72[8] = 2048;
        *v73 = v14;
        *&v73[8] = 2048;
        *v74 = a4;
        _os_log_impl(&dword_181A37000, v61, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
      }

      a4 = 0xFFFFFFFFLL;
      a5 = v60;
      a1 = v59;
    }

    else
    {
      a4 = 0xFFFFFFFFLL;
    }
  }

LABEL_18:
  result = nw_protocol_get_output_frames_quiet(a1->output_handler, a1, a3, a4, a5, a6);
  if (result && v14)
  {
    v16 = result;
    tqh_first = a6->tqh_first;
    v18 = nw_frame_unclaimed_length(a6->tqh_first);
    if (v18 < v14)
    {
      v19 = v18;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *buf = 136446722;
      v70 = "nw_http3_passthrough_stream_get_output_frames";
      v71 = 1024;
      *v72 = v14;
      *&v72[4] = 1024;
      *&v72[6] = v19;
      v20 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v67 = 0;
      if (__nwlog_fault(v20, &type, &v67))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = gLogObj;
          v22 = type;
          if (os_log_type_enabled(gLogObj, type))
          {
            *buf = 136446722;
            v70 = "nw_http3_passthrough_stream_get_output_frames";
            v71 = 1024;
            *v72 = v14;
            *&v72[4] = 1024;
            *&v72[6] = v19;
            v23 = "%{public}s Expected header_length (%u) to be <= first frame's claimed_length (%u)";
LABEL_45:
            _os_log_impl(&dword_181A37000, v21, v22, v23, buf, 0x18u);
          }
        }

        else if (v67 == 1)
        {
          v28 = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = gLogObj;
          v22 = type;
          v29 = os_log_type_enabled(gLogObj, type);
          if (v28)
          {
            if (v29)
            {
              *buf = 136446978;
              v70 = "nw_http3_passthrough_stream_get_output_frames";
              v71 = 1024;
              *v72 = v14;
              *&v72[4] = 1024;
              *&v72[6] = v19;
              *v73 = 2082;
              *&v73[2] = v28;
              _os_log_impl(&dword_181A37000, v21, v22, "%{public}s Expected header_length (%u) to be <= first frame's claimed_length (%u), dumping backtrace:%{public}s", buf, 0x22u);
            }

            free(v28);
            goto LABEL_46;
          }

          if (v29)
          {
            *buf = 136446722;
            v70 = "nw_http3_passthrough_stream_get_output_frames";
            v71 = 1024;
            *v72 = v14;
            *&v72[4] = 1024;
            *&v72[6] = v19;
            v23 = "%{public}s Expected header_length (%u) to be <= first frame's claimed_length (%u), no backtrace";
            goto LABEL_45;
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = gLogObj;
          v22 = type;
          if (os_log_type_enabled(gLogObj, type))
          {
            *buf = 136446722;
            v70 = "nw_http3_passthrough_stream_get_output_frames";
            v71 = 1024;
            *v72 = v14;
            *&v72[4] = 1024;
            *&v72[6] = v19;
            v23 = "%{public}s Expected header_length (%u) to be <= first frame's claimed_length (%u), backtrace limit exceeded";
            goto LABEL_45;
          }
        }
      }

LABEL_46:
      if (v20)
      {
        free(v20);
      }

      v63[0] = MEMORY[0x1E69E9820];
      v63[1] = 0x40000000;
      v64 = ___ZL45nw_http3_passthrough_stream_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
      v65 = &__block_descriptor_tmp_159_64741;
      v66 = a6;
      v30 = a6->tqh_first;
      do
      {
        if (!v30)
        {
          break;
        }

        v31 = *(v30 + 4);
        v32 = (v64)(v63);
        v30 = v31;
      }

      while ((v32 & 1) != 0);
      return 0;
    }

    if (nw_frame_uses_external_data(tqh_first))
    {
      v25 = tqh_first;
      v26 = 0;
      v27 = v14;
    }

    else
    {
      v25 = tqh_first;
      v26 = v14;
      v27 = 0;
    }

    nw_frame_claim(v25, v24, v26, v27);
    *(handle + 734) |= 0x40u;
    return v16;
  }

  return result;
}

uint64_t ___ZL45nw_http3_passthrough_stream_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  v2 = (*(a1 + 32) + 8);
  v3 = *(a2 + 32);
  v4 = *(a2 + 40);
  if (v3)
  {
    v2 = (v3 + 40);
  }

  *v2 = v4;
  *v4 = v3;
  *(a2 + 32) = 0;
  *(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

uint64_t nw_http3_passthrough_stream_get_input_frames(nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  v50 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v39 = "nw_http3_passthrough_stream_get_input_frames";
    v16 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v16, &type, &v36))
    {
      goto LABEL_60;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_60;
      }

      *buf = 136446210;
      v39 = "nw_http3_passthrough_stream_get_input_frames";
      v19 = "%{public}s called with null protocol";
      goto LABEL_59;
    }

    if (v36 != 1)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_60;
      }

      *buf = 136446210;
      v39 = "nw_http3_passthrough_stream_get_input_frames";
      v19 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_59;
    }

    backtrace_string = __nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v29 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v29)
      {
        goto LABEL_60;
      }

      *buf = 136446210;
      v39 = "nw_http3_passthrough_stream_get_input_frames";
      v19 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_59;
    }

    if (!v29)
    {
      goto LABEL_44;
    }

    *buf = 136446466;
    v39 = "nw_http3_passthrough_stream_get_input_frames";
    v40 = 2082;
    v41 = backtrace_string;
    v30 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_43:
    _os_log_impl(&dword_181A37000, v17, v18, v30, buf, 0x16u);
    goto LABEL_44;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v39 = "nw_http3_passthrough_stream_get_input_frames";
    v16 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v16, &type, &v36))
    {
      goto LABEL_60;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_60;
      }

      *buf = 136446210;
      v39 = "nw_http3_passthrough_stream_get_input_frames";
      v19 = "%{public}s called with null http3_stream";
      goto LABEL_59;
    }

    if (v36 != 1)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_60;
      }

      *buf = 136446210;
      v39 = "nw_http3_passthrough_stream_get_input_frames";
      v19 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_59;
    }

    backtrace_string = __nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v31 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v31)
      {
        goto LABEL_60;
      }

      *buf = 136446210;
      v39 = "nw_http3_passthrough_stream_get_input_frames";
      v19 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_59;
    }

    if (!v31)
    {
      goto LABEL_44;
    }

    *buf = 136446466;
    v39 = "nw_http3_passthrough_stream_get_input_frames";
    v40 = 2082;
    v41 = backtrace_string;
    v30 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
    goto LABEL_43;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v39 = "nw_http3_passthrough_stream_get_input_frames";
    v16 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v16, &type, &v36))
    {
      goto LABEL_60;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_60;
      }

      *buf = 136446210;
      v39 = "nw_http3_passthrough_stream_get_input_frames";
      v19 = "%{public}s called with null input_protocol";
      goto LABEL_59;
    }

    if (v36 != 1)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
      {
        goto LABEL_60;
      }

      *buf = 136446210;
      v39 = "nw_http3_passthrough_stream_get_input_frames";
      v19 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_59;
    }

    backtrace_string = __nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v32 = os_log_type_enabled(v17, type);
    if (backtrace_string)
    {
      if (v32)
      {
        *buf = 136446466;
        v39 = "nw_http3_passthrough_stream_get_input_frames";
        v40 = 2082;
        v41 = backtrace_string;
        v30 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_43;
      }

LABEL_44:
      free(backtrace_string);
      goto LABEL_60;
    }

    if (!v32)
    {
      goto LABEL_60;
    }

    *buf = 136446210;
    v39 = "nw_http3_passthrough_stream_get_input_frames";
    v19 = "%{public}s called with null input_protocol, no backtrace";
LABEL_59:
    _os_log_impl(&dword_181A37000, v17, v18, v19, buf, 0xCu);
LABEL_60:
    if (v16)
    {
      free(v16);
    }

    return 0;
  }

  if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v20 = a6;
    v21 = a5;
    v22 = a4;
    v23 = a3;
    v24 = __nwlog_obj();
    v25 = os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG);
    a3 = v23;
    a4 = v22;
    a5 = v21;
    a6 = v20;
    if (v25)
    {
      v26 = *(*(handle + 43) + 1304);
      v27 = *(handle + 30);
      *buf = 136447234;
      v39 = "nw_http3_passthrough_stream_get_input_frames";
      v40 = 2082;
      v41 = handle + 632;
      v42 = 2080;
      v43 = " ";
      v44 = 1024;
      v45 = v26;
      v46 = 2048;
      v47 = v27;
      _os_log_impl(&dword_181A37000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      a3 = v23;
      a4 = v22;
      a5 = v21;
      a6 = v20;
    }
  }

  v7 = *(handle + 156);
  if (v7 == 2 || v7 == 1 && (*(handle + 30) & 1) != (*(*(handle + 43) + 1397) & 1))
  {
    v9 = a3;
    v10 = a4;
    v11 = a5;
    v12 = (handle + 176);
    v13 = a6;
    frame_count = nw_frame_array_get_frame_count(handle + 22, 1, 0);
    if (frame_count && *v12)
    {
      tqh_last = v13->tqh_last;
      *tqh_last = *v12;
      *(*(handle + 22) + 40) = tqh_last;
      v13->tqh_last = *(handle + 23);
      *(handle + 22) = 0;
      *(handle + 23) = v12;
    }

    return nw_protocol_common_get_input_frames(handle, handle, v9, v10, v11, v13) + frame_count;
  }

  else
  {
    if ((*(handle + 366) & 0x2000) != 0 || gLogDatapath != 1)
    {
      return 0;
    }

    v33 = __nwlog_obj();
    result = os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG);
    if (result)
    {
      v34 = *(*(handle + 43) + 1304);
      v35 = *(handle + 30);
      *buf = 136447490;
      v39 = "nw_http3_passthrough_stream_get_input_frames";
      v40 = 2082;
      v41 = handle + 632;
      v42 = 2080;
      v43 = " ";
      v44 = 1024;
      v45 = v34;
      v46 = 2048;
      v47 = v35;
      v48 = 2048;
      v49 = v35;
      _os_log_impl(&dword_181A37000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> ignoring as stream %llu can't read", buf, 0x3Au);
      return 0;
    }
  }

  return result;
}

void nw_http3_passthrough_stream_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  v36 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_input_finished";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_input_finished";
      v10 = "%{public}s called with null protocol";
    }

    else if (v22 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v17 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *buf = 136446466;
          v25 = "nw_http3_passthrough_stream_input_finished";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_58:
        if (!v7)
        {
          return;
        }

        goto LABEL_59;
      }

      if (!v17)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_input_finished";
      v10 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_input_finished";
      v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_57;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_input_finished";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
    {
      goto LABEL_58;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v22 != 1)
      {
        v8 = __nwlog_obj();
        v9 = type;
        if (!os_log_type_enabled(v8, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v25 = "nw_http3_passthrough_stream_input_finished";
        v10 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_57;
      }

      v18 = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v19 = os_log_type_enabled(v8, type);
      if (!v18)
      {
        if (!v19)
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v25 = "nw_http3_passthrough_stream_input_finished";
        v10 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_57;
      }

      if (v19)
      {
        *buf = 136446466;
        v25 = "nw_http3_passthrough_stream_input_finished";
        v26 = 2082;
        v27 = v18;
        v20 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_42:
        _os_log_impl(&dword_181A37000, v8, v9, v20, buf, 0x16u);
      }

LABEL_43:
      free(v18);
      if (!v7)
      {
        return;
      }

LABEL_59:
      free(v7);
      return;
    }

    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_input_finished";
    v10 = "%{public}s called with null http3_stream";
LABEL_57:
    _os_log_impl(&dword_181A37000, v8, v9, v10, buf, 0xCu);
    goto LABEL_58;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_input_finished";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_input_finished";
      v10 = "%{public}s called with null other_protocol";
      goto LABEL_57;
    }

    if (v22 != 1)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_input_finished";
      v10 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_57;
    }

    v18 = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v21 = os_log_type_enabled(v8, type);
    if (!v18)
    {
      if (!v21)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_input_finished";
      v10 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_57;
    }

    if (v21)
    {
      *buf = 136446466;
      v25 = "nw_http3_passthrough_stream_input_finished";
      v26 = 2082;
      v27 = v18;
      v20 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_42;
    }

    goto LABEL_43;
  }

  if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v11 = a1;
    v12 = __nwlog_obj();
    v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
    a1 = v11;
    if (v13)
    {
      v14 = *(handle[43] + 1304);
      v15 = handle[30];
      *buf = 136447234;
      v25 = "nw_http3_passthrough_stream_input_finished";
      v26 = 2082;
      v27 = (handle + 79);
      v28 = 2080;
      v29 = " ";
      v30 = 1024;
      v31 = v14;
      v32 = 2048;
      v33 = v15;
      _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      a1 = v11;
    }
  }

  v3 = *(handle + 156);
  if (v3 == 2 || v3 == 1 && (handle[30] & 1) != (*(handle[43] + 1397) & 1))
  {
    nw_protocol_input_finished_quiet(a1->default_input_handler->flow_id, a1);
    *(handle + 366) &= ~0x400u;
  }

  else if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v4 = __nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v5 = *(handle[43] + 1304);
      v6 = handle[30];
      *buf = 136447490;
      v25 = "nw_http3_passthrough_stream_input_finished";
      v26 = 2082;
      v27 = (handle + 79);
      v28 = 2080;
      v29 = " ";
      v30 = 1024;
      v31 = v5;
      v32 = 2048;
      v33 = v6;
      v34 = 2048;
      v35 = v6;
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> ignoring as stream %llu can't read", buf, 0x3Au);
    }
  }
}

void nw_http3_passthrough_stream_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  v36 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_output_finished";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v4, &type, &v22))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_output_finished";
      v7 = "%{public}s called with null protocol";
    }

    else if (v22 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v14 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v25 = "nw_http3_passthrough_stream_output_finished";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_58:
        if (!v4)
        {
          return;
        }

        goto LABEL_59;
      }

      if (!v14)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_output_finished";
      v7 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_output_finished";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_57;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_output_finished";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v4, &type, &v22))
    {
      goto LABEL_58;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v22 != 1)
      {
        v5 = __nwlog_obj();
        v6 = type;
        if (!os_log_type_enabled(v5, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v25 = "nw_http3_passthrough_stream_output_finished";
        v7 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_57;
      }

      v15 = __nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v16 = os_log_type_enabled(v5, type);
      if (!v15)
      {
        if (!v16)
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v25 = "nw_http3_passthrough_stream_output_finished";
        v7 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_57;
      }

      if (v16)
      {
        *buf = 136446466;
        v25 = "nw_http3_passthrough_stream_output_finished";
        v26 = 2082;
        v27 = v15;
        v17 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_40:
        _os_log_impl(&dword_181A37000, v5, v6, v17, buf, 0x16u);
      }

LABEL_41:
      free(v15);
      if (!v4)
      {
        return;
      }

LABEL_59:
      free(v4);
      return;
    }

    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_output_finished";
    v7 = "%{public}s called with null http3_stream";
LABEL_57:
    _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0xCu);
    goto LABEL_58;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_output_finished";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v4, &type, &v22))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_output_finished";
      v7 = "%{public}s called with null other_protocol";
      goto LABEL_57;
    }

    if (v22 != 1)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_output_finished";
      v7 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_57;
    }

    v15 = __nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v18 = os_log_type_enabled(v5, type);
    if (!v15)
    {
      if (!v18)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_output_finished";
      v7 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_57;
    }

    if (v18)
    {
      *buf = 136446466;
      v25 = "nw_http3_passthrough_stream_output_finished";
      v26 = 2082;
      v27 = v15;
      v17 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_40;
    }

    goto LABEL_41;
  }

  if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v8 = a1;
    v9 = __nwlog_obj();
    v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
    a1 = v8;
    if (v10)
    {
      v11 = *(handle[43] + 1304);
      v12 = handle[30];
      *buf = 136447234;
      v25 = "nw_http3_passthrough_stream_output_finished";
      v26 = 2082;
      v27 = (handle + 79);
      v28 = 2080;
      v29 = " ";
      v30 = 1024;
      v31 = v11;
      v32 = 2048;
      v33 = v12;
      _os_log_impl(&dword_181A37000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      a1 = v8;
    }
  }

  v3 = *(handle + 156);
  if (v3 == 2 || v3 == 1 && (handle[30] & 1) == (*(handle[43] + 1397) & 1))
  {
    nw_protocol_output_finished_quiet(a1->output_handler->flow_id, a1);
  }

  else if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v19 = __nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      v20 = *(handle[43] + 1304);
      v21 = handle[30];
      *buf = 136447490;
      v25 = "nw_http3_passthrough_stream_output_finished";
      v26 = 2082;
      v27 = (handle + 79);
      v28 = 2080;
      v29 = " ";
      v30 = 1024;
      v31 = v20;
      v32 = 2048;
      v33 = v21;
      v34 = 2048;
      v35 = v21;
      _os_log_impl(&dword_181A37000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> ignoring as stream %llu can't write", buf, 0x3Au);
    }
  }
}

void nw_http3_passthrough_stream_output_available(nw_protocol *a1, nw_protocol *a2)
{
  v36 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_output_available";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v4, &type, &v22))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_output_available";
      v7 = "%{public}s called with null protocol";
    }

    else if (v22 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v14 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v25 = "nw_http3_passthrough_stream_output_available";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_58:
        if (!v4)
        {
          return;
        }

        goto LABEL_59;
      }

      if (!v14)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_output_available";
      v7 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_output_available";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_57;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_output_available";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v4, &type, &v22))
    {
      goto LABEL_58;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v22 != 1)
      {
        v5 = __nwlog_obj();
        v6 = type;
        if (!os_log_type_enabled(v5, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v25 = "nw_http3_passthrough_stream_output_available";
        v7 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_57;
      }

      v15 = __nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v16 = os_log_type_enabled(v5, type);
      if (!v15)
      {
        if (!v16)
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v25 = "nw_http3_passthrough_stream_output_available";
        v7 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_57;
      }

      if (v16)
      {
        *buf = 136446466;
        v25 = "nw_http3_passthrough_stream_output_available";
        v26 = 2082;
        v27 = v15;
        v17 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_40:
        _os_log_impl(&dword_181A37000, v5, v6, v17, buf, 0x16u);
      }

LABEL_41:
      free(v15);
      if (!v4)
      {
        return;
      }

LABEL_59:
      free(v4);
      return;
    }

    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_output_available";
    v7 = "%{public}s called with null http3_stream";
LABEL_57:
    _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0xCu);
    goto LABEL_58;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_output_available";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v4, &type, &v22))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_output_available";
      v7 = "%{public}s called with null other_protocol";
      goto LABEL_57;
    }

    if (v22 != 1)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_output_available";
      v7 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_57;
    }

    v15 = __nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v18 = os_log_type_enabled(v5, type);
    if (!v15)
    {
      if (!v18)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_output_available";
      v7 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_57;
    }

    if (v18)
    {
      *buf = 136446466;
      v25 = "nw_http3_passthrough_stream_output_available";
      v26 = 2082;
      v27 = v15;
      v17 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_40;
    }

    goto LABEL_41;
  }

  if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v8 = a1;
    v9 = __nwlog_obj();
    v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
    a1 = v8;
    if (v10)
    {
      v11 = *(handle[43] + 1304);
      v12 = handle[30];
      *buf = 136447234;
      v25 = "nw_http3_passthrough_stream_output_available";
      v26 = 2082;
      v27 = (handle + 79);
      v28 = 2080;
      v29 = " ";
      v30 = 1024;
      v31 = v11;
      v32 = 2048;
      v33 = v12;
      _os_log_impl(&dword_181A37000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      a1 = v8;
    }
  }

  v3 = *(handle + 156);
  if (v3 == 2 || v3 == 1 && (handle[30] & 1) == (*(handle[43] + 1397) & 1))
  {
    nw_protocol_output_available_quiet(a1->default_input_handler->flow_id, a1);
  }

  else if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v19 = __nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      v20 = *(handle[43] + 1304);
      v21 = handle[30];
      *buf = 136447490;
      v25 = "nw_http3_passthrough_stream_output_available";
      v26 = 2082;
      v27 = (handle + 79);
      v28 = 2080;
      v29 = " ";
      v30 = 1024;
      v31 = v20;
      v32 = 2048;
      v33 = v21;
      v34 = 2048;
      v35 = v21;
      _os_log_impl(&dword_181A37000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> ignoring as stream %llu can't write", buf, 0x3Au);
    }
  }
}

void nw_http3_passthrough_stream_input_available(nw_protocol *a1, nw_protocol *a2)
{
  v36 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_input_available";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_input_available";
      v10 = "%{public}s called with null protocol";
    }

    else if (v22 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v17 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *buf = 136446466;
          v25 = "nw_http3_passthrough_stream_input_available";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_58:
        if (!v7)
        {
          return;
        }

        goto LABEL_59;
      }

      if (!v17)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_input_available";
      v10 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_input_available";
      v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_57;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_input_available";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
    {
      goto LABEL_58;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v22 != 1)
      {
        v8 = __nwlog_obj();
        v9 = type;
        if (!os_log_type_enabled(v8, type))
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v25 = "nw_http3_passthrough_stream_input_available";
        v10 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_57;
      }

      v18 = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v19 = os_log_type_enabled(v8, type);
      if (!v18)
      {
        if (!v19)
        {
          goto LABEL_58;
        }

        *buf = 136446210;
        v25 = "nw_http3_passthrough_stream_input_available";
        v10 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_57;
      }

      if (v19)
      {
        *buf = 136446466;
        v25 = "nw_http3_passthrough_stream_input_available";
        v26 = 2082;
        v27 = v18;
        v20 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_42:
        _os_log_impl(&dword_181A37000, v8, v9, v20, buf, 0x16u);
      }

LABEL_43:
      free(v18);
      if (!v7)
      {
        return;
      }

LABEL_59:
      free(v7);
      return;
    }

    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
    {
      goto LABEL_58;
    }

    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_input_available";
    v10 = "%{public}s called with null http3_stream";
LABEL_57:
    _os_log_impl(&dword_181A37000, v8, v9, v10, buf, 0xCu);
    goto LABEL_58;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_http3_passthrough_stream_input_available";
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
    {
      goto LABEL_58;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_input_available";
      v10 = "%{public}s called with null other_protocol";
      goto LABEL_57;
    }

    if (v22 != 1)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_input_available";
      v10 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_57;
    }

    v18 = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v21 = os_log_type_enabled(v8, type);
    if (!v18)
    {
      if (!v21)
      {
        goto LABEL_58;
      }

      *buf = 136446210;
      v25 = "nw_http3_passthrough_stream_input_available";
      v10 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_57;
    }

    if (v21)
    {
      *buf = 136446466;
      v25 = "nw_http3_passthrough_stream_input_available";
      v26 = 2082;
      v27 = v18;
      v20 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_42;
    }

    goto LABEL_43;
  }

  if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v11 = a1;
    v12 = __nwlog_obj();
    v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
    a1 = v11;
    if (v13)
    {
      v14 = *(handle[43] + 1304);
      v15 = handle[30];
      *buf = 136447234;
      v25 = "nw_http3_passthrough_stream_input_available";
      v26 = 2082;
      v27 = (handle + 79);
      v28 = 2080;
      v29 = " ";
      v30 = 1024;
      v31 = v14;
      v32 = 2048;
      v33 = v15;
      _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      a1 = v11;
    }
  }

  v3 = *(handle + 156);
  if (v3 == 2 || v3 == 1 && (handle[30] & 1) != (*(handle[43] + 1397) & 1))
  {
    nw_protocol_input_available_quiet(a1->default_input_handler->flow_id, a1);
  }

  else if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v4 = __nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v5 = *(handle[43] + 1304);
      v6 = handle[30];
      *buf = 136447490;
      v25 = "nw_http3_passthrough_stream_input_available";
      v26 = 2082;
      v27 = (handle + 79);
      v28 = 2080;
      v29 = " ";
      v30 = 1024;
      v31 = v5;
      v32 = 2048;
      v33 = v6;
      v34 = 2048;
      v35 = v6;
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> ignoring as stream %llu can't read", buf, 0x3Au);
    }
  }
}

uint64_t nw_protocol_http3_stream_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  v30 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_protocol_http3_stream_remove_listen_handler";
    v5 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v5, &type, &v18))
    {
      goto LABEL_49;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
      {
        goto LABEL_49;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_stream_remove_listen_handler";
      v8 = "%{public}s called with null protocol";
LABEL_48:
      _os_log_impl(&dword_181A37000, v6, v7, v8, buf, 0xCu);
      goto LABEL_49;
    }

    if (v18 != 1)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v21 = "nw_protocol_http3_stream_remove_listen_handler";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    backtrace_string = __nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v14 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *buf = 136446210;
        v21 = "nw_protocol_http3_stream_remove_listen_handler";
        v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    if (!v14)
    {
      goto LABEL_35;
    }

    *buf = 136446466;
    v21 = "nw_protocol_http3_stream_remove_listen_handler";
    v22 = 2082;
    v23 = backtrace_string;
    v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_34:
    _os_log_impl(&dword_181A37000, v6, v7, v15, buf, 0x16u);
    goto LABEL_35;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_protocol_http3_stream_remove_listen_handler";
    v5 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v5, &type, &v18))
    {
      goto LABEL_49;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
      {
        goto LABEL_49;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_stream_remove_listen_handler";
      v8 = "%{public}s called with null http3_stream";
      goto LABEL_48;
    }

    if (v18 != 1)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v21 = "nw_protocol_http3_stream_remove_listen_handler";
        v8 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    backtrace_string = __nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v16 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *buf = 136446210;
        v21 = "nw_protocol_http3_stream_remove_listen_handler";
        v8 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    if (!v16)
    {
      goto LABEL_35;
    }

    *buf = 136446466;
    v21 = "nw_protocol_http3_stream_remove_listen_handler";
    v22 = 2082;
    v23 = backtrace_string;
    v15 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
    goto LABEL_34;
  }

  v3 = handle[43];
  if (v3)
  {
    if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
    {
      v9 = __nwlog_obj();
      v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
      v3 = handle[43];
      if (v10)
      {
        v11 = *(v3 + 1304);
        v12 = handle[30];
        *buf = 136447234;
        v21 = "nw_protocol_http3_stream_remove_listen_handler";
        v22 = 2082;
        v23 = (handle + 79);
        v24 = 2080;
        v25 = " ";
        v26 = 1024;
        v27 = v11;
        v28 = 2048;
        v29 = v12;
        _os_log_impl(&dword_181A37000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
        v3 = handle[43];
      }
    }

    return (*(*(v3 + 24) + 240))();
  }

  __nwlog_obj();
  *buf = 136446210;
  v21 = "nw_protocol_http3_stream_remove_listen_handler";
  v5 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v5, &type, &v18))
  {
    goto LABEL_49;
  }

  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v18 != 1)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v21 = "nw_protocol_http3_stream_remove_listen_handler";
        v8 = "%{public}s called with null http3_stream->http3_connection, backtrace limit exceeded";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    backtrace_string = __nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v17 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *buf = 136446210;
        v21 = "nw_protocol_http3_stream_remove_listen_handler";
        v8 = "%{public}s called with null http3_stream->http3_connection, no backtrace";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    if (v17)
    {
      *buf = 136446466;
      v21 = "nw_protocol_http3_stream_remove_listen_handler";
      v22 = 2082;
      v23 = backtrace_string;
      v15 = "%{public}s called with null http3_stream->http3_connection, dumping backtrace:%{public}s";
      goto LABEL_34;
    }

LABEL_35:
    free(backtrace_string);
    goto LABEL_49;
  }

  v6 = __nwlog_obj();
  v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *buf = 136446210;
    v21 = "nw_protocol_http3_stream_remove_listen_handler";
    v8 = "%{public}s called with null http3_stream->http3_connection";
    goto LABEL_48;
  }

LABEL_49:
  if (v5)
  {
    free(v5);
  }

  return 0;
}

uint64_t nw_protocol_http3_stream_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  v30 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_protocol_http3_stream_add_listen_handler";
    v5 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v5, &type, &v18))
    {
      goto LABEL_49;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
      {
        goto LABEL_49;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_stream_add_listen_handler";
      v8 = "%{public}s called with null protocol";
LABEL_48:
      _os_log_impl(&dword_181A37000, v6, v7, v8, buf, 0xCu);
      goto LABEL_49;
    }

    if (v18 != 1)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v21 = "nw_protocol_http3_stream_add_listen_handler";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    backtrace_string = __nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v14 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *buf = 136446210;
        v21 = "nw_protocol_http3_stream_add_listen_handler";
        v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    if (!v14)
    {
      goto LABEL_35;
    }

    *buf = 136446466;
    v21 = "nw_protocol_http3_stream_add_listen_handler";
    v22 = 2082;
    v23 = backtrace_string;
    v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_34:
    _os_log_impl(&dword_181A37000, v6, v7, v15, buf, 0x16u);
    goto LABEL_35;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_protocol_http3_stream_add_listen_handler";
    v5 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v5, &type, &v18))
    {
      goto LABEL_49;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
      {
        goto LABEL_49;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_stream_add_listen_handler";
      v8 = "%{public}s called with null http3_stream";
      goto LABEL_48;
    }

    if (v18 != 1)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v21 = "nw_protocol_http3_stream_add_listen_handler";
        v8 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    backtrace_string = __nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v16 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *buf = 136446210;
        v21 = "nw_protocol_http3_stream_add_listen_handler";
        v8 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    if (!v16)
    {
      goto LABEL_35;
    }

    *buf = 136446466;
    v21 = "nw_protocol_http3_stream_add_listen_handler";
    v22 = 2082;
    v23 = backtrace_string;
    v15 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
    goto LABEL_34;
  }

  v3 = handle[43];
  if (v3)
  {
    if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
    {
      v9 = __nwlog_obj();
      v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
      v3 = handle[43];
      if (v10)
      {
        v11 = *(v3 + 1304);
        v12 = handle[30];
        *buf = 136447234;
        v21 = "nw_protocol_http3_stream_add_listen_handler";
        v22 = 2082;
        v23 = (handle + 79);
        v24 = 2080;
        v25 = " ";
        v26 = 1024;
        v27 = v11;
        v28 = 2048;
        v29 = v12;
        _os_log_impl(&dword_181A37000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
        v3 = handle[43];
      }
    }

    return (*(*(v3 + 24) + 232))();
  }

  __nwlog_obj();
  *buf = 136446210;
  v21 = "nw_protocol_http3_stream_add_listen_handler";
  v5 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v5, &type, &v18))
  {
    goto LABEL_49;
  }

  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v18 != 1)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v21 = "nw_protocol_http3_stream_add_listen_handler";
        v8 = "%{public}s called with null http3_stream->http3_connection, backtrace limit exceeded";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    backtrace_string = __nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v17 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *buf = 136446210;
        v21 = "nw_protocol_http3_stream_add_listen_handler";
        v8 = "%{public}s called with null http3_stream->http3_connection, no backtrace";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    if (v17)
    {
      *buf = 136446466;
      v21 = "nw_protocol_http3_stream_add_listen_handler";
      v22 = 2082;
      v23 = backtrace_string;
      v15 = "%{public}s called with null http3_stream->http3_connection, dumping backtrace:%{public}s";
      goto LABEL_34;
    }

LABEL_35:
    free(backtrace_string);
    goto LABEL_49;
  }

  v6 = __nwlog_obj();
  v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *buf = 136446210;
    v21 = "nw_protocol_http3_stream_add_listen_handler";
    v8 = "%{public}s called with null http3_stream->http3_connection";
    goto LABEL_48;
  }

LABEL_49:
  if (v5)
  {
    free(v5);
  }

  return 0;
}

uint64_t nw_protocol_http3_stream_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  v53 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v42 = "nw_protocol_http3_stream_add_input_handler";
    v15 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v15, &type, &v39))
    {
      goto LABEL_62;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v42 = "nw_protocol_http3_stream_add_input_handler";
      v18 = "%{public}s called with null protocol";
      goto LABEL_61;
    }

    if (v39 != 1)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v42 = "nw_protocol_http3_stream_add_input_handler";
      v18 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_61;
    }

    backtrace_string = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v27 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v27)
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v42 = "nw_protocol_http3_stream_add_input_handler";
      v18 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_61;
    }

    if (v27)
    {
      *buf = 136446466;
      v42 = "nw_protocol_http3_stream_add_input_handler";
      v43 = 2082;
      v44 = backtrace_string;
      _os_log_impl(&dword_181A37000, v16, v17, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
LABEL_62:
    if (!v15)
    {
      return 0;
    }

LABEL_63:
    free(v15);
    return 0;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v42 = "nw_protocol_http3_stream_add_input_handler";
    v15 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v15, &type, &v39))
    {
      goto LABEL_62;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v42 = "nw_protocol_http3_stream_add_input_handler";
      v18 = "%{public}s called with null http3_stream";
      goto LABEL_61;
    }

    if (v39 != 1)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v42 = "nw_protocol_http3_stream_add_input_handler";
      v18 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_61;
    }

    v28 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v29 = os_log_type_enabled(v16, type);
    if (v28)
    {
      if (v29)
      {
        *buf = 136446466;
        v42 = "nw_protocol_http3_stream_add_input_handler";
        v43 = 2082;
        v44 = v28;
        _os_log_impl(&dword_181A37000, v16, v17, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v28);
      if (!v15)
      {
        return 0;
      }

      goto LABEL_63;
    }

    if (v29)
    {
      *buf = 136446210;
      v42 = "nw_protocol_http3_stream_add_input_handler";
      v18 = "%{public}s called with null http3_stream, no backtrace";
LABEL_61:
      _os_log_impl(&dword_181A37000, v16, v17, v18, buf, 0xCu);
      goto LABEL_62;
    }

    goto LABEL_62;
  }

  if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v19 = a2;
    v20 = a1;
    v21 = __nwlog_obj();
    v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG);
    a2 = v19;
    v23 = v22;
    a1 = v20;
    if (v23)
    {
      v24 = *(*(handle + 43) + 1304);
      v25 = *(handle + 30);
      *buf = 136447234;
      v42 = "nw_protocol_http3_stream_add_input_handler";
      v43 = 2082;
      v44 = handle + 632;
      v45 = 2080;
      v46 = " ";
      v47 = 1024;
      v48 = v24;
      v49 = 2048;
      v50 = v25;
      _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      a1 = v20;
      a2 = v19;
    }
  }

  v3 = *(handle + 43);
  if (v3)
  {
    v4 = a1->default_input_handler == a2;
  }

  else
  {
    v4 = 1;
  }

  if (!v4)
  {
    if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
    {
      v30 = a2;
      v31 = __nwlog_obj();
      v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG);
      a2 = v30;
      if (v32)
      {
        v33 = *(*(handle + 43) + 1304);
        v34 = *(handle + 30);
        *buf = 136447490;
        v42 = "nw_protocol_http3_stream_add_input_handler";
        v43 = 2082;
        v44 = handle + 632;
        v45 = 2080;
        v46 = " ";
        v47 = 1024;
        v48 = v33;
        v49 = 2048;
        v50 = v34;
        v51 = 2048;
        v52 = handle;
        _os_log_impl(&dword_181A37000, v31, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> Peeling off a new stream from %p", buf, 0x3Au);
        a2 = v30;
      }
    }

    v12 = a2;
    parameters = nw_protocol_get_parameters(a2);
    if (parameters)
    {
      v14 = parameters;
      nw_http3_stream_replace_protocol_instance(handle, parameters, handle, v3);
      if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
      {
        v35 = __nwlog_obj();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        {
          v36 = *(*(handle + 43) + 1304);
          v37 = *(handle + 30);
          *buf = 136447490;
          v42 = "nw_protocol_http3_stream_add_input_handler";
          v43 = 2082;
          v44 = handle + 632;
          v45 = 2080;
          v46 = " ";
          v47 = 1024;
          v48 = v36;
          v49 = 2048;
          v50 = v37;
          v51 = 2048;
          v52 = v14;
          _os_log_impl(&dword_181A37000, v35, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> Set connection protocol as instance in peeled off parameters %p", buf, 0x3Au);
        }
      }
    }

    if (*(handle + 43))
    {
      return nw_protocol_http3_add_input_handler(v3, v12);
    }

    return 0;
  }

  if (v3)
  {
    if ((*(handle + 366) & 0x2000) != 0 || gLogDatapath != 1)
    {
      return 0;
    }

    v5 = __nwlog_obj();
    result = os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);
    if (!result)
    {
      return result;
    }

    v7 = *(*(handle + 43) + 1304);
    v8 = *(handle + 30);
    *buf = 136447234;
    v42 = "nw_protocol_http3_stream_add_input_handler";
    v43 = 2082;
    v44 = handle + 632;
    v45 = 2080;
    v46 = " ";
    v47 = 1024;
    v48 = v7;
    v49 = 2048;
    v50 = v8;
    v9 = "%{public}s %{public}s%s<i%u:s%llu> Rejecting duplicate request for a stream";
    v10 = v5;
    v11 = 48;
    goto LABEL_56;
  }

  if (gLogDatapath != 1)
  {
    return 0;
  }

  v38 = __nwlog_obj();
  result = os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    *buf = 136446210;
    v42 = "nw_protocol_http3_stream_add_input_handler";
    v9 = "%{public}s Rejecting duplicate request for a stream";
    v10 = v38;
    v11 = 12;
LABEL_56:
    _os_log_impl(&dword_181A37000, v10, OS_LOG_TYPE_DEBUG, v9, buf, v11);
    return 0;
  }

  return result;
}

void ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_107(uint64_t a1, void *a2, int a3)
{
  v82 = *MEMORY[0x1E69E9840];
  if (a3 <= 1)
  {
    if (a3)
    {
      if (a3 != 1)
      {
        return;
      }

      outbound_body_size = nw_http_transaction_metadata_get_outbound_body_size(a2);
      v12 = *(a1 + 32);
      if (v12)
      {
        if ((*(v12 + 732) & 0x2000) != 0)
        {
          return;
        }
      }

      if (__nwlog_http_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_http_log::onceToken, &__block_literal_global_36);
      }

      v13 = ghttpLogObj;
      if (!os_log_type_enabled(ghttpLogObj, OS_LOG_TYPE_INFO))
      {
        return;
      }

      v14 = *(a1 + 32);
      v15 = (v14 + 632);
      v16 = "";
      v17 = v14 == 0;
      if (!v14)
      {
        v15 = "";
      }

      v18 = *(*(v14 + 344) + 1304);
      v19 = *(v14 + 240);
      if (!v17)
      {
        v16 = " ";
      }

      *buf = 136447490;
      v71 = "nw_protocol_http3_stream_connected_block_invoke";
      v72 = 2082;
      v73 = v15;
      v74 = 2080;
      v75 = v16;
      v76 = 1024;
      v77 = v18;
      v78 = 2048;
      v79 = v19;
      v80 = 2048;
      v81 = outbound_body_size;
      v20 = "%{public}s %{public}s%s<i%u:s%llu> finished sending {body_bytes=%llu}";
      goto LABEL_45;
    }

    outbound_message = nw_http_transaction_metadata_get_outbound_message(a2);
    v22 = nw_http_metadata_copy_request(outbound_message);
    v45 = nw_http_metadata_copy_response(outbound_message);
    if (v22)
    {
      v69[0] = MEMORY[0x1E69E9820];
      v69[1] = 0x40000000;
      v69[2] = ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_2;
      v69[3] = &__block_descriptor_tmp_108_65053;
      v69[4] = *(a1 + 32);
      v46 = v22;
      v47 = v69;
      _nw_http_request_access_method(v46, v47);
    }

    if (v45)
    {
      v26 = v45;
      status_code = _nw_http_response_get_status_code(v26);

      v49 = *(a1 + 32);
      if (v49 && (*(v49 + 732) & 0x2000) != 0)
      {
        goto LABEL_60;
      }

      if (__nwlog_http_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_http_log::onceToken, &__block_literal_global_36);
      }

      v29 = ghttpLogObj;
      if (!os_log_type_enabled(ghttpLogObj, OS_LOG_TYPE_INFO))
      {
        goto LABEL_60;
      }

      v50 = *(a1 + 32);
      v51 = (v50 + 632);
      v52 = "";
      v53 = v50 == 0;
      if (!v50)
      {
        v51 = "";
      }

      v54 = *(*(v50 + 344) + 1304);
      v55 = *(v50 + 240);
      if (!v53)
      {
        v52 = " ";
      }

      *buf = 136447490;
      v71 = "nw_protocol_http3_stream_connected_block_invoke";
      v72 = 2082;
      v73 = v51;
      v74 = 2080;
      v75 = v52;
      v76 = 1024;
      v77 = v54;
      v78 = 2048;
      v79 = v55;
      v80 = 1024;
      LODWORD(v81) = status_code;
      v36 = "%{public}s %{public}s%s<i%u:s%llu> sending response header {status=%hu}";
      goto LABEL_59;
    }
  }

  else
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
        if (a3 != 4)
        {
          return;
        }

        v63[0] = MEMORY[0x1E69E9820];
        v63[1] = 0x40000000;
        v64 = ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_111;
        v65 = &__block_descriptor_tmp_112;
        v5 = *(a1 + 32);
        v66 = a2;
        v67 = v5;
        v6 = nw_http_transaction_metadata_get_outbound_message(a2);
        v7 = v6;
        if (v6)
        {
          v8 = nw_http_metadata_copy_request(v6);
          v9 = nw_http_metadata_copy_response(v7);
          inbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
          if (!inbound_message)
          {
            goto LABEL_69;
          }

          if (v8)
          {
            if (v9)
            {
              goto LABEL_70;
            }

LABEL_68:
            v9 = nw_http_metadata_copy_response(inbound_message);
LABEL_69:
            if (!v9)
            {
              v58 = 0;
              if (!v8)
              {
                goto LABEL_84;
              }

              goto LABEL_73;
            }

LABEL_70:
            v9 = v9;
            v58 = _nw_http_response_get_status_code(v9);

            if (!v8)
            {
LABEL_84:
              v64(v63, "", v58);
              v59 = 0;
              if (!inbound_message)
              {
LABEL_75:
                if (v7)
                {
                  os_release(v7);
                }

                if (v9)
                {
                  os_release(v9);
                }

                if (v59)
                {
                  v56 = v59;
                  goto LABEL_81;
                }

                return;
              }

LABEL_74:
              os_release(inbound_message);
              goto LABEL_75;
            }

LABEL_73:
            v61[0] = MEMORY[0x1E69E9820];
            v61[1] = 0x40000000;
            v61[2] = ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_113;
            v61[3] = &unk_1E6A38EA8;
            v61[4] = v63;
            v62 = v58;
            v59 = v8;
            v60 = v61;
            _nw_http_request_access_method(v59, v60);

            if (!inbound_message)
            {
              goto LABEL_75;
            }

            goto LABEL_74;
          }
        }

        else
        {
          v57 = nw_http_transaction_metadata_get_inbound_message(a2);
          v9 = 0;
          if (!v57)
          {
            v58 = 0;
            inbound_message = 0;
            goto LABEL_84;
          }

          inbound_message = v57;
        }

        v8 = nw_http_metadata_copy_request(inbound_message);
        if (v9)
        {
          goto LABEL_70;
        }

        goto LABEL_68;
      }

      inbound_body_size = nw_http_transaction_metadata_get_inbound_body_size(a2);
      v38 = *(a1 + 32);
      if (v38 && (*(v38 + 732) & 0x2000) != 0)
      {
        return;
      }

      if (__nwlog_http_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_http_log::onceToken, &__block_literal_global_36);
      }

      v13 = ghttpLogObj;
      if (!os_log_type_enabled(ghttpLogObj, OS_LOG_TYPE_INFO))
      {
        return;
      }

      v39 = *(a1 + 32);
      v40 = (v39 + 632);
      v41 = "";
      v42 = v39 == 0;
      if (!v39)
      {
        v40 = "";
      }

      v43 = *(*(v39 + 344) + 1304);
      v44 = *(v39 + 240);
      if (!v42)
      {
        v41 = " ";
      }

      *buf = 136447490;
      v71 = "nw_protocol_http3_stream_connected_block_invoke";
      v72 = 2082;
      v73 = v40;
      v74 = 2080;
      v75 = v41;
      v76 = 1024;
      v77 = v43;
      v78 = 2048;
      v79 = v44;
      v80 = 2048;
      v81 = inbound_body_size;
      v20 = "%{public}s %{public}s%s<i%u:s%llu> finished receiving {body_bytes=%llu}";
LABEL_45:
      _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_INFO, v20, buf, 0x3Au);
      return;
    }

    outbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
    v22 = nw_http_metadata_copy_request(outbound_message);
    v23 = nw_http_metadata_copy_response(outbound_message);
    if (v22)
    {
      v68[0] = MEMORY[0x1E69E9820];
      v68[1] = 0x40000000;
      v68[2] = ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_109;
      v68[3] = &__block_descriptor_tmp_110;
      v68[4] = *(a1 + 32);
      v24 = v22;
      v25 = v68;
      _nw_http_request_access_method(v24, v25);
    }

    if (v23)
    {
      v26 = v23;
      v27 = _nw_http_response_get_status_code(v26);

      v28 = *(a1 + 32);
      if (v28 && (*(v28 + 732) & 0x2000) != 0)
      {
        goto LABEL_60;
      }

      if (__nwlog_http_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_http_log::onceToken, &__block_literal_global_36);
      }

      v29 = ghttpLogObj;
      if (!os_log_type_enabled(ghttpLogObj, OS_LOG_TYPE_INFO))
      {
        goto LABEL_60;
      }

      v30 = *(a1 + 32);
      v31 = (v30 + 632);
      v32 = "";
      v33 = v30 == 0;
      if (!v30)
      {
        v31 = "";
      }

      v34 = *(*(v30 + 344) + 1304);
      v35 = *(v30 + 240);
      if (!v33)
      {
        v32 = " ";
      }

      *buf = 136447490;
      v71 = "nw_protocol_http3_stream_connected_block_invoke";
      v72 = 2082;
      v73 = v31;
      v74 = 2080;
      v75 = v32;
      v76 = 1024;
      v77 = v34;
      v78 = 2048;
      v79 = v35;
      v80 = 1024;
      LODWORD(v81) = v27;
      v36 = "%{public}s %{public}s%s<i%u:s%llu> receiving response header {status=%hu}";
LABEL_59:
      _os_log_impl(&dword_181A37000, v29, OS_LOG_TYPE_INFO, v36, buf, 0x36u);
LABEL_60:
      os_release(v26);
    }
  }

  if (v22)
  {
    os_release(v22);
  }

  if (outbound_message)
  {
    v56 = outbound_message;
LABEL_81:
    os_release(v56);
  }
}

void ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_111(uint64_t a1, uint64_t a2, int a3)
{
  v66 = *MEMORY[0x1E69E9840];
  start_reason = nw_http_transaction_metadata_get_start_reason(*(a1 + 32));
  start_time = nw_http_transaction_metadata_get_start_time(*(a1 + 32));
  end_time = nw_http_transaction_metadata_get_end_time(*(a1 + 32));
  outbound_message_start_time = nw_http_transaction_metadata_get_outbound_message_start_time(*(a1 + 32));
  outbound_message_end_time = nw_http_transaction_metadata_get_outbound_message_end_time(*(a1 + 32));
  inbound_message_start_time = nw_http_transaction_metadata_get_inbound_message_start_time(*(a1 + 32));
  inbound_message_end_time = nw_http_transaction_metadata_get_inbound_message_end_time(*(a1 + 32));
  outbound_body_size = nw_http_transaction_metadata_get_outbound_body_size(*(a1 + 32));
  inbound_body_size = nw_http_transaction_metadata_get_inbound_body_size(*(a1 + 32));
  v12 = *(a1 + 40);
  if (!v12 || (*(v12 + 732) & 0x2000) == 0)
  {
    if (__nwlog_http_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_http_log::onceToken, &__block_literal_global_36);
    }

    v13 = ghttpLogObj;
    if (os_log_type_enabled(ghttpLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v14 = *(a1 + 40);
      if (v14)
      {
        v15 = (v14 + 632);
      }

      else
      {
        v15 = "";
      }

      v16 = " ";
      if (!v14)
      {
        v16 = "";
      }

      v31 = v15;
      v32 = v16;
      if ((start_reason - 1) > 3)
      {
        v17 = "initial";
      }

      else
      {
        v17 = off_1E6A3AE00[start_reason - 1];
      }

      v28 = *(*(v14 + 344) + 1304);
      v29 = *(v14 + 240);
      v30 = v17;
      v18 = -1;
      if (start_time && end_time)
      {
        v19 = nw_delta_nanos(start_time, end_time);
        if (v19 > 0xF423FFFFFFFFFLL)
        {
          v18 = -1;
        }

        else
        {
          v18 = v19 / 0xF4240;
        }
      }

      v20 = -1;
      if (start_time && outbound_message_start_time)
      {
        v21 = nw_delta_nanos(start_time, outbound_message_start_time);
        if (v21 > 0xF423FFFFFFFFFLL)
        {
          v20 = -1;
        }

        else
        {
          v20 = v21 / 0xF4240;
        }
      }

      v22 = -1;
      if (outbound_message_start_time && outbound_message_end_time)
      {
        v23 = nw_delta_nanos(outbound_message_start_time, outbound_message_end_time);
        if (v23 > 0xF423FFFFFFFFFLL)
        {
          v22 = -1;
        }

        else
        {
          v22 = v23 / 0xF4240;
        }
      }

      v24 = -1;
      if (start_time && inbound_message_start_time)
      {
        v25 = nw_delta_nanos(start_time, inbound_message_start_time);
        if (v25 > 0xF423FFFFFFFFFLL)
        {
          v24 = -1;
        }

        else
        {
          v24 = v25 / 0xF4240;
        }
      }

      LODWORD(v26) = -1;
      if (inbound_message_start_time && inbound_message_end_time)
      {
        v27 = nw_delta_nanos(inbound_message_start_time, inbound_message_end_time);
        v26 = v27 / 0xF4240;
        if (v27 > 0xF423FFFFFFFFFLL)
        {
          LODWORD(v26) = -1;
        }
      }

      *buf = 136449794;
      v37 = "nw_protocol_http3_stream_connected_block_invoke";
      v38 = 2082;
      v39 = v31;
      v40 = 2080;
      v41 = v32;
      v42 = 1024;
      v43 = v28;
      v44 = 2048;
      v45 = v29;
      v46 = 2080;
      v47 = v30;
      v48 = 1024;
      v49 = v18;
      v50 = 2082;
      v51 = a2;
      v52 = 1024;
      v53 = a3;
      v54 = 1024;
      v55 = v20;
      v56 = 1024;
      v57 = v22;
      v58 = 1024;
      v59 = v24;
      v60 = 1024;
      v61 = v26;
      v62 = 2048;
      v63 = outbound_body_size;
      v64 = 2048;
      v65 = inbound_body_size;
      _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u:s%llu> transaction summary {start_reason=%s, duration_ms=%d, request_method=%{public}s, response_status=%hu, outbound_start_ms=%d, outbound_duration_ms=%d, inbound_start_ms=%d, inbound_duration_ms=%d, outbound_body_bytes=%llu, inbound_body_bytes=%llu}", buf, 0x7Cu);
    }
  }
}

void ___ZL32nw_http3_start_0rtt_state_lookupP17nw_protocol_http3_block_invoke(uint64_t a1, NSObject *a2, NSObject *a3, NSObject *a4)
{
  v7 = (*(*(a1 + 32) + 16))();
  if (v7)
  {
    v8 = v7;
    v9 = *(v7 + 1397);
    if ((v9 & 8) == 0)
    {
      *(v7 + 1397) = v9 | 0x40;
      if (a2 && a3 && a4)
      {
        v10 = *(v7 + 1168);
        if (v10)
        {
          dispatch_release(v10);
        }

        v8[146] = a2;
        dispatch_retain(a2);
        v11 = v8[144];
        if (v11)
        {
          dispatch_release(v11);
        }

        v8[144] = a3;
        dispatch_retain(a3);
        v12 = v8[145];
        if (v12)
        {
          dispatch_release(v12);
        }

        v8[145] = a4;
        dispatch_retain(a4);
      }

      nw_http3_setup_connection_if_needed(v8);
      for (i = v8[111]; i; i = *(i + 536))
      {
        nw_http3_stream_connect_lower(i);
      }

      nw_http3_signal_output_pending(v8, 0);
    }
  }
}

uint64_t nw_protocol_http3_stream_unregister_notification(uint64_t a1, uint64_t a2, int a3)
{
  v28 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v3 = *(a1 + 40);
    if (v3)
    {
      if (a3 == 5)
      {
        if ((*(v3 + 732) & 0x2000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v4 = gLogObj;
          if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_INFO))
          {
            v5 = *(*(v3 + 344) + 1304);
            v6 = *(v3 + 240);
            *buf = 136447234;
            v19 = "nw_protocol_http3_stream_unregister_notification";
            v20 = 2082;
            v21 = (v3 + 632);
            v22 = 2080;
            v23 = " ";
            v24 = 1024;
            v25 = v5;
            v26 = 2048;
            v27 = v6;
            _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> unregistered metadata_changed notification", buf, 0x30u);
          }
        }

        *(v3 + 734) &= ~8u;
        return 1;
      }

      else
      {

        return nw_protocol_common_unregister_notification(a1, a2, a3);
      }
    }

    __nwlog_obj();
    *buf = 136446210;
    v19 = "nw_protocol_http3_stream_unregister_notification";
    v8 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v8, &type, &v16))
    {
      goto LABEL_39;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_http3_stream_unregister_notification";
        v11 = "%{public}s called with null http3_stream";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (v16 != 1)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_http3_stream_unregister_notification";
        v11 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    backtrace_string = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *buf = 136446210;
        v19 = "nw_protocol_http3_stream_unregister_notification";
        v11 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (v15)
    {
      *buf = 136446466;
      v19 = "nw_protocol_http3_stream_unregister_notification";
      v20 = 2082;
      v21 = backtrace_string;
      v14 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_28;
    }

    goto LABEL_29;
  }

  __nwlog_obj();
  *buf = 136446210;
  v19 = "nw_protocol_http3_stream_unregister_notification";
  v8 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v8, &type, &v16))
  {
    goto LABEL_39;
  }

  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v16 != 1)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v19 = "nw_protocol_http3_stream_unregister_notification";
        v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    backtrace_string = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v13 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *buf = 136446210;
        v19 = "nw_protocol_http3_stream_unregister_notification";
        v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (v13)
    {
      *buf = 136446466;
      v19 = "nw_protocol_http3_stream_unregister_notification";
      v20 = 2082;
      v21 = backtrace_string;
      v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_28:
      _os_log_impl(&dword_181A37000, v9, v10, v14, buf, 0x16u);
    }

LABEL_29:
    free(backtrace_string);
    goto LABEL_39;
  }

  v9 = __nwlog_obj();
  v10 = type;
  if (os_log_type_enabled(v9, type))
  {
    *buf = 136446210;
    v19 = "nw_protocol_http3_stream_unregister_notification";
    v11 = "%{public}s called with null protocol";
LABEL_38:
    _os_log_impl(&dword_181A37000, v9, v10, v11, buf, 0xCu);
  }

LABEL_39:
  if (v8)
  {
    free(v8);
  }

  return 0;
}

uint64_t ___ZL47nw_protocol_http3_stream_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_150(uint64_t a1, uint64_t a2)
{
  v4 = nw_frame_copy_metadata_for_protocol(a2, *(a1 + 32));
  if (v4)
  {
    v5 = v4;
    if (nw_http_metadata_is_capsule(v4))
    {
      v6 = *(*(a1 + 40) + 528);
      if (v6 || (v6 = _nw_array_create(), (*(*(a1 + 40) + 528) = v6) != 0))
      {
        _nw_array_append(v6, v5);
      }
    }

    os_release(v5);
  }

  if (*(a2 + 80) == nw_protocol_http3_capsule_frame_finalizer)
  {
    v7 = (*(a1 + 48) + 8);
    v8 = *(a2 + 32);
    v9 = *(a2 + 40);
    if (v8)
    {
      v7 = (v8 + 40);
    }

    *v7 = v9;
    *v9 = v8;
    *(a2 + 32) = 0;
    *(a2 + 40) = 0;
    nw_frame_finalize(a2);
  }

  return 1;
}

void nw_http3_stream_send_pending_capsules(uint64_t a1)
{
  v2 = *(a1 + 528);
  if (v2 && !_nw_array_is_empty(v2))
  {
    v3 = _nw_array_create();
    v4 = *(a1 + 528);
    aBlock[0] = MEMORY[0x1E69E9820];
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZL37nw_http3_stream_send_pending_capsulesP24nw_protocol_http3_stream_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_119_65236;
    aBlock[4] = a1;
    aBlock[5] = v3;
    if (v4)
    {
      _nw_array_apply(v4, aBlock);
    }

    v5[0] = MEMORY[0x1E69E9820];
    v5[1] = 0x40000000;
    v5[2] = ___ZL37nw_http3_stream_send_pending_capsulesP24nw_protocol_http3_stream_block_invoke_120;
    v5[3] = &__block_descriptor_tmp_121_65237;
    v5[4] = a1;
    if (v3)
    {
      _nw_array_apply(v3, v5);
      os_release(v3);
    }
  }
}

uint64_t ___ZL37nw_http3_stream_send_pending_capsulesP24nw_protocol_http3_stream_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  v3 = a3;
  v102 = *MEMORY[0x1E69E9840];
  capsule_type = nw_http_metadata_get_capsule_type(a3);
  v86 = 0;
  v87 = &v86;
  v88 = 0x2000000000;
  v89 = nw_http_metadata_copy_capsule_data(v3);
  v80 = 0;
  v81 = &v80;
  v82 = 0x3802000000;
  v83 = __Block_byref_object_copy__63268;
  v84 = __Block_byref_object_dispose__63269;
  v85[0] = 0;
  v85[1] = v85;
  size = dispatch_data_get_size(v87[3]);
  v76 = 0;
  v77 = &v76;
  v78 = 0x2000000000;
  v79 = size;
  v68 = a1;
  v7 = *(a1 + 32);
  v8 = *(v7 + 160);
  if (!v8 || (v9 = *(v8 + 24)) == 0 || !*(v9 + 88))
  {
    v65 = __nwlog_obj();
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v93 = "nw_http3_framer_get_output_frames_for_capsule";
      v94 = 2048;
      v95 = v8;
      _os_log_impl(&dword_181A37000, v65, OS_LOG_TYPE_ERROR, "%{public}s Output handler (%p)'s get_output_frames callback is not properly set", buf, 0x16u);
    }

    goto LABEL_77;
  }

  v69 = capsule_type;
  if (capsule_type >= 0x40)
  {
    if (capsule_type >= 0x4000)
    {
      if (capsule_type >> 30)
      {
        if (capsule_type >> 62)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
          *buf = 136446466;
          v93 = "_http_vle_length";
          v94 = 2048;
          v95 = capsule_type;
          v11 = _os_log_send_and_compose_impl();
          result = __nwlog_should_abort(v11);
          if (result)
          {
            goto LABEL_115;
          }

          free(v11);
          v10 = 0;
        }

        else
        {
          v10 = 8;
        }
      }

      else
      {
        v10 = 4;
      }
    }

    else
    {
      v10 = 2;
    }
  }

  else
  {
    v10 = 1;
  }

  if (size >> 30)
  {
    v13 = 8;
  }

  else
  {
    v13 = 4;
  }

  if (size >= 0x4000)
  {
    v14 = v13;
  }

  else
  {
    v14 = 2;
  }

  if (size >= 0x40)
  {
    v15 = v14;
  }

  else
  {
    v15 = 1;
  }

  v16 = v15 + v10;
  v17 = v15 + v10 + size;
  if (v17 >> 30)
  {
    v18 = 9;
  }

  else
  {
    v18 = 5;
  }

  if (v17 >= 0x4000)
  {
    v19 = v18;
  }

  else
  {
    v19 = 3;
  }

  if (v17 >= 0x40)
  {
    v20 = v19;
  }

  else
  {
    v20 = 2;
  }

  v21 = v17 + v20;
  if (__CFADD__(v17, v20))
  {
    v67 = v3;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446978;
    v93 = "nw_http3_framer_get_output_frames_for_capsule";
    v94 = 2082;
    v95 = "frame_length";
    v96 = 2048;
    v97 = v20;
    v98 = 2048;
    v99 = v21;
    v22 = _os_log_send_and_compose_impl();
    v91 = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (__nwlog_fault(v22, &v91, &v90))
    {
      if (v91 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v24 = v91;
        if (os_log_type_enabled(gLogObj, v91))
        {
          *buf = 136446978;
          v93 = "nw_http3_framer_get_output_frames_for_capsule";
          v94 = 2082;
          v95 = "frame_length";
          v96 = 2048;
          v97 = v20;
          v98 = 2048;
          v99 = v21;
          v25 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_45:
          v29 = v23;
          v30 = v24;
LABEL_46:
          _os_log_impl(&dword_181A37000, v29, v30, v25, buf, 0x2Au);
        }
      }

      else if (v90 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v27 = gLogObj;
        type = v91;
        v28 = os_log_type_enabled(gLogObj, v91);
        if (backtrace_string)
        {
          if (v28)
          {
            *buf = 136447234;
            v93 = "nw_http3_framer_get_output_frames_for_capsule";
            v94 = 2082;
            v95 = "frame_length";
            v96 = 2048;
            v97 = v20;
            v98 = 2048;
            v99 = v21;
            v100 = 2082;
            v101 = backtrace_string;
            _os_log_impl(&dword_181A37000, v27, type, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }

          free(backtrace_string);
          goto LABEL_47;
        }

        if (v28)
        {
          *buf = 136446978;
          v93 = "nw_http3_framer_get_output_frames_for_capsule";
          v94 = 2082;
          v95 = "frame_length";
          v96 = 2048;
          v97 = v20;
          v98 = 2048;
          v99 = v21;
          v25 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          v29 = v27;
          v30 = type;
          goto LABEL_46;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v24 = v91;
        if (os_log_type_enabled(gLogObj, v91))
        {
          *buf = 136446978;
          v93 = "nw_http3_framer_get_output_frames_for_capsule";
          v94 = 2082;
          v95 = "frame_length";
          v96 = 2048;
          v97 = v20;
          v98 = 2048;
          v99 = v21;
          v25 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_45;
        }
      }
    }

LABEL_47:
    if (v22)
    {
      free(v22);
    }

    v21 = 0xFFFFFFFFLL;
    v3 = v67;
  }

  if (!(*(*(v8 + 24) + 88))(v8, *(v7 + 152), v21, v21, 0xFFFFFFFFLL, v85))
  {
LABEL_77:
    v50 = 0;
LABEL_78:
    _Block_object_dispose(&v76, 8);
    _Block_object_dispose(&v80, 8);
    _Block_object_dispose(&v86, 8);
    return v50;
  }

  nw_http3_framer_claim_http3_frame_header(v16 + v20, v85[0]);
  v70[0] = MEMORY[0x1E69E9820];
  v70[1] = 0x40000000;
  v71 = ___ZL37nw_http3_stream_send_pending_capsulesP24nw_protocol_http3_stream_block_invoke_2;
  v72 = &unk_1E6A38EF0;
  v73 = &v86;
  v74 = &v76;
  v75 = &v80;
  v31 = v81[5];
  do
  {
    if (!v31)
    {
      break;
    }

    v32 = *(v31 + 32);
    v33 = v71(v70);
    v31 = v32;
  }

  while ((v33 & 1) != 0);
  if (v87[3])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v93 = "nw_http3_stream_send_pending_capsules_block_invoke";
    v34 = _os_log_send_and_compose_impl();
    v91 = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (!__nwlog_fault(v34, &v91, &v90))
    {
      goto LABEL_75;
    }

    if (v91 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v35 = gLogObj;
      v36 = v91;
      if (!os_log_type_enabled(gLogObj, v91))
      {
        goto LABEL_75;
      }

      *buf = 136446210;
      v93 = "nw_http3_stream_send_pending_capsules_block_invoke";
      v37 = "%{public}s Not enough space in capsule frames";
    }

    else
    {
      if (v90 == 1)
      {
        v44 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v45 = gLogObj;
        v46 = v91;
        v47 = os_log_type_enabled(gLogObj, v91);
        if (v44)
        {
          if (v47)
          {
            *buf = 136446466;
            v93 = "nw_http3_stream_send_pending_capsules_block_invoke";
            v94 = 2082;
            v95 = v44;
            _os_log_impl(&dword_181A37000, v45, v46, "%{public}s Not enough space in capsule frames, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v44);
          goto LABEL_75;
        }

        if (!v47)
        {
LABEL_75:
          if (v34)
          {
            free(v34);
          }

          goto LABEL_77;
        }

        *buf = 136446210;
        v93 = "nw_http3_stream_send_pending_capsules_block_invoke";
        v37 = "%{public}s Not enough space in capsule frames, no backtrace";
        v48 = v45;
        v49 = v46;
LABEL_74:
        _os_log_impl(&dword_181A37000, v48, v49, v37, buf, 0xCu);
        goto LABEL_75;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v35 = gLogObj;
      v36 = v91;
      if (!os_log_type_enabled(gLogObj, v91))
      {
        goto LABEL_75;
      }

      *buf = 136446210;
      v93 = "nw_http3_stream_send_pending_capsules_block_invoke";
      v37 = "%{public}s Not enough space in capsule frames, backtrace limit exceeded";
    }

    v48 = v35;
    v49 = v36;
    goto LABEL_74;
  }

  v38 = *(v68 + 32);
  v39 = *(v38 + 160);
  if (!v39 || (v40 = *(v39 + 24)) == 0 || !*(v40 + 96))
  {
LABEL_108:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v63 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_INFO))
    {
      *buf = 136446722;
      v93 = "nw_http3_stream_send_pending_capsules_block_invoke";
      v94 = 2048;
      v95 = v69;
      v96 = 2048;
      v97 = size;
      _os_log_impl(&dword_181A37000, v63, OS_LOG_TYPE_INFO, "%{public}s Sending capsule type 0x%llx length %zu", buf, 0x20u);
    }

    v64 = *(v68 + 40);
    v50 = 1;
    if (v64 && v3)
    {
      _nw_array_append(v64, v3);
    }

    goto LABEL_78;
  }

  v41 = *(v77 + 6);
  v42 = v81;
  if (v69 < 0x40)
  {
    v43 = 1;
LABEL_89:
    if (v41 >> 30)
    {
      v54 = 8;
    }

    else
    {
      v54 = 4;
    }

    if (v41 >= 0x4000)
    {
      v55 = v54;
    }

    else
    {
      v55 = 2;
    }

    if (v41 >= 0x40)
    {
      v56 = v55;
    }

    else
    {
      v56 = 1;
    }

    v57 = v56 + v43;
    v58 = v56 + v43 + v41;
    if (v58 >> 30)
    {
      v59 = 9;
    }

    else
    {
      v59 = 5;
    }

    if (v58 >= 0x4000)
    {
      v60 = v59;
    }

    else
    {
      v60 = 3;
    }

    if (v58 >= 0x40)
    {
      v61 = v60;
    }

    else
    {
      v61 = 2;
    }

    v62 = v42[5];
    nw_http3_framer_write_http3_frame_header(v38 + 128, v69, v41, v57, v62);
    nw_http3_framer_write_http3_frame_header(v38 + 128, 0, v58, v61, v62);
    (*(*(v39 + 24) + 96))(v39, v42 + 5);
    goto LABEL_108;
  }

  if (v69 < 0x4000)
  {
    v43 = 2;
    goto LABEL_89;
  }

  if (!(v69 >> 30))
  {
    v43 = 4;
    goto LABEL_89;
  }

  if (!(v69 >> 62))
  {
    v43 = 8;
    goto LABEL_89;
  }

  v51 = *(v77 + 6);
  v52 = __nwlog_obj();
  os_log_type_enabled(v52, OS_LOG_TYPE_ERROR);
  *buf = 136446466;
  v93 = "_http_vle_length";
  v94 = 2048;
  v95 = v69;
  v53 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v53);
  if (!result)
  {
    free(v53);
    v43 = 0;
    v41 = v51;
    goto LABEL_89;
  }

LABEL_115:
  __break(1u);
  return result;
}

BOOL ___ZL37nw_http3_stream_send_pending_capsulesP24nw_protocol_http3_stream_block_invoke_2(void *a1, uint64_t a2)
{
  v36 = *MEMORY[0x1E69E9840];
  if ((nw_frame_uses_external_data(a2) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v33 = "nw_http3_stream_send_pending_capsules_block_invoke_2";
    v8 = _os_log_send_and_compose_impl();
    LOBYTE(offset) = 16;
    offset_7 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v8, &offset, &offset_7))
    {
      if (offset == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = offset;
        if (os_log_type_enabled(gLogObj, offset))
        {
          *buf = 136446210;
          v33 = "nw_http3_stream_send_pending_capsules_block_invoke";
          v11 = "%{public}s Capsule frame does not support external data";
LABEL_23:
          v20 = v9;
          v21 = v10;
LABEL_24:
          _os_log_impl(&dword_181A37000, v20, v21, v11, buf, 0xCu);
        }
      }

      else if (offset_7 == OS_LOG_TYPE_INFO)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = gLogObj;
        v18 = offset;
        v19 = os_log_type_enabled(gLogObj, offset);
        if (backtrace_string)
        {
          if (v19)
          {
            *buf = 136446466;
            v33 = "nw_http3_stream_send_pending_capsules_block_invoke";
            v34 = 2082;
            v35 = backtrace_string;
            _os_log_impl(&dword_181A37000, v17, v18, "%{public}s Capsule frame does not support external data, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v19)
        {
          *buf = 136446210;
          v33 = "nw_http3_stream_send_pending_capsules_block_invoke";
          v11 = "%{public}s Capsule frame does not support external data, no backtrace";
          v20 = v17;
          v21 = v18;
          goto LABEL_24;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = offset;
        if (os_log_type_enabled(gLogObj, offset))
        {
          *buf = 136446210;
          v33 = "nw_http3_stream_send_pending_capsules_block_invoke";
          v11 = "%{public}s Capsule frame does not support external data, backtrace limit exceeded";
          goto LABEL_23;
        }
      }
    }

LABEL_25:
    if (v8)
    {
      free(v8);
    }

    return 0;
  }

  offset = 0;
  nw_frame_set_external_data(a2, *(*(a1[4] + 8) + 24), &offset);
  v4 = *(*(a1[5] + 8) + 24);
  v5 = *(*(a1[4] + 8) + 24);
  v6 = offset < v4;
  if (offset < v4)
  {
    if (v5)
    {
      v7 = *(*(a1[4] + 8) + 24);
      dispatch_release(v5);
      *(*(a1[4] + 8) + 24) = 0;
      *(*(a1[4] + 8) + 24) = dispatch_data_create_subrange(v7, offset, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(v7);
    }

    else
    {
      *(*(a1[4] + 8) + 24) = dispatch_data_create_subrange(0, offset, 0xFFFFFFFFFFFFFFFFLL);
    }

    *(*(a1[5] + 8) + 24) -= offset;
    return v6;
  }

  if (v5)
  {
    dispatch_release(v5);
    *(*(a1[4] + 8) + 24) = 0;
  }

  if (**(*(*(a1[6] + 8) + 48) + 8) != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v33 = "nw_http3_stream_send_pending_capsules_block_invoke";
    v12 = _os_log_send_and_compose_impl();
    offset_7 = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v12, &offset_7, &v29))
    {
      goto LABEL_41;
    }

    if (offset_7 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = offset_7;
      if (!os_log_type_enabled(gLogObj, offset_7))
      {
        goto LABEL_41;
      }

      *buf = 136446210;
      v33 = "nw_http3_stream_send_pending_capsules_block_invoke";
      v15 = "%{public}s Too much space in capsule frames";
    }

    else
    {
      if (v29 == 1)
      {
        v22 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v24 = offset_7;
        v25 = os_log_type_enabled(gLogObj, offset_7);
        if (v22)
        {
          if (v25)
          {
            *buf = 136446466;
            v33 = "nw_http3_stream_send_pending_capsules_block_invoke";
            v34 = 2082;
            v35 = v22;
            _os_log_impl(&dword_181A37000, v23, v24, "%{public}s Too much space in capsule frames, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v22);
          goto LABEL_41;
        }

        if (!v25)
        {
LABEL_41:
          if (v12)
          {
            free(v12);
          }

          return v6;
        }

        *buf = 136446210;
        v33 = "nw_http3_stream_send_pending_capsules_block_invoke";
        v15 = "%{public}s Too much space in capsule frames, no backtrace";
        v26 = v23;
        v27 = v24;
LABEL_40:
        _os_log_impl(&dword_181A37000, v26, v27, v15, buf, 0xCu);
        goto LABEL_41;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = offset_7;
      if (!os_log_type_enabled(gLogObj, offset_7))
      {
        goto LABEL_41;
      }

      *buf = 136446210;
      v33 = "nw_http3_stream_send_pending_capsules_block_invoke";
      v15 = "%{public}s Too much space in capsule frames, backtrace limit exceeded";
    }

    v26 = v13;
    v27 = v14;
    goto LABEL_40;
  }

  return v6;
}

void nw_protocol_http3_capsule_frame_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  nw_frame_reset(a1, 0, 0, 0, 0);
  if (a1)
  {

    os_release(a1);
  }
}

void ___ZL64nw_http3_framer_finalize_output_frames_for_multiple_http3_framesP15nw_http3_framer21nw_http3_frame_type_tP16nw_frame_array_sPjS4_Pc_block_invoke_2(uint64_t a1)
{
  v16 = *MEMORY[0x1E69E9840];
  if (!*(a1 + 32))
  {
    v2 = nw_frame_unclaimed_bytes(*(a1 + 40), 0);
    if (__nwlog_http_diagnostics_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_http_diagnostics_log::onceToken, &__block_literal_global_40_47449);
    }

    v3 = ghttp_diagnosticsLogObj;
    if (os_log_type_enabled(ghttp_diagnosticsLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *(a1 + 48);
      v5 = "";
      v6 = v4 == 0;
      if (!v4)
      {
        v4 = "";
      }

      v7 = *(a1 + 56);
      v8 = 136446978;
      if (!v6)
      {
        v5 = " ";
      }

      v9 = v4;
      v10 = 2080;
      v11 = v5;
      v12 = 1040;
      v13 = v7;
      v14 = 2096;
      v15 = v2;
      _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_DEFAULT, "%{public}s%sH3 Outbound Body Data:\n%{network:data}.*P", &v8, 0x26u);
    }
  }
}

uint64_t ___ZL41nw_protocol_http3_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  v65 = *MEMORY[0x1E69E9840];
  v3 = *(a1 + 80);
  v4 = *(a1 + 104) == 1 && *(v3 + 216) == 0;
  if (*(v3 + 380) != 8)
  {
    if ((*(v3 + 732) & 0x2000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        v8 = *(*(v3 + 344) + 1304);
        v9 = *(v3 + 240);
        v10 = *(v3 + 380);
        *buf = 136447490;
        v50 = "nw_http3_stream_frame_received_for_capsule";
        v51 = 2082;
        v52 = (v3 + 632);
        v53 = 2080;
        v54 = " ";
        v55 = 1024;
        v56 = v8;
        v57 = 2048;
        v58 = v9;
        v59 = 1024;
        LODWORD(v60) = v10;
        _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> processing capsule data in incorrect state %u", buf, 0x36u);
      }
    }

    goto LABEL_18;
  }

  v5 = *(a1 + 88);
  if ((*(v3 + 732) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v31 = *(a1 + 96);
    v32 = a1;
    v33 = __nwlog_obj();
    v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG);
    a1 = v32;
    if (v34)
    {
      v35 = *(*(v3 + 344) + 1304);
      v36 = *(v3 + 240);
      *buf = 136448002;
      v50 = "nw_http3_stream_frame_received_for_capsule";
      v51 = 2082;
      v52 = (v3 + 632);
      v53 = 2080;
      v54 = " ";
      v55 = 1024;
      v56 = v35;
      v57 = 2048;
      v58 = v36;
      v59 = 2048;
      v60 = v5;
      v61 = 2048;
      v62 = v31;
      v63 = 1024;
      v64 = v4;
      _os_log_impl(&dword_181A37000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> received frame type %llu, length %llu, complete %{BOOL}d", buf, 0x4Au);
      a1 = v32;
    }
  }

  if (v5 > 0xD)
  {
    goto LABEL_15;
  }

  if (((1 << v5) & 0x2098) != 0)
  {
LABEL_17:
    nw_http3_fail_all_streams(*(v3 + 344), 261);
LABEL_18:
    v6 = 0;
    return v6 & 1;
  }

  if (v5)
  {
    if (v5 == 1)
    {
      v6 = 0;
      *(v3 + 380) = 5;
      return v6 & 1;
    }

LABEL_15:
    if (v5 == 65 || v5 == 4287504053)
    {
      goto LABEL_17;
    }

    v12 = a1;
    if ((*(v3 + 732) & 0x2000) == 0 && gLogDatapath == 1)
    {
      v37 = __nwlog_obj();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
      {
        v38 = *(*(v3 + 344) + 1304);
        v39 = *(v3 + 240);
        *buf = 136447234;
        v50 = "nw_http3_stream_frame_received_for_capsule";
        v51 = 2082;
        v52 = (v3 + 632);
        v53 = 2080;
        v54 = " ";
        v55 = 1024;
        v56 = v38;
        v57 = 2048;
        v58 = v39;
        _os_log_impl(&dword_181A37000, v37, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> dropping unknown frame type", buf, 0x30u);
      }
    }

    nw_frame_finalize(a2);
    a1 = v12;
  }

  v13 = a1;
  v46 = 0;
  v14 = nw_frame_unclaimed_bytes(a2, &v46);
  if (v14)
  {
    v15 = v13;
    if (*(*(v13[4] + 8) + 24))
    {
      goto LABEL_33;
    }

    v16 = *(*(v13[5] + 8) + 24);
    if (16 - v16 >= v46)
    {
      v17 = v46;
    }

    else
    {
      v17 = 16 - v16;
    }

    memcpy((*(*(v13[6] + 8) + 24) + v16), v14, v17);
    *(*(v13[5] + 8) + 24) += v17;
    v18 = *(*(v13[6] + 8) + 24);
    if (v18)
    {
      v15 = v13;
      v19 = *(*(v13[5] + 8) + 24);
      if (*(*(v13[5] + 8) + 24))
      {
        v20 = *v18;
        if (v20 > 0x3F)
        {
          v27 = v20 >> 6;
          if (v27 == 2)
          {
            if (v19 < 4)
            {
              goto LABEL_33;
            }

            v20 = bswap32(*v18 & 0xFFFFFF7F);
            v21 = 4;
          }

          else if (v27 == 1)
          {
            if (v19 == 1)
            {
              goto LABEL_33;
            }

            v20 = bswap32(*v18 & 0xFFBF) >> 16;
            v21 = 2;
          }

          else
          {
            if (v19 < 8)
            {
              goto LABEL_33;
            }

            v20 = bswap64(*v18 & 0xFFFFFFFFFFFFFF3FLL);
            v21 = 8;
          }
        }

        else
        {
          v21 = 1;
        }

        *(*(v13[7] + 8) + 24) = v20;
        v22 = v21;
        *(*(v13[8] + 8) + 24) = v21;
        v23 = v19 - v21;
        if (v23)
        {
          v28 = *(v18 + v22);
          if (v28 > 0x3F)
          {
            v30 = v28 >> 6;
            if (v30 == 2)
            {
              if (v23 < 4)
              {
                goto LABEL_33;
              }

              v28 = bswap32(*(v18 + v22) & 0xFFFFFF7F);
              v29 = 4;
            }

            else if (v30 == 1)
            {
              if (v23 == 1)
              {
                goto LABEL_33;
              }

              v28 = bswap32(*(v18 + v22) & 0xFFBF) >> 16;
              v29 = 2;
            }

            else
            {
              if (v23 < 8)
              {
                goto LABEL_33;
              }

              v28 = bswap64(*(v18 + v22) & 0xFFFFFFFFFFFFFF3FLL);
              v29 = 8;
            }
          }

          else
          {
            v29 = 1;
          }

          v6 = 0;
          *(*(v13[9] + 8) + 24) = v28;
          *(*(v13[8] + 8) + 24) += v29;
          *(*(v13[5] + 8) + 24) = 0;
          *(*(v13[4] + 8) + 24) = 1;
          return v6 & 1;
        }
      }

LABEL_33:
      v6 = *(*(v15[4] + 8) + 24) ^ 1;
      return v6 & 1;
    }

    __nwlog_obj();
    *buf = 136446210;
    v50 = "_http_vle_decode";
    v40 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (__nwlog_fault(v40, &type, &v47))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v41 = __nwlog_obj();
        v42 = type;
        if (os_log_type_enabled(v41, type))
        {
          *buf = 136446210;
          v50 = "_http_vle_decode";
          v43 = "%{public}s called with null *buffer";
LABEL_73:
          _os_log_impl(&dword_181A37000, v41, v42, v43, buf, 0xCu);
        }
      }

      else if (v47 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v41 = __nwlog_obj();
        v42 = type;
        v45 = os_log_type_enabled(v41, type);
        if (backtrace_string)
        {
          if (v45)
          {
            *buf = 136446466;
            v50 = "_http_vle_decode";
            v51 = 2082;
            v52 = backtrace_string;
            _os_log_impl(&dword_181A37000, v41, v42, "%{public}s called with null *buffer, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_74;
        }

        if (v45)
        {
          *buf = 136446210;
          v50 = "_http_vle_decode";
          v43 = "%{public}s called with null *buffer, no backtrace";
          goto LABEL_73;
        }
      }

      else
      {
        v41 = __nwlog_obj();
        v42 = type;
        if (os_log_type_enabled(v41, type))
        {
          *buf = 136446210;
          v50 = "_http_vle_decode";
          v43 = "%{public}s called with null *buffer, backtrace limit exceeded";
          goto LABEL_73;
        }
      }
    }

LABEL_74:
    if (v40)
    {
      free(v40);
    }

    v15 = v13;
    goto LABEL_33;
  }

  v24 = (v13[10] + 224);
  v25 = *(a2 + 32);
  v26 = *(a2 + 40);
  if (v25)
  {
    v24 = (v25 + 40);
  }

  *v24 = v26;
  *v26 = v25;
  *(a2 + 32) = 0;
  *(a2 + 40) = 0;
  v6 = 1;
  nw_frame_finalize(a2);
  return v6 & 1;
}

BOOL ___ZL41nw_protocol_http3_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_124(void *a1, uint64_t a2)
{
  LODWORD(size) = 0;
  v4 = nw_frame_unclaimed_bytes(a2, &size);
  v6 = *(a1[4] + 8);
  v7 = *(v6 + 24);
  if (*(v6 + 24))
  {
    if (size < v7)
    {
      *(v6 + 24) = v7 - size;
      v8 = (a1[7] + 224);
      v9 = *(a2 + 32);
      v10 = *(a2 + 40);
      if (v9)
      {
        v8 = (v9 + 40);
      }

      *v8 = v10;
      *v10 = v9;
      *(a2 + 32) = 0;
      *(a2 + 40) = 0;
      nw_frame_finalize(a2);
      return 1;
    }

    nw_frame_claim(a2, v5, v7, 0);
    v4 = nw_frame_unclaimed_bytes(a2, &size);
    *(*(a1[4] + 8) + 24) = 0;
  }

  v12 = *(a1[5] + 8);
  v13 = *(v12 + 24);
  if (!v13)
  {
    return 0;
  }

  v14 = size;
  if (v13 <= size)
  {
    v21 = dispatch_data_create(v4, v13, 0, 0);
    if (v21)
    {
      v23 = v21;
      v24 = *(a1[6] + 8);
      v25 = *(v24 + 24);
      if (v25)
      {
        concat = dispatch_data_create_concat(v25, v23);
        v27 = *(*(a1[6] + 8) + 24);
        if (v27)
        {
          dispatch_release(v27);
          *(*(a1[6] + 8) + 24) = 0;
        }

        dispatch_release(v23);
        *(*(a1[6] + 8) + 24) = concat;
      }

      else
      {
        *(v24 + 24) = v23;
      }
    }

    nw_frame_claim(a2, v22, *(*(a1[5] + 8) + 24), 0);
    result = 0;
    *(*(a1[5] + 8) + 24) = 0;
  }

  else
  {
    *(v12 + 24) = v13 - size;
    v15 = dispatch_data_create(v4, v14, 0, 0);
    if (v15)
    {
      v16 = v15;
      v17 = *(a1[6] + 8);
      v18 = *(v17 + 24);
      if (v18)
      {
        v19 = dispatch_data_create_concat(v18, v16);
        v20 = *(*(a1[6] + 8) + 24);
        if (v20)
        {
          dispatch_release(v20);
          *(*(a1[6] + 8) + 24) = 0;
        }

        dispatch_release(v16);
        *(*(a1[6] + 8) + 24) = v19;
      }

      else
      {
        *(v17 + 24) = v16;
      }
    }

    v28 = (a1[7] + 224);
    v29 = *(a2 + 32);
    v30 = *(a2 + 40);
    if (v29)
    {
      v28 = (v29 + 40);
    }

    *v28 = v30;
    *v30 = v29;
    *(a2 + 32) = 0;
    *(a2 + 40) = 0;
    nw_frame_finalize(a2);
    return *(*(a1[5] + 8) + 24) != 0;
  }

  return result;
}

BOOL ___ZL41nw_protocol_http3_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_126(uint64_t a1, uint64_t a2)
{
  v147 = *MEMORY[0x1E69E9840];
  v4 = *(a1 + 48);
  if ((!v4 || (*(v4 + 732) & 0x2000) == 0) && gLogDatapath == 1)
  {
    v62 = __nwlog_obj();
    v63 = os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG);
    v4 = *(a1 + 48);
    if (v63)
    {
      v64 = (v4 + 632);
      v65 = "";
      v66 = *(*(v4 + 344) + 1304);
      v67 = v4 == 0;
      if (!v4)
      {
        v64 = "";
      }

      v68 = *(v4 + 240);
      if (!v67)
      {
        v65 = " ";
      }

      *buf = 136447490;
      *&buf[4] = "nw_protocol_http3_stream_get_input_frames_block_invoke";
      *&buf[12] = 2082;
      *&buf[14] = v64;
      *&buf[22] = 2080;
      *&buf[24] = v65;
      v138 = 1024;
      v139 = v66;
      v140 = 2048;
      v141 = v68;
      v142 = 2048;
      *v143 = a2;
      _os_log_impl(&dword_181A37000, v62, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> processing frame %p", buf, 0x3Au);
      v4 = *(a1 + 48);
    }
  }

  v5 = (v4 + 224);
  v7 = (a2 + 32);
  v6 = *(a2 + 32);
  v8 = *(a2 + 40);
  if (v6)
  {
    v5 = (v6 + 40);
  }

  *v5 = v8;
  *v8 = v6;
  *(a2 + 40) = 0;
  *v7 = 0;
  is_metadata_complete = nw_frame_is_metadata_complete(a2);
  v10 = is_metadata_complete;
  v11 = *(a1 + 48);
  v12 = *(a1 + 56);
  v13 = *(a1 + 64);
  if (*(a1 + 84) == 1)
  {
    v14 = *(v11 + 216) == 0;
    v16 = (a1 + 72);
    v15 = *(a1 + 72);
    v17 = *(a1 + 80);
    v18 = (*(*(a1 + 40) + 8) + 24);
    v19 = v11 == 0;
  }

  else
  {
    v19 = 0;
    v16 = (a1 + 72);
    v15 = *(a1 + 72);
    v17 = *(a1 + 80);
    v18 = (*(*(a1 + 40) + 8) + 24);
    if (!v11)
    {
      v20 = 1;
      goto LABEL_11;
    }

    v14 = 0;
  }

  v20 = v19;
  v19 = v14;
  if ((*(v11 + 732) & 0x2000) != 0)
  {
    goto LABEL_12;
  }

LABEL_11:
  if (gLogDatapath != 1)
  {
LABEL_12:
    if (v12 > 0xD)
    {
      goto LABEL_92;
    }

    goto LABEL_13;
  }

  objecta = v15;
  v128 = *(a1 + 64);
  v131 = v17;
  v120 = is_metadata_complete;
  log = __nwlog_obj();
  if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
  {
    v69 = (v11 + 632);
    v70 = "";
    v71 = *(*(v11 + 344) + 1304);
    v72 = *(v11 + 240);
    if (v20)
    {
      v69 = "";
    }

    else
    {
      v70 = " ";
    }

    *buf = 136448002;
    *&buf[4] = "nw_http3_stream_frame_received";
    *&buf[12] = 2082;
    *&buf[14] = v69;
    *&buf[22] = 2080;
    *&buf[24] = v70;
    v138 = 1024;
    v139 = v71;
    v140 = 2048;
    v141 = v72;
    v142 = 2048;
    *v143 = v12;
    *&v143[8] = 2048;
    v144 = v128;
    v145 = 1024;
    v146 = v19;
    _os_log_impl(&dword_181A37000, log, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> received frame type %llu, length %llu, complete %{BOOL}d", buf, 0x4Au);
    v13 = v128;
    v10 = v120;
  }

  else
  {
    v10 = v120;
    v13 = v128;
  }

  v17 = v131;
  v15 = objecta;
  if (v12 > 0xD)
  {
    goto LABEL_92;
  }

LABEL_13:
  if (((1 << v12) & 0x2098) != 0)
  {
    goto LABEL_94;
  }

  if (!v12)
  {
    v29 = *(v11 + 380);
    if (v29 <= 8)
    {
      if (((1 << v29) & 0x1EE) != 0)
      {
        v22 = v10;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v30 = *(v11 + 380);
        *buf = 136446466;
        *&buf[4] = "nw_http3_stream_frame_received";
        *&buf[12] = 1024;
        *&buf[14] = v30;
        v24 = _os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v135 = 0;
        if (!__nwlog_fault(v24, &type, &v135))
        {
          goto LABEL_76;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v25 = gLogObj;
          v26 = type;
          if (!os_log_type_enabled(gLogObj, type))
          {
            goto LABEL_76;
          }

          goto LABEL_21;
        }

        if (v135 == 1)
        {
          backtrace_string = __nw_create_backtrace_string();
          v25 = __nwlog_obj();
          v26 = type;
          v32 = os_log_type_enabled(v25, type);
          if (backtrace_string)
          {
            if (v32)
            {
              v33 = *(v11 + 380);
              *buf = 136446722;
              *&buf[4] = "nw_http3_stream_frame_received";
              *&buf[12] = 1024;
              *&buf[14] = v33;
              *&buf[18] = 2082;
              *&buf[20] = backtrace_string;
              _os_log_impl(&dword_181A37000, v25, v26, "%{public}s Unexpected input state %d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(backtrace_string);
            if (!v24)
            {
              goto LABEL_78;
            }

            goto LABEL_77;
          }

          if (!v32)
          {
LABEL_76:
            if (!v24)
            {
LABEL_78:
              v44 = 2;
              v10 = v22;
              goto LABEL_95;
            }

LABEL_77:
            free(v24);
            goto LABEL_78;
          }

LABEL_74:
          v61 = *(v11 + 380);
          *buf = 136446466;
          *&buf[4] = "nw_http3_stream_frame_received";
          *&buf[12] = 1024;
          *&buf[14] = v61;
          v28 = "%{public}s Unexpected input state %d, no backtrace";
          goto LABEL_75;
        }

        v25 = __nwlog_obj();
        v26 = type;
        if (!os_log_type_enabled(v25, type))
        {
          goto LABEL_76;
        }

LABEL_52:
        v45 = *(v11 + 380);
        *buf = 136446466;
        *&buf[4] = "nw_http3_stream_frame_received";
        *&buf[12] = 1024;
        *&buf[14] = v45;
        v28 = "%{public}s Unexpected input state %d, backtrace limit exceeded";
        goto LABEL_75;
      }

      v43 = v10;
      if (!v29)
      {
        nw_http3_fail_all_streams(*(v11 + 344), 261);
        v44 = 2;
        v10 = v43;
        goto LABEL_95;
      }

      v50 = v15;
      v129 = v17;
      objectc = *(v11 + 408);
      v126 = v13;
      v51 = nw_frame_is_metadata_complete(a2);
      nw_frame_set_metadata(a2, objectc, 1, v51);
      v52 = nw_frame_unclaimed_length(a2);
      if ((*(v11 + 732) & 0x2000) == 0 && gLogDatapath == 1)
      {
        objectb = v52;
        v121 = __nwlog_obj();
        v116 = os_log_type_enabled(v121, OS_LOG_TYPE_DEBUG);
        v52 = objectb;
        if (v116)
        {
          v117 = *(*(v11 + 344) + 1304);
          v118 = *(v11 + 240);
          *buf = 136447490;
          *&buf[4] = "nw_http3_stream_frame_received";
          *&buf[12] = 2082;
          *&buf[14] = v11 + 632;
          *&buf[22] = 2080;
          *&buf[24] = " ";
          v138 = 1024;
          v139 = v117;
          v140 = 2048;
          v141 = v118;
          v142 = 1024;
          *v143 = objectb;
          _os_log_impl(&dword_181A37000, v121, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> received %u data bytes", buf, 0x36u);
          v52 = objectb;
        }
      }

      *(a2 + 32) = 0;
      v53 = *(v50 + 1);
      *(a2 + 40) = v53;
      *v53 = a2;
      *(v50 + 1) = v7;
      ++*v18;
      v10 = v43;
      if (v19)
      {
        *v132 = MEMORY[0x1E69E9820];
        v133[0] = 0x40000000;
        v133[1] = ___ZL30nw_http3_stream_frame_receivedP24nw_protocol_http3_streamP8nw_frame21nw_http3_frame_type_tybjP16nw_frame_array_sPj_block_invoke;
        v133[2] = &__block_descriptor_tmp_136_65328;
        v133[3] = a2;
        v133[4] = v11;
        v134 = v52;
        nw_http_diag_log_for_level(3, 1, v132);
        nw_http_transaction_metadata_increment_inbound_body_transfer_size(*(v11 + 400), v126 + v129);
        nw::http::content_length_manager::increment_inbound_body_size(v11 + 280, v126);
        v10 = v43;
      }
    }

    goto LABEL_115;
  }

  if (v12 != 1)
  {
LABEL_92:
    if (v12 != 65 && v12 != 4287504053)
    {
      v83 = v10;
      if (((v20 & 1) != 0 || (*(v11 + 732) & 0x2000) == 0) && gLogDatapath == 1)
      {
        v109 = __nwlog_obj();
        if (os_log_type_enabled(v109, OS_LOG_TYPE_DEBUG))
        {
          v110 = (v11 + 632);
          v111 = "";
          v112 = *(*(v11 + 344) + 1304);
          v113 = *(v11 + 240);
          if (v20)
          {
            v110 = "";
          }

          else
          {
            v111 = " ";
          }

          *buf = 136447234;
          *&buf[4] = "nw_http3_stream_frame_received";
          *&buf[12] = 2082;
          *&buf[14] = v110;
          *&buf[22] = 2080;
          *&buf[24] = v111;
          v138 = 1024;
          v139 = v112;
          v140 = 2048;
          v141 = v113;
          _os_log_impl(&dword_181A37000, v109, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> dropping unknown frame type", buf, 0x30u);
        }
      }

      nw_frame_finalize(a2);
      v10 = v83;
      goto LABEL_115;
    }

LABEL_94:
    v73 = v10;
    nw_http3_fail_all_streams(*(v11 + 344), 261);
    v10 = v73;
    v44 = 2;
    goto LABEL_95;
  }

  v21 = *(v11 + 380);
  if (v21 <= 8)
  {
    if (((1 << v21) & 0x1CC) != 0)
    {
      v22 = v10;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = *(v11 + 380);
      *buf = 136446466;
      *&buf[4] = "nw_http3_stream_frame_received";
      *&buf[12] = 1024;
      *&buf[14] = v23;
      v24 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v135 = 0;
      if (!__nwlog_fault(v24, &type, &v135))
      {
        goto LABEL_76;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = gLogObj;
        v26 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_76;
        }

LABEL_21:
        v27 = *(v11 + 380);
        *buf = 136446466;
        *&buf[4] = "nw_http3_stream_frame_received";
        *&buf[12] = 1024;
        *&buf[14] = v27;
        v28 = "%{public}s Unexpected input state %d";
LABEL_75:
        _os_log_impl(&dword_181A37000, v25, v26, v28, buf, 0x12u);
        goto LABEL_76;
      }

      if (v135 == 1)
      {
        v40 = __nw_create_backtrace_string();
        v25 = __nwlog_obj();
        v26 = type;
        v41 = os_log_type_enabled(v25, type);
        if (v40)
        {
          if (v41)
          {
            v42 = *(v11 + 380);
            *buf = 136446722;
            *&buf[4] = "nw_http3_stream_frame_received";
            *&buf[12] = 1024;
            *&buf[14] = v42;
            *&buf[18] = 2082;
            *&buf[20] = v40;
            _os_log_impl(&dword_181A37000, v25, v26, "%{public}s Unexpected input state %d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v40);
          goto LABEL_76;
        }

        if (!v41)
        {
          goto LABEL_76;
        }

        goto LABEL_74;
      }

      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
      {
        goto LABEL_76;
      }

      goto LABEL_52;
    }

    if (v21 == 4)
    {
      *(v11 + 380) = 5;
    }

    else if (v21 != 5)
    {
      goto LABEL_37;
    }

    v46 = v15;
    v47 = v10;
    v44 = nw_http3_stream_handle_fields(v11, v13, a2, v19);
    v48 = *(v11 + 384);
    if (v48)
    {
      *(v48 + 32) = 0;
      v49 = v46[1];
      *(v48 + 40) = v49;
      *v49 = v48;
      v46[1] = v48 + 32;
      ++*v18;
      *(v11 + 384) = 0;
    }

LABEL_71:
    v10 = v47;
    if (v44)
    {
      goto LABEL_95;
    }

    goto LABEL_115;
  }

LABEL_37:
  if (v21 == 1)
  {
LABEL_67:
    v130 = v17;
    v55 = v15;
    v47 = v10;
    v56 = v13;
    v44 = nw_http3_stream_handle_fields(v11, v13, a2, v19);
    v57 = *(v11 + 384);
    if (v57)
    {
      *(v57 + 32) = 0;
      v58 = v55[1];
      *(v57 + 40) = v58;
      *v58 = v57;
      v55[1] = v57 + 32;
      ++*v18;
      *(v11 + 384) = 0;
    }

    if (v19)
    {
      v59 = v44;
      v60 = nw_http3_encoder_stream_get_and_reset_received_size(*(v11 + 344));
      nw_http_transaction_metadata_increment_inbound_header_size(*(v11 + 400), v56 + v130 + v60);
      v44 = v59;
    }

    goto LABEL_71;
  }

  if (!v21)
  {
    object = v15;
    v34 = v17;
    v35 = v13;
    v36 = v10;
    *(v11 + 380) = 1;
    v37 = *(v11 + 344);
    if (v37 && *(v37 + 1308))
    {
      *(v37 + 1308) = 0;
    }

    v38 = _nw_http_parsed_fields_create();
    v39 = *(v11 + 504);
    if (v39)
    {
      v54 = *(v11 + 496);
      v10 = v36;
      v13 = v35;
      v17 = v34;
      if (v54)
      {
        v127 = v38;
        os_release(v54);
        v17 = v34;
        v13 = v35;
        v10 = v36;
        v38 = v127;
        v39 = *(v11 + 504);
      }
    }

    else
    {
      v10 = v36;
      v13 = v35;
      v17 = v34;
    }

    *(v11 + 496) = v38;
    *(v11 + 504) = v39 | 1;
    v15 = object;
    goto LABEL_67;
  }

LABEL_115:
  v44 = 0;
LABEL_95:
  *(*(*(a1 + 32) + 8) + 24) = v44;
  v74 = *(a1 + 48);
  if ((!v74 || (*(v74 + 732) & 0x2000) == 0) && gLogDatapath == 1)
  {
    v94 = v10;
    v95 = __nwlog_obj();
    v96 = os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG);
    v10 = v94;
    if (v96)
    {
      v97 = *(a1 + 48);
      v98 = (v97 + 632);
      v99 = "";
      if (v97)
      {
        v99 = " ";
      }

      else
      {
        v98 = "";
      }

      v100 = *(*(v97 + 344) + 1304);
      v101 = *(v97 + 240);
      v102 = *(*(*(a1 + 32) + 8) + 24);
      v103 = *(v97 + 380);
      *buf = 136447746;
      *&buf[4] = "nw_protocol_http3_stream_get_input_frames_block_invoke";
      *&buf[12] = 2082;
      *&buf[14] = v98;
      *&buf[22] = 2080;
      *&buf[24] = v99;
      v138 = 1024;
      v139 = v100;
      v140 = 2048;
      v141 = v101;
      v142 = 1024;
      *v143 = v102;
      *&v143[4] = 1024;
      *&v143[6] = v103;
      _os_log_impl(&dword_181A37000, v95, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> status %u http3_stream->input_state %u", buf, 0x3Cu);
      v10 = v94;
    }
  }

  if (v10)
  {
    nw_http_transaction_metadata_mark_inbound_message_end(*(*(a1 + 48) + 400));
    v75 = *(a1 + 48);
    if (*(v75 + 312) == 1 && *(v75 + 304) != *(v75 + 320))
    {
      if ((*(v75 + 732) & 0x2000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v76 = gLogObj;
        if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
        {
          v77 = *(a1 + 48);
          if (v77)
          {
            v78 = (v77 + 632);
          }

          else
          {
            v78 = "";
          }

          if (v77)
          {
            v79 = " ";
          }

          else
          {
            v79 = "";
          }

          v80 = *(*(v77 + 344) + 1304);
          v81 = *(v77 + 240);
          if (*(v77 + 312) == 1)
          {
            v82 = *(v77 + 304);
          }

          else
          {
            v82 = -1;
          }

          v84 = *(v77 + 320);
          *buf = 136447746;
          *&buf[4] = "nw_protocol_http3_stream_get_input_frames_block_invoke";
          *&buf[12] = 2082;
          *&buf[14] = v78;
          *&buf[22] = 2080;
          *&buf[24] = v79;
          v138 = 1024;
          v139 = v80;
          v140 = 2048;
          v141 = v81;
          v142 = 2048;
          *v143 = v82;
          *&v143[8] = 2048;
          v144 = v84;
          _os_log_impl(&dword_181A37000, v76, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%llu> Content length header %llu does not equal body size %llu", buf, 0x44u);
        }
      }

      v85 = *v16;
      if (*v16)
      {
        if (gLogDatapath == 1)
        {
          v108 = __nwlog_obj();
          if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG))
          {
            *buf = 136446210;
            *&buf[4] = "nw_protocol_finalize_temp_frame_array";
            _os_log_impl(&dword_181A37000, v108, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
          }
        }

        v86 = *v85;
        if (*v85)
        {
          *(v86 + 40) = v132;
          v87 = v85[1];
          *v132 = v86;
          v133[0] = v87;
          *v85 = 0;
          v85[1] = v85;
          *buf = MEMORY[0x1E69E9820];
          *&buf[8] = 0x40000000;
          *&buf[16] = ___ZL25__nw_frame_array_finalizeP16nw_frame_array_sbb_block_invoke;
          *&buf[24] = &__block_descriptor_tmp_21_49595;
          LOBYTE(v138) = 0;
          do
          {
            v88 = *v132;
            if (!*v132)
            {
              break;
            }

            v89 = *(*v132 + 32);
            v90 = *(*v132 + 40);
            v91 = (v89 + 40);
            if (!v89)
            {
              v91 = v133;
            }

            *v91 = v90;
            *v90 = v89;
            *(v88 + 32) = 0;
            *(v88 + 40) = 0;
          }

          while (((*&buf[16])(buf) & 1) != 0);
        }

LABEL_126:
        v92 = *(a1 + 48);
        v92[4].identifier = 270;
        nw_protocol_http3_stream_error(v92, v92);
        nw_protocol_http3_stream_disconnect(*(a1 + 48), *(a1 + 48));
        *(*(*(a1 + 32) + 8) + 24) = 2;
        *(*(*(a1 + 40) + 8) + 24) = 0;
        return *(*(*(a1 + 32) + 8) + 24) == 0;
      }

      __nwlog_obj();
      *buf = 136446210;
      *&buf[4] = "nw_protocol_finalize_temp_frame_array";
      v104 = _os_log_send_and_compose_impl();
      v132[0] = OS_LOG_TYPE_ERROR;
      type = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v104, v132, &type))
      {
        if (v132[0] == OS_LOG_TYPE_FAULT)
        {
          v105 = __nwlog_obj();
          v106 = v132[0];
          if (!os_log_type_enabled(v105, v132[0]))
          {
            goto LABEL_154;
          }

          *buf = 136446210;
          *&buf[4] = "nw_protocol_finalize_temp_frame_array";
          v107 = "%{public}s called with null array";
          goto LABEL_153;
        }

        if (type != OS_LOG_TYPE_INFO)
        {
          v105 = __nwlog_obj();
          v106 = v132[0];
          if (!os_log_type_enabled(v105, v132[0]))
          {
            goto LABEL_154;
          }

          *buf = 136446210;
          *&buf[4] = "nw_protocol_finalize_temp_frame_array";
          v107 = "%{public}s called with null array, backtrace limit exceeded";
          goto LABEL_153;
        }

        v114 = __nw_create_backtrace_string();
        v105 = __nwlog_obj();
        v106 = v132[0];
        v115 = os_log_type_enabled(v105, v132[0]);
        if (v114)
        {
          if (v115)
          {
            *buf = 136446466;
            *&buf[4] = "nw_protocol_finalize_temp_frame_array";
            *&buf[12] = 2082;
            *&buf[14] = v114;
            _os_log_impl(&dword_181A37000, v105, v106, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v114);
          goto LABEL_154;
        }

        if (v115)
        {
          *buf = 136446210;
          *&buf[4] = "nw_protocol_finalize_temp_frame_array";
          v107 = "%{public}s called with null array, no backtrace";
LABEL_153:
          _os_log_impl(&dword_181A37000, v105, v106, v107, buf, 0xCu);
        }
      }

LABEL_154:
      if (v104)
      {
        free(v104);
      }

      goto LABEL_126;
    }
  }

  return *(*(*(a1 + 32) + 8) + 24) == 0;
}

void ___ZL30nw_http3_stream_frame_receivedP24nw_protocol_http3_streamP8nw_frame21nw_http3_frame_type_tybjP16nw_frame_array_sPj_block_invoke(uint64_t a1)
{
  v14 = *MEMORY[0x1E69E9840];
  v2 = nw_frame_unclaimed_bytes(*(a1 + 32), 0);
  if (__nwlog_http_diagnostics_log::onceToken[0] != -1)
  {
    dispatch_once(__nwlog_http_diagnostics_log::onceToken, &__block_literal_global_40_47449);
  }

  v3 = ghttp_diagnosticsLogObj;
  if (os_log_type_enabled(ghttp_diagnosticsLogObj, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(a1 + 40) + 632;
    v5 = *(a1 + 48);
    v6 = 136446978;
    v7 = v4;
    v8 = 2080;
    v9 = " ";
    v10 = 1040;
    v11 = v5;
    v12 = 2096;
    v13 = v2;
    _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_DEFAULT, "%{public}s%sH3 Inbound Body Data:\n%{network:data}.*P", &v6, 0x26u);
  }
}

void nw_protocol_http3_stream_output_available(nw_protocol *a1, nw_protocol *a2)
{
  v59 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v50 = "nw_protocol_http3_stream_output_available";
    v23 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (!__nwlog_fault(v23, &type, &v47))
    {
      goto LABEL_74;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
      {
        goto LABEL_74;
      }

      *buf = 136446210;
      v50 = "nw_protocol_http3_stream_output_available";
      v26 = "%{public}s called with null protocol";
      goto LABEL_73;
    }

    if (v47 != 1)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
      {
        goto LABEL_74;
      }

      *buf = 136446210;
      v50 = "nw_protocol_http3_stream_output_available";
      v26 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_73;
    }

    backtrace_string = __nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v25 = type;
    v31 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (!v31)
      {
        goto LABEL_74;
      }

      *buf = 136446210;
      v50 = "nw_protocol_http3_stream_output_available";
      v26 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_73;
    }

    if (v31)
    {
      *buf = 136446466;
      v50 = "nw_protocol_http3_stream_output_available";
      v51 = 2082;
      v52 = backtrace_string;
      _os_log_impl(&dword_181A37000, v24, v25, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
LABEL_74:
    if (!v23)
    {
      return;
    }

    goto LABEL_75;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v50 = "nw_protocol_http3_stream_output_available";
    v23 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (!__nwlog_fault(v23, &type, &v47))
    {
      goto LABEL_74;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
      {
        goto LABEL_74;
      }

      *buf = 136446210;
      v50 = "nw_protocol_http3_stream_output_available";
      v26 = "%{public}s called with null http3_stream";
      goto LABEL_73;
    }

    if (v47 != 1)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
      {
        goto LABEL_74;
      }

      *buf = 136446210;
      v50 = "nw_protocol_http3_stream_output_available";
      v26 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_73;
    }

    v32 = __nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v25 = type;
    v33 = os_log_type_enabled(v24, type);
    if (v32)
    {
      if (v33)
      {
        *buf = 136446466;
        v50 = "nw_protocol_http3_stream_output_available";
        v51 = 2082;
        v52 = v32;
        _os_log_impl(&dword_181A37000, v24, v25, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v32);
      if (!v23)
      {
        return;
      }

LABEL_75:
      v39 = v23;
      goto LABEL_76;
    }

    if (v33)
    {
      *buf = 136446210;
      v50 = "nw_protocol_http3_stream_output_available";
      v26 = "%{public}s called with null http3_stream, no backtrace";
LABEL_73:
      _os_log_impl(&dword_181A37000, v24, v25, v26, buf, 0xCu);
      goto LABEL_74;
    }

    goto LABEL_74;
  }

  if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
  {
    v27 = __nwlog_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      v28 = *(*(handle + 43) + 1304);
      v29 = *(handle + 30);
      *buf = 136447234;
      v50 = "nw_protocol_http3_stream_output_available";
      v51 = 2082;
      v52 = handle + 632;
      v53 = 2080;
      v54 = " ";
      v55 = 1024;
      v56 = v28;
      v57 = 2048;
      v58 = v29;
      _os_log_impl(&dword_181A37000, v27, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
    }
  }

  v3 = *(handle + 94);
  if (v3 > 1)
  {
    if (v3 != 2)
    {
      if (v3 != 3 && v3 != 5)
      {
        return;
      }

      goto LABEL_14;
    }

    is_metadata_complete = nw_frame_is_metadata_complete(*(handle + 49));
    if (!nw_http3_stream_send_fields(handle, is_metadata_complete))
    {
      return;
    }

    v9 = *(handle + 6);
    if (v9)
    {
      v10 = *(v9 + 24);
      if (v10)
      {
        v7 = *(v10 + 72);
        if (v7)
        {
          goto LABEL_17;
        }
      }
    }

    __nwlog_obj();
    v11 = *(handle + 6);
    v12 = "invalid";
    if (v11)
    {
      v13 = *(v11 + 16);
      if (v13)
      {
        v12 = v13;
      }
    }

    *buf = 136446466;
    v50 = "nw_protocol_http3_stream_output_available";
    v51 = 2082;
    v52 = v12;
    type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    v46 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault(v46, &type, &v47))
    {
      goto LABEL_88;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
      {
        goto LABEL_88;
      }

      v16 = *(handle + 6);
      v17 = "invalid";
      if (v16)
      {
        v18 = *(v16 + 16);
        if (v18)
        {
          v17 = v18;
        }
      }

      *buf = 136446466;
      v50 = "nw_protocol_http3_stream_output_available";
      v51 = 2082;
      v52 = v17;
      v19 = "%{public}s protocol %{public}s has invalid output_available callback";
    }

    else if (v47 == 1)
    {
      v34 = __nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v35 = os_log_type_enabled(v14, type);
      if (v34)
      {
        if (v35)
        {
          v36 = *(handle + 6);
          v37 = "invalid";
          if (v36)
          {
            v38 = *(v36 + 16);
            if (v38)
            {
              v37 = v38;
            }
          }

          *buf = 136446722;
          v50 = "nw_protocol_http3_stream_output_available";
          v51 = 2082;
          v52 = v37;
          v53 = 2082;
          v54 = v34;
          _os_log_impl(&dword_181A37000, v14, v15, "%{public}s protocol %{public}s has invalid output_available callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v34);
LABEL_88:
        v39 = v46;
        if (!v46)
        {
          return;
        }

LABEL_76:
        free(v39);
        return;
      }

      if (!v35)
      {
        goto LABEL_88;
      }

      v43 = *(handle + 6);
      v44 = "invalid";
      if (v43)
      {
        v45 = *(v43 + 16);
        if (v45)
        {
          v44 = v45;
        }
      }

      *buf = 136446466;
      v50 = "nw_protocol_http3_stream_output_available";
      v51 = 2082;
      v52 = v44;
      v19 = "%{public}s protocol %{public}s has invalid output_available callback, no backtrace";
    }

    else
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
      {
        goto LABEL_88;
      }

      v40 = *(handle + 6);
      v41 = "invalid";
      if (v40)
      {
        v42 = *(v40 + 16);
        if (v42)
        {
          v41 = v42;
        }
      }

      *buf = 136446466;
      v50 = "nw_protocol_http3_stream_output_available";
      v51 = 2082;
      v52 = v41;
      v19 = "%{public}s protocol %{public}s has invalid output_available callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v14, v15, v19, buf, 0x16u);
    goto LABEL_88;
  }

  if (v3)
  {
    if (v3 != 1)
    {
      return;
    }

LABEL_14:
    nw_http3_stream_send_pending_capsules(handle);
    v5 = *(handle + 6);
    if (!v5)
    {
      return;
    }

    v6 = *(v5 + 24);
    if (!v6)
    {
      return;
    }

    v7 = *(v6 + 72);
    if (!v7)
    {
      return;
    }

LABEL_17:
    v7();
    return;
  }

  if ((*(handle + 366) & 0x2000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_INFO))
    {
      v21 = *(*(handle + 43) + 1304);
      v22 = *(handle + 30);
      *buf = 136447234;
      v50 = "nw_protocol_http3_stream_output_available";
      v51 = 2082;
      v52 = handle + 632;
      v53 = 2080;
      v54 = " ";
      v55 = 1024;
      v56 = v21;
      v57 = 2048;
      v58 = v22;
      _os_log_impl(&dword_181A37000, v20, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> output_available before get_output_frames", buf, 0x30u);
    }
  }
}

void nw_protocol_http3_stream_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  v54 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_protocol_http3_stream_output_finished";
    v11 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v11, &type, &v42))
    {
      goto LABEL_86;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
      {
        goto LABEL_86;
      }

      *buf = 136446210;
      v45 = "nw_protocol_http3_stream_output_finished";
      v17 = "%{public}s called with null protocol";
LABEL_84:
      v39 = v18;
      v40 = v19;
      v41 = 12;
      goto LABEL_85;
    }

    if (v42 != 1)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
      {
        goto LABEL_86;
      }

      *buf = 136446210;
      v45 = "nw_protocol_http3_stream_output_finished";
      v17 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_84;
    }

    backtrace_string = __nw_create_backtrace_string();
    v18 = __nwlog_obj();
    v19 = type;
    v29 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (!v29)
      {
        goto LABEL_86;
      }

      *buf = 136446210;
      v45 = "nw_protocol_http3_stream_output_finished";
      v17 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_84;
    }

    if (!v29)
    {
      goto LABEL_59;
    }

    *buf = 136446466;
    v45 = "nw_protocol_http3_stream_output_finished";
    v46 = 2082;
    v47 = backtrace_string;
    v30 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_58:
    _os_log_impl(&dword_181A37000, v18, v19, v30, buf, 0x16u);
    goto LABEL_59;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_protocol_http3_stream_output_finished";
    v11 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v11, &type, &v42))
    {
      goto LABEL_86;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
      {
        goto LABEL_86;
      }

      *buf = 136446210;
      v45 = "nw_protocol_http3_stream_output_finished";
      v17 = "%{public}s called with null http3_stream";
      goto LABEL_84;
    }

    if (v42 != 1)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
      {
        goto LABEL_86;
      }

      *buf = 136446210;
      v45 = "nw_protocol_http3_stream_output_finished";
      v17 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_84;
    }

    backtrace_string = __nw_create_backtrace_string();
    v18 = __nwlog_obj();
    v19 = type;
    v31 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (!v31)
      {
        goto LABEL_86;
      }

      *buf = 136446210;
      v45 = "nw_protocol_http3_stream_output_finished";
      v17 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_84;
    }

    if (!v31)
    {
      goto LABEL_59;
    }

    *buf = 136446466;
    v45 = "nw_protocol_http3_stream_output_finished";
    v46 = 2082;
    v47 = backtrace_string;
    v30 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
    goto LABEL_58;
  }

  if (a2)
  {
    if ((*(handle + 366) & 0x2000) == 0 && gLogDatapath == 1)
    {
      v20 = __nwlog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        v21 = *(*(handle + 43) + 1304);
        v22 = *(handle + 30);
        *buf = 136447234;
        v45 = "nw_protocol_http3_stream_output_finished";
        v46 = 2082;
        v47 = handle + 632;
        v48 = 2080;
        v49 = " ";
        v50 = 1024;
        v51 = v21;
        v52 = 2048;
        v53 = v22;
        _os_log_impl(&dword_181A37000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }

    v4 = *(handle + 94);
    if (v4 > 5)
    {
      return;
    }

    if (((1 << v4) & 0x2B) == 0)
    {
      *(handle + 366) |= 0x800u;
      return;
    }

    output_handler = a1->output_handler;
    if (output_handler)
    {
      callbacks = output_handler->callbacks;
      if (callbacks)
      {
        output_finished = callbacks->output_finished;
        if (output_finished)
        {
          output_finished();
          return;
        }
      }
    }

    __nwlog_obj();
    v8 = a1->output_handler;
    v9 = "invalid";
    if (v8)
    {
      identifier = v8->identifier;
      if (identifier)
      {
        v9 = identifier;
      }
    }

    *buf = 136446466;
    v45 = "nw_protocol_http3_stream_output_finished";
    v46 = 2082;
    v47 = v9;
    v11 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v11, &type, &v42))
    {
      goto LABEL_86;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_86;
      }

      v14 = a1->output_handler;
      v15 = "invalid";
      if (v14)
      {
        v16 = v14->identifier;
        if (v16)
        {
          v15 = v16;
        }
      }

      *buf = 136446466;
      v45 = "nw_protocol_http3_stream_output_finished";
      v46 = 2082;
      v47 = v15;
      v17 = "%{public}s protocol %{public}s has invalid output_finished callback";
    }

    else if (v42 == 1)
    {
      v23 = __nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v13 = type;
      v24 = os_log_type_enabled(v12, type);
      if (v23)
      {
        if (v24)
        {
          v25 = a1->output_handler;
          v26 = "invalid";
          if (v25)
          {
            v27 = v25->identifier;
            if (v27)
            {
              v26 = v27;
            }
          }

          *buf = 136446722;
          v45 = "nw_protocol_http3_stream_output_finished";
          v46 = 2082;
          v47 = v26;
          v48 = 2082;
          v49 = v23;
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s protocol %{public}s has invalid output_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v23);
LABEL_86:
        if (v11)
        {
          goto LABEL_87;
        }

        return;
      }

      if (!v24)
      {
        goto LABEL_86;
      }

      v36 = a1->output_handler;
      v37 = "invalid";
      if (v36)
      {
        v38 = v36->identifier;
        if (v38)
        {
          v37 = v38;
        }
      }

      *buf = 136446466;
      v45 = "nw_protocol_http3_stream_output_finished";
      v46 = 2082;
      v47 = v37;
      v17 = "%{public}s protocol %{public}s has invalid output_finished callback, no backtrace";
    }

    else
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_86;
      }

      v33 = a1->output_handler;
      v34 = "invalid";
      if (v33)
      {
        v35 = v33->identifier;
        if (v35)
        {
          v34 = v35;
        }
      }

      *buf = 136446466;
      v45 = "nw_protocol_http3_stream_output_finished";
      v46 = 2082;
      v47 = v34;
      v17 = "%{public}s protocol %{public}s has invalid output_finished callback, backtrace limit exceeded";
    }

    v39 = v12;
    v40 = v13;
    v41 = 22;
LABEL_85:
    _os_log_impl(&dword_181A37000, v39, v40, v17, buf, v41);
    goto LABEL_86;
  }

  __nwlog_obj();
  *buf = 136446210;
  v45 = "nw_protocol_http3_stream_output_finished";
  v11 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (!__nwlog_fault(v11, &type, &v42))
  {
    goto LABEL_86;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v18 = __nwlog_obj();
    v19 = type;
    if (!os_log_type_enabled(v18, type))
    {
      goto LABEL_86;
    }

    *buf = 136446210;
    v45 = "nw_protocol_http3_stream_output_finished";
    v17 = "%{public}s called with null other_protocol";
    goto LABEL_84;
  }

  if (v42 != 1)
  {
    v18 = __nwlog_obj();
    v19 = type;
    if (!os_log_type_enabled(v18, type))
    {
      goto LABEL_86;
    }

    *buf = 136446210;
    v45 = "nw_protocol_http3_stream_output_finished";
    v17 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_84;
  }

  backtrace_string = __nw_create_backtrace_string();
  v18 = __nwlog_obj();
  v19 = type;
  v32 = os_log_type_enabled(v18, type);
  if (!backtrace_string)
  {
    if (!v32)
    {
      goto LABEL_86;
    }

    *buf = 136446210;
    v45 = "nw_protocol_http3_stream_output_finished";
    v17 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_84;
  }

  if (v32)
  {
    *buf = 136446466;
    v45 = "nw_protocol_http3_stream_output_finished";
    v46 = 2082;
    v47 = backtrace_string;
    v30 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_58;
  }

LABEL_59:
  free(backtrace_string);
  if (v11)
  {
LABEL_87:
    free(v11);
  }
}

void nw_protocol_http3_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  v27 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v20 = "nw_protocol_http3_input_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v3, &type, &v17))
    {
      goto LABEL_52;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_52;
      }

      *buf = 136446210;
      v20 = "nw_protocol_http3_input_finished";
      v6 = "%{public}s called with null protocol";
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v12 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_protocol_http3_input_finished";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_52:
        if (!v3)
        {
          return;
        }

        goto LABEL_53;
      }

      if (!v12)
      {
        goto LABEL_52;
      }

      *buf = 136446210;
      v20 = "nw_protocol_http3_input_finished";
      v6 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_52;
      }

      *buf = 136446210;
      v20 = "nw_protocol_http3_input_finished";
      v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_51;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v20 = "nw_protocol_http3_input_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v3, &type, &v17))
    {
      goto LABEL_52;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v17 != 1)
      {
        v4 = __nwlog_obj();
        v5 = type;
        if (!os_log_type_enabled(v4, type))
        {
          goto LABEL_52;
        }

        *buf = 136446210;
        v20 = "nw_protocol_http3_input_finished";
        v6 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_51;
      }

      v13 = __nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v14 = os_log_type_enabled(v4, type);
      if (!v13)
      {
        if (!v14)
        {
          goto LABEL_52;
        }

        *buf = 136446210;
        v20 = "nw_protocol_http3_input_finished";
        v6 = "%{public}s called with null http3, no backtrace";
        goto LABEL_51;
      }

      if (v14)
      {
        *buf = 136446466;
        v20 = "nw_protocol_http3_input_finished";
        v21 = 2082;
        v22 = v13;
        v15 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_181A37000, v4, v5, v15, buf, 0x16u);
      }

LABEL_37:
      free(v13);
      if (!v3)
      {
        return;
      }

LABEL_53:
      free(v3);
      return;
    }

    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
    {
      goto LABEL_52;
    }

    *buf = 136446210;
    v20 = "nw_protocol_http3_input_finished";
    v6 = "%{public}s called with null http3";
LABEL_51:
    _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
    goto LABEL_52;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v20 = "nw_protocol_http3_input_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v3, &type, &v17))
    {
      goto LABEL_52;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_52;
      }

      *buf = 136446210;
      v20 = "nw_protocol_http3_input_finished";
      v6 = "%{public}s called with null other_protocol";
      goto LABEL_51;
    }

    if (v17 != 1)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_52;
      }

      *buf = 136446210;
      v20 = "nw_protocol_http3_input_finished";
      v6 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_51;
    }

    v13 = __nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v16 = os_log_type_enabled(v4, type);
    if (!v13)
    {
      if (!v16)
      {
        goto LABEL_52;
      }

      *buf = 136446210;
      v20 = "nw_protocol_http3_input_finished";
      v6 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_51;
    }

    if (v16)
    {
      *buf = 136446466;
      v20 = "nw_protocol_http3_input_finished";
      v21 = 2082;
      v22 = v13;
      v15 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_36;
    }

    goto LABEL_37;
  }

  if ((*(handle + 1399) & 0x20) == 0 && gLogDatapath == 1)
  {
    v7 = handle;
    v8 = __nwlog_obj();
    v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG);
    handle = v7;
    if (v9)
    {
      v10 = *(v7 + 326);
      *buf = 136446978;
      v20 = "nw_protocol_http3_input_finished";
      v21 = 2082;
      v22 = v7 + 1313;
      v23 = 2080;
      v24 = " ";
      v25 = 1024;
      v26 = v10;
      _os_log_impl(&dword_181A37000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      handle = v7;
    }
  }

  if ((*(handle + 1397) & 8) == 0)
  {
    nw_http3_fail_all_streams(handle, 260);
  }
}

void nw_protocol_http3_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  v24 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_protocol_http3_output_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v3, &type, &v18))
    {
      goto LABEL_17;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_17;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_output_finished";
      v6 = "%{public}s called with null protocol";
      goto LABEL_15;
    }

    if (v18 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v14 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (!v14)
        {
          goto LABEL_47;
        }

        *buf = 136446466;
        v21 = "nw_protocol_http3_output_finished";
        v22 = 2082;
        v23 = backtrace_string;
        v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_46;
      }

      if (!v14)
      {
        goto LABEL_17;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_output_finished";
      v6 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_17;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_output_finished";
      v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_15:
    v11 = v4;
    v12 = v5;
LABEL_16:
    _os_log_impl(&dword_181A37000, v11, v12, v6, buf, 0xCu);
    goto LABEL_17;
  }

  if (!a1->handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_protocol_http3_output_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v3, &type, &v18))
    {
      goto LABEL_17;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_17;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_output_finished";
      v6 = "%{public}s called with null http3";
      goto LABEL_15;
    }

    if (v18 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v16 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (!v16)
        {
          goto LABEL_47;
        }

        *buf = 136446466;
        v21 = "nw_protocol_http3_output_finished";
        v22 = 2082;
        v23 = backtrace_string;
        v15 = "%{public}s called with null http3, dumping backtrace:%{public}s";
        goto LABEL_46;
      }

      if (!v16)
      {
        goto LABEL_17;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_output_finished";
      v6 = "%{public}s called with null http3, no backtrace";
    }

    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_17;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_output_finished";
      v6 = "%{public}s called with null http3, backtrace limit exceeded";
    }

    goto LABEL_15;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (a2)
  {
    *buf = 136446210;
    v21 = "nw_protocol_http3_output_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v3, &type, &v18))
    {
      goto LABEL_17;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      v5 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_17;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_output_finished";
      v6 = "%{public}s http3 should not get output_finished";
      goto LABEL_15;
    }

    if (v18 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      v5 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_17;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_output_finished";
      v6 = "%{public}s http3 should not get output_finished, backtrace limit exceeded";
      goto LABEL_15;
    }

    v7 = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    v9 = type;
    v10 = os_log_type_enabled(gLogObj, type);
    if (v7)
    {
      if (v10)
      {
        *buf = 136446466;
        v21 = "nw_protocol_http3_output_finished";
        v22 = 2082;
        v23 = v7;
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s http3 should not get output_finished, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v7);
    }

    else if (v10)
    {
      *buf = 136446210;
      v21 = "nw_protocol_http3_output_finished";
      v6 = "%{public}s http3 should not get output_finished, no backtrace";
      v11 = v8;
      v12 = v9;
      goto LABEL_16;
    }

LABEL_17:
    if (!v3)
    {
      return;
    }

    goto LABEL_18;
  }

  *buf = 136446210;
  v21 = "nw_protocol_http3_output_finished";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v3, &type, &v18))
  {
    goto LABEL_17;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
    {
      goto LABEL_17;
    }

    *buf = 136446210;
    v21 = "nw_protocol_http3_output_finished";
    v6 = "%{public}s called with null other_protocol";
    goto LABEL_15;
  }

  if (v18 != 1)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
    {
      goto LABEL_17;
    }

    *buf = 136446210;
    v21 = "nw_protocol_http3_output_finished";
    v6 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_15;
  }

  backtrace_string = __nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = type;
  v17 = os_log_type_enabled(v4, type);
  if (!backtrace_string)
  {
    if (!v17)
    {
      goto LABEL_17;
    }

    *buf = 136446210;
    v21 = "nw_protocol_http3_output_finished";
    v6 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_15;
  }

  if (!v17)
  {
    goto LABEL_47;
  }

  *buf = 136446466;
  v21 = "nw_protocol_http3_output_finished";
  v22 = 2082;
  v23 = backtrace_string;
  v15 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_46:
  _os_log_impl(&dword_181A37000, v4, v5, v15, buf, 0x16u);
LABEL_47:
  free(backtrace_string);
  if (v3)
  {
LABEL_18:
    free(v3);
  }
}

void nw_protocol_http3_error(nw_protocol *a1, nw_protocol *a2)
{
  v28 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_protocol_http3_error";
    v6 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v6, &type, &v18))
    {
      goto LABEL_52;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_52;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_error";
      v9 = "%{public}s called with null protocol";
    }

    else if (v18 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v21 = "nw_protocol_http3_error";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_52:
        if (!v6)
        {
          return;
        }

        goto LABEL_53;
      }

      if (!v13)
      {
        goto LABEL_52;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_error";
      v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_52;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_error";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_51;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_protocol_http3_error";
    v6 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v6, &type, &v18))
    {
      goto LABEL_52;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v18 != 1)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (!os_log_type_enabled(v7, type))
        {
          goto LABEL_52;
        }

        *buf = 136446210;
        v21 = "nw_protocol_http3_error";
        v9 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_51;
      }

      v14 = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v15 = os_log_type_enabled(v7, type);
      if (!v14)
      {
        if (!v15)
        {
          goto LABEL_52;
        }

        *buf = 136446210;
        v21 = "nw_protocol_http3_error";
        v9 = "%{public}s called with null http3, no backtrace";
        goto LABEL_51;
      }

      if (v15)
      {
        *buf = 136446466;
        v21 = "nw_protocol_http3_error";
        v22 = 2082;
        v23 = v14;
        v16 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_181A37000, v7, v8, v16, buf, 0x16u);
      }

LABEL_37:
      free(v14);
      if (!v6)
      {
        return;
      }

LABEL_53:
      free(v6);
      return;
    }

    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_52;
    }

    *buf = 136446210;
    v21 = "nw_protocol_http3_error";
    v9 = "%{public}s called with null http3";
LABEL_51:
    _os_log_impl(&dword_181A37000, v7, v8, v9, buf, 0xCu);
    goto LABEL_52;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_protocol_http3_error";
    v6 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v6, &type, &v18))
    {
      goto LABEL_52;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_52;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_error";
      v9 = "%{public}s called with null other_protocol";
      goto LABEL_51;
    }

    if (v18 != 1)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_52;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_error";
      v9 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_51;
    }

    v14 = __nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v17 = os_log_type_enabled(v7, type);
    if (!v14)
    {
      if (!v17)
      {
        goto LABEL_52;
      }

      *buf = 136446210;
      v21 = "nw_protocol_http3_error";
      v9 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_51;
    }

    if (v17)
    {
      *buf = 136446466;
      v21 = "nw_protocol_http3_error";
      v22 = 2082;
      v23 = v14;
      v16 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_36;
    }

    goto LABEL_37;
  }

  if ((handle[1399] & 0x20) == 0 && gLogDatapath == 1)
  {
    v10 = __nwlog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      v11 = *(handle + 326);
      *buf = 136446978;
      v21 = "nw_protocol_http3_error";
      v22 = 2082;
      v23 = handle + 1313;
      v24 = 2080;
      v25 = " ";
      v26 = 1024;
      v27 = v11;
      _os_log_impl(&dword_181A37000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }

  v4 = *(handle + 111);
  if (v4)
  {
    do
    {
      callbacks = v4[8].callbacks;
      nw_protocol_http3_stream_error(v4, a2);
      v4 = callbacks;
    }

    while (callbacks);
  }
}

void nw_protocol_http3_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  v25 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v18 = "nw_protocol_http3_disconnected";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v3, &type, &v15))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_38;
      }

      *buf = 136446210;
      v18 = "nw_protocol_http3_disconnected";
      v6 = "%{public}s called with null protocol";
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v12 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v18 = "nw_protocol_http3_disconnected";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v3)
        {
          return;
        }

LABEL_39:
        free(v3);
        return;
      }

      if (!v12)
      {
        goto LABEL_38;
      }

      *buf = 136446210;
      v18 = "nw_protocol_http3_disconnected";
      v6 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
      {
        goto LABEL_38;
      }

      *buf = 136446210;
      v18 = "nw_protocol_http3_disconnected";
      v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_37:
    _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
    goto LABEL_38;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((*(handle + 1399) & 0x20) == 0 && gLogDatapath == 1)
    {
      v7 = handle;
      v8 = __nwlog_obj();
      v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG);
      handle = v7;
      if (v9)
      {
        v10 = *(v7 + 326);
        *buf = 136446978;
        v18 = "nw_protocol_http3_disconnected";
        v19 = 2082;
        v20 = v7 + 1313;
        v21 = 2080;
        v22 = " ";
        v23 = 1024;
        v24 = v10;
        _os_log_impl(&dword_181A37000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        handle = v7;
      }
    }

    if ((*(handle + 1397) & 8) == 0)
    {
      nw_http3_fail_all_streams(handle, 260);
    }

    return;
  }

  __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_protocol_http3_disconnected";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v3, &type, &v15))
  {
    goto LABEL_38;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
    {
      goto LABEL_38;
    }

    *buf = 136446210;
    v18 = "nw_protocol_http3_disconnected";
    v6 = "%{public}s called with null http3";
    goto LABEL_37;
  }

  if (v15 != 1)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
    {
      goto LABEL_38;
    }

    *buf = 136446210;
    v18 = "nw_protocol_http3_disconnected";
    v6 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_37;
  }

  v13 = __nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = type;
  v14 = os_log_type_enabled(v4, type);
  if (!v13)
  {
    if (!v14)
    {
      goto LABEL_38;
    }

    *buf = 136446210;
    v18 = "nw_protocol_http3_disconnected";
    v6 = "%{public}s called with null http3, no backtrace";
    goto LABEL_37;
  }

  if (v14)
  {
    *buf = 136446466;
    v18 = "nw_protocol_http3_disconnected";
    v19 = 2082;
    v20 = v13;
    _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v13);
  if (v3)
  {
    goto LABEL_39;
  }
}

void nw_protocol_http3_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  v28 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_protocol_http3_disconnect";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v4, &type, &v20))
    {
      goto LABEL_19;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
      {
        goto LABEL_19;
      }

      *buf = 136446210;
      v23 = "nw_protocol_http3_disconnect";
      v7 = "%{public}s called with null protocol";
      goto LABEL_61;
    }

    if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type;
      v16 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (!v16)
        {
          goto LABEL_47;
        }

        *buf = 136446466;
        v23 = "nw_protocol_http3_disconnect";
        v24 = 2082;
        v25 = backtrace_string;
        v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_46;
      }

      if (!v16)
      {
        goto LABEL_19;
      }

      *buf = 136446210;
      v23 = "nw_protocol_http3_disconnect";
      v7 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
      {
        goto LABEL_19;
      }

      *buf = 136446210;
      v23 = "nw_protocol_http3_disconnect";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_61:
    v10 = v13;
    v11 = v14;
    v12 = 12;
    goto LABEL_18;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_protocol_http3_disconnect";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v4, &type, &v20))
    {
      goto LABEL_19;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
      {
        goto LABEL_19;
      }

      *buf = 136446210;
      v23 = "nw_protocol_http3_disconnect";
      v7 = "%{public}s called with null http3";
      goto LABEL_61;
    }

    if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type;
      v18 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (!v18)
        {
          goto LABEL_47;
        }

        *buf = 136446466;
        v23 = "nw_protocol_http3_disconnect";
        v24 = 2082;
        v25 = backtrace_string;
        v17 = "%{public}s called with null http3, dumping backtrace:%{public}s";
        goto LABEL_46;
      }

      if (!v18)
      {
        goto LABEL_19;
      }

      *buf = 136446210;
      v23 = "nw_protocol_http3_disconnect";
      v7 = "%{public}s called with null http3, no backtrace";
    }

    else
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
      {
        goto LABEL_19;
      }

      *buf = 136446210;
      v23 = "nw_protocol_http3_disconnect";
      v7 = "%{public}s called with null http3, backtrace limit exceeded";
    }

    goto LABEL_61;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (a2)
  {
    *buf = 136446466;
    v23 = "nw_protocol_http3_disconnect";
    v24 = 2048;
    v25 = handle;
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v4, &type, &v20))
    {
      goto LABEL_19;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_19;
      }

      *buf = 136446466;
      v23 = "nw_protocol_http3_disconnect";
      v24 = 2048;
      v25 = handle;
      v7 = "%{public}s http3 %p called";
LABEL_17:
      v10 = v5;
      v11 = v6;
      v12 = 22;
LABEL_18:
      _os_log_impl(&dword_181A37000, v10, v11, v7, buf, v12);
      goto LABEL_19;
    }

    if (v20 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_19;
      }

      *buf = 136446466;
      v23 = "nw_protocol_http3_disconnect";
      v24 = 2048;
      v25 = handle;
      v7 = "%{public}s http3 %p called, backtrace limit exceeded";
      goto LABEL_17;
    }

    v8 = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    v6 = type;
    v9 = os_log_type_enabled(gLogObj, type);
    if (!v8)
    {
      if (!v9)
      {
        goto LABEL_19;
      }

      *buf = 136446466;
      v23 = "nw_protocol_http3_disconnect";
      v24 = 2048;
      v25 = handle;
      v7 = "%{public}s http3 %p called, no backtrace";
      goto LABEL_17;
    }

    if (v9)
    {
      *buf = 136446722;
      v23 = "nw_protocol_http3_disconnect";
      v24 = 2048;
      v25 = handle;
      v26 = 2082;
      v27 = v8;
      _os_log_impl(&dword_181A37000, v5, v6, "%{public}s http3 %p called, dumping backtrace:%{public}s", buf, 0x20u);
    }

    free(v8);
LABEL_19:
    if (!v4)
    {
      return;
    }

    goto LABEL_20;
  }

  *buf = 136446210;
  v23 = "nw_protocol_http3_disconnect";
  v4 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v4, &type, &v20))
  {
    goto LABEL_19;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v13 = __nwlog_obj();
    v14 = type;
    if (!os_log_type_enabled(v13, type))
    {
      goto LABEL_19;
    }

    *buf = 136446210;
    v23 = "nw_protocol_http3_disconnect";
    v7 = "%{public}s called with null other_protocol";
    goto LABEL_61;
  }

  if (v20 != 1)
  {
    v13 = __nwlog_obj();
    v14 = type;
    if (!os_log_type_enabled(v13, type))
    {
      goto LABEL_19;
    }

    *buf = 136446210;
    v23 = "nw_protocol_http3_disconnect";
    v7 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_61;
  }

  backtrace_string = __nw_create_backtrace_string();
  v13 = __nwlog_obj();
  v14 = type;
  v19 = os_log_type_enabled(v13, type);
  if (!backtrace_string)
  {
    if (!v19)
    {
      goto LABEL_19;
    }

    *buf = 136446210;
    v23 = "nw_protocol_http3_disconnect";
    v7 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_61;
  }

  if (!v19)
  {
    goto LABEL_47;
  }

  *buf = 136446466;
  v23 = "nw_protocol_http3_disconnect";
  v24 = 2082;
  v25 = backtrace_string;
  v17 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_46:
  _os_log_impl(&dword_181A37000, v13, v14, v17, buf, 0x16u);
LABEL_47:
  free(backtrace_string);
  if (v4)
  {
LABEL_20:
    free(v4);
  }
}

uint64_t nw_protocol_http3_connect(nw_protocol *a1, nw_protocol *a2)
{
  v28 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_protocol_http3_connect";
    v11 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v11, &type, &v20))
    {
      goto LABEL_61;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_61;
      }

      *buf = 136446210;
      v23 = "nw_protocol_http3_connect";
      v14 = "%{public}s called with null protocol";
LABEL_60:
      _os_log_impl(&dword_181A37000, v12, v13, v14, buf, 0xCu);
      goto LABEL_61;
    }

    if (v20 != 1)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v23 = "nw_protocol_http3_connect";
        v14 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    backtrace_string = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v16 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *buf = 136446210;
        v23 = "nw_protocol_http3_connect";
        v14 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    if (!v16)
    {
      goto LABEL_47;
    }

    *buf = 136446466;
    v23 = "nw_protocol_http3_connect";
    v24 = 2082;
    v25 = backtrace_string;
    v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_46:
    _os_log_impl(&dword_181A37000, v12, v13, v17, buf, 0x16u);
    goto LABEL_47;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_protocol_http3_connect";
    v11 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v11, &type, &v20))
    {
      goto LABEL_61;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_61;
      }

      *buf = 136446210;
      v23 = "nw_protocol_http3_connect";
      v14 = "%{public}s called with null http3";
      goto LABEL_60;
    }

    if (v20 != 1)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v23 = "nw_protocol_http3_connect";
        v14 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    backtrace_string = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v18 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *buf = 136446210;
        v23 = "nw_protocol_http3_connect";
        v14 = "%{public}s called with null http3, no backtrace";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    if (!v18)
    {
      goto LABEL_47;
    }

    *buf = 136446466;
    v23 = "nw_protocol_http3_connect";
    v24 = 2082;
    v25 = backtrace_string;
    v17 = "%{public}s called with null http3, dumping backtrace:%{public}s";
    goto LABEL_46;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (a2)
  {
    *buf = 136446466;
    v23 = "nw_protocol_http3_connect";
    v24 = 2048;
    v25 = handle;
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v4, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        v6 = type;
        if (os_log_type_enabled(gLogObj, type))
        {
          *buf = 136446466;
          v23 = "nw_protocol_http3_connect";
          v24 = 2048;
          v25 = handle;
          v7 = "%{public}s http3 %p called";
LABEL_17:
          _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0x16u);
        }
      }

      else if (v20 == 1)
      {
        v8 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        v6 = type;
        v9 = os_log_type_enabled(gLogObj, type);
        if (v8)
        {
          if (v9)
          {
            *buf = 136446722;
            v23 = "nw_protocol_http3_connect";
            v24 = 2048;
            v25 = handle;
            v26 = 2082;
            v27 = v8;
            _os_log_impl(&dword_181A37000, v5, v6, "%{public}s http3 %p called, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v8);
          goto LABEL_18;
        }

        if (v9)
        {
          *buf = 136446466;
          v23 = "nw_protocol_http3_connect";
          v24 = 2048;
          v25 = handle;
          v7 = "%{public}s http3 %p called, no backtrace";
          goto LABEL_17;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        v6 = type;
        if (os_log_type_enabled(gLogObj, type))
        {
          *buf = 136446466;
          v23 = "nw_protocol_http3_connect";
          v24 = 2048;
          v25 = handle;
          v7 = "%{public}s http3 %p called, backtrace limit exceeded";
          goto LABEL_17;
        }
      }
    }

LABEL_18:
    if (v4)
    {
      free(v4);
    }

    return 1;
  }

  *buf = 136446210;
  v23 = "nw_protocol_http3_connect";
  v11 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v11, &type, &v20))
  {
    goto LABEL_61;
  }

  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v20 != 1)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v23 = "nw_protocol_http3_connect";
        v14 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    backtrace_string = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v19 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *buf = 136446210;
        v23 = "nw_protocol_http3_connect";
        v14 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    if (v19)
    {
      *buf = 136446466;
      v23 = "nw_protocol_http3_connect";
      v24 = 2082;
      v25 = backtrace_string;
      v17 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_46;
    }

LABEL_47:
    free(backtrace_string);
    goto LABEL_61;
  }

  v12 = __nwlog_obj();
  v13 = type;
  if (os_log_type_enabled(v12, type))
  {
    *buf = 136446210;
    v23 = "nw_protocol_http3_connect";
    v14 = "%{public}s called with null other_protocol";
    goto LABEL_60;
  }

LABEL_61:
  if (v11)
  {
    free(v11);
  }

  return 0;
}

BOOL nw_queue_target_dispatch_queue(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    if (nw_context_copy_implicit_context::onceToken[0] != -1)
    {
      dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
    }

    v2 = nw_context_copy_implicit_context::implicit_context;
    v3 = nw_context_copy_workloop(v2);

    dispatch_set_target_queue(v1, v3);
    goto LABEL_5;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_queue_target_dispatch_queue";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_queue_target_dispatch_queue";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null queue", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_queue_target_dispatch_queue";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_queue_target_dispatch_queue";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_queue_target_dispatch_queue";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v6)
  {
    free(v6);
  }

LABEL_5:

  return v1 != 0;
}

uint64_t nw_queue_register_dispatch_queue(void *a1)
{
  v22 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = gLogObj;
    *buf = 136446210;
    v19 = "nw_queue_register_dispatch_queue";
    v3 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v3, &type, &v16))
    {
      goto LABEL_19;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl(&dword_181A37000, v4, v5, "%{public}s nw_queue_register_dispatch_queue is deprecated", buf, 0xCu);
      }

LABEL_18:

      goto LABEL_19;
    }

    if (v16 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl(&dword_181A37000, v4, v9, "%{public}s nw_queue_register_dispatch_queue is deprecated, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_18;
    }

    backtrace_string = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    v7 = type;
    v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *buf = 136446210;
        v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl(&dword_181A37000, v4, v7, "%{public}s nw_queue_register_dispatch_queue is deprecated, no backtrace", buf, 0xCu);
      }

      goto LABEL_18;
    }

    if (v8)
    {
      *buf = 136446466;
      v19 = "nw_queue_register_dispatch_queue";
      v20 = 2082;
      v21 = backtrace_string;
      _os_log_impl(&dword_181A37000, v4, v7, "%{public}s nw_queue_register_dispatch_queue is deprecated, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_11:

    free(backtrace_string);
    if (!v3)
    {
      goto LABEL_21;
    }

    goto LABEL_20;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v19 = "nw_queue_register_dispatch_queue";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v3, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl(&dword_181A37000, v4, v12, "%{public}s called with null queue", buf, 0xCu);
      }

      goto LABEL_18;
    }

    if (v16 != 1)
    {
      v4 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl(&dword_181A37000, v4, v15, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_18;
    }

    backtrace_string = __nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v13 = type;
    v14 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *buf = 136446210;
        v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl(&dword_181A37000, v4, v13, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_18;
    }

    if (v14)
    {
      *buf = 136446466;
      v19 = "nw_queue_register_dispatch_queue";
      v20 = 2082;
      v21 = backtrace_string;
      _os_log_impl(&dword_181A37000, v4, v13, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_11;
  }

LABEL_19:
  if (v3)
  {
LABEL_20:
    free(v3);
  }

LABEL_21:

  return 0;
}

void nw_queue_async(void *a1)
{
  block = a1;
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
  {
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }

  v1 = nw_context_copy_implicit_context::implicit_context;
  v2 = nw_context_copy_workloop(v1);

  dispatch_async(v2, block);
}

void nw_queue_async_current(void *a1)
{
  block = a1;
  v1 = nw_queue_copy_current_workloop();
  dispatch_async(v1, block);
}

uint64_t nw_queue_create_source(int a1, int a2, unsigned int a3, void *a4, void *a5)
{
  v9 = a4;
  v10 = a5;
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
  {
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }

  v11 = nw_context_copy_implicit_context::implicit_context;
  source = nw_queue_context_create_source(v11, a1, a2, a3, v9, v10);

  return source;
}

void nw_queue_source_run_timer(uint64_t a1, uint64_t a2)
{
  v13 = *MEMORY[0x1E69E9840];
  if (*(a1 + 16))
  {
    if (*(a1 + 40) == -1)
    {
      v7 = *(a1 + 8);
      v8 = *(a1 + 32);

      nw_context_reset_timer_block_with_time(v7, a1, v8);
    }

    else
    {
      v3 = _Block_copy(*(a1 + 16));
      v4 = *(a1 + 8);
      v5 = *(a1 + 32);
      v10 = v3;
      v6 = v3;
      nw_context_reset_timer_block_with_time(v4, a1, v5);
    }
  }

  else if (gLogDatapath == 1)
  {
    v9 = __nwlog_obj(a1, a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *buf = 136446210;
      v12 = "nw_queue_source_run_timer";
      _os_log_impl(&dword_181A37000, v9, OS_LOG_TYPE_DEBUG, "%{public}s Cancelled, not running timer", buf, 0xCu);
    }
  }
}

uint64_t ___ZL25nw_queue_source_run_timerP15nw_queue_source_block_invoke(uint64_t a1)
{
  (*(*(a1 + 32) + 16))();
  v2 = *(a1 + 40);
  v3 = *(v2 + 40);
  if (v3 == -1)
  {
    v4 = -1;
  }

  else
  {
    v4 = dispatch_time(0x8000000000000000, v3);
    v2 = *(a1 + 40);
  }

  *(v2 + 32) = v4;

  return nw_queue_source_run_timer();
}

void __nw_queue_cancel_source_block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  if (v1)
  {
    free(v1);
  }
}

uint64_t nw_hash_table_create_no_lock(unsigned int a1, int a2, const void *(*a3)(const void *, unsigned int *), unsigned int (*a4)(const void *, unsigned int), BOOL (*a5)(const void *, const void *, unsigned int), void (*a6)(void *), void *(*a7)(void *))
{
  v20 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    result = nw_hash_table_create_internal(a1, a2, a3, a4, a5, a6, a7);
    if (result)
    {
      *(result + 56) &= ~2u;
    }

    return result;
  }

  __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_hash_table_create_no_lock";
  v8 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v8, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v17 = "nw_hash_table_create_no_lock";
        v11 = "%{public}s called with null count";
LABEL_18:
        _os_log_impl(&dword_181A37000, v9, v10, v11, buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v17 = "nw_hash_table_create_no_lock";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null count, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (v13)
      {
        *buf = 136446210;
        v17 = "nw_hash_table_create_no_lock";
        v11 = "%{public}s called with null count, no backtrace";
        goto LABEL_18;
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v17 = "nw_hash_table_create_no_lock";
        v11 = "%{public}s called with null count, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
  }

LABEL_19:
  if (v8)
  {
    free(v8);
  }

  return 0;
}

uint64_t nw_hash_table_create_internal(unsigned int a1, int a2, const void *(*a3)(const void *, unsigned int *), unsigned int (*a4)(const void *, unsigned int), BOOL (*a5)(const void *, const void *, unsigned int), void (*a6)(void *), void *(*a7)(void *))
{
  result = malloc_type_calloc(1uLL, 16 * a1 + 64, 0xC93C5A51uLL);
  if (!result)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    v15 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v15);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v15);
    result = 0;
  }

  *(result + 40) = a1;
  *(result + 44) = a2;
  *result = a3;
  *(result + 8) = a4;
  *(result + 24) = a6;
  *(result + 32) = a7;
  *(result + 16) = a5;
  *(result + 56) = *(result + 56) | 3u;
  if (a1 < 4)
  {
    v16 = 0;
LABEL_9:
    v25 = a1 - v16;
    v26 = (result + 16 * v16 + 64);
    do
    {
      *v26 = 0;
      v26[1] = v26;
      v26 += 2;
      --v25;
    }

    while (v25);
    return result;
  }

  v17 = (result + 64);
  v16 = a1 & 0xFFFFFFFC;
  v18 = 0uLL;
  v19 = v16;
  do
  {
    v20 = v17;
    v21 = v17 + 2;
    *&v22 = v17 + 6;
    v23 = v17 + 8;
    vst2q_f64(v17, *&v18);
    v24 = v17 + 4;
    *&v27.val[1].f64[0] = v24;
    v27.val[1].f64[1] = v22;
    v27.val[0] = 0uLL;
    vst2q_f64(v24, v27);
    v17 = v23;
    v19 -= 4;
  }

  while (v19);
  if (v16 != a1)
  {
    goto LABEL_9;
  }

  return result;
}

uint64_t nw_hash_table_create_with_lock(unsigned int a1, int a2, const void *(*a3)(const void *, unsigned int *), unsigned int (*a4)(const void *, unsigned int), BOOL (*a5)(const void *, const void *, unsigned int), void (*a6)(void *), void *(*a7)(void *))
{
  v20 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return nw_hash_table_create_internal(a1, a2, a3, a4, a5, a6, a7);
  }

  __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_hash_table_create_with_lock";
  v8 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v8, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v17 = "nw_hash_table_create_with_lock";
        v11 = "%{public}s called with null count";
LABEL_18:
        _os_log_impl(&dword_181A37000, v9, v10, v11, buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v17 = "nw_hash_table_create_with_lock";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null count, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (v13)
      {
        *buf = 136446210;
        v17 = "nw_hash_table_create_with_lock";
        v11 = "%{public}s called with null count, no backtrace";
        goto LABEL_18;
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v17 = "nw_hash_table_create_with_lock";
        v11 = "%{public}s called with null count, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
  }

LABEL_19:
  if (v8)
  {
    free(v8);
  }

  return 0;
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke_65919()
{
  result = networkd_settings_get_BOOL(nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

uint64_t nw_protocol_hash_retain(uint64_t result)
{
  if (result && *(result + 40) == &nw_protocol_ref_counted_handle)
  {
    v1 = *(result + 88);
    if (v1)
    {
      *(result + 88) = v1 + 1;
    }
  }

  return result;
}

void nw_protocol_hash_release(void *a1)
{
  if (a1)
  {
    if (*(a1 + 5) == &nw_protocol_ref_counted_handle)
    {
      v2 = *(a1 + 11);
      if (v2)
      {
        v3 = v2 - 1;
        *(a1 + 11) = v3;
        if (!v3)
        {
          v4 = *(a1 + 8);
          if (v4)
          {
            *(a1 + 8) = 0;
            v5 = a1;
            v4[2](v4);
            _Block_release(v4);
            a1 = v5;
          }

          if ((*(a1 + 72) & 1) != 0 && *(a1 + 8))
          {
            v6 = a1;
            _Block_release(*(a1 + 8));
            a1 = v6;
          }

          free(a1);
        }
      }
    }
  }
}

void nw_packet_release(void *a1)
{
  if (a1)
  {
    free(a1);
  }
}

BOOL nw_packet_matches_key(uint64_t *a1, uint64_t *a2)
{
  v2 = *a1;
  v3 = a1[1];
  v4 = *a2;
  v5 = a2[1];
  v6 = a1[2];
  v7 = a1[3];
  v8 = a2[2];
  v9 = a2[3];
  v10 = a1[4];
  v11 = a1[5];
  v12 = a2[4];
  v13 = a2[5];
  v14 = a1[6];
  v15 = a2[6];
  v16 = *(a1 + 14);
  v17 = *(a2 + 14);
  return v2 == v4 && v3 == v5 && v6 == v8 && v7 == v9 && v10 == v12 && v11 == v13 && v14 == v15 && v16 == v17;
}

void sub_1828F4548(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = NWConcrete_nw_http_proxy_server;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void nw_http_proxy_connection_pair_cancel(NWConcrete_nw_http_proxy_connection_pair *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *(v1 + 2);
    block[0] = MEMORY[0x1E69E9820];
    block[1] = 3221225472;
    block[2] = ___ZL36nw_http_proxy_connection_pair_cancelP40NWConcrete_nw_http_proxy_connection_pair_block_invoke;
    block[3] = &unk_1E6A3D868;
    v13 = v1;
    dispatch_async(v3, block);

    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_http_proxy_connection_pair_cancel";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_http_proxy_connection_pair_cancel";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v17 = "nw_http_proxy_connection_pair_cancel";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null pair, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v17 = "nw_http_proxy_connection_pair_cancel";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v17 = "nw_http_proxy_connection_pair_cancel";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

LABEL_3:
}

void ___ZL36nw_http_proxy_connection_pair_cancelP40NWConcrete_nw_http_proxy_connection_pair_block_invoke(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(v2 + 32);
  if (v3)
  {
    nw_connection_cancel(v3);
    v2 = *(a1 + 32);
  }

  v4 = *(v2 + 40);
  if (v4)
  {

    nw_connection_cancel(v4);
  }
}

id *nw_http_proxy_server_create(void *a1, void *a2)
{
  v64 = *MEMORY[0x1E69E9840];
  v4 = a1;
  v5 = a2;
  v6 = [NWConcrete_nw_http_proxy_server alloc];
  v7 = v4;
  v8 = v5;
  if (!v6)
  {
    goto LABEL_17;
  }

  v54.receiver = v6;
  v54.super_class = NWConcrete_nw_http_proxy_server;
  v9 = objc_msgSendSuper2(&v54, sel_init);
  v10 = v9;
  if (!v9)
  {
    v30 = __nwlog_obj();
    *iterate_block = 136446210;
    *&iterate_block[4] = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
    v31 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (__nwlog_fault(v31, type, buf))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v32 = __nwlog_obj();
        v33 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          *iterate_block = 136446210;
          *&iterate_block[4] = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
          _os_log_impl(&dword_181A37000, v32, v33, "%{public}s [super init] failed", iterate_block, 0xCu);
        }
      }

      else if (buf[0] == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v32 = __nwlog_obj();
        v39 = type[0];
        v40 = os_log_type_enabled(v32, type[0]);
        if (backtrace_string)
        {
          if (v40)
          {
            *iterate_block = 136446466;
            *&iterate_block[4] = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
            *&iterate_block[12] = 2082;
            *&iterate_block[14] = backtrace_string;
            _os_log_impl(&dword_181A37000, v32, v39, "%{public}s [super init] failed, dumping backtrace:%{public}s", iterate_block, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_62;
        }

        if (v40)
        {
          *iterate_block = 136446210;
          *&iterate_block[4] = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
          _os_log_impl(&dword_181A37000, v32, v39, "%{public}s [super init] failed, no backtrace", iterate_block, 0xCu);
        }
      }

      else
      {
        v32 = __nwlog_obj();
        v44 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          *iterate_block = 136446210;
          *&iterate_block[4] = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
          _os_log_impl(&dword_181A37000, v32, v44, "%{public}s [super init] failed, backtrace limit exceeded", iterate_block, 0xCu);
        }
      }
    }

LABEL_62:
    if (v31)
    {
      free(v31);
    }

    goto LABEL_17;
  }

  objc_storeStrong(v9 + 2, a1);
  v11 = v10[3];
  v10[3] = 0;

  v12 = dispatch_queue_create("com.apple.networking.http_proxy_server", 0);
  v13 = v10[4];
  v10[4] = v12;

  objc_storeStrong(v10 + 5, a2);
  v14 = v10[6];
  v10[6] = 0;

  v15 = v10[7];
  v10[7] = 0;

  v16 = _nw_array_create();
  v17 = v10[8];
  v10[8] = v16;

  if (!v10[4])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = gLogObj;
    *iterate_block = 136446210;
    *&iterate_block[4] = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
    v22 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (__nwlog_fault(v22, type, buf))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v24 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *iterate_block = 136446210;
          *&iterate_block[4] = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
          _os_log_impl(&dword_181A37000, v23, v24, "%{public}s dispatch_queue_create failed", iterate_block, 0xCu);
        }
      }

      else if (buf[0] == 1)
      {
        v26 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v27 = type[0];
        v28 = os_log_type_enabled(v23, type[0]);
        if (v26)
        {
          if (v28)
          {
            *iterate_block = 136446466;
            *&iterate_block[4] = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
            *&iterate_block[12] = 2082;
            *&iterate_block[14] = v26;
            _os_log_impl(&dword_181A37000, v23, v27, "%{public}s dispatch_queue_create failed, dumping backtrace:%{public}s", iterate_block, 0x16u);
          }

          free(v26);
          if (!v22)
          {
            goto LABEL_16;
          }

          goto LABEL_15;
        }

        if (v28)
        {
          *iterate_block = 136446210;
          *&iterate_block[4] = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
          _os_log_impl(&dword_181A37000, v23, v27, "%{public}s dispatch_queue_create failed, no backtrace", iterate_block, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v29 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *iterate_block = 136446210;
          *&iterate_block[4] = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
          _os_log_impl(&dword_181A37000, v23, v29, "%{public}s dispatch_queue_create failed, backtrace limit exceeded", iterate_block, 0xCu);
        }
      }
    }

    if (!v22)
    {
LABEL_16:

LABEL_17:
      v20 = 0;
      goto LABEL_18;
    }

LABEL_15:
    free(v22);
    goto LABEL_16;
  }

  v18 = nw_parameters_copy_context(v7);
  v52 = v18;
  v53 = -1;
  nw_queue_context_target_dispatch_queue(v18, v10[4]);
  *type = 0;
  v49 = type;
  v50 = 0x2020000000;
  v51 = 0;
  v19 = nw_parameters_copy_default_protocol_stack(v10[2]);
  *iterate_block = MEMORY[0x1E69E9820];
  *&iterate_block[8] = 3221225472;
  *&iterate_block[16] = __66__NWConcrete_nw_http_proxy_server_initWithParameters_clientQueue___block_invoke;
  v62 = &unk_1E6A395C0;
  v63 = type;
  nw_protocol_stack_iterate_application_protocols(v19, iterate_block);
  if ((v49[24] & 1) == 0)
  {
    v34 = __nwlog_obj();
    *buf = 136446466;
    v56 = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
    v57 = 2082;
    v58 = "Did not find HTTP in protocol stack.";
    v35 = _os_log_send_and_compose_impl();

    v47 = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (__nwlog_fault(v35, &v47, &v46))
    {
      if (v47 == OS_LOG_TYPE_FAULT)
      {
        v36 = __nwlog_obj();
        v37 = v47;
        if (os_log_type_enabled(v36, v47))
        {
          *buf = 136446466;
          v56 = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
          v57 = 2082;
          v58 = "Did not find HTTP in protocol stack.";
          _os_log_impl(&dword_181A37000, v36, v37, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
        }
      }

      else if (v46 == 1)
      {
        v41 = __nw_create_backtrace_string();
        v36 = __nwlog_obj();
        v42 = v47;
        v43 = os_log_type_enabled(v36, v47);
        if (v41)
        {
          if (v43)
          {
            *buf = 136446722;
            v56 = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
            v57 = 2082;
            v58 = "Did not find HTTP in protocol stack.";
            v59 = 2082;
            v60 = v41;
            _os_log_impl(&dword_181A37000, v36, v42, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v41);
          goto LABEL_67;
        }

        if (v43)
        {
          *buf = 136446466;
          v56 = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
          v57 = 2082;
          v58 = "Did not find HTTP in protocol stack.";
          _os_log_impl(&dword_181A37000, v36, v42, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
        }
      }

      else
      {
        v36 = __nwlog_obj();
        v45 = v47;
        if (os_log_type_enabled(v36, v47))
        {
          *buf = 136446466;
          v56 = "[NWConcrete_nw_http_proxy_server initWithParameters:clientQueue:]";
          v57 = 2082;
          v58 = "Did not find HTTP in protocol stack.";
          _os_log_impl(&dword_181A37000, v36, v45, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }

LABEL_67:
    if (v35)
    {
      free(v35);
    }

    v20 = 0;
    goto LABEL_6;
  }

  v20 = v10;
LABEL_6:

  _Block_object_dispose(type, 8);
  if (v18)
  {
  }

LABEL_18:

  return v20;
}

void sub_1828F52D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  v14 = va_arg(va1, void);
  v16 = va_arg(va1, void);
  v17 = va_arg(va1, void);
  v18 = va_arg(va1, void);

  _Block_object_dispose(va, 8);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(va1);

  _Unwind_Resume(a1);
}

void nw_http_proxy_server_set_state_changed_handler(void *a1, void *a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    aBlock[0] = MEMORY[0x1E69E9820];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_http_proxy_server_set_state_changed_handler_block_invoke;
    aBlock[3] = &unk_1E6A3D710;
    v15 = v3;
    v16 = v4;
    v5 = _Block_copy(aBlock);
    os_unfair_lock_lock(v3 + 2);
    v5[2](v5);
    os_unfair_lock_unlock(v3 + 2);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_http_proxy_server_set_state_changed_handler";
  v7 = _os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_http_proxy_server_set_state_changed_handler";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null server", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_http_proxy_server_set_state_changed_handler";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_http_proxy_server_set_state_changed_handler";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_http_proxy_server_set_state_changed_handler";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void __nw_http_proxy_server_set_state_changed_handler_block_invoke(uint64_t a1)
{
  v2 = _Block_copy(*(a1 + 40));
  v3 = *(a1 + 32);
  v4 = *(v3 + 48);
  *(v3 + 48) = v2;
}

void nw_http_proxy_server_set_outbound_connection_handler(void *a1, void *a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    aBlock[0] = MEMORY[0x1E69E9820];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_http_proxy_server_set_outbound_connection_handler_block_invoke;
    aBlock[3] = &unk_1E6A3D710;
    v15 = v3;
    v16 = v4;
    v5 = _Block_copy(aBlock);
    os_unfair_lock_lock(v3 + 2);
    v5[2](v5);
    os_unfair_lock_unlock(v3 + 2);

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_http_proxy_server_set_outbound_connection_handler";
  v7 = _os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_http_proxy_server_set_outbound_connection_handler";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null server", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v20 = "nw_http_proxy_server_set_outbound_connection_handler";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v20 = "nw_http_proxy_server_set_outbound_connection_handler";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *buf = 136446210;
        v20 = "nw_http_proxy_server_set_outbound_connection_handler";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void __nw_http_proxy_server_set_outbound_connection_handler_block_invoke(uint64_t a1)
{
  v2 = _Block_copy(*(a1 + 40));
  v3 = *(a1 + 32);
  v4 = *(v3 + 56);
  *(v3 + 56) = v2;
}

uint64_t nw_http_proxy_server_get_port(void *a1)
{
  v21 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v20 = 0;
    aBlock[0] = MEMORY[0x1E69E9820];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_http_proxy_server_get_port_block_invoke;
    aBlock[3] = &unk_1E6A3D738;
    v15 = v1;
    v16 = buf;
    v3 = _Block_copy(aBlock);
    os_unfair_lock_lock(v2 + 2);
    v3[2](v3);
    os_unfair_lock_unlock(v2 + 2);

    v4 = *(*&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_http_proxy_server_get_port";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_server_get_port";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null server", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          *&buf[4] = "nw_http_proxy_server_get_port";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_server_get_port";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_server_get_port";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

  v4 = 0;
LABEL_3:

  return v4;
}

void sub_1828F5DDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

NSObject *__nw_http_proxy_server_get_port_block_invoke(uint64_t a1)
{
  result = *(*(a1 + 32) + 24);
  if (result)
  {
    result = nw_listener_get_port(result);
    *(*(*(a1 + 40) + 8) + 24) = result;
  }

  return result;
}

void nw_http_proxy_server_start(void *a1)
{
  v39 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v8 = __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_http_proxy_server_start";
    v9 = _os_log_send_and_compose_impl();

    v34 = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v9, &v34, &v33))
    {
      goto LABEL_55;
    }

    if (v34 == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = v34;
      if (os_log_type_enabled(v10, v34))
      {
        *buf = 136446210;
        v36 = "nw_http_proxy_server_start";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null server", buf, 0xCu);
      }
    }

    else if (v33 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v17 = v34;
      v18 = os_log_type_enabled(v10, v34);
      if (backtrace_string)
      {
        if (v18)
        {
          *buf = 136446466;
          v36 = "nw_http_proxy_server_start";
          v37 = 2082;
          v38 = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v17, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v9)
        {
          goto LABEL_5;
        }

LABEL_56:
        free(v9);
        goto LABEL_5;
      }

      if (v18)
      {
        *buf = 136446210;
        v36 = "nw_http_proxy_server_start";
        _os_log_impl(&dword_181A37000, v10, v17, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v24 = v34;
      if (os_log_type_enabled(v10, v34))
      {
        *buf = 136446210;
        v36 = "nw_http_proxy_server_start";
        _os_log_impl(&dword_181A37000, v10, v24, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_54:

    goto LABEL_55;
  }

  if (!*&v1[8]._os_unfair_lock_opaque)
  {
    v12 = __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_http_proxy_server_start";
    v9 = _os_log_send_and_compose_impl();

    v34 = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v9, &v34, &v33))
    {
      goto LABEL_55;
    }

    if (v34 == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v13 = v34;
      if (os_log_type_enabled(v10, v34))
      {
        *buf = 136446210;
        v36 = "nw_http_proxy_server_start";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null server->queue", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v33 != 1)
    {
      v10 = __nwlog_obj();
      v25 = v34;
      if (os_log_type_enabled(v10, v34))
      {
        *buf = 136446210;
        v36 = "nw_http_proxy_server_start";
        _os_log_impl(&dword_181A37000, v10, v25, "%{public}s called with null server->queue, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    v19 = __nw_create_backtrace_string();
    v10 = __nwlog_obj();
    v20 = v34;
    v21 = os_log_type_enabled(v10, v34);
    if (!v19)
    {
      if (v21)
      {
        *buf = 136446210;
        v36 = "nw_http_proxy_server_start";
        _os_log_impl(&dword_181A37000, v10, v20, "%{public}s called with null server->queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *buf = 136446466;
      v36 = "nw_http_proxy_server_start";
      v37 = 2082;
      v38 = v19;
      _os_log_impl(&dword_181A37000, v10, v20, "%{public}s called with null server->queue, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_35;
  }

  if (!*&v1[4]._os_unfair_lock_opaque)
  {
    v14 = __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_http_proxy_server_start";
    v9 = _os_log_send_and_compose_impl();

    v34 = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v9, &v34, &v33))
    {
      goto LABEL_55;
    }

    if (v34 == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v15 = v34;
      if (os_log_type_enabled(v10, v34))
      {
        *buf = 136446210;
        v36 = "nw_http_proxy_server_start";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null server->parameters", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v33 != 1)
    {
      v10 = __nwlog_obj();
      v26 = v34;
      if (os_log_type_enabled(v10, v34))
      {
        *buf = 136446210;
        v36 = "nw_http_proxy_server_start";
        _os_log_impl(&dword_181A37000, v10, v26, "%{public}s called with null server->parameters, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    v19 = __nw_create_backtrace_string();
    v10 = __nwlog_obj();
    v22 = v34;
    v23 = os_log_type_enabled(v10, v34);
    if (!v19)
    {
      if (v23)
      {
        *buf = 136446210;
        v36 = "nw_http_proxy_server_start";
        _os_log_impl(&dword_181A37000, v10, v22, "%{public}s called with null server->parameters, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *buf = 136446466;
      v36 = "nw_http_proxy_server_start";
      v37 = 2082;
      v38 = v19;
      _os_log_impl(&dword_181A37000, v10, v22, "%{public}s called with null server->parameters, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_35:

    free(v19);
    if (!v9)
    {
      goto LABEL_5;
    }

    goto LABEL_56;
  }

  aBlock[0] = MEMORY[0x1E69E9820];
  aBlock[1] = 3221225472;
  aBlock[2] = __nw_http_proxy_server_start_block_invoke;
  aBlock[3] = &unk_1E6A3D868;
  v3 = v1;
  v32 = v3;
  v4 = _Block_copy(aBlock);
  os_unfair_lock_lock(v2 + 2);
  v4[2](v4);
  os_unfair_lock_unlock(v2 + 2);

  nw_listener_set_queue(v3[3], *&v2[8]._os_unfair_lock_opaque);
  v5 = v3[3];
  handler[0] = MEMORY[0x1E69E9820];
  handler[1] = 3221225472;
  handler[2] = __nw_http_proxy_server_start_block_invoke_2;
  handler[3] = &unk_1E6A3D820;
  v6 = v3;
  v30 = v6;
  nw_listener_set_state_changed_handler(v5, handler);
  v7 = v3[3];
  v27[0] = MEMORY[0x1E69E9820];
  v27[1] = 3221225472;
  v27[2] = __nw_http_proxy_server_start_block_invoke_2_76;
  v27[3] = &unk_1E6A395E8;
  v28 = v6;
  nw_listener_set_new_connection_handler(v7, v27);
  nw_listener_start(v3[3]);

LABEL_5:
}

void __nw_http_proxy_server_start_block_invoke(uint64_t a1)
{
  v2 = nw_listener_create(*(*(a1 + 32) + 16));
  v3 = *(a1 + 32);
  v4 = *(v3 + 24);
  *(v3 + 24) = v2;
}

void __nw_http_proxy_server_start_block_invoke_2(uint64_t a1, int a2, void *a3)
{
  v15 = *MEMORY[0x1E69E9840];
  v5 = a3;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = gLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v11 = 136446466;
    v12 = "nw_http_proxy_server_start_block_invoke_2";
    v13 = 1024;
    v14 = a2;
    _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_INFO, "%{public}s listener state changed to %u", &v11, 0x12u);
  }

  if (a2 == 4 && (v7 = *(*(a1 + 32) + 64)) != 0 && _nw_array_get_count(v7))
  {
    v8 = *(a1 + 32);
    v9 = *(v8 + 24);
    *(v8 + 24) = 0;

    v10 = *(*(a1 + 32) + 64);
    if (v10)
    {
      _nw_array_apply(v10, &__block_literal_global_74_66356);
    }
  }

  else
  {
    nw_http_proxy_server_report_state_change(*(a1 + 32), a2, v5);
  }
}

void __nw_http_proxy_server_start_block_invoke_2_76(uint64_t a1, void *a2)
{
  v109 = *MEMORY[0x1E69E9840];
  v4 = a2;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    *buf = 136446466;
    *&buf[4] = "nw_http_proxy_server_start_block_invoke_2";
    *&buf[12] = 2112;
    *&buf[14] = v4;
    _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_INFO, "%{public}s new inbound connection %@", buf, 0x16u);
  }

  v97 = v4;
  v6 = [NWConcrete_nw_http_proxy_connection_pair alloc];
  v7 = v97;
  if (v6)
  {
    *v108 = v6;
    *&v108[8] = NWConcrete_nw_http_proxy_connection_pair;
    v8 = objc_msgSendSuper2(v108, sel_init);
    v6 = v8;
    if (v8)
    {
      objc_storeStrong(v8 + 4, a2);
      v9 = *(v6 + 5);
      *(v6 + 5) = 0;

      goto LABEL_6;
    }

    v35 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "[NWConcrete_nw_http_proxy_connection_pair initWithInboundConnection:]";
    v36 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v101 = 0;
    if ((__nwlog_fault(v36, &type, &v101) & 1) == 0)
    {
      goto LABEL_131;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v37 = __nwlog_obj();
      v38 = type;
      if (os_log_type_enabled(v37, type))
      {
        *buf = 136446210;
        *&buf[4] = "[NWConcrete_nw_http_proxy_connection_pair initWithInboundConnection:]";
        _os_log_impl(&dword_181A37000, v37, v38, "%{public}s [super init] failed", buf, 0xCu);
      }
    }

    else if (v101 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v37 = __nwlog_obj();
      v62 = type;
      v63 = os_log_type_enabled(v37, type);
      if (backtrace_string)
      {
        if (v63)
        {
          *buf = 136446466;
          *&buf[4] = "[NWConcrete_nw_http_proxy_connection_pair initWithInboundConnection:]";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v37, v62, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_131;
      }

      if (v63)
      {
        *buf = 136446210;
        *&buf[4] = "[NWConcrete_nw_http_proxy_connection_pair initWithInboundConnection:]";
        _os_log_impl(&dword_181A37000, v37, v62, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v37 = __nwlog_obj();
      v83 = type;
      if (os_log_type_enabled(v37, type))
      {
        *buf = 136446210;
        *&buf[4] = "[NWConcrete_nw_http_proxy_connection_pair initWithInboundConnection:]";
        _os_log_impl(&dword_181A37000, v37, v83, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_131:
    if (v36)
    {
      free(v36);
    }

    v6 = 0;
  }

LABEL_6:

  v10 = *(a1 + 32);
  v11 = *(v10 + 32);
  v12 = *(v10 + 40);
  v13 = v6;
  v14 = v11;
  v15 = v12;
  v16 = v15;
  if (!v13)
  {
    v39 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
    v40 = _os_log_send_and_compose_impl();

    v108[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v40, v108, &type))
    {
      goto LABEL_172;
    }

    if (v108[0] == 17)
    {
      v41 = __nwlog_obj();
      v42 = v108[0];
      if (os_log_type_enabled(v41, v108[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
        _os_log_impl(&dword_181A37000, v41, v42, "%{public}s called with null pair", buf, 0xCu);
      }

      goto LABEL_171;
    }

    if (type != OS_LOG_TYPE_INFO)
    {
      v41 = __nwlog_obj();
      v84 = v108[0];
      if (os_log_type_enabled(v41, v108[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
        _os_log_impl(&dword_181A37000, v41, v84, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_171;
    }

    v64 = __nw_create_backtrace_string();
    v41 = __nwlog_obj();
    v65 = v108[0];
    v66 = os_log_type_enabled(v41, v108[0]);
    if (!v64)
    {
      if (v66)
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
        _os_log_impl(&dword_181A37000, v41, v65, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }

      goto LABEL_171;
    }

    if (v66)
    {
      *buf = 136446466;
      *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
      *&buf[12] = 2082;
      *&buf[14] = v64;
      _os_log_impl(&dword_181A37000, v41, v65, "%{public}s called with null pair, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v64);
    goto LABEL_172;
  }

  if (!v14)
  {
    v51 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
    v40 = _os_log_send_and_compose_impl();

    v108[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v40, v108, &type))
    {
      goto LABEL_172;
    }

    if (v108[0] == 17)
    {
      v41 = __nwlog_obj();
      v52 = v108[0];
      if (os_log_type_enabled(v41, v108[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
        _os_log_impl(&dword_181A37000, v41, v52, "%{public}s called with null queue", buf, 0xCu);
      }

      goto LABEL_171;
    }

    if (type != OS_LOG_TYPE_INFO)
    {
      v41 = __nwlog_obj();
      v87 = v108[0];
      if (os_log_type_enabled(v41, v108[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
        _os_log_impl(&dword_181A37000, v41, v87, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_171;
    }

    v73 = __nw_create_backtrace_string();
    v41 = __nwlog_obj();
    v74 = v108[0];
    v75 = os_log_type_enabled(v41, v108[0]);
    if (!v73)
    {
      if (v75)
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
        _os_log_impl(&dword_181A37000, v41, v74, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_171;
    }

    if (v75)
    {
      *buf = 136446466;
      *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
      *&buf[12] = 2082;
      *&buf[14] = v73;
      _os_log_impl(&dword_181A37000, v41, v74, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_96;
  }

  if (v15)
  {
    *buf = MEMORY[0x1E69E9820];
    *&buf[8] = 3221225472;
    *&buf[16] = ___ZL40nw_http_proxy_connection_pair_set_queuesP40NWConcrete_nw_http_proxy_connection_pairPU28objcproto17OS_dispatch_queue8NSObjectS3__block_invoke;
    v104 = &unk_1E6A3B4E0;
    v105 = v13;
    v106 = v14;
    v107 = v16;
    v17 = _Block_copy(buf);
    os_unfair_lock_lock(v13 + 2);
    v17[2](v17);
    os_unfair_lock_unlock(v13 + 2);

    goto LABEL_10;
  }

  v57 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
  v40 = _os_log_send_and_compose_impl();

  v108[0] = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v40, v108, &type))
  {
LABEL_172:
    if (!v40)
    {
      goto LABEL_10;
    }

    goto LABEL_173;
  }

  if (v108[0] == 17)
  {
    v41 = __nwlog_obj();
    v58 = v108[0];
    if (os_log_type_enabled(v41, v108[0]))
    {
      *buf = 136446210;
      *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
      _os_log_impl(&dword_181A37000, v41, v58, "%{public}s called with null client_queue", buf, 0xCu);
    }

LABEL_171:

    goto LABEL_172;
  }

  if (type != OS_LOG_TYPE_INFO)
  {
    v41 = __nwlog_obj();
    v89 = v108[0];
    if (os_log_type_enabled(v41, v108[0]))
    {
      *buf = 136446210;
      *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
      _os_log_impl(&dword_181A37000, v41, v89, "%{public}s called with null client_queue, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_171;
  }

  v73 = __nw_create_backtrace_string();
  v41 = __nwlog_obj();
  v79 = v108[0];
  v80 = os_log_type_enabled(v41, v108[0]);
  if (!v73)
  {
    if (v80)
    {
      *buf = 136446210;
      *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
      _os_log_impl(&dword_181A37000, v41, v79, "%{public}s called with null client_queue, no backtrace", buf, 0xCu);
    }

    goto LABEL_171;
  }

  if (v80)
  {
    *buf = 136446466;
    *&buf[4] = "nw_http_proxy_connection_pair_set_queues";
    *&buf[12] = 2082;
    *&buf[14] = v73;
    _os_log_impl(&dword_181A37000, v41, v79, "%{public}s called with null client_queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

LABEL_96:

  free(v73);
  if (v40)
  {
LABEL_173:
    free(v40);
  }

LABEL_10:

  v18 = *(*(a1 + 32) + 64);
  if (v18)
  {
    v19 = v13 == 0;
  }

  else
  {
    v19 = 1;
  }

  if (!v19)
  {
    _nw_array_append(v18, v13);
  }

  v98[0] = MEMORY[0x1E69E9820];
  v98[1] = 3221225472;
  v98[2] = __nw_http_proxy_server_start_block_invoke_77;
  v98[3] = &unk_1E6A3D958;
  v99 = v13;
  v100 = *(a1 + 32);
  v20 = v99;
  v21 = v98;
  if (v13)
  {
    *buf = MEMORY[0x1E69E9820];
    *&buf[8] = 3221225472;
    *&buf[16] = ___ZL55nw_http_proxy_connection_pair_set_state_changed_handlerP40NWConcrete_nw_http_proxy_connection_pairU13block_pointerFv21nw_connection_state_tPU22objcproto11OS_nw_error8NSObjectE_block_invoke;
    v104 = &unk_1E6A3D710;
    v105 = v20;
    v106 = v21;
    v22 = _Block_copy(buf);
    os_unfair_lock_lock(v20 + 2);
    v22[2](v22);
    os_unfair_lock_unlock(v20 + 2);

    goto LABEL_17;
  }

  v43 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_http_proxy_connection_pair_set_state_changed_handler";
  v44 = _os_log_send_and_compose_impl();

  v108[0] = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v44, v108, &type))
  {
    if (v108[0] == 17)
    {
      v45 = __nwlog_obj();
      v46 = v108[0];
      if (os_log_type_enabled(v45, v108[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_connection_pair_set_state_changed_handler";
        _os_log_impl(&dword_181A37000, v45, v46, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (type == OS_LOG_TYPE_INFO)
    {
      v67 = __nw_create_backtrace_string();
      v45 = __nwlog_obj();
      v68 = v108[0];
      v69 = os_log_type_enabled(v45, v108[0]);
      if (v67)
      {
        if (v69)
        {
          *buf = 136446466;
          *&buf[4] = "nw_http_proxy_connection_pair_set_state_changed_handler";
          *&buf[12] = 2082;
          *&buf[14] = v67;
          _os_log_impl(&dword_181A37000, v45, v68, "%{public}s called with null pair, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v67);
        goto LABEL_140;
      }

      if (v69)
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_connection_pair_set_state_changed_handler";
        _os_log_impl(&dword_181A37000, v45, v68, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v45 = __nwlog_obj();
      v85 = v108[0];
      if (os_log_type_enabled(v45, v108[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_connection_pair_set_state_changed_handler";
        _os_log_impl(&dword_181A37000, v45, v85, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_140:
  if (v44)
  {
    free(v44);
  }

LABEL_17:
  v23 = v13 == 0;

  v24 = *(*(a1 + 32) + 56);
  v25 = v20;
  v26 = v24;
  if (v23)
  {
    v47 = __nwlog_obj();
    *v108 = 136446210;
    *&v108[4] = "nw_http_proxy_connection_pair_set_outbound_connection_handler";
    v48 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v101 = 0;
    if (!__nwlog_fault(v48, &type, &v101))
    {
      goto LABEL_145;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v49 = __nwlog_obj();
      v50 = type;
      if (os_log_type_enabled(v49, type))
      {
        *v108 = 136446210;
        *&v108[4] = "nw_http_proxy_connection_pair_set_outbound_connection_handler";
        _os_log_impl(&dword_181A37000, v49, v50, "%{public}s called with null pair", v108, 0xCu);
      }
    }

    else if (v101 == 1)
    {
      v70 = __nw_create_backtrace_string();
      v49 = __nwlog_obj();
      v71 = type;
      v72 = os_log_type_enabled(v49, type);
      if (v70)
      {
        if (v72)
        {
          *v108 = 136446466;
          *&v108[4] = "nw_http_proxy_connection_pair_set_outbound_connection_handler";
          *&v108[12] = 2082;
          *&v108[14] = v70;
          _os_log_impl(&dword_181A37000, v49, v71, "%{public}s called with null pair, dumping backtrace:%{public}s", v108, 0x16u);
        }

        free(v70);
LABEL_145:
        if (v48)
        {
          free(v48);
        }

        v91 = __nwlog_obj();
        *v108 = 136446210;
        *&v108[4] = "nw_http_proxy_connection_pair_start";
        v54 = _os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v101 = 0;
        if (__nwlog_fault(v54, &type, &v101))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v55 = __nwlog_obj();
            v92 = type;
            if (os_log_type_enabled(v55, type))
            {
              *v108 = 136446210;
              *&v108[4] = "nw_http_proxy_connection_pair_start";
              _os_log_impl(&dword_181A37000, v55, v92, "%{public}s called with null pair", v108, 0xCu);
            }

            goto LABEL_176;
          }

          if (v101 != 1)
          {
            v55 = __nwlog_obj();
            v96 = type;
            if (os_log_type_enabled(v55, type))
            {
              *v108 = 136446210;
              *&v108[4] = "nw_http_proxy_connection_pair_start";
              _os_log_impl(&dword_181A37000, v55, v96, "%{public}s called with null pair, backtrace limit exceeded", v108, 0xCu);
            }

            goto LABEL_176;
          }

          v93 = __nw_create_backtrace_string();
          v55 = __nwlog_obj();
          v94 = type;
          v95 = os_log_type_enabled(v55, type);
          if (!v93)
          {
            if (v95)
            {
              *v108 = 136446210;
              *&v108[4] = "nw_http_proxy_connection_pair_start";
              _os_log_impl(&dword_181A37000, v55, v94, "%{public}s called with null pair, no backtrace", v108, 0xCu);
            }

            goto LABEL_176;
          }

          if (v95)
          {
            *v108 = 136446466;
            *&v108[4] = "nw_http_proxy_connection_pair_start";
            *&v108[12] = 2082;
            *&v108[14] = v93;
            _os_log_impl(&dword_181A37000, v55, v94, "%{public}s called with null pair, dumping backtrace:%{public}s", v108, 0x16u);
          }

          free(v93);
        }

LABEL_177:
        if (!v54)
        {
          goto LABEL_21;
        }

LABEL_178:
        free(v54);
        goto LABEL_21;
      }

      if (v72)
      {
        *v108 = 136446210;
        *&v108[4] = "nw_http_proxy_connection_pair_set_outbound_connection_handler";
        _os_log_impl(&dword_181A37000, v49, v71, "%{public}s called with null pair, no backtrace", v108, 0xCu);
      }
    }

    else
    {
      v49 = __nwlog_obj();
      v86 = type;
      if (os_log_type_enabled(v49, type))
      {
        *v108 = 136446210;
        *&v108[4] = "nw_http_proxy_connection_pair_set_outbound_connection_handler";
        _os_log_impl(&dword_181A37000, v49, v86, "%{public}s called with null pair, backtrace limit exceeded", v108, 0xCu);
      }
    }

    goto LABEL_145;
  }

  *buf = MEMORY[0x1E69E9820];
  *&buf[8] = 3221225472;
  *&buf[16] = ___ZL61nw_http_proxy_connection_pair_set_outbound_connection_handlerP40NWConcrete_nw_http_proxy_connection_pairU13block_pointerFvPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU29objcproto18OS_nw_http_requestS1_U13block_pointerFvS3_S5_PU30objcproto19OS_nw_http_responseS1_PU27objcproto16OS_dispatch_dataS1_EE_block_invoke;
  v104 = &unk_1E6A3D710;
  v27 = v25;
  v105 = v27;
  v28 = v26;
  v106 = v28;
  v29 = _Block_copy(buf);
  os_unfair_lock_lock(v25 + 2);
  v29[2](v29);
  os_unfair_lock_unlock(v25 + 2);

  v30 = v27;
  v31 = *&v30[8]._os_unfair_lock_opaque;
  if (!v31)
  {
    v53 = __nwlog_obj();
    *v108 = 136446210;
    *&v108[4] = "nw_http_proxy_connection_pair_start";
    v54 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v101 = 0;
    if (!__nwlog_fault(v54, &type, &v101))
    {
      goto LABEL_177;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v55 = __nwlog_obj();
      v56 = type;
      if (os_log_type_enabled(v55, type))
      {
        *v108 = 136446210;
        *&v108[4] = "nw_http_proxy_connection_pair_start";
        _os_log_impl(&dword_181A37000, v55, v56, "%{public}s called with null pair->inbound_connection", v108, 0xCu);
      }

      goto LABEL_176;
    }

    if (v101 != 1)
    {
      v55 = __nwlog_obj();
      v88 = type;
      if (os_log_type_enabled(v55, type))
      {
        *v108 = 136446210;
        *&v108[4] = "nw_http_proxy_connection_pair_start";
        _os_log_impl(&dword_181A37000, v55, v88, "%{public}s called with null pair->inbound_connection, backtrace limit exceeded", v108, 0xCu);
      }

      goto LABEL_176;
    }

    v76 = __nw_create_backtrace_string();
    v55 = __nwlog_obj();
    v77 = type;
    v78 = os_log_type_enabled(v55, type);
    if (!v76)
    {
      if (v78)
      {
        *v108 = 136446210;
        *&v108[4] = "nw_http_proxy_connection_pair_start";
        _os_log_impl(&dword_181A37000, v55, v77, "%{public}s called with null pair->inbound_connection, no backtrace", v108, 0xCu);
      }

      goto LABEL_176;
    }

    if (v78)
    {
      *v108 = 136446466;
      *&v108[4] = "nw_http_proxy_connection_pair_start";
      *&v108[12] = 2082;
      *&v108[14] = v76;
      _os_log_impl(&dword_181A37000, v55, v77, "%{public}s called with null pair->inbound_connection, dumping backtrace:%{public}s", v108, 0x16u);
    }

    goto LABEL_102;
  }

  v32 = *&v30[4]._os_unfair_lock_opaque;
  if (!v32)
  {
    v59 = __nwlog_obj();
    *v108 = 136446210;
    *&v108[4] = "nw_http_proxy_connection_pair_start";
    v54 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v101 = 0;
    if (!__nwlog_fault(v54, &type, &v101))
    {
      goto LABEL_177;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v55 = __nwlog_obj();
      v60 = type;
      if (os_log_type_enabled(v55, type))
      {
        *v108 = 136446210;
        *&v108[4] = "nw_http_proxy_connection_pair_start";
        _os_log_impl(&dword_181A37000, v55, v60, "%{public}s called with null pair->queue", v108, 0xCu);
      }

LABEL_176:

      goto LABEL_177;
    }

    if (v101 != 1)
    {
      v55 = __nwlog_obj();
      v90 = type;
      if (os_log_type_enabled(v55, type))
      {
        *v108 = 136446210;
        *&v108[4] = "nw_http_proxy_connection_pair_start";
        _os_log_impl(&dword_181A37000, v55, v90, "%{public}s called with null pair->queue, backtrace limit exceeded", v108, 0xCu);
      }

      goto LABEL_176;
    }

    v76 = __nw_create_backtrace_string();
    v55 = __nwlog_obj();
    v81 = type;
    v82 = os_log_type_enabled(v55, type);
    if (!v76)
    {
      if (v82)
      {
        *v108 = 136446210;
        *&v108[4] = "nw_http_proxy_connection_pair_start";
        _os_log_impl(&dword_181A37000, v55, v81, "%{public}s called with null pair->queue, no backtrace", v108, 0xCu);
      }

      goto LABEL_176;
    }

    if (v82)
    {
      *v108 = 136446466;
      *&v108[4] = "nw_http_proxy_connection_pair_start";
      *&v108[12] = 2082;
      *&v108[14] = v76;
      _os_log_impl(&dword_181A37000, v55, v81, "%{public}s called with null pair->queue, dumping backtrace:%{public}s", v108, 0x16u);
    }

LABEL_102:

    free(v76);
    if (!v54)
    {
      goto LABEL_21;
    }

    goto LABEL_178;
  }

  nw_connection_set_queue(v31, v32);
  v33 = *&v30[8]._os_unfair_lock_opaque;
  *buf = MEMORY[0x1E69E9820];
  *&buf[8] = 3221225472;
  *&buf[16] = ___ZL35nw_http_proxy_connection_pair_startP40NWConcrete_nw_http_proxy_connection_pair_block_invoke;
  v104 = &unk_1E6A3D820;
  v34 = v30;
  v105 = v34;
  nw_connection_set_state_changed_handler(v33, buf);
  nw_http_proxy_connection_pair_read_inbound(v34);
  nw_connection_start(*&v30[8]._os_unfair_lock_opaque);

LABEL_21:
}

void ___ZL40nw_http_proxy_connection_pair_set_queuesP40NWConcrete_nw_http_proxy_connection_pairPU28objcproto17OS_dispatch_queue8NSObjectS3__block_invoke(uint64_t a1)
{
  objc_storeStrong((*(a1 + 32) + 16), *(a1 + 40));
  v2 = *(a1 + 48);
  v3 = (*(a1 + 32) + 24);

  objc_storeStrong(v3, v2);
}

void __nw_http_proxy_server_start_block_invoke_77(uint64_t a1, unsigned int a2)
{
  v13 = *MEMORY[0x1E69E9840];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    if (a2 > 5)
    {
      v5 = "unknown";
    }

    else
    {
      v5 = off_1E6A2F020[a2];
    }

    v9 = 136446466;
    v10 = "nw_http_proxy_server_start_block_invoke";
    v11 = 2080;
    v12 = v5;
    _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_INFO, "%{public}s proxy connection pair changed state to %s", &v9, 0x16u);
  }

  if (a2 == 5)
  {
    nw_array_remove_object(*(*(a1 + 40) + 64), *(a1 + 32));
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      count = *(*(a1 + 40) + 64);
      if (count)
      {
        count = _nw_array_get_count(count);
      }

      v9 = 136446466;
      v10 = "nw_http_proxy_server_start_block_invoke";
      v11 = 2048;
      v12 = count;
      _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_INFO, "%{public}s proxy connection pair count is now %zu", &v9, 0x16u);
    }

    v8 = *(a1 + 40);
    if (*(v8 + 64))
    {
      if (_nw_array_get_count(*(v8 + 64)))
      {
        return;
      }

      v8 = *(a1 + 40);
    }

    if (!*(v8 + 24))
    {
      nw_http_proxy_server_report_state_change(v8, 4, 0);
    }
  }

  else if (a2 == 4)
  {
    nw_http_proxy_connection_pair_cancel(*(a1 + 32));
  }
}

void ___ZL55nw_http_proxy_connection_pair_set_state_changed_handlerP40NWConcrete_nw_http_proxy_connection_pairU13block_pointerFv21nw_connection_state_tPU22objcproto11OS_nw_error8NSObjectE_block_invoke(uint64_t a1)
{
  v2 = _Block_copy(*(a1 + 40));
  v3 = *(a1 + 32);
  v4 = *(v3 + 48);
  *(v3 + 48) = v2;
}

void ___ZL61nw_http_proxy_connection_pair_set_outbound_connection_handlerP40NWConcrete_nw_http_proxy_connection_pairU13block_pointerFvPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU29objcproto18OS_nw_http_requestS1_U13block_pointerFvS3_S5_PU30objcproto19OS_nw_http_responseS1_PU27objcproto16OS_dispatch_dataS1_EE_block_invoke(uint64_t a1)
{
  v2 = _Block_copy(*(a1 + 40));
  v3 = *(a1 + 32);
  v4 = *(v3 + 56);
  *(v3 + 56) = v2;
}

void ___ZL35nw_http_proxy_connection_pair_startP40NWConcrete_nw_http_proxy_connection_pair_block_invoke(uint64_t a1, unsigned int a2, void *a3)
{
  v19 = *MEMORY[0x1E69E9840];
  v5 = a3;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = gLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    if (a2 > 5)
    {
      v7 = "unknown";
    }

    else
    {
      v7 = off_1E6A2F020[a2];
    }

    v8 = *(*(a1 + 32) + 32);
    *buf = 136446722;
    *&buf[4] = "nw_http_proxy_connection_pair_start_block_invoke";
    *&buf[12] = 2112;
    *&buf[14] = v8;
    *&buf[22] = 2080;
    v16 = v7;
    _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_INFO, "%{public}s inbound connection from %@ has transitioned to %s", buf, 0x20u);
  }

  if (a2 == 5)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x3032000000;
    v16 = __Block_byref_object_copy__66298;
    v17 = __Block_byref_object_dispose__66299;
    v18 = 0;
    v9 = *(a1 + 32);
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = ___ZL35nw_http_proxy_connection_pair_startP40NWConcrete_nw_http_proxy_connection_pair_block_invoke_100;
    v12[3] = &unk_1E6A3D738;
    v13 = v9;
    v14 = buf;
    v10 = _Block_copy(v12);
    os_unfair_lock_lock(v9 + 2);
    v10[2](v10);
    os_unfair_lock_unlock(v9 + 2);

    v11 = *(*&buf[8] + 40);
    if (v11)
    {
      (*(v11 + 16))(v11, 5, v5);
    }

    _Block_object_dispose(buf, 8);
  }

  else if (a2 == 4)
  {
    nw_connection_cancel(*(*(a1 + 32) + 32));
  }
}

void sub_1828F8630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);

  _Unwind_Resume(a1);
}

void nw_http_proxy_connection_pair_read_inbound(NWConcrete_nw_http_proxy_connection_pair *a1)
{
  v29 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_http_proxy_connection_pair_read_inbound";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
    {
      goto LABEL_41;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v26 = "nw_http_proxy_connection_pair_read_inbound";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v23 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v26 = "nw_http_proxy_connection_pair_read_inbound";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null pair, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v8)
        {
          goto LABEL_7;
        }

LABEL_42:
        free(v8);
        goto LABEL_7;
      }

      if (v15)
      {
        *buf = 136446210;
        v26 = "nw_http_proxy_connection_pair_read_inbound";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v26 = "nw_http_proxy_connection_pair_read_inbound";
        _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_40:

    goto LABEL_41;
  }

  v3 = *(v1 + 4);
  if (v3)
  {
    v4 = *(v1 + 5);
    v5 = v4 != 0;
    if (v4)
    {
      v6 = -1;
    }

    else
    {
      v6 = 0;
    }

    v21[0] = MEMORY[0x1E69E9820];
    v21[1] = 3221225472;
    v21[2] = ___ZL42nw_http_proxy_connection_pair_read_inboundP40NWConcrete_nw_http_proxy_connection_pair_block_invoke;
    v21[3] = &unk_1E6A39638;
    v22 = v1;
    nw_connection_receive_internal(v3, 0, v5, v6, v21);

    goto LABEL_7;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v26 = "nw_http_proxy_connection_pair_read_inbound";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v8, &type, &v23))
  {
    goto LABEL_41;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v26 = "nw_http_proxy_connection_pair_read_inbound";
      _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null pair->inbound_connection", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v23 != 1)
  {
    v9 = __nwlog_obj();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v26 = "nw_http_proxy_connection_pair_read_inbound";
      _os_log_impl(&dword_181A37000, v9, v20, "%{public}s called with null pair->inbound_connection, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_40;
  }

  v16 = __nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *buf = 136446210;
      v26 = "nw_http_proxy_connection_pair_read_inbound";
      _os_log_impl(&dword_181A37000, v9, v17, "%{public}s called with null pair->inbound_connection, no backtrace", buf, 0xCu);
    }

    goto LABEL_40;
  }

  if (v18)
  {
    *buf = 136446466;
    v26 = "nw_http_proxy_connection_pair_read_inbound";
    v27 = 2082;
    v28 = v16;
    _os_log_impl(&dword_181A37000, v9, v17, "%{public}s called with null pair->inbound_connection, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
  {
    goto LABEL_42;
  }

LABEL_7:
}

void ___ZL42nw_http_proxy_connection_pair_read_inboundP40NWConcrete_nw_http_proxy_connection_pair_block_invoke(uint64_t a1, void *a2, void *a3, BOOL a4, void *a5)
{
  v99 = *MEMORY[0x1E69E9840];
  v9 = a2;
  v10 = a3;
  v11 = a5;
  if (!v11)
  {
    v12 = *(a1 + 32);
    if (*(v12 + 32))
    {
      v13 = *(v12 + 40);
      if (v13)
      {
        completion[0] = MEMORY[0x1E69E9820];
        completion[1] = 3221225472;
        completion[2] = ___ZL42nw_http_proxy_connection_pair_read_inboundP40NWConcrete_nw_http_proxy_connection_pair_block_invoke_101;
        completion[3] = &unk_1E6A39610;
        v45 = a4;
        v44 = v12;
        nw_connection_send(v13, v9, &__block_literal_global_8_44676, a4, completion);
        v14 = v44;
LABEL_5:

        goto LABEL_6;
      }

      if (*(v12 + 64) == 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *buf = 136446210;
          *&buf[4] = "nw_http_proxy_connection_pair_read_inbound_block_invoke";
          _os_log_impl(&dword_181A37000, v14, OS_LOG_TYPE_ERROR, "%{public}s received a message on inbound connection after outbound connection was cancelled, dropping", buf, 0xCu);
        }

        goto LABEL_5;
      }

      *(v12 + 64) = 1;
      if (v10)
      {
        if (nw_protocol_copy_http_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_16_75909);
        }

        v15 = nw_protocol_copy_http_definition_http_definition;
        v14 = nw_content_context_copy_protocol_metadata(v10, v15);

        if (v14)
        {
          v16 = nw_http_metadata_copy_request(v14);
          v17 = *(a1 + 32);
          v18 = v16;
          v19 = v18;
          if (v17)
          {
            if (v18)
            {
              if (!v17[4])
              {
LABEL_31:

                goto LABEL_5;
              }

              v86 = 0;
              v87 = &v86;
              v88 = 0x2020000000;
              v89 = 0;
              *type = MEMORY[0x1E69E9820];
              v81 = 3221225472;
              v82 = ___ZL55nw_http_proxy_connection_pair_setup_outbound_connectionP40NWConcrete_nw_http_proxy_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke;
              v83 = &unk_1E6A39660;
              v85 = &v86;
              v20 = v17;
              v84 = v20;
              v21 = v19;
              v22 = type;
              _nw_http_request_access_method(v21, v22);

              v74 = 0;
              v75 = &v74;
              v76 = 0x3032000000;
              v77 = __Block_byref_object_copy__105;
              v78 = __Block_byref_object_dispose__106;
              secure_tcp = nw_parameters_create_secure_tcp(&__block_literal_global_19409, &__block_literal_global_2);
              nw_parameters_set_proxy_applied(v75[5]);
              v68 = 0;
              v69 = &v68;
              v70 = 0x3032000000;
              v71 = __Block_byref_object_copy__105;
              v72 = __Block_byref_object_dispose__106;
              v73 = 0;
              v62 = 0;
              v63 = &v62;
              v64 = 0x3032000000;
              v65 = __Block_byref_object_copy__105;
              v66 = __Block_byref_object_dispose__106;
              if (*(v87 + 24) == 1)
              {
                well_known = _nw_http_response_create_well_known(200);
              }

              else
              {
                well_known = _nw_http_response_create_well_known(405);
              }

              v25 = 0;
              v67 = well_known;
              v56 = 0;
              v57 = &v56;
              v58 = 0x3032000000;
              v59 = __Block_byref_object_copy__105;
              v60 = __Block_byref_object_dispose__106;
              v61 = 0;
              if (*(v87 + 24) == 1)
              {
                v55[0] = MEMORY[0x1E69E9820];
                v55[1] = 3221225472;
                v55[2] = ___ZL55nw_http_proxy_connection_pair_setup_outbound_connectionP40NWConcrete_nw_http_proxy_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke_107;
                v55[3] = &unk_1E6A3AA78;
                v55[4] = &v68;
                nw_http_request_access_path(v21, v55);
                if (!v69[5])
                {
                  nw_connection_cancel(v17[4]);
                  goto LABEL_30;
                }

                v49 = 0;
                v50 = &v49;
                v51 = 0x3032000000;
                v52 = __Block_byref_object_copy__66298;
                v53 = __Block_byref_object_dispose__66299;
                v54 = 0;
                aBlock[0] = MEMORY[0x1E69E9820];
                aBlock[1] = 3221225472;
                aBlock[2] = ___ZL55nw_http_proxy_connection_pair_setup_outbound_connectionP40NWConcrete_nw_http_proxy_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke_2;
                aBlock[3] = &unk_1E6A3D738;
                v26 = v20;
                v47 = v26;
                v48 = &v49;
                v27 = _Block_copy(aBlock);
                os_unfair_lock_lock(v20 + 2);
                v27[2](v27);
                os_unfair_lock_unlock(v20 + 2);

                if (v50[5])
                {
                  v28 = *&v26[6]._os_unfair_lock_opaque;
                  *buf = MEMORY[0x1E69E9820];
                  *&buf[8] = 3221225472;
                  *&buf[16] = ___ZL55nw_http_proxy_connection_pair_setup_outbound_connectionP40NWConcrete_nw_http_proxy_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke_3;
                  v91 = &unk_1E6A396D8;
                  v94 = &v49;
                  v95 = &v68;
                  v96 = &v74;
                  v92 = v21;
                  v97 = &v62;
                  v98 = &v56;
                  v93 = v26;
                  dispatch_async(v28, buf);

                  _Block_object_dispose(&v49, 8);
LABEL_30:
                  _Block_object_dispose(&v56, 8);

                  _Block_object_dispose(&v62, 8);
                  _Block_object_dispose(&v68, 8);

                  _Block_object_dispose(&v74, 8);
                  _Block_object_dispose(&v86, 8);
                  goto LABEL_31;
                }

                _Block_object_dispose(&v49, 8);
                v25 = v57[5];
              }

              nw_http_proxy_connection_pair_setup_outbound_connection_inner(v20, v69[5], v75[5], v63[5], v25);
              goto LABEL_30;
            }

            v33 = __nwlog_obj();
            *buf = 136446210;
            *&buf[4] = "nw_http_proxy_connection_pair_setup_outbound_connection";
            v30 = _os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v74) = 0;
            if (!__nwlog_fault(v30, type, &v74))
            {
              goto LABEL_65;
            }

            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v31 = __nwlog_obj();
              v34 = type[0];
              if (os_log_type_enabled(v31, type[0]))
              {
                *buf = 136446210;
                *&buf[4] = "nw_http_proxy_connection_pair_setup_outbound_connection";
                _os_log_impl(&dword_181A37000, v31, v34, "%{public}s called with null request", buf, 0xCu);
              }
            }

            else if (v74 == 1)
            {
              backtrace_string = __nw_create_backtrace_string();
              v31 = __nwlog_obj();
              v42 = type[0];
              v38 = os_log_type_enabled(v31, type[0]);
              if (backtrace_string)
              {
                if (v38)
                {
                  *buf = 136446466;
                  *&buf[4] = "nw_http_proxy_connection_pair_setup_outbound_connection";
                  *&buf[12] = 2082;
                  *&buf[14] = backtrace_string;
                  _os_log_impl(&dword_181A37000, v31, v42, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(backtrace_string);
                if (!v30)
                {
                  goto LABEL_31;
                }

                goto LABEL_66;
              }

              if (v38)
              {
                *buf = 136446210;
                *&buf[4] = "nw_http_proxy_connection_pair_setup_outbound_connection";
                _os_log_impl(&dword_181A37000, v31, v42, "%{public}s called with null request, no backtrace", buf, 0xCu);
              }
            }

            else
            {
              v31 = __nwlog_obj();
              v40 = type[0];
              if (os_log_type_enabled(v31, type[0]))
              {
                *buf = 136446210;
                *&buf[4] = "nw_http_proxy_connection_pair_setup_outbound_connection";
                _os_log_impl(&dword_181A37000, v31, v40, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }

          else
          {
            v29 = __nwlog_obj();
            *buf = 136446210;
            *&buf[4] = "nw_http_proxy_connection_pair_setup_outbound_connection";
            v30 = _os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v74) = 0;
            if (!__nwlog_fault(v30, type, &v74))
            {
              goto LABEL_65;
            }

            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v31 = __nwlog_obj();
              v32 = type[0];
              if (os_log_type_enabled(v31, type[0]))
              {
                *buf = 136446210;
                *&buf[4] = "nw_http_proxy_connection_pair_setup_outbound_connection";
                _os_log_impl(&dword_181A37000, v31, v32, "%{public}s called with null pair", buf, 0xCu);
              }
            }

            else if (v74 == 1)
            {
              v35 = __nw_create_backtrace_string();
              v31 = __nwlog_obj();
              v41 = type[0];
              v36 = os_log_type_enabled(v31, type[0]);
              if (v35)
              {
                if (v36)
                {
                  *buf = 136446466;
                  *&buf[4] = "nw_http_proxy_connection_pair_setup_outbound_connection";
                  *&buf[12] = 2082;
                  *&buf[14] = v35;
                  _os_log_impl(&dword_181A37000, v31, v41, "%{public}s called with null pair, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v35);
LABEL_65:
                if (!v30)
                {
                  goto LABEL_31;
                }

LABEL_66:
                free(v30);
                goto LABEL_31;
              }

              if (v36)
              {
                *buf = 136446210;
                *&buf[4] = "nw_http_proxy_connection_pair_setup_outbound_connection";
                _os_log_impl(&dword_181A37000, v31, v41, "%{public}s called with null pair, no backtrace", buf, 0xCu);
              }
            }

            else
            {
              v31 = __nwlog_obj();
              v39 = type[0];
              if (os_log_type_enabled(v31, type[0]))
              {
                *buf = 136446210;
                *&buf[4] = "nw_http_proxy_connection_pair_setup_outbound_connection";
                _os_log_impl(&dword_181A37000, v31, v39, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }

          goto LABEL_65;
        }
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = gLogObj;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_connection_pair_read_inbound_block_invoke";
        _os_log_impl(&dword_181A37000, v24, OS_LOG_TYPE_ERROR, "%{public}s expecting to receive non-nil metadata. Unable to create outbound connection", buf, 0xCu);
      }

      nw_connection_cancel(*(*(a1 + 32) + 32));
    }
  }

LABEL_6:
}

void sub_1828F9740(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, id a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, id a42, char a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, id a48, char a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, id a54, char a55, uint64_t a56, uint64_t a57, uint64_t a58, uint64_t a59, id a60, uint64_t a61, uint64_t a62, uint64_t a63)
{
  _Block_object_dispose(&a26, 8);

  _Block_object_dispose(&a37, 8);
  _Block_object_dispose(&a43, 8);

  _Block_object_dispose(&a49, 8);
  _Block_object_dispose(&a55, 8);

  _Block_object_dispose((v71 - 240), 8);
  _Unwind_Resume(a1);
}

void ___ZL55nw_http_proxy_connection_pair_setup_outbound_connectionP40NWConcrete_nw_http_proxy_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke(uint64_t a1, char *__s1)
{
  v12 = *MEMORY[0x1E69E9840];
  if (!strcmp(__s1, "CONNECT"))
  {
    *(*(*(a1 + 40) + 8) + 24) = 1;
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *(*(a1 + 32) + 32);
      v6 = 136446722;
      v7 = "nw_http_proxy_connection_pair_setup_outbound_connection_block_invoke";
      v8 = 2114;
      v9 = v5;
      v10 = 2080;
      v11 = __s1;
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ received method %s, expected CONNECT", &v6, 0x20u);
    }
  }
}

uint64_t __Block_byref_object_copy__105(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

void ___ZL55nw_http_proxy_connection_pair_setup_outbound_connectionP40NWConcrete_nw_http_proxy_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke_107(uint64_t a1, const char *a2)
{
  if (a2)
  {
    url = 0;
    asprintf(&url, "tcp://%s", a2);
    v3 = nw_endpoint_create_url(url);
    v4 = nw_endpoint_copy_host_port_endpoint_for_url(v3);
    v5 = *(*(a1 + 32) + 8);
    v6 = *(v5 + 40);
    *(v5 + 40) = v4;

    if (url)
    {
      free(url);
    }
  }
}

void *__Block_byref_object_copy__66298(uint64_t a1, uint64_t a2)
{
  result = _Block_copy(*(a2 + 40));
  *(a1 + 40) = result;
  return result;
}

void ___ZL55nw_http_proxy_connection_pair_setup_outbound_connectionP40NWConcrete_nw_http_proxy_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke_2(uint64_t a1)
{
  v2 = *(*(a1 + 32) + 56);
  if (v2)
  {
    v3 = _Block_copy(v2);
    v4 = *(*(a1 + 40) + 8);
    v5 = *(v4 + 40);
    *(v4 + 40) = v3;
  }
}

void ___ZL55nw_http_proxy_connection_pair_setup_outbound_connectionP40NWConcrete_nw_http_proxy_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke_3(uint64_t a1)
{
  v1 = *(a1 + 56);
  v2 = *(*(*(a1 + 48) + 8) + 40);
  v3 = *(*(v1 + 8) + 40);
  v4 = *(a1 + 32);
  v7[0] = MEMORY[0x1E69E9820];
  v5 = *(a1 + 64);
  v6 = *(*(*(a1 + 64) + 8) + 40);
  v7[1] = 3221225472;
  v7[2] = ___ZL55nw_http_proxy_connection_pair_setup_outbound_connectionP40NWConcrete_nw_http_proxy_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke_4;
  v7[3] = &unk_1E6A396B0;
  v9 = v1;
  v10 = v5;
  v11 = *(a1 + 80);
  v8 = *(a1 + 40);
  (*(v2 + 16))(v2, v3, v6, v4, v7);
}

void nw_http_proxy_connection_pair_setup_outbound_connection_inner(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  v65 = *MEMORY[0x1E69E9840];
  v9 = a1;
  v10 = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  if (!v9)
  {
    v28 = __nwlog_obj();
    *buf = 136446210;
    v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
    v29 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v29, &type, &v57))
    {
      goto LABEL_80;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *buf = 136446210;
        v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
        _os_log_impl(&dword_181A37000, v30, v31, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v57 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v39 = type;
      v40 = os_log_type_enabled(v30, type);
      if (backtrace_string)
      {
        if (v40)
        {
          *buf = 136446466;
          v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
          v61 = 2082;
          v62 = backtrace_string;
          _os_log_impl(&dword_181A37000, v30, v39, "%{public}s called with null pair, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_80:
        if (!v29)
        {
          goto LABEL_14;
        }

LABEL_81:
        free(v29);
        goto LABEL_14;
      }

      if (v40)
      {
        *buf = 136446210;
        v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
        _os_log_impl(&dword_181A37000, v30, v39, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v30 = __nwlog_obj();
      v48 = type;
      if (os_log_type_enabled(v30, type))
      {
        *buf = 136446210;
        v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
        _os_log_impl(&dword_181A37000, v30, v48, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_79:

    goto LABEL_80;
  }

  if (!v10)
  {
    v32 = __nwlog_obj();
    *buf = 136446210;
    v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
    v29 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v29, &type, &v57))
    {
      goto LABEL_80;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v30 = __nwlog_obj();
      v33 = type;
      if (os_log_type_enabled(v30, type))
      {
        *buf = 136446210;
        v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
        _os_log_impl(&dword_181A37000, v30, v33, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_79;
    }

    if (v57 != 1)
    {
      v30 = __nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v30, type))
      {
        *buf = 136446210;
        v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
        _os_log_impl(&dword_181A37000, v30, v49, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_79;
    }

    v41 = __nw_create_backtrace_string();
    v30 = __nwlog_obj();
    v42 = type;
    v43 = os_log_type_enabled(v30, type);
    if (!v41)
    {
      if (v43)
      {
        *buf = 136446210;
        v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
        _os_log_impl(&dword_181A37000, v30, v42, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_79;
    }

    if (v43)
    {
      *buf = 136446466;
      v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
      v61 = 2082;
      v62 = v41;
      _os_log_impl(&dword_181A37000, v30, v42, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_54;
  }

  if (!v11)
  {
    v34 = __nwlog_obj();
    *buf = 136446210;
    v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
    v29 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v29, &type, &v57))
    {
      goto LABEL_80;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v30 = __nwlog_obj();
      v35 = type;
      if (os_log_type_enabled(v30, type))
      {
        *buf = 136446210;
        v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
        _os_log_impl(&dword_181A37000, v30, v35, "%{public}s called with null parameters", buf, 0xCu);
      }

      goto LABEL_79;
    }

    if (v57 != 1)
    {
      v30 = __nwlog_obj();
      v50 = type;
      if (os_log_type_enabled(v30, type))
      {
        *buf = 136446210;
        v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
        _os_log_impl(&dword_181A37000, v30, v50, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_79;
    }

    v41 = __nw_create_backtrace_string();
    v30 = __nwlog_obj();
    v44 = type;
    v45 = os_log_type_enabled(v30, type);
    if (!v41)
    {
      if (v45)
      {
        *buf = 136446210;
        v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
        _os_log_impl(&dword_181A37000, v30, v44, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }

      goto LABEL_79;
    }

    if (v45)
    {
      *buf = 136446466;
      v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
      v61 = 2082;
      v62 = v41;
      _os_log_impl(&dword_181A37000, v30, v44, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_54;
  }

  if (!v12)
  {
    v36 = __nwlog_obj();
    *buf = 136446210;
    v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
    v29 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v29, &type, &v57))
    {
      goto LABEL_80;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v30 = __nwlog_obj();
      v37 = type;
      if (os_log_type_enabled(v30, type))
      {
        *buf = 136446210;
        v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
        _os_log_impl(&dword_181A37000, v30, v37, "%{public}s called with null response", buf, 0xCu);
      }

      goto LABEL_79;
    }

    if (v57 != 1)
    {
      v30 = __nwlog_obj();
      v51 = type;
      if (os_log_type_enabled(v30, type))
      {
        *buf = 136446210;
        v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
        _os_log_impl(&dword_181A37000, v30, v51, "%{public}s called with null response, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_79;
    }

    v41 = __nw_create_backtrace_string();
    v30 = __nwlog_obj();
    v46 = type;
    v47 = os_log_type_enabled(v30, type);
    if (!v41)
    {
      if (v47)
      {
        *buf = 136446210;
        v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
        _os_log_impl(&dword_181A37000, v30, v46, "%{public}s called with null response, no backtrace", buf, 0xCu);
      }

      goto LABEL_79;
    }

    if (v47)
    {
      *buf = 136446466;
      v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
      v61 = 2082;
      v62 = v41;
      _os_log_impl(&dword_181A37000, v30, v46, "%{public}s called with null response, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_54:

    free(v41);
    if (!v29)
    {
      goto LABEL_14;
    }

    goto LABEL_81;
  }

  if (v9[4])
  {
    v14 = nw_content_context_create("response");
    metadata_for_response = nw_http_create_metadata_for_response(v12);
    nw_content_context_set_metadata_for_protocol(v14, metadata_for_response);

    v16 = v9[4];
    completion[0] = MEMORY[0x1E69E9820];
    completion[1] = 3221225472;
    completion[2] = ___ZL61nw_http_proxy_connection_pair_setup_outbound_connection_innerP40NWConcrete_nw_http_proxy_connection_pairPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU30objcproto19OS_nw_http_responseS1_PU27objcproto16OS_dispatch_dataS1__block_invoke;
    completion[3] = &unk_1E6A3A558;
    v17 = v12;
    v55 = v17;
    v18 = v9;
    v56 = v18;
    nw_connection_send(v16, v13, v14, 1, completion);
    v19 = v17;
    LODWORD(v16) = _nw_http_response_get_status_code(v19);

    if (v16 == 200)
    {
      v20 = nw_connection_create(v10, v11);
      v21 = v18[5];
      v18[5] = v20;

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        v23 = v18[5];
        v24 = v9[4];
        *buf = 136446722;
        v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
        v61 = 2112;
        v62 = v23;
        v63 = 2112;
        v64 = v24;
        _os_log_impl(&dword_181A37000, v22, OS_LOG_TYPE_INFO, "%{public}s created new outbound connection %@ for inbound connection %@", buf, 0x20u);
      }

      nw_connection_set_queue(v18[5], v18[2]);
      v25 = v18[5];
      handler[0] = MEMORY[0x1E69E9820];
      handler[1] = 3221225472;
      handler[2] = ___ZL61nw_http_proxy_connection_pair_setup_outbound_connection_innerP40NWConcrete_nw_http_proxy_connection_pairPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU30objcproto19OS_nw_http_responseS1_PU27objcproto16OS_dispatch_dataS1__block_invoke_111;
      handler[3] = &unk_1E6A3D820;
      v26 = v18;
      v53 = v26;
      nw_connection_set_state_changed_handler(v25, handler);
      nw_http_proxy_connection_pair_read_outbound(v26);
      nw_connection_start(v18[5]);
      nw_http_proxy_connection_pair_read_inbound(v26);
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v27 = gLogObj;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v60 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner";
      _os_log_impl(&dword_181A37000, v27, OS_LOG_TYPE_ERROR, "%{public}s inbound connection was nil, cannot setup outbound connection", buf, 0xCu);
    }
  }

LABEL_14:
}

void ___ZL42nw_http_proxy_connection_pair_read_inboundP40NWConcrete_nw_http_proxy_connection_pair_block_invoke_101(uint64_t a1, void *a2)
{
  v9 = *MEMORY[0x1E69E9840];
  v3 = a2;
  if (v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136446466;
      v6 = "nw_http_proxy_connection_pair_read_inbound_block_invoke";
      v7 = 2112;
      v8 = v3;
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_ERROR, "%{public}s received error sending to outbound connection %@", &v5, 0x16u);
    }
  }

  if ((*(a1 + 40) & 1) == 0)
  {
    nw_http_proxy_connection_pair_read_inbound(*(a1 + 32));
  }
}

void ___ZL61nw_http_proxy_connection_pair_setup_outbound_connection_innerP40NWConcrete_nw_http_proxy_connection_pairPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU30objcproto19OS_nw_http_responseS1_PU27objcproto16OS_dispatch_dataS1__block_invoke(uint64_t a1, void *a2)
{
  v9 = *MEMORY[0x1E69E9840];
  v3 = a2;
  if (v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136446466;
      v6 = "nw_http_proxy_connection_pair_setup_outbound_connection_inner_block_invoke";
      v7 = 2112;
      v8 = v3;
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_ERROR, "%{public}s received error sending to inbound connection %@", &v5, 0x16u);
    }
  }

  if (nw_http_response_get_status_code(*(a1 + 32)) != 200)
  {
    nw_connection_cancel(*(*(a1 + 40) + 32));
  }
}

void ___ZL61nw_http_proxy_connection_pair_setup_outbound_connection_innerP40NWConcrete_nw_http_proxy_connection_pairPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU30objcproto19OS_nw_http_responseS1_PU27objcproto16OS_dispatch_dataS1__block_invoke_111(uint64_t a1, unsigned int a2, void *a3)
{
  v19 = *MEMORY[0x1E69E9840];
  v5 = a3;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = gLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    if (a2 > 5)
    {
      v7 = "unknown";
    }

    else
    {
      v7 = off_1E6A2F020[a2];
    }

    v8 = *(*(a1 + 32) + 40);
    *buf = 136446722;
    *&buf[4] = "nw_http_proxy_connection_pair_setup_outbound_connection_inner_block_invoke";
    *&buf[12] = 2112;
    *&buf[14] = v8;
    *&buf[22] = 2080;
    v16 = v7;
    _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_INFO, "%{public}s outbound connection %@ has transitioned to %s", buf, 0x20u);
  }

  if (a2 == 5)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x3032000000;
    v16 = __Block_byref_object_copy__66298;
    v17 = __Block_byref_object_dispose__66299;
    v18 = 0;
    v9 = *(a1 + 32);
    v12[0] = MEMORY[0x1E69E9820];
    v12[1] = 3221225472;
    v12[2] = ___ZL61nw_http_proxy_connection_pair_setup_outbound_connection_innerP40NWConcrete_nw_http_proxy_connection_pairPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU30objcproto19OS_nw_http_responseS1_PU27objcproto16OS_dispatch_dataS1__block_invoke_112;
    v12[3] = &unk_1E6A3D738;
    v13 = v9;
    v14 = buf;
    v10 = _Block_copy(v12);
    os_unfair_lock_lock(v9 + 2);
    v10[2](v10);
    os_unfair_lock_unlock(v9 + 2);

    v11 = *(*&buf[8] + 40);
    if (v11)
    {
      (*(v11 + 16))(v11, 5, v5);
    }

    _Block_object_dispose(buf, 8);
  }

  else if (a2 == 4)
  {
    nw_connection_cancel(*(*(a1 + 32) + 40));
  }
}

void sub_1828FAC48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);

  _Unwind_Resume(a1);
}

void nw_http_proxy_connection_pair_read_outbound(NWConcrete_nw_http_proxy_connection_pair *a1)
{
  v31 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v4 = __nwlog_obj();
    *buf = 136446210;
    v28 = "nw_http_proxy_connection_pair_read_outbound";
    v5 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v5, &type, &v25))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v28 = "nw_http_proxy_connection_pair_read_outbound";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v25 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v13 = type;
      v14 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v28 = "nw_http_proxy_connection_pair_read_outbound";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v13, "%{public}s called with null pair, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v5)
        {
          goto LABEL_5;
        }

LABEL_56:
        free(v5);
        goto LABEL_5;
      }

      if (v14)
      {
        *buf = 136446210;
        v28 = "nw_http_proxy_connection_pair_read_outbound";
        _os_log_impl(&dword_181A37000, v6, v13, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v28 = "nw_http_proxy_connection_pair_read_outbound";
        _os_log_impl(&dword_181A37000, v6, v20, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_54:

    goto LABEL_55;
  }

  if (!*(v1 + 4))
  {
    v8 = __nwlog_obj();
    *buf = 136446210;
    v28 = "nw_http_proxy_connection_pair_read_outbound";
    v5 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v5, &type, &v25))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v28 = "nw_http_proxy_connection_pair_read_outbound";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null pair->inbound_connection", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v25 != 1)
    {
      v6 = __nwlog_obj();
      v21 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v28 = "nw_http_proxy_connection_pair_read_outbound";
        _os_log_impl(&dword_181A37000, v6, v21, "%{public}s called with null pair->inbound_connection, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    v15 = __nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v16 = type;
    v17 = os_log_type_enabled(v6, type);
    if (!v15)
    {
      if (v17)
      {
        *buf = 136446210;
        v28 = "nw_http_proxy_connection_pair_read_outbound";
        _os_log_impl(&dword_181A37000, v6, v16, "%{public}s called with null pair->inbound_connection, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v17)
    {
      *buf = 136446466;
      v28 = "nw_http_proxy_connection_pair_read_outbound";
      v29 = 2082;
      v30 = v15;
      _os_log_impl(&dword_181A37000, v6, v16, "%{public}s called with null pair->inbound_connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_35;
  }

  v3 = *(v1 + 5);
  if (!v3)
  {
    v10 = __nwlog_obj();
    *buf = 136446210;
    v28 = "nw_http_proxy_connection_pair_read_outbound";
    v5 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v5, &type, &v25))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v28 = "nw_http_proxy_connection_pair_read_outbound";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null pair->outbound_connection", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v25 != 1)
    {
      v6 = __nwlog_obj();
      v22 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v28 = "nw_http_proxy_connection_pair_read_outbound";
        _os_log_impl(&dword_181A37000, v6, v22, "%{public}s called with null pair->outbound_connection, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    v15 = __nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v18 = type;
    v19 = os_log_type_enabled(v6, type);
    if (!v15)
    {
      if (v19)
      {
        *buf = 136446210;
        v28 = "nw_http_proxy_connection_pair_read_outbound";
        _os_log_impl(&dword_181A37000, v6, v18, "%{public}s called with null pair->outbound_connection, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v19)
    {
      *buf = 136446466;
      v28 = "nw_http_proxy_connection_pair_read_outbound";
      v29 = 2082;
      v30 = v15;
      _os_log_impl(&dword_181A37000, v6, v18, "%{public}s called with null pair->outbound_connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_35:

    free(v15);
    if (!v5)
    {
      goto LABEL_5;
    }

    goto LABEL_56;
  }

  v23[0] = MEMORY[0x1E69E9820];
  v23[1] = 3221225472;
  v23[2] = ___ZL43nw_http_proxy_connection_pair_read_outboundP40NWConcrete_nw_http_proxy_connection_pair_block_invoke;
  v23[3] = &unk_1E6A39638;
  v24 = v1;
  nw_connection_receive_internal(v3, 0, 1u, 0xFFFFFFFF, v23);

LABEL_5:
}

void ___ZL43nw_http_proxy_connection_pair_read_outboundP40NWConcrete_nw_http_proxy_connection_pair_block_invoke(uint64_t a1, void *a2, void *a3, BOOL a4, void *a5)
{
  v9 = a2;
  v10 = a3;
  v11 = a5;
  v12 = *(a1 + 32);
  v13 = v12[4];
  if (v13 && !v11 && v12[5])
  {
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = ___ZL43nw_http_proxy_connection_pair_read_outboundP40NWConcrete_nw_http_proxy_connection_pair_block_invoke_2;
    v14[3] = &unk_1E6A39610;
    v16 = a4;
    v15 = v12;
    nw_connection_send(v13, v9, &__block_literal_global_8_44676, a4, v14);

    v11 = 0;
  }
}

void ___ZL43nw_http_proxy_connection_pair_read_outboundP40NWConcrete_nw_http_proxy_connection_pair_block_invoke_2(uint64_t a1, void *a2)
{
  v13 = *MEMORY[0x1E69E9840];
  v3 = a2;
  if (!v3)
  {
    goto LABEL_6;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    v9 = 136446466;
    v10 = "nw_http_proxy_connection_pair_read_outbound_block_invoke_2";
    v11 = 2112;
    v12 = v3;
    _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_ERROR, "%{public}s received error sending to inbound connection %@", &v9, 0x16u);
  }

  v5 = v3;
  v6 = v5[2] == 1;

  if (!v6 || (v7 = v5, v8 = v7[3] == 89, v7, !v8))
  {
LABEL_6:
    if ((*(a1 + 40) & 1) == 0)
    {
      nw_http_proxy_connection_pair_read_outbound(*(a1 + 32));
    }
  }
}

void ___ZL61nw_http_proxy_connection_pair_setup_outbound_connection_innerP40NWConcrete_nw_http_proxy_connection_pairPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU30objcproto19OS_nw_http_responseS1_PU27objcproto16OS_dispatch_dataS1__block_invoke_112(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(v2 + 40);
  *(v2 + 40) = 0;

  v4 = *(a1 + 32);
  v5 = *(v4 + 32);
  if (v5)
  {

    nw_connection_cancel(v5);
  }

  else
  {
    v6 = *(v4 + 48);
    if (v6)
    {
      v7 = _Block_copy(v6);
      v8 = *(*(a1 + 40) + 8);
      v9 = *(v8 + 40);
      *(v8 + 40) = v7;

      v10 = *(a1 + 32);
      v11 = *(v10 + 48);
      *(v10 + 48) = 0;
    }
  }
}

void ___ZL55nw_http_proxy_connection_pair_setup_outbound_connectionP40NWConcrete_nw_http_proxy_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke_4(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  v10 = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  if (v10)
  {
    objc_storeStrong((*(a1[5] + 8) + 40), a2);
  }

  if (v11)
  {
    objc_storeStrong((*(a1[6] + 8) + 40), a3);
  }

  if (v12)
  {
    objc_storeStrong((*(a1[7] + 8) + 40), a4);
  }

  if (v13 && dispatch_data_get_size(v13))
  {
    objc_storeStrong((*(a1[8] + 8) + 40), a5);
  }

  v14 = a1[4];
  v15 = v14[2];
  block[0] = MEMORY[0x1E69E9820];
  block[1] = 3221225472;
  block[2] = ___ZL55nw_http_proxy_connection_pair_setup_outbound_connectionP40NWConcrete_nw_http_proxy_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke_5;
  block[3] = &unk_1E6A39688;
  v18 = v14;
  v16 = *(a1 + 7);
  v19 = *(a1 + 5);
  v20 = v16;
  dispatch_async(v15, block);
}

void ___ZL35nw_http_proxy_connection_pair_startP40NWConcrete_nw_http_proxy_connection_pair_block_invoke_100(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(v2 + 32);
  *(v2 + 32) = 0;

  v4 = *(a1 + 32);
  v5 = *(v4 + 40);
  if (v5)
  {

    nw_connection_cancel(v5);
  }

  else
  {
    v6 = *(v4 + 48);
    if (v6)
    {
      v7 = _Block_copy(v6);
      v8 = *(*(a1 + 40) + 8);
      v9 = *(v8 + 40);
      *(v8 + 40) = v7;

      v10 = *(a1 + 32);
      v11 = *(v10 + 48);
      *(v10 + 48) = 0;
    }
  }
}

void nw_http_proxy_server_report_state_change(void *a1, int a2, void *a3)
{
  v32 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a3;
  if (v5)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x3032000000;
    v29 = __Block_byref_object_copy__66298;
    v30 = __Block_byref_object_dispose__66299;
    v31 = 0;
    aBlock[0] = MEMORY[0x1E69E9820];
    aBlock[1] = 3221225472;
    aBlock[2] = ___ZL40nw_http_proxy_server_report_state_changeP31NWConcrete_nw_http_proxy_server19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke;
    aBlock[3] = &unk_1E6A3C060;
    v7 = v5;
    v23 = v7;
    v24 = buf;
    v25 = a2;
    v8 = _Block_copy(aBlock);
    os_unfair_lock_lock(v5 + 2);
    v8[2](v8);
    os_unfair_lock_unlock(v5 + 2);

    if (*(*&buf[8] + 40))
    {
      v9 = *&v7[10]._os_unfair_lock_opaque;
      block[0] = MEMORY[0x1E69E9820];
      block[1] = 3221225472;
      block[2] = ___ZL40nw_http_proxy_server_report_state_changeP31NWConcrete_nw_http_proxy_server19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_2;
      block[3] = &unk_1E6A3C060;
      v20 = buf;
      v21 = a2;
      v19 = v6;
      dispatch_async(v9, block);
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  v10 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_http_proxy_server_report_state_change";
  v11 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (__nwlog_fault(v11, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_server_report_state_change";
        _os_log_impl(&dword_181A37000, v12, v13, "%{public}s called with null server", buf, 0xCu);
      }
    }

    else if (v26 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v15 = type;
      v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *buf = 136446466;
          *&buf[4] = "nw_http_proxy_server_report_state_change";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v12, v15, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v16)
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_server_report_state_change";
        _os_log_impl(&dword_181A37000, v12, v15, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v12 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_http_proxy_server_report_state_change";
        _os_log_impl(&dword_181A37000, v12, v17, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v11)
  {
    free(v11);
  }

LABEL_5:
}

void sub_1828FBD10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, id a32)
{
  _Block_object_dispose(&a27, 8);

  _Unwind_Resume(a1);
}

void ___ZL40nw_http_proxy_server_report_state_changeP31NWConcrete_nw_http_proxy_server19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke(uint64_t a1)
{
  v2 = *(*(a1 + 32) + 48);
  if (v2)
  {
    v3 = _Block_copy(v2);
    v4 = *(*(a1 + 40) + 8);
    v5 = *(v4 + 40);
    *(v4 + 40) = v3;

    if (*(a1 + 48) == 4)
    {
      v6 = *(a1 + 32);
      v7 = *(v6 + 48);
      *(v6 + 48) = 0;
    }
  }
}

void nw_http_proxy_server_cancel(void *a1)
{
  v26 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v4 = __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_http_proxy_server_cancel";
    v5 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v5, &type, &v20))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v23 = "nw_http_proxy_server_cancel";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null server", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v23 = "nw_http_proxy_server_cancel";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v5)
        {
          goto LABEL_4;
        }

LABEL_39:
        free(v5);
        goto LABEL_4;
      }

      if (v12)
      {
        *buf = 136446210;
        v23 = "nw_http_proxy_server_cancel";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v23 = "nw_http_proxy_server_cancel";
        _os_log_impl(&dword_181A37000, v6, v16, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_37:

    goto LABEL_38;
  }

  v3 = v1[4];
  if (v3)
  {
    block[0] = MEMORY[0x1E69E9820];
    block[1] = 3221225472;
    block[2] = __nw_http_proxy_server_cancel_block_invoke;
    block[3] = &unk_1E6A3D868;
    v19 = v1;
    dispatch_async(v3, block);

    goto LABEL_4;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  v23 = "nw_http_proxy_server_cancel";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v5, &type, &v20))
  {
    goto LABEL_38;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v6 = __nwlog_obj();
    v9 = type;
    if (os_log_type_enabled(v6, type))
    {
      *buf = 136446210;
      v23 = "nw_http_proxy_server_cancel";
      _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null server->queue", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v20 != 1)
  {
    v6 = __nwlog_obj();
    v17 = type;
    if (os_log_type_enabled(v6, type))
    {
      *buf = 136446210;
      v23 = "nw_http_proxy_server_cancel";
      _os_log_impl(&dword_181A37000, v6, v17, "%{public}s called with null server->queue, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_37;
  }

  v13 = __nw_create_backtrace_string();
  v6 = __nwlog_obj();
  v14 = type;
  v15 = os_log_type_enabled(v6, type);
  if (!v13)
  {
    if (v15)
    {
      *buf = 136446210;
      v23 = "nw_http_proxy_server_cancel";
      _os_log_impl(&dword_181A37000, v6, v14, "%{public}s called with null server->queue, no backtrace", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v15)
  {
    *buf = 136446466;
    v23 = "nw_http_proxy_server_cancel";
    v24 = 2082;
    v25 = v13;
    _os_log_impl(&dword_181A37000, v6, v14, "%{public}s called with null server->queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v13);
  if (v5)
  {
    goto LABEL_39;
  }

LABEL_4:
}

void __nw_http_proxy_server_cancel_block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  aBlock[0] = MEMORY[0x1E69E9820];
  aBlock[1] = 3221225472;
  aBlock[2] = __nw_http_proxy_server_cancel_block_invoke_2;
  aBlock[3] = &unk_1E6A3D868;
  v4 = v1;
  v2 = _Block_copy(aBlock);
  os_unfair_lock_lock(v1 + 2);
  v2[2](v2);
  os_unfair_lock_unlock(v1 + 2);
}

void __nw_http_proxy_server_cancel_block_invoke_2(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(v2 + 64);
  if (v3)
  {
    _nw_array_apply(v3, &__block_literal_global_80_66368);
    v2 = *(a1 + 32);
  }

  v4 = *(v2 + 24);
  if (v4)
  {
    nw_listener_cancel(v4);
    v5 = *(a1 + 32);
    v6 = *(v5 + 24);
    *(v5 + 24) = 0;
  }
}

_DWORD *nw_fd_wrapper_create_do_not_guard(int a1)
{
  *&v18[13] = *MEMORY[0x1E69E9840];
  if (a1 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    *buf = 136446466;
    v16 = "nw_fd_wrapper_create_do_not_guard";
    v17 = 1024;
    *v18 = a1;
    v5 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = gLogObj;
        v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *buf = 136446466;
          v16 = "nw_fd_wrapper_create_do_not_guard";
          v17 = 1024;
          *v18 = a1;
          _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with invalid fd %d", buf, 0x12u);
        }
      }

      else if (v13 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = gLogObj;
        v10 = type;
        v11 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *buf = 136446722;
            v16 = "nw_fd_wrapper_create_do_not_guard";
            v17 = 1024;
            *v18 = a1;
            v18[2] = 2082;
            *&v18[3] = backtrace_string;
            _os_log_impl(&dword_181A37000, v6, v10, "%{public}s called with invalid fd %d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(backtrace_string);
          if (!v5)
          {
            return 0;
          }

          goto LABEL_11;
        }

        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_fd_wrapper_create_do_not_guard";
          v17 = 1024;
          *v18 = a1;
          _os_log_impl(&dword_181A37000, v6, v10, "%{public}s called with invalid fd %d, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = gLogObj;
        v12 = type;
        if (os_log_type_enabled(v6, type))
        {
          *buf = 136446466;
          v16 = "nw_fd_wrapper_create_do_not_guard";
          v17 = 1024;
          *v18 = a1;
          _os_log_impl(&dword_181A37000, v6, v12, "%{public}s called with invalid fd %d, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }

    if (!v5)
    {
      return 0;
    }

LABEL_11:
    free(v5);
    return 0;
  }

  v2 = [[NWConcrete_nw_fd_wrapper alloc] initWithFileDescriptor:a1];
  *(v2 + 24) |= 2u;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = gLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *buf = 136446466;
    v16 = "nw_fd_wrapper_create_do_not_guard";
    v17 = 2114;
    *v18 = v2;
    _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_DEBUG, "%{public}s Created %{public}@", buf, 0x16u);
  }

  return v2;
}

uint64_t nw_fd_wrapper_is_guarded(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 3);
    v3 = v2[6]._os_unfair_lock_opaque & 1;
    os_unfair_lock_unlock(v2 + 3);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_fd_wrapper_is_guarded";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_fd_wrapper_is_guarded";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null wrapper", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_fd_wrapper_is_guarded";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_fd_wrapper_is_guarded";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null wrapper, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_fd_wrapper_is_guarded";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null wrapper, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

void nw_fd_wrapper_relinquish_fd(void *a1)
{
  *&v39[13] = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 3);
    if ((v2[2]._os_unfair_lock_opaque & 0x80000000) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      os_unfair_lock_opaque = v2[2]._os_unfair_lock_opaque;
      *buf = 136446466;
      v37 = "nw_fd_wrapper_relinquish_fd";
      v38 = 1024;
      *v39 = os_unfair_lock_opaque;
      v5 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v34 = 0;
      if (!__nwlog_fault(v5, &type, &v34))
      {
        goto LABEL_38;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = gLogObj;
        v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          v8 = v2[2]._os_unfair_lock_opaque;
          *buf = 136446466;
          v37 = "nw_fd_wrapper_relinquish_fd";
          v38 = 1024;
          *v39 = v8;
          _os_log_impl(&dword_181A37000, v6, v7, "%{public}s attempt to relinquish invalid fd %d", buf, 0x12u);
        }

        goto LABEL_37;
      }

      if (v34 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = gLogObj;
        v20 = type;
        if (os_log_type_enabled(v6, type))
        {
          v21 = v2[2]._os_unfair_lock_opaque;
          *buf = 136446466;
          v37 = "nw_fd_wrapper_relinquish_fd";
          v38 = 1024;
          *v39 = v21;
          _os_log_impl(&dword_181A37000, v6, v20, "%{public}s attempt to relinquish invalid fd %d, backtrace limit exceeded", buf, 0x12u);
        }

        goto LABEL_37;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v14 = type;
      v15 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          v24 = v2[2]._os_unfair_lock_opaque;
          *buf = 136446466;
          v37 = "nw_fd_wrapper_relinquish_fd";
          v38 = 1024;
          *v39 = v24;
          _os_log_impl(&dword_181A37000, v6, v14, "%{public}s attempt to relinquish invalid fd %d, no backtrace", buf, 0x12u);
        }

        goto LABEL_37;
      }

      if (v15)
      {
        v16 = v2[2]._os_unfair_lock_opaque;
        *buf = 136446722;
        v37 = "nw_fd_wrapper_relinquish_fd";
        v38 = 1024;
        *v39 = v16;
        v39[2] = 2082;
        *&v39[3] = backtrace_string;
        _os_log_impl(&dword_181A37000, v6, v14, "%{public}s attempt to relinquish invalid fd %d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
    }

    else
    {
      if ((v2[6]._os_unfair_lock_opaque & 1) == 0)
      {
        v2[2]._os_unfair_lock_opaque = -1;
LABEL_40:
        os_unfair_lock_unlock(v2 + 3);
        goto LABEL_41;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = v2[2]._os_unfair_lock_opaque;
      *buf = 136446466;
      v37 = "nw_fd_wrapper_relinquish_fd";
      v38 = 1024;
      *v39 = v10;
      v5 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v34 = 0;
      if (!__nwlog_fault(v5, &type, &v34))
      {
        goto LABEL_38;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = gLogObj;
        v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          v12 = v2[2]._os_unfair_lock_opaque;
          *buf = 136446466;
          v37 = "nw_fd_wrapper_relinquish_fd";
          v38 = 1024;
          *v39 = v12;
          _os_log_impl(&dword_181A37000, v6, v11, "%{public}s attempt to relinquish guarded fd %d", buf, 0x12u);
        }

LABEL_37:

LABEL_38:
        if (!v5)
        {
          goto LABEL_40;
        }

LABEL_39:
        free(v5);
        goto LABEL_40;
      }

      if (v34 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = gLogObj;
        v22 = type;
        if (os_log_type_enabled(v6, type))
        {
          v23 = v2[2]._os_unfair_lock_opaque;
          *buf = 136446466;
          v37 = "nw_fd_wrapper_relinquish_fd";
          v38 = 1024;
          *v39 = v23;
          _os_log_impl(&dword_181A37000, v6, v22, "%{public}s attempt to relinquish guarded fd %d, backtrace limit exceeded", buf, 0x12u);
        }

        goto LABEL_37;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v17 = type;
      v18 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          v25 = v2[2]._os_unfair_lock_opaque;
          *buf = 136446466;
          v37 = "nw_fd_wrapper_relinquish_fd";
          v38 = 1024;
          *v39 = v25;
          _os_log_impl(&dword_181A37000, v6, v17, "%{public}s attempt to relinquish guarded fd %d, no backtrace", buf, 0x12u);
        }

        goto LABEL_37;
      }

      if (v18)
      {
        v19 = v2[2]._os_unfair_lock_opaque;
        *buf = 136446722;
        v37 = "nw_fd_wrapper_relinquish_fd";
        v38 = 1024;
        *v39 = v19;
        v39[2] = 2082;
        *&v39[3] = backtrace_string;
        _os_log_impl(&dword_181A37000, v6, v17, "%{public}s attempt to relinquish guarded fd %d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
    }

    free(backtrace_string);
    if (!v5)
    {
      goto LABEL_40;
    }

    goto LABEL_39;
  }

  v26 = __nwlog_obj();
  *buf = 136446210;
  v37 = "nw_fd_wrapper_relinquish_fd";
  v27 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v34 = 0;
  if (__nwlog_fault(v27, &type, &v34))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *buf = 136446210;
        v37 = "nw_fd_wrapper_relinquish_fd";
        _os_log_impl(&dword_181A37000, v28, v29, "%{public}s called with null wrapper", buf, 0xCu);
      }
    }

    else if (v34 == 1)
    {
      v30 = __nw_create_backtrace_string();
      v28 = __nwlog_obj();
      v31 = type;
      v32 = os_log_type_enabled(v28, type);
      if (v30)
      {
        if (v32)
        {
          *buf = 136446466;
          v37 = "nw_fd_wrapper_relinquish_fd";
          v38 = 2082;
          *v39 = v30;
          _os_log_impl(&dword_181A37000, v28, v31, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v30);
        goto LABEL_58;
      }

      if (v32)
      {
        *buf = 136446210;
        v37 = "nw_fd_wrapper_relinquish_fd";
        _os_log_impl(&dword_181A37000, v28, v31, "%{public}s called with null wrapper, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v28 = __nwlog_obj();
      v33 = type;
      if (os_log_type_enabled(v28, type))
      {
        *buf = 136446210;
        v37 = "nw_fd_wrapper_relinquish_fd";
        _os_log_impl(&dword_181A37000, v28, v33, "%{public}s called with null wrapper, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_58:
  if (v27)
  {
    free(v27);
  }

LABEL_41:
}

void sub_1828FD718(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = NWConcrete_nw_interpose;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

id *nw_interpose_client_register(int a1, void *a2)
{
  v53 = *MEMORY[0x1E69E9840];
  v4 = a2;
  nw_allow_use_of_dispatch_internal();
  v5 = [NWConcrete_nw_interpose alloc];
  v6 = v4;
  if (!v5)
  {
LABEL_60:

    goto LABEL_61;
  }

  v41.receiver = v5;
  v41.super_class = NWConcrete_nw_interpose;
  v7 = objc_msgSendSuper2(&v41, sel_init);
  v8 = v7;
  if (!v7)
  {
    v23 = __nwlog_obj();
    LODWORD(buffer[0]) = 136446210;
    *(buffer + 4) = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
    v24 = _os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v42) = 0;
    if (__nwlog_fault(v24, buf, &v42))
    {
      if (buf[0] == 17)
      {
        v25 = __nwlog_obj();
        v26 = buf[0];
        if (os_log_type_enabled(v25, buf[0]))
        {
          LODWORD(buffer[0]) = 136446210;
          *(buffer + 4) = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
          _os_log_impl(&dword_181A37000, v25, v26, "%{public}s [super init] failed", buffer, 0xCu);
        }
      }

      else if (v42 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v25 = __nwlog_obj();
        v32 = buf[0];
        v33 = os_log_type_enabled(v25, buf[0]);
        if (backtrace_string)
        {
          if (v33)
          {
            LODWORD(buffer[0]) = 136446466;
            *(buffer + 4) = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
            WORD6(buffer[0]) = 2082;
            *(buffer + 14) = backtrace_string;
            _os_log_impl(&dword_181A37000, v25, v32, "%{public}s [super init] failed, dumping backtrace:%{public}s", buffer, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_52;
        }

        if (v33)
        {
          LODWORD(buffer[0]) = 136446210;
          *(buffer + 4) = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
          _os_log_impl(&dword_181A37000, v25, v32, "%{public}s [super init] failed, no backtrace", buffer, 0xCu);
        }
      }

      else
      {
        v25 = __nwlog_obj();
        v37 = buf[0];
        if (os_log_type_enabled(v25, buf[0]))
        {
          LODWORD(buffer[0]) = 136446210;
          *(buffer + 4) = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
          _os_log_impl(&dword_181A37000, v25, v37, "%{public}s [super init] failed, backtrace limit exceeded", buffer, 0xCu);
        }
      }
    }

LABEL_52:
    if (v24)
    {
      free(v24);
    }

    goto LABEL_60;
  }

  v9 = v7;
  *(v7 + 7) = a1;
  objc_storeStrong(v7 + 8, a2);
  v10 = v8[8];
  if (!v10)
  {
    if (nw_context_copy_implicit_context::onceToken[0] != -1)
    {
      dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
    }

    objc_storeStrong(v8 + 8, nw_context_copy_implicit_context::implicit_context);
    v10 = v8[8];
  }

  if (nw_context_is_inline(v10))
  {
    v27 = __nwlog_obj();
    LODWORD(buffer[0]) = 136446210;
    *(buffer + 4) = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
    v28 = _os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v42) = 0;
    if (__nwlog_fault(v28, buf, &v42))
    {
      if (buf[0] == 17)
      {
        v29 = __nwlog_obj();
        v30 = buf[0];
        if (os_log_type_enabled(v29, buf[0]))
        {
          LODWORD(buffer[0]) = 136446210;
          *(buffer + 4) = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
          _os_log_impl(&dword_181A37000, v29, v30, "%{public}s Cannot use nw_interpose on inline contexts", buffer, 0xCu);
        }
      }

      else if (v42 == 1)
      {
        v34 = __nw_create_backtrace_string();
        v29 = __nwlog_obj();
        v35 = buf[0];
        v36 = os_log_type_enabled(v29, buf[0]);
        if (v34)
        {
          if (v36)
          {
            LODWORD(buffer[0]) = 136446466;
            *(buffer + 4) = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
            WORD6(buffer[0]) = 2082;
            *(buffer + 14) = v34;
            _os_log_impl(&dword_181A37000, v29, v35, "%{public}s Cannot use nw_interpose on inline contexts, dumping backtrace:%{public}s", buffer, 0x16u);
          }

          free(v34);
          goto LABEL_57;
        }

        if (v36)
        {
          LODWORD(buffer[0]) = 136446210;
          *(buffer + 4) = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
          _os_log_impl(&dword_181A37000, v29, v35, "%{public}s Cannot use nw_interpose on inline contexts, no backtrace", buffer, 0xCu);
        }
      }

      else
      {
        v29 = __nwlog_obj();
        v38 = buf[0];
        if (os_log_type_enabled(v29, buf[0]))
        {
          LODWORD(buffer[0]) = 136446210;
          *(buffer + 4) = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
          _os_log_impl(&dword_181A37000, v29, v38, "%{public}s Cannot use nw_interpose on inline contexts, backtrace limit exceeded", buffer, 0xCu);
        }
      }
    }

LABEL_57:
    if (v28)
    {
      free(v28);
    }

    goto LABEL_60;
  }

  v52 = 0;
  memset(buffer, 0, sizeof(buffer));
  v11 = proc_pidinfo(a1, 17, 1uLL, buffer, 56);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v12 = gLogObj;
  v13 = v12;
  if (v11 != 56)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v20 = *(v8 + 7);
      *buf = 136446722;
      v44 = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
      v45 = 2114;
      v46 = v8;
      v47 = 1024;
      v48 = v20;
      _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] failed to get upid for pid %d", buf, 0x1Cu);
    }

    goto LABEL_20;
  }

  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    *buf = 136446978;
    v44 = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
    v45 = 2114;
    v46 = v8;
    v47 = 1024;
    v48 = a1;
    v49 = 2048;
    v50 = *&buffer[1];
    _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] pid %d upid %llu", buf, 0x26u);
  }

  v13 = _nw_parameters_create();
  nw_parameters_set_pid(v13, *(v8 + 7));
  nw_parameters_set_proc_uuid(v13, buffer);
  nw_parameters_set_e_proc_uuid(v13, buffer);
  nw_parameters_set_delegated_unique_pid(v13, *&buffer[1]);
  nw_parameters_set_include_peer_to_peer(v13, 1);
  nw_parameters_set_context(v13, v8[8]);
  evaluator_for_interpose = nw_path_create_evaluator_for_interpose(v13);
  v15 = v8[5];
  v8[5] = evaluator_for_interpose;

  v16 = v8[5];
  if (!v16)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = gLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446722;
      v44 = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
      v45 = 2114;
      v46 = v8;
      v47 = 1024;
      v48 = a1;
      _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] failed to create evaluator for pid %d", buf, 0x1Cu);
    }

LABEL_20:
    v19 = 0;
    goto LABEL_21;
  }

  v17 = v16;
  v42 = v17[5];

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v18 = gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    *buf = 136446978;
    v44 = "[NWConcrete_nw_interpose initWithDelegatedPid:nw_context:]";
    v45 = 2114;
    v46 = v8;
    v47 = 1042;
    v48 = 16;
    v49 = 2098;
    v50 = &v42;
    _os_log_impl(&dword_181A37000, v18, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] registered with client %{public,uuid_t}.16P", buf, 0x26u);
  }

  v19 = v8;
LABEL_21:

  if (v19)
  {
    v22 = v19;
    goto LABEL_64;
  }

LABEL_61:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v39 = gLogObj;
  if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buffer[0]) = 136446466;
    *(buffer + 4) = "nw_interpose_client_register";
    WORD6(buffer[0]) = 2114;
    *(buffer + 14) = 0;
    _os_log_impl(&dword_181A37000, v39, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] failed to allocate interpose", buffer, 0x16u);
  }

  v22 = 0;
LABEL_64:

  return v22;
}

id *nw_interpose_client_claim(const unsigned __int8 *a1, void *a2)
{
  v37 = *MEMORY[0x1E69E9840];
  v4 = a2;
  nw_allow_use_of_dispatch_internal();
  if (uuid_is_null(a1))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
LABEL_5:

      v7 = 0;
      goto LABEL_18;
    }

    *buf = 136446466;
    v30 = "nw_interpose_client_claim";
    v31 = 2114;
    v32 = 0;
    v6 = "%{public}s [%{public}@] no client UUID";
LABEL_4:
    _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_ERROR, v6, buf, 0x16u);
    goto LABEL_5;
  }

  v8 = [NWConcrete_nw_interpose alloc];
  v9 = v4;
  if (!v8)
  {
LABEL_22:

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_5;
    }

    *buf = 136446466;
    v30 = "nw_interpose_client_claim";
    v31 = 2114;
    v32 = 0;
    v6 = "%{public}s [%{public}@] failed to allocate interpose";
    goto LABEL_4;
  }

  v28.receiver = v8;
  v28.super_class = NWConcrete_nw_interpose;
  v10 = objc_msgSendSuper2(&v28, sel_init);
  v7 = v10;
  if (!v10)
  {
    v18 = __nwlog_obj();
    *buf = 136446210;
    v30 = "[NWConcrete_nw_interpose initWithClientUUID:nw_context:]";
    v19 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v19, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v20 = __nwlog_obj();
        v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *buf = 136446210;
          v30 = "[NWConcrete_nw_interpose initWithClientUUID:nw_context:]";
          _os_log_impl(&dword_181A37000, v20, v21, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v26 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v20 = __nwlog_obj();
        v23 = type;
        v24 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *buf = 136446466;
            v30 = "[NWConcrete_nw_interpose initWithClientUUID:nw_context:]";
            v31 = 2082;
            v32 = backtrace_string;
            _os_log_impl(&dword_181A37000, v20, v23, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_40;
        }

        if (v24)
        {
          *buf = 136446210;
          v30 = "[NWConcrete_nw_interpose initWithClientUUID:nw_context:]";
          _os_log_impl(&dword_181A37000, v20, v23, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v20 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v20, type))
        {
          *buf = 136446210;
          v30 = "[NWConcrete_nw_interpose initWithClientUUID:nw_context:]";
          _os_log_impl(&dword_181A37000, v20, v25, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_40:
    if (v19)
    {
      free(v19);
    }

    goto LABEL_22;
  }

  *(v10 + 12) = *a1;
  objc_storeStrong(v10 + 8, a2);
  if (!v7[8])
  {
    if (nw_context_copy_implicit_context::onceToken[0] != -1)
    {
      dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
    }

    objc_storeStrong(v7 + 8, nw_context_copy_implicit_context::implicit_context);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v11 = gLogObj;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    *buf = 136446978;
    v30 = "[NWConcrete_nw_interpose initWithClientUUID:nw_context:]";
    v31 = 2114;
    v32 = v7;
    v33 = 1042;
    v34 = 16;
    v35 = 2098;
    v36 = a1;
    _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] claiming evaluator with client UUID %{public,uuid_t}.16P", buf, 0x26u);
  }

  evaluator_for_client_id = nw_path_create_evaluator_for_client_id(a1, v7[8]);
  v13 = v7[5];
  v7[5] = evaluator_for_client_id;

  v14 = v7[5];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v15 = gLogObj;
  v16 = v15;
  if (!v14)
  {
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446978;
      v30 = "[NWConcrete_nw_interpose initWithClientUUID:nw_context:]";
      v31 = 2114;
      v32 = v7;
      v33 = 1042;
      v34 = 16;
      v35 = 2098;
      v36 = a1;
      _os_log_impl(&dword_181A37000, v16, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] failed to claim evaluator with client UUID %{public,uuid_t}.16P", buf, 0x26u);
    }

    goto LABEL_22;
  }

  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    *buf = 136446978;
    v30 = "[NWConcrete_nw_interpose initWithClientUUID:nw_context:]";
    v31 = 2114;
    v32 = v7;
    v33 = 1042;
    v34 = 16;
    v35 = 2098;
    v36 = a1;
    _os_log_impl(&dword_181A37000, v16, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] claimed evaluator with client UUID %{public,uuid_t}.16P", buf, 0x26u);
  }

LABEL_18:
  return v7;
}

BOOL nw_interpose_get_client_uuid(void *a1, _OWORD *a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    os_unfair_lock_lock(v3 + 2);
    client_id = nw_path_evaluator_get_client_id(*&v4[10]._os_unfair_lock_opaque, a2);
    os_unfair_lock_unlock(v4 + 2);
    goto LABEL_3;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_interpose_get_client_uuid";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_interpose_get_client_uuid";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null interpose", buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v18 = "nw_interpose_get_client_uuid";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null interpose, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *buf = 136446210;
        v18 = "nw_interpose_get_client_uuid";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null interpose, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_interpose_get_client_uuid";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null interpose, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v8)
  {
    free(v8);
  }

  client_id = 0;
LABEL_3:

  return client_id;
}

void nw_interpose_set_queue(void *a1, void *a2)
{
  v26 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    v6 = __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_interpose_set_queue";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v23 = "nw_interpose_set_queue";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null interpose", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v23 = "nw_interpose_set_queue";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null interpose, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7)
        {
          goto LABEL_4;
        }

LABEL_39:
        free(v7);
        goto LABEL_4;
      }

      if (v14)
      {
        *buf = 136446210;
        v23 = "nw_interpose_set_queue";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null interpose, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v23 = "nw_interpose_set_queue";
        _os_log_impl(&dword_181A37000, v8, v18, "%{public}s called with null interpose, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_37:

    goto LABEL_38;
  }

  if (v4)
  {
    os_unfair_lock_lock(v3 + 2);
    objc_storeStrong(v3 + 9, a2);
    os_unfair_lock_unlock(v3 + 2);
    goto LABEL_4;
  }

  v10 = __nwlog_obj();
  *buf = 136446210;
  v23 = "nw_interpose_set_queue";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20))
  {
    goto LABEL_38;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *buf = 136446210;
      v23 = "nw_interpose_set_queue";
      _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null queue", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v20 != 1)
  {
    v8 = __nwlog_obj();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *buf = 136446210;
      v23 = "nw_interpose_set_queue";
      _os_log_impl(&dword_181A37000, v8, v19, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_37;
  }

  v15 = __nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *buf = 136446210;
      v23 = "nw_interpose_set_queue";
      _os_log_impl(&dword_181A37000, v8, v16, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v17)
  {
    *buf = 136446466;
    v23 = "nw_interpose_set_queue";
    v24 = 2082;
    v25 = v15;
    _os_log_impl(&dword_181A37000, v8, v16, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
  {
    goto LABEL_39;
  }

LABEL_4:
}

void nw_interpose_set_flow_event_handler(void *a1, void *a2)
{
  v29 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    v9 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_interpose_set_flow_event_handler";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v26 = "nw_interpose_set_flow_event_handler";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null interpose", buf, 0xCu);
      }
    }

    else if (v23 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *buf = 136446466;
          v26 = "nw_interpose_set_flow_event_handler";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null interpose, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v10)
        {
          goto LABEL_4;
        }

LABEL_39:
        free(v10);
        goto LABEL_4;
      }

      if (v17)
      {
        *buf = 136446210;
        v26 = "nw_interpose_set_flow_event_handler";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null interpose, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v26 = "nw_interpose_set_flow_event_handler";
        _os_log_impl(&dword_181A37000, v11, v21, "%{public}s called with null interpose, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_37:

    goto LABEL_38;
  }

  if (v4)
  {
    os_unfair_lock_lock(v3 + 2);
    v6 = v3;
    v7 = _Block_copy(v5);
    v8 = *&v6[14]._os_unfair_lock_opaque;
    *&v6[14]._os_unfair_lock_opaque = v7;

    os_unfair_lock_unlock(v3 + 2);
    goto LABEL_4;
  }

  v13 = __nwlog_obj();
  *buf = 136446210;
  v26 = "nw_interpose_set_flow_event_handler";
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v10, &type, &v23))
  {
    goto LABEL_38;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v11 = __nwlog_obj();
    v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *buf = 136446210;
      v26 = "nw_interpose_set_flow_event_handler";
      _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null handler", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v23 != 1)
  {
    v11 = __nwlog_obj();
    v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *buf = 136446210;
      v26 = "nw_interpose_set_flow_event_handler";
      _os_log_impl(&dword_181A37000, v11, v22, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_37;
  }

  v18 = __nw_create_backtrace_string();
  v11 = __nwlog_obj();
  v19 = type;
  v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *buf = 136446210;
      v26 = "nw_interpose_set_flow_event_handler";
      _os_log_impl(&dword_181A37000, v11, v19, "%{public}s called with null handler, no backtrace", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v20)
  {
    *buf = 136446466;
    v26 = "nw_interpose_set_flow_event_handler";
    v27 = 2082;
    v28 = v18;
    _os_log_impl(&dword_181A37000, v11, v19, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10)
  {
    goto LABEL_39;
  }

LABEL_4:
}

void nw_interpose_start(void *a1)
{
  v23 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 2);
    objc_initWeak(location, v2);
    v3 = *&v2[10]._os_unfair_lock_opaque;
    v4 = *&v2[18]._os_unfair_lock_opaque;
    v16[0] = MEMORY[0x1E69E9820];
    v16[1] = 3221225472;
    v16[2] = __nw_interpose_start_block_invoke;
    v16[3] = &unk_1E6A3D2D8;
    objc_copyWeak(&v17, location);
    nw_path_evaluator_set_update_handler(v3, v4, v16);
    v5 = *&v2[16]._os_unfair_lock_opaque;
    v14[0] = MEMORY[0x1E69E9820];
    v14[1] = 3221225472;
    v14[2] = __nw_interpose_start_block_invoke_7;
    v14[3] = &unk_1E6A3D868;
    v15 = v2;
    nw_queue_context_async(v5, v14);
    os_unfair_lock_unlock(v2 + 2);

    objc_destroyWeak(&v17);
    objc_destroyWeak(location);
    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *location = 136446210;
  *&location[4] = "nw_interpose_start";
  v7 = _os_log_send_and_compose_impl();

  v19 = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (__nwlog_fault(v7, &v19, &v18))
  {
    if (v19 == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = v19;
      if (os_log_type_enabled(v8, v19))
      {
        *location = 136446210;
        *&location[4] = "nw_interpose_start";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null interpose", location, 0xCu);
      }
    }

    else if (v18 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = v19;
      v12 = os_log_type_enabled(v8, v19);
      if (backtrace_string)
      {
        if (v12)
        {
          *location = 136446466;
          *&location[4] = "nw_interpose_start";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null interpose, dumping backtrace:%{public}s", location, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *location = 136446210;
        *&location[4] = "nw_interpose_start";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null interpose, no backtrace", location, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = v19;
      if (os_log_type_enabled(v8, v19))
      {
        *location = 136446210;
        *&location[4] = "nw_interpose_start";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null interpose, backtrace limit exceeded", location, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:
}

void sub_1828FF6D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  objc_destroyWeak((v19 + 32));
  objc_destroyWeak((v20 - 96));

  _Unwind_Resume(a1);
}

void __nw_interpose_start_block_invoke(uint64_t a1, void *a2)
{
  v12 = *MEMORY[0x1E69E9840];
  v3 = a2;
  WeakRetained = objc_loadWeakRetained((a1 + 32));
  if (WeakRetained)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      v6 = 136446722;
      v7 = "nw_interpose_start_block_invoke";
      v8 = 2114;
      v9 = WeakRetained;
      v10 = 2114;
      v11 = v3;
      _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] Handling new path %{public}@", &v6, 0x20u);
    }

    os_unfair_lock_lock(WeakRetained + 2);
    nw_interpose_handle_path_update_locked(WeakRetained, v3);
    os_unfair_lock_unlock(WeakRetained + 2);
  }
}

void __nw_interpose_start_block_invoke_7(uint64_t a1)
{
  os_unfair_lock_lock((*(a1 + 32) + 8));
  v2 = *(a1 + 32);
  v3 = v2[5];
  if (v3)
  {
    v4 = v3;
    os_unfair_lock_lock(v3 + 24);
    v5 = v4[6];
    os_unfair_lock_unlock(v3 + 24);
  }

  else
  {
    v5 = 0;
  }

  nw_interpose_handle_path_update_locked(v2, v5);

  v6 = (*(a1 + 32) + 8);

  os_unfair_lock_unlock(v6);
}

void nw_interpose_handle_path_update_locked(void *a1, void *a2)
{
  v31 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = nw_dictionary_create();
  v22[0] = MEMORY[0x1E69E9820];
  v22[1] = 3221225472;
  v22[2] = ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke;
  v22[3] = &unk_1E6A39720;
  v6 = v3;
  v23 = v6;
  v7 = v5;
  v24 = v7;
  nw_path_enumerate_interface_options(v4, v22);
  v8 = v6[6];
  if (v8)
  {
    v20[0] = MEMORY[0x1E69E9820];
    v20[1] = 3221225472;
    v20[2] = ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke_82;
    v20[3] = &unk_1E6A39A98;
    v21 = v7;
    nw_dictionary_apply(v8, v20);
  }

  objc_storeStrong(v6 + 6, v5);
  v9 = v6[8];
  v18[0] = MEMORY[0x1E69E9820];
  v18[1] = 3221225472;
  v18[2] = ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke_2;
  v18[3] = &unk_1E6A3D868;
  v10 = v6;
  v19 = v10;
  nw_queue_context_async(v9, v18);
  v11 = _nw_path_copy_flows(v4);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v12 = gLogObj;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    if (v11)
    {
      count = _nw_array_get_count(v11);
    }

    else
    {
      count = 0;
    }

    *buf = 136446722;
    v26 = "nw_interpose_handle_path_update_locked";
    v27 = 2114;
    v28 = v10;
    v29 = 1024;
    v30 = count;
    _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] got %d flows from path", buf, 0x1Cu);
  }

  aBlock[0] = MEMORY[0x1E69E9820];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke_83;
  aBlock[3] = &unk_1E6A3CCB8;
  v14 = v10;
  v17 = v14;
  v15 = v14;
  if (v11)
  {
    _nw_array_apply(v11, aBlock);
    v15 = v17;
  }
}

void ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke(uint64_t a1, void *a2, const unsigned __int8 *a3)
{
  v37 = *MEMORY[0x1E69E9840];
  v5 = a2;
  v6 = v5;
  if (v5)
  {
    name = _nw_interface_get_name(v5);
    if (name)
    {
      if (uuid_is_null(a3))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        p_super = gLogObj;
        if (os_log_type_enabled(p_super, OS_LOG_TYPE_ERROR))
        {
          v9 = *(a1 + 32);
          *buf = 136446466;
          v28 = "nw_interpose_handle_path_update_locked_block_invoke";
          v29 = 2114;
          v30 = v9;
          v10 = "%{public}s [%{public}@] no nexus agent";
LABEL_8:
          _os_log_impl(&dword_181A37000, p_super, OS_LOG_TYPE_ERROR, v10, buf, 0x16u);
          goto LABEL_9;
        }

        goto LABEL_9;
      }

      v12 = *(*(a1 + 32) + 48);
      if (v12 && (v13 = nw_dictionary_copy_value(v12, name)) != 0)
      {
        v14 = v13;
        if ([(nw_interpose_flow *)v13 matchNexusAgent:a3])
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v15 = gLogObj;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            v16 = *(a1 + 32);
            *buf = 136447234;
            v28 = "nw_interpose_handle_path_update_locked_block_invoke";
            v29 = 2114;
            v30 = v16;
            v31 = 1042;
            v32 = 16;
            v33 = 2098;
            v34 = a3;
            v35 = 2080;
            v36 = name;
            _os_log_impl(&dword_181A37000, v15, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] flow registration already exists for nexus agent %{public,uuid_t}.16P on %s", buf, 0x30u);
          }

LABEL_25:
          nw_dictionary_set_value(*(a1 + 40), name, v14);
          p_super = &v14->super;
          goto LABEL_9;
        }

        p_super = &v14->super;
      }

      else
      {
        p_super = 0;
      }

      v26 = *a3;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        v18 = *(a1 + 32);
        *buf = 136447234;
        v28 = "nw_interpose_handle_path_update_locked_block_invoke";
        v29 = 2114;
        v30 = v18;
        v31 = 1042;
        v32 = 16;
        v33 = 2098;
        v34 = &v26;
        v35 = 2080;
        v36 = name;
        _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] adding flow registration for nexus agent %{public,uuid_t}.16P on %s", buf, 0x30u);
      }

      v19 = nw_path_evaluator_create_flow_inner(*(*(a1 + 32) + 40), 0, 1, 0, 0, &v26, 0, 0, 0, 0, 0);
      if (v19)
      {
        v14 = [[nw_interpose_flow alloc] initWithInterface:v6 registration:v19 eventHandler:*(*(a1 + 32) + 56)];

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = gLogObj;
        v21 = v20;
        if (v14)
        {
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            v22 = *(a1 + 32);
            *buf = 136447234;
            v28 = "nw_interpose_handle_path_update_locked_block_invoke";
            v29 = 2114;
            v30 = v22;
            v31 = 1042;
            v32 = 16;
            v33 = 2098;
            v34 = &v26;
            v35 = 2080;
            v36 = name;
            _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] added flow registration for nexus agent %{public,uuid_t}.16P on %s", buf, 0x30u);
          }

          goto LABEL_25;
        }

        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          v25 = *(a1 + 32);
          *buf = 136447234;
          v28 = "nw_interpose_handle_path_update_locked_block_invoke";
          v29 = 2114;
          v30 = v25;
          v31 = 1042;
          v32 = 16;
          v33 = 2098;
          v34 = &v26;
          v35 = 2080;
          v36 = name;
          _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] failed to create flow object for nexus agent %{public,uuid_t}.16P on %s", buf, 0x30u);
        }

        p_super = 0;
        nw_path_flow_registration_close(v19);
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          v24 = *(a1 + 32);
          *buf = 136447234;
          v28 = "nw_interpose_handle_path_update_locked_block_invoke";
          v29 = 2114;
          v30 = v24;
          v31 = 1042;
          v32 = 16;
          v33 = 2098;
          v34 = &v26;
          v35 = 2080;
          v36 = name;
          _os_log_impl(&dword_181A37000, v23, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] failed to create flow registration for nexus agent %{public,uuid_t}.16P on %s", buf, 0x30u);
        }
      }

      goto LABEL_9;
    }
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  p_super = gLogObj;
  if (os_log_type_enabled(p_super, OS_LOG_TYPE_ERROR))
  {
    v11 = *(a1 + 32);
    *buf = 136446466;
    v28 = "nw_interpose_handle_path_update_locked_block_invoke";
    v29 = 2114;
    v30 = v11;
    v10 = "%{public}s [%{public}@] no interface name";
    goto LABEL_8;
  }

LABEL_9:
}

uint64_t ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke_82(uint64_t a1, uint64_t a2, void *a3)
{
  v5 = a3;
  v6 = nw_dictionary_copy_value(*(a1 + 32), a2);
  v7 = v6;
  if (v6)
  {
    v8 = v6 == v5;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    [v5 close];
  }

  return 1;
}

uint64_t ___ZL38nw_interpose_handle_path_update_lockedP23NWConcrete_nw_interposePU21objcproto10OS_nw_path8NSObject_block_invoke_83(uint64_t a1, uint64_t a2, void *a3)
{
  v43 = *MEMORY[0x1E69E9840];
  v4 = a3;
  v5 = *(a1 + 32);
  v6 = v4;
  v7 = v6;
  if (!v5)
  {
    v13 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_interpose_flow_get_locked";
    v14 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v14, &type, &v37))
    {
      goto LABEL_57;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_181A37000, v15, v16, "%{public}s called with null interpose", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v37 != 1)
    {
      v15 = __nwlog_obj();
      v29 = type;
      if (os_log_type_enabled(v15, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_181A37000, v15, v29, "%{public}s called with null interpose, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v15 = __nwlog_obj();
    v22 = type;
    v23 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *buf = 136446210;
        *&buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_181A37000, v15, v22, "%{public}s called with null interpose, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v23)
    {
      *buf = 136446466;
      *&buf[4] = "nw_interpose_flow_get_locked";
      *&buf[12] = 2082;
      *&buf[14] = backtrace_string;
      _os_log_impl(&dword_181A37000, v15, v22, "%{public}s called with null interpose, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_32;
  }

  v8 = v5[6];
  if (!v8)
  {
    v17 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_interpose_flow_get_locked";
    v14 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v14, &type, &v37))
    {
      goto LABEL_57;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v18 = type;
      if (os_log_type_enabled(v15, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_181A37000, v15, v18, "%{public}s called with null interpose->flows", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v37 != 1)
    {
      v15 = __nwlog_obj();
      v30 = type;
      if (os_log_type_enabled(v15, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_181A37000, v15, v30, "%{public}s called with null interpose->flows, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = __nw_create_backtrace_string();
    v15 = __nwlog_obj();
    v24 = type;
    v25 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *buf = 136446210;
        *&buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_181A37000, v15, v24, "%{public}s called with null interpose->flows, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v25)
    {
      *buf = 136446466;
      *&buf[4] = "nw_interpose_flow_get_locked";
      *&buf[12] = 2082;
      *&buf[14] = backtrace_string;
      _os_log_impl(&dword_181A37000, v15, v24, "%{public}s called with null interpose->flows, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_32:

    free(backtrace_string);
    if (!v14)
    {
      goto LABEL_59;
    }

    goto LABEL_58;
  }

  if (!v6)
  {
    v19 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_interpose_flow_get_locked";
    v14 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v14, &type, &v37))
    {
      goto LABEL_57;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v15, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_181A37000, v15, v20, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v37 == 1)
    {
      v26 = __nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v27 = type;
      v28 = os_log_type_enabled(v15, type);
      if (v26)
      {
        if (v28)
        {
          *buf = 136446466;
          *&buf[4] = "nw_interpose_flow_get_locked";
          *&buf[12] = 2082;
          *&buf[14] = v26;
          _os_log_impl(&dword_181A37000, v15, v27, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v26);
LABEL_57:
        if (!v14)
        {
LABEL_59:

          goto LABEL_60;
        }

LABEL_58:
        free(v14);
        goto LABEL_59;
      }

      if (v28)
      {
        *buf = 136446210;
        *&buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_181A37000, v15, v27, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v15 = __nwlog_obj();
      v31 = type;
      if (os_log_type_enabled(v15, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_181A37000, v15, v31, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_56:

    goto LABEL_57;
  }

  *buf = 0;
  *&buf[8] = buf;
  *&buf[16] = 0x3032000000;
  v40 = __Block_byref_object_copy__66701;
  v41 = __Block_byref_object_dispose__66702;
  v42 = 0;
  v34[0] = MEMORY[0x1E69E9820];
  v34[1] = 3221225472;
  v34[2] = ___ZL28nw_interpose_flow_get_lockedP23NWConcrete_nw_interposePU26objcproto15OS_nw_path_flow8NSObject_block_invoke;
  v34[3] = &unk_1E6A3BF70;
  v9 = v6;
  v35 = v9;
  v36 = buf;
  nw_dictionary_apply(v8, v34);
  v10 = *(*&buf[8] + 40);

  _Block_object_dispose(buf, 8);
  if (v10)
  {
    [v10 resetFlow:v9];
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v12 = *(a1 + 32);
      *buf = 136446466;
      *&buf[4] = "nw_interpose_handle_path_update_locked_block_invoke";
      *&buf[12] = 2114;
      *&buf[14] = v12;
      _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] updated flow", buf, 0x16u);
    }

    goto LABEL_62;
  }

LABEL_60:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v10 = gLogObj;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    v32 = *(a1 + 32);
    *buf = 136446466;
    *&buf[4] = "nw_interpose_handle_path_update_locked_block_invoke";
    *&buf[12] = 2114;
    *&buf[14] = v32;
    _os_log_impl(&dword_181A37000, v10, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] failed to find flowObj", buf, 0x16u);
  }

LABEL_62:

  return 1;
}

uint64_t __Block_byref_object_copy__66701(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

uint64_t ___ZL28nw_interpose_flow_get_lockedP23NWConcrete_nw_interposePU26objcproto15OS_nw_path_flow8NSObject_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  v5 = a3;
  v6 = [v5 matchNexusAgentWithFlow:*(a1 + 32)];
  if (v6)
  {
    objc_storeStrong((*(*(a1 + 40) + 8) + 40), a3);
  }

  return v6 ^ 1u;
}

void nw_interpose_cancel(void *a1)
{
  v30 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 2);
    v3 = v2;
    v4 = *&v3[12]._os_unfair_lock_opaque;
    if (v4)
    {
      nw_dictionary_apply(v4, &__block_literal_global_66724);
LABEL_4:
      v5 = *&v3[14]._os_unfair_lock_opaque;
      *&v3[14]._os_unfair_lock_opaque = 0;

      v6 = *&v3[10]._os_unfair_lock_opaque;
      if (v6)
      {
        nw_path_evaluator_cancel(v6);
        v7 = *&v3[10]._os_unfair_lock_opaque;
        *&v3[10]._os_unfair_lock_opaque = 0;
      }

      os_unfair_lock_unlock(v2 + 2);
      goto LABEL_7;
    }

    v12 = __nwlog_obj();
    *buf = 136446210;
    v27 = "nw_interpose_flow_clear_handlers_locked";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v13, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *buf = 136446210;
          v27 = "nw_interpose_flow_clear_handlers_locked";
          _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null interpose->flows", buf, 0xCu);
        }
      }

      else if (v24 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v20 = type;
        v21 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *buf = 136446466;
            v27 = "nw_interpose_flow_clear_handlers_locked";
            v28 = 2082;
            v29 = backtrace_string;
            _os_log_impl(&dword_181A37000, v14, v20, "%{public}s called with null interpose->flows, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }

        if (v21)
        {
          *buf = 136446210;
          v27 = "nw_interpose_flow_clear_handlers_locked";
          _os_log_impl(&dword_181A37000, v14, v20, "%{public}s called with null interpose->flows, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v14 = __nwlog_obj();
        v23 = type;
        if (os_log_type_enabled(v14, type))
        {
          *buf = 136446210;
          v27 = "nw_interpose_flow_clear_handlers_locked";
          _os_log_impl(&dword_181A37000, v14, v23, "%{public}s called with null interpose->flows, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_42:
    if (v13)
    {
      free(v13);
    }

    goto LABEL_4;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  v27 = "nw_interpose_cancel";
  v9 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (__nwlog_fault(v9, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v27 = "nw_interpose_cancel";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null interpose", buf, 0xCu);
      }
    }

    else if (v24 == 1)
    {
      v16 = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v17 = type;
      v18 = os_log_type_enabled(v10, type);
      if (v16)
      {
        if (v18)
        {
          *buf = 136446466;
          v27 = "nw_interpose_cancel";
          v28 = 2082;
          v29 = v16;
          _os_log_impl(&dword_181A37000, v10, v17, "%{public}s called with null interpose, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v16);
        goto LABEL_37;
      }

      if (v18)
      {
        *buf = 136446210;
        v27 = "nw_interpose_cancel";
        _os_log_impl(&dword_181A37000, v10, v17, "%{public}s called with null interpose, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v22 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v27 = "nw_interpose_cancel";
        _os_log_impl(&dword_181A37000, v10, v22, "%{public}s called with null interpose, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_37:
  if (v9)
  {
    free(v9);
  }

LABEL_7:
}

void __nw_http_cookie_storage_copy_shared_block_invoke()
{
  v0 = objc_alloc_init(NWConcrete_nw_http_cookie_storage);
  v1 = nw_http_cookie_storage_copy_shared_storage;
  nw_http_cookie_storage_copy_shared_storage = v0;

  v2 = [MEMORY[0x1E695AC00] sharedHTTPCookieStorage];
  v3 = *(nw_http_cookie_storage_copy_shared_storage + 8);
  *(nw_http_cookie_storage_copy_shared_storage + 8) = v2;
}

NWConcrete_nw_http_cookie_storage *nw_http_cookie_storage_create_ns(void *a1)
{
  v1 = a1;
  v2 = objc_alloc_init(NWConcrete_nw_http_cookie_storage);
  cookieStorage = v2->cookieStorage;
  v2->cookieStorage = v1;

  return v2;
}

void __nw_http_cookie_enumerate_block_invoke(uint64_t a1, void *a2)
{
  v17 = *MEMORY[0x1E69E9840];
  v3 = a2;
  v4 = v3;
  if (v3)
  {
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v5)
    {
      v6 = v5;
      v7 = *v13;
      do
      {
        for (i = 0; i != v6; ++i)
        {
          if (*v13 != v7)
          {
            objc_enumerationMutation(v4);
          }

          v9 = *(*(&v12 + 1) + 8 * i);
          v10 = [v9 name];
          v11 = [v9 value];
          (*(*(a1 + 32) + 16))(*(a1 + 32), [v10 UTF8String], objc_msgSend(v11, "UTF8String"));
        }

        v6 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }

      while (v6);
    }
  }
}

uint64_t __nw_http_cookie_parse_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v6 = [objc_alloc(MEMORY[0x1E696AEC0]) initWithBytes:a4 length:a5 encoding:5];
  if (*(a1 + 40))
  {
    v7 = [MEMORY[0x1E696AEC0] stringWithUTF8String:?];
  }

  else
  {
    v7 = 0;
  }

  v8 = [MEMORY[0x1E695ABF8] _cookieForSetCookieString:v6 forURL:*(a1 + 48) partition:v7];
  if (v8)
  {
    [*(a1 + 32) addObject:v8];
  }

  return 1;
}

void nw_mem_buffer_manager_close(void *a1)
{
  v28 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_mem_buffer_manager_close";
    v11 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v11, &type, &v18))
    {
      goto LABEL_37;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_37;
      }

      *buf = 136446210;
      v21 = "nw_mem_buffer_manager_close";
      v14 = "%{public}s called with null buffer_manager";
    }

    else if (v18 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v13 = type;
      v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *buf = 136446466;
          v21 = "nw_mem_buffer_manager_close";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s called with null buffer_manager, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_37;
      }

      if (!v16)
      {
LABEL_37:
        if (v11)
        {
          free(v11);
        }

        return;
      }

      *buf = 136446210;
      v21 = "nw_mem_buffer_manager_close";
      v14 = "%{public}s called with null buffer_manager, no backtrace";
    }

    else
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
      {
        goto LABEL_37;
      }

      *buf = 136446210;
      v21 = "nw_mem_buffer_manager_close";
      v14 = "%{public}s called with null buffer_manager, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v12, v13, v14, buf, 0xCu);
    goto LABEL_37;
  }

  if ((use_malloc_memory & 1) == 0)
  {
    v2 = a1[11];
    if (v2)
    {
      os_unfair_lock_lock(&nw_mem_cache_lock);
      v3 = v2[10];
      v4 = v2[11];
      v5 = (v3 + 88);
      if (!v3)
      {
        v5 = &qword_1ED411060;
      }

      *v5 = v4;
      *v4 = v3;
      os_unfair_lock_unlock(&nw_mem_cache_lock);
      nw_mem_cache_magazine_purge(v2);
      if (v2[1])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
        v6 = v2[1];
        *buf = 136446978;
        v21 = "nw_mem_cache_destroy";
        v22 = 2082;
        v23 = (v2 + 12);
        v24 = 2048;
        v25 = v2;
        v26 = 2048;
        v27 = v6;
        v7 = _os_log_send_and_compose_impl();
        if (__nwlog_should_abort(v7))
        {
          __break(1u);
          return;
        }

        free(v7);
      }

      v2[23] = -1;
      v2[24] = -1;
      v2[25] = 0;
      v8 = v2[36];
      if (v8)
      {
        free(v8);
        v2[36] = 0;
      }

      if (gLogDatapath == 1)
      {
        v17 = __nwlog_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          *buf = 136446722;
          v21 = "nw_mem_cache_destroy";
          v22 = 2082;
          v23 = (v2 + 12);
          v24 = 2048;
          v25 = v2;
          _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s: nwm %p", buf, 0x20u);
        }
      }

      nw_mem_region_release(v2[27]);
      v2[27] = 0;
      v9 = *(v2 - 1);
      if (v9)
      {
        malloc_zone_free(g_slab_zone, v9);
      }

      a1[11] = 0;
    }

    v10 = a1[10];
    if (v10)
    {
      nw_mem_region_release(v10);
      a1[10] = 0;
    }
  }

  if (a1 != &g_buffer_manager)
  {

    free(a1);
  }
}

void ___ZL47nw_mem_slab_allocator_buffer_manager_initializeP19dispatch_workloop_sPKcmm_block_invoke()
{
  v31 = *MEMORY[0x1E69E9840];
  int64_with_default = networkd_settings_get_int64_with_default(nw_setting_slab_allocator_segment_size, 0x4000);
  if (int64_with_default <= 0x4000)
  {
    v1 = 0x4000;
  }

  else
  {
    v1 = int64_with_default;
  }

  v2 = -v1 & 0xFFFFC000;
  v3 = -v2;
  nw_mem_seg_size = -v2;
  if (!v2)
  {
    v19 = __nwlog_obj();
    os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    *buf = 136446466;
    v26 = "nw_mem_region_init";
    v27 = 2082;
    *v28 = "VERIFY nw_mem_seg_size != 0 && (nw_mem_seg_size % NW_MEM_PAGE_SIZE) == 0 failed";
    v20 = _os_log_send_and_compose_impl();
    if (__nwlog_should_abort(v20))
    {
      goto LABEL_42;
    }

    free(v20);
    v3 = nw_mem_seg_size;
  }

  v4 = networkd_settings_get_int64_with_default(nw_setting_slab_allocator_buffer_segment_size, v3);
  v5 = nw_mem_seg_size;
  if (nw_mem_seg_size <= v4)
  {
    v5 = v4;
  }

  nw_mem_buf_seg_size = -(-v5 & 0xFFFFC000);
  nw_mem_seg_min_buf_cnt = networkd_settings_get_int64_with_default(nw_setting_slab_allocator_buffer_count, 8);
  nw_mem_batch_seg_count = networkd_settings_get_int64_with_default(nw_setting_slab_allocator_batch_seg_count, 8);
  if (gLogDatapath == 1)
  {
    v21 = __nwlog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      *buf = 136447234;
      v26 = "nw_mem_region_init";
      v27 = 1024;
      *v28 = nw_mem_seg_size;
      *&v28[4] = 1024;
      *&v28[6] = nw_mem_buf_seg_size;
      *v29 = 1024;
      *&v29[2] = nw_mem_seg_min_buf_cnt;
      LOWORD(v30[0]) = 1024;
      *(v30 + 2) = nw_mem_batch_seg_count;
      _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_DEBUG, "%{public}s seg_size %u, buf_seg_size %u buf count %u batch seg count %u", buf, 0x24u);
    }
  }

  nw_mem_region_head = 0;
  qword_1ED411038 = &nw_mem_region_head;
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
  {
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }

  source = nw_queue_context_create_source(nw_context_copy_implicit_context::implicit_context, 2, 3, 0, &__block_literal_global_23523, 0);
  nw_mem_region_update_source = source;
  if (source)
  {
    v7 = source;
    v8 = dispatch_time(0x8000000000000000, 13000000000);
    if (*v7)
    {
      dispatch_source_set_timer(*v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    }

    else
    {
      *(v7 + 32) = v8;
      *(v7 + 40) = -1;
      if (*(v7 + 48) == 1 && *(v7 + 49) == 1)
      {
        nw_queue_source_run_timer(v7, v8);
      }
    }

    nw_queue_activate_source(nw_mem_region_update_source, v8);
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v26 = "nw_mem_region_init";
    v9 = _os_log_send_and_compose_impl();
    if (__nwlog_should_abort(v9))
    {
      goto LABEL_42;
    }

    free(v9);
  }

  LOBYTE(nw_mem_debug) = networkd_settings_get_int64_with_default(nw_setting_slab_allocator_debug, nw_mem_debug) & 3;
  nw_mem_debug = nw_mem_debug;
  nw_mem_dump_slab_stats = networkd_settings_get_BOOL(nw_setting_slab_allocator_dump_stats_enable);
  nw_mem_cache_head = 0;
  qword_1ED411060 = &nw_mem_cache_head;
  if (dword_1ED40FFA4 < 128 || (v10 = vcnt_s8(dword_1ED40FFA4), v10.i16[0] = vaddlv_u8(v10), v10.i32[0] >= 2u))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446466;
    v26 = "nw_mem_cache_init";
    v27 = 1024;
    *v28 = dword_1ED40FFA4;
    v11 = _os_log_send_and_compose_impl();
    if (__nwlog_should_abort(v11))
    {
      goto LABEL_42;
    }

    free(v11);
  }

  snprintf(byte_1ED40FFB8, 0x40uLL, "%s_mem_mg_%d", "NWSlab", nw_mem_magtype);
  if (nw_mem_magtype > nw_mem_cache_magsize_max)
  {
    nw_mem_cache_magsize_max = nw_mem_magtype;
  }

  os_unfair_lock_lock(&nw_mem_cache_lock);
  v13 = nw_mem_cache_head;
  if (nw_mem_cache_head)
  {
    *&v12 = 136446978;
    do
    {
      if ((*(v13 + 176) & 1) == 0)
      {
        *(v13 + 560) = **(v13 + 336);
        if (gLogDatapath == 1)
        {
          v24 = v12;
          v14 = __nwlog_obj();
          v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
          v12 = v24;
          if (v15)
          {
            v16 = *(v13 + 232);
            v17 = *(v13 + 560);
            *buf = v24;
            v26 = "nw_mem_cache_magazine_enable";
            v27 = 2048;
            *v28 = v13;
            *&v28[8] = 1024;
            *v29 = v16;
            *&v29[4] = 1024;
            v30[0] = v17;
            _os_log_impl(&dword_181A37000, v14, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p chunksize %u magsize %d", buf, 0x22u);
            v12 = v24;
          }
        }
      }

      v13 = *(v13 + 80);
    }

    while (v13);
  }

  os_unfair_lock_unlock(&nw_mem_cache_lock);
  nw_mem_cache_ready = 1;
  if (nw_mem_dump_slab_stats == 1)
  {
    atexit(nw_mem_cache_stats_dump);
  }

  zone = malloc_create_zone((((dword_1ED40FFA4 + 8 * nw_mem_magtype) << 9) + 556288), 0);
  g_slab_zone = zone;
  if (zone)
  {
    goto LABEL_35;
  }

  v22 = __nwlog_obj();
  os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
  *buf = 136446210;
  v26 = "nw_mem_allocate_zone";
  v23 = _os_log_send_and_compose_impl();
  if (!__nwlog_should_abort(v23))
  {
    free(v23);
    zone = g_slab_zone;
LABEL_35:
    malloc_set_zone_name(zone, "NWMallocZone");
    return;
  }

LABEL_42:
  __break(1u);
}

nw_path_monitor_t nw_path_monitor_create_with_type(nw_interface_type_t required_interface_type)
{
  v2 = _nw_parameters_create();
  nw_parameters_set_multipath_service(v2, nw_multipath_service_handover);
  nw_parameters_set_required_interface_type(v2, required_interface_type);
  evaluator_for_endpoint_no_evaluate = nw_path_create_evaluator_for_endpoint_no_evaluate(0, v2);

  return evaluator_for_endpoint_no_evaluate;
}

nw_path_monitor_t nw_path_monitor_create_for_ethernet_channel(void)
{
  v0 = _nw_parameters_create();
  v1 = nw_path_create_evaluator_for_all_custom_ether_interfaces(v0);

  return v1;
}

void nw_path_monitor_prohibit_interface_type(nw_path_monitor_t monitor, nw_interface_type_t interface_type)
{
  v2 = *&interface_type;
  v29 = *MEMORY[0x1E69E9840];
  v3 = monitor;
  v4 = v3;
  if (v3)
  {
    v5 = v3;
    os_unfair_lock_lock(&v5[12]);
    v6 = v5[1].isa;
    os_unfair_lock_unlock(&v5[12]);

    if (v6)
    {
      _nw_parameters_prohibit_interface_type(v6, v2);
LABEL_4:

      goto LABEL_5;
    }

    v11 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_path_monitor_prohibit_interface_type";
    v12 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v12, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v13 = __nwlog_obj();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *buf = 136446210;
          v26 = "nw_path_monitor_prohibit_interface_type";
          _os_log_impl(&dword_181A37000, v13, v14, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else if (v23 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v13 = __nwlog_obj();
        v19 = type;
        v20 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *buf = 136446466;
            v26 = "nw_path_monitor_prohibit_interface_type";
            v27 = 2082;
            v28 = backtrace_string;
            _os_log_impl(&dword_181A37000, v13, v19, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_40;
        }

        if (v20)
        {
          *buf = 136446210;
          v26 = "nw_path_monitor_prohibit_interface_type";
          _os_log_impl(&dword_181A37000, v13, v19, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v13 = __nwlog_obj();
        v22 = type;
        if (os_log_type_enabled(v13, type))
        {
          *buf = 136446210;
          v26 = "nw_path_monitor_prohibit_interface_type";
          _os_log_impl(&dword_181A37000, v13, v22, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_40:
    if (v12)
    {
      free(v12);
    }

    goto LABEL_4;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  v26 = "nw_path_monitor_prohibit_interface_type";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (__nwlog_fault(v8, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v26 = "nw_path_monitor_prohibit_interface_type";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null monitor", buf, 0xCu);
      }
    }

    else if (v23 == 1)
    {
      v15 = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (v15)
      {
        if (v17)
        {
          *buf = 136446466;
          v26 = "nw_path_monitor_prohibit_interface_type";
          v27 = 2082;
          v28 = v15;
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v15);
        goto LABEL_35;
      }

      if (v17)
      {
        *buf = 136446210;
        v26 = "nw_path_monitor_prohibit_interface_type";
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v21 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v26 = "nw_path_monitor_prohibit_interface_type";
        _os_log_impl(&dword_181A37000, v9, v21, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_35:
  if (v8)
  {
    free(v8);
  }

LABEL_5:
}

void sub_182902CA4(_Unwind_Exception *a1)
{
  objc_destroyWeak((v1 + 40));
  objc_destroyWeak((v2 - 40));
  _Unwind_Resume(a1);
}

__int128 *nw_socket_protocol_identifier()
{
  if (nw_socket_protocol_identifier::onceToken[0] != -1)
  {
    dispatch_once(nw_socket_protocol_identifier::onceToken, &__block_literal_global_67171);
  }

  return &nw_socket_protocol_identifier::identifier;
}

void nw_protocol_socket_notify(char *a1, uint64_t a2, int a3, unsigned __int8 *a4, uint64_t a5)
{
  v45 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v5 = a1;
    v6 = *(a1 + 5);
    v7 = a1;
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      goto LABEL_6;
    }

    if (v6 != &nw_protocol_ref_counted_additional_handle)
    {
      v8 = 1;
      goto LABEL_11;
    }

    v7 = *(a1 + 8);
    if (v7)
    {
LABEL_6:
      v9 = *(v7 + 11);
      v8 = 0;
      if (v9)
      {
        *(v7 + 11) = v9 + 1;
      }
    }

    else
    {
      v8 = 1;
    }

    v6 = *(a1 + 5);
LABEL_11:
    v10 = a1;
    if (v6 != &nw_protocol_ref_counted_handle)
    {
      if (v6 != &nw_protocol_ref_counted_additional_handle)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *buf = 136446210;
        v40 = "nw_protocol_socket_notify";
        v11 = _os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v37 = 0;
        if (!__nwlog_fault(v11, &type, &v37))
        {
          goto LABEL_36;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = gLogObj;
          v13 = type;
          if (!os_log_type_enabled(gLogObj, type))
          {
            goto LABEL_36;
          }

          *buf = 136446210;
          v40 = "nw_protocol_socket_notify";
          v14 = "%{public}s called with null socket_handler";
          goto LABEL_34;
        }

        if (v37 != 1)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = gLogObj;
          v13 = type;
          if (!os_log_type_enabled(gLogObj, type))
          {
            goto LABEL_36;
          }

          *buf = 136446210;
          v40 = "nw_protocol_socket_notify";
          v14 = "%{public}s called with null socket_handler, backtrace limit exceeded";
          goto LABEL_34;
        }

        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        v19 = type;
        v20 = os_log_type_enabled(gLogObj, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *buf = 136446466;
            v40 = "nw_protocol_socket_notify";
            v41 = 2082;
            v42 = backtrace_string;
            _os_log_impl(&dword_181A37000, v18, v19, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
        }

        else if (v20)
        {
          *buf = 136446210;
          v40 = "nw_protocol_socket_notify";
          v14 = "%{public}s called with null socket_handler, no backtrace";
          v21 = v18;
          v22 = v19;
          goto LABEL_35;
        }

LABEL_36:
        if (!v11)
        {
          goto LABEL_38;
        }

        goto LABEL_37;
      }

      v10 = *(a1 + 8);
    }

    if (a3 != 16)
    {
      goto LABEL_38;
    }

    if (a4)
    {
      if (a5 == 1)
      {
        v15 = *a4;
        if ((*(v10 + 413) & 0x80) == 0)
        {
          if (__nwlog_connection_log::onceToken[0] != -1)
          {
            dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
          }

          v16 = gconnectionLogObj;
          if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
          {
            *buf = 136446722;
            v40 = "nw_protocol_socket_notify";
            v41 = 2082;
            v42 = v10 + 420;
            v43 = 1024;
            v44 = v15;
            _os_log_impl(&dword_181A37000, v16, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s nw_protocol_notification_type_connection_idle is %{BOOL}d", buf, 0x1Cu);
          }
        }

        nw_socket_set_connection_idle((v10 + 12), v15);
        goto LABEL_38;
      }

      __nwlog_obj();
      *buf = 136446210;
      v40 = "nw_protocol_socket_notify";
      v11 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v37 = 0;
      if (!__nwlog_fault(v11, &type, &v37))
      {
        goto LABEL_36;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
        {
          goto LABEL_36;
        }

        *buf = 136446210;
        v40 = "nw_protocol_socket_notify";
        v14 = "%{public}s called with null (len == sizeof(BOOL))";
        goto LABEL_34;
      }

      if (v37 == 1)
      {
        v33 = __nw_create_backtrace_string();
        v12 = __nwlog_obj();
        v13 = type;
        v36 = os_log_type_enabled(v12, type);
        if (v33)
        {
          if (!v36)
          {
            goto LABEL_82;
          }

          *buf = 136446466;
          v40 = "nw_protocol_socket_notify";
          v41 = 2082;
          v42 = v33;
          v35 = "%{public}s called with null (len == sizeof(BOOL)), dumping backtrace:%{public}s";
LABEL_81:
          _os_log_impl(&dword_181A37000, v12, v13, v35, buf, 0x16u);
LABEL_82:
          free(v33);
          if (v11)
          {
LABEL_37:
            free(v11);
          }

LABEL_38:
          if ((v8 & 1) == 0)
          {
            v23 = *(v5 + 5);
            if (v23 == &nw_protocol_ref_counted_handle || v23 == &nw_protocol_ref_counted_additional_handle && (v5 = *(v5 + 8)) != 0)
            {
              v24 = *(v5 + 11);
              if (v24)
              {
                v25 = v24 - 1;
                *(v5 + 11) = v25;
                if (!v25)
                {
                  v26 = *(v5 + 8);
                  if (v26)
                  {
                    *(v5 + 8) = 0;
                    v26[2](v26);
                    _Block_release(v26);
                  }

                  if (v5[72])
                  {
                    v27 = *(v5 + 8);
                    if (v27)
                    {
                      _Block_release(v27);
                    }
                  }

                  goto LABEL_49;
                }
              }
            }
          }

          return;
        }

        if (!v36)
        {
          goto LABEL_36;
        }

        *buf = 136446210;
        v40 = "nw_protocol_socket_notify";
        v14 = "%{public}s called with null (len == sizeof(BOOL)), no backtrace";
      }

      else
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
        {
          goto LABEL_36;
        }

        *buf = 136446210;
        v40 = "nw_protocol_socket_notify";
        v14 = "%{public}s called with null (len == sizeof(BOOL)), backtrace limit exceeded";
      }
    }

    else
    {
      __nwlog_obj();
      *buf = 136446210;
      v40 = "nw_protocol_socket_notify";
      v11 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v37 = 0;
      if (!__nwlog_fault(v11, &type, &v37))
      {
        goto LABEL_36;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
        {
          goto LABEL_36;
        }

        *buf = 136446210;
        v40 = "nw_protocol_socket_notify";
        v14 = "%{public}s called with null (val != nil)";
        goto LABEL_34;
      }

      if (v37 == 1)
      {
        v33 = __nw_create_backtrace_string();
        v12 = __nwlog_obj();
        v13 = type;
        v34 = os_log_type_enabled(v12, type);
        if (v33)
        {
          if (!v34)
          {
            goto LABEL_82;
          }

          *buf = 136446466;
          v40 = "nw_protocol_socket_notify";
          v41 = 2082;
          v42 = v33;
          v35 = "%{public}s called with null (val != nil), dumping backtrace:%{public}s";
          goto LABEL_81;
        }

        if (!v34)
        {
          goto LABEL_36;
        }

        *buf = 136446210;
        v40 = "nw_protocol_socket_notify";
        v14 = "%{public}s called with null (val != nil), no backtrace";
      }

      else
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
        {
          goto LABEL_36;
        }

        *buf = 136446210;
        v40 = "nw_protocol_socket_notify";
        v14 = "%{public}s called with null (val != nil), backtrace limit exceeded";
      }
    }

LABEL_34:
    v21 = v12;
    v22 = v13;
LABEL_35:
    _os_log_impl(&dword_181A37000, v21, v22, v14, buf, 0xCu);
    goto LABEL_36;
  }

  __nwlog_obj();
  *buf = 136446210;
  v40 = "nw_protocol_socket_notify";
  v5 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v5, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (!os_log_type_enabled(v28, type))
      {
        goto LABEL_87;
      }

      *buf = 136446210;
      v40 = "nw_protocol_socket_notify";
      v30 = "%{public}s called with null protocol";
    }

    else if (v37 == 1)
    {
      v31 = __nw_create_backtrace_string();
      v28 = __nwlog_obj();
      v29 = type;
      v32 = os_log_type_enabled(v28, type);
      if (v31)
      {
        if (v32)
        {
          *buf = 136446466;
          v40 = "nw_protocol_socket_notify";
          v41 = 2082;
          v42 = v31;
          _os_log_impl(&dword_181A37000, v28, v29, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v31);
        if (v5)
        {
          goto LABEL_49;
        }

        return;
      }

      if (!v32)
      {
        goto LABEL_87;
      }

      *buf = 136446210;
      v40 = "nw_protocol_socket_notify";
      v30 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (!os_log_type_enabled(v28, type))
      {
        goto LABEL_87;
      }

      *buf = 136446210;
      v40 = "nw_protocol_socket_notify";
      v30 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v28, v29, v30, buf, 0xCu);
  }

LABEL_87:
  if (v5)
  {
LABEL_49:
    free(v5);
  }
}

void nw_socket_set_connection_idle(uint64_t a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    *type = a2;
    if (setsockopt(*(a1 + 188), 0xFFFF, 4407, type, 4u))
    {
      v3 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
      }

      v4 = gconnectionLogObj;
      if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446722;
        v14 = "nw_socket_set_connection_idle";
        v15 = 2082;
        v16 = (a1 + 324);
        v17 = 1024;
        v18 = v3;
        _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}s setsockopt SO_CONNECTION_IDLE failed %{darwin.errno}d", buf, 0x1Cu);
      }
    }

    return;
  }

  __nwlog_obj();
  *buf = 136446210;
  v14 = "nw_socket_set_connection_idle";
  v5 = _os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, type, &v12))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type[0];
      if (!os_log_type_enabled(v6, type[0]))
      {
        goto LABEL_22;
      }

      *buf = 136446210;
      v14 = "nw_socket_set_connection_idle";
      v8 = "%{public}s called with null socket_handler";
      goto LABEL_21;
    }

    if (v12 != 1)
    {
      v6 = __nwlog_obj();
      v7 = type[0];
      if (!os_log_type_enabled(v6, type[0]))
      {
        goto LABEL_22;
      }

      *buf = 136446210;
      v14 = "nw_socket_set_connection_idle";
      v8 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_21;
    }

    backtrace_string = __nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type[0];
    v10 = os_log_type_enabled(v6, type[0]);
    if (backtrace_string)
    {
      if (v10)
      {
        *buf = 136446466;
        v14 = "nw_socket_set_connection_idle";
        v15 = 2082;
        v16 = backtrace_string;
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
      goto LABEL_22;
    }

    if (v10)
    {
      *buf = 136446210;
      v14 = "nw_socket_set_connection_idle";
      v8 = "%{public}s called with null socket_handler, no backtrace";
LABEL_21:
      _os_log_impl(&dword_181A37000, v6, v7, v8, buf, 0xCu);
    }
  }

LABEL_22:
  if (v5)
  {
    free(v5);
  }
}

uint64_t nw_socket_unregister_notification(uint64_t a1, uint64_t a2, int a3)
{
  v52 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v3 = a1;
    v4 = *(a1 + 40);
    v5 = a1;
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      goto LABEL_6;
    }

    if (v4 != &nw_protocol_ref_counted_additional_handle)
    {
      v6 = 1;
      goto LABEL_11;
    }

    v5 = *(a1 + 64);
    if (v5)
    {
LABEL_6:
      v7 = *(v5 + 88);
      v6 = 0;
      if (v7)
      {
        *(v5 + 88) = v7 + 1;
      }
    }

    else
    {
      v6 = 1;
    }

    v4 = *(a1 + 40);
LABEL_11:
    v8 = a1;
    if (v4 != &nw_protocol_ref_counted_handle)
    {
      if (v4 != &nw_protocol_ref_counted_additional_handle)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *buf = 136446210;
        v45 = "nw_socket_unregister_notification";
        v9 = _os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v42 = 0;
        if (!__nwlog_fault(v9, &type, &v42))
        {
          goto LABEL_51;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = gLogObj;
          v11 = type;
          if (!os_log_type_enabled(gLogObj, type))
          {
            goto LABEL_51;
          }

          *buf = 136446210;
          v45 = "nw_socket_unregister_notification";
          v12 = "%{public}s called with null socket_handler";
        }

        else
        {
          if (v42 == 1)
          {
            backtrace_string = __nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v16 = gLogObj;
            v17 = type;
            v18 = os_log_type_enabled(gLogObj, type);
            if (backtrace_string)
            {
              if (v18)
              {
                *buf = 136446466;
                v45 = "nw_socket_unregister_notification";
                v46 = 2082;
                v47 = backtrace_string;
                _os_log_impl(&dword_181A37000, v16, v17, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(backtrace_string);
              if (!v9)
              {
                goto LABEL_53;
              }

              goto LABEL_52;
            }

            if (!v18)
            {
              goto LABEL_51;
            }

            *buf = 136446210;
            v45 = "nw_socket_unregister_notification";
            v12 = "%{public}s called with null socket_handler, no backtrace";
            v23 = v16;
            v24 = v17;
            goto LABEL_49;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = gLogObj;
          v11 = type;
          if (!os_log_type_enabled(gLogObj, type))
          {
            goto LABEL_51;
          }

          *buf = 136446210;
          v45 = "nw_socket_unregister_notification";
          v12 = "%{public}s called with null socket_handler, backtrace limit exceeded";
        }

        v23 = v10;
        v24 = v11;
LABEL_49:
        v25 = 12;
LABEL_50:
        _os_log_impl(&dword_181A37000, v23, v24, v12, buf, v25);
        goto LABEL_51;
      }

      v8 = *(a1 + 64);
    }

    result = 0;
    if (a3 > 1)
    {
      if (a3 != 2)
      {
        if (a3 != 3)
        {
          goto LABEL_54;
        }

        result = nw_socket_add_socket_events(v8 + 96, 0, 256, 0);
        if (v6)
        {
          return result;
        }

LABEL_55:
        v26 = *(v3 + 40);
        if (v26 == &nw_protocol_ref_counted_handle || v26 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
        {
          v27 = *(v3 + 88);
          if (v27)
          {
            v28 = v27 - 1;
            *(v3 + 88) = v28;
            if (!v28)
            {
              v29 = result;
              v30 = *(v3 + 64);
              if (v30)
              {
                *(v3 + 64) = 0;
                v30[2](v30);
                _Block_release(v30);
              }

              if (*(v3 + 72))
              {
                v31 = *(v3 + 64);
                if (v31)
                {
                  _Block_release(v31);
                }
              }

              free(v3);
              return v29;
            }
          }
        }

        return result;
      }

      v22 = *(v8 + 308);
      *(v8 + 308) = 0;
      if ((nw_socket_add_socket_events(v8 + 96, 0, 512, 0) & 1) == 0)
      {
        result = 0;
        *(v8 + 308) = v22;
        if (v6)
        {
          return result;
        }

        goto LABEL_55;
      }

LABEL_44:
      result = 1;
      if (v6)
      {
        return result;
      }

      goto LABEL_55;
    }

    if (a3)
    {
      if (a3 != 1)
      {
        goto LABEL_54;
      }

      v14 = *(v8 + 304);
      *(v8 + 304) = 0;
      if ((nw_socket_add_socket_events(v8 + 96, 0, 1024, 0) & 1) == 0)
      {
        result = 0;
        *(v8 + 304) = v14;
        if (v6)
        {
          return result;
        }

        goto LABEL_55;
      }

      goto LABEL_44;
    }

    if ((*(v8 + 413) & 0x80) != 0)
    {
      goto LABEL_53;
    }

    if (__nwlog_connection_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
    }

    v19 = (v8 + 420);
    *buf = 136446722;
    v45 = "nw_socket_unregister_notification";
    v46 = 2082;
    v47 = (v8 + 420);
    v48 = 2082;
    v49 = "undefined";
    v9 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v9, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken[0] != -1)
        {
          dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
        }

        v20 = gconnectionLogObj;
        v21 = type;
        if (os_log_type_enabled(gconnectionLogObj, type))
        {
          *buf = 136446722;
          v45 = "nw_socket_unregister_notification";
          v46 = 2082;
          v47 = v19;
          v48 = 2082;
          v49 = "undefined";
          v12 = "%{public}s %{public}s invalid registration notification: %{public}s";
LABEL_81:
          v23 = v20;
          v24 = v21;
LABEL_82:
          v25 = 32;
          goto LABEL_50;
        }
      }

      else if (v42 == 1)
      {
        v32 = __nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken[0] != -1)
        {
          dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
        }

        v33 = gconnectionLogObj;
        v34 = type;
        v35 = os_log_type_enabled(gconnectionLogObj, type);
        if (v32)
        {
          if (v35)
          {
            *buf = 136446978;
            v45 = "nw_socket_unregister_notification";
            v46 = 2082;
            v47 = v19;
            v48 = 2082;
            v49 = "undefined";
            v50 = 2082;
            v51 = v32;
            _os_log_impl(&dword_181A37000, v33, v34, "%{public}s %{public}s invalid registration notification: %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v32);
        }

        else if (v35)
        {
          *buf = 136446722;
          v45 = "nw_socket_unregister_notification";
          v46 = 2082;
          v47 = v19;
          v48 = 2082;
          v49 = "undefined";
          v12 = "%{public}s %{public}s invalid registration notification: %{public}s, no backtrace";
          v23 = v33;
          v24 = v34;
          goto LABEL_82;
        }
      }

      else
      {
        if (__nwlog_connection_log::onceToken[0] != -1)
        {
          dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
        }

        v20 = gconnectionLogObj;
        v21 = type;
        if (os_log_type_enabled(gconnectionLogObj, type))
        {
          *buf = 136446722;
          v45 = "nw_socket_unregister_notification";
          v46 = 2082;
          v47 = v19;
          v48 = 2082;
          v49 = "undefined";
          v12 = "%{public}s %{public}s invalid registration notification: %{public}s, backtrace limit exceeded";
          goto LABEL_81;
        }
      }
    }

LABEL_51:
    if (v9)
    {
LABEL_52:
      free(v9);
    }

LABEL_53:
    result = 0;
LABEL_54:
    if (v6)
    {
      return result;
    }

    goto LABEL_55;
  }

  __nwlog_obj();
  *buf = 136446210;
  v45 = "nw_socket_unregister_notification";
  v36 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (__nwlog_fault(v36, &type, &v42))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v37 = __nwlog_obj();
      v38 = type;
      if (os_log_type_enabled(v37, type))
      {
        *buf = 136446210;
        v45 = "nw_socket_unregister_notification";
        v39 = "%{public}s called with null protocol";
LABEL_98:
        _os_log_impl(&dword_181A37000, v37, v38, v39, buf, 0xCu);
      }
    }

    else if (v42 == 1)
    {
      v40 = __nw_create_backtrace_string();
      v37 = __nwlog_obj();
      v38 = type;
      v41 = os_log_type_enabled(v37, type);
      if (v40)
      {
        if (v41)
        {
          *buf = 136446466;
          v45 = "nw_socket_unregister_notification";
          v46 = 2082;
          v47 = v40;
          _os_log_impl(&dword_181A37000, v37, v38, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v40);
        goto LABEL_99;
      }

      if (v41)
      {
        *buf = 136446210;
        v45 = "nw_socket_unregister_notification";
        v39 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_98;
      }
    }

    else
    {
      v37 = __nwlog_obj();
      v38 = type;
      if (os_log_type_enabled(v37, type))
      {
        *buf = 136446210;
        v45 = "nw_socket_unregister_notification";
        v39 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_98;
      }
    }
  }

LABEL_99:
  if (v36)
  {
    free(v36);
  }

  return 0;
}

uint64_t __Block_byref_object_copy__67231(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(result + 48) = *(result + 48) & 0xFE | *(a2 + 48) & 1;
  *(a2 + 40) = 0;
  *(a2 + 48) &= ~1u;
  return result;
}

uint64_t __Block_byref_object_copy__37_67233(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(result + 48) = *(result + 48) & 0xFE | *(a2 + 48) & 1;
  *(a2 + 40) = 0;
  *(a2 + 48) &= ~1u;
  return result;
}

uint64_t __Block_byref_object_dispose__38_67234(uint64_t result)
{
  if ((*(result + 48) & 1) != 0 && *(result + 40))
  {
    v1 = result;
    os_release(*(result + 40));
    result = v1;
  }

  *(result + 40) = 0;
  return result;
}

void nw_socket_set_maximum_segment_size(uint64_t a1, int a2)
{
  v21 = *MEMORY[0x1E69E9840];
  if (*(a1 + 192) == 2)
  {
    if ((*(a1 + 317) & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
      }

      v4 = gconnectionLogObj;
      if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 136446722;
        v18 = "nw_socket_set_maximum_segment_size";
        v19 = 2082;
        *v20 = a1 + 324;
        *&v20[8] = 1024;
        *&v20[10] = a2;
        _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s setting MSS to %u", buf, 0x1Cu);
      }
    }

    v16 = a2;
    if (setsockopt(*(a1 + 188), 6, 2, &v16, 4u))
    {
      v5 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
      }

      v6 = gconnectionLogObj;
      if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446722;
        v18 = "nw_socket_set_maximum_segment_size";
        v19 = 2082;
        *v20 = a1 + 324;
        *&v20[8] = 1024;
        *&v20[10] = v5;
        _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d", buf, 0x1Cu);
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      if (v5 == 22)
      {
        if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
        {
          *buf = 136446466;
          v18 = "nw_socket_set_maximum_segment_size";
          v19 = 1024;
          *v20 = 22;
          _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d", buf, 0x12u);
        }

        return;
      }

      *buf = 136446466;
      v18 = "nw_socket_set_maximum_segment_size";
      v19 = 1024;
      *v20 = v5;
      v8 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v14 = 0;
      if (!__nwlog_fault(v8, &type, &v14))
      {
        goto LABEL_29;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_29;
        }

        *buf = 136446466;
        v18 = "nw_socket_set_maximum_segment_size";
        v19 = 1024;
        *v20 = v5;
        v11 = "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d";
      }

      else if (v14 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        v13 = os_log_type_enabled(gLogObj, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *buf = 136446722;
            v18 = "nw_socket_set_maximum_segment_size";
            v19 = 1024;
            *v20 = v5;
            *&v20[4] = 2082;
            *&v20[6] = backtrace_string;
            _os_log_impl(&dword_181A37000, v9, v10, "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(backtrace_string);
          goto LABEL_29;
        }

        if (!v13)
        {
LABEL_29:
          if (v8)
          {
            free(v8);
          }

          return;
        }

        *buf = 136446466;
        v18 = "nw_socket_set_maximum_segment_size";
        v19 = 1024;
        *v20 = v5;
        v11 = "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d, no backtrace";
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_29;
        }

        *buf = 136446466;
        v18 = "nw_socket_set_maximum_segment_size";
        v19 = 1024;
        *v20 = v5;
        v11 = "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A37000, v9, v10, v11, buf, 0x12u);
      goto LABEL_29;
    }
  }
}

void ___ZL29nw_socket_handle_socket_eventP9nw_socket_block_invoke(uint64_t a1)
{
  nw_socket_update_output_source(*(a1 + 40));
  v2 = *(a1 + 40);
  if ((*(v2 + 317) & 0x200) != 0)
  {
    nw_socket_update_input_source(v2);
  }

  v3 = *(*(*(a1 + 32) + 8) + 24);
  if (v3)
  {
    v4 = *(v3 + 40);
    if (v4 == &nw_protocol_ref_counted_handle || v4 == &nw_protocol_ref_counted_additional_handle && (v3 = *(v3 + 64)) != 0)
    {
      v5 = *(v3 + 88);
      if (v5)
      {
        v6 = v5 - 1;
        *(v3 + 88) = v6;
        if (!v6)
        {
          v7 = *(v3 + 64);
          if (v7)
          {
            *(v3 + 64) = 0;
            v7[2](v7);
            _Block_release(v7);
          }

          if (*(v3 + 72))
          {
            v8 = *(v3 + 64);
            if (v8)
            {
              _Block_release(v8);
            }
          }

          free(v3);
        }
      }
    }
  }
}

void nw_socket_internal_error(uint64_t a1)
{
  v25 = *MEMORY[0x1E69E9840];
  v1 = *(a1 + 56);
  if (v1)
  {
    v2 = *(v1 + 24);
    if (v2)
    {
      v3 = *(v2 + 56);
      if (v3)
      {

        v3();
        return;
      }
    }

    v4 = v1;
    __nwlog_obj();
    v5 = v4;
    v6 = *(v4 + 16);
    if (!v6)
    {
      v6 = "invalid";
    }
  }

  else
  {
    v5 = 0;
    __nwlog_obj();
    v6 = "invalid";
  }

  *buf = 136446466;
  v20 = "nw_socket_internal_error";
  v21 = 2082;
  v22 = v6;
  v7 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_37;
      }

      v10 = "invalid";
      if (v5 && *(v5 + 16))
      {
        v10 = *(v5 + 16);
      }

      *buf = 136446466;
      v20 = "nw_socket_internal_error";
      v21 = 2082;
      v22 = v10;
      v11 = "%{public}s protocol %{public}s has invalid error callback";
      goto LABEL_36;
    }

    if (v17 != 1)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
      {
        goto LABEL_37;
      }

      v15 = "invalid";
      if (v5 && *(v5 + 16))
      {
        v15 = *(v5 + 16);
      }

      *buf = 136446466;
      v20 = "nw_socket_internal_error";
      v21 = 2082;
      v22 = v15;
      v11 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
      goto LABEL_36;
    }

    backtrace_string = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v13 = os_log_type_enabled(v8, type);
    if (backtrace_string)
    {
      if (v13)
      {
        v14 = "invalid";
        if (v5 && *(v5 + 16))
        {
          v14 = *(v5 + 16);
        }

        *buf = 136446722;
        v20 = "nw_socket_internal_error";
        v21 = 2082;
        v22 = v14;
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
      }

      free(backtrace_string);
      goto LABEL_37;
    }

    if (v13)
    {
      v16 = "invalid";
      if (v5 && *(v5 + 16))
      {
        v16 = *(v5 + 16);
      }

      *buf = 136446466;
      v20 = "nw_socket_internal_error";
      v21 = 2082;
      v22 = v16;
      v11 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
LABEL_36:
      _os_log_impl(&dword_181A37000, v8, v9, v11, buf, 0x16u);
    }
  }

LABEL_37:
  if (v7)
  {
    free(v7);
  }
}

void nw_socket_update_output_source(uint64_t a1)
{
  v24 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v2 = (a1 + 317);
    if ((*(a1 + 317) & 0x4000) == 0)
    {
      if ((*(a1 + 319) & 0x40) != 0)
      {
        nw_socket_internal_link_state(a1, 0);
      }

      if (nw_socket_service_writes(a1))
      {
        v4 = *v2;
        if ((*v2 & 8) != 0)
        {
          nw_socket_output_finished((a1 - 96), v3);
          v4 = *v2;
        }

        if ((v4 & 0x40) != 0)
        {
          if ((v4 & 8) == 0 && (!*(a1 + 248) || (*(a1 + 319) & 4) != 0))
          {

            nw_socket_internal_disconnect(a1);
          }
        }

        else
        {
          v5 = *(a1 + 56);
          if (v5)
          {
            v6 = *(v5 + 24);
            if (v6)
            {
              v7 = *(v6 + 72);
              if (v7)
              {

                v7();
              }
            }
          }
        }
      }
    }

    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446210;
  v21 = "nw_socket_update_output_source";
  v8 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (__nwlog_fault(v8, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_28;
      }

      *buf = 136446210;
      v21 = "nw_socket_update_output_source";
      v11 = "%{public}s called with null socket_handler";
LABEL_26:
      v16 = v9;
      v17 = v10;
LABEL_27:
      _os_log_impl(&dword_181A37000, v16, v17, v11, buf, 0xCu);
      goto LABEL_28;
    }

    if (v18 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_28;
      }

      *buf = 136446210;
      v21 = "nw_socket_update_output_source";
      v11 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_26;
    }

    backtrace_string = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = gLogObj;
    v14 = type;
    v15 = os_log_type_enabled(gLogObj, type);
    if (backtrace_string)
    {
      if (v15)
      {
        *buf = 136446466;
        v21 = "nw_socket_update_output_source";
        v22 = 2082;
        v23 = backtrace_string;
        _os_log_impl(&dword_181A37000, v13, v14, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
      goto LABEL_28;
    }

    if (v15)
    {
      *buf = 136446210;
      v21 = "nw_socket_update_output_source";
      v11 = "%{public}s called with null socket_handler, no backtrace";
      v16 = v13;
      v17 = v14;
      goto LABEL_27;
    }
  }

LABEL_28:
  if (v8)
  {
    free(v8);
  }
}

void nw_socket_update_input_source(uint64_t a1)
{
  v26 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v21 = "nw_socket_update_input_source";
    v6 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v6, &type, &v18))
    {
      goto LABEL_33;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_33;
      }

      *buf = 136446210;
      v21 = "nw_socket_update_input_source";
      v9 = "%{public}s called with null socket_handler";
    }

    else
    {
      if (v18 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v12 = type;
        v13 = os_log_type_enabled(gLogObj, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *buf = 136446466;
            v21 = "nw_socket_update_input_source";
            v22 = 2082;
            v23 = backtrace_string;
            _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_33;
        }

        if (!v13)
        {
LABEL_33:
          if (v6)
          {
            free(v6);
          }

          return;
        }

        *buf = 136446210;
        v21 = "nw_socket_update_input_source";
        v9 = "%{public}s called with null socket_handler, no backtrace";
        v14 = v11;
        v15 = v12;
LABEL_32:
        _os_log_impl(&dword_181A37000, v14, v15, v9, buf, 0xCu);
        goto LABEL_33;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_33;
      }

      *buf = 136446210;
      v21 = "nw_socket_update_input_source";
      v9 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    }

    v14 = v7;
    v15 = v8;
    goto LABEL_32;
  }

  v2 = (a1 + 317);
  if ((*(a1 + 317) & 0x80) == 0 && gLogDatapath == 1)
  {
    if (__nwlog_connection_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
    }

    v16 = gconnectionLogObj;
    if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v17 = *(a1 + 188);
      *buf = 136446722;
      v21 = "nw_socket_update_input_source";
      v22 = 2082;
      v23 = (a1 + 324);
      v24 = 1024;
      v25 = v17;
      _os_log_impl(&dword_181A37000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Input available for %d", buf, 0x1Cu);
    }
  }

  if ((*v2 & 0x4000) == 0)
  {
    *v2 |= 0x200u;
    if (_nw_signposts_once != -1)
    {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_22_67263);
    }

    if (_nw_signposts_enabled == 1 && kdebug_is_enabled())
    {
      kdebug_trace();
      v3 = *(a1 + 56);
      if (v3)
      {
        goto LABEL_10;
      }
    }

    else
    {
      v3 = *(a1 + 56);
      if (v3)
      {
LABEL_10:
        v4 = *(v3 + 24);
        if (v4)
        {
          v5 = *(v4 + 64);
          if (v5)
          {
            v5();
          }
        }
      }
    }

    if ((*v2 & 0x600) == 0x200)
    {
      if (_nw_signposts_once != -1)
      {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_22_67263);
      }

      if (_nw_signposts_enabled == 1)
      {
        if (kdebug_is_enabled())
        {
          kdebug_trace();
        }
      }

      nw_queue_suspend_source(*(a1 + 128));
      *v2 |= 0x400u;
    }
  }
}

void nw_socket_internal_link_state(uint64_t a1, int a2)
{
  v18 = *MEMORY[0x1E69E9840];
  v4 = *(a1 + 56);
  v5 = *(a1 + 160);
  if (v5)
  {
    v6 = v5;
    v7 = v6[2];
    v6[2] = a2;

    if (v7 == a2)
    {
      if (gLogDatapath == 1)
      {
        v8 = __nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v14 = 136446466;
          v15 = "nw_socket_internal_link_state";
          v16 = 1024;
          LODWORD(v17) = a2;
          _os_log_impl(&dword_181A37000, v8, OS_LOG_TYPE_DEBUG, "%{public}s Not updating link state because it's the same %d", &v14, 0x12u);
        }
      }

      return;
    }
  }

  else
  {
    *(a1 + 160) = nw_link_info_create(a2);
  }

  v9 = *(a1 + 317);
  if (a2)
  {
    if ((v9 & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
      }

      v10 = gconnectionLogObj;
      if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        v14 = 136446466;
        v15 = "nw_socket_internal_link_state";
        v16 = 2082;
        v17 = a1 + 324;
        _os_log_impl(&dword_181A37000, v10, OS_LOG_TYPE_INFO, "%{public}s %{public}s Link is flow controlled", &v14, 0x16u);
      }
    }

    *(a1 + 319) |= 0x40u;
    if (!v4)
    {
      return;
    }

LABEL_21:
    v12 = *(v4 + 24);
    if (v12)
    {
      v13 = *(v12 + 104);
      if (v13)
      {
        v13(v4, a1 - 96, *(a1 + 160));
      }
    }

    return;
  }

  if ((v9 & 0x80) == 0)
  {
    if (__nwlog_connection_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
    }

    v11 = gconnectionLogObj;
    if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_INFO))
    {
      v14 = 136446466;
      v15 = "nw_socket_internal_link_state";
      v16 = 2082;
      v17 = a1 + 324;
      _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_INFO, "%{public}s %{public}s Link is no longer flow controlled", &v14, 0x16u);
    }
  }

  *(a1 + 319) &= ~0x40u;
  if (v4)
  {
    goto LABEL_21;
  }
}

void nw_socket_set_send_low_water_mark(uint64_t a1, unsigned int a2)
{
  v40 = *MEMORY[0x1E69E9840];
  if (a2 <= 1)
  {
    v2 = 1;
  }

  else
  {
    v2 = a2;
  }

  v34 = v2;
  v3 = *(a1 + 172);
  if (v3 == v2)
  {
    return;
  }

  if (v2 > v3)
  {
    v32 = 4;
    *v33 = 0;
    if (getsockopt(*(a1 + 188), 0xFFFF, 4097, v33, &v32))
    {
      v5 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken[0] != -1)
      {
        dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
      }

      v6 = gconnectionLogObj;
      if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446722;
        v36 = "nw_socket_set_send_low_water_mark";
        v37 = 2082;
        *&v38 = a1 + 324;
        WORD4(v38) = 1024;
        *(&v38 + 10) = v5;
        _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d", buf, 0x1Cu);
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *buf = 136446466;
      v36 = "nw_socket_set_send_low_water_mark";
      v37 = 1024;
      LODWORD(v38) = v5;
      v7 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v30 = 0;
      if (!__nwlog_fault(v7, &type, &v30))
      {
        goto LABEL_31;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_31;
        }

        *buf = 136446466;
        v36 = "nw_socket_set_send_low_water_mark";
        v37 = 1024;
        LODWORD(v38) = v5;
        v10 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d";
      }

      else if (v30 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        v13 = os_log_type_enabled(gLogObj, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *buf = 136446722;
            v36 = "nw_socket_set_send_low_water_mark";
            v37 = 1024;
            LODWORD(v38) = v5;
            WORD2(v38) = 2082;
            *(&v38 + 6) = backtrace_string;
            _os_log_impl(&dword_181A37000, v8, v9, "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(backtrace_string);
          goto LABEL_31;
        }

        if (!v13)
        {
LABEL_31:
          if (v7)
          {
            free(v7);
          }

          goto LABEL_33;
        }

        *buf = 136446466;
        v36 = "nw_socket_set_send_low_water_mark";
        v37 = 1024;
        LODWORD(v38) = v5;
        v10 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, no backtrace";
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_31;
        }

        *buf = 136446466;
        v36 = "nw_socket_set_send_low_water_mark";
        v37 = 1024;
        LODWORD(v38) = v5;
        v10 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A37000, v8, v9, v10, buf, 0x12u);
      goto LABEL_31;
    }

    if (*v33 && v2 > *v33 / 3u)
    {
      if (*v33 < 3u)
      {
        v11 = 1;
      }

      else
      {
        v11 = *v33 / 3u;
      }

      v34 = v11;
    }
  }

LABEL_33:
  if (!setsockopt(*(a1 + 188), 0xFFFF, 4099, &v34, 4u))
  {
    *(a1 + 172) = v34;
    return;
  }

  v14 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken[0] != -1)
  {
    dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
  }

  v15 = gconnectionLogObj;
  if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    v16 = *(a1 + 188);
    *buf = 136447234;
    v36 = "nw_socket_set_send_low_water_mark";
    v37 = 2082;
    *&v38 = a1 + 324;
    WORD4(v38) = 1024;
    *(&v38 + 10) = v34;
    HIWORD(v38) = 1024;
    *v39 = v16;
    *&v39[4] = 1024;
    *&v39[6] = v14;
    _os_log_impl(&dword_181A37000, v15, OS_LOG_TYPE_ERROR, "%{public}s %{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d", buf, 0x28u);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v17 = gLogObj;
  if (v14 == 22)
  {
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      v18 = *(a1 + 188);
      *buf = 136446978;
      v36 = "nw_socket_set_send_low_water_mark";
      v37 = 1024;
      LODWORD(v38) = v34;
      WORD2(v38) = 1024;
      *(&v38 + 6) = v18;
      WORD5(v38) = 1024;
      HIDWORD(v38) = 22;
      _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d", buf, 0x1Eu);
    }

    return;
  }

  v19 = *(a1 + 188);
  *buf = 136446978;
  v36 = "nw_socket_set_send_low_water_mark";
  v37 = 1024;
  LODWORD(v38) = v34;
  WORD2(v38) = 1024;
  *(&v38 + 6) = v19;
  WORD5(v38) = 1024;
  HIDWORD(v38) = v14;
  v20 = _os_log_send_and_compose_impl();
  v33[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v32) = 0;
  if (!__nwlog_fault(v20, v33, &v32))
  {
    goto LABEL_56;
  }

  if (v33[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = gLogObj;
    v22 = v33[0];
    if (!os_log_type_enabled(gLogObj, v33[0]))
    {
      goto LABEL_56;
    }

    v23 = *(a1 + 188);
    *buf = 136446978;
    v36 = "nw_socket_set_send_low_water_mark";
    v37 = 1024;
    LODWORD(v38) = v34;
    WORD2(v38) = 1024;
    *(&v38 + 6) = v23;
    WORD5(v38) = 1024;
    HIDWORD(v38) = v14;
    v24 = "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d";
    goto LABEL_55;
  }

  if (v32 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = gLogObj;
    v22 = v33[0];
    if (!os_log_type_enabled(gLogObj, v33[0]))
    {
      goto LABEL_56;
    }

    v28 = *(a1 + 188);
    *buf = 136446978;
    v36 = "nw_socket_set_send_low_water_mark";
    v37 = 1024;
    LODWORD(v38) = v34;
    WORD2(v38) = 1024;
    *(&v38 + 6) = v28;
    WORD5(v38) = 1024;
    HIDWORD(v38) = v14;
    v24 = "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d, backtrace limit exceeded";
    goto LABEL_55;
  }

  v25 = __nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v21 = gLogObj;
  v22 = v33[0];
  v26 = os_log_type_enabled(gLogObj, v33[0]);
  if (v25)
  {
    if (v26)
    {
      v27 = *(a1 + 188);
      *buf = 136447234;
      v36 = "nw_socket_set_send_low_water_mark";
      v37 = 1024;
      LODWORD(v38) = v34;
      WORD2(v38) = 1024;
      *(&v38 + 6) = v27;
      WORD5(v38) = 1024;
      HIDWORD(v38) = v14;
      *v39 = 2082;
      *&v39[2] = v25;
      _os_log_impl(&dword_181A37000, v21, v22, "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x28u);
    }

    free(v25);
    goto LABEL_56;
  }

  if (v26)
  {
    v29 = *(a1 + 188);
    *buf = 136446978;
    v36 = "nw_socket_set_send_low_water_mark";
    v37 = 1024;
    LODWORD(v38) = v34;
    WORD2(v38) = 1024;
    *(&v38 + 6) = v29;
    WORD5(v38) = 1024;
    HIDWORD(v38) = v14;
    v24 = "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d, no backtrace";
LABEL_55:
    _os_log_impl(&dword_181A37000, v21, v22, v24, buf, 0x1Eu);
  }

LABEL_56:
  if (v20)
  {
    free(v20);
  }
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke_67459()
{
  result = networkd_settings_get_BOOL(nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

uint64_t nw_socket_register_notification(void *a1, uint64_t a2, int a3, int *a4, uint64_t a5)
{
  v69 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v5 = a1;
    v6 = a1[5];
    v7 = a1;
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      goto LABEL_6;
    }

    if (v6 != &nw_protocol_ref_counted_additional_handle)
    {
      v8 = 1;
      goto LABEL_11;
    }

    v7 = a1[8];
    if (v7)
    {
LABEL_6:
      v9 = v7[11];
      v8 = 0;
      if (v9)
      {
        v7[11] = v9 + 1;
      }
    }

    else
    {
      v8 = 1;
    }

    v6 = a1[5];
LABEL_11:
    v10 = a1;
    if (v6 != &nw_protocol_ref_counted_handle)
    {
      if (v6 != &nw_protocol_ref_counted_additional_handle)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *buf = 136446210;
        v62 = "nw_socket_register_notification";
        v11 = _os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v59 = 0;
        if (!__nwlog_fault(v11, &type, &v59))
        {
          goto LABEL_113;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = gLogObj;
          v13 = type;
          if (!os_log_type_enabled(gLogObj, type))
          {
            goto LABEL_113;
          }

          *buf = 136446210;
          v62 = "nw_socket_register_notification";
          v14 = "%{public}s called with null socket_handler";
          goto LABEL_54;
        }

        if (v59 != 1)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = gLogObj;
          v13 = type;
          if (!os_log_type_enabled(gLogObj, type))
          {
            goto LABEL_113;
          }

          *buf = 136446210;
          v62 = "nw_socket_register_notification";
          v14 = "%{public}s called with null socket_handler, backtrace limit exceeded";
          goto LABEL_54;
        }

        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = gLogObj;
        v21 = type;
        v22 = os_log_type_enabled(gLogObj, type);
        if (!backtrace_string)
        {
          if (!v22)
          {
            goto LABEL_113;
          }

          *buf = 136446210;
          v62 = "nw_socket_register_notification";
          v14 = "%{public}s called with null socket_handler, no backtrace";
          v33 = v20;
          v34 = v21;
          goto LABEL_55;
        }

        if (v22)
        {
          *buf = 136446466;
          v62 = "nw_socket_register_notification";
          v63 = 2082;
          v64 = backtrace_string;
          v23 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
          v24 = v20;
          v25 = v21;
          v26 = 22;
LABEL_34:
          _os_log_impl(&dword_181A37000, v24, v25, v23, buf, v26);
        }

LABEL_35:
        free(backtrace_string);
        if (!v11)
        {
          goto LABEL_115;
        }

        goto LABEL_114;
      }

      v10 = a1[8];
    }

    result = 0;
    if (a3 > 1)
    {
      if (a3 != 2)
      {
        if (a3 == 3)
        {
          result = nw_socket_add_socket_events((v10 + 12), 1, 256, 0);
        }

        goto LABEL_116;
      }

      if (a4)
      {
        if (a5)
        {
          v30 = *a4;
          v31 = *(v10 + 77);
          if (!*a4)
          {
            v30 = 5;
          }

          *(v10 + 77) = v30;
          v32 = nw_socket_add_socket_events((v10 + 12), 1, 512, 0);
          result = 1;
          if ((v32 & 1) == 0)
          {
            result = 0;
            *(v10 + 77) = v31;
          }

          goto LABEL_116;
        }

        if ((*(v10 + 413) & 0x80) != 0)
        {
          goto LABEL_115;
        }

        if (__nwlog_connection_log::onceToken[0] != -1)
        {
          dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
        }

        v37 = v10 + 420;
        *buf = 136446722;
        v62 = "nw_socket_register_notification";
        v63 = 2082;
        v64 = v10 + 420;
        v65 = 2082;
        v66 = "write_timeout";
        v11 = _os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v59 = 0;
        if (!__nwlog_fault(v11, &type, &v59))
        {
          goto LABEL_113;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken[0] != -1)
          {
            dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
          }

          v28 = gconnectionLogObj;
          v29 = type;
          if (os_log_type_enabled(gconnectionLogObj, type))
          {
            *buf = 136446722;
            v62 = "nw_socket_register_notification";
            v63 = 2082;
            v64 = v37;
            v65 = 2082;
            v66 = "write_timeout";
            v14 = "%{public}s %{public}s register notification for %{public}s called with zero length";
            goto LABEL_110;
          }

          goto LABEL_113;
        }

        if (v59 != 1)
        {
          if (__nwlog_connection_log::onceToken[0] != -1)
          {
            dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
          }

          v28 = gconnectionLogObj;
          v29 = type;
          if (os_log_type_enabled(gconnectionLogObj, type))
          {
            *buf = 136446722;
            v62 = "nw_socket_register_notification";
            v63 = 2082;
            v64 = v37;
            v65 = 2082;
            v66 = "write_timeout";
            v14 = "%{public}s %{public}s register notification for %{public}s called with zero length, backtrace limit exceeded";
            goto LABEL_110;
          }

          goto LABEL_113;
        }

        backtrace_string = __nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken[0] != -1)
        {
          dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
        }

        v39 = gconnectionLogObj;
        v40 = type;
        v43 = os_log_type_enabled(gconnectionLogObj, type);
        if (backtrace_string)
        {
          if (!v43)
          {
            goto LABEL_35;
          }

          *buf = 136446978;
          v62 = "nw_socket_register_notification";
          v63 = 2082;
          v64 = v37;
          v65 = 2082;
          v66 = "write_timeout";
          v67 = 2082;
          v68 = backtrace_string;
          v23 = "%{public}s %{public}s register notification for %{public}s called with zero length, dumping backtrace:%{public}s";
LABEL_99:
          v24 = v39;
          v25 = v40;
          v26 = 42;
          goto LABEL_34;
        }

        if (!v43)
        {
          goto LABEL_113;
        }

        *buf = 136446722;
        v62 = "nw_socket_register_notification";
        v63 = 2082;
        v64 = v37;
        v65 = 2082;
        v66 = "write_timeout";
        v14 = "%{public}s %{public}s register notification for %{public}s called with zero length, no backtrace";
LABEL_133:
        v33 = v39;
        v34 = v40;
        goto LABEL_111;
      }

      __nwlog_obj();
      *buf = 136446210;
      v62 = "nw_socket_register_notification";
      v11 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v59 = 0;
      if (!__nwlog_fault(v11, &type, &v59))
      {
        goto LABEL_113;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
        {
          goto LABEL_113;
        }

        *buf = 136446210;
        v62 = "nw_socket_register_notification";
        v14 = "%{public}s called with null val";
      }

      else if (v59 == 1)
      {
        v56 = __nw_create_backtrace_string();
        v12 = __nwlog_obj();
        v13 = type;
        v58 = os_log_type_enabled(v12, type);
        if (v56)
        {
          if (!v58)
          {
            goto LABEL_167;
          }

          goto LABEL_166;
        }

        if (!v58)
        {
          goto LABEL_113;
        }

        *buf = 136446210;
        v62 = "nw_socket_register_notification";
        v14 = "%{public}s called with null val, no backtrace";
      }

      else
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
        {
          goto LABEL_113;
        }

        *buf = 136446210;
        v62 = "nw_socket_register_notification";
        v14 = "%{public}s called with null val, backtrace limit exceeded";
      }
    }

    else
    {
      if (!a3)
      {
        if ((*(v10 + 413) & 0x80) != 0)
        {
          goto LABEL_115;
        }

        if (__nwlog_connection_log::onceToken[0] != -1)
        {
          dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
        }

        v27 = v10 + 420;
        *buf = 136446722;
        v62 = "nw_socket_register_notification";
        v63 = 2082;
        v64 = v10 + 420;
        v65 = 2082;
        v66 = "undefined";
        v11 = _os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v59 = 0;
        if (!__nwlog_fault(v11, &type, &v59))
        {
          goto LABEL_113;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken[0] != -1)
          {
            dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
          }

          v28 = gconnectionLogObj;
          v29 = type;
          if (os_log_type_enabled(gconnectionLogObj, type))
          {
            *buf = 136446722;
            v62 = "nw_socket_register_notification";
            v63 = 2082;
            v64 = v27;
            v65 = 2082;
            v66 = "undefined";
            v14 = "%{public}s %{public}s invalid registration notification: %{public}s";
LABEL_110:
            v33 = v28;
            v34 = v29;
LABEL_111:
            v35 = 32;
            goto LABEL_112;
          }

LABEL_113:
          if (v11)
          {
LABEL_114:
            free(v11);
          }

LABEL_115:
          result = 0;
LABEL_116:
          if ((v8 & 1) == 0)
          {
            v44 = v5[5];
            if (v44 == &nw_protocol_ref_counted_handle || v44 == &nw_protocol_ref_counted_additional_handle && (v5 = v5[8]) != 0)
            {
              v45 = v5[11];
              if (v45)
              {
                v46 = v45 - 1;
                v5[11] = v46;
                if (!v46)
                {
                  v47 = result;
                  v48 = v5[8];
                  if (v48)
                  {
                    v5[8] = 0;
                    v48[2](v48);
                    _Block_release(v48);
                  }

                  if (v5[9])
                  {
                    v49 = v5[8];
                    if (v49)
                    {
                      _Block_release(v49);
                    }
                  }

                  free(v5);
                  return v47;
                }
              }
            }
          }

          return result;
        }

        if (v59 != 1)
        {
          if (__nwlog_connection_log::onceToken[0] != -1)
          {
            dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
          }

          v28 = gconnectionLogObj;
          v29 = type;
          if (os_log_type_enabled(gconnectionLogObj, type))
          {
            *buf = 136446722;
            v62 = "nw_socket_register_notification";
            v63 = 2082;
            v64 = v27;
            v65 = 2082;
            v66 = "undefined";
            v14 = "%{public}s %{public}s invalid registration notification: %{public}s, backtrace limit exceeded";
            goto LABEL_110;
          }

          goto LABEL_113;
        }

        v38 = __nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken[0] != -1)
        {
          dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
        }

        v39 = gconnectionLogObj;
        v40 = type;
        v41 = os_log_type_enabled(gconnectionLogObj, type);
        if (v38)
        {
          if (v41)
          {
            *buf = 136446978;
            v62 = "nw_socket_register_notification";
            v63 = 2082;
            v64 = v27;
            v65 = 2082;
            v66 = "undefined";
            v67 = 2082;
            v68 = v38;
            _os_log_impl(&dword_181A37000, v39, v40, "%{public}s %{public}s invalid registration notification: %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v38);
          goto LABEL_113;
        }

        if (!v41)
        {
          goto LABEL_113;
        }

        *buf = 136446722;
        v62 = "nw_socket_register_notification";
        v63 = 2082;
        v64 = v27;
        v65 = 2082;
        v66 = "undefined";
        v14 = "%{public}s %{public}s invalid registration notification: %{public}s, no backtrace";
        goto LABEL_133;
      }

      if (a3 != 1)
      {
        goto LABEL_116;
      }

      if (a4)
      {
        if (a5)
        {
          v16 = *a4;
          v17 = *(v10 + 76);
          if (!*a4)
          {
            v16 = 5;
          }

          *(v10 + 76) = v16;
          v18 = nw_socket_add_socket_events((v10 + 12), 1, 1024, 0);
          result = 1;
          if ((v18 & 1) == 0)
          {
            result = 0;
            *(v10 + 76) = v17;
          }

          goto LABEL_116;
        }

        if ((*(v10 + 413) & 0x80) != 0)
        {
          goto LABEL_115;
        }

        if (__nwlog_connection_log::onceToken[0] != -1)
        {
          dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
        }

        v36 = v10 + 420;
        *buf = 136446722;
        v62 = "nw_socket_register_notification";
        v63 = 2082;
        v64 = v10 + 420;
        v65 = 2082;
        v66 = "read_timeout";
        v11 = _os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v59 = 0;
        if (!__nwlog_fault(v11, &type, &v59))
        {
          goto LABEL_113;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken[0] != -1)
          {
            dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
          }

          v28 = gconnectionLogObj;
          v29 = type;
          if (os_log_type_enabled(gconnectionLogObj, type))
          {
            *buf = 136446722;
            v62 = "nw_socket_register_notification";
            v63 = 2082;
            v64 = v36;
            v65 = 2082;
            v66 = "read_timeout";
            v14 = "%{public}s %{public}s register notification for %{public}s called with zero length";
            goto LABEL_110;
          }

          goto LABEL_113;
        }

        if (v59 != 1)
        {
          if (__nwlog_connection_log::onceToken[0] != -1)
          {
            dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
          }

          v28 = gconnectionLogObj;
          v29 = type;
          if (os_log_type_enabled(gconnectionLogObj, type))
          {
            *buf = 136446722;
            v62 = "nw_socket_register_notification";
            v63 = 2082;
            v64 = v36;
            v65 = 2082;
            v66 = "read_timeout";
            v14 = "%{public}s %{public}s register notification for %{public}s called with zero length, backtrace limit exceeded";
            goto LABEL_110;
          }

          goto LABEL_113;
        }

        backtrace_string = __nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken[0] != -1)
        {
          dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
        }

        v39 = gconnectionLogObj;
        v40 = type;
        v42 = os_log_type_enabled(gconnectionLogObj, type);
        if (backtrace_string)
        {
          if (!v42)
          {
            goto LABEL_35;
          }

          *buf = 136446978;
          v62 = "nw_socket_register_notification";
          v63 = 2082;
          v64 = v36;
          v65 = 2082;
          v66 = "read_timeout";
          v67 = 2082;
          v68 = backtrace_string;
          v23 = "%{public}s %{public}s register notification for %{public}s called with zero length, dumping backtrace:%{public}s";
          goto LABEL_99;
        }

        if (!v42)
        {
          goto LABEL_113;
        }

        *buf = 136446722;
        v62 = "nw_socket_register_notification";
        v63 = 2082;
        v64 = v36;
        v65 = 2082;
        v66 = "read_timeout";
        v14 = "%{public}s %{public}s register notification for %{public}s called with zero length, no backtrace";
        goto LABEL_133;
      }

      __nwlog_obj();
      *buf = 136446210;
      v62 = "nw_socket_register_notification";
      v11 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v59 = 0;
      if (!__nwlog_fault(v11, &type, &v59))
      {
        goto LABEL_113;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
        {
          goto LABEL_113;
        }

        *buf = 136446210;
        v62 = "nw_socket_register_notification";
        v14 = "%{public}s called with null val";
        goto LABEL_54;
      }

      if (v59 == 1)
      {
        v56 = __nw_create_backtrace_string();
        v12 = __nwlog_obj();
        v13 = type;
        v57 = os_log_type_enabled(v12, type);
        if (v56)
        {
          if (!v57)
          {
            goto LABEL_167;
          }

LABEL_166:
          *buf = 136446466;
          v62 = "nw_socket_register_notification";
          v63 = 2082;
          v64 = v56;
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s called with null val, dumping backtrace:%{public}s", buf, 0x16u);
LABEL_167:
          free(v56);
          if (!v11)
          {
            goto LABEL_115;
          }

          goto LABEL_114;
        }

        if (!v57)
        {
          goto LABEL_113;
        }

        *buf = 136446210;
        v62 = "nw_socket_register_notification";
        v14 = "%{public}s called with null val, no backtrace";
      }

      else
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
        {
          goto LABEL_113;
        }

        *buf = 136446210;
        v62 = "nw_socket_register_notification";
        v14 = "%{public}s called with null val, backtrace limit exceeded";
      }
    }

LABEL_54:
    v33 = v12;
    v34 = v13;
LABEL_55:
    v35 = 12;
LABEL_112:
    _os_log_impl(&dword_181A37000, v33, v34, v14, buf, v35);
    goto LABEL_113;
  }

  __nwlog_obj();
  *buf = 136446210;
  v62 = "nw_socket_register_notification";
  v50 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v59 = 0;
  if (__nwlog_fault(v50, &type, &v59))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v51 = __nwlog_obj();
      v52 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        v62 = "nw_socket_register_notification";
        v53 = "%{public}s called with null protocol";
LABEL_155:
        _os_log_impl(&dword_181A37000, v51, v52, v53, buf, 0xCu);
      }
    }

    else if (v59 == 1)
    {
      v54 = __nw_create_backtrace_string();
      v51 = __nwlog_obj();
      v52 = type;
      v55 = os_log_type_enabled(v51, type);
      if (v54)
      {
        if (v55)
        {
          *buf = 136446466;
          v62 = "nw_socket_register_notification";
          v63 = 2082;
          v64 = v54;
          _os_log_impl(&dword_181A37000, v51, v52, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v54);
        goto LABEL_156;
      }

      if (v55)
      {
        *buf = 136446210;
        v62 = "nw_socket_register_notification";
        v53 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_155;
      }
    }

    else
    {
      v51 = __nwlog_obj();
      v52 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        v62 = "nw_socket_register_notification";
        v53 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_155;
      }
    }
  }

LABEL_156:
  if (v50)
  {
    free(v50);
  }

  return 0;
}

uint64_t nw_socket_reset(nw_protocol *a1, nw_protocol *a2)
{
  v41 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v38 = "nw_socket_reset";
    v29 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v29, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *buf = 136446210;
          v38 = "nw_socket_reset";
          v32 = "%{public}s called with null protocol";
LABEL_65:
          _os_log_impl(&dword_181A37000, v30, v31, v32, buf, 0xCu);
        }
      }

      else if (v35 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v30 = __nwlog_obj();
        v31 = type;
        v34 = os_log_type_enabled(v30, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *buf = 136446466;
            v38 = "nw_socket_reset";
            v39 = 2082;
            v40 = backtrace_string;
            _os_log_impl(&dword_181A37000, v30, v31, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_66;
        }

        if (v34)
        {
          *buf = 136446210;
          v38 = "nw_socket_reset";
          v32 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_65;
        }
      }

      else
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *buf = 136446210;
          v38 = "nw_socket_reset";
          v32 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_65;
        }
      }
    }

LABEL_66:
    if (v29)
    {
      free(v29);
    }

    return 0;
  }

  v2 = a1;
  handle = a1->handle;
  v4 = a1;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    goto LABEL_6;
  }

  if (handle == &nw_protocol_ref_counted_additional_handle)
  {
    v4 = *a1[1].flow_id;
    if (!v4)
    {
      v5 = 1;
LABEL_10:
      handle = a1->handle;
      goto LABEL_11;
    }

LABEL_6:
    callbacks = v4[1].callbacks;
    v5 = 0;
    if (callbacks)
    {
      v4[1].callbacks = (&callbacks->add_input_handler + 1);
    }

    goto LABEL_10;
  }

  v5 = 1;
LABEL_11:
  v7 = a1;
  if (handle != &nw_protocol_ref_counted_handle)
  {
    if (handle != &nw_protocol_ref_counted_additional_handle)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *buf = 136446210;
      v38 = "nw_socket_reset";
      v8 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v35 = 0;
      if (!__nwlog_fault(v8, &type, &v35))
      {
        goto LABEL_35;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_35;
        }

        *buf = 136446210;
        v38 = "nw_socket_reset";
        v11 = "%{public}s called with null socket_handler";
      }

      else
      {
        if (v35 == 1)
        {
          v17 = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v18 = gLogObj;
          v19 = type;
          v20 = os_log_type_enabled(gLogObj, type);
          if (v17)
          {
            if (v20)
            {
              *buf = 136446466;
              v38 = "nw_socket_reset";
              v39 = 2082;
              v40 = v17;
              _os_log_impl(&dword_181A37000, v18, v19, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v17);
            goto LABEL_35;
          }

          if (!v20)
          {
LABEL_35:
            if (v8)
            {
              free(v8);
            }

LABEL_37:
            result = 0;
            if (v5)
            {
              return result;
            }

            goto LABEL_38;
          }

          *buf = 136446210;
          v38 = "nw_socket_reset";
          v11 = "%{public}s called with null socket_handler, no backtrace";
          v21 = v18;
          v22 = v19;
LABEL_34:
          _os_log_impl(&dword_181A37000, v21, v22, v11, buf, 0xCu);
          goto LABEL_35;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_35;
        }

        *buf = 136446210;
        v38 = "nw_socket_reset";
        v11 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      }

      v21 = v9;
      v22 = v10;
      goto LABEL_34;
    }

    v7 = *a1[1].flow_id;
  }

  if (v7[2].callbacks != a2)
  {
    goto LABEL_37;
  }

  nw_socket_cancel_input_source(&v7[1].output_handler, a2);
  v13 = v7[3].handle;
  if (v13)
  {
    nw_queue_cancel_source(v7[3].handle, v12);
    v7[3].handle = 0;
    if ((*(&v7[6].callbacks + 5) & 0x800) == 0)
    {
      nw_queue_resume_source(v13, v12);
      *(&v7[6].callbacks + 5) |= 0x800u;
    }
  }

  name = v7[3].identifier->name;
  if (name)
  {
    nw_queue_cancel_source(name, v12);
    v7[3].identifier = 0;
  }

  nw_protocol_socket_cancel(&v7[1].output_handler);
  HIDWORD(v7[4].callbacks) = -1;
  HIDWORD(v7[4].output_handler) = 6159;
  *&v7[4].flow_id[8] = 0x100000001;
  v15 = *(&v7[6].callbacks + 5);
  HIBYTE(v7[6].callbacks) &= 0xFCu;
  *(&v7[6].callbacks + 5) = v15 & 0x31C0 | 0x20;
  nw_socket_initialize_socket(v2);
  result = 1;
  if ((v5 & 1) == 0)
  {
LABEL_38:
    v23 = v2->handle;
    if (v23 == &nw_protocol_ref_counted_handle || v23 == &nw_protocol_ref_counted_additional_handle && (v2 = *v2[1].flow_id) != 0)
    {
      v24 = v2[1].callbacks;
      if (v24)
      {
        v25 = (v24 - 1);
        v2[1].callbacks = v25;
        if (!v25)
        {
          v26 = result;
          v27 = *v2[1].flow_id;
          if (v27)
          {
            *v2[1].flow_id = 0;
            v27[2](v27);
            _Block_release(v27);
          }

          if (v2[1].flow_id[8])
          {
            v28 = *v2[1].flow_id;
            if (v28)
            {
              _Block_release(v28);
            }
          }

          free(v2);
          return v26;
        }
      }
    }
  }

  return result;
}

uint64_t nw_socket_set_no_push(uint64_t a1, int a2)
{
  v20 = *MEMORY[0x1E69E9840];
  if (*(a1 + 192) != 2)
  {
    return 22;
  }

  v15 = a2;
  if (!setsockopt(*(a1 + 188), 6, 4, &v15, 4u))
  {
    return 0;
  }

  v3 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken[0] != -1)
  {
    dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
  }

  v4 = gconnectionLogObj;
  if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *buf = 136446722;
    v17 = "nw_socket_set_no_push";
    v18 = 2082;
    *v19 = a1 + 324;
    *&v19[8] = 1024;
    *&v19[10] = v3;
    _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}s setsockopt TCP_NOPUSH failed %{darwin.errno}d", buf, 0x1Cu);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = gLogObj;
  if (v3 == 22)
  {
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v17 = "nw_socket_set_no_push";
      v18 = 1024;
      *v19 = 22;
      _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_NOPUSH failed %{darwin.errno}d", buf, 0x12u);
    }

    return v3;
  }

  *buf = 136446466;
  v17 = "nw_socket_set_no_push";
  v18 = 1024;
  *v19 = v3;
  v6 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_26;
      }

      *buf = 136446466;
      v17 = "nw_socket_set_no_push";
      v18 = 1024;
      *v19 = v3;
      v9 = "%{public}s setsockopt TCP_NOPUSH failed %{darwin.errno}d";
      goto LABEL_25;
    }

    if (v13 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_26;
      }

      *buf = 136446466;
      v17 = "nw_socket_set_no_push";
      v18 = 1024;
      *v19 = v3;
      v9 = "%{public}s setsockopt TCP_NOPUSH failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_25;
    }

    backtrace_string = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    v8 = type;
    v11 = os_log_type_enabled(gLogObj, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *buf = 136446722;
        v17 = "nw_socket_set_no_push";
        v18 = 1024;
        *v19 = v3;
        *&v19[4] = 2082;
        *&v19[6] = backtrace_string;
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s setsockopt TCP_NOPUSH failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }

      free(backtrace_string);
      goto LABEL_26;
    }

    if (v11)
    {
      *buf = 136446466;
      v17 = "nw_socket_set_no_push";
      v18 = 1024;
      *v19 = v3;
      v9 = "%{public}s setsockopt TCP_NOPUSH failed %{darwin.errno}d, no backtrace";
LABEL_25:
      _os_log_impl(&dword_181A37000, v7, v8, v9, buf, 0x12u);
    }
  }

LABEL_26:
  if (v6)
  {
    free(v6);
  }

  return v3;
}

uint64_t nw_protocol_socket_set_max_pacing_rate(char *a1, uint64_t a2)
{
  v29 = *MEMORY[0x1E69E9840];
  v24 = a2;
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_protocol_socket_set_max_pacing_rate";
    v16 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (__nwlog_fault(v16, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v17 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *buf = 136446210;
          v26 = "nw_protocol_socket_set_max_pacing_rate";
          v19 = "%{public}s called with null handle";
LABEL_48:
          _os_log_impl(&dword_181A37000, v17, v18, v19, buf, 0xCu);
        }
      }

      else if (v22 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v17 = __nwlog_obj();
        v18 = type;
        v21 = os_log_type_enabled(v17, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *buf = 136446466;
            v26 = "nw_protocol_socket_set_max_pacing_rate";
            v27 = 2082;
            *v28 = backtrace_string;
            _os_log_impl(&dword_181A37000, v17, v18, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_49;
        }

        if (v21)
        {
          *buf = 136446210;
          v26 = "nw_protocol_socket_set_max_pacing_rate";
          v19 = "%{public}s called with null handle, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        v17 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *buf = 136446210;
          v26 = "nw_protocol_socket_set_max_pacing_rate";
          v19 = "%{public}s called with null handle, backtrace limit exceeded";
          goto LABEL_48;
        }
      }
    }

LABEL_49:
    if (v16)
    {
      free(v16);
    }

    return 22;
  }

  if (setsockopt(*(a1 + 47), 0xFFFF, 4406, &v24, 8u))
  {
    v3 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
    }

    v4 = gconnectionLogObj;
    if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446722;
      v26 = "nw_protocol_socket_set_max_pacing_rate";
      v27 = 2082;
      *v28 = a1 + 324;
      *&v28[8] = 1024;
      *&v28[10] = v3;
      _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}s setsockopt SO_MAX_PACING_RATE failed %{darwin.errno}d", buf, 0x1Cu);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    if (v3 == 22)
    {
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446466;
        v26 = "nw_protocol_socket_set_max_pacing_rate";
        v27 = 1024;
        *v28 = 22;
        _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_MAX_PACING_RATE failed %{darwin.errno}d", buf, 0x12u);
      }

      return v3;
    }

    *buf = 136446466;
    v26 = "nw_protocol_socket_set_max_pacing_rate";
    v27 = 1024;
    *v28 = v3;
    v7 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
    {
      goto LABEL_32;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_32;
      }

      *buf = 136446466;
      v26 = "nw_protocol_socket_set_max_pacing_rate";
      v27 = 1024;
      *v28 = v3;
      v10 = "%{public}s setsockopt SO_MAX_PACING_RATE failed %{darwin.errno}d";
    }

    else if (v22 == 1)
    {
      v13 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      v14 = os_log_type_enabled(gLogObj, type);
      if (v13)
      {
        if (v14)
        {
          *buf = 136446722;
          v26 = "nw_protocol_socket_set_max_pacing_rate";
          v27 = 1024;
          *v28 = v3;
          *&v28[4] = 2082;
          *&v28[6] = v13;
          _os_log_impl(&dword_181A37000, v8, v9, "%{public}s setsockopt SO_MAX_PACING_RATE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(v13);
        goto LABEL_32;
      }

      if (!v14)
      {
LABEL_32:
        if (v7)
        {
          free(v7);
        }

        return v3;
      }

      *buf = 136446466;
      v26 = "nw_protocol_socket_set_max_pacing_rate";
      v27 = 1024;
      *v28 = v3;
      v10 = "%{public}s setsockopt SO_MAX_PACING_RATE failed %{darwin.errno}d, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_32;
      }

      *buf = 136446466;
      v26 = "nw_protocol_socket_set_max_pacing_rate";
      v27 = 1024;
      *v28 = v3;
      v10 = "%{public}s setsockopt SO_MAX_PACING_RATE failed %{darwin.errno}d, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v8, v9, v10, buf, 0x12u);
    goto LABEL_32;
  }

  v6 = v24;
  if (v24 == *(a1 + 6))
  {
    return 0;
  }

  if ((*(a1 + 317) & 0x80) == 0)
  {
    if (__nwlog_connection_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
    }

    v11 = gconnectionLogObj;
    v12 = os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_INFO);
    v6 = v24;
    if (v12)
    {
      *buf = 136446722;
      v26 = "nw_protocol_socket_set_max_pacing_rate";
      v27 = 2082;
      *v28 = a1 + 324;
      *&v28[8] = 2048;
      *&v28[10] = v24;
      _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_INFO, "%{public}s %{public}s nw_protocol_socket_set_max_pacing_rate %llu", buf, 0x20u);
      v6 = v24;
    }
  }

  v3 = 0;
  *(a1 + 6) = v6;
  return v3;
}

uint64_t nw_protocol_socket_set_no_push(uint64_t a1, int a2)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return nw_socket_set_no_push(a1, a2);
  }

  __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_socket_set_no_push";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_socket_set_no_push";
        v6 = "%{public}s called with null handle";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else if (v9 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *buf = 136446466;
          v12 = "nw_protocol_socket_set_no_push";
          v13 = 2082;
          v14 = backtrace_string;
          _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (v8)
      {
        *buf = 136446210;
        v12 = "nw_protocol_socket_set_no_push";
        v6 = "%{public}s called with null handle, no backtrace";
        goto LABEL_18;
      }
    }

    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_socket_set_no_push";
        v6 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
  }

LABEL_19:
  if (v3)
  {
    free(v3);
  }

  return 22;
}

uint64_t nw_protocol_socket_set_no_delay(uint64_t a1, int a2)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return nw_socket_set_no_delay(a1, a2);
  }

  __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_protocol_socket_set_no_delay";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_socket_set_no_delay";
        v6 = "%{public}s called with null handle";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else if (v9 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *buf = 136446466;
          v12 = "nw_protocol_socket_set_no_delay";
          v13 = 2082;
          v14 = backtrace_string;
          _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (v8)
      {
        *buf = 136446210;
        v12 = "nw_protocol_socket_set_no_delay";
        v6 = "%{public}s called with null handle, no backtrace";
        goto LABEL_18;
      }
    }

    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_protocol_socket_set_no_delay";
        v6 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
  }

LABEL_19:
  if (v3)
  {
    free(v3);
  }

  return 22;
}

uint64_t nw_protocol_socket_reset_keepalives(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  v27 = *MEMORY[0x1E69E9840];
  v19 = a5;
  v20 = a4;
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v22 = "nw_protocol_socket_reset_keepalives";
    v11 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v17) = 0;
    if (__nwlog_fault(v11, type, &v17))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *buf = 136446210;
          v22 = "nw_protocol_socket_reset_keepalives";
          v14 = "%{public}s called with null handle";
LABEL_38:
          _os_log_impl(&dword_181A37000, v12, v13, v14, buf, 0xCu);
        }
      }

      else if (v17 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v12 = __nwlog_obj();
        v13 = type[0];
        v16 = os_log_type_enabled(v12, type[0]);
        if (backtrace_string)
        {
          if (v16)
          {
            *buf = 136446466;
            v22 = "nw_protocol_socket_reset_keepalives";
            v23 = 2082;
            v24 = backtrace_string;
            _os_log_impl(&dword_181A37000, v12, v13, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_39;
        }

        if (v16)
        {
          *buf = 136446210;
          v22 = "nw_protocol_socket_reset_keepalives";
          v14 = "%{public}s called with null handle, no backtrace";
          goto LABEL_38;
        }
      }

      else
      {
        v12 = __nwlog_obj();
        v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *buf = 136446210;
          v22 = "nw_protocol_socket_reset_keepalives";
          v14 = "%{public}s called with null handle, backtrace limit exceeded";
          goto LABEL_38;
        }
      }
    }

LABEL_39:
    if (v11)
    {
      free(v11);
    }

    return 22;
  }

  *type = a2;
  if (setsockopt(a1[47], 0xFFFF, 8, type, 4u) < 0)
  {
    v7 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
    }

    v8 = gconnectionLogObj;
    if (!os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      return v7;
    }

    *buf = 136446722;
    v22 = "nw_protocol_socket_reset_keepalives";
    v23 = 2082;
    v24 = (a1 + 81);
    v25 = 1024;
    v26 = v7;
    v9 = "%{public}s %{public}s setsockopt SO_KEEPALIVE failed %{darwin.errno}d";
LABEL_23:
    _os_log_impl(&dword_181A37000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0x1Cu);
    return v7;
  }

  if (setsockopt(a1[47], 6, 16, &v20, 4u) < 0)
  {
    v7 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
    }

    v8 = gconnectionLogObj;
    if (!os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      return v7;
    }

    *buf = 136446722;
    v22 = "nw_protocol_socket_reset_keepalives";
    v23 = 2082;
    v24 = (a1 + 81);
    v25 = 1024;
    v26 = v7;
    v9 = "%{public}s %{public}s setsockopt TCP_KEEPALIVE failed %{darwin.errno}d";
    goto LABEL_23;
  }

  if (setsockopt(a1[47], 6, 257, &v19, 4u) < 0)
  {
    v7 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
    }

    v8 = gconnectionLogObj;
    if (!os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      return v7;
    }

    *buf = 136446722;
    v22 = "nw_protocol_socket_reset_keepalives";
    v23 = 2082;
    v24 = (a1 + 81);
    v25 = 1024;
    v26 = v7;
    v9 = "%{public}s %{public}s setsockopt TCP_KEEPINTVL failed %{darwin.errno}d";
    goto LABEL_23;
  }

  v17 = a3;
  if ((setsockopt(a1[47], 6, 258, &v17, 4u) & 0x80000000) == 0)
  {
    return 0;
  }

  v7 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken[0] != -1)
  {
    dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
  }

  v8 = gconnectionLogObj;
  if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *buf = 136446722;
    v22 = "nw_protocol_socket_reset_keepalives";
    v23 = 2082;
    v24 = (a1 + 81);
    v25 = 1024;
    v26 = v7;
    v9 = "%{public}s %{public}s setsockopt TCP_KEEPCNT failed %{darwin.errno}d";
    goto LABEL_23;
  }

  return v7;
}

uint64_t nw_protocol_socket_get_send_buffer_size(_DWORD *a1)
{
  v25 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v19 = 4;
    *v20 = 0;
    if (!getsockopt(a1[47], 0xFFFF, 4132, v20, &v19))
    {
      return *v20;
    }

    v2 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
    }

    v3 = gconnectionLogObj;
    if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446722;
      v22 = "nw_protocol_socket_get_send_buffer_size";
      v23 = 2082;
      *v24 = a1 + 81;
      *&v24[8] = 1024;
      *&v24[10] = v2;
      _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_ERROR, "%{public}s %{public}s getsockopt SO_NWRITE failed %{darwin.errno}d", buf, 0x1Cu);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446466;
    v22 = "nw_protocol_socket_get_send_buffer_size";
    v23 = 1024;
    *v24 = v2;
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v4, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        v6 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_21;
        }

        *buf = 136446466;
        v22 = "nw_protocol_socket_get_send_buffer_size";
        v23 = 1024;
        *v24 = v2;
        v7 = "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d";
        goto LABEL_20;
      }

      if (v17 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        v6 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_21;
        }

        *buf = 136446466;
        v22 = "nw_protocol_socket_get_send_buffer_size";
        v23 = 1024;
        *v24 = v2;
        v7 = "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_20;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      v9 = os_log_type_enabled(gLogObj, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *buf = 136446722;
          v22 = "nw_protocol_socket_get_send_buffer_size";
          v23 = 1024;
          *v24 = v2;
          *&v24[4] = 2082;
          *&v24[6] = backtrace_string;
          _os_log_impl(&dword_181A37000, v5, v6, "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v9)
      {
        *buf = 136446466;
        v22 = "nw_protocol_socket_get_send_buffer_size";
        v23 = 1024;
        *v24 = v2;
        v7 = "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d, no backtrace";
LABEL_20:
        _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0x12u);
      }
    }

LABEL_21:
    if (v4)
    {
      free(v4);
    }

    return *v20;
  }

  __nwlog_obj();
  *buf = 136446210;
  v22 = "nw_protocol_socket_get_send_buffer_size";
  v11 = _os_log_send_and_compose_impl();
  v20[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v19) = 0;
  if (__nwlog_fault(v11, v20, &v19))
  {
    if (v20[0] == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = v20[0];
      if (os_log_type_enabled(v12, v20[0]))
      {
        *buf = 136446210;
        v22 = "nw_protocol_socket_get_send_buffer_size";
        v14 = "%{public}s called with null handle";
LABEL_37:
        _os_log_impl(&dword_181A37000, v12, v13, v14, buf, 0xCu);
      }
    }

    else if (v19 == 1)
    {
      v15 = __nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v13 = v20[0];
      v16 = os_log_type_enabled(v12, v20[0]);
      if (v15)
      {
        if (v16)
        {
          *buf = 136446466;
          v22 = "nw_protocol_socket_get_send_buffer_size";
          v23 = 2082;
          *v24 = v15;
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v15);
        goto LABEL_38;
      }

      if (v16)
      {
        *buf = 136446210;
        v22 = "nw_protocol_socket_get_send_buffer_size";
        v14 = "%{public}s called with null handle, no backtrace";
        goto LABEL_37;
      }
    }

    else
    {
      v12 = __nwlog_obj();
      v13 = v20[0];
      if (os_log_type_enabled(v12, v20[0]))
      {
        *buf = 136446210;
        v22 = "nw_protocol_socket_get_send_buffer_size";
        v14 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_37;
      }
    }
  }

LABEL_38:
  if (v11)
  {
    free(v11);
  }

  return 0;
}

uint64_t nw_protocol_socket_get_receive_buffer_size(_DWORD *a1)
{
  v25 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v19 = 4;
    *v20 = 0;
    if (!getsockopt(a1[47], 0xFFFF, 4128, v20, &v19))
    {
      return *v20;
    }

    v2 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
    }

    v3 = gconnectionLogObj;
    if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446722;
      v22 = "nw_protocol_socket_get_receive_buffer_size";
      v23 = 2082;
      *v24 = a1 + 81;
      *&v24[8] = 1024;
      *&v24[10] = v2;
      _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_ERROR, "%{public}s %{public}s getsockopt SO_NREAD failed %{darwin.errno}d", buf, 0x1Cu);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446466;
    v22 = "nw_protocol_socket_get_receive_buffer_size";
    v23 = 1024;
    *v24 = v2;
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v4, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        v6 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_21;
        }

        *buf = 136446466;
        v22 = "nw_protocol_socket_get_receive_buffer_size";
        v23 = 1024;
        *v24 = v2;
        v7 = "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d";
        goto LABEL_20;
      }

      if (v17 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        v6 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_21;
        }

        *buf = 136446466;
        v22 = "nw_protocol_socket_get_receive_buffer_size";
        v23 = 1024;
        *v24 = v2;
        v7 = "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_20;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      v9 = os_log_type_enabled(gLogObj, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *buf = 136446722;
          v22 = "nw_protocol_socket_get_receive_buffer_size";
          v23 = 1024;
          *v24 = v2;
          *&v24[4] = 2082;
          *&v24[6] = backtrace_string;
          _os_log_impl(&dword_181A37000, v5, v6, "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v9)
      {
        *buf = 136446466;
        v22 = "nw_protocol_socket_get_receive_buffer_size";
        v23 = 1024;
        *v24 = v2;
        v7 = "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d, no backtrace";
LABEL_20:
        _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0x12u);
      }
    }

LABEL_21:
    if (v4)
    {
      free(v4);
    }

    return *v20;
  }

  __nwlog_obj();
  *buf = 136446210;
  v22 = "nw_protocol_socket_get_receive_buffer_size";
  v11 = _os_log_send_and_compose_impl();
  v20[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v19) = 0;
  if (__nwlog_fault(v11, v20, &v19))
  {
    if (v20[0] == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = v20[0];
      if (os_log_type_enabled(v12, v20[0]))
      {
        *buf = 136446210;
        v22 = "nw_protocol_socket_get_receive_buffer_size";
        v14 = "%{public}s called with null handle";
LABEL_37:
        _os_log_impl(&dword_181A37000, v12, v13, v14, buf, 0xCu);
      }
    }

    else if (v19 == 1)
    {
      v15 = __nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v13 = v20[0];
      v16 = os_log_type_enabled(v12, v20[0]);
      if (v15)
      {
        if (v16)
        {
          *buf = 136446466;
          v22 = "nw_protocol_socket_get_receive_buffer_size";
          v23 = 2082;
          *v24 = v15;
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v15);
        goto LABEL_38;
      }

      if (v16)
      {
        *buf = 136446210;
        v22 = "nw_protocol_socket_get_receive_buffer_size";
        v14 = "%{public}s called with null handle, no backtrace";
        goto LABEL_37;
      }
    }

    else
    {
      v12 = __nwlog_obj();
      v13 = v20[0];
      if (os_log_type_enabled(v12, v20[0]))
      {
        *buf = 136446210;
        v22 = "nw_protocol_socket_get_receive_buffer_size";
        v14 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_37;
      }
    }
  }

LABEL_38:
  if (v11)
  {
    free(v11);
  }

  return 0;
}

void nw_socket_error(nw_protocol *a1, nw_protocol *a2)
{
  v59 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_socket_error";
    v2 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v2, &type, &v51))
    {
      goto LABEL_94;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v35 = __nwlog_obj();
      v36 = type;
      if (!os_log_type_enabled(v35, type))
      {
        goto LABEL_94;
      }

      *buf = 136446210;
      v54 = "nw_socket_error";
      v37 = "%{public}s called with null protocol";
    }

    else if (v51 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = type;
      v44 = os_log_type_enabled(v35, type);
      if (backtrace_string)
      {
        if (v44)
        {
          *buf = 136446466;
          v54 = "nw_socket_error";
          v55 = 2082;
          v56 = backtrace_string;
          _os_log_impl(&dword_181A37000, v35, v36, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (v2)
        {
          goto LABEL_46;
        }

        return;
      }

      if (!v44)
      {
LABEL_94:
        if (!v2)
        {
          return;
        }

        goto LABEL_46;
      }

      *buf = 136446210;
      v54 = "nw_socket_error";
      v37 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v35 = __nwlog_obj();
      v36 = type;
      if (!os_log_type_enabled(v35, type))
      {
        goto LABEL_94;
      }

      *buf = 136446210;
      v54 = "nw_socket_error";
      v37 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v35, v36, v37, buf, 0xCu);
    goto LABEL_94;
  }

  v2 = a1;
  handle = a1->handle;
  v4 = a1;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    goto LABEL_6;
  }

  if (handle != &nw_protocol_ref_counted_additional_handle)
  {
    v5 = 1;
    goto LABEL_11;
  }

  v4 = *a1[1].flow_id;
  if (v4)
  {
LABEL_6:
    callbacks = v4[1].callbacks;
    v5 = 0;
    if (callbacks)
    {
      v4[1].callbacks = (&callbacks->add_input_handler + 1);
    }
  }

  else
  {
    v5 = 1;
  }

  handle = a1->handle;
LABEL_11:
  v7 = a1;
  if (handle == &nw_protocol_ref_counted_handle)
  {
LABEL_18:
    v12 = v7[2].callbacks;
    if (v12)
    {
      connect = v12->connect;
      if (connect)
      {
        v14 = *(connect + 7);
        if (v14)
        {
          v14();
          goto LABEL_35;
        }
      }
    }

    __nwlog_obj();
    v27 = v7[2].callbacks;
    v28 = "invalid";
    if (v27)
    {
      replace_input_handler = v27->replace_input_handler;
      if (replace_input_handler)
      {
        v28 = replace_input_handler;
      }
    }

    *buf = 136446466;
    v54 = "nw_socket_error";
    v55 = 2082;
    v56 = v28;
    v8 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (__nwlog_fault(v8, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (!os_log_type_enabled(v30, type))
        {
          goto LABEL_33;
        }

        v32 = v7[2].callbacks;
        v33 = "invalid";
        if (v32)
        {
          v34 = v32->replace_input_handler;
          if (v34)
          {
            v33 = v34;
          }
        }

        *buf = 136446466;
        v54 = "nw_socket_error";
        v55 = 2082;
        v56 = v33;
        v11 = "%{public}s protocol %{public}s has invalid error callback";
      }

      else if (v51 == 1)
      {
        v38 = __nw_create_backtrace_string();
        v30 = __nwlog_obj();
        v31 = type;
        v39 = os_log_type_enabled(v30, type);
        if (v38)
        {
          if (v39)
          {
            v40 = v7[2].callbacks;
            v41 = "invalid";
            if (v40)
            {
              v42 = v40->replace_input_handler;
              if (v42)
              {
                v41 = v42;
              }
            }

            *buf = 136446722;
            v54 = "nw_socket_error";
            v55 = 2082;
            v56 = v41;
            v57 = 2082;
            v58 = v38;
            _os_log_impl(&dword_181A37000, v30, v31, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v38);
          goto LABEL_33;
        }

        if (!v39)
        {
          goto LABEL_33;
        }

        v48 = v7[2].callbacks;
        v49 = "invalid";
        if (v48)
        {
          v50 = v48->replace_input_handler;
          if (v50)
          {
            v49 = v50;
          }
        }

        *buf = 136446466;
        v54 = "nw_socket_error";
        v55 = 2082;
        v56 = v49;
        v11 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
      }

      else
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (!os_log_type_enabled(v30, type))
        {
          goto LABEL_33;
        }

        v45 = v7[2].callbacks;
        v46 = "invalid";
        if (v45)
        {
          v47 = v45->replace_input_handler;
          if (v47)
          {
            v46 = v47;
          }
        }

        *buf = 136446466;
        v54 = "nw_socket_error";
        v55 = 2082;
        v56 = v46;
        v11 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
      }

      v19 = v30;
      v20 = v31;
      v21 = 22;
      goto LABEL_32;
    }

LABEL_33:
    if (!v8)
    {
      goto LABEL_35;
    }

    goto LABEL_34;
  }

  if (handle == &nw_protocol_ref_counted_additional_handle)
  {
    v7 = *a1[1].flow_id;
    goto LABEL_18;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446210;
  v54 = "nw_socket_error";
  v8 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v51 = 0;
  if (!__nwlog_fault(v8, &type, &v51))
  {
    goto LABEL_33;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    v10 = type;
    if (!os_log_type_enabled(gLogObj, type))
    {
      goto LABEL_33;
    }

    *buf = 136446210;
    v54 = "nw_socket_error";
    v11 = "%{public}s called with null socket_handler";
LABEL_30:
    v19 = v9;
    v20 = v10;
LABEL_31:
    v21 = 12;
LABEL_32:
    _os_log_impl(&dword_181A37000, v19, v20, v11, buf, v21);
    goto LABEL_33;
  }

  if (v51 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    v10 = type;
    if (!os_log_type_enabled(gLogObj, type))
    {
      goto LABEL_33;
    }

    *buf = 136446210;
    v54 = "nw_socket_error";
    v11 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    goto LABEL_30;
  }

  v15 = __nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v16 = gLogObj;
  v17 = type;
  v18 = os_log_type_enabled(gLogObj, type);
  if (!v15)
  {
    if (v18)
    {
      *buf = 136446210;
      v54 = "nw_socket_error";
      v11 = "%{public}s called with null socket_handler, no backtrace";
      v19 = v16;
      v20 = v17;
      goto LABEL_31;
    }

    goto LABEL_33;
  }

  if (v18)
  {
    *buf = 136446466;
    v54 = "nw_socket_error";
    v55 = 2082;
    v56 = v15;
    _os_log_impl(&dword_181A37000, v16, v17, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v8)
  {
LABEL_34:
    free(v8);
  }

LABEL_35:
  if ((v5 & 1) == 0)
  {
    v22 = v2->handle;
    if (v22 == &nw_protocol_ref_counted_handle || v22 == &nw_protocol_ref_counted_additional_handle && (v2 = *v2[1].flow_id) != 0)
    {
      v23 = v2[1].callbacks;
      if (v23)
      {
        v24 = (v23 - 1);
        v2[1].callbacks = v24;
        if (!v24)
        {
          v25 = *v2[1].flow_id;
          if (v25)
          {
            *v2[1].flow_id = 0;
            v25[2](v25);
            _Block_release(v25);
          }

          if (v2[1].flow_id[8])
          {
            v26 = *v2[1].flow_id;
            if (v26)
            {
              _Block_release(v26);
            }
          }

LABEL_46:
          free(v2);
        }
      }
    }
  }
}

uint64_t nw_socket_get_output_interface(nw_protocol *a1)
{
  v36 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v33 = "nw_socket_get_output_interface";
    v24 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v24, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *buf = 136446210;
          v33 = "nw_socket_get_output_interface";
          v27 = "%{public}s called with null protocol";
LABEL_59:
          _os_log_impl(&dword_181A37000, v25, v26, v27, buf, 0xCu);
        }
      }

      else if (v30 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v25 = __nwlog_obj();
        v26 = type;
        v29 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *buf = 136446466;
            v33 = "nw_socket_get_output_interface";
            v34 = 2082;
            v35 = backtrace_string;
            _os_log_impl(&dword_181A37000, v25, v26, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_60;
        }

        if (v29)
        {
          *buf = 136446210;
          v33 = "nw_socket_get_output_interface";
          v27 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_59;
        }
      }

      else
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *buf = 136446210;
          v33 = "nw_socket_get_output_interface";
          v27 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_59;
        }
      }
    }

LABEL_60:
    if (v24)
    {
      free(v24);
    }

    return 0;
  }

  v1 = a1;
  handle = a1->handle;
  v3 = a1;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    goto LABEL_6;
  }

  if (handle != &nw_protocol_ref_counted_additional_handle)
  {
    v4 = 1;
    goto LABEL_11;
  }

  v3 = *a1[1].flow_id;
  if (v3)
  {
LABEL_6:
    callbacks = v3[1].callbacks;
    v4 = 0;
    if (callbacks)
    {
      v3[1].callbacks = (&callbacks->add_input_handler + 1);
    }
  }

  else
  {
    v4 = 1;
  }

  handle = a1->handle;
LABEL_11:
  v6 = a1;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    goto LABEL_18;
  }

  if (handle == &nw_protocol_ref_counted_additional_handle)
  {
    v6 = *a1[1].flow_id;
LABEL_18:
    result = *&v6[3].flow_id[8];
    if (v4)
    {
      return result;
    }

    goto LABEL_32;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446210;
  v33 = "nw_socket_get_output_interface";
  v7 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v30 = 0;
  if (!__nwlog_fault(v7, &type, &v30))
  {
    goto LABEL_29;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    v9 = type;
    if (!os_log_type_enabled(gLogObj, type))
    {
      goto LABEL_29;
    }

    *buf = 136446210;
    v33 = "nw_socket_get_output_interface";
    v10 = "%{public}s called with null socket_handler";
LABEL_27:
    v16 = v8;
    v17 = v9;
LABEL_28:
    _os_log_impl(&dword_181A37000, v16, v17, v10, buf, 0xCu);
    goto LABEL_29;
  }

  if (v30 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    v9 = type;
    if (!os_log_type_enabled(gLogObj, type))
    {
      goto LABEL_29;
    }

    *buf = 136446210;
    v33 = "nw_socket_get_output_interface";
    v10 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    goto LABEL_27;
  }

  v12 = __nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v13 = gLogObj;
  v14 = type;
  v15 = os_log_type_enabled(gLogObj, type);
  if (v12)
  {
    if (v15)
    {
      *buf = 136446466;
      v33 = "nw_socket_get_output_interface";
      v34 = 2082;
      v35 = v12;
      _os_log_impl(&dword_181A37000, v13, v14, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v12);
  }

  else if (v15)
  {
    *buf = 136446210;
    v33 = "nw_socket_get_output_interface";
    v10 = "%{public}s called with null socket_handler, no backtrace";
    v16 = v13;
    v17 = v14;
    goto LABEL_28;
  }

LABEL_29:
  if (v7)
  {
    free(v7);
  }

  result = 0;
  if ((v4 & 1) == 0)
  {
LABEL_32:
    v18 = v1->handle;
    if (v18 == &nw_protocol_ref_counted_handle || v18 == &nw_protocol_ref_counted_additional_handle && (v1 = *v1[1].flow_id) != 0)
    {
      v19 = v1[1].callbacks;
      if (v19)
      {
        v20 = (v19 - 1);
        v1[1].callbacks = v20;
        if (!v20)
        {
          v21 = result;
          v22 = *v1[1].flow_id;
          if (v22)
          {
            *v1[1].flow_id = 0;
            v22[2](v22);
            _Block_release(v22);
          }

          if (v1[1].flow_id[8])
          {
            v23 = *v1[1].flow_id;
            if (v23)
            {
              _Block_release(v23);
            }
          }

          free(v1);
          return v21;
        }
      }
    }
  }

  return result;
}

uint64_t ___ZL25__nw_frame_array_finalizeP16nw_frame_array_sbb_block_invoke_68307(uint64_t a1, uint64_t a2)
{
  v20 = *MEMORY[0x1E69E9840];
  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v17 = "__nw_frame_finalize";
    v6 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
    {
      goto LABEL_33;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_33;
      }

      *buf = 136446210;
      v17 = "__nw_frame_finalize";
      v9 = "%{public}s called with null frame";
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v17 = "__nw_frame_finalize";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_33:
        if (!v6)
        {
          return 1;
        }

LABEL_34:
        free(v6);
        return 1;
      }

      if (!v11)
      {
        goto LABEL_33;
      }

      *buf = 136446210;
      v17 = "__nw_frame_finalize";
      v9 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
      {
        goto LABEL_33;
      }

      *buf = 136446210;
      v17 = "__nw_frame_finalize";
      v9 = "%{public}s called with null frame, backtrace limit exceeded";
    }

LABEL_32:
    _os_log_impl(&dword_181A37000, v7, v8, v9, buf, 0xCu);
    goto LABEL_33;
  }

  v2 = *(a2 + 80);
  if (v2)
  {
    v3 = *(a1 + 32);
    v4 = *(a2 + 88);
    *(a2 + 80) = 0;
    *(a2 + 88) = 0;
    v2(a2, v3, v4);
    return 1;
  }

  __nwlog_obj();
  *buf = 136446210;
  v17 = "__nw_frame_finalize";
  v6 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (!__nwlog_fault(v6, &type, &v14))
  {
    goto LABEL_33;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_33;
    }

    *buf = 136446210;
    v17 = "__nw_frame_finalize";
    v9 = "%{public}s called with null frame->finalizer";
    goto LABEL_32;
  }

  if (v14 != 1)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
    {
      goto LABEL_33;
    }

    *buf = 136446210;
    v17 = "__nw_frame_finalize";
    v9 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
    goto LABEL_32;
  }

  v12 = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v13 = os_log_type_enabled(v7, type);
  if (!v12)
  {
    if (!v13)
    {
      goto LABEL_33;
    }

    *buf = 136446210;
    v17 = "__nw_frame_finalize";
    v9 = "%{public}s called with null frame->finalizer, no backtrace";
    goto LABEL_32;
  }

  if (v13)
  {
    *buf = 136446466;
    v17 = "__nw_frame_finalize";
    v18 = 2082;
    v19 = v12;
    _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v12);
  if (v6)
  {
    goto LABEL_34;
  }

  return 1;
}

void nw_socket_output_available(nw_protocol *a1, nw_protocol *a2)
{
  v38 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v35 = "nw_socket_output_available";
    v2 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v2, &type, &v32))
    {
      goto LABEL_68;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
      {
        goto LABEL_68;
      }

      *buf = 136446210;
      v35 = "nw_socket_output_available";
      v29 = "%{public}s called with null protocol";
    }

    else if (v32 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v27 = __nwlog_obj();
      v28 = type;
      v31 = os_log_type_enabled(v27, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *buf = 136446466;
          v35 = "nw_socket_output_available";
          v36 = 2082;
          v37 = backtrace_string;
          _os_log_impl(&dword_181A37000, v27, v28, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (v2)
        {
          goto LABEL_49;
        }

        return;
      }

      if (!v31)
      {
LABEL_68:
        if (!v2)
        {
          return;
        }

        goto LABEL_49;
      }

      *buf = 136446210;
      v35 = "nw_socket_output_available";
      v29 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
      {
        goto LABEL_68;
      }

      *buf = 136446210;
      v35 = "nw_socket_output_available";
      v29 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v27, v28, v29, buf, 0xCu);
    goto LABEL_68;
  }

  v2 = a1;
  handle = a1->handle;
  v4 = a1;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    goto LABEL_6;
  }

  if (handle != &nw_protocol_ref_counted_additional_handle)
  {
    v5 = 1;
    goto LABEL_11;
  }

  v4 = *a1[1].flow_id;
  if (v4)
  {
LABEL_6:
    callbacks = v4[1].callbacks;
    v5 = 0;
    if (callbacks)
    {
      v4[1].callbacks = (&callbacks->add_input_handler + 1);
    }
  }

  else
  {
    v5 = 1;
  }

  handle = a1->handle;
LABEL_11:
  v7 = a1;
  if (handle != &nw_protocol_ref_counted_handle)
  {
    if (handle != &nw_protocol_ref_counted_additional_handle)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *buf = 136446210;
      v35 = "nw_socket_output_available";
      v8 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v32 = 0;
      if (!__nwlog_fault(v8, &type, &v32))
      {
        goto LABEL_36;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_36;
        }

        *buf = 136446210;
        v35 = "nw_socket_output_available";
        v11 = "%{public}s called with null socket_handler";
      }

      else
      {
        if (v32 == 1)
        {
          v16 = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v17 = gLogObj;
          v18 = type;
          v19 = os_log_type_enabled(gLogObj, type);
          if (v16)
          {
            if (v19)
            {
              *buf = 136446466;
              v35 = "nw_socket_output_available";
              v36 = 2082;
              v37 = v16;
              _os_log_impl(&dword_181A37000, v17, v18, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v16);
            goto LABEL_36;
          }

          if (!v19)
          {
LABEL_36:
            if (v8)
            {
              free(v8);
            }

            goto LABEL_38;
          }

          *buf = 136446210;
          v35 = "nw_socket_output_available";
          v11 = "%{public}s called with null socket_handler, no backtrace";
          v20 = v17;
          v21 = v18;
LABEL_35:
          _os_log_impl(&dword_181A37000, v20, v21, v11, buf, 0xCu);
          goto LABEL_36;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_36;
        }

        *buf = 136446210;
        v35 = "nw_socket_output_available";
        v11 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      }

      v20 = v9;
      v21 = v10;
      goto LABEL_35;
    }

    v7 = *a1[1].flow_id;
  }

  v12 = v7[2].callbacks;
  if (v12)
  {
    connect = v12->connect;
    if (connect)
    {
      v14 = *(connect + 9);
      if (v14)
      {
        v14();
      }
    }
  }

  else if ((*(&v7[6].callbacks + 5) & 0x80) == 0)
  {
    if (__nwlog_connection_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
    }

    v15 = gconnectionLogObj;
    if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v35 = "nw_socket_output_available";
      v36 = 2082;
      v37 = &v7[6].output_handler + 4;
      _os_log_impl(&dword_181A37000, v15, OS_LOG_TYPE_ERROR, "%{public}s %{public}s No input handler", buf, 0x16u);
    }
  }

LABEL_38:
  if ((v5 & 1) == 0)
  {
    v22 = v2->handle;
    if (v22 == &nw_protocol_ref_counted_handle || v22 == &nw_protocol_ref_counted_additional_handle && (v2 = *v2[1].flow_id) != 0)
    {
      v23 = v2[1].callbacks;
      if (v23)
      {
        v24 = (v23 - 1);
        v2[1].callbacks = v24;
        if (!v24)
        {
          v25 = *v2[1].flow_id;
          if (v25)
          {
            *v2[1].flow_id = 0;
            (v25)[2](v25, a2);
            _Block_release(v25);
          }

          if (v2[1].flow_id[8])
          {
            v26 = *v2[1].flow_id;
            if (v26)
            {
              _Block_release(v26);
            }
          }

LABEL_49:
          free(v2);
        }
      }
    }
  }
}

void nw_socket_input_available(nw_protocol *a1, nw_protocol *a2)
{
  v38 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v35 = "nw_socket_input_available";
    v2 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v2, &type, &v32))
    {
      goto LABEL_68;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
      {
        goto LABEL_68;
      }

      *buf = 136446210;
      v35 = "nw_socket_input_available";
      v29 = "%{public}s called with null protocol";
    }

    else if (v32 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v27 = __nwlog_obj();
      v28 = type;
      v31 = os_log_type_enabled(v27, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *buf = 136446466;
          v35 = "nw_socket_input_available";
          v36 = 2082;
          v37 = backtrace_string;
          _os_log_impl(&dword_181A37000, v27, v28, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (v2)
        {
          goto LABEL_49;
        }

        return;
      }

      if (!v31)
      {
LABEL_68:
        if (!v2)
        {
          return;
        }

        goto LABEL_49;
      }

      *buf = 136446210;
      v35 = "nw_socket_input_available";
      v29 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
      {
        goto LABEL_68;
      }

      *buf = 136446210;
      v35 = "nw_socket_input_available";
      v29 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A37000, v27, v28, v29, buf, 0xCu);
    goto LABEL_68;
  }

  v2 = a1;
  handle = a1->handle;
  v4 = a1;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    goto LABEL_6;
  }

  if (handle != &nw_protocol_ref_counted_additional_handle)
  {
    v5 = 1;
    goto LABEL_11;
  }

  v4 = *a1[1].flow_id;
  if (v4)
  {
LABEL_6:
    callbacks = v4[1].callbacks;
    v5 = 0;
    if (callbacks)
    {
      v4[1].callbacks = (&callbacks->add_input_handler + 1);
    }
  }

  else
  {
    v5 = 1;
  }

  handle = a1->handle;
LABEL_11:
  v7 = a1;
  if (handle != &nw_protocol_ref_counted_handle)
  {
    if (handle != &nw_protocol_ref_counted_additional_handle)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *buf = 136446210;
      v35 = "nw_socket_input_available";
      v8 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v32 = 0;
      if (!__nwlog_fault(v8, &type, &v32))
      {
        goto LABEL_36;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_36;
        }

        *buf = 136446210;
        v35 = "nw_socket_input_available";
        v11 = "%{public}s called with null socket_handler";
      }

      else
      {
        if (v32 == 1)
        {
          v16 = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v17 = gLogObj;
          v18 = type;
          v19 = os_log_type_enabled(gLogObj, type);
          if (v16)
          {
            if (v19)
            {
              *buf = 136446466;
              v35 = "nw_socket_input_available";
              v36 = 2082;
              v37 = v16;
              _os_log_impl(&dword_181A37000, v17, v18, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v16);
            goto LABEL_36;
          }

          if (!v19)
          {
LABEL_36:
            if (v8)
            {
              free(v8);
            }

            goto LABEL_38;
          }

          *buf = 136446210;
          v35 = "nw_socket_input_available";
          v11 = "%{public}s called with null socket_handler, no backtrace";
          v20 = v17;
          v21 = v18;
LABEL_35:
          _os_log_impl(&dword_181A37000, v20, v21, v11, buf, 0xCu);
          goto LABEL_36;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_36;
        }

        *buf = 136446210;
        v35 = "nw_socket_input_available";
        v11 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      }

      v20 = v9;
      v21 = v10;
      goto LABEL_35;
    }

    v7 = *a1[1].flow_id;
  }

  v12 = v7[2].callbacks;
  if (v12)
  {
    connect = v12->connect;
    if (connect)
    {
      v14 = *(connect + 8);
      if (v14)
      {
        v14();
      }
    }
  }

  else if ((*(&v7[6].callbacks + 5) & 0x80) == 0)
  {
    if (__nwlog_connection_log::onceToken[0] != -1)
    {
      dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
    }

    v15 = gconnectionLogObj;
    if (os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v35 = "nw_socket_input_available";
      v36 = 2082;
      v37 = &v7[6].output_handler + 4;
      _os_log_impl(&dword_181A37000, v15, OS_LOG_TYPE_ERROR, "%{public}s %{public}s No input handler", buf, 0x16u);
    }
  }

LABEL_38:
  if ((v5 & 1) == 0)
  {
    v22 = v2->handle;
    if (v22 == &nw_protocol_ref_counted_handle || v22 == &nw_protocol_ref_counted_additional_handle && (v2 = *v2[1].flow_id) != 0)
    {
      v23 = v2[1].callbacks;
      if (v23)
      {
        v24 = (v23 - 1);
        v2[1].callbacks = v24;
        if (!v24)
        {
          v25 = *v2[1].flow_id;
          if (v25)
          {
            *v2[1].flow_id = 0;
            (v25)[2](v25, a2);
            _Block_release(v25);
          }

          if (v2[1].flow_id[8])
          {
            v26 = *v2[1].flow_id;
            if (v26)
            {
              _Block_release(v26);
            }
          }

LABEL_49:
          free(v2);
        }
      }
    }
  }
}

BOOL nw_socket_replace_input_handler(nw_protocol *a1, nw_protocol *a2, nw_protocol *a3)
{
  v84 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v3 = a1;
    handle = a1->handle;
    v5 = a1;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      goto LABEL_6;
    }

    if (handle != &nw_protocol_ref_counted_additional_handle)
    {
      v6 = 1;
      goto LABEL_11;
    }

    v5 = *a1[1].flow_id;
    if (v5)
    {
LABEL_6:
      callbacks = v5[1].callbacks;
      v6 = 0;
      if (callbacks)
      {
        v5[1].callbacks = (&callbacks->add_input_handler + 1);
      }
    }

    else
    {
      v6 = 1;
    }

    handle = a1->handle;
LABEL_11:
    v8 = a1;
    if (handle != &nw_protocol_ref_counted_handle)
    {
      if (handle != &nw_protocol_ref_counted_additional_handle)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *buf = 136446210;
        v77 = "nw_socket_replace_input_handler";
        v9 = _os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v74 = 0;
        if (!__nwlog_fault(v9, &type, &v74))
        {
          goto LABEL_59;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = gLogObj;
          v11 = type;
          if (!os_log_type_enabled(gLogObj, type))
          {
            goto LABEL_59;
          }

          *buf = 136446210;
          v77 = "nw_socket_replace_input_handler";
          v12 = "%{public}s called with null socket_handler";
LABEL_57:
          v35 = v10;
          v36 = v11;
LABEL_58:
          _os_log_impl(&dword_181A37000, v35, v36, v12, buf, 0xCu);
          goto LABEL_59;
        }

        if (v74 != 1)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = gLogObj;
          v11 = type;
          if (!os_log_type_enabled(gLogObj, type))
          {
            goto LABEL_59;
          }

          *buf = 136446210;
          v77 = "nw_socket_replace_input_handler";
          v12 = "%{public}s called with null socket_handler, backtrace limit exceeded";
          goto LABEL_57;
        }

        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        v19 = type;
        v20 = os_log_type_enabled(gLogObj, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *buf = 136446466;
            v77 = "nw_socket_replace_input_handler";
            v78 = 2082;
            v79 = backtrace_string;
            v21 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
LABEL_43:
            _os_log_impl(&dword_181A37000, v18, v19, v21, buf, 0x16u);
            goto LABEL_44;
          }

          goto LABEL_44;
        }

        if (v20)
        {
          *buf = 136446210;
          v77 = "nw_socket_replace_input_handler";
          v12 = "%{public}s called with null socket_handler, no backtrace";
LABEL_86:
          v35 = v18;
          v36 = v19;
          goto LABEL_58;
        }

        goto LABEL_59;
      }

      v8 = *a1[1].flow_id;
    }

    if (!a2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *buf = 136446210;
      v77 = "nw_socket_replace_input_handler";
      v9 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v74 = 0;
      if (!__nwlog_fault(v9, &type, &v74))
      {
        goto LABEL_59;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        v11 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_59;
        }

        *buf = 136446210;
        v77 = "nw_socket_replace_input_handler";
        v12 = "%{public}s called with null old_input_handler";
        goto LABEL_57;
      }

      if (v74 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        v11 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_59;
        }

        *buf = 136446210;
        v77 = "nw_socket_replace_input_handler";
        v12 = "%{public}s called with null old_input_handler, backtrace limit exceeded";
        goto LABEL_57;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = gLogObj;
      v19 = type;
      v26 = os_log_type_enabled(gLogObj, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *buf = 136446466;
          v77 = "nw_socket_replace_input_handler";
          v78 = 2082;
          v79 = backtrace_string;
          v21 = "%{public}s called with null old_input_handler, dumping backtrace:%{public}s";
          goto LABEL_43;
        }

LABEL_44:
        free(backtrace_string);
        goto LABEL_59;
      }

      if (v26)
      {
        *buf = 136446210;
        v77 = "nw_socket_replace_input_handler";
        v12 = "%{public}s called with null old_input_handler, no backtrace";
        goto LABEL_86;
      }

LABEL_59:
      if (v9)
      {
        free(v9);
      }

LABEL_61:
      result = 0;
      if (v6)
      {
        return result;
      }

      goto LABEL_73;
    }

    if (a3)
    {
      if (v8[2].callbacks != a2)
      {
        if ((*(&v8[6].callbacks + 5) & 0x80) != 0)
        {
          goto LABEL_61;
        }

        if (__nwlog_connection_log::onceToken[0] != -1)
        {
          dispatch_once(__nwlog_connection_log::onceToken, &__block_literal_global_28_47435);
        }

        v14 = gconnectionLogObj;
        result = os_log_type_enabled(gconnectionLogObj, OS_LOG_TYPE_ERROR);
        if (result)
        {
          v16 = v8[2].callbacks;
          *buf = 136446978;
          v77 = "nw_socket_replace_input_handler";
          v78 = 2082;
          v79 = &v8[6].output_handler + 4;
          v80 = 2048;
          v81 = v16;
          v82 = 2048;
          v83 = a2;
          _os_log_impl(&dword_181A37000, v14, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Old input handler does not match (%p != %p)", buf, 0x2Au);
          result = 0;
          if (v6)
          {
            return result;
          }

LABEL_73:
          v39 = v3->handle;
          if (v39 == &nw_protocol_ref_counted_handle || v39 == &nw_protocol_ref_counted_additional_handle && (v3 = *v3[1].flow_id) != 0)
          {
            v40 = v3[1].callbacks;
            if (v40)
            {
              v41 = (v40 - 1);
              v3[1].callbacks = v41;
              if (!v41)
              {
                v42 = result;
                v43 = *v3[1].flow_id;
                if (v43)
                {
                  *v3[1].flow_id = 0;
                  v43[2](v43);
                  _Block_release(v43);
                }

                if (v3[1].flow_id[8])
                {
                  v44 = *v3[1].flow_id;
                  if (v44)
                  {
                    _Block_release(v44);
                  }
                }

                free(v3);
                return v42;
              }
            }
          }

          return result;
        }

LABEL_72:
        if (v6)
        {
          return result;
        }

        goto LABEL_73;
      }

      v27 = a3->handle;
      v28 = a3;
      if (v27 == &nw_protocol_ref_counted_handle || v27 == &nw_protocol_ref_counted_additional_handle && (v28 = *a3[1].flow_id) != 0)
      {
        v45 = v28[1].callbacks;
        if (v45)
        {
          v28[1].callbacks = (&v45->add_input_handler + 1);
        }

        v30 = 1;
      }

      else
      {
        v30 = 0;
      }

      nw::retained_ptr<nw_protocol *>::~retained_ptr(&v8[2].callbacks);
      v46 = a3;
      v8[2].callbacks = a3;
      LOBYTE(v8[2].output_handler) = v8[2].output_handler & 0xFE | v30;
      if (!a3->output_handler)
      {
        if (v8)
        {
          nw_protocol_release(0);
          v46 = a3;
          a3->output_handler = v8;
          v47 = v8->handle;
          v48 = v8;
          if (v47 == &nw_protocol_ref_counted_handle || v47 == &nw_protocol_ref_counted_additional_handle && (v48 = *v8[1].flow_id) != 0)
          {
            v49 = v48[1].callbacks;
            if (v49)
            {
              v48[1].callbacks = (&v49->add_input_handler + 1);
            }
          }
        }
      }

      v50 = v46->callbacks;
      if (v50 && (supports_external_data = v50->supports_external_data) != 0)
      {
        v52 = v46->handle;
        v53 = v46;
        if (v52 == &nw_protocol_ref_counted_handle || v52 == &nw_protocol_ref_counted_additional_handle && (v53 = *v46[1].flow_id) != 0)
        {
          v55 = v53[1].callbacks;
          if (v55)
          {
            v53[1].callbacks = (&v55->add_input_handler + 1);
          }

          v56 = supports_external_data();
          v57 = a3;
          v54 = v56;
          v58 = v57->handle;
          if (v58 == &nw_protocol_ref_counted_handle || v58 == &nw_protocol_ref_counted_additional_handle && (v57 = *v57[1].flow_id) != 0)
          {
            v59 = v57[1].callbacks;
            if (v59)
            {
              v60 = (v59 - 1);
              v57[1].callbacks = v60;
              if (!v60)
              {
                v61 = *v57[1].flow_id;
                if (v61)
                {
                  *v57[1].flow_id = 0;
                  v62 = v57;
                  v61[2](v61);
                  _Block_release(v61);
                  v57 = v62;
                }

                if (v57[1].flow_id[8])
                {
                  v63 = *v57[1].flow_id;
                  if (v63)
                  {
                    v64 = v57;
                    _Block_release(v63);
                    v57 = v64;
                  }
                }

                free(v57);
              }
            }
          }
        }

        else
        {
          v54 = supports_external_data();
        }

        v65 = (&v8[6].callbacks + 5);
        if (((v54 ^ ((*(&v8[6].callbacks + 5) & 0x1000) == 0)) & 1) == 0)
        {
          nw_socket_release_frame_array(&v8[4].output_handler_context);
          v66 = *v65;
          if (v54)
          {
            v67 = 4096;
          }

          else
          {
            v67 = 0;
          }

          goto LABEL_121;
        }
      }

      else
      {
        v65 = (&v8[6].callbacks + 5);
        if ((*(&v8[6].callbacks + 5) & 0x1000) != 0)
        {
          nw_socket_release_frame_array(&v8[4].output_handler_context);
          v67 = 0;
          v66 = *v65;
LABEL_121:
          *v65 = v66 & 0xEFFF | v67;
        }
      }

      result = 1;
      if (v6)
      {
        return result;
      }

      goto LABEL_73;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446210;
    v77 = "nw_socket_replace_input_handler";
    v22 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v74 = 0;
    if (__nwlog_fault(v22, &type, &v74))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v24 = type;
        if (os_log_type_enabled(gLogObj, type))
        {
          *buf = 136446210;
          v77 = "nw_socket_replace_input_handler";
          v25 = "%{public}s called with null new_input_handler";
LABEL_67:
          v37 = v23;
          v38 = v24;
LABEL_68:
          _os_log_impl(&dword_181A37000, v37, v38, v25, buf, 0xCu);
        }
      }

      else if (v74 == 1)
      {
        v31 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v32 = gLogObj;
        v33 = type;
        v34 = os_log_type_enabled(gLogObj, type);
        if (v31)
        {
          if (v34)
          {
            *buf = 136446466;
            v77 = "nw_socket_replace_input_handler";
            v78 = 2082;
            v79 = v31;
            _os_log_impl(&dword_181A37000, v32, v33, "%{public}s called with null new_input_handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v31);
          goto LABEL_69;
        }

        if (v34)
        {
          *buf = 136446210;
          v77 = "nw_socket_replace_input_handler";
          v25 = "%{public}s called with null new_input_handler, no backtrace";
          v37 = v32;
          v38 = v33;
          goto LABEL_68;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v24 = type;
        if (os_log_type_enabled(gLogObj, type))
        {
          *buf = 136446210;
          v77 = "nw_socket_replace_input_handler";
          v25 = "%{public}s called with null new_input_handler, backtrace limit exceeded";
          goto LABEL_67;
        }
      }
    }

LABEL_69:
    if (v22)
    {
      free(v22);
    }

    result = 0;
    goto LABEL_72;
  }

  __nwlog_obj();
  *buf = 136446210;
  v77 = "nw_socket_replace_input_handler";
  v68 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v74 = 0;
  if (__nwlog_fault(v68, &type, &v74))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v69 = __nwlog_obj();
      v70 = type;
      if (os_log_type_enabled(v69, type))
      {
        *buf = 136446210;
        v77 = "nw_socket_replace_input_handler";
        v71 = "%{public}s called with null protocol";
LABEL_141:
        _os_log_impl(&dword_181A37000, v69, v70, v71, buf, 0xCu);
      }
    }

    else if (v74 == 1)
    {
      v72 = __nw_create_backtrace_string();
      v69 = __nwlog_obj();
      v70 = type;
      v73 = os_log_type_enabled(v69, type);
      if (v72)
      {
        if (v73)
        {
          *buf = 136446466;
          v77 = "nw_socket_replace_input_handler";
          v78 = 2082;
          v79 = v72;
          _os_log_impl(&dword_181A37000, v69, v70, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v72);
        goto LABEL_142;
      }

      if (v73)
      {
        *buf = 136446210;
        v77 = "nw_socket_replace_input_handler";
        v71 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_141;
      }
    }

    else
    {
      v69 = __nwlog_obj();
      v70 = type;
      if (os_log_type_enabled(v69, type))
      {
        *buf = 136446210;
        v77 = "nw_socket_replace_input_handler";
        v71 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_141;
      }
    }
  }

LABEL_142:
  if (v68)
  {
    free(v68);
  }

  return 0;
}

const sockaddr *NWUtilsCreateNSStringFromSockaddr(const sockaddr *result, int a2)
{
  v7 = *MEMORY[0x1E69E9840];
  if (result)
  {
    if (a2)
    {
      v2 = result;
      if (getnameinfo(result, result->sa_len, v6, 0x46u, v5, 6u, 10))
      {
        return 0;
      }

      else
      {
        if (v2->sa_family == 30)
        {
          v4 = ".";
        }

        else
        {
          v4 = ":";
        }

        [MEMORY[0x1E696AEC0] stringWithFormat:@"%s%s%s", v6, v4, v5];
        return objc_claimAutoreleasedReturnValue();
      }
    }

    else
    {
      v3 = getnameinfo(result, result->sa_len, v6, 0x46u, 0, 0, 10);
      result = 0;
      if (!v3)
      {
        [MEMORY[0x1E696AEC0] stringWithUTF8String:v6];
        return objc_claimAutoreleasedReturnValue();
      }
    }
  }

  return result;
}

uint64_t NWUtilsStringMatchesPattern(void *a1, void *a2)
{
  v3 = a1;
  v4 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass()))
  {
    if ([v4 hasSuffix:@"*"])
    {
      v5 = [v4 substringWithRange:{0, objc_msgSend(v4, "length") - 1}];
      v6 = [v3 hasPrefix:v5];
    }

    else
    {
      if (![v4 hasPrefix:@"*"])
      {
        v7 = [v3 isEqualToString:v4];
        goto LABEL_6;
      }

      v5 = [v4 substringWithRange:{1, objc_msgSend(v4, "length") - 1}];
      v9 = [v3 length];
      if (v9 == [v5 length] - 1 && objc_msgSend(v5, "hasPrefix:", @"."))
      {
        v10 = [v5 substringWithRange:{1, objc_msgSend(v5, "length") - 1}];

        v5 = v10;
      }

      v6 = [v3 hasSuffix:v5];
    }

    v7 = v6;
  }

  else
  {
    v7 = 0;
  }

LABEL_6:

  return v7;
}

uint64_t NWUtilsStringMatchesPatternSet(void *a1, void *a2)
{
  v15 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v12 = 0u;
    v13 = 0u;
    v10 = 0u;
    v11 = 0u;
    v5 = v4;
    v6 = [v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
    if (v6)
    {
      v7 = *v11;
      while (2)
      {
        for (i = 0; i != v6; ++i)
        {
          if (*v11 != v7)
          {
            objc_enumerationMutation(v5);
          }

          if (NWUtilsStringMatchesPattern(v3, *(*(&v10 + 1) + 8 * i)))
          {
            v6 = 1;
            goto LABEL_13;
          }
        }

        v6 = [v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
        if (v6)
        {
          continue;
        }

        break;
      }
    }

LABEL_13:
  }

  else
  {
    v6 = 0;
  }

  return v6;
}

uint64_t NWUtilsAnyStringsMatchPatternSet(void *a1, void *a2)
{
  v15 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v5 = v3;
  v6 = [v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v6)
  {
    v7 = *v11;
    while (2)
    {
      for (i = 0; i != v6; ++i)
      {
        if (*v11 != v7)
        {
          objc_enumerationMutation(v5);
        }

        if (NWUtilsStringMatchesPatternSet(*(*(&v10 + 1) + 8 * i), v4))
        {
          v6 = 1;
          goto LABEL_11;
        }
      }

      v6 = [v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
      if (v6)
      {
        continue;
      }

      break;
    }
  }

LABEL_11:

  return v6;
}

uint64_t NWUtilsAreNSObjectsEqual(void *a1, void *a2)
{
  v3 = a1;
  v4 = a2;
  v5 = v4;
  v6 = v3 == v4;
  if (v3 != v4 && v3 && v4)
  {
    if ([v3 isMemberOfClass:objc_opt_class()])
    {
      v6 = [v3 isEqual:v5];
    }

    else
    {
      v6 = 0;
    }
  }

  return v6;
}

id NWUtilsCreateNSDictionaryFromXPCDictionary(void *a1)
{
  v1 = MEMORY[0x1E695DF90];
  v2 = a1;
  v3 = [v1 dictionary];
  applier[0] = MEMORY[0x1E69E9820];
  applier[1] = 3221225472;
  applier[2] = __NWUtilsCreateNSDictionaryFromXPCDictionary_block_invoke;
  applier[3] = &unk_1E6A39980;
  v4 = v3;
  v7 = v4;
  xpc_dictionary_apply(v2, applier);

  return v4;
}

uint64_t __NWUtilsCreateNSArrayFromXPCArray_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  Class = object_getClass(v4);
  if (Class == MEMORY[0x1E69E9E50])
  {
    v7 = MEMORY[0x1E695DF70];
    v8 = v4;
    v9 = [v7 array];
    applier = MEMORY[0x1E69E9820];
    v14 = 3221225472;
    v15 = __NWUtilsCreateNSArrayFromXPCArray_block_invoke;
    v16 = &unk_1E6A3D300;
    NSObjectFromSimpleXPCObject = v9;
    v17 = NSObjectFromSimpleXPCObject;
    xpc_array_apply(v8, &applier);
  }

  else
  {
    if (Class != MEMORY[0x1E69E9E80])
    {
      NSObjectFromSimpleXPCObject = NWUtilsCreateNSObjectFromSimpleXPCObject(v4);
      if (!NSObjectFromSimpleXPCObject)
      {
        goto LABEL_9;
      }

      goto LABEL_8;
    }

    v10 = MEMORY[0x1E695DF90];
    v8 = v4;
    v11 = [v10 dictionary];
    applier = MEMORY[0x1E69E9820];
    v14 = 3221225472;
    v15 = __NWUtilsCreateNSDictionaryFromXPCDictionary_block_invoke;
    v16 = &unk_1E6A39980;
    NSObjectFromSimpleXPCObject = v11;
    v17 = NSObjectFromSimpleXPCObject;
    xpc_dictionary_apply(v8, &applier);
  }

  if (NSObjectFromSimpleXPCObject)
  {
LABEL_8:
    [*(a1 + 32) addObject:NSObjectFromSimpleXPCObject];
  }

LABEL_9:

  return 1;
}

xpc_object_t NWUtilsCreateXPCArrayFromNSArray(void *a1, void *a2)
{
  v27 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = xpc_array_create(0, 0);
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v6 = v4;
  v7 = [v6 countByEnumeratingWithState:&v18 objects:v26 count:16];
  if (v7)
  {
    v8 = v7;
    v9 = *v19;
    do
    {
      for (i = 0; i != v8; ++i)
      {
        if (*v19 != v9)
        {
          objc_enumerationMutation(v6);
        }

        v11 = *(*(&v18 + 1) + 8 * i);
        objc_opt_class();
        isKindOfClass = objc_opt_isKindOfClass();

        if (isKindOfClass)
        {
          XPCArrayFromNSArray = NWUtilsCreateXPCArrayFromNSArray(v3, v11);
          if (XPCArrayFromNSArray)
          {
            goto LABEL_14;
          }
        }

        else
        {
          v14 = v11;
          objc_opt_class();
          v15 = objc_opt_isKindOfClass();

          if (v15)
          {
            XPCArrayFromNSArray = NWUtilsCreateXPCDictionaryFromNSDictionary(v14);
            if (XPCArrayFromNSArray)
            {
              goto LABEL_14;
            }
          }

          else
          {
            XPCArrayFromNSArray = NWUtilsCreateXPCObjectFromSimpleNSObject(v3, v14);
            if (XPCArrayFromNSArray)
            {
LABEL_14:
              xpc_array_append_value(v5, XPCArrayFromNSArray);
              goto LABEL_6;
            }
          }
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *buf = 136446466;
          v23 = "NWUtilsCreateXPCArrayFromNSArray";
          v24 = 2114;
          v25 = v11;
          _os_log_impl(&dword_181A37000, v16, OS_LOG_TYPE_ERROR, "%{public}s Could not create xpc object for %{public}@", buf, 0x16u);
        }

LABEL_6:
      }

      v8 = [v6 countByEnumeratingWithState:&v18 objects:v26 count:16];
    }

    while (v8);
  }

  return v5;
}

BOOL NWUtilsCurrentProcessHasEntitlement(void *a1)
{
  v39 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = SecTaskCreateFromSelf(*MEMORY[0x1E695E480]);
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    *buf = 136446210;
    v32 = "NWUtilsCurrentProcessHasEntitlement";
    v11 = _os_log_send_and_compose_impl();

    LOBYTE(error) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v11, &error, &type))
    {
      if (error == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v13 = error;
        if (!os_log_type_enabled(v12, error))
        {
          goto LABEL_46;
        }

        *buf = 136446210;
        v32 = "NWUtilsCurrentProcessHasEntitlement";
        v14 = "%{public}s SecTaskCreateFromSelf failed";
LABEL_44:
        v26 = v12;
        v27 = v13;
        goto LABEL_45;
      }

      if (type != OS_LOG_TYPE_INFO)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v13 = error;
        if (!os_log_type_enabled(v12, error))
        {
          goto LABEL_46;
        }

        *buf = 136446210;
        v32 = "NWUtilsCurrentProcessHasEntitlement";
        v14 = "%{public}s SecTaskCreateFromSelf failed, backtrace limit exceeded";
        goto LABEL_44;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v21 = error;
      v22 = os_log_type_enabled(v12, error);
      if (!backtrace_string)
      {
        if (!v22)
        {
LABEL_46:

          if (!v11)
          {
            goto LABEL_34;
          }

          goto LABEL_33;
        }

        *buf = 136446210;
        v32 = "NWUtilsCurrentProcessHasEntitlement";
        v14 = "%{public}s SecTaskCreateFromSelf failed, no backtrace";
        v26 = v12;
        v27 = v21;
LABEL_45:
        _os_log_impl(&dword_181A37000, v26, v27, v14, buf, 0xCu);
        goto LABEL_46;
      }

      if (v22)
      {
        *buf = 136446466;
        v32 = "NWUtilsCurrentProcessHasEntitlement";
        v33 = 2082;
        v34 = backtrace_string;
        _os_log_impl(&dword_181A37000, v12, v21, "%{public}s SecTaskCreateFromSelf failed, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }

    if (!v11)
    {
LABEL_34:
      v19 = 0;
      goto LABEL_35;
    }

LABEL_33:
    free(v11);
    goto LABEL_34;
  }

  v3 = v2;
  error = 0;
  v4 = SecTaskCopyValueForEntitlement(v2, v1, &error);
  if (error)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    *buf = 136446722;
    v32 = "NWUtilsCurrentProcessHasEntitlement";
    v33 = 2114;
    v34 = v1;
    v35 = 2114;
    v36 = error;
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v6, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
        {
          goto LABEL_40;
        }

        *buf = 136446722;
        v32 = "NWUtilsCurrentProcessHasEntitlement";
        v33 = 2114;
        v34 = v1;
        v35 = 2114;
        v36 = error;
        v9 = "%{public}s SecTaskCopyValueForEntitlement %{public}@ error %{public}@ failed";
LABEL_38:
        v24 = v7;
        v25 = v8;
        goto LABEL_39;
      }

      if (v28 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
        {
          goto LABEL_40;
        }

        *buf = 136446722;
        v32 = "NWUtilsCurrentProcessHasEntitlement";
        v33 = 2114;
        v34 = v1;
        v35 = 2114;
        v36 = error;
        v9 = "%{public}s SecTaskCopyValueForEntitlement %{public}@ error %{public}@ failed, backtrace limit exceeded";
        goto LABEL_38;
      }

      v15 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v16 = type;
      v17 = os_log_type_enabled(v7, type);
      if (!v15)
      {
        if (!v17)
        {
LABEL_40:

          if (!v6)
          {
LABEL_18:
            if (error)
            {
              CFRelease(error);
              error = 0;
            }

            goto LABEL_20;
          }

LABEL_17:
          free(v6);
          goto LABEL_18;
        }

        *buf = 136446722;
        v32 = "NWUtilsCurrentProcessHasEntitlement";
        v33 = 2114;
        v34 = v1;
        v35 = 2114;
        v36 = error;
        v9 = "%{public}s SecTaskCopyValueForEntitlement %{public}@ error %{public}@ failed, no backtrace";
        v24 = v7;
        v25 = v16;
LABEL_39:
        _os_log_impl(&dword_181A37000, v24, v25, v9, buf, 0x20u);
        goto LABEL_40;
      }

      if (v17)
      {
        *buf = 136446978;
        v32 = "NWUtilsCurrentProcessHasEntitlement";
        v33 = 2114;
        v34 = v1;
        v35 = 2114;
        v36 = error;
        v37 = 2082;
        v38 = v15;
        _os_log_impl(&dword_181A37000, v7, v16, "%{public}s SecTaskCopyValueForEntitlement %{public}@ error %{public}@ failed, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v15);
    }

    if (!v6)
    {
      goto LABEL_18;
    }

    goto LABEL_17;
  }

LABEL_20:
  if (v4)
  {
    v18 = CFGetTypeID(v4);
    v19 = v18 == CFBooleanGetTypeID() && CFBooleanGetValue(v4) != 0;
    CFRelease(v4);
  }

  else
  {
    v19 = 0;
  }

  CFRelease(v3);
LABEL_35:

  return v19;
}

uint64_t *nw_protocol_recorder_identifier()
{
  if (nw_protocol_recorder_identifier::onceToken != -1)
  {
    dispatch_once(&nw_protocol_recorder_identifier::onceToken, &__block_literal_global_68638);
  }

  return &g_recorder_protocol_identifier;
}

uint64_t __nw_protocol_recorder_identifier_block_invoke()
{
  qword_1EA842B90 = 0;
  *algn_1EA842B81 = 0u;
  strcpy(&g_recorder_protocol_identifier, "recorder");
  qword_1EA842B98 = 0x100000000;
  qword_1EA842BB0 = nw_protocol_default_replace_input_handler;
  qword_1EA842BE0 = nw_protocol_default_input_available;
  qword_1EA842BE8 = nw_protocol_default_output_available;
  qword_1EA842C58 = nw_protocol_default_input_finished;
  qword_1EA842C60 = nw_protocol_default_output_finished;
  qword_1EA842CA8 = nw_protocol_default_input_flush;
  qword_1EA842C98 = nw_protocol_default_get_message_properties;
  qword_1EA842C08 = nw_protocol_default_link_state;
  qword_1EA842C10 = nw_protocol_default_get_parameters;
  qword_1EA842C20 = nw_protocol_default_get_local;
  qword_1EA842C28 = nw_protocol_default_get_remote;
  qword_1EA842C18 = nw_protocol_default_get_path;
  qword_1EA842C48 = nw_protocol_default_updated_path;
  qword_1EA842C68 = nw_protocol_default_get_output_local;
  qword_1EA842C70 = nw_protocol_default_get_output_interface;
  qword_1EA842BB8 = nw_protocol_default_connect;
  qword_1EA842BC0 = nw_protocol_default_disconnect;
  qword_1EA842BC8 = nw_protocol_default_connected;
  qword_1EA842BD0 = nw_protocol_default_disconnected;
  qword_1EA842BD8 = nw_protocol_default_error;
  qword_1EA842CA0 = nw_protocol_default_reset;
  qword_1EA842C50 = nw_protocol_default_supports_external_data;
  qword_1EA842C78 = nw_protocol_default_waiting_for_output;
  qword_1EA842C80 = nw_protocol_default_copy_info;
  qword_1EA842C30 = nw_protocol_default_register_notification;
  qword_1EA842C38 = nw_protocol_default_unregister_notification;
  qword_1EA842C40 = nw_protocol_default_notify;
  qword_1EA842C88 = nw_protocol_default_add_listen_handler;
  qword_1EA842C90 = nw_protocol_default_remove_listen_handler;
  g_recorder_protocol_callbacks = nw_protocol_recorder_add_input_handler;
  qword_1EA842BA8 = nw_protocol_recorder_remove_input_handler;
  qword_1EA842BF0 = nw_protocol_recorder_get_input_frames;
  qword_1EA842BF8 = nw_protocol_recorder_get_output_frames;
  qword_1EA842C00 = nw_protocol_recorder_finalize_output_frames;
  return nw_protocol_register(&g_recorder_protocol_identifier, nw_protocol_recorder_create);
}

uint64_t nw_protocol_recorder_create(const nw_protocol_identifier *a1)
{
  v11 = *MEMORY[0x1E69E9840];
  memptr = 0;
  if (!malloc_type_posix_memalign(&memptr, 8uLL, 0x58uLL, 0x2429AC6uLL))
  {
    result = memptr;
    if (memptr)
    {
      goto LABEL_3;
    }
  }

  v2 = __nwlog_obj();
  os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  v5 = 136446722;
  v6 = "nw_protocol_recorder_create";
  v7 = 2048;
  v8 = 8;
  v9 = 2048;
  v10 = 88;
  v3 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v3);
  if (!result)
  {
    free(v3);
    result = memptr;
LABEL_3:
    *(result + 80) = 0;
    *(result + 48) = 0u;
    *(result + 64) = 0u;
    *(result + 16) = 0u;
    *(result + 32) = 0u;
    *result = 0u;
    *(result + 16) = &g_recorder_protocol_identifier;
    *(result + 24) = &g_recorder_protocol_callbacks;
    *(result + 40) = result;
    return result;
  }

  __break(1u);
  return result;
}

uint64_t nw_protocol_recorder_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  v25 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      v15[0] = MEMORY[0x1E69E9820];
      v15[1] = 0x40000000;
      v16 = ___ZL43nw_protocol_recorder_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
      v17 = &__block_descriptor_tmp_15_68654;
      v18 = handle;
      tqh_first = a2->tqh_first;
      do
      {
        if (!tqh_first)
        {
          break;
        }

        v4 = *(tqh_first + 4);
        v5 = (v16)(v15);
        tqh_first = v4;
      }

      while ((v5 & 1) != 0);
      return (*(*(handle[4] + 24) + 96))();
    }

    __nwlog_obj();
    *buf = 136446210;
    v22 = "nw_protocol_recorder_finalize_output_frames";
    v7 = _os_log_send_and_compose_impl();
    v20 = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v7, &v20, &v19))
    {
      goto LABEL_35;
    }

    if (v20 == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = v20;
      if (os_log_type_enabled(v8, v20))
      {
        *buf = 136446210;
        v22 = "nw_protocol_recorder_finalize_output_frames";
        v10 = "%{public}s called with null recorder";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    if (v19 != 1)
    {
      v8 = __nwlog_obj();
      v9 = v20;
      if (os_log_type_enabled(v8, v20))
      {
        *buf = 136446210;
        v22 = "nw_protocol_recorder_finalize_output_frames";
        v10 = "%{public}s called with null recorder, backtrace limit exceeded";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    backtrace_string = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = v20;
    v14 = os_log_type_enabled(v8, v20);
    if (!backtrace_string)
    {
      if (v14)
      {
        *buf = 136446210;
        v22 = "nw_protocol_recorder_finalize_output_frames";
        v10 = "%{public}s called with null recorder, no backtrace";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    if (v14)
    {
      *buf = 136446466;
      v22 = "nw_protocol_recorder_finalize_output_frames";
      v23 = 2082;
      v24 = backtrace_string;
      v13 = "%{public}s called with null recorder, dumping backtrace:%{public}s";
      goto LABEL_24;
    }

    goto LABEL_25;
  }

  __nwlog_obj();
  *buf = 136446210;
  v22 = "nw_protocol_recorder_finalize_output_frames";
  v7 = _os_log_send_and_compose_impl();
  v20 = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v7, &v20, &v19))
  {
    goto LABEL_35;
  }

  if (v20 != OS_LOG_TYPE_FAULT)
  {
    if (v19 != 1)
    {
      v8 = __nwlog_obj();
      v9 = v20;
      if (os_log_type_enabled(v8, v20))
      {
        *buf = 136446210;
        v22 = "nw_protocol_recorder_finalize_output_frames";
        v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    backtrace_string = __nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = v20;
    v12 = os_log_type_enabled(v8, v20);
    if (!backtrace_string)
    {
      if (v12)
      {
        *buf = 136446210;
        v22 = "nw_protocol_recorder_finalize_output_frames";
        v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    if (v12)
    {
      *buf = 136446466;
      v22 = "nw_protocol_recorder_finalize_output_frames";
      v23 = 2082;
      v24 = backtrace_string;
      v13 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_24:
      _os_log_impl(&dword_181A37000, v8, v9, v13, buf, 0x16u);
    }

LABEL_25:
    free(backtrace_string);
    goto LABEL_35;
  }

  v8 = __nwlog_obj();
  v9 = v20;
  if (os_log_type_enabled(v8, v20))
  {
    *buf = 136446210;
    v22 = "nw_protocol_recorder_finalize_output_frames";
    v10 = "%{public}s called with null protocol";
LABEL_34:
    _os_log_impl(&dword_181A37000, v8, v9, v10, buf, 0xCu);
  }

LABEL_35:
  if (v7)
  {
    free(v7);
  }

  return 0;
}

uint64_t ___ZL43nw_protocol_recorder_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  v32 = *MEMORY[0x1E69E9840];
  v25 = 0;
  if (!nw_frame_unclaimed_bytes(a2, &v25) || !v25)
  {
    return 1;
  }

  if (pcap_ng_block_alloc_delayInitStub(v3))
  {
    pcap_ng_block_reset_delayInitStub(v4);
    enhanced_packet_fields_delayInitStub = pcap_ng_get_enhanced_packet_fields_delayInitStub(v5);
    v7 = *(*(a1 + 32) + 64);
    v8 = mach_continuous_time();
    if (v8 <= 1)
    {
      v9 = 1;
    }

    else
    {
      v9 = v8;
    }

    *(enhanced_packet_fields_delayInitStub + 4) = nw_delta_nanos(v7, v9) / 0x3B9ACA00uLL;
    v10 = *(*(a1 + 32) + 64);
    v11 = mach_continuous_time();
    if (v11 <= 1)
    {
      v12 = 1;
    }

    else
    {
      v12 = v11;
    }

    *(enhanced_packet_fields_delayInitStub + 8) = nw_delta_nanos(v10, v12) / 0xF4240uLL;
    pcap_ng_block_packet_set_data_delayInitStub(v13);
    pcap_ng_dump_block_delayInitStub(v14);
    pcap_ng_free_block_delayInitStub(v15);
    return 1;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446466;
  v27 = "nw_protocol_recorder_finalize_output_frames_block_invoke";
  v28 = 1024;
  v29 = v25 + 2048;
  v16 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (__nwlog_fault(v16, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      v18 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_25;
      }

      *buf = 136446466;
      v27 = "nw_protocol_recorder_finalize_output_frames_block_invoke";
      v28 = 1024;
      v29 = v25 + 2048;
      v19 = "%{public}s pcap_ng_block_alloc(%u) failed";
      goto LABEL_24;
    }

    if (v23 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      v18 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_25;
      }

      *buf = 136446466;
      v27 = "nw_protocol_recorder_finalize_output_frames_block_invoke";
      v28 = 1024;
      v29 = v25 + 2048;
      v19 = "%{public}s pcap_ng_block_alloc(%u) failed, backtrace limit exceeded";
      goto LABEL_24;
    }

    backtrace_string = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    v18 = type;
    v21 = os_log_type_enabled(gLogObj, type);
    if (backtrace_string)
    {
      if (v21)
      {
        *buf = 136446722;
        v27 = "nw_protocol_recorder_finalize_output_frames_block_invoke";
        v28 = 1024;
        v29 = v25 + 2048;
        v30 = 2082;
        v31 = backtrace_string;
        _os_log_impl(&dword_181A37000, v17, v18, "%{public}s pcap_ng_block_alloc(%u) failed, dumping backtrace:%{public}s", buf, 0x1Cu);
      }

      free(backtrace_string);
      goto LABEL_25;
    }

    if (v21)
    {
      *buf = 136446466;
      v27 = "nw_protocol_recorder_finalize_output_frames_block_invoke";
      v28 = 1024;
      v29 = v25 + 2048;
      v19 = "%{public}s pcap_ng_block_alloc(%u) failed, no backtrace";
LABEL_24:
      _os_log_impl(&dword_181A37000, v17, v18, v19, buf, 0x12u);
    }
  }

LABEL_25:
  if (v16)
  {
    free(v16);
  }

  return 1;
}

uint64_t nw_protocol_recorder_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  v23 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v20 = "nw_protocol_recorder_get_output_frames";
    v9 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v9, &type, &v17))
    {
      goto LABEL_34;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v20 = "nw_protocol_recorder_get_output_frames";
      v12 = "%{public}s called with null protocol";
      goto LABEL_33;
    }

    if (v17 != 1)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v20 = "nw_protocol_recorder_get_output_frames";
      v12 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_33;
    }

    backtrace_string = __nw_create_backtrace_string();
    v10 = __nwlog_obj();
    v11 = type;
    v14 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (!v14)
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v20 = "nw_protocol_recorder_get_output_frames";
      v12 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_33;
    }

    if (v14)
    {
      *buf = 136446466;
      v20 = "nw_protocol_recorder_get_output_frames";
      v21 = 2082;
      v22 = backtrace_string;
      _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
LABEL_34:
    if (!v9)
    {
      return 0;
    }

LABEL_35:
    free(v9);
    return 0;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v20 = "nw_protocol_recorder_get_output_frames";
    v9 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v9, &type, &v17))
    {
      goto LABEL_34;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v20 = "nw_protocol_recorder_get_output_frames";
      v12 = "%{public}s called with null recorder";
      goto LABEL_33;
    }

    if (v17 != 1)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
      {
        goto LABEL_34;
      }

      *buf = 136446210;
      v20 = "nw_protocol_recorder_get_output_frames";
      v12 = "%{public}s called with null recorder, backtrace limit exceeded";
      goto LABEL_33;
    }

    v15 = __nw_create_backtrace_string();
    v10 = __nwlog_obj();
    v11 = type;
    v16 = os_log_type_enabled(v10, type);
    if (v15)
    {
      if (v16)
      {
        *buf = 136446466;
        v20 = "nw_protocol_recorder_get_output_frames";
        v21 = 2082;
        v22 = v15;
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null recorder, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v15);
      if (!v9)
      {
        return 0;
      }

      goto LABEL_35;
    }

    if (v16)
    {
      *buf = 136446210;
      v20 = "nw_protocol_recorder_get_output_frames";
      v12 = "%{public}s called with null recorder, no backtrace";
LABEL_33:
      _os_log_impl(&dword_181A37000, v10, v11, v12, buf, 0xCu);
      goto LABEL_34;
    }

    goto LABEL_34;
  }

  v7 = *(*(handle[4] + 24) + 88);

  return v7();
}

uint64_t nw_protocol_recorder_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  v31 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      v8 = (*(*(handle[4] + 24) + 80))();
      v21[0] = MEMORY[0x1E69E9820];
      v21[1] = 0x40000000;
      v22 = ___ZL37nw_protocol_recorder_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
      v23 = &__block_descriptor_tmp_14_68681;
      v24 = handle;
      tqh_first = a6->tqh_first;
      do
      {
        if (!tqh_first)
        {
          break;
        }

        v10 = *(tqh_first + 4);
        v11 = (v22)(v21);
        tqh_first = v10;
      }

      while ((v11 & 1) != 0);
      return v8;
    }

    __nwlog_obj();
    *buf = 136446210;
    v28 = "nw_protocol_recorder_get_input_frames";
    v13 = _os_log_send_and_compose_impl();
    v26 = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v13, &v26, &v25))
    {
      goto LABEL_34;
    }

    if (v26 == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = v26;
      if (os_log_type_enabled(v14, v26))
      {
        *buf = 136446210;
        v28 = "nw_protocol_recorder_get_input_frames";
        v16 = "%{public}s called with null recorder";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (v25 != 1)
    {
      v14 = __nwlog_obj();
      v15 = v26;
      if (os_log_type_enabled(v14, v26))
      {
        *buf = 136446210;
        v28 = "nw_protocol_recorder_get_input_frames";
        v16 = "%{public}s called with null recorder, backtrace limit exceeded";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    backtrace_string = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = v26;
    v20 = os_log_type_enabled(v14, v26);
    if (!backtrace_string)
    {
      if (v20)
      {
        *buf = 136446210;
        v28 = "nw_protocol_recorder_get_input_frames";
        v16 = "%{public}s called with null recorder, no backtrace";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (v20)
    {
      *buf = 136446466;
      v28 = "nw_protocol_recorder_get_input_frames";
      v29 = 2082;
      v30 = backtrace_string;
      v19 = "%{public}s called with null recorder, dumping backtrace:%{public}s";
      goto LABEL_23;
    }

    goto LABEL_24;
  }

  __nwlog_obj();
  *buf = 136446210;
  v28 = "nw_protocol_recorder_get_input_frames";
  v13 = _os_log_send_and_compose_impl();
  v26 = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v13, &v26, &v25))
  {
    goto LABEL_34;
  }

  if (v26 != OS_LOG_TYPE_FAULT)
  {
    if (v25 != 1)
    {
      v14 = __nwlog_obj();
      v15 = v26;
      if (os_log_type_enabled(v14, v26))
      {
        *buf = 136446210;
        v28 = "nw_protocol_recorder_get_input_frames";
        v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    backtrace_string = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = v26;
    v18 = os_log_type_enabled(v14, v26);
    if (!backtrace_string)
    {
      if (v18)
      {
        *buf = 136446210;
        v28 = "nw_protocol_recorder_get_input_frames";
        v16 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (v18)
    {
      *buf = 136446466;
      v28 = "nw_protocol_recorder_get_input_frames";
      v29 = 2082;
      v30 = backtrace_string;
      v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_23:
      _os_log_impl(&dword_181A37000, v14, v15, v19, buf, 0x16u);
    }

LABEL_24:
    free(backtrace_string);
    goto LABEL_34;
  }

  v14 = __nwlog_obj();
  v15 = v26;
  if (os_log_type_enabled(v14, v26))
  {
    *buf = 136446210;
    v28 = "nw_protocol_recorder_get_input_frames";
    v16 = "%{public}s called with null protocol";
LABEL_33:
    _os_log_impl(&dword_181A37000, v14, v15, v16, buf, 0xCu);
  }

LABEL_34:
  if (v13)
  {
    free(v13);
  }

  return 0;
}

uint64_t ___ZL37nw_protocol_recorder_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  v32 = *MEMORY[0x1E69E9840];
  v25 = 0;
  if (!nw_frame_unclaimed_bytes(a2, &v25) || !v25)
  {
    return 1;
  }

  if (pcap_ng_block_alloc_delayInitStub(v3))
  {
    pcap_ng_block_reset_delayInitStub(v4);
    enhanced_packet_fields_delayInitStub = pcap_ng_get_enhanced_packet_fields_delayInitStub(v5);
    v7 = *(*(a1 + 32) + 64);
    v8 = mach_continuous_time();
    if (v8 <= 1)
    {
      v9 = 1;
    }

    else
    {
      v9 = v8;
    }

    *(enhanced_packet_fields_delayInitStub + 4) = nw_delta_nanos(v7, v9) / 0x3B9ACA00uLL;
    v10 = *(*(a1 + 32) + 64);
    v11 = mach_continuous_time();
    if (v11 <= 1)
    {
      v12 = 1;
    }

    else
    {
      v12 = v11;
    }

    *(enhanced_packet_fields_delayInitStub + 8) = nw_delta_nanos(v10, v12) / 0xF4240uLL;
    pcap_ng_block_packet_set_data_delayInitStub(v13);
    pcap_ng_dump_block_delayInitStub(v14);
    pcap_ng_free_block_delayInitStub(v15);
    return 1;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446466;
  v27 = "nw_protocol_recorder_get_input_frames_block_invoke";
  v28 = 1024;
  v29 = v25 + 2048;
  v16 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (__nwlog_fault(v16, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      v18 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_25;
      }

      *buf = 136446466;
      v27 = "nw_protocol_recorder_get_input_frames_block_invoke";
      v28 = 1024;
      v29 = v25 + 2048;
      v19 = "%{public}s pcap_ng_block_alloc(%u) failed";
      goto LABEL_24;
    }

    if (v23 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      v18 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_25;
      }

      *buf = 136446466;
      v27 = "nw_protocol_recorder_get_input_frames_block_invoke";
      v28 = 1024;
      v29 = v25 + 2048;
      v19 = "%{public}s pcap_ng_block_alloc(%u) failed, backtrace limit exceeded";
      goto LABEL_24;
    }

    backtrace_string = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    v18 = type;
    v21 = os_log_type_enabled(gLogObj, type);
    if (backtrace_string)
    {
      if (v21)
      {
        *buf = 136446722;
        v27 = "nw_protocol_recorder_get_input_frames_block_invoke";
        v28 = 1024;
        v29 = v25 + 2048;
        v30 = 2082;
        v31 = backtrace_string;
        _os_log_impl(&dword_181A37000, v17, v18, "%{public}s pcap_ng_block_alloc(%u) failed, dumping backtrace:%{public}s", buf, 0x1Cu);
      }

      free(backtrace_string);
      goto LABEL_25;
    }

    if (v21)
    {
      *buf = 136446466;
      v27 = "nw_protocol_recorder_get_input_frames_block_invoke";
      v28 = 1024;
      v29 = v25 + 2048;
      v19 = "%{public}s pcap_ng_block_alloc(%u) failed, no backtrace";
LABEL_24:
      _os_log_impl(&dword_181A37000, v17, v18, v19, buf, 0x12u);
    }
  }

LABEL_25:
  if (v16)
  {
    free(v16);
  }

  return 1;
}

uint64_t nw_protocol_recorder_remove_input_handler(nw_protocol *a1, nw_protocol *a2, int a3)
{
  v24 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_protocol_recorder_remove_input_handler";
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v10, &type, &v18))
    {
      goto LABEL_44;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v18 != 1)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
        {
          goto LABEL_44;
        }

        *buf = 136446210;
        v21 = "nw_protocol_recorder_remove_input_handler";
        v13 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_43;
      }

      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v15 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
          goto LABEL_44;
        }

        *buf = 136446210;
        v21 = "nw_protocol_recorder_remove_input_handler";
        v13 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_43;
      }

      if (v15)
      {
        *buf = 136446466;
        v21 = "nw_protocol_recorder_remove_input_handler";
        v22 = 2082;
        v23 = backtrace_string;
        v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_33:
        _os_log_impl(&dword_181A37000, v11, v12, v16, buf, 0x16u);
      }

LABEL_34:
      free(backtrace_string);
      goto LABEL_44;
    }

    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
    {
      goto LABEL_44;
    }

    *buf = 136446210;
    v21 = "nw_protocol_recorder_remove_input_handler";
    v13 = "%{public}s called with null protocol";
LABEL_43:
    _os_log_impl(&dword_181A37000, v11, v12, v13, buf, 0xCu);
LABEL_44:
    if (v10)
    {
      free(v10);
    }

    return 0;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v21 = "nw_protocol_recorder_remove_input_handler";
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v10, &type, &v18))
    {
      goto LABEL_44;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
      {
        goto LABEL_44;
      }

      *buf = 136446210;
      v21 = "nw_protocol_recorder_remove_input_handler";
      v13 = "%{public}s called with null recorder";
      goto LABEL_43;
    }

    if (v18 != 1)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
      {
        goto LABEL_44;
      }

      *buf = 136446210;
      v21 = "nw_protocol_recorder_remove_input_handler";
      v13 = "%{public}s called with null recorder, backtrace limit exceeded";
      goto LABEL_43;
    }

    backtrace_string = __nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v12 = type;
    v17 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (v17)
      {
        *buf = 136446466;
        v21 = "nw_protocol_recorder_remove_input_handler";
        v22 = 2082;
        v23 = backtrace_string;
        v16 = "%{public}s called with null recorder, dumping backtrace:%{public}s";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (!v17)
    {
      goto LABEL_44;
    }

    *buf = 136446210;
    v21 = "nw_protocol_recorder_remove_input_handler";
    v13 = "%{public}s called with null recorder, no backtrace";
    goto LABEL_43;
  }

  if (a2->output_handler == a1)
  {
    v6 = a2;
    nw_protocol_set_output_handler(a2, 0);
    a2 = v6;
  }

  if (a1->default_input_handler != a2)
  {
    return 0;
  }

  nw_protocol_set_input_handler(a1, 0);
  output_handler = a1->output_handler;
  if (output_handler)
  {
    (output_handler->callbacks->remove_input_handler)();
  }

  if (a3)
  {
    if (handle[10])
    {
      pcap_ng_dump_close_delayInitStub(v8);
      handle[10] = 0;
    }

    if (handle[9])
    {
      pcap_close_delayInitStub(v8);
    }

    a1->handle = 0;
    free(handle);
  }

  return 1;
}

uint64_t nw_protocol_recorder_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  v43 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    LODWORD(v40[0]) = 136446210;
    *(v40 + 4) = "nw_protocol_recorder_add_input_handler";
    v11 = _os_log_send_and_compose_impl();
    __str[0] = 16;
    out[0] = 0;
    if (!__nwlog_fault(v11, __str, out))
    {
      goto LABEL_41;
    }

    if (__str[0] == 17)
    {
      v28 = __nwlog_obj();
      v29 = __str[0];
      if (!os_log_type_enabled(v28, __str[0]))
      {
        goto LABEL_41;
      }

      LODWORD(v40[0]) = 136446210;
      *(v40 + 4) = "nw_protocol_recorder_add_input_handler";
      v14 = "%{public}s called with null protocol";
      goto LABEL_69;
    }

    if (out[0] == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v28 = __nwlog_obj();
      v29 = __str[0];
      v30 = os_log_type_enabled(v28, __str[0]);
      if (backtrace_string)
      {
        if (!v30)
        {
          goto LABEL_24;
        }

        LODWORD(v40[0]) = 136446466;
        *(v40 + 4) = "nw_protocol_recorder_add_input_handler";
        WORD6(v40[0]) = 2082;
        *(v40 + 14) = backtrace_string;
        v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_60;
      }

      if (!v30)
      {
        goto LABEL_41;
      }

      LODWORD(v40[0]) = 136446210;
      *(v40 + 4) = "nw_protocol_recorder_add_input_handler";
      v14 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v28 = __nwlog_obj();
      v29 = __str[0];
      if (!os_log_type_enabled(v28, __str[0]))
      {
        goto LABEL_41;
      }

      LODWORD(v40[0]) = 136446210;
      *(v40 + 4) = "nw_protocol_recorder_add_input_handler";
      v14 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

LABEL_69:
    v24 = v40;
    v25 = v28;
    v26 = v29;
    v27 = 12;
    goto LABEL_40;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    LODWORD(v40[0]) = 136446210;
    *(v40 + 4) = "nw_protocol_recorder_add_input_handler";
    v11 = _os_log_send_and_compose_impl();
    __str[0] = 16;
    out[0] = 0;
    if (!__nwlog_fault(v11, __str, out))
    {
      goto LABEL_41;
    }

    if (__str[0] == 17)
    {
      v28 = __nwlog_obj();
      v29 = __str[0];
      if (!os_log_type_enabled(v28, __str[0]))
      {
        goto LABEL_41;
      }

      LODWORD(v40[0]) = 136446210;
      *(v40 + 4) = "nw_protocol_recorder_add_input_handler";
      v14 = "%{public}s called with null recorder";
      goto LABEL_69;
    }

    if (out[0] == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v28 = __nwlog_obj();
      v29 = __str[0];
      v31 = os_log_type_enabled(v28, __str[0]);
      if (backtrace_string)
      {
        if (!v31)
        {
          goto LABEL_24;
        }

        LODWORD(v40[0]) = 136446466;
        *(v40 + 4) = "nw_protocol_recorder_add_input_handler";
        WORD6(v40[0]) = 2082;
        *(v40 + 14) = backtrace_string;
        v17 = "%{public}s called with null recorder, dumping backtrace:%{public}s";
LABEL_60:
        v18 = v40;
        v19 = v28;
        v20 = v29;
        v21 = 22;
        goto LABEL_23;
      }

      if (!v31)
      {
        goto LABEL_41;
      }

      LODWORD(v40[0]) = 136446210;
      *(v40 + 4) = "nw_protocol_recorder_add_input_handler";
      v14 = "%{public}s called with null recorder, no backtrace";
    }

    else
    {
      v28 = __nwlog_obj();
      v29 = __str[0];
      if (!os_log_type_enabled(v28, __str[0]))
      {
        goto LABEL_41;
      }

      LODWORD(v40[0]) = 136446210;
      *(v40 + 4) = "nw_protocol_recorder_add_input_handler";
      v14 = "%{public}s called with null recorder, backtrace limit exceeded";
    }

    goto LABEL_69;
  }

  nw_protocol_set_input_handler(a1, a2);
  *handle = *a2->flow_id;
  if (!a2->output_handler)
  {
    nw_protocol_set_output_handler(a2, handle);
  }

  v4 = mach_continuous_time();
  if (v4 <= 1)
  {
    v5 = 1;
  }

  else
  {
    v5 = v4;
  }

  *(handle + 8) = v5;
  memset(out, 0, 37);
  uuid_unparse_upper(handle, out);
  snprintf(__str, 0x80uLL, "/var/tmp/nw-%s-%s.pcap", a2->identifier->name, out);
  __str[127] = 0;
  memset(v40, 0, sizeof(v40));
  delayInitStub = pcap_create_delayInitStub(0.0);
  *(handle + 9) = delayInitStub;
  if (!delayInitStub)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *buf = 136446466;
    v35 = "nw_protocol_recorder_add_input_handler";
    v36 = 2082;
    v37 = v40;
    v11 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v11, &type, &v32))
    {
      goto LABEL_41;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_41;
      }

      *buf = 136446466;
      v35 = "nw_protocol_recorder_add_input_handler";
      v36 = 2082;
      v37 = v40;
      v14 = "%{public}s pcap_create: %{public}s failed";
LABEL_39:
      v24 = buf;
      v25 = v12;
      v26 = v13;
      v27 = 22;
LABEL_40:
      _os_log_impl(&dword_181A37000, v25, v26, v14, v24, v27);
      goto LABEL_41;
    }

    if (v32 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_41;
      }

      *buf = 136446466;
      v35 = "nw_protocol_recorder_add_input_handler";
      v36 = 2082;
      v37 = v40;
      v14 = "%{public}s pcap_create: %{public}s failed, backtrace limit exceeded";
      goto LABEL_39;
    }

    backtrace_string = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = type;
    v16 = os_log_type_enabled(gLogObj, type);
    if (!backtrace_string)
    {
      if (!v16)
      {
        goto LABEL_41;
      }

      *buf = 136446466;
      v35 = "nw_protocol_recorder_add_input_handler";
      v36 = 2082;
      v37 = v40;
      v14 = "%{public}s pcap_create: %{public}s failed, no backtrace";
      goto LABEL_39;
    }

    if (v16)
    {
      *buf = 136446722;
      v35 = "nw_protocol_recorder_add_input_handler";
      v36 = 2082;
      v37 = v40;
      v38 = 2082;
      v39 = backtrace_string;
      v17 = "%{public}s pcap_create: %{public}s failed, dumping backtrace:%{public}s";
      v18 = buf;
      v19 = v12;
      v20 = v13;
      v21 = 32;
LABEL_23:
      _os_log_impl(&dword_181A37000, v19, v20, v17, v18, v21);
    }

LABEL_24:
    free(backtrace_string);
    if (!v11)
    {
      return 0;
    }

    goto LABEL_42;
  }

  pcap_activate_delayInitStub(v7);
  inited = pcap_ng_dump_open_delayInitStub(v8);
  *(handle + 10) = inited;
  if (inited)
  {
    return 1;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *buf = 136446466;
  v35 = "nw_protocol_recorder_add_input_handler";
  v36 = 2082;
  v37 = __str;
  v11 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v32 = 0;
  if (__nwlog_fault(v11, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_41;
      }

      *buf = 136446466;
      v35 = "nw_protocol_recorder_add_input_handler";
      v36 = 2082;
      v37 = __str;
      v14 = "%{public}s pcap_create: %{public}s failed";
      goto LABEL_39;
    }

    if (v32 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (!os_log_type_enabled(gLogObj, type))
      {
        goto LABEL_41;
      }

      *buf = 136446466;
      v35 = "nw_protocol_recorder_add_input_handler";
      v36 = 2082;
      v37 = __str;
      v14 = "%{public}s pcap_create: %{public}s failed, backtrace limit exceeded";
      goto LABEL_39;
    }

    v22 = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = type;
    v23 = os_log_type_enabled(gLogObj, type);
    if (!v22)
    {
      if (!v23)
      {
        goto LABEL_41;
      }

      *buf = 136446466;
      v35 = "nw_protocol_recorder_add_input_handler";
      v36 = 2082;
      v37 = __str;
      v14 = "%{public}s pcap_create: %{public}s failed, no backtrace";
      goto LABEL_39;
    }

    if (v23)
    {
      *buf = 136446722;
      v35 = "nw_protocol_recorder_add_input_handler";
      v36 = 2082;
      v37 = __str;
      v38 = 2082;
      v39 = v22;
      _os_log_impl(&dword_181A37000, v12, v13, "%{public}s pcap_create: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
    }

    free(v22);
  }

LABEL_41:
  if (v11)
  {
LABEL_42:
    free(v11);
  }

  return 0;
}

unsigned __int16 *nw_http_oblivious_config_select(unsigned __int16 *a1, uint64_t a2, void *a3, uint64_t *a4)
{
  v4 = 0;
  v54 = *MEMORY[0x1E69E9840];
  if (!a1 || a2 < 0x29)
  {
    return v4;
  }

  if (*(a1 + 1) != 0x2000)
  {
    goto LABEL_18;
  }

  if (*(a1 + 37) == 256)
  {
    v5 = *(a1 + 39);
    if (v5 == 256 || v5 == 512)
    {
      if (a4)
      {
        v6 = a1;
        v8 = a3;
        v9 = a2;
        if (v5 == 512)
        {
          v10 = cchpke_params_x25519_AESGCM256_HKDF_SHA256();
        }

        else
        {
          v10 = cchpke_params_x25519_AESGCM128_HKDF_SHA256();
        }

        *a4 = v10;
        a2 = v9;
        a3 = v8;
        a1 = v6;
      }

      if (a3)
      {
        goto LABEL_52;
      }

      return a1;
    }
  }

  if (a2 < 42)
  {
    goto LABEL_18;
  }

  v11 = a1 + a2;
  v12 = (a1 + 41);
  while (1)
  {
    v13 = v12 + 2;
    if ((v12 + 2) > v11)
    {
      break;
    }

    if (*v12 == 256)
    {
      v14 = v12[1];
      if (v14 == 256)
      {
        v15 = a2;
        v16 = a3;
        v17 = a4;
        v18 = a1;
        v19 = cchpke_params_x25519_AESGCM128_HKDF_SHA256();
LABEL_59:
        a3 = v16;
        a2 = v15;
        v40 = v19;
        a1 = v18;
        *v17 = v40;
        if (v16)
        {
LABEL_52:
          *a3 = a2;
          return a1;
        }

        return a1;
      }

      if (v14 == 512)
      {
        v15 = a2;
        v16 = a3;
        v17 = a4;
        v18 = a1;
        v19 = cchpke_params_x25519_AESGCM256_HKDF_SHA256();
        goto LABEL_59;
      }
    }

    v12 = v13;
    if (v13 >= v11)
    {
      goto LABEL_18;
    }
  }

  while (1)
  {
LABEL_18:
    v4 = a1 + 1;
    v20 = *a1;
    v21 = __rev16(v20);
    v22 = a2 - 2;
    if (a2 - 2 < v21)
    {
      return 0;
    }

    if (v21 >= 0x29 && *(a1 + 3) == 0x2000)
    {
      break;
    }

LABEL_25:
    a2 = v22 - v21;
    if (v22 < v21)
    {
      v32 = v22 - v21;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *buf = 136446978;
      v45 = "nw_http_oblivious_config_select";
      v46 = 2082;
      v47 = "remaining_length";
      v48 = 2048;
      v49 = v21;
      v50 = 2048;
      v33 = v32;
      v51 = v32;
      v34 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v42 = 0;
      if (!__nwlog_fault(v34, &type, &v42))
      {
        goto LABEL_64;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = gLogObj;
        v36 = type;
        if (!os_log_type_enabled(gLogObj, type))
        {
          goto LABEL_64;
        }

        *buf = 136446978;
        v45 = "nw_http_oblivious_config_select";
        v46 = 2082;
        v47 = "remaining_length";
        v48 = 2048;
        v49 = v21;
        v50 = 2048;
        v51 = v33;
        v37 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
      }

      else if (v42 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v35 = __nwlog_obj();
        v36 = type;
        v39 = os_log_type_enabled(v35, type);
        if (backtrace_string)
        {
          if (v39)
          {
            *buf = 136447234;
            v45 = "nw_http_oblivious_config_select";
            v46 = 2082;
            v47 = "remaining_length";
            v48 = 2048;
            v49 = v21;
            v50 = 2048;
            v51 = v33;
            v52 = 2082;
            v53 = backtrace_string;
            _os_log_impl(&dword_181A37000, v35, v36, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }

          free(backtrace_string);
          goto LABEL_64;
        }

        if (!v39)
        {
LABEL_64:
          if (v34)
          {
            free(v34);
          }

          return 0;
        }

        *buf = 136446978;
        v45 = "nw_http_oblivious_config_select";
        v46 = 2082;
        v47 = "remaining_length";
        v48 = 2048;
        v49 = v21;
        v50 = 2048;
        v51 = v33;
        v37 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
      }

      else
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
        {
          goto LABEL_64;
        }

        *buf = 136446978;
        v45 = "nw_http_oblivious_config_select";
        v46 = 2082;
        v47 = "remaining_length";
        v48 = 2048;
        v49 = v21;
        v50 = 2048;
        v51 = v33;
        v37 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A37000, v35, v36, v37, buf, 0x2Au);
      goto LABEL_64;
    }

    a1 = (v4 + v21);
    if (a2 <= 2)
    {
      return 0;
    }
  }

  if (*(a1 + 39) != 256 || (v23 = *(a1 + 41), v23 != 256) && v23 != 512)
  {
    if (v20 != 10496)
    {
      v24 = v4 + v21;
      v25 = (a1 + 43);
      while (1)
      {
        v26 = v25 + 2;
        if ((v25 + 2) > v24)
        {
          break;
        }

        if (*v25 == 256)
        {
          v27 = v25[1];
          if (v27 == 256)
          {
            v28 = a1 + 1;
            v29 = a4;
            v30 = a3;
            goto LABEL_40;
          }

          if (v27 == 512)
          {
            v28 = a1 + 1;
            v29 = a4;
            v30 = a3;
            v31 = cchpke_params_x25519_AESGCM256_HKDF_SHA256();
            goto LABEL_41;
          }
        }

        v25 = v26;
        if (v26 >= v24)
        {
          goto LABEL_25;
        }
      }
    }

    goto LABEL_25;
  }

  if (a4)
  {
    v28 = a1 + 1;
    v29 = a4;
    v30 = a3;
    if (v23 == 512)
    {
      v31 = cchpke_params_x25519_AESGCM256_HKDF_SHA256();
    }

    else
    {
LABEL_40:
      v31 = cchpke_params_x25519_AESGCM128_HKDF_SHA256();
    }

LABEL_41:
    *v29 = v31;
    a3 = v30;
    v4 = v28;
  }

  if (a3)
  {
    *a3 = v21;
  }

  return v4;
}

uint64_t nw_http_encrypt_oblivious_request(const void *a1, size_t a2, const char *a3, unsigned __int16 *a4, uint64_t a5, char **a6, void *a7, void *a8, size_t *a9, size_t *a10)
{
  v85 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v50 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v77) = 0;
    if (!__nwlog_fault(v50, type, &v77))
    {
      goto LABEL_175;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v77 != 1)
      {
        v51 = __nwlog_obj();
        v52 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null message_buffer, backtrace limit exceeded";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      backtrace_string = __nw_create_backtrace_string();
      v51 = __nwlog_obj();
      v52 = type[0];
      v55 = os_log_type_enabled(v51, type[0]);
      if (!backtrace_string)
      {
        if (v55)
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null message_buffer, no backtrace";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      if (!v55)
      {
        goto LABEL_131;
      }

      *buf = 136446466;
      v80 = "nw_http_encrypt_oblivious_request";
      v81 = 2082;
      v82 = backtrace_string;
      v56 = "%{public}s called with null message_buffer, dumping backtrace:%{public}s";
      goto LABEL_130;
    }

    v51 = __nwlog_obj();
    v52 = type[0];
    if (!os_log_type_enabled(v51, type[0]))
    {
      goto LABEL_175;
    }

    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v53 = "%{public}s called with null message_buffer";
LABEL_174:
    _os_log_impl(&dword_181A37000, v51, v52, v53, buf, 0xCu);
    goto LABEL_175;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v50 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v77) = 0;
    if (!__nwlog_fault(v50, type, &v77))
    {
      goto LABEL_175;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v77 != 1)
      {
        v51 = __nwlog_obj();
        v52 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null message_length, backtrace limit exceeded";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      backtrace_string = __nw_create_backtrace_string();
      v51 = __nwlog_obj();
      v52 = type[0];
      v57 = os_log_type_enabled(v51, type[0]);
      if (!backtrace_string)
      {
        if (v57)
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null message_length, no backtrace";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      if (!v57)
      {
        goto LABEL_131;
      }

      *buf = 136446466;
      v80 = "nw_http_encrypt_oblivious_request";
      v81 = 2082;
      v82 = backtrace_string;
      v56 = "%{public}s called with null message_length, dumping backtrace:%{public}s";
      goto LABEL_130;
    }

    v51 = __nwlog_obj();
    v52 = type[0];
    if (!os_log_type_enabled(v51, type[0]))
    {
      goto LABEL_175;
    }

    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v53 = "%{public}s called with null message_length";
    goto LABEL_174;
  }

  if (!a3)
  {
    __nwlog_obj();
    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v50 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v77) = 0;
    if (!__nwlog_fault(v50, type, &v77))
    {
      goto LABEL_175;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v77 != 1)
      {
        v51 = __nwlog_obj();
        v52 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null media_type, backtrace limit exceeded";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      backtrace_string = __nw_create_backtrace_string();
      v51 = __nwlog_obj();
      v52 = type[0];
      v58 = os_log_type_enabled(v51, type[0]);
      if (!backtrace_string)
      {
        if (v58)
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null media_type, no backtrace";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      if (!v58)
      {
        goto LABEL_131;
      }

      *buf = 136446466;
      v80 = "nw_http_encrypt_oblivious_request";
      v81 = 2082;
      v82 = backtrace_string;
      v56 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_130;
    }

    v51 = __nwlog_obj();
    v52 = type[0];
    if (!os_log_type_enabled(v51, type[0]))
    {
      goto LABEL_175;
    }

    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v53 = "%{public}s called with null media_type";
    goto LABEL_174;
  }

  if (!a4)
  {
    __nwlog_obj();
    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v50 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v77) = 0;
    if (!__nwlog_fault(v50, type, &v77))
    {
      goto LABEL_175;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v77 != 1)
      {
        v51 = __nwlog_obj();
        v52 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null config_buffer, backtrace limit exceeded";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      backtrace_string = __nw_create_backtrace_string();
      v51 = __nwlog_obj();
      v52 = type[0];
      v59 = os_log_type_enabled(v51, type[0]);
      if (!backtrace_string)
      {
        if (v59)
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null config_buffer, no backtrace";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      if (!v59)
      {
        goto LABEL_131;
      }

      *buf = 136446466;
      v80 = "nw_http_encrypt_oblivious_request";
      v81 = 2082;
      v82 = backtrace_string;
      v56 = "%{public}s called with null config_buffer, dumping backtrace:%{public}s";
      goto LABEL_130;
    }

    v51 = __nwlog_obj();
    v52 = type[0];
    if (!os_log_type_enabled(v51, type[0]))
    {
      goto LABEL_175;
    }

    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v53 = "%{public}s called with null config_buffer";
    goto LABEL_174;
  }

  if (!a5)
  {
    __nwlog_obj();
    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v50 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v77) = 0;
    if (!__nwlog_fault(v50, type, &v77))
    {
      goto LABEL_175;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v77 != 1)
      {
        v51 = __nwlog_obj();
        v52 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null in_config_length, backtrace limit exceeded";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      backtrace_string = __nw_create_backtrace_string();
      v51 = __nwlog_obj();
      v52 = type[0];
      v60 = os_log_type_enabled(v51, type[0]);
      if (!backtrace_string)
      {
        if (v60)
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null in_config_length, no backtrace";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      if (!v60)
      {
        goto LABEL_131;
      }

      *buf = 136446466;
      v80 = "nw_http_encrypt_oblivious_request";
      v81 = 2082;
      v82 = backtrace_string;
      v56 = "%{public}s called with null in_config_length, dumping backtrace:%{public}s";
      goto LABEL_130;
    }

    v51 = __nwlog_obj();
    v52 = type[0];
    if (!os_log_type_enabled(v51, type[0]))
    {
      goto LABEL_175;
    }

    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v53 = "%{public}s called with null in_config_length";
    goto LABEL_174;
  }

  if (!a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v50 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v77) = 0;
    if (!__nwlog_fault(v50, type, &v77))
    {
      goto LABEL_175;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v77 != 1)
      {
        v51 = __nwlog_obj();
        v52 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null out_context, backtrace limit exceeded";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      backtrace_string = __nw_create_backtrace_string();
      v51 = __nwlog_obj();
      v52 = type[0];
      v61 = os_log_type_enabled(v51, type[0]);
      if (!backtrace_string)
      {
        if (v61)
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null out_context, no backtrace";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      if (!v61)
      {
        goto LABEL_131;
      }

      *buf = 136446466;
      v80 = "nw_http_encrypt_oblivious_request";
      v81 = 2082;
      v82 = backtrace_string;
      v56 = "%{public}s called with null out_context, dumping backtrace:%{public}s";
      goto LABEL_130;
    }

    v51 = __nwlog_obj();
    v52 = type[0];
    if (!os_log_type_enabled(v51, type[0]))
    {
      goto LABEL_175;
    }

    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v53 = "%{public}s called with null out_context";
    goto LABEL_174;
  }

  if (!a7)
  {
    __nwlog_obj();
    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v50 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v77) = 0;
    if (!__nwlog_fault(v50, type, &v77))
    {
      goto LABEL_175;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v77 != 1)
      {
        v51 = __nwlog_obj();
        v52 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null out_context_length, backtrace limit exceeded";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      backtrace_string = __nw_create_backtrace_string();
      v51 = __nwlog_obj();
      v52 = type[0];
      v62 = os_log_type_enabled(v51, type[0]);
      if (!backtrace_string)
      {
        if (v62)
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null out_context_length, no backtrace";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      if (!v62)
      {
        goto LABEL_131;
      }

      *buf = 136446466;
      v80 = "nw_http_encrypt_oblivious_request";
      v81 = 2082;
      v82 = backtrace_string;
      v56 = "%{public}s called with null out_context_length, dumping backtrace:%{public}s";
      goto LABEL_130;
    }

    v51 = __nwlog_obj();
    v52 = type[0];
    if (!os_log_type_enabled(v51, type[0]))
    {
      goto LABEL_175;
    }

    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v53 = "%{public}s called with null out_context_length";
    goto LABEL_174;
  }

  if (!a8)
  {
    __nwlog_obj();
    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v50 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v77) = 0;
    if (!__nwlog_fault(v50, type, &v77))
    {
      goto LABEL_175;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v77 != 1)
      {
        v51 = __nwlog_obj();
        v52 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null out_request_enc, backtrace limit exceeded";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      backtrace_string = __nw_create_backtrace_string();
      v51 = __nwlog_obj();
      v52 = type[0];
      v63 = os_log_type_enabled(v51, type[0]);
      if (!backtrace_string)
      {
        if (v63)
        {
          *buf = 136446210;
          v80 = "nw_http_encrypt_oblivious_request";
          v53 = "%{public}s called with null out_request_enc, no backtrace";
          goto LABEL_174;
        }

        goto LABEL_175;
      }

      if (!v63)
      {
        goto LABEL_131;
      }

      *buf = 136446466;
      v80 = "nw_http_encrypt_oblivious_request";
      v81 = 2082;
      v82 = backtrace_string;
      v56 = "%{public}s called with null out_request_enc, dumping backtrace:%{public}s";
      goto LABEL_130;
    }

    v51 = __nwlog_obj();
    v52 = type[0];
    if (!os_log_type_enabled(v51, type[0]))
    {
      goto LABEL_175;
    }

    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v53 = "%{public}s called with null out_request_enc";
    goto LABEL_174;
  }

  if (!a9)
  {
    __nwlog_obj();
    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v50 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v77) = 0;
    if (!__nwlog_fault(v50, type, &v77))
    {
      goto LABEL_175;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v51 = __nwlog_obj();
      v52 = type[0];
      if (!os_log_type_enabled(v51, type[0]))
      {
        goto LABEL_175;
      }

      *buf = 136446210;
      v80 = "nw_http_encrypt_oblivious_request";
      v53 = "%{public}s called with null out_request_enc_length";
      goto LABEL_174;
    }

    if (v77 != 1)
    {
      v51 = __nwlog_obj();
      v52 = type[0];
      if (os_log_type_enabled(v51, type[0]))
      {
        *buf = 136446210;
        v80 = "nw_http_encrypt_oblivious_request";
        v53 = "%{public}s called with null out_request_enc_length, backtrace limit exceeded";
        goto LABEL_174;
      }

      goto LABEL_175;
    }

    backtrace_string = __nw_create_backtrace_string();
    v51 = __nwlog_obj();
    v52 = type[0];
    v64 = os_log_type_enabled(v51, type[0]);
    if (!backtrace_string)
    {
      if (v64)
      {
        *buf = 136446210;
        v80 = "nw_http_encrypt_oblivious_request";
        v53 = "%{public}s called with null out_request_enc_length, no backtrace";
        goto LABEL_174;
      }

      goto LABEL_175;
    }

    if (!v64)
    {
      goto LABEL_131;
    }

    *buf = 136446466;
    v80 = "nw_http_encrypt_oblivious_request";
    v81 = 2082;
    v82 = backtrace_string;
    v56 = "%{public}s called with null out_request_enc_length, dumping backtrace:%{public}s";
LABEL_130:
    _os_log_impl(&dword_181A37000, v51, v52, v56, buf, 0x16u);
    goto LABEL_131;
  }

  if (!a10)
  {
    __nwlog_obj();
    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v50 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v77) = 0;
    if (!__nwlog_fault(v50, type, &v77))
    {
      goto LABEL_175;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v51 = __nwlog_obj();
      v52 = type[0];
      if (os_log_type_enabled(v51, type[0]))
      {
        *buf = 136446210;
        v80 = "nw_http_encrypt_oblivious_request";
        v53 = "%{public}s called with null out_encrypted_length";
        goto LABEL_174;
      }

LABEL_175:
      if (!v50)
      {
        return 0;
      }

      v46 = v50;
      goto LABEL_42;
    }

    if (v77 != 1)
    {
      v51 = __nwlog_obj();
      v52 = type[0];
      if (os_log_type_enabled(v51, type[0]))
      {
        *buf = 136446210;
        v80 = "nw_http_encrypt_oblivious_request";
        v53 = "%{public}s called with null out_encrypted_length, backtrace limit exceeded";
        goto LABEL_174;
      }

      goto LABEL_175;
    }

    backtrace_string = __nw_create_backtrace_string();
    v51 = __nwlog_obj();
    v52 = type[0];
    v65 = os_log_type_enabled(v51, type[0]);
    if (!backtrace_string)
    {
      if (v65)
      {
        *buf = 136446210;
        v80 = "nw_http_encrypt_oblivious_request";
        v53 = "%{public}s called with null out_encrypted_length, no backtrace";
        goto LABEL_174;
      }

      goto LABEL_175;
    }

    if (v65)
    {
      *buf = 136446466;
      v80 = "nw_http_encrypt_oblivious_request";
      v81 = 2082;
      v82 = backtrace_string;
      v56 = "%{public}s called with null out_encrypted_length, dumping backtrace:%{public}s";
      goto LABEL_130;
    }

LABEL_131:
    free(backtrace_string);
    goto LABEL_175;
  }

  v77 = 0;
  *type = 0;
  v16 = nw_http_oblivious_config_select(a4, a5, type, &v77);
  if (!v16 || *type < 0x29uLL || !v77)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v80 = "nw_http_encrypt_oblivious_request";
      v19 = "%{public}s Config parsing failed";
      goto LABEL_19;
    }

    return 0;
  }

  v17 = v16;
  v76 = strlen(a3);
  if (v76 >= 0x101)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v80 = "nw_http_encrypt_oblivious_request";
      v19 = "%{public}s Media type exceeds max length";
LABEL_19:
      _os_log_impl(&dword_181A37000, v18, OS_LOG_TYPE_ERROR, v19, buf, 0xCu);
      return 0;
    }

    return 0;
  }

  v71 = a6;
  v20 = cchpke_params_sizeof_aead_tag();
  v21 = cchpke_params_sizeof_kem_enc();
  v74 = malloc_type_calloc(1uLL, 0x60uLL, 0x11AEC5F6uLL);
  v72 = a7;
  if (!v74)
  {
    v22 = v21;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v80 = "nw_http_encrypt_oblivious_request";
    v81 = 2048;
    v82 = 1;
    v83 = 2048;
    v84 = 96;
    v23 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v23);
    if (result)
    {
      goto LABEL_179;
    }

    free(v23);
    v21 = v22;
  }

  v75 = v21;
  v25 = a2 + v20 + v21;
  v26 = v25 + 7;
  v73 = v25 + 7;
  if (v25 == -7)
  {
    v66 = __nwlog_obj();
    os_log_type_enabled(v66, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v67 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v67);
    if (result)
    {
      goto LABEL_179;
    }

    free(v67);
    v26 = v73;
  }

  v27 = malloc_type_calloc(1uLL, v26, 0xDDFEFD80uLL);
  if (!v27)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v80 = "nw_http_encrypt_oblivious_request";
    v81 = 2048;
    v82 = 1;
    v83 = 2048;
    v84 = v73;
    v28 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v28);
    if (result)
    {
      goto LABEL_179;
    }

    free(v28);
  }

  v70 = a8;
  *v27 = *v17;
  *(v27 + 1) = *(v17 + 1);
  *(v27 + 3) = 256;
  v29 = v77;
  if (v29 == cchpke_params_x25519_AESGCM256_HKDF_SHA256())
  {
    v30 = 512;
  }

  else
  {
    v30 = 256;
  }

  *(v27 + 5) = v30;
  ccrng();
  v31 = v75;
  memcpy(&v27[v75 + 7], a1, a2);
  v32 = v76;
  v33 = malloc_type_calloc(1uLL, v76 + 16, 0xB18C12A7uLL);
  if (!v33)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v80 = "nw_http_encrypt_oblivious_request";
    v81 = 2048;
    v82 = 1;
    v83 = 2048;
    v84 = v76 + 16;
    v34 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v34);
    if (result)
    {
      goto LABEL_179;
    }

    free(v34);
    v31 = v75;
    v32 = v76;
  }

  v35 = v32 + 9;
  snprintf(v33, v35, "%s request", a3);
  v36 = &v33[v35];
  v37 = *v27;
  *(v36 + 3) = *(v27 + 3);
  *v36 = v37;
  v38 = cchpke_initiator_setup();
  free(v33);
  if (v38)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v39 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v80 = "nw_http_encrypt_oblivious_request";
      v81 = 1024;
      LODWORD(v82) = v38;
      v40 = "%{public}s Setup error: %d";
      v41 = v39;
LABEL_39:
      _os_log_impl(&dword_181A37000, v41, OS_LOG_TYPE_ERROR, v40, buf, 0x12u);
      goto LABEL_40;
    }

    goto LABEL_40;
  }

  v42 = v31;
  v43 = cchpke_initiator_encrypt();
  if (v43)
  {
    v44 = v43;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v45 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v80 = "nw_http_encrypt_oblivious_request";
      v81 = 1024;
      LODWORD(v82) = v44;
      v40 = "%{public}s Encrypt: %d";
      v41 = v45;
      goto LABEL_39;
    }

LABEL_40:
    free(v27);
    if (!v74)
    {
      return 0;
    }

    v46 = v74;
LABEL_42:
    free(v46);
    return 0;
  }

  *v71 = v74;
  *v72 = 96;
  if (!v31)
  {
    v68 = __nwlog_obj();
    os_log_type_enabled(v68, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v80 = "nw_http_encrypt_oblivious_request";
    v69 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v69);
    if (result)
    {
      goto LABEL_179;
    }

    free(v69);
    v42 = v75;
  }

  v47 = malloc_type_calloc(1uLL, v42, 0x8870793uLL);
  if (v47)
  {
LABEL_49:
    *v70 = v47;
    memcpy(v47, v27 + 7, v42);
    *a9 = v42;
    *a10 = v73;
    return v27;
  }

  v48 = __nwlog_obj();
  os_log_type_enabled(v48, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v80 = "nw_http_encrypt_oblivious_request";
  v81 = 2048;
  v82 = 1;
  v83 = 2048;
  v84 = v42;
  v49 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v49);
  if (!result)
  {
    free(v49);
    v47 = 0;
    goto LABEL_49;
  }

LABEL_179:
  __break(1u);
  return result;
}

uint64_t nw_http_encrypt_chunked_oblivious_request_header(const char *a1, unsigned __int16 *a2, uint64_t a3, char **a4, void *a5, void *a6, size_t *a7, size_t *a8)
{
  v70 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v39 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v39, type, &v62))
    {
      goto LABEL_145;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v62 != 1)
      {
        v40 = __nwlog_obj();
        v41 = type[0];
        if (os_log_type_enabled(v40, type[0]))
        {
          *buf = 136446210;
          v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          v42 = "%{public}s called with null media_type, backtrace limit exceeded";
          goto LABEL_144;
        }

        goto LABEL_145;
      }

      backtrace_string = __nw_create_backtrace_string();
      v40 = __nwlog_obj();
      v41 = type[0];
      v44 = os_log_type_enabled(v40, type[0]);
      if (!backtrace_string)
      {
        if (v44)
        {
          *buf = 136446210;
          v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          v42 = "%{public}s called with null media_type, no backtrace";
          goto LABEL_144;
        }

        goto LABEL_145;
      }

      if (!v44)
      {
        goto LABEL_109;
      }

      *buf = 136446466;
      v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      v66 = 2082;
      v67 = backtrace_string;
      v45 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_108;
    }

    v40 = __nwlog_obj();
    v41 = type[0];
    if (!os_log_type_enabled(v40, type[0]))
    {
      goto LABEL_145;
    }

    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v42 = "%{public}s called with null media_type";
LABEL_144:
    _os_log_impl(&dword_181A37000, v40, v41, v42, buf, 0xCu);
    goto LABEL_145;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v39 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v39, type, &v62))
    {
      goto LABEL_145;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v62 != 1)
      {
        v40 = __nwlog_obj();
        v41 = type[0];
        if (os_log_type_enabled(v40, type[0]))
        {
          *buf = 136446210;
          v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          v42 = "%{public}s called with null config_buffer, backtrace limit exceeded";
          goto LABEL_144;
        }

        goto LABEL_145;
      }

      backtrace_string = __nw_create_backtrace_string();
      v40 = __nwlog_obj();
      v41 = type[0];
      v46 = os_log_type_enabled(v40, type[0]);
      if (!backtrace_string)
      {
        if (v46)
        {
          *buf = 136446210;
          v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          v42 = "%{public}s called with null config_buffer, no backtrace";
          goto LABEL_144;
        }

        goto LABEL_145;
      }

      if (!v46)
      {
        goto LABEL_109;
      }

      *buf = 136446466;
      v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      v66 = 2082;
      v67 = backtrace_string;
      v45 = "%{public}s called with null config_buffer, dumping backtrace:%{public}s";
      goto LABEL_108;
    }

    v40 = __nwlog_obj();
    v41 = type[0];
    if (!os_log_type_enabled(v40, type[0]))
    {
      goto LABEL_145;
    }

    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v42 = "%{public}s called with null config_buffer";
    goto LABEL_144;
  }

  if (!a3)
  {
    __nwlog_obj();
    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v39 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v39, type, &v62))
    {
      goto LABEL_145;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v62 != 1)
      {
        v40 = __nwlog_obj();
        v41 = type[0];
        if (os_log_type_enabled(v40, type[0]))
        {
          *buf = 136446210;
          v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          v42 = "%{public}s called with null in_config_length, backtrace limit exceeded";
          goto LABEL_144;
        }

        goto LABEL_145;
      }

      backtrace_string = __nw_create_backtrace_string();
      v40 = __nwlog_obj();
      v41 = type[0];
      v47 = os_log_type_enabled(v40, type[0]);
      if (!backtrace_string)
      {
        if (v47)
        {
          *buf = 136446210;
          v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          v42 = "%{public}s called with null in_config_length, no backtrace";
          goto LABEL_144;
        }

        goto LABEL_145;
      }

      if (!v47)
      {
        goto LABEL_109;
      }

      *buf = 136446466;
      v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      v66 = 2082;
      v67 = backtrace_string;
      v45 = "%{public}s called with null in_config_length, dumping backtrace:%{public}s";
      goto LABEL_108;
    }

    v40 = __nwlog_obj();
    v41 = type[0];
    if (!os_log_type_enabled(v40, type[0]))
    {
      goto LABEL_145;
    }

    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v42 = "%{public}s called with null in_config_length";
    goto LABEL_144;
  }

  if (!a4)
  {
    __nwlog_obj();
    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v39 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v39, type, &v62))
    {
      goto LABEL_145;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v62 != 1)
      {
        v40 = __nwlog_obj();
        v41 = type[0];
        if (os_log_type_enabled(v40, type[0]))
        {
          *buf = 136446210;
          v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          v42 = "%{public}s called with null out_context, backtrace limit exceeded";
          goto LABEL_144;
        }

        goto LABEL_145;
      }

      backtrace_string = __nw_create_backtrace_string();
      v40 = __nwlog_obj();
      v41 = type[0];
      v48 = os_log_type_enabled(v40, type[0]);
      if (!backtrace_string)
      {
        if (v48)
        {
          *buf = 136446210;
          v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          v42 = "%{public}s called with null out_context, no backtrace";
          goto LABEL_144;
        }

        goto LABEL_145;
      }

      if (!v48)
      {
        goto LABEL_109;
      }

      *buf = 136446466;
      v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      v66 = 2082;
      v67 = backtrace_string;
      v45 = "%{public}s called with null out_context, dumping backtrace:%{public}s";
      goto LABEL_108;
    }

    v40 = __nwlog_obj();
    v41 = type[0];
    if (!os_log_type_enabled(v40, type[0]))
    {
      goto LABEL_145;
    }

    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v42 = "%{public}s called with null out_context";
    goto LABEL_144;
  }

  if (!a5)
  {
    __nwlog_obj();
    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v39 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v39, type, &v62))
    {
      goto LABEL_145;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v62 != 1)
      {
        v40 = __nwlog_obj();
        v41 = type[0];
        if (os_log_type_enabled(v40, type[0]))
        {
          *buf = 136446210;
          v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          v42 = "%{public}s called with null out_context_length, backtrace limit exceeded";
          goto LABEL_144;
        }

        goto LABEL_145;
      }

      backtrace_string = __nw_create_backtrace_string();
      v40 = __nwlog_obj();
      v41 = type[0];
      v49 = os_log_type_enabled(v40, type[0]);
      if (!backtrace_string)
      {
        if (v49)
        {
          *buf = 136446210;
          v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          v42 = "%{public}s called with null out_context_length, no backtrace";
          goto LABEL_144;
        }

        goto LABEL_145;
      }

      if (!v49)
      {
        goto LABEL_109;
      }

      *buf = 136446466;
      v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      v66 = 2082;
      v67 = backtrace_string;
      v45 = "%{public}s called with null out_context_length, dumping backtrace:%{public}s";
      goto LABEL_108;
    }

    v40 = __nwlog_obj();
    v41 = type[0];
    if (!os_log_type_enabled(v40, type[0]))
    {
      goto LABEL_145;
    }

    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v42 = "%{public}s called with null out_context_length";
    goto LABEL_144;
  }

  if (!a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v39 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v39, type, &v62))
    {
      goto LABEL_145;
    }

    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v62 != 1)
      {
        v40 = __nwlog_obj();
        v41 = type[0];
        if (os_log_type_enabled(v40, type[0]))
        {
          *buf = 136446210;
          v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          v42 = "%{public}s called with null out_request_enc, backtrace limit exceeded";
          goto LABEL_144;
        }

        goto LABEL_145;
      }

      backtrace_string = __nw_create_backtrace_string();
      v40 = __nwlog_obj();
      v41 = type[0];
      v50 = os_log_type_enabled(v40, type[0]);
      if (!backtrace_string)
      {
        if (v50)
        {
          *buf = 136446210;
          v65 = "nw_http_encrypt_chunked_oblivious_request_header";
          v42 = "%{public}s called with null out_request_enc, no backtrace";
          goto LABEL_144;
        }

        goto LABEL_145;
      }

      if (!v50)
      {
        goto LABEL_109;
      }

      *buf = 136446466;
      v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      v66 = 2082;
      v67 = backtrace_string;
      v45 = "%{public}s called with null out_request_enc, dumping backtrace:%{public}s";
      goto LABEL_108;
    }

    v40 = __nwlog_obj();
    v41 = type[0];
    if (!os_log_type_enabled(v40, type[0]))
    {
      goto LABEL_145;
    }

    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v42 = "%{public}s called with null out_request_enc";
    goto LABEL_144;
  }

  if (!a7)
  {
    __nwlog_obj();
    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v39 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v39, type, &v62))
    {
      goto LABEL_145;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v40 = __nwlog_obj();
      v41 = type[0];
      if (!os_log_type_enabled(v40, type[0]))
      {
        goto LABEL_145;
      }

      *buf = 136446210;
      v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      v42 = "%{public}s called with null out_request_enc_length";
      goto LABEL_144;
    }

    if (v62 != 1)
    {
      v40 = __nwlog_obj();
      v41 = type[0];
      if (os_log_type_enabled(v40, type[0]))
      {
        *buf = 136446210;
        v65 = "nw_http_encrypt_chunked_oblivious_request_header";
        v42 = "%{public}s called with null out_request_enc_length, backtrace limit exceeded";
        goto LABEL_144;
      }

      goto LABEL_145;
    }

    backtrace_string = __nw_create_backtrace_string();
    v40 = __nwlog_obj();
    v41 = type[0];
    v51 = os_log_type_enabled(v40, type[0]);
    if (!backtrace_string)
    {
      if (v51)
      {
        *buf = 136446210;
        v65 = "nw_http_encrypt_chunked_oblivious_request_header";
        v42 = "%{public}s called with null out_request_enc_length, no backtrace";
        goto LABEL_144;
      }

      goto LABEL_145;
    }

    if (!v51)
    {
      goto LABEL_109;
    }

    *buf = 136446466;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v66 = 2082;
    v67 = backtrace_string;
    v45 = "%{public}s called with null out_request_enc_length, dumping backtrace:%{public}s";
LABEL_108:
    _os_log_impl(&dword_181A37000, v40, v41, v45, buf, 0x16u);
    goto LABEL_109;
  }

  if (!a8)
  {
    __nwlog_obj();
    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v39 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62) = 0;
    if (!__nwlog_fault(v39, type, &v62))
    {
      goto LABEL_145;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v40 = __nwlog_obj();
      v41 = type[0];
      if (os_log_type_enabled(v40, type[0]))
      {
        *buf = 136446210;
        v65 = "nw_http_encrypt_chunked_oblivious_request_header";
        v42 = "%{public}s called with null out_header_length";
        goto LABEL_144;
      }

LABEL_145:
      if (!v39)
      {
        return 0;
      }

      v36 = v39;
      goto LABEL_36;
    }

    if (v62 != 1)
    {
      v40 = __nwlog_obj();
      v41 = type[0];
      if (os_log_type_enabled(v40, type[0]))
      {
        *buf = 136446210;
        v65 = "nw_http_encrypt_chunked_oblivious_request_header";
        v42 = "%{public}s called with null out_header_length, backtrace limit exceeded";
        goto LABEL_144;
      }

      goto LABEL_145;
    }

    backtrace_string = __nw_create_backtrace_string();
    v40 = __nwlog_obj();
    v41 = type[0];
    v52 = os_log_type_enabled(v40, type[0]);
    if (!backtrace_string)
    {
      if (v52)
      {
        *buf = 136446210;
        v65 = "nw_http_encrypt_chunked_oblivious_request_header";
        v42 = "%{public}s called with null out_header_length, no backtrace";
        goto LABEL_144;
      }

      goto LABEL_145;
    }

    if (v52)
    {
      *buf = 136446466;
      v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      v66 = 2082;
      v67 = backtrace_string;
      v45 = "%{public}s called with null out_header_length, dumping backtrace:%{public}s";
      goto LABEL_108;
    }

LABEL_109:
    free(backtrace_string);
    goto LABEL_145;
  }

  v62 = 0;
  *type = 0;
  v14 = nw_http_oblivious_config_select(a2, a3, type, &v62);
  if (!v14 || *type < 0x29uLL || !v62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      v18 = "%{public}s Config parsing failed";
      goto LABEL_17;
    }

    return 0;
  }

  v15 = v14;
  v16 = strlen(a1);
  if (v16 >= 0x101)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      v18 = "%{public}s Media type exceeds max length";
LABEL_17:
      _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_ERROR, v18, buf, 0xCu);
      return 0;
    }

    return 0;
  }

  v19 = v16;
  v20 = cchpke_params_sizeof_kem_enc();
  v60 = malloc_type_calloc(1uLL, 0x60uLL, 0x2E155EFFuLL);
  if (!v60)
  {
    v21 = v20;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v66 = 2048;
    v67 = 1;
    v68 = 2048;
    v69 = 96;
    v22 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v22);
    if (result)
    {
      goto LABEL_149;
    }

    free(v22);
    v20 = v21;
  }

  v61 = v20;
  v24 = v20 + 7;
  if (v20 == -7)
  {
    v53 = __nwlog_obj();
    os_log_type_enabled(v53, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v54 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v54);
    if (result)
    {
      goto LABEL_149;
    }

    free(v54);
    v24 = 0;
  }

  v59 = v24;
  v25 = malloc_type_calloc(1uLL, v24, 0xC9FFF129uLL);
  if (!v25)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v66 = 2048;
    v67 = 1;
    v68 = 2048;
    v69 = v59;
    v26 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v26);
    if (result)
    {
      goto LABEL_149;
    }

    free(v26);
  }

  v57 = a7;
  v58 = a8;
  *v25 = *v15;
  *(v25 + 1) = *(v15 + 1);
  *(v25 + 3) = 256;
  v27 = v62;
  if (v27 == cchpke_params_x25519_AESGCM256_HKDF_SHA256())
  {
    v28 = 512;
  }

  else
  {
    v28 = 256;
  }

  *(v25 + 5) = v28;
  ccrng();
  v29 = malloc_type_calloc(1uLL, v19 + 24, 0x17C2AF8FuLL);
  if (!v29)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v66 = 2048;
    v67 = 1;
    v68 = 2048;
    v69 = v19 + 24;
    v30 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v30);
    if (result)
    {
      goto LABEL_149;
    }

    free(v30);
  }

  snprintf(v29, v19 + 17, "%s chunked request", a1);
  v31 = &v29[v19 + 17];
  v32 = *v25;
  *(v31 + 3) = *(v25 + 3);
  *v31 = v32;
  v33 = v61;
  v34 = cchpke_initiator_setup();
  free(v29);
  if (v34)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v35 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      v66 = 1024;
      LODWORD(v67) = v34;
      _os_log_impl(&dword_181A37000, v35, OS_LOG_TYPE_ERROR, "%{public}s Setup error: %d", buf, 0x12u);
    }

    free(v25);
    if (!v60)
    {
      return 0;
    }

    v36 = v60;
LABEL_36:
    free(v36);
    return 0;
  }

  *a4 = v60;
  *a5 = 96;
  if (!v61)
  {
    v55 = __nwlog_obj();
    os_log_type_enabled(v55, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v65 = "nw_http_encrypt_chunked_oblivious_request_header";
    v56 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v56);
    if (result)
    {
      goto LABEL_149;
    }

    free(v56);
    v33 = v61;
  }

  v37 = malloc_type_calloc(1uLL, v33, 0x133D5F66uLL);
  if (v37)
  {
LABEL_43:
    *a6 = v37;
    memcpy(v37, v25 + 7, v33);
    *v57 = v33;
    *v58 = v59;
    return v25;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v65 = "nw_http_encrypt_chunked_oblivious_request_header";
  v66 = 2048;
  v67 = 1;
  v68 = 2048;
  v69 = v33;
  v38 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v38);
  if (!result)
  {
    free(v38);
    v37 = 0;
    goto LABEL_43;
  }

LABEL_149:
  __break(1u);
  return result;
}

uint64_t nw_http_encrypt_chunked_oblivious_request_chunk(const void *a1, size_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, size_t *a8)
{
  v41 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v18 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v18, &type, &v33))
    {
      goto LABEL_108;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v33 != 1)
      {
        v19 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *buf = 136446210;
          v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          v21 = "%{public}s called with null message_buffer, backtrace limit exceeded";
          goto LABEL_107;
        }

        goto LABEL_108;
      }

      backtrace_string = __nw_create_backtrace_string();
      v19 = __nwlog_obj();
      v20 = type;
      v25 = os_log_type_enabled(v19, type);
      if (!backtrace_string)
      {
        if (v25)
        {
          *buf = 136446210;
          v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          v21 = "%{public}s called with null message_buffer, no backtrace";
          goto LABEL_107;
        }

        goto LABEL_108;
      }

      if (!v25)
      {
        goto LABEL_78;
      }

      *buf = 136446466;
      v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      v37 = 2082;
      v38 = backtrace_string;
      v26 = "%{public}s called with null message_buffer, dumping backtrace:%{public}s";
      goto LABEL_77;
    }

    v19 = __nwlog_obj();
    v20 = type;
    if (!os_log_type_enabled(v19, type))
    {
      goto LABEL_108;
    }

    *buf = 136446210;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v21 = "%{public}s called with null message_buffer";
LABEL_107:
    _os_log_impl(&dword_181A37000, v19, v20, v21, buf, 0xCu);
    goto LABEL_108;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v18 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v18, &type, &v33))
    {
      goto LABEL_108;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v33 != 1)
      {
        v19 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *buf = 136446210;
          v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          v21 = "%{public}s called with null message_length, backtrace limit exceeded";
          goto LABEL_107;
        }

        goto LABEL_108;
      }

      backtrace_string = __nw_create_backtrace_string();
      v19 = __nwlog_obj();
      v20 = type;
      v27 = os_log_type_enabled(v19, type);
      if (!backtrace_string)
      {
        if (v27)
        {
          *buf = 136446210;
          v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          v21 = "%{public}s called with null message_length, no backtrace";
          goto LABEL_107;
        }

        goto LABEL_108;
      }

      if (!v27)
      {
        goto LABEL_78;
      }

      *buf = 136446466;
      v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      v37 = 2082;
      v38 = backtrace_string;
      v26 = "%{public}s called with null message_length, dumping backtrace:%{public}s";
      goto LABEL_77;
    }

    v19 = __nwlog_obj();
    v20 = type;
    if (!os_log_type_enabled(v19, type))
    {
      goto LABEL_108;
    }

    *buf = 136446210;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v21 = "%{public}s called with null message_length";
    goto LABEL_107;
  }

  if (!a4)
  {
    __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v18 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v18, &type, &v33))
    {
      goto LABEL_108;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v33 != 1)
      {
        v19 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *buf = 136446210;
          v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          v21 = "%{public}s called with null request_context, backtrace limit exceeded";
          goto LABEL_107;
        }

        goto LABEL_108;
      }

      backtrace_string = __nw_create_backtrace_string();
      v19 = __nwlog_obj();
      v20 = type;
      v28 = os_log_type_enabled(v19, type);
      if (!backtrace_string)
      {
        if (v28)
        {
          *buf = 136446210;
          v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          v21 = "%{public}s called with null request_context, no backtrace";
          goto LABEL_107;
        }

        goto LABEL_108;
      }

      if (!v28)
      {
        goto LABEL_78;
      }

      *buf = 136446466;
      v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      v37 = 2082;
      v38 = backtrace_string;
      v26 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
      goto LABEL_77;
    }

    v19 = __nwlog_obj();
    v20 = type;
    if (!os_log_type_enabled(v19, type))
    {
      goto LABEL_108;
    }

    *buf = 136446210;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v21 = "%{public}s called with null request_context";
    goto LABEL_107;
  }

  if (!a5)
  {
    __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v18 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v18, &type, &v33))
    {
      goto LABEL_108;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v33 != 1)
      {
        v19 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *buf = 136446210;
          v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          v21 = "%{public}s called with null request_context_length, backtrace limit exceeded";
          goto LABEL_107;
        }

        goto LABEL_108;
      }

      backtrace_string = __nw_create_backtrace_string();
      v19 = __nwlog_obj();
      v20 = type;
      v29 = os_log_type_enabled(v19, type);
      if (!backtrace_string)
      {
        if (v29)
        {
          *buf = 136446210;
          v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          v21 = "%{public}s called with null request_context_length, no backtrace";
          goto LABEL_107;
        }

        goto LABEL_108;
      }

      if (!v29)
      {
        goto LABEL_78;
      }

      *buf = 136446466;
      v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      v37 = 2082;
      v38 = backtrace_string;
      v26 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
      goto LABEL_77;
    }

    v19 = __nwlog_obj();
    v20 = type;
    if (!os_log_type_enabled(v19, type))
    {
      goto LABEL_108;
    }

    *buf = 136446210;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v21 = "%{public}s called with null request_context_length";
    goto LABEL_107;
  }

  if (!a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v18 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v18, &type, &v33))
    {
      goto LABEL_108;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v33 != 1)
      {
        v19 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *buf = 136446210;
          v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          v21 = "%{public}s called with null request_enc, backtrace limit exceeded";
          goto LABEL_107;
        }

        goto LABEL_108;
      }

      backtrace_string = __nw_create_backtrace_string();
      v19 = __nwlog_obj();
      v20 = type;
      v30 = os_log_type_enabled(v19, type);
      if (!backtrace_string)
      {
        if (v30)
        {
          *buf = 136446210;
          v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
          v21 = "%{public}s called with null request_enc, no backtrace";
          goto LABEL_107;
        }

        goto LABEL_108;
      }

      if (!v30)
      {
        goto LABEL_78;
      }

      *buf = 136446466;
      v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      v37 = 2082;
      v38 = backtrace_string;
      v26 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
      goto LABEL_77;
    }

    v19 = __nwlog_obj();
    v20 = type;
    if (!os_log_type_enabled(v19, type))
    {
      goto LABEL_108;
    }

    *buf = 136446210;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v21 = "%{public}s called with null request_enc";
    goto LABEL_107;
  }

  if (!a7)
  {
    __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v18 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v18, &type, &v33))
    {
      goto LABEL_108;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
      {
        goto LABEL_108;
      }

      *buf = 136446210;
      v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      v21 = "%{public}s called with null request_enc_length";
      goto LABEL_107;
    }

    if (v33 != 1)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *buf = 136446210;
        v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        v21 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
        goto LABEL_107;
      }

      goto LABEL_108;
    }

    backtrace_string = __nw_create_backtrace_string();
    v19 = __nwlog_obj();
    v20 = type;
    v31 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v31)
      {
        *buf = 136446210;
        v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        v21 = "%{public}s called with null request_enc_length, no backtrace";
        goto LABEL_107;
      }

      goto LABEL_108;
    }

    if (!v31)
    {
      goto LABEL_78;
    }

    *buf = 136446466;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v37 = 2082;
    v38 = backtrace_string;
    v26 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
LABEL_77:
    _os_log_impl(&dword_181A37000, v19, v20, v26, buf, 0x16u);
    goto LABEL_78;
  }

  if (!a8)
  {
    __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v18 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v18, &type, &v33))
    {
      goto LABEL_108;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *buf = 136446210;
        v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        v21 = "%{public}s called with null out_encrypted_length";
        goto LABEL_107;
      }

LABEL_108:
      if (v18)
      {
        free(v18);
      }

      return 0;
    }

    if (v33 != 1)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *buf = 136446210;
        v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        v21 = "%{public}s called with null out_encrypted_length, backtrace limit exceeded";
        goto LABEL_107;
      }

      goto LABEL_108;
    }

    backtrace_string = __nw_create_backtrace_string();
    v19 = __nwlog_obj();
    v20 = type;
    v32 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *buf = 136446210;
        v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        v21 = "%{public}s called with null out_encrypted_length, no backtrace";
        goto LABEL_107;
      }

      goto LABEL_108;
    }

    if (v32)
    {
      *buf = 136446466;
      v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      v37 = 2082;
      v38 = backtrace_string;
      v26 = "%{public}s called with null out_encrypted_length, dumping backtrace:%{public}s";
      goto LABEL_77;
    }

LABEL_78:
    free(backtrace_string);
    goto LABEL_108;
  }

  v11 = cchpke_params_sizeof_aead_tag() + a2;
  if (!v11)
  {
    v22 = __nwlog_obj();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
    v23 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v23);
    if (result)
    {
      goto LABEL_111;
    }

    free(v23);
  }

  v12 = malloc_type_calloc(1uLL, v11, 0x4B9FEB89uLL);
  if (v12)
  {
    goto LABEL_12;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
  v37 = 2048;
  v38 = 1;
  v39 = 2048;
  v40 = v11;
  v13 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v13);
  if (!result)
  {
    free(v13);
LABEL_12:
    memcpy(v12, a1, a2);
    v15 = cchpke_initiator_encrypt();
    if (v15)
    {
      v16 = v15;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446466;
        v36 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        v37 = 1024;
        LODWORD(v38) = v16;
        _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_ERROR, "%{public}s Encrypt: %d", buf, 0x12u);
      }

      if (v12)
      {
        free(v12);
        return 0;
      }
    }

    else
    {
      *a8 = v11;
    }

    return v12;
  }

LABEL_111:
  __break(1u);
  return result;
}

uint64_t nw_http_decrypt_oblivious_request(uint64_t a1, unint64_t a2, const char *a3, uint64_t a4, uint64_t a5, char **a6, void *a7, void *a8, size_t *a9, size_t *a10)
{
  v86 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v47 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v47, &type, &v78))
    {
      goto LABEL_209;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v78 != 1)
      {
        v48 = __nwlog_obj();
        v49 = type;
        if (!os_log_type_enabled(v48, type))
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null request_buffer, backtrace limit exceeded";
        goto LABEL_208;
      }

      backtrace_string = __nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v49 = type;
      v52 = os_log_type_enabled(v48, type);
      if (!backtrace_string)
      {
        if (!v52)
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null request_buffer, no backtrace";
        goto LABEL_208;
      }

      if (!v52)
      {
        goto LABEL_145;
      }

      *buf = 136446466;
      v81 = "nw_http_decrypt_oblivious_request";
      v82 = 2082;
      v83 = backtrace_string;
      v53 = "%{public}s called with null request_buffer, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v48 = __nwlog_obj();
    v49 = type;
    if (!os_log_type_enabled(v48, type))
    {
      goto LABEL_209;
    }

    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v50 = "%{public}s called with null request_buffer";
LABEL_208:
    _os_log_impl(&dword_181A37000, v48, v49, v50, buf, 0xCu);
    goto LABEL_209;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v47 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v47, &type, &v78))
    {
      goto LABEL_209;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v78 != 1)
      {
        v48 = __nwlog_obj();
        v49 = type;
        if (!os_log_type_enabled(v48, type))
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null request_length, backtrace limit exceeded";
        goto LABEL_208;
      }

      backtrace_string = __nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v49 = type;
      v54 = os_log_type_enabled(v48, type);
      if (!backtrace_string)
      {
        if (!v54)
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null request_length, no backtrace";
        goto LABEL_208;
      }

      if (!v54)
      {
        goto LABEL_145;
      }

      *buf = 136446466;
      v81 = "nw_http_decrypt_oblivious_request";
      v82 = 2082;
      v83 = backtrace_string;
      v53 = "%{public}s called with null request_length, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v48 = __nwlog_obj();
    v49 = type;
    if (!os_log_type_enabled(v48, type))
    {
      goto LABEL_209;
    }

    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v50 = "%{public}s called with null request_length";
    goto LABEL_208;
  }

  if (!a3)
  {
    __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v47 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v47, &type, &v78))
    {
      goto LABEL_209;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v78 != 1)
      {
        v48 = __nwlog_obj();
        v49 = type;
        if (!os_log_type_enabled(v48, type))
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null media_type, backtrace limit exceeded";
        goto LABEL_208;
      }

      backtrace_string = __nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v49 = type;
      v55 = os_log_type_enabled(v48, type);
      if (!backtrace_string)
      {
        if (!v55)
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null media_type, no backtrace";
        goto LABEL_208;
      }

      if (!v55)
      {
        goto LABEL_145;
      }

      *buf = 136446466;
      v81 = "nw_http_decrypt_oblivious_request";
      v82 = 2082;
      v83 = backtrace_string;
      v53 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v48 = __nwlog_obj();
    v49 = type;
    if (!os_log_type_enabled(v48, type))
    {
      goto LABEL_209;
    }

    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v50 = "%{public}s called with null media_type";
    goto LABEL_208;
  }

  if (!a4)
  {
    __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v47 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v47, &type, &v78))
    {
      goto LABEL_209;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v78 != 1)
      {
        v48 = __nwlog_obj();
        v49 = type;
        if (!os_log_type_enabled(v48, type))
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null private_key, backtrace limit exceeded";
        goto LABEL_208;
      }

      backtrace_string = __nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v49 = type;
      v56 = os_log_type_enabled(v48, type);
      if (!backtrace_string)
      {
        if (!v56)
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null private_key, no backtrace";
        goto LABEL_208;
      }

      if (!v56)
      {
        goto LABEL_145;
      }

      *buf = 136446466;
      v81 = "nw_http_decrypt_oblivious_request";
      v82 = 2082;
      v83 = backtrace_string;
      v53 = "%{public}s called with null private_key, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v48 = __nwlog_obj();
    v49 = type;
    if (!os_log_type_enabled(v48, type))
    {
      goto LABEL_209;
    }

    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v50 = "%{public}s called with null private_key";
    goto LABEL_208;
  }

  if (!a5)
  {
    __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v47 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v47, &type, &v78))
    {
      goto LABEL_209;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v78 != 1)
      {
        v48 = __nwlog_obj();
        v49 = type;
        if (!os_log_type_enabled(v48, type))
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null private_key_length, backtrace limit exceeded";
        goto LABEL_208;
      }

      backtrace_string = __nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v49 = type;
      v57 = os_log_type_enabled(v48, type);
      if (!backtrace_string)
      {
        if (!v57)
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null private_key_length, no backtrace";
        goto LABEL_208;
      }

      if (!v57)
      {
        goto LABEL_145;
      }

      *buf = 136446466;
      v81 = "nw_http_decrypt_oblivious_request";
      v82 = 2082;
      v83 = backtrace_string;
      v53 = "%{public}s called with null private_key_length, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v48 = __nwlog_obj();
    v49 = type;
    if (!os_log_type_enabled(v48, type))
    {
      goto LABEL_209;
    }

    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v50 = "%{public}s called with null private_key_length";
    goto LABEL_208;
  }

  if (!a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v47 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v47, &type, &v78))
    {
      goto LABEL_209;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v78 != 1)
      {
        v48 = __nwlog_obj();
        v49 = type;
        if (!os_log_type_enabled(v48, type))
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null out_context, backtrace limit exceeded";
        goto LABEL_208;
      }

      backtrace_string = __nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v49 = type;
      v58 = os_log_type_enabled(v48, type);
      if (!backtrace_string)
      {
        if (!v58)
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null out_context, no backtrace";
        goto LABEL_208;
      }

      if (!v58)
      {
        goto LABEL_145;
      }

      *buf = 136446466;
      v81 = "nw_http_decrypt_oblivious_request";
      v82 = 2082;
      v83 = backtrace_string;
      v53 = "%{public}s called with null out_context, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v48 = __nwlog_obj();
    v49 = type;
    if (!os_log_type_enabled(v48, type))
    {
      goto LABEL_209;
    }

    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v50 = "%{public}s called with null out_context";
    goto LABEL_208;
  }

  if (!a7)
  {
    __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v47 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v47, &type, &v78))
    {
      goto LABEL_209;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v78 != 1)
      {
        v48 = __nwlog_obj();
        v49 = type;
        if (!os_log_type_enabled(v48, type))
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null out_context_length, backtrace limit exceeded";
        goto LABEL_208;
      }

      backtrace_string = __nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v49 = type;
      v59 = os_log_type_enabled(v48, type);
      if (!backtrace_string)
      {
        if (!v59)
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null out_context_length, no backtrace";
        goto LABEL_208;
      }

      if (!v59)
      {
        goto LABEL_145;
      }

      *buf = 136446466;
      v81 = "nw_http_decrypt_oblivious_request";
      v82 = 2082;
      v83 = backtrace_string;
      v53 = "%{public}s called with null out_context_length, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v48 = __nwlog_obj();
    v49 = type;
    if (!os_log_type_enabled(v48, type))
    {
      goto LABEL_209;
    }

    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v50 = "%{public}s called with null out_context_length";
    goto LABEL_208;
  }

  if (!a8)
  {
    __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v47 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v47, &type, &v78))
    {
      goto LABEL_209;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v78 != 1)
      {
        v48 = __nwlog_obj();
        v49 = type;
        if (!os_log_type_enabled(v48, type))
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null out_request_enc, backtrace limit exceeded";
        goto LABEL_208;
      }

      backtrace_string = __nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v49 = type;
      v60 = os_log_type_enabled(v48, type);
      if (!backtrace_string)
      {
        if (!v60)
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null out_request_enc, no backtrace";
        goto LABEL_208;
      }

      if (!v60)
      {
        goto LABEL_145;
      }

      *buf = 136446466;
      v81 = "nw_http_decrypt_oblivious_request";
      v82 = 2082;
      v83 = backtrace_string;
      v53 = "%{public}s called with null out_request_enc, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v48 = __nwlog_obj();
    v49 = type;
    if (!os_log_type_enabled(v48, type))
    {
      goto LABEL_209;
    }

    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v50 = "%{public}s called with null out_request_enc";
    goto LABEL_208;
  }

  if (!a9)
  {
    __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v47 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v47, &type, &v78))
    {
      goto LABEL_209;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v78 != 1)
      {
        v48 = __nwlog_obj();
        v49 = type;
        if (!os_log_type_enabled(v48, type))
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null out_request_enc_length, backtrace limit exceeded";
        goto LABEL_208;
      }

      backtrace_string = __nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v49 = type;
      v61 = os_log_type_enabled(v48, type);
      if (!backtrace_string)
      {
        if (!v61)
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null out_request_enc_length, no backtrace";
        goto LABEL_208;
      }

      if (!v61)
      {
        goto LABEL_145;
      }

      *buf = 136446466;
      v81 = "nw_http_decrypt_oblivious_request";
      v82 = 2082;
      v83 = backtrace_string;
      v53 = "%{public}s called with null out_request_enc_length, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v48 = __nwlog_obj();
    v49 = type;
    if (!os_log_type_enabled(v48, type))
    {
      goto LABEL_209;
    }

    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v50 = "%{public}s called with null out_request_enc_length";
    goto LABEL_208;
  }

  if (!a10)
  {
    __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v47 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v47, &type, &v78))
    {
      goto LABEL_209;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v78 != 1)
      {
        v48 = __nwlog_obj();
        v49 = type;
        if (!os_log_type_enabled(v48, type))
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null out_decrypted_length, backtrace limit exceeded";
        goto LABEL_208;
      }

      backtrace_string = __nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v49 = type;
      v62 = os_log_type_enabled(v48, type);
      if (!backtrace_string)
      {
        if (!v62)
        {
          goto LABEL_209;
        }

        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null out_decrypted_length, no backtrace";
        goto LABEL_208;
      }

      if (!v62)
      {
        goto LABEL_145;
      }

      *buf = 136446466;
      v81 = "nw_http_decrypt_oblivious_request";
      v82 = 2082;
      v83 = backtrace_string;
      v53 = "%{public}s called with null out_decrypted_length, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v48 = __nwlog_obj();
    v49 = type;
    if (!os_log_type_enabled(v48, type))
    {
      goto LABEL_209;
    }

    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v50 = "%{public}s called with null out_decrypted_length";
    goto LABEL_208;
  }

  v10 = a2 - 7;
  if (a2 <= 7)
  {
    __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v47 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v47, &type, &v78))
    {
      goto LABEL_209;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (!os_log_type_enabled(v48, type))
      {
        goto LABEL_209;
      }

      *buf = 136446210;
      v81 = "nw_http_decrypt_oblivious_request";
      v50 = "%{public}s called with null (request_length > hdr_length)";
      goto LABEL_208;
    }

    if (v78 != 1)
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (!os_log_type_enabled(v48, type))
      {
        goto LABEL_209;
      }

      *buf = 136446210;
      v81 = "nw_http_decrypt_oblivious_request";
      v50 = "%{public}s called with null (request_length > hdr_length), backtrace limit exceeded";
      goto LABEL_208;
    }

    backtrace_string = __nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = type;
    v63 = os_log_type_enabled(v48, type);
    if (!backtrace_string)
    {
      if (!v63)
      {
        goto LABEL_209;
      }

      *buf = 136446210;
      v81 = "nw_http_decrypt_oblivious_request";
      v50 = "%{public}s called with null (request_length > hdr_length), no backtrace";
      goto LABEL_208;
    }

    if (!v63)
    {
      goto LABEL_145;
    }

    *buf = 136446466;
    v81 = "nw_http_decrypt_oblivious_request";
    v82 = 2082;
    v83 = backtrace_string;
    v53 = "%{public}s called with null (request_length > hdr_length), dumping backtrace:%{public}s";
LABEL_144:
    _os_log_impl(&dword_181A37000, v48, v49, v53, buf, 0x16u);
    goto LABEL_145;
  }

  if (*(a1 + 1) != 0x2000 || *(a1 + 3) != 256)
  {
    return 0;
  }

  v11 = *(a1 + 5);
  if (v11 == 512)
  {
    v12 = a2;
    v13 = a3;
    v14 = a1;
    v76 = a6;
    v77 = a7;
    v75 = a8;
    cchpke_params_x25519_AESGCM256_HKDF_SHA256();
  }

  else
  {
    if (v11 != 256)
    {
      return 0;
    }

    v12 = a2;
    v13 = a3;
    v14 = a1;
    v76 = a6;
    v77 = a7;
    v75 = a8;
    cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  }

  v15 = strlen(v13);
  if (v15 >= 0x101)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v81 = "nw_http_decrypt_oblivious_request";
      _os_log_impl(&dword_181A37000, v16, OS_LOG_TYPE_ERROR, "%{public}s Media type exceeds max length", buf, 0xCu);
    }

    return 0;
  }

  v17 = v15;
  v18 = cchpke_params_sizeof_aead_tag();
  v19 = cchpke_params_sizeof_kem_enc();
  v73 = v19 + v18;
  size = v18;
  if (v19 + v18 + 7 >= v12)
  {
    __nwlog_obj();
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v47 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v47, &type, &v78))
    {
      goto LABEL_209;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null (request_length > (hdr_length + tag_length + enc_length))";
        goto LABEL_208;
      }

LABEL_209:
      if (!v47)
      {
        return 0;
      }

      v42 = v47;
      goto LABEL_48;
    }

    if (v78 != 1)
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null (request_length > (hdr_length + tag_length + enc_length)), backtrace limit exceeded";
        goto LABEL_208;
      }

      goto LABEL_209;
    }

    backtrace_string = __nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = type;
    v64 = os_log_type_enabled(v48, type);
    if (!backtrace_string)
    {
      if (v64)
      {
        *buf = 136446210;
        v81 = "nw_http_decrypt_oblivious_request";
        v50 = "%{public}s called with null (request_length > (hdr_length + tag_length + enc_length)), no backtrace";
        goto LABEL_208;
      }

      goto LABEL_209;
    }

    if (v64)
    {
      *buf = 136446466;
      v81 = "nw_http_decrypt_oblivious_request";
      v82 = 2082;
      v83 = backtrace_string;
      v53 = "%{public}s called with null (request_length > (hdr_length + tag_length + enc_length)), dumping backtrace:%{public}s";
      goto LABEL_144;
    }

LABEL_145:
    free(backtrace_string);
    goto LABEL_209;
  }

  v20 = v19;
  v21 = malloc_type_calloc(1uLL, v17 + 16, 0xCA9AEECDuLL);
  if (!v21)
  {
    v71 = v20;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v81 = "nw_http_decrypt_oblivious_request";
    v82 = 2048;
    v83 = 1;
    v84 = 2048;
    v85 = v17 + 16;
    v22 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v22);
    if (result)
    {
      goto LABEL_211;
    }

    free(v22);
    v20 = v71;
  }

  v24 = v17 + 9;
  snprintf(v21, v24, "%s request", v13);
  v25 = &v21[v24];
  v26 = *(v14 + 3);
  *v25 = *v14;
  *(v25 + 3) = v26;
  v27 = malloc_type_calloc(1uLL, 0x60uLL, 0xE0B9AC54uLL);
  if (!v27)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v81 = "nw_http_decrypt_oblivious_request";
    v82 = 2048;
    v83 = 1;
    v84 = 2048;
    v85 = 96;
    v28 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v28);
    if (result)
    {
      goto LABEL_211;
    }

    free(v28);
  }

  v29 = v14 + 7;
  v30 = cchpke_responder_setup();
  free(v21);
  if (v30)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v31 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v81 = "nw_http_decrypt_oblivious_request";
      v82 = 1024;
      LODWORD(v83) = v30;
      _os_log_impl(&dword_181A37000, v31, OS_LOG_TYPE_ERROR, "%{public}s Setup error: %d", buf, 0x12u);
    }

    goto LABEL_46;
  }

  v32 = size;
  if (!size)
  {
    v65 = __nwlog_obj();
    os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v66 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v66);
    if (result)
    {
      goto LABEL_211;
    }

    free(v66);
    v32 = 0;
  }

  v33 = malloc_type_calloc(1uLL, v32, 0xD4E967CDuLL);
  if (!v33)
  {
    v34 = __nwlog_obj();
    os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v81 = "nw_http_decrypt_oblivious_request";
    v82 = 2048;
    v83 = 1;
    v84 = 2048;
    v85 = v32;
    v35 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v35);
    if (result)
    {
      goto LABEL_211;
    }

    free(v35);
  }

  v36 = v10 - v73;
  v72 = v20;
  memcpy(v33, &v29[v20 + v10 - v73], v32);
  if (v10 == v73)
  {
    v67 = __nwlog_obj();
    os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v81 = "nw_http_decrypt_oblivious_request";
    v68 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v68);
    if (result)
    {
      goto LABEL_211;
    }

    free(v68);
  }

  v37 = malloc_type_calloc(1uLL, v36, 0x65A491E8uLL);
  if (!v37)
  {
    v38 = __nwlog_obj();
    os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v81 = "nw_http_decrypt_oblivious_request";
    v82 = 2048;
    v83 = 1;
    v84 = 2048;
    v85 = v36;
    v39 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v39);
    if (result)
    {
      goto LABEL_211;
    }

    free(v39);
  }

  v40 = cchpke_responder_decrypt();
  if (v33)
  {
    free(v33);
  }

  if (!v40)
  {
    *v76 = v27;
    *v77 = 96;
    v43 = v72;
    if (!v72)
    {
      v69 = __nwlog_obj();
      os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
      *buf = 136446210;
      v81 = "nw_http_decrypt_oblivious_request";
      v70 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v70);
      if (result)
      {
        goto LABEL_211;
      }

      free(v70);
      v43 = 0;
    }

    v44 = malloc_type_calloc(1uLL, v43, 0xAC60DD8BuLL);
    if (v44)
    {
LABEL_55:
      *v75 = v44;
      memcpy(v44, v29, v43);
      *a9 = v43;
      *a10 = v36;
      return v37;
    }

    v45 = __nwlog_obj();
    os_log_type_enabled(v45, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v81 = "nw_http_decrypt_oblivious_request";
    v82 = 2048;
    v83 = 1;
    v84 = 2048;
    v85 = v43;
    v46 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v46);
    if (!result)
    {
      free(v46);
      v44 = 0;
      v43 = v72;
      goto LABEL_55;
    }

LABEL_211:
    __break(1u);
    return result;
  }

  v41 = __nwlog_obj();
  if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
  {
    *buf = 136446466;
    v81 = "nw_http_decrypt_oblivious_request";
    v82 = 1024;
    LODWORD(v83) = v40;
    _os_log_impl(&dword_181A37000, v41, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", buf, 0x12u);
  }

  if (v37)
  {
    free(v37);
  }

LABEL_46:
  if (v27)
  {
    v42 = v27;
LABEL_48:
    free(v42);
  }

  return 0;
}

uint64_t nw_http_decrypt_chunked_oblivious_request_header(uint64_t a1, unint64_t a2, const char *a3, uint64_t a4, uint64_t a5, char **a6, void *a7, void *a8, size_t *a9)
{
  v61 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v33, &type, &v53))
    {
      goto LABEL_174;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v53 != 1)
      {
        v34 = __nwlog_obj();
        v35 = type;
        if (!os_log_type_enabled(v34, type))
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null header_buffer, backtrace limit exceeded";
        goto LABEL_173;
      }

      backtrace_string = __nw_create_backtrace_string();
      v34 = __nwlog_obj();
      v35 = type;
      v38 = os_log_type_enabled(v34, type);
      if (!backtrace_string)
      {
        if (!v38)
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null header_buffer, no backtrace";
        goto LABEL_173;
      }

      if (!v38)
      {
        goto LABEL_120;
      }

      *buf = 136446466;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v57 = 2082;
      v58 = backtrace_string;
      v39 = "%{public}s called with null header_buffer, dumping backtrace:%{public}s";
      goto LABEL_119;
    }

    v34 = __nwlog_obj();
    v35 = type;
    if (!os_log_type_enabled(v34, type))
    {
      goto LABEL_174;
    }

    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v36 = "%{public}s called with null header_buffer";
LABEL_173:
    _os_log_impl(&dword_181A37000, v34, v35, v36, buf, 0xCu);
    goto LABEL_174;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v33, &type, &v53))
    {
      goto LABEL_174;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v53 != 1)
      {
        v34 = __nwlog_obj();
        v35 = type;
        if (!os_log_type_enabled(v34, type))
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null header_length, backtrace limit exceeded";
        goto LABEL_173;
      }

      backtrace_string = __nw_create_backtrace_string();
      v34 = __nwlog_obj();
      v35 = type;
      v40 = os_log_type_enabled(v34, type);
      if (!backtrace_string)
      {
        if (!v40)
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null header_length, no backtrace";
        goto LABEL_173;
      }

      if (!v40)
      {
        goto LABEL_120;
      }

      *buf = 136446466;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v57 = 2082;
      v58 = backtrace_string;
      v39 = "%{public}s called with null header_length, dumping backtrace:%{public}s";
      goto LABEL_119;
    }

    v34 = __nwlog_obj();
    v35 = type;
    if (!os_log_type_enabled(v34, type))
    {
      goto LABEL_174;
    }

    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v36 = "%{public}s called with null header_length";
    goto LABEL_173;
  }

  if (!a3)
  {
    __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v33, &type, &v53))
    {
      goto LABEL_174;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v53 != 1)
      {
        v34 = __nwlog_obj();
        v35 = type;
        if (!os_log_type_enabled(v34, type))
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null media_type, backtrace limit exceeded";
        goto LABEL_173;
      }

      backtrace_string = __nw_create_backtrace_string();
      v34 = __nwlog_obj();
      v35 = type;
      v41 = os_log_type_enabled(v34, type);
      if (!backtrace_string)
      {
        if (!v41)
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null media_type, no backtrace";
        goto LABEL_173;
      }

      if (!v41)
      {
        goto LABEL_120;
      }

      *buf = 136446466;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v57 = 2082;
      v58 = backtrace_string;
      v39 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_119;
    }

    v34 = __nwlog_obj();
    v35 = type;
    if (!os_log_type_enabled(v34, type))
    {
      goto LABEL_174;
    }

    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v36 = "%{public}s called with null media_type";
    goto LABEL_173;
  }

  if (!a4)
  {
    __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v33, &type, &v53))
    {
      goto LABEL_174;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v53 != 1)
      {
        v34 = __nwlog_obj();
        v35 = type;
        if (!os_log_type_enabled(v34, type))
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null private_key, backtrace limit exceeded";
        goto LABEL_173;
      }

      backtrace_string = __nw_create_backtrace_string();
      v34 = __nwlog_obj();
      v35 = type;
      v42 = os_log_type_enabled(v34, type);
      if (!backtrace_string)
      {
        if (!v42)
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null private_key, no backtrace";
        goto LABEL_173;
      }

      if (!v42)
      {
        goto LABEL_120;
      }

      *buf = 136446466;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v57 = 2082;
      v58 = backtrace_string;
      v39 = "%{public}s called with null private_key, dumping backtrace:%{public}s";
      goto LABEL_119;
    }

    v34 = __nwlog_obj();
    v35 = type;
    if (!os_log_type_enabled(v34, type))
    {
      goto LABEL_174;
    }

    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v36 = "%{public}s called with null private_key";
    goto LABEL_173;
  }

  if (!a5)
  {
    __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v33, &type, &v53))
    {
      goto LABEL_174;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v53 != 1)
      {
        v34 = __nwlog_obj();
        v35 = type;
        if (!os_log_type_enabled(v34, type))
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null private_key_length, backtrace limit exceeded";
        goto LABEL_173;
      }

      backtrace_string = __nw_create_backtrace_string();
      v34 = __nwlog_obj();
      v35 = type;
      v43 = os_log_type_enabled(v34, type);
      if (!backtrace_string)
      {
        if (!v43)
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null private_key_length, no backtrace";
        goto LABEL_173;
      }

      if (!v43)
      {
        goto LABEL_120;
      }

      *buf = 136446466;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v57 = 2082;
      v58 = backtrace_string;
      v39 = "%{public}s called with null private_key_length, dumping backtrace:%{public}s";
      goto LABEL_119;
    }

    v34 = __nwlog_obj();
    v35 = type;
    if (!os_log_type_enabled(v34, type))
    {
      goto LABEL_174;
    }

    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v36 = "%{public}s called with null private_key_length";
    goto LABEL_173;
  }

  if (!a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v33, &type, &v53))
    {
      goto LABEL_174;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v53 != 1)
      {
        v34 = __nwlog_obj();
        v35 = type;
        if (!os_log_type_enabled(v34, type))
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null out_context, backtrace limit exceeded";
        goto LABEL_173;
      }

      backtrace_string = __nw_create_backtrace_string();
      v34 = __nwlog_obj();
      v35 = type;
      v44 = os_log_type_enabled(v34, type);
      if (!backtrace_string)
      {
        if (!v44)
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null out_context, no backtrace";
        goto LABEL_173;
      }

      if (!v44)
      {
        goto LABEL_120;
      }

      *buf = 136446466;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v57 = 2082;
      v58 = backtrace_string;
      v39 = "%{public}s called with null out_context, dumping backtrace:%{public}s";
      goto LABEL_119;
    }

    v34 = __nwlog_obj();
    v35 = type;
    if (!os_log_type_enabled(v34, type))
    {
      goto LABEL_174;
    }

    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v36 = "%{public}s called with null out_context";
    goto LABEL_173;
  }

  if (!a7)
  {
    __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v33, &type, &v53))
    {
      goto LABEL_174;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v53 != 1)
      {
        v34 = __nwlog_obj();
        v35 = type;
        if (!os_log_type_enabled(v34, type))
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null out_context_length, backtrace limit exceeded";
        goto LABEL_173;
      }

      backtrace_string = __nw_create_backtrace_string();
      v34 = __nwlog_obj();
      v35 = type;
      v45 = os_log_type_enabled(v34, type);
      if (!backtrace_string)
      {
        if (!v45)
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null out_context_length, no backtrace";
        goto LABEL_173;
      }

      if (!v45)
      {
        goto LABEL_120;
      }

      *buf = 136446466;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v57 = 2082;
      v58 = backtrace_string;
      v39 = "%{public}s called with null out_context_length, dumping backtrace:%{public}s";
      goto LABEL_119;
    }

    v34 = __nwlog_obj();
    v35 = type;
    if (!os_log_type_enabled(v34, type))
    {
      goto LABEL_174;
    }

    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v36 = "%{public}s called with null out_context_length";
    goto LABEL_173;
  }

  if (!a8)
  {
    __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v33, &type, &v53))
    {
      goto LABEL_174;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v53 != 1)
      {
        v34 = __nwlog_obj();
        v35 = type;
        if (!os_log_type_enabled(v34, type))
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null out_request_enc, backtrace limit exceeded";
        goto LABEL_173;
      }

      backtrace_string = __nw_create_backtrace_string();
      v34 = __nwlog_obj();
      v35 = type;
      v46 = os_log_type_enabled(v34, type);
      if (!backtrace_string)
      {
        if (!v46)
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null out_request_enc, no backtrace";
        goto LABEL_173;
      }

      if (!v46)
      {
        goto LABEL_120;
      }

      *buf = 136446466;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v57 = 2082;
      v58 = backtrace_string;
      v39 = "%{public}s called with null out_request_enc, dumping backtrace:%{public}s";
      goto LABEL_119;
    }

    v34 = __nwlog_obj();
    v35 = type;
    if (!os_log_type_enabled(v34, type))
    {
      goto LABEL_174;
    }

    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v36 = "%{public}s called with null out_request_enc";
    goto LABEL_173;
  }

  if (!a9)
  {
    __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v33, &type, &v53))
    {
      goto LABEL_174;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v53 != 1)
      {
        v34 = __nwlog_obj();
        v35 = type;
        if (!os_log_type_enabled(v34, type))
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null out_request_enc_length, backtrace limit exceeded";
        goto LABEL_173;
      }

      backtrace_string = __nw_create_backtrace_string();
      v34 = __nwlog_obj();
      v35 = type;
      v47 = os_log_type_enabled(v34, type);
      if (!backtrace_string)
      {
        if (!v47)
        {
          goto LABEL_174;
        }

        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null out_request_enc_length, no backtrace";
        goto LABEL_173;
      }

      if (!v47)
      {
        goto LABEL_120;
      }

      *buf = 136446466;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v57 = 2082;
      v58 = backtrace_string;
      v39 = "%{public}s called with null out_request_enc_length, dumping backtrace:%{public}s";
      goto LABEL_119;
    }

    v34 = __nwlog_obj();
    v35 = type;
    if (!os_log_type_enabled(v34, type))
    {
      goto LABEL_174;
    }

    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v36 = "%{public}s called with null out_request_enc_length";
    goto LABEL_173;
  }

  if (a2 <= 7)
  {
    __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v33, &type, &v53))
    {
      goto LABEL_174;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v34 = __nwlog_obj();
      v35 = type;
      if (!os_log_type_enabled(v34, type))
      {
        goto LABEL_174;
      }

      *buf = 136446210;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v36 = "%{public}s called with null (header_length > hdr_length)";
      goto LABEL_173;
    }

    if (v53 != 1)
    {
      v34 = __nwlog_obj();
      v35 = type;
      if (!os_log_type_enabled(v34, type))
      {
        goto LABEL_174;
      }

      *buf = 136446210;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v36 = "%{public}s called with null (header_length > hdr_length), backtrace limit exceeded";
      goto LABEL_173;
    }

    backtrace_string = __nw_create_backtrace_string();
    v34 = __nwlog_obj();
    v35 = type;
    v48 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (!v48)
      {
        goto LABEL_174;
      }

      *buf = 136446210;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v36 = "%{public}s called with null (header_length > hdr_length), no backtrace";
      goto LABEL_173;
    }

    if (!v48)
    {
      goto LABEL_120;
    }

    *buf = 136446466;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v57 = 2082;
    v58 = backtrace_string;
    v39 = "%{public}s called with null (header_length > hdr_length), dumping backtrace:%{public}s";
LABEL_119:
    _os_log_impl(&dword_181A37000, v34, v35, v39, buf, 0x16u);
    goto LABEL_120;
  }

  if (*(a1 + 1) != 0x2000 || *(a1 + 3) != 256)
  {
    return 0;
  }

  v9 = *(a1 + 5);
  if (v9 == 512)
  {
    v10 = a2;
    v11 = a3;
    v52 = a7;
    v50 = a8;
    v51 = a6;
    v12 = a1;
    cchpke_params_x25519_AESGCM256_HKDF_SHA256();
  }

  else
  {
    if (v9 != 256)
    {
      return 0;
    }

    v10 = a2;
    v11 = a3;
    v52 = a7;
    v50 = a8;
    v51 = a6;
    v12 = a1;
    cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  }

  v13 = strlen(v11);
  if (v13 < 0x101)
  {
    v16 = v13;
    v17 = cchpke_params_sizeof_kem_enc();
    if (v17 + 7 == v10)
    {
      v18 = v17;
      v19 = malloc_type_calloc(1uLL, v16 + 24, 0x9738858FuLL);
      if (!v19)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
        *buf = 136446722;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v57 = 2048;
        v58 = 1;
        v59 = 2048;
        v60 = v16 + 24;
        v20 = _os_log_send_and_compose_impl();
        result = __nwlog_should_abort(v20);
        if (result)
        {
          goto LABEL_176;
        }

        free(v20);
      }

      v21 = v16 + 17;
      snprintf(v19, v21, "%s chunked request", v11);
      v22 = &v19[v21];
      v23 = *(v12 + 3);
      v24 = v12;
      *v22 = *v12;
      *(v22 + 3) = v23;
      v25 = malloc_type_calloc(1uLL, 0x60uLL, 0xEE8BE67FuLL);
      if (!v25)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
        *buf = 136446722;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v57 = 2048;
        v58 = 1;
        v59 = 2048;
        v60 = 96;
        v26 = _os_log_send_and_compose_impl();
        result = __nwlog_should_abort(v26);
        if (result)
        {
          goto LABEL_176;
        }

        free(v26);
      }

      v27 = cchpke_responder_setup();
      free(v19);
      if (v27)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = gLogObj;
        if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
        {
          *buf = 136446466;
          v56 = "nw_http_decrypt_chunked_oblivious_request_header";
          v57 = 1024;
          LODWORD(v58) = v27;
          _os_log_impl(&dword_181A37000, v28, OS_LOG_TYPE_ERROR, "%{public}s Setup error: %d", buf, 0x12u);
        }

        if (!v25)
        {
          return 0;
        }

        v29 = v25;
LABEL_32:
        free(v29);
        return 0;
      }

      *v51 = v25;
      *v52 = 96;
      v30 = malloc_type_calloc(1uLL, v18, 0x92322915uLL);
      if (v30)
      {
LABEL_38:
        *v50 = v30;
        memcpy(v30, v24 + 7, v18);
        *a9 = v18;
        return 1;
      }

      v31 = __nwlog_obj();
      os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
      *buf = 136446722;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v57 = 2048;
      v58 = 1;
      v59 = 2048;
      v60 = v18;
      v32 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v32);
      if (!result)
      {
        free(v32);
        v30 = 0;
        goto LABEL_38;
      }

LABEL_176:
      __break(1u);
      return result;
    }

    __nwlog_obj();
    *buf = 136446210;
    v56 = "nw_http_decrypt_chunked_oblivious_request_header";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v33, &type, &v53))
    {
      goto LABEL_174;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v34 = __nwlog_obj();
      v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null (header_length == (hdr_length + enc_length))";
        goto LABEL_173;
      }

LABEL_174:
      if (!v33)
      {
        return 0;
      }

      v29 = v33;
      goto LABEL_32;
    }

    if (v53 != 1)
    {
      v34 = __nwlog_obj();
      v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null (header_length == (hdr_length + enc_length)), backtrace limit exceeded";
        goto LABEL_173;
      }

      goto LABEL_174;
    }

    backtrace_string = __nw_create_backtrace_string();
    v34 = __nwlog_obj();
    v35 = type;
    v49 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (v49)
      {
        *buf = 136446210;
        v56 = "nw_http_decrypt_chunked_oblivious_request_header";
        v36 = "%{public}s called with null (header_length == (hdr_length + enc_length)), no backtrace";
        goto LABEL_173;
      }

      goto LABEL_174;
    }

    if (v49)
    {
      *buf = 136446466;
      v56 = "nw_http_decrypt_chunked_oblivious_request_header";
      v57 = 2082;
      v58 = backtrace_string;
      v39 = "%{public}s called with null (header_length == (hdr_length + enc_length)), dumping backtrace:%{public}s";
      goto LABEL_119;
    }

LABEL_120:
    free(backtrace_string);
    goto LABEL_174;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v14 = gLogObj;
  result = os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
  if (!result)
  {
    return result;
  }

  *buf = 136446210;
  v56 = "nw_http_decrypt_chunked_oblivious_request_header";
  _os_log_impl(&dword_181A37000, v14, OS_LOG_TYPE_ERROR, "%{public}s Media type exceeds max length", buf, 0xCu);
  return 0;
}

uint64_t nw_http_decrypt_chunked_oblivious_request_chunk(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, size_t *a8)
{
  v47 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v25 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v25, &type, &v39))
    {
      goto LABEL_127;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v39 != 1)
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          v24 = "%{public}s called with null request_buffer, backtrace limit exceeded";
          goto LABEL_126;
        }

        goto LABEL_127;
      }

      backtrace_string = __nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type;
      v30 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v30)
        {
          *buf = 136446210;
          v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          v24 = "%{public}s called with null request_buffer, no backtrace";
          goto LABEL_126;
        }

        goto LABEL_127;
      }

      if (!v30)
      {
        goto LABEL_93;
      }

      *buf = 136446466;
      v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      v43 = 2082;
      v44 = backtrace_string;
      v31 = "%{public}s called with null request_buffer, dumping backtrace:%{public}s";
      goto LABEL_92;
    }

    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
    {
      goto LABEL_127;
    }

    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v24 = "%{public}s called with null request_buffer";
LABEL_126:
    _os_log_impl(&dword_181A37000, v22, v23, v24, buf, 0xCu);
    goto LABEL_127;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v25 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v25, &type, &v39))
    {
      goto LABEL_127;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v39 != 1)
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          v24 = "%{public}s called with null request_length, backtrace limit exceeded";
          goto LABEL_126;
        }

        goto LABEL_127;
      }

      backtrace_string = __nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type;
      v32 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v32)
        {
          *buf = 136446210;
          v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          v24 = "%{public}s called with null request_length, no backtrace";
          goto LABEL_126;
        }

        goto LABEL_127;
      }

      if (!v32)
      {
        goto LABEL_93;
      }

      *buf = 136446466;
      v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      v43 = 2082;
      v44 = backtrace_string;
      v31 = "%{public}s called with null request_length, dumping backtrace:%{public}s";
      goto LABEL_92;
    }

    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
    {
      goto LABEL_127;
    }

    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v24 = "%{public}s called with null request_length";
    goto LABEL_126;
  }

  if (!a4)
  {
    __nwlog_obj();
    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v25 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v25, &type, &v39))
    {
      goto LABEL_127;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v39 != 1)
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          v24 = "%{public}s called with null request_context, backtrace limit exceeded";
          goto LABEL_126;
        }

        goto LABEL_127;
      }

      backtrace_string = __nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type;
      v33 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v33)
        {
          *buf = 136446210;
          v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          v24 = "%{public}s called with null request_context, no backtrace";
          goto LABEL_126;
        }

        goto LABEL_127;
      }

      if (!v33)
      {
        goto LABEL_93;
      }

      *buf = 136446466;
      v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      v43 = 2082;
      v44 = backtrace_string;
      v31 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
      goto LABEL_92;
    }

    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
    {
      goto LABEL_127;
    }

    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v24 = "%{public}s called with null request_context";
    goto LABEL_126;
  }

  if (!a5)
  {
    __nwlog_obj();
    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v25 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v25, &type, &v39))
    {
      goto LABEL_127;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v39 != 1)
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          v24 = "%{public}s called with null request_context_length, backtrace limit exceeded";
          goto LABEL_126;
        }

        goto LABEL_127;
      }

      backtrace_string = __nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type;
      v34 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v34)
        {
          *buf = 136446210;
          v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          v24 = "%{public}s called with null request_context_length, no backtrace";
          goto LABEL_126;
        }

        goto LABEL_127;
      }

      if (!v34)
      {
        goto LABEL_93;
      }

      *buf = 136446466;
      v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      v43 = 2082;
      v44 = backtrace_string;
      v31 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
      goto LABEL_92;
    }

    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
    {
      goto LABEL_127;
    }

    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v24 = "%{public}s called with null request_context_length";
    goto LABEL_126;
  }

  if (!a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v25 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v25, &type, &v39))
    {
      goto LABEL_127;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v39 != 1)
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          v24 = "%{public}s called with null request_enc, backtrace limit exceeded";
          goto LABEL_126;
        }

        goto LABEL_127;
      }

      backtrace_string = __nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type;
      v35 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v35)
        {
          *buf = 136446210;
          v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          v24 = "%{public}s called with null request_enc, no backtrace";
          goto LABEL_126;
        }

        goto LABEL_127;
      }

      if (!v35)
      {
        goto LABEL_93;
      }

      *buf = 136446466;
      v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      v43 = 2082;
      v44 = backtrace_string;
      v31 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
      goto LABEL_92;
    }

    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
    {
      goto LABEL_127;
    }

    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v24 = "%{public}s called with null request_enc";
    goto LABEL_126;
  }

  if (!a7)
  {
    __nwlog_obj();
    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v25 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v25, &type, &v39))
    {
      goto LABEL_127;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v39 != 1)
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          v24 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
          goto LABEL_126;
        }

        goto LABEL_127;
      }

      backtrace_string = __nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type;
      v36 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *buf = 136446210;
          v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
          v24 = "%{public}s called with null request_enc_length, no backtrace";
          goto LABEL_126;
        }

        goto LABEL_127;
      }

      if (!v36)
      {
        goto LABEL_93;
      }

      *buf = 136446466;
      v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      v43 = 2082;
      v44 = backtrace_string;
      v31 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
      goto LABEL_92;
    }

    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
    {
      goto LABEL_127;
    }

    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v24 = "%{public}s called with null request_enc_length";
    goto LABEL_126;
  }

  if (!a8)
  {
    __nwlog_obj();
    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v25 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v25, &type, &v39))
    {
      goto LABEL_127;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
      {
        goto LABEL_127;
      }

      *buf = 136446210;
      v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      v24 = "%{public}s called with null out_decrypted_length";
      goto LABEL_126;
    }

    if (v39 != 1)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *buf = 136446210;
        v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        v24 = "%{public}s called with null out_decrypted_length, backtrace limit exceeded";
        goto LABEL_126;
      }

      goto LABEL_127;
    }

    backtrace_string = __nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type;
    v37 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (v37)
      {
        *buf = 136446210;
        v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        v24 = "%{public}s called with null out_decrypted_length, no backtrace";
        goto LABEL_126;
      }

      goto LABEL_127;
    }

    if (!v37)
    {
      goto LABEL_93;
    }

    *buf = 136446466;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v43 = 2082;
    v44 = backtrace_string;
    v31 = "%{public}s called with null out_decrypted_length, dumping backtrace:%{public}s";
LABEL_92:
    _os_log_impl(&dword_181A37000, v22, v23, v31, buf, 0x16u);
    goto LABEL_93;
  }

  v11 = cchpke_params_sizeof_aead_tag();
  v12 = a2 > v11;
  v13 = a2 - v11;
  if (!v12)
  {
    __nwlog_obj();
    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v25 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v25, &type, &v39))
    {
      goto LABEL_127;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *buf = 136446210;
        v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        v24 = "%{public}s called with null (request_length > tag_length)";
        goto LABEL_126;
      }

LABEL_127:
      if (v25)
      {
        free(v25);
      }

      return 0;
    }

    if (v39 != 1)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *buf = 136446210;
        v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        v24 = "%{public}s called with null (request_length > tag_length), backtrace limit exceeded";
        goto LABEL_126;
      }

      goto LABEL_127;
    }

    backtrace_string = __nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type;
    v38 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (v38)
      {
        *buf = 136446210;
        v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        v24 = "%{public}s called with null (request_length > tag_length), no backtrace";
        goto LABEL_126;
      }

      goto LABEL_127;
    }

    if (v38)
    {
      *buf = 136446466;
      v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      v43 = 2082;
      v44 = backtrace_string;
      v31 = "%{public}s called with null (request_length > tag_length), dumping backtrace:%{public}s";
      goto LABEL_92;
    }

LABEL_93:
    free(backtrace_string);
    goto LABEL_127;
  }

  v14 = v11;
  if (!v11)
  {
    v27 = __nwlog_obj();
    os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v28 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v28);
    if (result)
    {
      goto LABEL_130;
    }

    free(v28);
  }

  v15 = malloc_type_calloc(1uLL, v14, 0x4B1E0410uLL);
  if (!v15)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
    v43 = 2048;
    v44 = 1;
    v45 = 2048;
    v46 = v14;
    v16 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v16);
    if (result)
    {
      goto LABEL_130;
    }

    free(v16);
  }

  memcpy(v15, (a1 + v13), v14);
  v18 = malloc_type_calloc(1uLL, v13, 0xE1E664D4uLL);
  if (v18)
  {
LABEL_17:
    v20 = cchpke_responder_decrypt();
    if (v15)
    {
      free(v15);
    }

    if (v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = gLogObj;
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446466;
        v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        v43 = 1024;
        LODWORD(v44) = v20;
        _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", buf, 0x12u);
      }

      if (v18)
      {
        free(v18);
        return 0;
      }
    }

    else
    {
      *a8 = v13;
    }

    return v18;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v42 = "nw_http_decrypt_chunked_oblivious_request_chunk";
  v43 = 2048;
  v44 = 1;
  v45 = 2048;
  v46 = v13;
  v19 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v19);
  if (!result)
  {
    free(v19);
    goto LABEL_17;
  }

LABEL_130:
  __break(1u);
  return result;
}

uint64_t nw_http_encrypt_oblivious_response(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, void *a6, size_t a7, void *a8)
{
  v99 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v44 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v77 = 0;
    if (!__nwlog_fault(v44, buf, &v77))
    {
      goto LABEL_187;
    }

    if (buf[0] != 17)
    {
      if (v77 != 1)
      {
        v45 = __nwlog_obj();
        v46 = buf[0];
        if (os_log_type_enabled(v45, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_encrypt_oblivious_response";
          v47 = "%{public}s called with null message_buffer, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v45 = __nwlog_obj();
      v46 = buf[0];
      v52 = os_log_type_enabled(v45, buf[0]);
      if (!backtrace_string)
      {
        if (v52)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_encrypt_oblivious_response";
          v47 = "%{public}s called with null message_buffer, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v52)
      {
        goto LABEL_145;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_encrypt_oblivious_response";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v53 = "%{public}s called with null message_buffer, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v45 = __nwlog_obj();
    v46 = buf[0];
    if (!os_log_type_enabled(v45, buf[0]))
    {
      goto LABEL_187;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v47 = "%{public}s called with null message_buffer";
LABEL_186:
    _os_log_impl(&dword_181A37000, v45, v46, v47, __str, 0xCu);
    goto LABEL_187;
  }

  v8 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v44 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v77 = 0;
    if (!__nwlog_fault(v44, buf, &v77))
    {
      goto LABEL_187;
    }

    if (buf[0] != 17)
    {
      if (v77 != 1)
      {
        v45 = __nwlog_obj();
        v46 = buf[0];
        if (os_log_type_enabled(v45, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_encrypt_oblivious_response";
          v47 = "%{public}s called with null message_length, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v45 = __nwlog_obj();
      v46 = buf[0];
      v54 = os_log_type_enabled(v45, buf[0]);
      if (!backtrace_string)
      {
        if (v54)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_encrypt_oblivious_response";
          v47 = "%{public}s called with null message_length, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v54)
      {
        goto LABEL_145;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_encrypt_oblivious_response";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v53 = "%{public}s called with null message_length, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v45 = __nwlog_obj();
    v46 = buf[0];
    if (!os_log_type_enabled(v45, buf[0]))
    {
      goto LABEL_187;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v47 = "%{public}s called with null message_length";
    goto LABEL_186;
  }

  if (!a3)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v44 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v77 = 0;
    if (!__nwlog_fault(v44, buf, &v77))
    {
      goto LABEL_187;
    }

    if (buf[0] != 17)
    {
      if (v77 != 1)
      {
        v45 = __nwlog_obj();
        v46 = buf[0];
        if (os_log_type_enabled(v45, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_encrypt_oblivious_response";
          v47 = "%{public}s called with null media_type, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v45 = __nwlog_obj();
      v46 = buf[0];
      v55 = os_log_type_enabled(v45, buf[0]);
      if (!backtrace_string)
      {
        if (v55)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_encrypt_oblivious_response";
          v47 = "%{public}s called with null media_type, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v55)
      {
        goto LABEL_145;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_encrypt_oblivious_response";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v53 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v45 = __nwlog_obj();
    v46 = buf[0];
    if (!os_log_type_enabled(v45, buf[0]))
    {
      goto LABEL_187;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v47 = "%{public}s called with null media_type";
    goto LABEL_186;
  }

  if (!a4)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v44 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v77 = 0;
    if (!__nwlog_fault(v44, buf, &v77))
    {
      goto LABEL_187;
    }

    if (buf[0] != 17)
    {
      if (v77 != 1)
      {
        v45 = __nwlog_obj();
        v46 = buf[0];
        if (os_log_type_enabled(v45, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_encrypt_oblivious_response";
          v47 = "%{public}s called with null request_context, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v45 = __nwlog_obj();
      v46 = buf[0];
      v56 = os_log_type_enabled(v45, buf[0]);
      if (!backtrace_string)
      {
        if (v56)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_encrypt_oblivious_response";
          v47 = "%{public}s called with null request_context, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v56)
      {
        goto LABEL_145;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_encrypt_oblivious_response";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v53 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v45 = __nwlog_obj();
    v46 = buf[0];
    if (!os_log_type_enabled(v45, buf[0]))
    {
      goto LABEL_187;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v47 = "%{public}s called with null request_context";
    goto LABEL_186;
  }

  if (!a5)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v44 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v77 = 0;
    if (!__nwlog_fault(v44, buf, &v77))
    {
      goto LABEL_187;
    }

    if (buf[0] != 17)
    {
      if (v77 != 1)
      {
        v45 = __nwlog_obj();
        v46 = buf[0];
        if (os_log_type_enabled(v45, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_encrypt_oblivious_response";
          v47 = "%{public}s called with null request_context_length, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v45 = __nwlog_obj();
      v46 = buf[0];
      v57 = os_log_type_enabled(v45, buf[0]);
      if (!backtrace_string)
      {
        if (v57)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_encrypt_oblivious_response";
          v47 = "%{public}s called with null request_context_length, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v57)
      {
        goto LABEL_145;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_encrypt_oblivious_response";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v53 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v45 = __nwlog_obj();
    v46 = buf[0];
    if (!os_log_type_enabled(v45, buf[0]))
    {
      goto LABEL_187;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v47 = "%{public}s called with null request_context_length";
    goto LABEL_186;
  }

  if (!a6)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v44 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v77 = 0;
    if (!__nwlog_fault(v44, buf, &v77))
    {
      goto LABEL_187;
    }

    if (buf[0] != 17)
    {
      if (v77 != 1)
      {
        v45 = __nwlog_obj();
        v46 = buf[0];
        if (os_log_type_enabled(v45, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_encrypt_oblivious_response";
          v47 = "%{public}s called with null request_enc, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v45 = __nwlog_obj();
      v46 = buf[0];
      v58 = os_log_type_enabled(v45, buf[0]);
      if (!backtrace_string)
      {
        if (v58)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_encrypt_oblivious_response";
          v47 = "%{public}s called with null request_enc, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v58)
      {
        goto LABEL_145;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_encrypt_oblivious_response";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v53 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

    v45 = __nwlog_obj();
    v46 = buf[0];
    if (!os_log_type_enabled(v45, buf[0]))
    {
      goto LABEL_187;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v47 = "%{public}s called with null request_enc";
    goto LABEL_186;
  }

  if (!a7)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v44 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v77 = 0;
    if (!__nwlog_fault(v44, buf, &v77))
    {
      goto LABEL_187;
    }

    if (buf[0] == 17)
    {
      v45 = __nwlog_obj();
      v46 = buf[0];
      if (!os_log_type_enabled(v45, buf[0]))
      {
        goto LABEL_187;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_oblivious_response";
      v47 = "%{public}s called with null request_enc_length";
      goto LABEL_186;
    }

    if (v77 != 1)
    {
      v45 = __nwlog_obj();
      v46 = buf[0];
      if (os_log_type_enabled(v45, buf[0]))
      {
        *__str = 136446210;
        *&__str[4] = "nw_http_encrypt_oblivious_response";
        v47 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
        goto LABEL_186;
      }

      goto LABEL_187;
    }

    backtrace_string = __nw_create_backtrace_string();
    v45 = __nwlog_obj();
    v46 = buf[0];
    v59 = os_log_type_enabled(v45, buf[0]);
    if (!backtrace_string)
    {
      if (v59)
      {
        *__str = 136446210;
        *&__str[4] = "nw_http_encrypt_oblivious_response";
        v47 = "%{public}s called with null request_enc_length, no backtrace";
        goto LABEL_186;
      }

      goto LABEL_187;
    }

    if (!v59)
    {
      goto LABEL_145;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v53 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
LABEL_144:
    _os_log_impl(&dword_181A37000, v45, v46, v53, __str, 0x16u);
    goto LABEL_145;
  }

  if (!a8)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v44 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v77 = 0;
    if (!__nwlog_fault(v44, buf, &v77))
    {
      goto LABEL_187;
    }

    if (buf[0] == 17)
    {
      v45 = __nwlog_obj();
      v46 = buf[0];
      if (os_log_type_enabled(v45, buf[0]))
      {
        *__str = 136446210;
        *&__str[4] = "nw_http_encrypt_oblivious_response";
        v47 = "%{public}s called with null out_encrypted_length";
        goto LABEL_186;
      }

LABEL_187:
      if (!v44)
      {
        return 0;
      }

      v21 = v44;
LABEL_74:
      free(v21);
      return 0;
    }

    if (v77 != 1)
    {
      v45 = __nwlog_obj();
      v46 = buf[0];
      if (os_log_type_enabled(v45, buf[0]))
      {
        *__str = 136446210;
        *&__str[4] = "nw_http_encrypt_oblivious_response";
        v47 = "%{public}s called with null out_encrypted_length, backtrace limit exceeded";
        goto LABEL_186;
      }

      goto LABEL_187;
    }

    backtrace_string = __nw_create_backtrace_string();
    v45 = __nwlog_obj();
    v46 = buf[0];
    v60 = os_log_type_enabled(v45, buf[0]);
    if (!backtrace_string)
    {
      if (v60)
      {
        *__str = 136446210;
        *&__str[4] = "nw_http_encrypt_oblivious_response";
        v47 = "%{public}s called with null out_encrypted_length, no backtrace";
        goto LABEL_186;
      }

      goto LABEL_187;
    }

    if (v60)
    {
      *__str = 136446466;
      *&__str[4] = "nw_http_encrypt_oblivious_response";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v53 = "%{public}s called with null out_encrypted_length, dumping backtrace:%{public}s";
      goto LABEL_144;
    }

LABEL_145:
    free(backtrace_string);
    goto LABEL_187;
  }

  v12 = cchpke_params_sizeof_aead_key();
  v13 = cchpke_params_sizeof_aead_nonce();
  v76 = cchpke_params_sizeof_aead_tag();
  v72 = v13;
  size = v12;
  if (v12 > v13)
  {
    v13 = v12;
  }

  if (!v13)
  {
    v48 = v8;
    v49 = __nwlog_obj();
    os_log_type_enabled(v49, OS_LOG_TYPE_ERROR);
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    v50 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v50);
    if (result)
    {
      goto LABEL_191;
    }

    free(v50);
    v8 = v48;
  }

  __src = a6;
  v14 = malloc_type_calloc(1uLL, v13, 0xE461CEBEuLL);
  if (!v14)
  {
    v15 = v8;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *__str = 136446722;
    *&__str[4] = "nw_http_encrypt_oblivious_response";
    *&__str[12] = 2048;
    *&__str[14] = 1;
    *&__str[22] = 2048;
    *&__str[24] = v13;
    v16 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v16);
    if (result)
    {
      goto LABEL_191;
    }

    free(v16);
    v8 = v15;
  }

  v97 = 0u;
  v98 = 0u;
  v95 = 0u;
  v96 = 0u;
  v93 = 0u;
  v94 = 0u;
  v91 = 0u;
  v92 = 0u;
  v89 = 0u;
  v90 = 0u;
  v87 = 0u;
  v88 = 0u;
  v85 = 0u;
  v86 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x100uLL, "%s response", a3);
  strlen(__str);
  v18 = cchpke_responder_export();
  if (v18)
  {
    v19 = v18;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v79 = "nw_http_encrypt_oblivious_response";
      v80 = 1024;
      LODWORD(v81) = v19;
      _os_log_impl(&dword_181A37000, v20, OS_LOG_TYPE_ERROR, "%{public}s Export error: %d", buf, 0x12u);
    }

    if (!v14)
    {
      return 0;
    }

    v21 = v14;
    goto LABEL_74;
  }

  if (!(v13 + v8 + v76))
  {
    v61 = __nwlog_obj();
    os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v79 = "nw_http_encrypt_oblivious_response";
    v62 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v62);
    if (result)
    {
      goto LABEL_191;
    }

    free(v62);
  }

  v22 = malloc_type_calloc(1uLL, v13 + v8 + v76, 0x3022142AuLL);
  if (!v22)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v79 = "nw_http_encrypt_oblivious_response";
    v80 = 2048;
    v81 = 1;
    v82 = 2048;
    v83 = v13 + v8 + v76;
    v23 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v23);
    if (result)
    {
      goto LABEL_191;
    }

    free(v23);
  }

  arc4random_buf(v22, v13);
  if (!(v13 + a7))
  {
    v63 = __nwlog_obj();
    os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v79 = "nw_http_encrypt_oblivious_response";
    v64 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v64);
    if (result)
    {
      goto LABEL_191;
    }

    free(v64);
  }

  v24 = malloc_type_calloc(1uLL, v13 + a7, 0xBA42A2E7uLL);
  if (!v24)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v79 = "nw_http_encrypt_oblivious_response";
    v80 = 2048;
    v81 = 1;
    v82 = 2048;
    v83 = v13 + a7;
    v25 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v25);
    if (result)
    {
      goto LABEL_191;
    }

    free(v25);
  }

  memcpy(v24, __src, a7);
  memcpy(&v24[a7], v22, v13);
  v26 = cchpke_params_sizeof_kdf_hash();
  if (!v26)
  {
    v65 = __nwlog_obj();
    os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v79 = "nw_http_encrypt_oblivious_response";
    v66 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v66);
    if (result)
    {
      goto LABEL_191;
    }

    free(v66);
  }

  __srca = (v13 + v8 + v76);
  v27 = malloc_type_calloc(1uLL, v26, 0x5A19580EuLL);
  if (!v27)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v79 = "nw_http_encrypt_oblivious_response";
    v80 = 2048;
    v81 = 1;
    v82 = 2048;
    v83 = v26;
    v28 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v28);
    if (result)
    {
      goto LABEL_191;
    }

    free(v28);
  }

  ccsha256_di();
  v29 = cchkdf_extract();
  if (v24)
  {
    free(v24);
  }

  if (v14)
  {
    free(v14);
  }

  if (v29)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v30 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v79 = "nw_http_encrypt_oblivious_response";
      v80 = 1024;
      LODWORD(v81) = v29;
      _os_log_impl(&dword_181A37000, v30, OS_LOG_TYPE_ERROR, "%{public}s Extract error: %d", buf, 0x12u);
    }

    if (v27)
    {
      free(v27);
    }

LABEL_72:
    if (!v22)
    {
      return v22;
    }

    v21 = v22;
    goto LABEL_74;
  }

  if (!size)
  {
    v67 = __nwlog_obj();
    os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v79 = "nw_http_encrypt_oblivious_response";
    v68 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v68);
    if (result)
    {
      goto LABEL_191;
    }

    free(v68);
  }

  v31 = malloc_type_calloc(1uLL, size, 0x46C43DF0uLL);
  if (!v31)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v79 = "nw_http_encrypt_oblivious_response";
    v80 = 2048;
    v81 = 1;
    v82 = 2048;
    v83 = size;
    v32 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v32);
    if (result)
    {
      goto LABEL_191;
    }

    free(v32);
  }

  v33 = cchkdf_expand();
  if (v33)
  {
    v34 = v33;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v35 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v79 = "nw_http_encrypt_oblivious_response";
      v80 = 1024;
      LODWORD(v81) = v34;
      _os_log_impl(&dword_181A37000, v35, OS_LOG_TYPE_ERROR, "%{public}s Key expand error: %d", buf, 0x12u);
    }

    if (v27)
    {
      free(v27);
    }

    if (v31)
    {
      free(v31);
    }

    goto LABEL_72;
  }

  v36 = v72;
  if (!v72)
  {
    v69 = __nwlog_obj();
    os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v79 = "nw_http_encrypt_oblivious_response";
    v70 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v70);
    if (result)
    {
      goto LABEL_191;
    }

    free(v70);
    v36 = 0;
  }

  v37 = malloc_type_calloc(1uLL, v36, 0xEE9A7367uLL);
  if (v37)
  {
    goto LABEL_56;
  }

  v38 = __nwlog_obj();
  os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v79 = "nw_http_encrypt_oblivious_response";
  v80 = 2048;
  v81 = 1;
  v82 = 2048;
  v83 = v36;
  v39 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v39);
  if (!result)
  {
    free(v39);
LABEL_56:
    v40 = cchkdf_expand();
    if (v27)
    {
      free(v27);
    }

    if (v40)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v41 = gLogObj;
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446466;
        v79 = "nw_http_encrypt_oblivious_response";
        v80 = 1024;
        LODWORD(v81) = v40;
        _os_log_impl(&dword_181A37000, v41, OS_LOG_TYPE_ERROR, "%{public}s Nonce expand error: %d", buf, 0x12u);
      }

      if (v31)
      {
        free(v31);
      }

      if (v37)
      {
        free(v37);
      }
    }

    else
    {
      ccaes_gcm_encrypt_mode();
      v42 = ccgcm_one_shot();
      if (v31)
      {
        free(v31);
      }

      if (v37)
      {
        free(v37);
      }

      if (!v42)
      {
        *a8 = __srca;
        return v22;
      }

      v43 = __nwlog_obj();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446466;
        v79 = "nw_http_encrypt_oblivious_response";
        v80 = 1024;
        LODWORD(v81) = v42;
        _os_log_impl(&dword_181A37000, v43, OS_LOG_TYPE_ERROR, "%{public}s Encrypt error: %d", buf, 0x12u);
      }
    }

    goto LABEL_72;
  }

LABEL_191:
  __break(1u);
  return result;
}

uint64_t nw_http_generate_chunked_oblivious_response_nonce(size_t *a1)
{
  v24 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v19 = "nw_http_generate_chunked_oblivious_response_nonce";
    v8 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v19 = "nw_http_generate_chunked_oblivious_response_nonce";
          v11 = "%{public}s called with null out_nonce_length";
LABEL_26:
          _os_log_impl(&dword_181A37000, v9, v10, v11, buf, 0xCu);
        }
      }

      else if (v16 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v9 = __nwlog_obj();
        v10 = type;
        v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *buf = 136446466;
            v19 = "nw_http_generate_chunked_oblivious_response_nonce";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null out_nonce_length, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }

        if (v15)
        {
          *buf = 136446210;
          v19 = "nw_http_generate_chunked_oblivious_response_nonce";
          v11 = "%{public}s called with null out_nonce_length, no backtrace";
          goto LABEL_26;
        }
      }

      else
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v19 = "nw_http_generate_chunked_oblivious_response_nonce";
          v11 = "%{public}s called with null out_nonce_length, backtrace limit exceeded";
          goto LABEL_26;
        }
      }
    }

LABEL_27:
    if (v8)
    {
      free(v8);
    }

    return 0;
  }

  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  v2 = cchpke_params_sizeof_aead_key();
  v3 = cchpke_params_sizeof_aead_nonce();
  if (v2 <= v3)
  {
    v4 = v3;
  }

  else
  {
    v4 = v2;
  }

  if (!v4)
  {
    v12 = __nwlog_obj();
    os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v19 = "nw_http_generate_chunked_oblivious_response_nonce";
    v13 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v13);
    if (result)
    {
      goto LABEL_30;
    }

    free(v13);
  }

  v5 = malloc_type_calloc(1uLL, v4, 0xF0F9B309uLL);
  if (v5)
  {
LABEL_9:
    arc4random_buf(v5, v4);
    *a1 = v4;
    return v5;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v19 = "nw_http_generate_chunked_oblivious_response_nonce";
  v20 = 2048;
  v21 = 1;
  v22 = 2048;
  v23 = v4;
  v6 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v6);
  if (!result)
  {
    free(v6);
    goto LABEL_9;
  }

LABEL_30:
  __break(1u);
  return result;
}

unint64_t nw_http_get_chunked_oblivious_response_nonce_length()
{
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  v0 = cchpke_params_sizeof_aead_key();
  result = cchpke_params_sizeof_aead_nonce();
  if (v0 > result)
  {
    return v0;
  }

  return result;
}

uint64_t nw_http_calculate_chunked_oblivious_response_aead_nonce(const char *a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5, const void *a6, size_t a7, size_t *a8)
{
  v79 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null media_type, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v39 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v39)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null media_type, no backtrace";
        goto LABEL_166;
      }

      if (!v39)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v37 = "%{public}s called with null media_type";
LABEL_166:
    _os_log_impl(&dword_181A37000, v35, v36, v37, __str, 0xCu);
    goto LABEL_167;
  }

  if (!a2)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null request_context, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v41 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v41)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null request_context, no backtrace";
        goto LABEL_166;
      }

      if (!v41)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v37 = "%{public}s called with null request_context";
    goto LABEL_166;
  }

  if (!a3)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null request_context_length, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v42 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v42)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null request_context_length, no backtrace";
        goto LABEL_166;
      }

      if (!v42)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v37 = "%{public}s called with null request_context_length";
    goto LABEL_166;
  }

  if (!a4)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null request_enc, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v43 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v43)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null request_enc, no backtrace";
        goto LABEL_166;
      }

      if (!v43)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v37 = "%{public}s called with null request_enc";
    goto LABEL_166;
  }

  if (!a5)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v44 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v44)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null request_enc_length, no backtrace";
        goto LABEL_166;
      }

      if (!v44)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v37 = "%{public}s called with null request_enc_length";
    goto LABEL_166;
  }

  if (!a6)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null response_nonce, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v45 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v45)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null response_nonce, no backtrace";
        goto LABEL_166;
      }

      if (!v45)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null response_nonce, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v37 = "%{public}s called with null response_nonce";
    goto LABEL_166;
  }

  if (!a7)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null response_nonce_length, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v46 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v46)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v37 = "%{public}s called with null response_nonce_length, no backtrace";
        goto LABEL_166;
      }

      if (!v46)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null response_nonce_length, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v37 = "%{public}s called with null response_nonce_length";
    goto LABEL_166;
  }

  if (!a8)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] == 17)
    {
      v35 = __nwlog_obj();
      v36 = buf[0];
      if (!os_log_type_enabled(v35, buf[0]))
      {
        goto LABEL_167;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      v37 = "%{public}s called with null out_aead_nonce_length";
      goto LABEL_166;
    }

    if (v57 != 1)
    {
      v35 = __nwlog_obj();
      v36 = buf[0];
      if (!os_log_type_enabled(v35, buf[0]))
      {
        goto LABEL_167;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      v37 = "%{public}s called with null out_aead_nonce_length, backtrace limit exceeded";
      goto LABEL_166;
    }

    backtrace_string = __nw_create_backtrace_string();
    v35 = __nwlog_obj();
    v36 = buf[0];
    v47 = os_log_type_enabled(v35, buf[0]);
    if (!backtrace_string)
    {
      if (!v47)
      {
        goto LABEL_167;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      v37 = "%{public}s called with null out_aead_nonce_length, no backtrace";
      goto LABEL_166;
    }

    if (!v47)
    {
      goto LABEL_123;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v40 = "%{public}s called with null out_aead_nonce_length, dumping backtrace:%{public}s";
LABEL_122:
    _os_log_impl(&dword_181A37000, v35, v36, v40, __str, 0x16u);
    goto LABEL_123;
  }

  v14 = cchpke_params_sizeof_aead_key();
  v15 = cchpke_params_sizeof_aead_nonce();
  size = v15;
  if (v14 <= v15)
  {
    v16 = v15;
  }

  else
  {
    v16 = v14;
  }

  if (v16 == a7)
  {
    v55 = a8;
    v17 = malloc_type_calloc(1uLL, a7, 0xCA26D3BEuLL);
    if (!v17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
      *__str = 136446722;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      *&__str[12] = 2048;
      *&__str[14] = 1;
      *&__str[22] = 2048;
      *&__str[24] = a7;
      v18 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v18);
      if (result)
      {
        goto LABEL_171;
      }

      free(v18);
    }

    v77 = 0u;
    v78 = 0u;
    v75 = 0u;
    v76 = 0u;
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    v65 = 0u;
    v66 = 0u;
    memset(__str, 0, sizeof(__str));
    snprintf(__str, 0x100uLL, "%s chunked response", a1);
    strlen(__str);
    v20 = cchpke_responder_export();
    if (v20)
    {
      v21 = v20;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      if (!os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        goto LABEL_20;
      }

      *buf = 136446466;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      v60 = 1024;
      LODWORD(v61) = v21;
      v23 = "%{public}s Export error: %d";
LABEL_19:
      _os_log_impl(&dword_181A37000, v22, OS_LOG_TYPE_ERROR, v23, buf, 0x12u);
LABEL_20:
      if (v17)
      {
        v24 = v17;
LABEL_39:
        free(v24);
        return 0;
      }

      return 0;
    }

    if (!(a7 + a5))
    {
      v49 = __nwlog_obj();
      os_log_type_enabled(v49, OS_LOG_TYPE_ERROR);
      *buf = 136446210;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      v50 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v50);
      if (result)
      {
        goto LABEL_171;
      }

      free(v50);
    }

    v25 = malloc_type_calloc(1uLL, a7 + a5, 0x75DCAC43uLL);
    if (!v25)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
      *buf = 136446722;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      v60 = 2048;
      v61 = 1;
      v62 = 2048;
      v63 = a7 + a5;
      v26 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v26);
      if (result)
      {
        goto LABEL_171;
      }

      free(v26);
    }

    memcpy(v25, a4, a5);
    memcpy(&v25[a5], a6, a7);
    v27 = cchpke_params_sizeof_kdf_hash();
    if (!v27)
    {
      v51 = __nwlog_obj();
      os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
      *buf = 136446210;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      v52 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v52);
      if (result)
      {
        goto LABEL_171;
      }

      free(v52);
    }

    v28 = malloc_type_calloc(1uLL, v27, 0x46BE6938uLL);
    if (!v28)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
      *buf = 136446722;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      v60 = 2048;
      v61 = 1;
      v62 = 2048;
      v63 = v27;
      v29 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v29);
      if (result)
      {
        goto LABEL_171;
      }

      free(v29);
    }

    ccsha256_di();
    v30 = cchkdf_extract();
    if (v25)
    {
      free(v25);
    }

    if (v17)
    {
      free(v17);
    }

    if (v30)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = gLogObj;
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446466;
        v59 = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
        v60 = 1024;
        LODWORD(v61) = v30;
        _os_log_impl(&dword_181A37000, v31, OS_LOG_TYPE_ERROR, "%{public}s Extract error: %d", buf, 0x12u);
      }

      if (v28)
      {
        v24 = v28;
        goto LABEL_39;
      }

      return 0;
    }

    if (!size)
    {
      v53 = __nwlog_obj();
      os_log_type_enabled(v53, OS_LOG_TYPE_ERROR);
      *buf = 136446210;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      v54 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v54);
      if (result)
      {
        goto LABEL_171;
      }

      free(v54);
    }

    v17 = malloc_type_calloc(1uLL, size, 0x5CE56F02uLL);
    if (v17)
    {
LABEL_44:
      v33 = cchkdf_expand();
      if (v28)
      {
        free(v28);
      }

      if (!v33)
      {
        *v55 = size;
        return v17;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      if (!os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        goto LABEL_20;
      }

      *buf = 136446466;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      v60 = 1024;
      LODWORD(v61) = v33;
      v23 = "%{public}s Nonce expand error: %d";
      goto LABEL_19;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v59 = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
    v60 = 2048;
    v61 = 1;
    v62 = 2048;
    v63 = size;
    v32 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v32);
    if (!result)
    {
      free(v32);
      goto LABEL_44;
    }

LABEL_171:
    __break(1u);
    return result;
  }

  __nwlog_obj();
  *__str = 136446210;
  *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
  v34 = _os_log_send_and_compose_impl();
  buf[0] = 16;
  v57 = 0;
  if (__nwlog_fault(v34, buf, &v57))
  {
    if (buf[0] == 17)
    {
      v35 = __nwlog_obj();
      v36 = buf[0];
      if (!os_log_type_enabled(v35, buf[0]))
      {
        goto LABEL_167;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      v37 = "%{public}s called with null (exported_secret_length == response_nonce_length)";
      goto LABEL_166;
    }

    if (v57 != 1)
    {
      v35 = __nwlog_obj();
      v36 = buf[0];
      if (!os_log_type_enabled(v35, buf[0]))
      {
        goto LABEL_167;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      v37 = "%{public}s called with null (exported_secret_length == response_nonce_length), backtrace limit exceeded";
      goto LABEL_166;
    }

    backtrace_string = __nw_create_backtrace_string();
    v35 = __nwlog_obj();
    v36 = buf[0];
    v48 = os_log_type_enabled(v35, buf[0]);
    if (!backtrace_string)
    {
      if (!v48)
      {
        goto LABEL_167;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      v37 = "%{public}s called with null (exported_secret_length == response_nonce_length), no backtrace";
      goto LABEL_166;
    }

    if (v48)
    {
      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_nonce";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null (exported_secret_length == response_nonce_length), dumping backtrace:%{public}s";
      goto LABEL_122;
    }

LABEL_123:
    free(backtrace_string);
  }

LABEL_167:
  if (v34)
  {
    free(v34);
  }

  return 0;
}

uint64_t nw_http_calculate_chunked_oblivious_response_aead_key(const char *a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5, const void *a6, size_t a7, size_t *a8)
{
  v79 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null media_type, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v39 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v39)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null media_type, no backtrace";
        goto LABEL_166;
      }

      if (!v39)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v37 = "%{public}s called with null media_type";
LABEL_166:
    _os_log_impl(&dword_181A37000, v35, v36, v37, __str, 0xCu);
    goto LABEL_167;
  }

  if (!a2)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null request_context, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v41 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v41)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null request_context, no backtrace";
        goto LABEL_166;
      }

      if (!v41)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v37 = "%{public}s called with null request_context";
    goto LABEL_166;
  }

  if (!a3)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null request_context_length, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v42 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v42)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null request_context_length, no backtrace";
        goto LABEL_166;
      }

      if (!v42)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v37 = "%{public}s called with null request_context_length";
    goto LABEL_166;
  }

  if (!a4)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null request_enc, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v43 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v43)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null request_enc, no backtrace";
        goto LABEL_166;
      }

      if (!v43)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v37 = "%{public}s called with null request_enc";
    goto LABEL_166;
  }

  if (!a5)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v44 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v44)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null request_enc_length, no backtrace";
        goto LABEL_166;
      }

      if (!v44)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v37 = "%{public}s called with null request_enc_length";
    goto LABEL_166;
  }

  if (!a6)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null response_nonce, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v45 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v45)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null response_nonce, no backtrace";
        goto LABEL_166;
      }

      if (!v45)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null response_nonce, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v37 = "%{public}s called with null response_nonce";
    goto LABEL_166;
  }

  if (!a7)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] != 17)
    {
      if (v57 != 1)
      {
        v35 = __nwlog_obj();
        v36 = buf[0];
        if (!os_log_type_enabled(v35, buf[0]))
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null response_nonce_length, backtrace limit exceeded";
        goto LABEL_166;
      }

      backtrace_string = __nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = buf[0];
      v46 = os_log_type_enabled(v35, buf[0]);
      if (!backtrace_string)
      {
        if (!v46)
        {
          goto LABEL_167;
        }

        *__str = 136446210;
        *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v37 = "%{public}s called with null response_nonce_length, no backtrace";
        goto LABEL_166;
      }

      if (!v46)
      {
        goto LABEL_123;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null response_nonce_length, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    v35 = __nwlog_obj();
    v36 = buf[0];
    if (!os_log_type_enabled(v35, buf[0]))
    {
      goto LABEL_167;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v37 = "%{public}s called with null response_nonce_length";
    goto LABEL_166;
  }

  if (!a8)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v34 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v57 = 0;
    if (!__nwlog_fault(v34, buf, &v57))
    {
      goto LABEL_167;
    }

    if (buf[0] == 17)
    {
      v35 = __nwlog_obj();
      v36 = buf[0];
      if (!os_log_type_enabled(v35, buf[0]))
      {
        goto LABEL_167;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      v37 = "%{public}s called with null out_aead_key_length";
      goto LABEL_166;
    }

    if (v57 != 1)
    {
      v35 = __nwlog_obj();
      v36 = buf[0];
      if (!os_log_type_enabled(v35, buf[0]))
      {
        goto LABEL_167;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      v37 = "%{public}s called with null out_aead_key_length, backtrace limit exceeded";
      goto LABEL_166;
    }

    backtrace_string = __nw_create_backtrace_string();
    v35 = __nwlog_obj();
    v36 = buf[0];
    v47 = os_log_type_enabled(v35, buf[0]);
    if (!backtrace_string)
    {
      if (!v47)
      {
        goto LABEL_167;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      v37 = "%{public}s called with null out_aead_key_length, no backtrace";
      goto LABEL_166;
    }

    if (!v47)
    {
      goto LABEL_123;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v40 = "%{public}s called with null out_aead_key_length, dumping backtrace:%{public}s";
LABEL_122:
    _os_log_impl(&dword_181A37000, v35, v36, v40, __str, 0x16u);
    goto LABEL_123;
  }

  v14 = cchpke_params_sizeof_aead_key();
  v15 = cchpke_params_sizeof_aead_nonce();
  size = v14;
  if (v14 <= v15)
  {
    v16 = v15;
  }

  else
  {
    v16 = v14;
  }

  if (v16 == a7)
  {
    v55 = a8;
    v17 = malloc_type_calloc(1uLL, a7, 0xC0A6427BuLL);
    if (!v17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
      *__str = 136446722;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      *&__str[12] = 2048;
      *&__str[14] = 1;
      *&__str[22] = 2048;
      *&__str[24] = a7;
      v18 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v18);
      if (result)
      {
        goto LABEL_171;
      }

      free(v18);
    }

    v77 = 0u;
    v78 = 0u;
    v75 = 0u;
    v76 = 0u;
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    v65 = 0u;
    v66 = 0u;
    memset(__str, 0, sizeof(__str));
    snprintf(__str, 0x100uLL, "%s chunked response", a1);
    strlen(__str);
    v20 = cchpke_responder_export();
    if (v20)
    {
      v21 = v20;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      if (!os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        goto LABEL_20;
      }

      *buf = 136446466;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_key";
      v60 = 1024;
      LODWORD(v61) = v21;
      v23 = "%{public}s Export error: %d";
LABEL_19:
      _os_log_impl(&dword_181A37000, v22, OS_LOG_TYPE_ERROR, v23, buf, 0x12u);
LABEL_20:
      if (v17)
      {
        v24 = v17;
LABEL_39:
        free(v24);
        return 0;
      }

      return 0;
    }

    if (!(a7 + a5))
    {
      v49 = __nwlog_obj();
      os_log_type_enabled(v49, OS_LOG_TYPE_ERROR);
      *buf = 136446210;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_key";
      v50 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v50);
      if (result)
      {
        goto LABEL_171;
      }

      free(v50);
    }

    v25 = malloc_type_calloc(1uLL, a7 + a5, 0x905BAF72uLL);
    if (!v25)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
      *buf = 136446722;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_key";
      v60 = 2048;
      v61 = 1;
      v62 = 2048;
      v63 = a7 + a5;
      v26 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v26);
      if (result)
      {
        goto LABEL_171;
      }

      free(v26);
    }

    memcpy(v25, a4, a5);
    memcpy(&v25[a5], a6, a7);
    v27 = cchpke_params_sizeof_kdf_hash();
    if (!v27)
    {
      v51 = __nwlog_obj();
      os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
      *buf = 136446210;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_key";
      v52 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v52);
      if (result)
      {
        goto LABEL_171;
      }

      free(v52);
    }

    v28 = malloc_type_calloc(1uLL, v27, 0x6256EE70uLL);
    if (!v28)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
      *buf = 136446722;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_key";
      v60 = 2048;
      v61 = 1;
      v62 = 2048;
      v63 = v27;
      v29 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v29);
      if (result)
      {
        goto LABEL_171;
      }

      free(v29);
    }

    ccsha256_di();
    v30 = cchkdf_extract();
    if (v25)
    {
      free(v25);
    }

    if (v17)
    {
      free(v17);
    }

    if (v30)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = gLogObj;
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446466;
        v59 = "nw_http_calculate_chunked_oblivious_response_aead_key";
        v60 = 1024;
        LODWORD(v61) = v30;
        _os_log_impl(&dword_181A37000, v31, OS_LOG_TYPE_ERROR, "%{public}s Extract error: %d", buf, 0x12u);
      }

      if (v28)
      {
        v24 = v28;
        goto LABEL_39;
      }

      return 0;
    }

    if (!size)
    {
      v53 = __nwlog_obj();
      os_log_type_enabled(v53, OS_LOG_TYPE_ERROR);
      *buf = 136446210;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_key";
      v54 = _os_log_send_and_compose_impl();
      result = __nwlog_should_abort(v54);
      if (result)
      {
        goto LABEL_171;
      }

      free(v54);
    }

    v17 = malloc_type_calloc(1uLL, size, 0x35A30262uLL);
    if (v17)
    {
LABEL_44:
      v33 = cchkdf_expand();
      if (v28)
      {
        free(v28);
      }

      if (!v33)
      {
        *v55 = size;
        return v17;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      if (!os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        goto LABEL_20;
      }

      *buf = 136446466;
      v59 = "nw_http_calculate_chunked_oblivious_response_aead_key";
      v60 = 1024;
      LODWORD(v61) = v33;
      v23 = "%{public}s Key expand error: %d";
      goto LABEL_19;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v59 = "nw_http_calculate_chunked_oblivious_response_aead_key";
    v60 = 2048;
    v61 = 1;
    v62 = 2048;
    v63 = size;
    v32 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v32);
    if (!result)
    {
      free(v32);
      goto LABEL_44;
    }

LABEL_171:
    __break(1u);
    return result;
  }

  __nwlog_obj();
  *__str = 136446210;
  *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
  v34 = _os_log_send_and_compose_impl();
  buf[0] = 16;
  v57 = 0;
  if (__nwlog_fault(v34, buf, &v57))
  {
    if (buf[0] == 17)
    {
      v35 = __nwlog_obj();
      v36 = buf[0];
      if (!os_log_type_enabled(v35, buf[0]))
      {
        goto LABEL_167;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      v37 = "%{public}s called with null (exported_secret_length == response_nonce_length)";
      goto LABEL_166;
    }

    if (v57 != 1)
    {
      v35 = __nwlog_obj();
      v36 = buf[0];
      if (!os_log_type_enabled(v35, buf[0]))
      {
        goto LABEL_167;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      v37 = "%{public}s called with null (exported_secret_length == response_nonce_length), backtrace limit exceeded";
      goto LABEL_166;
    }

    backtrace_string = __nw_create_backtrace_string();
    v35 = __nwlog_obj();
    v36 = buf[0];
    v48 = os_log_type_enabled(v35, buf[0]);
    if (!backtrace_string)
    {
      if (!v48)
      {
        goto LABEL_167;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      v37 = "%{public}s called with null (exported_secret_length == response_nonce_length), no backtrace";
      goto LABEL_166;
    }

    if (v48)
    {
      *__str = 136446466;
      *&__str[4] = "nw_http_calculate_chunked_oblivious_response_aead_key";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v40 = "%{public}s called with null (exported_secret_length == response_nonce_length), dumping backtrace:%{public}s";
      goto LABEL_122;
    }

LABEL_123:
    free(backtrace_string);
  }

LABEL_167:
  if (v34)
  {
    free(v34);
  }

  return 0;
}

void *nw_http_encrypt_chunked_oblivious_response_chunk(uint64_t a1, uint64_t a2, const char *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const void *a8, size_t a9, const void *a10, size_t a11, size_t *a12)
{
  v106 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v51 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v84 = 0;
    if (!__nwlog_fault(v51, buf, &v84))
    {
      goto LABEL_223;
    }

    if (buf[0] == 17)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null message_buffer";
      goto LABEL_222;
    }

    if (v84 != 1)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null message_buffer, backtrace limit exceeded";
      goto LABEL_222;
    }

    backtrace_string = __nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = buf[0];
    v56 = os_log_type_enabled(v52, buf[0]);
    if (!backtrace_string)
    {
      if (!v56)
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null message_buffer, no backtrace";
      goto LABEL_222;
    }

    if (!v56)
    {
      goto LABEL_171;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null message_buffer, dumping backtrace:%{public}s";
LABEL_170:
    _os_log_impl(&dword_181A37000, v52, v53, v57, __str, 0x16u);
    goto LABEL_171;
  }

  if (!a2)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v51 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v84 = 0;
    if (!__nwlog_fault(v51, buf, &v84))
    {
      goto LABEL_223;
    }

    if (buf[0] == 17)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null message_length";
      goto LABEL_222;
    }

    if (v84 != 1)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null message_length, backtrace limit exceeded";
      goto LABEL_222;
    }

    backtrace_string = __nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = buf[0];
    v58 = os_log_type_enabled(v52, buf[0]);
    if (!backtrace_string)
    {
      if (!v58)
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null message_length, no backtrace";
      goto LABEL_222;
    }

    if (!v58)
    {
      goto LABEL_171;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null message_length, dumping backtrace:%{public}s";
    goto LABEL_170;
  }

  if (!a3)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v51 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v84 = 0;
    if (!__nwlog_fault(v51, buf, &v84))
    {
      goto LABEL_223;
    }

    if (buf[0] == 17)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null media_type";
      goto LABEL_222;
    }

    if (v84 != 1)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null media_type, backtrace limit exceeded";
      goto LABEL_222;
    }

    backtrace_string = __nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = buf[0];
    v59 = os_log_type_enabled(v52, buf[0]);
    if (!backtrace_string)
    {
      if (!v59)
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null media_type, no backtrace";
      goto LABEL_222;
    }

    if (!v59)
    {
      goto LABEL_171;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
    goto LABEL_170;
  }

  if (!a6)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v51 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v84 = 0;
    if (!__nwlog_fault(v51, buf, &v84))
    {
      goto LABEL_223;
    }

    if (buf[0] == 17)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null request_context";
      goto LABEL_222;
    }

    if (v84 != 1)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null request_context, backtrace limit exceeded";
      goto LABEL_222;
    }

    backtrace_string = __nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = buf[0];
    v60 = os_log_type_enabled(v52, buf[0]);
    if (!backtrace_string)
    {
      if (!v60)
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null request_context, no backtrace";
      goto LABEL_222;
    }

    if (!v60)
    {
      goto LABEL_171;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
    goto LABEL_170;
  }

  if (!a7)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v51 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v84 = 0;
    if (!__nwlog_fault(v51, buf, &v84))
    {
      goto LABEL_223;
    }

    if (buf[0] == 17)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null request_context_length";
      goto LABEL_222;
    }

    if (v84 != 1)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null request_context_length, backtrace limit exceeded";
      goto LABEL_222;
    }

    backtrace_string = __nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = buf[0];
    v61 = os_log_type_enabled(v52, buf[0]);
    if (!backtrace_string)
    {
      if (!v61)
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null request_context_length, no backtrace";
      goto LABEL_222;
    }

    if (!v61)
    {
      goto LABEL_171;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
    goto LABEL_170;
  }

  if (!a8)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v51 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v84 = 0;
    if (!__nwlog_fault(v51, buf, &v84))
    {
      goto LABEL_223;
    }

    if (buf[0] == 17)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null request_enc";
      goto LABEL_222;
    }

    if (v84 != 1)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null request_enc, backtrace limit exceeded";
      goto LABEL_222;
    }

    backtrace_string = __nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = buf[0];
    v62 = os_log_type_enabled(v52, buf[0]);
    if (!backtrace_string)
    {
      if (!v62)
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null request_enc, no backtrace";
      goto LABEL_222;
    }

    if (!v62)
    {
      goto LABEL_171;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
    goto LABEL_170;
  }

  if (!a9)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v51 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v84 = 0;
    if (!__nwlog_fault(v51, buf, &v84))
    {
      goto LABEL_223;
    }

    if (buf[0] == 17)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null request_enc_length";
      goto LABEL_222;
    }

    if (v84 != 1)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
      goto LABEL_222;
    }

    backtrace_string = __nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = buf[0];
    v63 = os_log_type_enabled(v52, buf[0]);
    if (!backtrace_string)
    {
      if (!v63)
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null request_enc_length, no backtrace";
      goto LABEL_222;
    }

    if (!v63)
    {
      goto LABEL_171;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
    goto LABEL_170;
  }

  if (!a10)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v51 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v84 = 0;
    if (!__nwlog_fault(v51, buf, &v84))
    {
      goto LABEL_223;
    }

    if (buf[0] == 17)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null response_nonce";
      goto LABEL_222;
    }

    if (v84 != 1)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null response_nonce, backtrace limit exceeded";
      goto LABEL_222;
    }

    backtrace_string = __nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = buf[0];
    v64 = os_log_type_enabled(v52, buf[0]);
    if (!backtrace_string)
    {
      if (!v64)
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null response_nonce, no backtrace";
      goto LABEL_222;
    }

    if (!v64)
    {
      goto LABEL_171;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null response_nonce, dumping backtrace:%{public}s";
    goto LABEL_170;
  }

  if (!a11)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v51 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v84 = 0;
    if (!__nwlog_fault(v51, buf, &v84))
    {
      goto LABEL_223;
    }

    if (buf[0] == 17)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null response_nonce_length";
      goto LABEL_222;
    }

    if (v84 != 1)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null response_nonce_length, backtrace limit exceeded";
      goto LABEL_222;
    }

    backtrace_string = __nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = buf[0];
    v65 = os_log_type_enabled(v52, buf[0]);
    if (!backtrace_string)
    {
      if (!v65)
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null response_nonce_length, no backtrace";
      goto LABEL_222;
    }

    if (!v65)
    {
      goto LABEL_171;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null response_nonce_length, dumping backtrace:%{public}s";
    goto LABEL_170;
  }

  if (!a12)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v51 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v84 = 0;
    if (!__nwlog_fault(v51, buf, &v84))
    {
      goto LABEL_223;
    }

    if (buf[0] == 17)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null out_encrypted_length";
      goto LABEL_222;
    }

    if (v84 != 1)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null out_encrypted_length, backtrace limit exceeded";
      goto LABEL_222;
    }

    backtrace_string = __nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = buf[0];
    v66 = os_log_type_enabled(v52, buf[0]);
    if (!backtrace_string)
    {
      if (!v66)
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null out_encrypted_length, no backtrace";
      goto LABEL_222;
    }

    if (!v66)
    {
      goto LABEL_171;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null out_encrypted_length, dumping backtrace:%{public}s";
    goto LABEL_170;
  }

  v13 = cchpke_params_sizeof_aead_key();
  v14 = cchpke_params_sizeof_aead_nonce();
  v79 = cchpke_params_sizeof_aead_tag();
  v81 = v14;
  v83 = v13;
  if (v13 <= v14)
  {
    v15 = v14;
  }

  else
  {
    v15 = v13;
  }

  if (v15 != a11)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v51 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v84 = 0;
    if (!__nwlog_fault(v51, buf, &v84))
    {
      goto LABEL_223;
    }

    if (buf[0] == 17)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null (exported_secret_length == response_nonce_length)";
      goto LABEL_222;
    }

    if (v84 != 1)
    {
      v52 = __nwlog_obj();
      v53 = buf[0];
      if (!os_log_type_enabled(v52, buf[0]))
      {
        goto LABEL_223;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v54 = "%{public}s called with null (exported_secret_length == response_nonce_length), backtrace limit exceeded";
      goto LABEL_222;
    }

    backtrace_string = __nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = buf[0];
    v67 = os_log_type_enabled(v52, buf[0]);
    if (backtrace_string)
    {
      if (v67)
      {
        *__str = 136446466;
        *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
        *&__str[12] = 2082;
        *&__str[14] = backtrace_string;
        v57 = "%{public}s called with null (exported_secret_length == response_nonce_length), dumping backtrace:%{public}s";
        goto LABEL_170;
      }

LABEL_171:
      free(backtrace_string);
      goto LABEL_223;
    }

    if (!v67)
    {
      goto LABEL_223;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v54 = "%{public}s called with null (exported_secret_length == response_nonce_length), no backtrace";
LABEL_222:
    _os_log_impl(&dword_181A37000, v52, v53, v54, __str, 0xCu);
LABEL_223:
    if (v51)
    {
      free(v51);
    }

    return 0;
  }

  v16 = malloc_type_calloc(1uLL, a11, 0x842733E1uLL);
  if (!v16)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *__str = 136446722;
    *&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2048;
    *&__str[14] = 1;
    *&__str[22] = 2048;
    *&__str[24] = a11;
    v17 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v17);
    if (result)
    {
      goto LABEL_229;
    }

    free(v17);
  }

  v104 = 0u;
  v105 = 0u;
  v102 = 0u;
  v103 = 0u;
  v100 = 0u;
  v101 = 0u;
  v98 = 0u;
  v99 = 0u;
  v96 = 0u;
  v97 = 0u;
  v94 = 0u;
  v95 = 0u;
  v92 = 0u;
  v93 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x100uLL, "%s chunked response", a3);
  strlen(__str);
  v19 = cchpke_responder_export();
  if (v19)
  {
    v20 = v19;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v87 = 1024;
      LODWORD(v88) = v20;
      _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_ERROR, "%{public}s Export error: %d", buf, 0x12u);
    }

    if (!v16)
    {
      return 0;
    }

    goto LABEL_22;
  }

  if (!(a11 + a9))
  {
    v68 = __nwlog_obj();
    os_log_type_enabled(v68, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v69 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v69);
    if (result)
    {
      goto LABEL_229;
    }

    free(v69);
  }

  v22 = malloc_type_calloc(1uLL, a11 + a9, 0x679A414CuLL);
  if (!v22)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v87 = 2048;
    v88 = 1;
    v89 = 2048;
    v90 = a11 + a9;
    v23 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v23);
    if (result)
    {
      goto LABEL_229;
    }

    free(v23);
  }

  memcpy(v22, a8, a9);
  memcpy(&v22[a9], a10, a11);
  v24 = cchpke_params_sizeof_kdf_hash();
  v25 = v13;
  if (!v24)
  {
    v70 = __nwlog_obj();
    os_log_type_enabled(v70, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v71 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v71);
    if (result)
    {
      goto LABEL_229;
    }

    free(v71);
  }

  v26 = malloc_type_calloc(1uLL, v24, 0x2E66795FuLL);
  if (!v26)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v87 = 2048;
    v88 = 1;
    v89 = 2048;
    v90 = v24;
    v27 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v27);
    if (result)
    {
      goto LABEL_229;
    }

    free(v27);
  }

  ccsha256_di();
  v28 = cchkdf_extract();
  if (v22)
  {
    free(v22);
  }

  if (v16)
  {
    free(v16);
  }

  if (v28)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v29 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v87 = 1024;
      LODWORD(v88) = v28;
      _os_log_impl(&dword_181A37000, v29, OS_LOG_TYPE_ERROR, "%{public}s Extract error: %d", buf, 0x12u);
    }

    if (!v26)
    {
      return 0;
    }

    result = v26;
    goto LABEL_40;
  }

  v30 = v81;
  if (!v83)
  {
    v72 = __nwlog_obj();
    os_log_type_enabled(v72, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v73 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v73);
    if (result)
    {
      goto LABEL_229;
    }

    free(v73);
  }

  v16 = malloc_type_calloc(1uLL, v25, 0xBFE17127uLL);
  if (!v16)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v87 = 2048;
    v88 = 1;
    v89 = 2048;
    v90 = v25;
    v31 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v31);
    if (result)
    {
      goto LABEL_229;
    }

    free(v31);
  }

  v32 = cchkdf_expand();
  if (v32)
  {
    v33 = v32;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v34 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v87 = 1024;
      LODWORD(v88) = v33;
      _os_log_impl(&dword_181A37000, v34, OS_LOG_TYPE_ERROR, "%{public}s Key expand error: %d", buf, 0x12u);
    }

    if (v26)
    {
      free(v26);
    }

    if (!v16)
    {
      return 0;
    }

LABEL_22:
    result = v16;
LABEL_40:
    free(result);
    return 0;
  }

  if (!v81)
  {
    v74 = __nwlog_obj();
    os_log_type_enabled(v74, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v75 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v75);
    if (result)
    {
      goto LABEL_229;
    }

    free(v75);
    v30 = v81;
  }

  v35 = malloc_type_calloc(1uLL, v30, 0x21690225uLL);
  if (!v35)
  {
    v36 = __nwlog_obj();
    os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v87 = 2048;
    v88 = 1;
    v89 = 2048;
    v90 = v30;
    v37 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v37);
    if (result)
    {
      goto LABEL_229;
    }

    free(v37);
  }

  v38 = cchkdf_expand();
  if (v26)
  {
    free(v26);
  }

  if (v38)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v39 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v87 = 1024;
      LODWORD(v88) = v38;
      v40 = "%{public}s Nonce expand error: %d";
      v41 = v39;
      v42 = 18;
LABEL_65:
      _os_log_impl(&dword_181A37000, v41, OS_LOG_TYPE_ERROR, v40, buf, v42);
      goto LABEL_66;
    }

    goto LABEL_66;
  }

  if (v30 <= 7)
  {
    v43 = __nwlog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v87 = 2048;
      v88 = v30;
      v40 = "%{public}s Bad nonce length: %zu";
      v41 = v43;
      v42 = 22;
      goto LABEL_65;
    }

LABEL_66:
    if (v16)
    {
      free(v16);
    }

    if (!v35)
    {
      return 0;
    }

    result = v35;
    goto LABEL_40;
  }

  *&v35[v30 - 8] ^= bswap64(a4);
  v44 = v79 + a2;
  if (!(v79 + a2))
  {
    v76 = __nwlog_obj();
    os_log_type_enabled(v76, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
    v77 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v77);
    if (result)
    {
      goto LABEL_229;
    }

    free(v77);
  }

  v45 = malloc_type_calloc(1uLL, v44, 0xA50387EDuLL);
  if (v45)
  {
    goto LABEL_74;
  }

  v46 = __nwlog_obj();
  os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
  v87 = 2048;
  v88 = 1;
  v89 = 2048;
  v90 = v79 + a2;
  v47 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v47);
  if (result)
  {
LABEL_229:
    __break(1u);
    return result;
  }

  free(v47);
  v45 = 0;
LABEL_74:
  v48 = v45;
  ccaes_gcm_encrypt_mode();
  v49 = ccgcm_one_shot();
  if (v16)
  {
    free(v16);
  }

  free(v35);
  if (v49)
  {
    v50 = __nwlog_obj();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v86 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v87 = 1024;
      LODWORD(v88) = v49;
      _os_log_impl(&dword_181A37000, v50, OS_LOG_TYPE_ERROR, "%{public}s Encrypt error: %d", buf, 0x12u);
    }

    result = v48;
    if (v48)
    {
      goto LABEL_40;
    }
  }

  else
  {
    *a12 = v44;
    return v48;
  }

  return result;
}

void *nw_http_decrypt_oblivious_response(char *a1, unint64_t a2, const char *a3, uint64_t a4, uint64_t a5, const void *a6, size_t a7, size_t *a8)
{
  v102 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    v47 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v80 = 0;
    if (!__nwlog_fault(v47, buf, &v80))
    {
      goto LABEL_204;
    }

    if (buf[0] == 17)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null response_buffer";
      goto LABEL_203;
    }

    if (v80 != 1)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null response_buffer, backtrace limit exceeded";
      goto LABEL_203;
    }

    backtrace_string = __nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = buf[0];
    v56 = os_log_type_enabled(v48, buf[0]);
    if (!backtrace_string)
    {
      if (!v56)
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null response_buffer, no backtrace";
      goto LABEL_203;
    }

    if (!v56)
    {
      goto LABEL_162;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null response_buffer, dumping backtrace:%{public}s";
LABEL_161:
    _os_log_impl(&dword_181A37000, v48, v49, v57, __str, 0x16u);
    goto LABEL_162;
  }

  if (!a2)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    v47 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v80 = 0;
    if (!__nwlog_fault(v47, buf, &v80))
    {
      goto LABEL_204;
    }

    if (buf[0] == 17)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null response_length";
      goto LABEL_203;
    }

    if (v80 != 1)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null response_length, backtrace limit exceeded";
      goto LABEL_203;
    }

    backtrace_string = __nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = buf[0];
    v58 = os_log_type_enabled(v48, buf[0]);
    if (!backtrace_string)
    {
      if (!v58)
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null response_length, no backtrace";
      goto LABEL_203;
    }

    if (!v58)
    {
      goto LABEL_162;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null response_length, dumping backtrace:%{public}s";
    goto LABEL_161;
  }

  if (!a3)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    v47 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v80 = 0;
    if (!__nwlog_fault(v47, buf, &v80))
    {
      goto LABEL_204;
    }

    if (buf[0] == 17)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null media_type";
      goto LABEL_203;
    }

    if (v80 != 1)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null media_type, backtrace limit exceeded";
      goto LABEL_203;
    }

    backtrace_string = __nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = buf[0];
    v59 = os_log_type_enabled(v48, buf[0]);
    if (!backtrace_string)
    {
      if (!v59)
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null media_type, no backtrace";
      goto LABEL_203;
    }

    if (!v59)
    {
      goto LABEL_162;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
    goto LABEL_161;
  }

  if (!a4)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    v47 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v80 = 0;
    if (!__nwlog_fault(v47, buf, &v80))
    {
      goto LABEL_204;
    }

    if (buf[0] == 17)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null request_context";
      goto LABEL_203;
    }

    if (v80 != 1)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null request_context, backtrace limit exceeded";
      goto LABEL_203;
    }

    backtrace_string = __nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = buf[0];
    v60 = os_log_type_enabled(v48, buf[0]);
    if (!backtrace_string)
    {
      if (!v60)
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null request_context, no backtrace";
      goto LABEL_203;
    }

    if (!v60)
    {
      goto LABEL_162;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
    goto LABEL_161;
  }

  if (!a5)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    v47 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v80 = 0;
    if (!__nwlog_fault(v47, buf, &v80))
    {
      goto LABEL_204;
    }

    if (buf[0] == 17)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null request_context_length";
      goto LABEL_203;
    }

    if (v80 != 1)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null request_context_length, backtrace limit exceeded";
      goto LABEL_203;
    }

    backtrace_string = __nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = buf[0];
    v61 = os_log_type_enabled(v48, buf[0]);
    if (!backtrace_string)
    {
      if (!v61)
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null request_context_length, no backtrace";
      goto LABEL_203;
    }

    if (!v61)
    {
      goto LABEL_162;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
    goto LABEL_161;
  }

  if (!a6)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    v47 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v80 = 0;
    if (!__nwlog_fault(v47, buf, &v80))
    {
      goto LABEL_204;
    }

    if (buf[0] == 17)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null request_enc";
      goto LABEL_203;
    }

    if (v80 != 1)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null request_enc, backtrace limit exceeded";
      goto LABEL_203;
    }

    backtrace_string = __nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = buf[0];
    v62 = os_log_type_enabled(v48, buf[0]);
    if (!backtrace_string)
    {
      if (!v62)
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null request_enc, no backtrace";
      goto LABEL_203;
    }

    if (!v62)
    {
      goto LABEL_162;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
    goto LABEL_161;
  }

  if (!a7)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    v47 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v80 = 0;
    if (!__nwlog_fault(v47, buf, &v80))
    {
      goto LABEL_204;
    }

    if (buf[0] == 17)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null request_enc_length";
      goto LABEL_203;
    }

    if (v80 != 1)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
      goto LABEL_203;
    }

    backtrace_string = __nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = buf[0];
    v63 = os_log_type_enabled(v48, buf[0]);
    if (!backtrace_string)
    {
      if (!v63)
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null request_enc_length, no backtrace";
      goto LABEL_203;
    }

    if (!v63)
    {
      goto LABEL_162;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
    goto LABEL_161;
  }

  if (!a8)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    v47 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v80 = 0;
    if (!__nwlog_fault(v47, buf, &v80))
    {
      goto LABEL_204;
    }

    if (buf[0] == 17)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null out_decrypted_length";
      goto LABEL_203;
    }

    if (v80 != 1)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null out_decrypted_length, backtrace limit exceeded";
      goto LABEL_203;
    }

    backtrace_string = __nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = buf[0];
    v64 = os_log_type_enabled(v48, buf[0]);
    if (!backtrace_string)
    {
      if (!v64)
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null out_decrypted_length, no backtrace";
      goto LABEL_203;
    }

    if (!v64)
    {
      goto LABEL_162;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v57 = "%{public}s called with null out_decrypted_length, dumping backtrace:%{public}s";
    goto LABEL_161;
  }

  v12 = cchpke_params_sizeof_aead_key();
  v13 = cchpke_params_sizeof_aead_nonce();
  v14 = cchpke_params_sizeof_aead_tag();
  v77 = v13;
  size = v12;
  if (v12 > v13)
  {
    v13 = v12;
  }

  v75 = a2 - (v13 + v14);
  v76 = v14;
  if (a2 <= v13 + v14)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    v47 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v80 = 0;
    if (!__nwlog_fault(v47, buf, &v80))
    {
      goto LABEL_204;
    }

    if (buf[0] == 17)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null (response_length > response_nonce_length + tag_length)";
      goto LABEL_203;
    }

    if (v80 != 1)
    {
      v48 = __nwlog_obj();
      v49 = buf[0];
      if (!os_log_type_enabled(v48, buf[0]))
      {
        goto LABEL_204;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_oblivious_response";
      v50 = "%{public}s called with null (response_length > response_nonce_length + tag_length), backtrace limit exceeded";
      goto LABEL_203;
    }

    backtrace_string = __nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = buf[0];
    v65 = os_log_type_enabled(v48, buf[0]);
    if (backtrace_string)
    {
      if (v65)
      {
        *__str = 136446466;
        *&__str[4] = "nw_http_decrypt_oblivious_response";
        *&__str[12] = 2082;
        *&__str[14] = backtrace_string;
        v57 = "%{public}s called with null (response_length > response_nonce_length + tag_length), dumping backtrace:%{public}s";
        goto LABEL_161;
      }

LABEL_162:
      free(backtrace_string);
      goto LABEL_204;
    }

    if (!v65)
    {
      goto LABEL_204;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    v50 = "%{public}s called with null (response_length > response_nonce_length + tag_length), no backtrace";
LABEL_203:
    _os_log_impl(&dword_181A37000, v48, v49, v50, __str, 0xCu);
LABEL_204:
    if (v47)
    {
      free(v47);
    }

    return 0;
  }

  if (!(v13 + a7))
  {
    v51 = __nwlog_obj();
    os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    v52 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v52);
    if (result)
    {
      goto LABEL_210;
    }

    free(v52);
  }

  v15 = malloc_type_calloc(1uLL, v13 + a7, 0x22576F28uLL);
  if (!v15)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *__str = 136446722;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    *&__str[12] = 2048;
    *&__str[14] = 1;
    *&__str[22] = 2048;
    *&__str[24] = v13 + a7;
    v16 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v16);
    if (result)
    {
      goto LABEL_210;
    }

    free(v16);
  }

  memcpy(v15, a6, a7);
  memcpy(&v15[a7], a1, v13);
  if (!v13)
  {
    v53 = __nwlog_obj();
    os_log_type_enabled(v53, OS_LOG_TYPE_ERROR);
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    v54 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v54);
    if (result)
    {
      goto LABEL_210;
    }

    free(v54);
  }

  v18 = malloc_type_calloc(1uLL, v13, 0x5B44A9F4uLL);
  if (!v18)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *__str = 136446722;
    *&__str[4] = "nw_http_decrypt_oblivious_response";
    *&__str[12] = 2048;
    *&__str[14] = 1;
    *&__str[22] = 2048;
    *&__str[24] = v13;
    v19 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v19);
    if (result)
    {
      goto LABEL_210;
    }

    free(v19);
  }

  v100 = 0u;
  v101 = 0u;
  v98 = 0u;
  v99 = 0u;
  v96 = 0u;
  v97 = 0u;
  v94 = 0u;
  v95 = 0u;
  v92 = 0u;
  v93 = 0u;
  v90 = 0u;
  v91 = 0u;
  v88 = 0u;
  v89 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x100uLL, "%s response", a3);
  strlen(__str);
  v20 = cchpke_initiator_export();
  if (v20)
  {
    v21 = v20;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v22 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v82 = "nw_http_decrypt_oblivious_response";
      v83 = 1024;
      LODWORD(v84) = v21;
      _os_log_impl(&dword_181A37000, v22, OS_LOG_TYPE_ERROR, "%{public}s Export error: %d", buf, 0x12u);
    }

    if (v18)
    {
      free(v18);
    }

    if (!v15)
    {
      return 0;
    }

    goto LABEL_26;
  }

  v23 = cchpke_params_sizeof_kdf_hash();
  if (!v23)
  {
    v66 = __nwlog_obj();
    os_log_type_enabled(v66, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v82 = "nw_http_decrypt_oblivious_response";
    v67 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v67);
    if (result)
    {
      goto LABEL_210;
    }

    free(v67);
  }

  v24 = malloc_type_calloc(1uLL, v23, 0xA3E40C66uLL);
  if (!v24)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v82 = "nw_http_decrypt_oblivious_response";
    v83 = 2048;
    v84 = 1;
    v85 = 2048;
    v86 = v23;
    v25 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v25);
    if (result)
    {
      goto LABEL_210;
    }

    free(v25);
  }

  ccsha256_di();
  v26 = cchkdf_extract();
  if (v15)
  {
    free(v15);
  }

  if (v18)
  {
    free(v18);
  }

  if (v26)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v27 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v82 = "nw_http_decrypt_oblivious_response";
      v83 = 1024;
      LODWORD(v84) = v26;
      _os_log_impl(&dword_181A37000, v27, OS_LOG_TYPE_ERROR, "%{public}s Extract error: %d", buf, 0x12u);
    }

    if (!v24)
    {
      return 0;
    }

    result = v24;
    goto LABEL_40;
  }

  if (!size)
  {
    v68 = __nwlog_obj();
    os_log_type_enabled(v68, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v82 = "nw_http_decrypt_oblivious_response";
    v69 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v69);
    if (result)
    {
      goto LABEL_210;
    }

    free(v69);
  }

  v15 = malloc_type_calloc(1uLL, size, 0xBA1C7084uLL);
  if (!v15)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v82 = "nw_http_decrypt_oblivious_response";
    v83 = 2048;
    v84 = 1;
    v85 = 2048;
    v86 = size;
    v28 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v28);
    if (result)
    {
      goto LABEL_210;
    }

    free(v28);
  }

  v29 = cchkdf_expand();
  if (v29)
  {
    v30 = v29;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v31 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v82 = "nw_http_decrypt_oblivious_response";
      v83 = 1024;
      LODWORD(v84) = v30;
      _os_log_impl(&dword_181A37000, v31, OS_LOG_TYPE_ERROR, "%{public}s Key expand error: %d", buf, 0x12u);
    }

    if (v24)
    {
      free(v24);
    }

    if (!v15)
    {
      return 0;
    }

LABEL_26:
    result = v15;
LABEL_40:
    free(result);
    return 0;
  }

  v32 = v77;
  if (!v77)
  {
    v70 = __nwlog_obj();
    os_log_type_enabled(v70, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v82 = "nw_http_decrypt_oblivious_response";
    v71 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v71);
    if (result)
    {
      goto LABEL_210;
    }

    free(v71);
    v32 = 0;
  }

  v33 = malloc_type_calloc(1uLL, v32, 0x7E1DCEFBuLL);
  if (!v33)
  {
    v34 = __nwlog_obj();
    os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v82 = "nw_http_decrypt_oblivious_response";
    v83 = 2048;
    v84 = 1;
    v85 = 2048;
    v86 = v32;
    v35 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v35);
    if (result)
    {
      goto LABEL_210;
    }

    free(v35);
  }

  v36 = cchkdf_expand();
  if (v24)
  {
    free(v24);
  }

  if (v36)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v37 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v82 = "nw_http_decrypt_oblivious_response";
      v83 = 1024;
      LODWORD(v84) = v36;
      _os_log_impl(&dword_181A37000, v37, OS_LOG_TYPE_ERROR, "%{public}s Nonce expand error: %d", buf, 0x12u);
    }

    if (v15)
    {
      free(v15);
    }

    if (!v33)
    {
      return 0;
    }

    result = v33;
    goto LABEL_40;
  }

  v38 = v76;
  if (!v76)
  {
    v72 = __nwlog_obj();
    os_log_type_enabled(v72, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v82 = "nw_http_decrypt_oblivious_response";
    v73 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v73);
    if (result)
    {
      goto LABEL_210;
    }

    free(v73);
    v38 = 0;
  }

  v39 = malloc_type_calloc(1uLL, v38, 0x9FAF3AE3uLL);
  if (!v39)
  {
    v40 = __nwlog_obj();
    os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v82 = "nw_http_decrypt_oblivious_response";
    v83 = 2048;
    v84 = 1;
    v85 = 2048;
    v86 = v38;
    v41 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v41);
    if (result)
    {
      goto LABEL_210;
    }

    free(v41);
  }

  memcpy(v39, &a1[v13 + v75], v38);
  v42 = malloc_type_calloc(1uLL, v75, 0x9C2CB57uLL);
  if (v42)
  {
    goto LABEL_73;
  }

  v43 = __nwlog_obj();
  os_log_type_enabled(v43, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v82 = "nw_http_decrypt_oblivious_response";
  v83 = 2048;
  v84 = 1;
  v85 = 2048;
  v86 = v75;
  v44 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v44);
  if (result)
  {
LABEL_210:
    __break(1u);
    return result;
  }

  free(v44);
LABEL_73:
  ccaes_gcm_decrypt_mode();
  v45 = ccgcm_one_shot();
  if (v15)
  {
    free(v15);
  }

  if (v33)
  {
    free(v33);
  }

  if (v39)
  {
    free(v39);
  }

  if (v45)
  {
    v46 = __nwlog_obj();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v82 = "nw_http_decrypt_oblivious_response";
      v83 = 1024;
      LODWORD(v84) = v45;
      _os_log_impl(&dword_181A37000, v46, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", buf, 0x12u);
    }

    result = v42;
    if (v42)
    {
      goto LABEL_40;
    }
  }

  else
  {
    *a8 = v75;
    return v42;
  }

  return result;
}

void *nw_http_decrypt_chunked_oblivious_response_chunk(uint64_t a1, uint64_t a2, const char *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const void *a8, size_t a9, const void *a10, size_t a11, void *a12)
{
  v111 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v55 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v89 = 0;
    if (!__nwlog_fault(v55, buf, &v89))
    {
      goto LABEL_233;
    }

    if (buf[0] != 17)
    {
      if (v89 != 1)
      {
        v56 = __nwlog_obj();
        v57 = buf[0];
        if (os_log_type_enabled(v56, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null response_buffer, backtrace limit exceeded";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      backtrace_string = __nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v57 = buf[0];
      v62 = os_log_type_enabled(v56, buf[0]);
      if (!backtrace_string)
      {
        if (v62)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null response_buffer, no backtrace";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      if (!v62)
      {
        goto LABEL_183;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v63 = "%{public}s called with null response_buffer, dumping backtrace:%{public}s";
      goto LABEL_182;
    }

    v56 = __nwlog_obj();
    v57 = buf[0];
    if (!os_log_type_enabled(v56, buf[0]))
    {
      goto LABEL_233;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v58 = "%{public}s called with null response_buffer";
LABEL_232:
    _os_log_impl(&dword_181A37000, v56, v57, v58, __str, 0xCu);
    goto LABEL_233;
  }

  if (!a2)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v55 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v89 = 0;
    if (!__nwlog_fault(v55, buf, &v89))
    {
      goto LABEL_233;
    }

    if (buf[0] != 17)
    {
      if (v89 != 1)
      {
        v56 = __nwlog_obj();
        v57 = buf[0];
        if (os_log_type_enabled(v56, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null response_length, backtrace limit exceeded";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      backtrace_string = __nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v57 = buf[0];
      v64 = os_log_type_enabled(v56, buf[0]);
      if (!backtrace_string)
      {
        if (v64)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null response_length, no backtrace";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      if (!v64)
      {
        goto LABEL_183;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v63 = "%{public}s called with null response_length, dumping backtrace:%{public}s";
      goto LABEL_182;
    }

    v56 = __nwlog_obj();
    v57 = buf[0];
    if (!os_log_type_enabled(v56, buf[0]))
    {
      goto LABEL_233;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v58 = "%{public}s called with null response_length";
    goto LABEL_232;
  }

  if (!a3)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v55 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v89 = 0;
    if (!__nwlog_fault(v55, buf, &v89))
    {
      goto LABEL_233;
    }

    if (buf[0] != 17)
    {
      if (v89 != 1)
      {
        v56 = __nwlog_obj();
        v57 = buf[0];
        if (os_log_type_enabled(v56, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null media_type, backtrace limit exceeded";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      backtrace_string = __nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v57 = buf[0];
      v65 = os_log_type_enabled(v56, buf[0]);
      if (!backtrace_string)
      {
        if (v65)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null media_type, no backtrace";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      if (!v65)
      {
        goto LABEL_183;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v63 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_182;
    }

    v56 = __nwlog_obj();
    v57 = buf[0];
    if (!os_log_type_enabled(v56, buf[0]))
    {
      goto LABEL_233;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v58 = "%{public}s called with null media_type";
    goto LABEL_232;
  }

  if (!a6)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v55 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v89 = 0;
    if (!__nwlog_fault(v55, buf, &v89))
    {
      goto LABEL_233;
    }

    if (buf[0] != 17)
    {
      if (v89 != 1)
      {
        v56 = __nwlog_obj();
        v57 = buf[0];
        if (os_log_type_enabled(v56, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null request_context, backtrace limit exceeded";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      backtrace_string = __nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v57 = buf[0];
      v66 = os_log_type_enabled(v56, buf[0]);
      if (!backtrace_string)
      {
        if (v66)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null request_context, no backtrace";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      if (!v66)
      {
        goto LABEL_183;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v63 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
      goto LABEL_182;
    }

    v56 = __nwlog_obj();
    v57 = buf[0];
    if (!os_log_type_enabled(v56, buf[0]))
    {
      goto LABEL_233;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v58 = "%{public}s called with null request_context";
    goto LABEL_232;
  }

  if (!a7)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v55 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v89 = 0;
    if (!__nwlog_fault(v55, buf, &v89))
    {
      goto LABEL_233;
    }

    if (buf[0] != 17)
    {
      if (v89 != 1)
      {
        v56 = __nwlog_obj();
        v57 = buf[0];
        if (os_log_type_enabled(v56, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null request_context_length, backtrace limit exceeded";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      backtrace_string = __nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v57 = buf[0];
      v67 = os_log_type_enabled(v56, buf[0]);
      if (!backtrace_string)
      {
        if (v67)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null request_context_length, no backtrace";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      if (!v67)
      {
        goto LABEL_183;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v63 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
      goto LABEL_182;
    }

    v56 = __nwlog_obj();
    v57 = buf[0];
    if (!os_log_type_enabled(v56, buf[0]))
    {
      goto LABEL_233;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v58 = "%{public}s called with null request_context_length";
    goto LABEL_232;
  }

  if (!a8)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v55 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v89 = 0;
    if (!__nwlog_fault(v55, buf, &v89))
    {
      goto LABEL_233;
    }

    if (buf[0] != 17)
    {
      if (v89 != 1)
      {
        v56 = __nwlog_obj();
        v57 = buf[0];
        if (os_log_type_enabled(v56, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null request_enc, backtrace limit exceeded";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      backtrace_string = __nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v57 = buf[0];
      v68 = os_log_type_enabled(v56, buf[0]);
      if (!backtrace_string)
      {
        if (v68)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null request_enc, no backtrace";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      if (!v68)
      {
        goto LABEL_183;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v63 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
      goto LABEL_182;
    }

    v56 = __nwlog_obj();
    v57 = buf[0];
    if (!os_log_type_enabled(v56, buf[0]))
    {
      goto LABEL_233;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v58 = "%{public}s called with null request_enc";
    goto LABEL_232;
  }

  if (!a9)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v55 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v89 = 0;
    if (!__nwlog_fault(v55, buf, &v89))
    {
      goto LABEL_233;
    }

    if (buf[0] != 17)
    {
      if (v89 != 1)
      {
        v56 = __nwlog_obj();
        v57 = buf[0];
        if (os_log_type_enabled(v56, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      backtrace_string = __nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v57 = buf[0];
      v69 = os_log_type_enabled(v56, buf[0]);
      if (!backtrace_string)
      {
        if (v69)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null request_enc_length, no backtrace";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      if (!v69)
      {
        goto LABEL_183;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v63 = "%{public}s called with null request_enc_length, dumping backtrace:%{public}s";
      goto LABEL_182;
    }

    v56 = __nwlog_obj();
    v57 = buf[0];
    if (!os_log_type_enabled(v56, buf[0]))
    {
      goto LABEL_233;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v58 = "%{public}s called with null request_enc_length";
    goto LABEL_232;
  }

  if (!a10)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v55 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v89 = 0;
    if (!__nwlog_fault(v55, buf, &v89))
    {
      goto LABEL_233;
    }

    if (buf[0] != 17)
    {
      if (v89 != 1)
      {
        v56 = __nwlog_obj();
        v57 = buf[0];
        if (os_log_type_enabled(v56, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null response_nonce, backtrace limit exceeded";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      backtrace_string = __nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v57 = buf[0];
      v70 = os_log_type_enabled(v56, buf[0]);
      if (!backtrace_string)
      {
        if (v70)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null response_nonce, no backtrace";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      if (!v70)
      {
        goto LABEL_183;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v63 = "%{public}s called with null response_nonce, dumping backtrace:%{public}s";
      goto LABEL_182;
    }

    v56 = __nwlog_obj();
    v57 = buf[0];
    if (!os_log_type_enabled(v56, buf[0]))
    {
      goto LABEL_233;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v58 = "%{public}s called with null response_nonce";
    goto LABEL_232;
  }

  if (!a11)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v55 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v89 = 0;
    if (!__nwlog_fault(v55, buf, &v89))
    {
      goto LABEL_233;
    }

    if (buf[0] != 17)
    {
      if (v89 != 1)
      {
        v56 = __nwlog_obj();
        v57 = buf[0];
        if (os_log_type_enabled(v56, buf[0]))
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null response_nonce_length, backtrace limit exceeded";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      backtrace_string = __nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v57 = buf[0];
      v71 = os_log_type_enabled(v56, buf[0]);
      if (!backtrace_string)
      {
        if (v71)
        {
          *__str = 136446210;
          *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
          v58 = "%{public}s called with null response_nonce_length, no backtrace";
          goto LABEL_232;
        }

        goto LABEL_233;
      }

      if (!v71)
      {
        goto LABEL_183;
      }

      *__str = 136446466;
      *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v63 = "%{public}s called with null response_nonce_length, dumping backtrace:%{public}s";
      goto LABEL_182;
    }

    v56 = __nwlog_obj();
    v57 = buf[0];
    if (!os_log_type_enabled(v56, buf[0]))
    {
      goto LABEL_233;
    }

    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v58 = "%{public}s called with null response_nonce_length";
    goto LABEL_232;
  }

  if (!a12)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v55 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v89 = 0;
    if (!__nwlog_fault(v55, buf, &v89))
    {
      goto LABEL_233;
    }

    if (buf[0] == 17)
    {
      v56 = __nwlog_obj();
      v57 = buf[0];
      if (!os_log_type_enabled(v56, buf[0]))
      {
        goto LABEL_233;
      }

      *__str = 136446210;
      *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      v58 = "%{public}s called with null out_decrypted_length";
      goto LABEL_232;
    }

    if (v89 != 1)
    {
      v56 = __nwlog_obj();
      v57 = buf[0];
      if (os_log_type_enabled(v56, buf[0]))
      {
        *__str = 136446210;
        *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
        v58 = "%{public}s called with null out_decrypted_length, backtrace limit exceeded";
        goto LABEL_232;
      }

      goto LABEL_233;
    }

    backtrace_string = __nw_create_backtrace_string();
    v56 = __nwlog_obj();
    v57 = buf[0];
    v72 = os_log_type_enabled(v56, buf[0]);
    if (!backtrace_string)
    {
      if (v72)
      {
        *__str = 136446210;
        *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
        v58 = "%{public}s called with null out_decrypted_length, no backtrace";
        goto LABEL_232;
      }

      goto LABEL_233;
    }

    if (!v72)
    {
      goto LABEL_183;
    }

    *__str = 136446466;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2082;
    *&__str[14] = backtrace_string;
    v63 = "%{public}s called with null out_decrypted_length, dumping backtrace:%{public}s";
LABEL_182:
    _os_log_impl(&dword_181A37000, v56, v57, v63, __str, 0x16u);
    goto LABEL_183;
  }

  v13 = cchpke_params_sizeof_aead_key();
  v14 = cchpke_params_sizeof_aead_nonce();
  size = cchpke_params_sizeof_aead_tag();
  v86 = v14;
  v87 = v13;
  if (v13 <= v14)
  {
    v15 = v14;
  }

  else
  {
    v15 = v13;
  }

  if (v15 != a11)
  {
    __nwlog_obj();
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v55 = _os_log_send_and_compose_impl();
    buf[0] = 16;
    v89 = 0;
    if (!__nwlog_fault(v55, buf, &v89))
    {
      goto LABEL_233;
    }

    if (buf[0] == 17)
    {
      v56 = __nwlog_obj();
      v57 = buf[0];
      if (os_log_type_enabled(v56, buf[0]))
      {
        *__str = 136446210;
        *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
        v58 = "%{public}s called with null (response_nonce_length == exported_secret_length)";
        goto LABEL_232;
      }

LABEL_233:
      if (!v55)
      {
        return 0;
      }

      result = v55;
      goto LABEL_70;
    }

    if (v89 != 1)
    {
      v56 = __nwlog_obj();
      v57 = buf[0];
      if (os_log_type_enabled(v56, buf[0]))
      {
        *__str = 136446210;
        *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
        v58 = "%{public}s called with null (response_nonce_length == exported_secret_length), backtrace limit exceeded";
        goto LABEL_232;
      }

      goto LABEL_233;
    }

    backtrace_string = __nw_create_backtrace_string();
    v56 = __nwlog_obj();
    v57 = buf[0];
    v73 = os_log_type_enabled(v56, buf[0]);
    if (!backtrace_string)
    {
      if (v73)
      {
        *__str = 136446210;
        *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
        v58 = "%{public}s called with null (response_nonce_length == exported_secret_length), no backtrace";
        goto LABEL_232;
      }

      goto LABEL_233;
    }

    if (v73)
    {
      *__str = 136446466;
      *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
      *&__str[12] = 2082;
      *&__str[14] = backtrace_string;
      v63 = "%{public}s called with null (response_nonce_length == exported_secret_length), dumping backtrace:%{public}s";
      goto LABEL_182;
    }

LABEL_183:
    free(backtrace_string);
    goto LABEL_233;
  }

  if (!(a11 + a9))
  {
    v59 = __nwlog_obj();
    os_log_type_enabled(v59, OS_LOG_TYPE_ERROR);
    *__str = 136446210;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v60 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v60);
    if (result)
    {
      goto LABEL_239;
    }

    free(v60);
  }

  v16 = malloc_type_calloc(1uLL, a11 + a9, 0x1A82313DuLL);
  if (!v16)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *__str = 136446722;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2048;
    *&__str[14] = 1;
    *&__str[22] = 2048;
    *&__str[24] = a11 + a9;
    v17 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v17);
    if (result)
    {
      goto LABEL_239;
    }

    free(v17);
  }

  memcpy(v16, a8, a9);
  memcpy(&v16[a9], a10, a11);
  v19 = malloc_type_calloc(1uLL, a11, 0x8F11CB13uLL);
  if (!v19)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *__str = 136446722;
    *&__str[4] = "nw_http_decrypt_chunked_oblivious_response_chunk";
    *&__str[12] = 2048;
    *&__str[14] = 1;
    *&__str[22] = 2048;
    *&__str[24] = a11;
    v20 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v20);
    if (result)
    {
      goto LABEL_239;
    }

    free(v20);
  }

  v109 = 0u;
  v110 = 0u;
  v107 = 0u;
  v108 = 0u;
  v105 = 0u;
  v106 = 0u;
  v103 = 0u;
  v104 = 0u;
  v101 = 0u;
  v102 = 0u;
  v99 = 0u;
  v100 = 0u;
  v97 = 0u;
  v98 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x100uLL, "%s chunked response", a3);
  strlen(__str);
  v21 = cchpke_initiator_export();
  if (v21)
  {
    v22 = v21;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      v92 = 1024;
      LODWORD(v93) = v22;
      _os_log_impl(&dword_181A37000, v23, OS_LOG_TYPE_ERROR, "%{public}s Export error: %d", buf, 0x12u);
    }

    if (v19)
    {
      free(v19);
    }

    if (!v16)
    {
      return 0;
    }

    result = v16;
    goto LABEL_70;
  }

  v24 = cchpke_params_sizeof_kdf_hash();
  if (!v24)
  {
    v74 = __nwlog_obj();
    os_log_type_enabled(v74, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v75 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v75);
    if (result)
    {
      goto LABEL_239;
    }

    free(v75);
  }

  v25 = malloc_type_calloc(1uLL, v24, 0x86365EC3uLL);
  if (!v25)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v92 = 2048;
    v93 = 1;
    v94 = 2048;
    v95 = v24;
    v26 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v26);
    if (result)
    {
      goto LABEL_239;
    }

    free(v26);
  }

  ccsha256_di();
  v27 = cchkdf_extract();
  if (v16)
  {
    free(v16);
  }

  if (v19)
  {
    free(v19);
  }

  if (v27)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v28 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      v92 = 1024;
      LODWORD(v93) = v27;
      _os_log_impl(&dword_181A37000, v28, OS_LOG_TYPE_ERROR, "%{public}s Extract error: %d", buf, 0x12u);
    }

    if (!v25)
    {
      return 0;
    }

    result = v25;
    goto LABEL_70;
  }

  v29 = v86;
  if (!v87)
  {
    v76 = __nwlog_obj();
    os_log_type_enabled(v76, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v77 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v77);
    if (result)
    {
      goto LABEL_239;
    }

    free(v77);
  }

  v30 = malloc_type_calloc(1uLL, v87, 0xDD05B8CFuLL);
  if (!v30)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v92 = 2048;
    v93 = 1;
    v94 = 2048;
    v95 = v87;
    v31 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v31);
    if (result)
    {
      goto LABEL_239;
    }

    free(v31);
  }

  v32 = cchkdf_expand();
  if (v32)
  {
    v33 = v32;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v34 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      v92 = 1024;
      LODWORD(v93) = v33;
      _os_log_impl(&dword_181A37000, v34, OS_LOG_TYPE_ERROR, "%{public}s Key expand error: %d", buf, 0x12u);
    }

    if (v25)
    {
      free(v25);
    }

    if (!v30)
    {
      return 0;
    }

    result = v30;
    goto LABEL_70;
  }

  if (!v86)
  {
    v78 = __nwlog_obj();
    os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v79 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v79);
    if (result)
    {
      goto LABEL_239;
    }

    free(v79);
    v29 = v86;
  }

  v35 = malloc_type_calloc(1uLL, v29, 0xC81FAD41uLL);
  if (!v35)
  {
    v36 = __nwlog_obj();
    os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v92 = 2048;
    v93 = 1;
    v94 = 2048;
    v95 = v29;
    v37 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v37);
    if (result)
    {
      goto LABEL_239;
    }

    free(v37);
  }

  v38 = cchkdf_expand();
  if (v25)
  {
    free(v25);
  }

  if (v38)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v39 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      v92 = 1024;
      LODWORD(v93) = v38;
      v40 = "%{public}s Nonce expand error: %d";
      v41 = v39;
      v42 = 18;
LABEL_65:
      _os_log_impl(&dword_181A37000, v41, OS_LOG_TYPE_ERROR, v40, buf, v42);
      goto LABEL_66;
    }

    goto LABEL_66;
  }

  if (v29 <= 7)
  {
    v43 = __nwlog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      v92 = 2048;
      v93 = v29;
      v40 = "%{public}s Bad nonce length: %zu";
      v41 = v43;
      v42 = 22;
      goto LABEL_65;
    }

LABEL_66:
    if (v30)
    {
      free(v30);
    }

    if (!v35)
    {
      return 0;
    }

    result = v35;
    goto LABEL_70;
  }

  *&v35[v29 - 8] ^= bswap64(a4);
  v44 = size;
  if (!size)
  {
    v80 = __nwlog_obj();
    os_log_type_enabled(v80, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v81 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v81);
    if (result)
    {
      goto LABEL_239;
    }

    free(v81);
    v44 = 0;
  }

  v45 = malloc_type_calloc(1uLL, v44, 0x1BF1E952uLL);
  if (!v45)
  {
    v46 = __nwlog_obj();
    os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v92 = 2048;
    v93 = 1;
    v94 = 2048;
    v95 = v44;
    v47 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v47);
    if (result)
    {
      goto LABEL_239;
    }

    free(v47);
  }

  v48 = v35;
  memcpy(v45, (a1 + a2 - v44), v44);
  if (a2 == v44)
  {
    v49 = 1;
  }

  else
  {
    v49 = a2 - v44;
  }

  v50 = malloc_type_calloc(1uLL, v49, 0x5CB9CE63uLL);
  if (!v50)
  {
    v51 = __nwlog_obj();
    os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v92 = 2048;
    v93 = 1;
    v94 = 2048;
    v95 = v49;
    v52 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v52);
    if (!result)
    {
      free(v52);
      goto LABEL_82;
    }

LABEL_239:
    __break(1u);
    return result;
  }

LABEL_82:
  ccaes_gcm_decrypt_mode();
  v53 = ccgcm_one_shot();
  if (v30)
  {
    free(v30);
  }

  free(v48);
  if (v45)
  {
    free(v45);
  }

  if (!v53)
  {
    *a12 = a2 - v44;
    return v50;
  }

  v54 = __nwlog_obj();
  if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
  {
    *buf = 136446466;
    v91 = "nw_http_decrypt_chunked_oblivious_response_chunk";
    v92 = 1024;
    LODWORD(v93) = v53;
    _os_log_impl(&dword_181A37000, v54, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", buf, 0x12u);
  }

  result = v50;
  if (v50)
  {
LABEL_70:
    free(result);
    return 0;
  }

  return result;
}

uint64_t nw_http_decrypt_oblivious_aead_response(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, size_t *a7)
{
  v52 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v27 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v27, &type, &v44))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v44 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null response_buffer, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v32 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v32)
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null response_buffer, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v32)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v47 = "nw_http_decrypt_oblivious_aead_response";
      v48 = 2082;
      v49 = backtrace_string;
      v33 = "%{public}s called with null response_buffer, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v26 = "%{public}s called with null response_buffer";
LABEL_155:
    _os_log_impl(&dword_181A37000, v24, v25, v26, buf, 0xCu);
    goto LABEL_156;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v27 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v27, &type, &v44))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v44 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null response_length, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v34 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v34)
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null response_length, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v34)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v47 = "nw_http_decrypt_oblivious_aead_response";
      v48 = 2082;
      v49 = backtrace_string;
      v33 = "%{public}s called with null response_length, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v26 = "%{public}s called with null response_length";
    goto LABEL_155;
  }

  if (!a3)
  {
    __nwlog_obj();
    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v27 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v27, &type, &v44))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v44 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null aead_nonce, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v35 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v35)
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null aead_nonce, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v35)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v47 = "nw_http_decrypt_oblivious_aead_response";
      v48 = 2082;
      v49 = backtrace_string;
      v33 = "%{public}s called with null aead_nonce, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v26 = "%{public}s called with null aead_nonce";
    goto LABEL_155;
  }

  if (!a4)
  {
    __nwlog_obj();
    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v27 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v27, &type, &v44))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v44 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null aead_nonce_length, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v36 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null aead_nonce_length, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v36)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v47 = "nw_http_decrypt_oblivious_aead_response";
      v48 = 2082;
      v49 = backtrace_string;
      v33 = "%{public}s called with null aead_nonce_length, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v26 = "%{public}s called with null aead_nonce_length";
    goto LABEL_155;
  }

  if (!a5)
  {
    __nwlog_obj();
    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v27 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v27, &type, &v44))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v44 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null aead_key, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v37 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v37)
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null aead_key, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v37)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v47 = "nw_http_decrypt_oblivious_aead_response";
      v48 = 2082;
      v49 = backtrace_string;
      v33 = "%{public}s called with null aead_key, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v26 = "%{public}s called with null aead_key";
    goto LABEL_155;
  }

  if (!a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v27 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v27, &type, &v44))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v44 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null aead_key_length, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v38 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v38)
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null aead_key_length, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v38)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v47 = "nw_http_decrypt_oblivious_aead_response";
      v48 = 2082;
      v49 = backtrace_string;
      v33 = "%{public}s called with null aead_key_length, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v26 = "%{public}s called with null aead_key_length";
    goto LABEL_155;
  }

  if (!a7)
  {
    __nwlog_obj();
    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v27 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v27, &type, &v44))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v44 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null out_decrypted_length, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v39 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v39)
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null out_decrypted_length, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v39)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v47 = "nw_http_decrypt_oblivious_aead_response";
      v48 = 2082;
      v49 = backtrace_string;
      v33 = "%{public}s called with null out_decrypted_length, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v26 = "%{public}s called with null out_decrypted_length";
    goto LABEL_155;
  }

  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  if (cchpke_params_sizeof_aead_key() != a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v27 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v27, &type, &v44))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v44 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v40 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *buf = 136446210;
          v47 = "nw_http_decrypt_oblivious_aead_response";
          v26 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v40)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v47 = "nw_http_decrypt_oblivious_aead_response";
      v48 = 2082;
      v49 = backtrace_string;
      v33 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v26 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params))";
    goto LABEL_155;
  }

  if (cchpke_params_sizeof_aead_nonce() != a4)
  {
    __nwlog_obj();
    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v27 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v27, &type, &v44))
    {
      goto LABEL_156;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
      {
        goto LABEL_156;
      }

      *buf = 136446210;
      v47 = "nw_http_decrypt_oblivious_aead_response";
      v26 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params))";
      goto LABEL_155;
    }

    if (v44 != 1)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *buf = 136446210;
        v47 = "nw_http_decrypt_oblivious_aead_response";
        v26 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), backtrace limit exceeded";
        goto LABEL_155;
      }

      goto LABEL_156;
    }

    backtrace_string = __nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v25 = type;
    v41 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v41)
      {
        *buf = 136446210;
        v47 = "nw_http_decrypt_oblivious_aead_response";
        v26 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), no backtrace";
        goto LABEL_155;
      }

      goto LABEL_156;
    }

    if (!v41)
    {
      goto LABEL_114;
    }

    *buf = 136446466;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v48 = 2082;
    v49 = backtrace_string;
    v33 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), dumping backtrace:%{public}s";
LABEL_113:
    _os_log_impl(&dword_181A37000, v24, v25, v33, buf, 0x16u);
    goto LABEL_114;
  }

  v12 = cchpke_params_sizeof_aead_tag();
  if (a6 <= a4)
  {
    v13 = a4;
  }

  else
  {
    v13 = a6;
  }

  v14 = a2 > v12 + v13;
  v15 = a2 - (v12 + v13);
  if (!v14)
  {
    __nwlog_obj();
    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v27 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v27, &type, &v44))
    {
      goto LABEL_156;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *buf = 136446210;
        v47 = "nw_http_decrypt_oblivious_aead_response";
        v26 = "%{public}s called with null (response_length > response_nonce_length + tag_length)";
        goto LABEL_155;
      }

LABEL_156:
      if (v27)
      {
        free(v27);
      }

      return 0;
    }

    if (v44 != 1)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *buf = 136446210;
        v47 = "nw_http_decrypt_oblivious_aead_response";
        v26 = "%{public}s called with null (response_length > response_nonce_length + tag_length), backtrace limit exceeded";
        goto LABEL_155;
      }

      goto LABEL_156;
    }

    backtrace_string = __nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v25 = type;
    v42 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v42)
      {
        *buf = 136446210;
        v47 = "nw_http_decrypt_oblivious_aead_response";
        v26 = "%{public}s called with null (response_length > response_nonce_length + tag_length), no backtrace";
        goto LABEL_155;
      }

      goto LABEL_156;
    }

    if (v42)
    {
      *buf = 136446466;
      v47 = "nw_http_decrypt_oblivious_aead_response";
      v48 = 2082;
      v49 = backtrace_string;
      v33 = "%{public}s called with null (response_length > response_nonce_length + tag_length), dumping backtrace:%{public}s";
      goto LABEL_113;
    }

LABEL_114:
    free(backtrace_string);
    goto LABEL_156;
  }

  v16 = v12;
  v43 = a7;
  if (!v12)
  {
    v29 = __nwlog_obj();
    os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v30 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v30);
    if (result)
    {
      goto LABEL_159;
    }

    free(v30);
  }

  v17 = malloc_type_calloc(1uLL, v16, 0xF57F2FA9uLL);
  if (!v17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v47 = "nw_http_decrypt_oblivious_aead_response";
    v48 = 2048;
    v49 = 1;
    v50 = 2048;
    v51 = v16;
    v18 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v18);
    if (result)
    {
      goto LABEL_159;
    }

    free(v18);
  }

  memcpy(v17, (a1 + v13 + v15), v16);
  v20 = malloc_type_calloc(1uLL, v15, 0x7A4EA294uLL);
  if (v20)
  {
LABEL_22:
    ccaes_gcm_decrypt_mode();
    v22 = ccgcm_one_shot();
    if (v17)
    {
      free(v17);
    }

    if (v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = gLogObj;
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446466;
        v47 = "nw_http_decrypt_oblivious_aead_response";
        v48 = 1024;
        LODWORD(v49) = v22;
        _os_log_impl(&dword_181A37000, v23, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", buf, 0x12u);
      }

      if (v20)
      {
        free(v20);
        return 0;
      }
    }

    else
    {
      *v43 = v15;
    }

    return v20;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v47 = "nw_http_decrypt_oblivious_aead_response";
  v48 = 2048;
  v49 = 1;
  v50 = 2048;
  v51 = v15;
  v21 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v21);
  if (!result)
  {
    free(v21);
    goto LABEL_22;
  }

LABEL_159:
  __break(1u);
  return result;
}

void *nw_http_decrypt_chunked_oblivious_aead_response_chunk(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, const void *a5, size_t a6, uint64_t a7, size_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  v59 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v31 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v31, &type, &v51))
    {
      goto LABEL_187;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v51 != 1)
      {
        v32 = __nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null response_buffer, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v33 = type;
      v38 = os_log_type_enabled(v32, type);
      if (!backtrace_string)
      {
        if (v38)
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null response_buffer, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v38)
      {
        goto LABEL_137;
      }

      *buf = 136446466;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v55 = 2082;
      v56 = backtrace_string;
      v39 = "%{public}s called with null response_buffer, dumping backtrace:%{public}s";
      goto LABEL_136;
    }

    v32 = __nwlog_obj();
    v33 = type;
    if (!os_log_type_enabled(v32, type))
    {
      goto LABEL_187;
    }

    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v34 = "%{public}s called with null response_buffer";
LABEL_186:
    _os_log_impl(&dword_181A37000, v32, v33, v34, buf, 0xCu);
    goto LABEL_187;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v31 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v31, &type, &v51))
    {
      goto LABEL_187;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v51 != 1)
      {
        v32 = __nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null response_length, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v33 = type;
      v40 = os_log_type_enabled(v32, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null response_length, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v40)
      {
        goto LABEL_137;
      }

      *buf = 136446466;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v55 = 2082;
      v56 = backtrace_string;
      v39 = "%{public}s called with null response_length, dumping backtrace:%{public}s";
      goto LABEL_136;
    }

    v32 = __nwlog_obj();
    v33 = type;
    if (!os_log_type_enabled(v32, type))
    {
      goto LABEL_187;
    }

    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v34 = "%{public}s called with null response_length";
    goto LABEL_186;
  }

  if (!a5)
  {
    __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v31 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v31, &type, &v51))
    {
      goto LABEL_187;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v51 != 1)
      {
        v32 = __nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null aead_nonce, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v33 = type;
      v41 = os_log_type_enabled(v32, type);
      if (!backtrace_string)
      {
        if (v41)
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null aead_nonce, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v41)
      {
        goto LABEL_137;
      }

      *buf = 136446466;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v55 = 2082;
      v56 = backtrace_string;
      v39 = "%{public}s called with null aead_nonce, dumping backtrace:%{public}s";
      goto LABEL_136;
    }

    v32 = __nwlog_obj();
    v33 = type;
    if (!os_log_type_enabled(v32, type))
    {
      goto LABEL_187;
    }

    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v34 = "%{public}s called with null aead_nonce";
    goto LABEL_186;
  }

  if (!a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v31 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v31, &type, &v51))
    {
      goto LABEL_187;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v51 != 1)
      {
        v32 = __nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null aead_nonce_length, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v33 = type;
      v42 = os_log_type_enabled(v32, type);
      if (!backtrace_string)
      {
        if (v42)
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null aead_nonce_length, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v42)
      {
        goto LABEL_137;
      }

      *buf = 136446466;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v55 = 2082;
      v56 = backtrace_string;
      v39 = "%{public}s called with null aead_nonce_length, dumping backtrace:%{public}s";
      goto LABEL_136;
    }

    v32 = __nwlog_obj();
    v33 = type;
    if (!os_log_type_enabled(v32, type))
    {
      goto LABEL_187;
    }

    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v34 = "%{public}s called with null aead_nonce_length";
    goto LABEL_186;
  }

  if (!a7)
  {
    __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v31 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v31, &type, &v51))
    {
      goto LABEL_187;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v51 != 1)
      {
        v32 = __nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null aead_key, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v33 = type;
      v43 = os_log_type_enabled(v32, type);
      if (!backtrace_string)
      {
        if (v43)
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null aead_key, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v43)
      {
        goto LABEL_137;
      }

      *buf = 136446466;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v55 = 2082;
      v56 = backtrace_string;
      v39 = "%{public}s called with null aead_key, dumping backtrace:%{public}s";
      goto LABEL_136;
    }

    v32 = __nwlog_obj();
    v33 = type;
    if (!os_log_type_enabled(v32, type))
    {
      goto LABEL_187;
    }

    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v34 = "%{public}s called with null aead_key";
    goto LABEL_186;
  }

  if (!a8)
  {
    __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v31 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v31, &type, &v51))
    {
      goto LABEL_187;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v51 != 1)
      {
        v32 = __nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null aead_key_length, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v33 = type;
      v44 = os_log_type_enabled(v32, type);
      if (!backtrace_string)
      {
        if (v44)
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null aead_key_length, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v44)
      {
        goto LABEL_137;
      }

      *buf = 136446466;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v55 = 2082;
      v56 = backtrace_string;
      v39 = "%{public}s called with null aead_key_length, dumping backtrace:%{public}s";
      goto LABEL_136;
    }

    v32 = __nwlog_obj();
    v33 = type;
    if (!os_log_type_enabled(v32, type))
    {
      goto LABEL_187;
    }

    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v34 = "%{public}s called with null aead_key_length";
    goto LABEL_186;
  }

  if (!a9)
  {
    __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v31 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v31, &type, &v51))
    {
      goto LABEL_187;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v51 != 1)
      {
        v32 = __nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null response_nonce, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v33 = type;
      v45 = os_log_type_enabled(v32, type);
      if (!backtrace_string)
      {
        if (v45)
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null response_nonce, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v45)
      {
        goto LABEL_137;
      }

      *buf = 136446466;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v55 = 2082;
      v56 = backtrace_string;
      v39 = "%{public}s called with null response_nonce, dumping backtrace:%{public}s";
      goto LABEL_136;
    }

    v32 = __nwlog_obj();
    v33 = type;
    if (!os_log_type_enabled(v32, type))
    {
      goto LABEL_187;
    }

    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v34 = "%{public}s called with null response_nonce";
    goto LABEL_186;
  }

  if (!a10)
  {
    __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v31 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v31, &type, &v51))
    {
      goto LABEL_187;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v51 != 1)
      {
        v32 = __nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null response_nonce_length, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v33 = type;
      v46 = os_log_type_enabled(v32, type);
      if (!backtrace_string)
      {
        if (v46)
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null response_nonce_length, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v46)
      {
        goto LABEL_137;
      }

      *buf = 136446466;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v55 = 2082;
      v56 = backtrace_string;
      v39 = "%{public}s called with null response_nonce_length, dumping backtrace:%{public}s";
      goto LABEL_136;
    }

    v32 = __nwlog_obj();
    v33 = type;
    if (!os_log_type_enabled(v32, type))
    {
      goto LABEL_187;
    }

    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v34 = "%{public}s called with null response_nonce_length";
    goto LABEL_186;
  }

  if (!a11)
  {
    __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v31 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v31, &type, &v51))
    {
      goto LABEL_187;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v51 != 1)
      {
        v32 = __nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null out_decrypted_length, backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v33 = type;
      v47 = os_log_type_enabled(v32, type);
      if (!backtrace_string)
      {
        if (v47)
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null out_decrypted_length, no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v47)
      {
        goto LABEL_137;
      }

      *buf = 136446466;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v55 = 2082;
      v56 = backtrace_string;
      v39 = "%{public}s called with null out_decrypted_length, dumping backtrace:%{public}s";
      goto LABEL_136;
    }

    v32 = __nwlog_obj();
    v33 = type;
    if (!os_log_type_enabled(v32, type))
    {
      goto LABEL_187;
    }

    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v34 = "%{public}s called with null out_decrypted_length";
    goto LABEL_186;
  }

  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  if (cchpke_params_sizeof_aead_key() != a8)
  {
    __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v31 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v31, &type, &v51))
    {
      goto LABEL_187;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v51 != 1)
      {
        v32 = __nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), backtrace limit exceeded";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      backtrace_string = __nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v33 = type;
      v48 = os_log_type_enabled(v32, type);
      if (!backtrace_string)
      {
        if (v48)
        {
          *buf = 136446210;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v34 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), no backtrace";
          goto LABEL_186;
        }

        goto LABEL_187;
      }

      if (!v48)
      {
        goto LABEL_137;
      }

      *buf = 136446466;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v55 = 2082;
      v56 = backtrace_string;
      v39 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), dumping backtrace:%{public}s";
      goto LABEL_136;
    }

    v32 = __nwlog_obj();
    v33 = type;
    if (!os_log_type_enabled(v32, type))
    {
      goto LABEL_187;
    }

    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v34 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params))";
    goto LABEL_186;
  }

  if (cchpke_params_sizeof_aead_nonce() != a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v31 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v31, &type, &v51))
    {
      goto LABEL_187;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v32 = __nwlog_obj();
      v33 = type;
      if (!os_log_type_enabled(v32, type))
      {
        goto LABEL_187;
      }

      *buf = 136446210;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v34 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params))";
      goto LABEL_186;
    }

    if (v51 != 1)
    {
      v32 = __nwlog_obj();
      v33 = type;
      if (os_log_type_enabled(v32, type))
      {
        *buf = 136446210;
        v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
        v34 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), backtrace limit exceeded";
        goto LABEL_186;
      }

      goto LABEL_187;
    }

    backtrace_string = __nw_create_backtrace_string();
    v32 = __nwlog_obj();
    v33 = type;
    v49 = os_log_type_enabled(v32, type);
    if (!backtrace_string)
    {
      if (v49)
      {
        *buf = 136446210;
        v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
        v34 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), no backtrace";
        goto LABEL_186;
      }

      goto LABEL_187;
    }

    if (!v49)
    {
      goto LABEL_137;
    }

    *buf = 136446466;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v55 = 2082;
    v56 = backtrace_string;
    v39 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), dumping backtrace:%{public}s";
LABEL_136:
    _os_log_impl(&dword_181A37000, v32, v33, v39, buf, 0x16u);
    goto LABEL_137;
  }

  v17 = cchpke_params_sizeof_aead_tag();
  if (a8 <= a6)
  {
    v18 = a6;
  }

  else
  {
    v18 = a8;
  }

  if (v18 == a10)
  {
    v19 = v17;
    v20 = malloc_type_calloc(1uLL, a6, 0xA039DF39uLL);
    if (!v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
      *buf = 136446722;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v55 = 2048;
      v56 = 1;
      v57 = 2048;
      v58 = a6;
      v21 = _os_log_send_and_compose_impl();
      if (__nwlog_should_abort(v21))
      {
        goto LABEL_190;
      }

      free(v21);
    }

    memcpy(v20, a5, a6);
    *&v20[a6 - 8] ^= bswap64(a3);
    if (!v19)
    {
      v35 = __nwlog_obj();
      os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
      *buf = 136446210;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v36 = _os_log_send_and_compose_impl();
      if (__nwlog_should_abort(v36))
      {
        goto LABEL_190;
      }

      free(v36);
    }

    v22 = malloc_type_calloc(1uLL, v19, 0x12D0B690uLL);
    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
      *buf = 136446722;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v55 = 2048;
      v56 = 1;
      v57 = 2048;
      v58 = v19;
      v23 = _os_log_send_and_compose_impl();
      if (__nwlog_should_abort(v23))
      {
        goto LABEL_190;
      }

      free(v23);
    }

    v24 = a2 - v19;
    memcpy(v22, (a1 + a2 - v19), v19);
    if (a2 == v19)
    {
      v25 = 1;
    }

    else
    {
      v25 = a2 - v19;
    }

    v26 = malloc_type_calloc(1uLL, v25, 0x9DE3DD53uLL);
    if (v26)
    {
      goto LABEL_29;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v55 = 2048;
    v56 = 1;
    v57 = 2048;
    v58 = v25;
    v27 = _os_log_send_and_compose_impl();
    if (!__nwlog_should_abort(v27))
    {
      free(v27);
LABEL_29:
      ccaes_gcm_decrypt_mode();
      v28 = ccgcm_one_shot();
      free(v20);
      if (v22)
      {
        free(v22);
      }

      if (v28)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v29 = gLogObj;
        if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
        {
          *buf = 136446466;
          v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
          v55 = 1024;
          LODWORD(v56) = v28;
          _os_log_impl(&dword_181A37000, v29, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", buf, 0x12u);
        }

        if (v26)
        {
          free(v26);
          return 0;
        }
      }

      else
      {
        *a11 = v24;
      }

      return v26;
    }

LABEL_190:
    __break(1u);
  }

  __nwlog_obj();
  *buf = 136446210;
  v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
  v31 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v51 = 0;
  if (!__nwlog_fault(v31, &type, &v51))
  {
    goto LABEL_187;
  }

  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v51 != 1)
    {
      v32 = __nwlog_obj();
      v33 = type;
      if (os_log_type_enabled(v32, type))
      {
        *buf = 136446210;
        v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
        v34 = "%{public}s called with null (response_nonce_length == exported_secret_length), backtrace limit exceeded";
        goto LABEL_186;
      }

      goto LABEL_187;
    }

    backtrace_string = __nw_create_backtrace_string();
    v32 = __nwlog_obj();
    v33 = type;
    v50 = os_log_type_enabled(v32, type);
    if (!backtrace_string)
    {
      if (v50)
      {
        *buf = 136446210;
        v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
        v34 = "%{public}s called with null (response_nonce_length == exported_secret_length), no backtrace";
        goto LABEL_186;
      }

      goto LABEL_187;
    }

    if (v50)
    {
      *buf = 136446466;
      v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
      v55 = 2082;
      v56 = backtrace_string;
      v39 = "%{public}s called with null (response_nonce_length == exported_secret_length), dumping backtrace:%{public}s";
      goto LABEL_136;
    }

LABEL_137:
    free(backtrace_string);
    goto LABEL_187;
  }

  v32 = __nwlog_obj();
  v33 = type;
  if (os_log_type_enabled(v32, type))
  {
    *buf = 136446210;
    v54 = "nw_http_decrypt_chunked_oblivious_aead_response_chunk";
    v34 = "%{public}s called with null (response_nonce_length == exported_secret_length)";
    goto LABEL_186;
  }

LABEL_187:
  if (v31)
  {
    free(v31);
  }

  return 0;
}

uint64_t nw_http_get_standalone_aead_nonce_length()
{
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();

  return cchpke_params_sizeof_aead_nonce();
}

uint64_t nw_http_get_standalone_aead_key_length()
{
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();

  return cchpke_params_sizeof_aead_key();
}

uint64_t nw_http_encrypt_standalone_aead_chunk(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7, size_t a8, size_t *a9)
{
  v50 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v23 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v23, &type, &v42))
    {
      goto LABEL_137;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v42 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null message_buffer, backtrace limit exceeded";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v30 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v30)
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null message_buffer, no backtrace";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      if (!v30)
      {
        goto LABEL_99;
      }

      *buf = 136446466;
      v45 = "nw_http_encrypt_standalone_aead_chunk";
      v46 = 2082;
      v47 = backtrace_string;
      v31 = "%{public}s called with null message_buffer, dumping backtrace:%{public}s";
      goto LABEL_98;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_137;
    }

    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v26 = "%{public}s called with null message_buffer";
LABEL_136:
    _os_log_impl(&dword_181A37000, v24, v25, v26, buf, 0xCu);
    goto LABEL_137;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v23 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v23, &type, &v42))
    {
      goto LABEL_137;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v42 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null message_length, backtrace limit exceeded";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v32 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v32)
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null message_length, no backtrace";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      if (!v32)
      {
        goto LABEL_99;
      }

      *buf = 136446466;
      v45 = "nw_http_encrypt_standalone_aead_chunk";
      v46 = 2082;
      v47 = backtrace_string;
      v31 = "%{public}s called with null message_length, dumping backtrace:%{public}s";
      goto LABEL_98;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_137;
    }

    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v26 = "%{public}s called with null message_length";
    goto LABEL_136;
  }

  if (!a5)
  {
    __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v23 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v23, &type, &v42))
    {
      goto LABEL_137;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v42 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null aead_key, backtrace limit exceeded";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v33 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v33)
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null aead_key, no backtrace";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      if (!v33)
      {
        goto LABEL_99;
      }

      *buf = 136446466;
      v45 = "nw_http_encrypt_standalone_aead_chunk";
      v46 = 2082;
      v47 = backtrace_string;
      v31 = "%{public}s called with null aead_key, dumping backtrace:%{public}s";
      goto LABEL_98;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_137;
    }

    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v26 = "%{public}s called with null aead_key";
    goto LABEL_136;
  }

  if (!a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v23 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v23, &type, &v42))
    {
      goto LABEL_137;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v42 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null aead_key_length, backtrace limit exceeded";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v34 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v34)
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null aead_key_length, no backtrace";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      if (!v34)
      {
        goto LABEL_99;
      }

      *buf = 136446466;
      v45 = "nw_http_encrypt_standalone_aead_chunk";
      v46 = 2082;
      v47 = backtrace_string;
      v31 = "%{public}s called with null aead_key_length, dumping backtrace:%{public}s";
      goto LABEL_98;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_137;
    }

    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v26 = "%{public}s called with null aead_key_length";
    goto LABEL_136;
  }

  if (!a7)
  {
    __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v23 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v23, &type, &v42))
    {
      goto LABEL_137;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v42 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null input_nonce, backtrace limit exceeded";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v35 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v35)
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null input_nonce, no backtrace";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      if (!v35)
      {
        goto LABEL_99;
      }

      *buf = 136446466;
      v45 = "nw_http_encrypt_standalone_aead_chunk";
      v46 = 2082;
      v47 = backtrace_string;
      v31 = "%{public}s called with null input_nonce, dumping backtrace:%{public}s";
      goto LABEL_98;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_137;
    }

    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v26 = "%{public}s called with null input_nonce";
    goto LABEL_136;
  }

  if (!a8)
  {
    __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v23 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v23, &type, &v42))
    {
      goto LABEL_137;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v42 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null aead_nonce_length, backtrace limit exceeded";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v36 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null aead_nonce_length, no backtrace";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      if (!v36)
      {
        goto LABEL_99;
      }

      *buf = 136446466;
      v45 = "nw_http_encrypt_standalone_aead_chunk";
      v46 = 2082;
      v47 = backtrace_string;
      v31 = "%{public}s called with null aead_nonce_length, dumping backtrace:%{public}s";
      goto LABEL_98;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_137;
    }

    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v26 = "%{public}s called with null aead_nonce_length";
    goto LABEL_136;
  }

  if (!a9)
  {
    __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v23 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v23, &type, &v42))
    {
      goto LABEL_137;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v42 != 1)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null out_encrypted_length, backtrace limit exceeded";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      backtrace_string = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v37 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v37)
        {
          *buf = 136446210;
          v45 = "nw_http_encrypt_standalone_aead_chunk";
          v26 = "%{public}s called with null out_encrypted_length, no backtrace";
          goto LABEL_136;
        }

        goto LABEL_137;
      }

      if (!v37)
      {
        goto LABEL_99;
      }

      *buf = 136446466;
      v45 = "nw_http_encrypt_standalone_aead_chunk";
      v46 = 2082;
      v47 = backtrace_string;
      v31 = "%{public}s called with null out_encrypted_length, dumping backtrace:%{public}s";
      goto LABEL_98;
    }

    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
    {
      goto LABEL_137;
    }

    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v26 = "%{public}s called with null out_encrypted_length";
    goto LABEL_136;
  }

  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  v14 = cchpke_params_sizeof_aead_tag();
  if (cchpke_params_sizeof_aead_key() != a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v23 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v23, &type, &v42))
    {
      goto LABEL_137;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
      {
        goto LABEL_137;
      }

      *buf = 136446210;
      v45 = "nw_http_encrypt_standalone_aead_chunk";
      v26 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params))";
      goto LABEL_136;
    }

    if (v42 != 1)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *buf = 136446210;
        v45 = "nw_http_encrypt_standalone_aead_chunk";
        v26 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), backtrace limit exceeded";
        goto LABEL_136;
      }

      goto LABEL_137;
    }

    backtrace_string = __nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v25 = type;
    v38 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v38)
      {
        *buf = 136446210;
        v45 = "nw_http_encrypt_standalone_aead_chunk";
        v26 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), no backtrace";
        goto LABEL_136;
      }

      goto LABEL_137;
    }

    if (!v38)
    {
      goto LABEL_99;
    }

    *buf = 136446466;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v46 = 2082;
    v47 = backtrace_string;
    v31 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), dumping backtrace:%{public}s";
LABEL_98:
    _os_log_impl(&dword_181A37000, v24, v25, v31, buf, 0x16u);
    goto LABEL_99;
  }

  if (cchpke_params_sizeof_aead_nonce() != a8)
  {
    __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v23 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v23, &type, &v42))
    {
      goto LABEL_137;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *buf = 136446210;
        v45 = "nw_http_encrypt_standalone_aead_chunk";
        v26 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params))";
        goto LABEL_136;
      }

LABEL_137:
      if (v23)
      {
        free(v23);
      }

      return 0;
    }

    if (v42 != 1)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *buf = 136446210;
        v45 = "nw_http_encrypt_standalone_aead_chunk";
        v26 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), backtrace limit exceeded";
        goto LABEL_136;
      }

      goto LABEL_137;
    }

    backtrace_string = __nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v25 = type;
    v39 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v39)
      {
        *buf = 136446210;
        v45 = "nw_http_encrypt_standalone_aead_chunk";
        v26 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), no backtrace";
        goto LABEL_136;
      }

      goto LABEL_137;
    }

    if (v39)
    {
      *buf = 136446466;
      v45 = "nw_http_encrypt_standalone_aead_chunk";
      v46 = 2082;
      v47 = backtrace_string;
      v31 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), dumping backtrace:%{public}s";
      goto LABEL_98;
    }

LABEL_99:
    free(backtrace_string);
    goto LABEL_137;
  }

  v15 = malloc_type_calloc(1uLL, a8, 0xE8D8354CuLL);
  v41 = v14;
  if (!v15)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v46 = 2048;
    v47 = 1;
    v48 = 2048;
    v49 = a8;
    v16 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v16);
    if (result)
    {
      goto LABEL_140;
    }

    free(v16);
    v14 = v41;
  }

  memcpy(v15, a7, a8);
  *&v15[a8 - 8] ^= bswap64(a3);
  v18 = v14 + a2;
  if (!(v14 + a2))
  {
    v27 = __nwlog_obj();
    os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v45 = "nw_http_encrypt_standalone_aead_chunk";
    v28 = _os_log_send_and_compose_impl();
    result = __nwlog_should_abort(v28);
    if (result)
    {
      goto LABEL_140;
    }

    free(v28);
    v18 = 0;
  }

  v40 = v18;
  v19 = malloc_type_calloc(1uLL, v18, 0x9B340CA3uLL);
  if (v19)
  {
    goto LABEL_17;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v45 = "nw_http_encrypt_standalone_aead_chunk";
  v46 = 2048;
  v47 = 1;
  v48 = 2048;
  v49 = v40;
  v20 = _os_log_send_and_compose_impl();
  result = __nwlog_should_abort(v20);
  if (!result)
  {
    free(v20);
LABEL_17:
    ccaes_gcm_encrypt_mode();
    v21 = ccgcm_one_shot();
    free(v15);
    if (v21)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446466;
        v45 = "nw_http_encrypt_standalone_aead_chunk";
        v46 = 1024;
        LODWORD(v47) = v21;
        _os_log_impl(&dword_181A37000, v22, OS_LOG_TYPE_ERROR, "%{public}s Encrypt error: %d", buf, 0x12u);
      }

      if (v19)
      {
        free(v19);
        return 0;
      }
    }

    else
    {
      *a9 = v40;
    }

    return v19;
  }

LABEL_140:
  __break(1u);
  return result;
}

void *nw_http_decrypt_standalone_aead_chunk(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7, size_t a8, size_t *a9)
{
  v58 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v33, &type, &v50))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v50 != 1)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null encrypted_buffer, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = type;
      v39 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (v39)
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null encrypted_buffer, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v39)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v53 = "nw_http_decrypt_standalone_aead_chunk";
      v54 = 2082;
      v55 = backtrace_string;
      v40 = "%{public}s called with null encrypted_buffer, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v30 = __nwlog_obj();
    v31 = type;
    if (!os_log_type_enabled(v30, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v32 = "%{public}s called with null encrypted_buffer";
LABEL_155:
    _os_log_impl(&dword_181A37000, v30, v31, v32, buf, 0xCu);
    goto LABEL_156;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v33, &type, &v50))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v50 != 1)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null encrypted_length, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = type;
      v41 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (v41)
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null encrypted_length, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v41)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v53 = "nw_http_decrypt_standalone_aead_chunk";
      v54 = 2082;
      v55 = backtrace_string;
      v40 = "%{public}s called with null encrypted_length, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v30 = __nwlog_obj();
    v31 = type;
    if (!os_log_type_enabled(v30, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v32 = "%{public}s called with null encrypted_length";
    goto LABEL_155;
  }

  if (!a5)
  {
    __nwlog_obj();
    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v33, &type, &v50))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v50 != 1)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null aead_key, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = type;
      v42 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (v42)
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null aead_key, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v42)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v53 = "nw_http_decrypt_standalone_aead_chunk";
      v54 = 2082;
      v55 = backtrace_string;
      v40 = "%{public}s called with null aead_key, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v30 = __nwlog_obj();
    v31 = type;
    if (!os_log_type_enabled(v30, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v32 = "%{public}s called with null aead_key";
    goto LABEL_155;
  }

  if (!a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v33, &type, &v50))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v50 != 1)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null aead_key_length, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = type;
      v43 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (v43)
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null aead_key_length, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v43)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v53 = "nw_http_decrypt_standalone_aead_chunk";
      v54 = 2082;
      v55 = backtrace_string;
      v40 = "%{public}s called with null aead_key_length, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v30 = __nwlog_obj();
    v31 = type;
    if (!os_log_type_enabled(v30, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v32 = "%{public}s called with null aead_key_length";
    goto LABEL_155;
  }

  if (!a7)
  {
    __nwlog_obj();
    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v33, &type, &v50))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v50 != 1)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null input_nonce, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = type;
      v44 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (v44)
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null input_nonce, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v44)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v53 = "nw_http_decrypt_standalone_aead_chunk";
      v54 = 2082;
      v55 = backtrace_string;
      v40 = "%{public}s called with null input_nonce, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v30 = __nwlog_obj();
    v31 = type;
    if (!os_log_type_enabled(v30, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v32 = "%{public}s called with null input_nonce";
    goto LABEL_155;
  }

  if (!a8)
  {
    __nwlog_obj();
    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v33, &type, &v50))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v50 != 1)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null aead_nonce_length, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = type;
      v45 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (v45)
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null aead_nonce_length, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v45)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v53 = "nw_http_decrypt_standalone_aead_chunk";
      v54 = 2082;
      v55 = backtrace_string;
      v40 = "%{public}s called with null aead_nonce_length, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v30 = __nwlog_obj();
    v31 = type;
    if (!os_log_type_enabled(v30, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v32 = "%{public}s called with null aead_nonce_length";
    goto LABEL_155;
  }

  if (!a9)
  {
    __nwlog_obj();
    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v33, &type, &v50))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v50 != 1)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null out_decrypted_length, backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = type;
      v46 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (v46)
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null out_decrypted_length, no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v46)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v53 = "nw_http_decrypt_standalone_aead_chunk";
      v54 = 2082;
      v55 = backtrace_string;
      v40 = "%{public}s called with null out_decrypted_length, dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v30 = __nwlog_obj();
    v31 = type;
    if (!os_log_type_enabled(v30, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v32 = "%{public}s called with null out_decrypted_length";
    goto LABEL_155;
  }

  v14 = a1;
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  if (cchpke_params_sizeof_aead_key() != a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v33, &type, &v50))
    {
      goto LABEL_156;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v50 != 1)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), backtrace limit exceeded";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      backtrace_string = __nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = type;
      v47 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (v47)
        {
          *buf = 136446210;
          v53 = "nw_http_decrypt_standalone_aead_chunk";
          v32 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), no backtrace";
          goto LABEL_155;
        }

        goto LABEL_156;
      }

      if (!v47)
      {
        goto LABEL_114;
      }

      *buf = 136446466;
      v53 = "nw_http_decrypt_standalone_aead_chunk";
      v54 = 2082;
      v55 = backtrace_string;
      v40 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params)), dumping backtrace:%{public}s";
      goto LABEL_113;
    }

    v30 = __nwlog_obj();
    v31 = type;
    if (!os_log_type_enabled(v30, type))
    {
      goto LABEL_156;
    }

    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v32 = "%{public}s called with null (aead_key_length == cchpke_params_sizeof_aead_key(params))";
    goto LABEL_155;
  }

  if (cchpke_params_sizeof_aead_nonce() != a8)
  {
    __nwlog_obj();
    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v33, &type, &v50))
    {
      goto LABEL_156;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (!os_log_type_enabled(v30, type))
      {
        goto LABEL_156;
      }

      *buf = 136446210;
      v53 = "nw_http_decrypt_standalone_aead_chunk";
      v32 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params))";
      goto LABEL_155;
    }

    if (v50 != 1)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *buf = 136446210;
        v53 = "nw_http_decrypt_standalone_aead_chunk";
        v32 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), backtrace limit exceeded";
        goto LABEL_155;
      }

      goto LABEL_156;
    }

    backtrace_string = __nw_create_backtrace_string();
    v30 = __nwlog_obj();
    v31 = type;
    v48 = os_log_type_enabled(v30, type);
    if (!backtrace_string)
    {
      if (v48)
      {
        *buf = 136446210;
        v53 = "nw_http_decrypt_standalone_aead_chunk";
        v32 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), no backtrace";
        goto LABEL_155;
      }

      goto LABEL_156;
    }

    if (!v48)
    {
      goto LABEL_114;
    }

    *buf = 136446466;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v54 = 2082;
    v55 = backtrace_string;
    v40 = "%{public}s called with null (aead_nonce_length == cchpke_params_sizeof_aead_nonce(params)), dumping backtrace:%{public}s";
LABEL_113:
    _os_log_impl(&dword_181A37000, v30, v31, v40, buf, 0x16u);
    goto LABEL_114;
  }

  v15 = cchpke_params_sizeof_aead_tag();
  v16 = a2 > v15;
  v17 = a2 - v15;
  if (!v16)
  {
    __nwlog_obj();
    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v33 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v33, &type, &v50))
    {
      goto LABEL_156;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *buf = 136446210;
        v53 = "nw_http_decrypt_standalone_aead_chunk";
        v32 = "%{public}s called with null (encrypted_length > tag_length)";
        goto LABEL_155;
      }

LABEL_156:
      if (v33)
      {
        free(v33);
      }

      return 0;
    }

    if (v50 != 1)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *buf = 136446210;
        v53 = "nw_http_decrypt_standalone_aead_chunk";
        v32 = "%{public}s called with null (encrypted_length > tag_length), backtrace limit exceeded";
        goto LABEL_155;
      }

      goto LABEL_156;
    }

    backtrace_string = __nw_create_backtrace_string();
    v30 = __nwlog_obj();
    v31 = type;
    v49 = os_log_type_enabled(v30, type);
    if (!backtrace_string)
    {
      if (v49)
      {
        *buf = 136446210;
        v53 = "nw_http_decrypt_standalone_aead_chunk";
        v32 = "%{public}s called with null (encrypted_length > tag_length), no backtrace";
        goto LABEL_155;
      }

      goto LABEL_156;
    }

    if (v49)
    {
      *buf = 136446466;
      v53 = "nw_http_decrypt_standalone_aead_chunk";
      v54 = 2082;
      v55 = backtrace_string;
      v40 = "%{public}s called with null (encrypted_length > tag_length), dumping backtrace:%{public}s";
      goto LABEL_113;
    }

LABEL_114:
    free(backtrace_string);
    goto LABEL_156;
  }

  v18 = v15;
  v19 = malloc_type_calloc(1uLL, a8, 0x688DEAA8uLL);
  if (!v19)
  {
    v20 = v14;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v54 = 2048;
    v55 = 1;
    v56 = 2048;
    v57 = a8;
    v21 = _os_log_send_and_compose_impl();
    if (__nwlog_should_abort(v21))
    {
      goto LABEL_159;
    }

    free(v21);
    v14 = v20;
  }

  memcpy(v19, a7, a8);
  *&v19[a8 - 8] ^= bswap64(a3);
  if (!v18)
  {
    v35 = v14;
    v36 = __nwlog_obj();
    os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v37 = _os_log_send_and_compose_impl();
    if (__nwlog_should_abort(v37))
    {
      goto LABEL_159;
    }

    free(v37);
    v14 = v35;
  }

  v22 = malloc_type_calloc(1uLL, v18, 0xB65EFF18uLL);
  if (!v22)
  {
    v23 = v14;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v54 = 2048;
    v55 = 1;
    v56 = 2048;
    v57 = v18;
    v24 = _os_log_send_and_compose_impl();
    if (__nwlog_should_abort(v24))
    {
      goto LABEL_159;
    }

    free(v24);
    v14 = v23;
  }

  memcpy(v22, (v14 + v17), v18);
  v25 = malloc_type_calloc(1uLL, v17, 0xB0E9A7D7uLL);
  if (!v25)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v53 = "nw_http_decrypt_standalone_aead_chunk";
    v54 = 2048;
    v55 = 1;
    v56 = 2048;
    v57 = v17;
    v26 = _os_log_send_and_compose_impl();
    if (!__nwlog_should_abort(v26))
    {
      free(v26);
      goto LABEL_22;
    }

LABEL_159:
    __break(1u);
  }

LABEL_22:
  ccaes_gcm_decrypt_mode();
  v27 = ccgcm_one_shot();
  free(v19);
  if (v22)
  {
    free(v22);
  }

  if (v27)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v28 = gLogObj;
    if (os_log_type_enabled(gLogObj, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v53 = "nw_http_decrypt_standalone_aead_chunk";
      v54 = 1024;
      LODWORD(v55) = v27;
      _os_log_impl(&dword_181A37000, v28, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", buf, 0x12u);
    }

    if (v25)
    {
      free(v25);
      return 0;
    }
  }

  else
  {
    *a9 = v17;
  }

  return v25;
}

void sub_182926E64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = NWConcrete_nw_proxy_hop;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

NWConcrete_nw_proxy_hop *nw_proxy_hop_create_masque(void *a1)
{
  v33 = *MEMORY[0x1E69E9840];
  v2 = a1;
  if (v2)
  {
    v3 = objc_alloc_init(NWConcrete_nw_proxy_hop);
    v4 = v3;
    if (v3)
    {
      objc_storeStrong(&v3->endpoint, a1);
      if (nw_protocol_masque_get_definition(void)::onceToken[0] != -1)
      {
        dispatch_once(nw_protocol_masque_get_definition(void)::onceToken, &__block_literal_global_27637);
      }

      if (nw_protocol_masque_get_definition(void)::definition && (v5 = os_retain(nw_protocol_masque_get_definition(void)::definition)) != 0)
      {
        v6 = os_retain(v5);
      }

      else
      {
        v6 = 0;
      }

      options = nw_proxy_create_options(v6);
      v8 = v4->options;
      v4->options = options;

      v9 = v4;
      goto LABEL_29;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    *buf = 136446210;
    v30 = "nw_proxy_hop_create_masque";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v11, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v30 = "nw_proxy_hop_create_masque";
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s [nw_proxy_hop init] failed", buf, 0xCu);
        }
      }

      else if (v27 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v15 = type;
        v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *buf = 136446466;
            v30 = "nw_proxy_hop_create_masque";
            v31 = 2082;
            v32 = backtrace_string;
            _os_log_impl(&dword_181A37000, v12, v15, "%{public}s [nw_proxy_hop init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v11)
          {
            goto LABEL_29;
          }

          goto LABEL_28;
        }

        if (v16)
        {
          *buf = 136446210;
          v30 = "nw_proxy_hop_create_masque";
          _os_log_impl(&dword_181A37000, v12, v15, "%{public}s [nw_proxy_hop init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v30 = "nw_proxy_hop_create_masque";
          _os_log_impl(&dword_181A37000, v12, v17, "%{public}s [nw_proxy_hop init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v11)
    {
LABEL_29:

      goto LABEL_30;
    }

LABEL_28:
    free(v11);
    goto LABEL_29;
  }

  v19 = __nwlog_obj();
  *buf = 136446210;
  v30 = "nw_proxy_hop_create_masque";
  v20 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (__nwlog_fault(v20, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v21 = __nwlog_obj();
      v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *buf = 136446210;
        v30 = "nw_proxy_hop_create_masque";
        _os_log_impl(&dword_181A37000, v21, v22, "%{public}s called with null proxy_endpoint", buf, 0xCu);
      }
    }

    else if (v27 == 1)
    {
      v23 = __nw_create_backtrace_string();
      v21 = __nwlog_obj();
      v24 = type;
      v25 = os_log_type_enabled(v21, type);
      if (v23)
      {
        if (v25)
        {
          *buf = 136446466;
          v30 = "nw_proxy_hop_create_masque";
          v31 = 2082;
          v32 = v23;
          _os_log_impl(&dword_181A37000, v21, v24, "%{public}s called with null proxy_endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v23);
        goto LABEL_47;
      }

      if (v25)
      {
        *buf = 136446210;
        v30 = "nw_proxy_hop_create_masque";
        _os_log_impl(&dword_181A37000, v21, v24, "%{public}s called with null proxy_endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v21 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v21, type))
      {
        *buf = 136446210;
        v30 = "nw_proxy_hop_create_masque";
        _os_log_impl(&dword_181A37000, v21, v26, "%{public}s called with null proxy_endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_47:
  if (v20)
  {
    free(v20);
  }

  v4 = 0;
LABEL_30:

  return v4;
}

void nw_proxy_hop_set_masque_version(void *a1, int a2)
{
  v25 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v5 = __nwlog_obj();
    *buf = 136446210;
    v22 = "nw_proxy_hop_set_masque_version";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v22 = "nw_proxy_hop_set_masque_version";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v19 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v22 = "nw_proxy_hop_set_masque_version";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
        {
          goto LABEL_4;
        }

LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *buf = 136446210;
        v22 = "nw_proxy_hop_set_masque_version";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v22 = "nw_proxy_hop_set_masque_version";
        _os_log_impl(&dword_181A37000, v7, v17, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_37:

    goto LABEL_38;
  }

  if (nw_protocol_options_is_masque(v3[5]))
  {
    nw_masque_options_set_version(v4[5], a2);
    goto LABEL_4;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v22 = "nw_proxy_hop_set_masque_version";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
  {
    goto LABEL_38;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v22 = "nw_proxy_hop_set_masque_version";
      _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null nw_protocol_options_is_masque(hop->options)", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v19 != 1)
  {
    v7 = __nwlog_obj();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v22 = "nw_proxy_hop_set_masque_version";
      _os_log_impl(&dword_181A37000, v7, v18, "%{public}s called with null nw_protocol_options_is_masque(hop->options), backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_37;
  }

  v14 = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *buf = 136446210;
      v22 = "nw_proxy_hop_set_masque_version";
      _os_log_impl(&dword_181A37000, v7, v15, "%{public}s called with null nw_protocol_options_is_masque(hop->options), no backtrace", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v16)
  {
    *buf = 136446466;
    v22 = "nw_proxy_hop_set_masque_version";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_181A37000, v7, v15, "%{public}s called with null nw_protocol_options_is_masque(hop->options), dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
  {
    goto LABEL_39;
  }

LABEL_4:
}

void nw_proxy_hop_set_supports_raw_ip(void *a1, char a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *(v3 + 84) = *(v3 + 84) & 0xFE | a2;
    if (nw_protocol_options_is_masque(v3[5]))
    {
      nw_masque_options_set_allow_connect_ip(v4[5], a2);
      if (nw_masque_options_get_version(v4[5]) == 1)
      {
        nw_masque_options_set_version(v4[5], 2);
      }
    }

    goto LABEL_5;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_proxy_hop_set_supports_raw_ip";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_supports_raw_ip";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_proxy_hop_set_supports_raw_ip";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_supports_raw_ip";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_supports_raw_ip";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v6)
  {
    free(v6);
  }

LABEL_5:
}

void nw_proxy_hop_set_supports_udp_listen(void *a1, int a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
    {
      v5 = 64;
    }

    else
    {
      v5 = 0;
    }

    *(v3 + 84) = *(v3 + 84) & 0xBF | v5;
    if (nw_protocol_options_is_masque(v3[5]) && nw_masque_options_get_version(v4[5]) == 1)
    {
      nw_masque_options_set_version(v4[5], 2);
    }

    goto LABEL_8;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_proxy_hop_set_supports_udp_listen";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_proxy_hop_set_supports_udp_listen";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v17 = "nw_proxy_hop_set_supports_udp_listen";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (v12)
      {
        *buf = 136446210;
        v17 = "nw_proxy_hop_set_supports_udp_listen";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_proxy_hop_set_supports_udp_listen";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_25:
  if (v7)
  {
    free(v7);
  }

LABEL_8:
}

void nw_proxy_hop_set_supports_resumption(void *a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    if (a2)
    {
      v4 = 2;
    }

    else
    {
      v4 = 0;
    }

    v3[84] = v3[84] & 0xFD | v4;
    goto LABEL_6;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_proxy_hop_set_supports_resumption";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_supports_resumption";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_proxy_hop_set_supports_resumption";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_supports_resumption";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_supports_resumption";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_6:
}

void nw_proxy_hop_set_resumable_session_agent(void *a1, _OWORD *a2)
{
  v18 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    *(v3 + 8) = *a2;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_proxy_hop_set_resumable_session_agent";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_proxy_hop_set_resumable_session_agent";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_proxy_hop_set_resumable_session_agent";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_proxy_hop_set_resumable_session_agent";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_proxy_hop_set_resumable_session_agent";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v3 = 0;
LABEL_3:
}

void nw_proxy_hop_set_supports_l4s(void *a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    if (a2)
    {
      v4 = 4;
    }

    else
    {
      v4 = 0;
    }

    v3[84] = v3[84] & 0xFB | v4;
    goto LABEL_6;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_proxy_hop_set_supports_l4s";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_supports_l4s";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_proxy_hop_set_supports_l4s";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_supports_l4s";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_supports_l4s";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_6:
}

void nw_proxy_hop_set_use_pqtls(void *a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    if (a2)
    {
      v4 = 8;
    }

    else
    {
      v4 = 0;
    }

    v3[85] = v3[85] & 0xF7 | v4;
    goto LABEL_6;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_proxy_hop_set_use_pqtls";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_use_pqtls";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_proxy_hop_set_use_pqtls";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_use_pqtls";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_use_pqtls";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_6:
}

void nw_proxy_hop_set_enable_multipath(void *a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    if (a2)
    {
      v4 = 8;
    }

    else
    {
      v4 = 0;
    }

    v3[84] = v3[84] & 0xF7 | v4;
    goto LABEL_6;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_proxy_hop_set_enable_multipath";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_enable_multipath";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_proxy_hop_set_enable_multipath";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_enable_multipath";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_enable_multipath";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_6:
}

NWConcrete_nw_proxy_hop *nw_proxy_hop_create_oblivious_http(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v43 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v19 = __nwlog_obj();
    *buf = 136446210;
    v40 = "nw_proxy_hop_create_oblivious_http";
    v20 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v20, &type, &v37))
    {
      goto LABEL_75;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v21 = __nwlog_obj();
      v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *buf = 136446210;
        v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_181A37000, v21, v22, "%{public}s called with null oblivious_config", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v37 != 1)
    {
      v21 = __nwlog_obj();
      v34 = type;
      if (os_log_type_enabled(v21, type))
      {
        *buf = 136446210;
        v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_181A37000, v21, v34, "%{public}s called with null oblivious_config, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_74;
    }

    backtrace_string = __nw_create_backtrace_string();
    v21 = __nwlog_obj();
    v28 = type;
    v29 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (v29)
      {
        *buf = 136446210;
        v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_181A37000, v21, v28, "%{public}s called with null oblivious_config, no backtrace", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v29)
    {
      *buf = 136446466;
      v40 = "nw_proxy_hop_create_oblivious_http";
      v41 = 2082;
      v42 = backtrace_string;
      _os_log_impl(&dword_181A37000, v21, v28, "%{public}s called with null oblivious_config, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_56:

    free(backtrace_string);
    goto LABEL_75;
  }

  if (!a2)
  {
    v23 = __nwlog_obj();
    *buf = 136446210;
    v40 = "nw_proxy_hop_create_oblivious_http";
    v20 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v20, &type, &v37))
    {
      goto LABEL_75;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v21 = __nwlog_obj();
      v24 = type;
      if (os_log_type_enabled(v21, type))
      {
        *buf = 136446210;
        v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_181A37000, v21, v24, "%{public}s called with null oblivious_config_length", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v37 != 1)
    {
      v21 = __nwlog_obj();
      v35 = type;
      if (os_log_type_enabled(v21, type))
      {
        *buf = 136446210;
        v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_181A37000, v21, v35, "%{public}s called with null oblivious_config_length, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_74;
    }

    backtrace_string = __nw_create_backtrace_string();
    v21 = __nwlog_obj();
    v30 = type;
    v31 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (v31)
      {
        *buf = 136446210;
        v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_181A37000, v21, v30, "%{public}s called with null oblivious_config_length, no backtrace", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v31)
    {
      *buf = 136446466;
      v40 = "nw_proxy_hop_create_oblivious_http";
      v41 = 2082;
      v42 = backtrace_string;
      _os_log_impl(&dword_181A37000, v21, v30, "%{public}s called with null oblivious_config_length, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_56;
  }

  if (a3)
  {
    v6 = objc_alloc_init(NWConcrete_nw_proxy_hop);
    if (v6)
    {
      options = nw_oblivious_http_create_options(a1, a2, a3);
      v8 = v6->options;
      v6->options = options;

      v9 = v6;
LABEL_25:

      return v6;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    *buf = 136446210;
    v40 = "nw_proxy_hop_create_oblivious_http";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault(v11, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v40 = "nw_proxy_hop_create_oblivious_http";
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s [nw_proxy_hop init] failed", buf, 0xCu);
        }
      }

      else if (v37 == 1)
      {
        v14 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v15 = type;
        v16 = os_log_type_enabled(v12, type);
        if (v14)
        {
          if (v16)
          {
            *buf = 136446466;
            v40 = "nw_proxy_hop_create_oblivious_http";
            v41 = 2082;
            v42 = v14;
            _os_log_impl(&dword_181A37000, v12, v15, "%{public}s [nw_proxy_hop init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v14);
          if (!v11)
          {
            goto LABEL_25;
          }

          goto LABEL_24;
        }

        if (v16)
        {
          *buf = 136446210;
          v40 = "nw_proxy_hop_create_oblivious_http";
          _os_log_impl(&dword_181A37000, v12, v15, "%{public}s [nw_proxy_hop init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v40 = "nw_proxy_hop_create_oblivious_http";
          _os_log_impl(&dword_181A37000, v12, v17, "%{public}s [nw_proxy_hop init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v11)
    {
      goto LABEL_25;
    }

LABEL_24:
    free(v11);
    goto LABEL_25;
  }

  v25 = __nwlog_obj();
  *buf = 136446210;
  v40 = "nw_proxy_hop_create_oblivious_http";
  v20 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v20, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v21 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v21, type))
      {
        *buf = 136446210;
        v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_181A37000, v21, v26, "%{public}s called with null request_path", buf, 0xCu);
      }

LABEL_74:

      goto LABEL_75;
    }

    if (v37 != 1)
    {
      v21 = __nwlog_obj();
      v36 = type;
      if (os_log_type_enabled(v21, type))
      {
        *buf = 136446210;
        v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_181A37000, v21, v36, "%{public}s called with null request_path, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_74;
    }

    backtrace_string = __nw_create_backtrace_string();
    v21 = __nwlog_obj();
    v32 = type;
    v33 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (v33)
      {
        *buf = 136446210;
        v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_181A37000, v21, v32, "%{public}s called with null request_path, no backtrace", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v33)
    {
      *buf = 136446466;
      v40 = "nw_proxy_hop_create_oblivious_http";
      v41 = 2082;
      v42 = backtrace_string;
      _os_log_impl(&dword_181A37000, v21, v32, "%{public}s called with null request_path, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_56;
  }

LABEL_75:
  if (v20)
  {
    free(v20);
  }

  return 0;
}

NWConcrete_nw_proxy_hop *nw_proxy_hop_create_oblivious_http_with_context(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v45 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v21 = __nwlog_obj();
    *buf = 136446210;
    v42 = "nw_proxy_hop_create_oblivious_http_with_context";
    v22 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v22, &type, &v39))
    {
      goto LABEL_75;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_181A37000, v23, v24, "%{public}s called with null oblivious_config", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v39 != 1)
    {
      v23 = __nwlog_obj();
      v36 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_181A37000, v23, v36, "%{public}s called with null oblivious_config, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_74;
    }

    backtrace_string = __nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v30 = type;
    v31 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v31)
      {
        *buf = 136446210;
        v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_181A37000, v23, v30, "%{public}s called with null oblivious_config, no backtrace", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v31)
    {
      *buf = 136446466;
      v42 = "nw_proxy_hop_create_oblivious_http_with_context";
      v43 = 2082;
      v44 = backtrace_string;
      _os_log_impl(&dword_181A37000, v23, v30, "%{public}s called with null oblivious_config, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_56:

    free(backtrace_string);
    goto LABEL_75;
  }

  if (!a2)
  {
    v25 = __nwlog_obj();
    *buf = 136446210;
    v42 = "nw_proxy_hop_create_oblivious_http_with_context";
    v22 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v22, &type, &v39))
    {
      goto LABEL_75;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_181A37000, v23, v26, "%{public}s called with null oblivious_config_length", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v39 != 1)
    {
      v23 = __nwlog_obj();
      v37 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_181A37000, v23, v37, "%{public}s called with null oblivious_config_length, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_74;
    }

    backtrace_string = __nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v32 = type;
    v33 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v33)
      {
        *buf = 136446210;
        v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_181A37000, v23, v32, "%{public}s called with null oblivious_config_length, no backtrace", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v33)
    {
      *buf = 136446466;
      v42 = "nw_proxy_hop_create_oblivious_http_with_context";
      v43 = 2082;
      v44 = backtrace_string;
      _os_log_impl(&dword_181A37000, v23, v32, "%{public}s called with null oblivious_config_length, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_56;
  }

  if (a3)
  {
    v8 = objc_alloc_init(NWConcrete_nw_proxy_hop);
    if (v8)
    {
      options_with_context = nw_oblivious_http_create_options_with_context(a1, a2, a3, a4);
      options = v8->options;
      v8->options = options_with_context;

      v11 = v8;
LABEL_25:

      return v8;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    *buf = 136446210;
    v42 = "nw_proxy_hop_create_oblivious_http_with_context";
    v13 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (__nwlog_fault(v13, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *buf = 136446210;
          v42 = "nw_proxy_hop_create_oblivious_http_with_context";
          _os_log_impl(&dword_181A37000, v14, v15, "%{public}s [nw_proxy_hop init] failed", buf, 0xCu);
        }
      }

      else if (v39 == 1)
      {
        v16 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v17 = type;
        v18 = os_log_type_enabled(v14, type);
        if (v16)
        {
          if (v18)
          {
            *buf = 136446466;
            v42 = "nw_proxy_hop_create_oblivious_http_with_context";
            v43 = 2082;
            v44 = v16;
            _os_log_impl(&dword_181A37000, v14, v17, "%{public}s [nw_proxy_hop init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v16);
          if (!v13)
          {
            goto LABEL_25;
          }

          goto LABEL_24;
        }

        if (v18)
        {
          *buf = 136446210;
          v42 = "nw_proxy_hop_create_oblivious_http_with_context";
          _os_log_impl(&dword_181A37000, v14, v17, "%{public}s [nw_proxy_hop init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *buf = 136446210;
          v42 = "nw_proxy_hop_create_oblivious_http_with_context";
          _os_log_impl(&dword_181A37000, v14, v19, "%{public}s [nw_proxy_hop init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v13)
    {
      goto LABEL_25;
    }

LABEL_24:
    free(v13);
    goto LABEL_25;
  }

  v27 = __nwlog_obj();
  *buf = 136446210;
  v42 = "nw_proxy_hop_create_oblivious_http_with_context";
  v22 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v39 = 0;
  if (__nwlog_fault(v22, &type, &v39))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v28 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_181A37000, v23, v28, "%{public}s called with null request_path", buf, 0xCu);
      }

LABEL_74:

      goto LABEL_75;
    }

    if (v39 != 1)
    {
      v23 = __nwlog_obj();
      v38 = type;
      if (os_log_type_enabled(v23, type))
      {
        *buf = 136446210;
        v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_181A37000, v23, v38, "%{public}s called with null request_path, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_74;
    }

    backtrace_string = __nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v34 = type;
    v35 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v35)
      {
        *buf = 136446210;
        v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_181A37000, v23, v34, "%{public}s called with null request_path, no backtrace", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v35)
    {
      *buf = 136446466;
      v42 = "nw_proxy_hop_create_oblivious_http_with_context";
      v43 = 2082;
      v44 = backtrace_string;
      _os_log_impl(&dword_181A37000, v23, v34, "%{public}s called with null request_path, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_56;
  }

LABEL_75:
  if (v22)
  {
    free(v22);
  }

  return 0;
}

void nw_proxy_hop_set_enable_chunked_oblivious_http(void *a1, char a2)
{
  v25 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v5 = __nwlog_obj();
    *buf = 136446210;
    v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v19 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
        {
          goto LABEL_4;
        }

LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *buf = 136446210;
        v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
        _os_log_impl(&dword_181A37000, v7, v17, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_37:

    goto LABEL_38;
  }

  if (nw_protocol_options_is_oblivious_http(v3[5]))
  {
    nw_oblivious_http_set_use_chunks(v4[5], a2);
    goto LABEL_4;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
  {
    goto LABEL_38;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
      _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options)", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v19 != 1)
  {
    v7 = __nwlog_obj();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
      _os_log_impl(&dword_181A37000, v7, v18, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options), backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_37;
  }

  v14 = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *buf = 136446210;
      v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
      _os_log_impl(&dword_181A37000, v7, v15, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options), no backtrace", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v16)
  {
    *buf = 136446466;
    v22 = "nw_proxy_hop_set_enable_chunked_oblivious_http";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_181A37000, v7, v15, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options), dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
  {
    goto LABEL_39;
  }

LABEL_4:
}

void nw_proxy_hop_set_oblivious_http_context_id(void *a1, uint64_t a2)
{
  v25 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v5 = __nwlog_obj();
    *buf = 136446210;
    v22 = "nw_proxy_hop_set_oblivious_http_context_id";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v22 = "nw_proxy_hop_set_oblivious_http_context_id";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v19 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v22 = "nw_proxy_hop_set_oblivious_http_context_id";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
        {
          goto LABEL_4;
        }

LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *buf = 136446210;
        v22 = "nw_proxy_hop_set_oblivious_http_context_id";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v22 = "nw_proxy_hop_set_oblivious_http_context_id";
        _os_log_impl(&dword_181A37000, v7, v17, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_37:

    goto LABEL_38;
  }

  if (nw_protocol_options_is_oblivious_http(v3[5]))
  {
    nw_oblivious_http_set_context_id(v4[5], a2);
    goto LABEL_4;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v22 = "nw_proxy_hop_set_oblivious_http_context_id";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
  {
    goto LABEL_38;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v22 = "nw_proxy_hop_set_oblivious_http_context_id";
      _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options)", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v19 != 1)
  {
    v7 = __nwlog_obj();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *buf = 136446210;
      v22 = "nw_proxy_hop_set_oblivious_http_context_id";
      _os_log_impl(&dword_181A37000, v7, v18, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options), backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_37;
  }

  v14 = __nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *buf = 136446210;
      v22 = "nw_proxy_hop_set_oblivious_http_context_id";
      _os_log_impl(&dword_181A37000, v7, v15, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options), no backtrace", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v16)
  {
    *buf = 136446466;
    v22 = "nw_proxy_hop_set_oblivious_http_context_id";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_181A37000, v7, v15, "%{public}s called with null nw_protocol_options_is_oblivious_http(hop->options), dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
  {
    goto LABEL_39;
  }

LABEL_4:
}

void nw_proxy_hop_add_next_hop_host(void *a1, void *a2)
{
  v34 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    v9 = __nwlog_obj();
    *buf = 136446210;
    v31 = "nw_proxy_hop_add_next_hop_host";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v31 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v28 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *buf = 136446466;
          v31 = "nw_proxy_hop_add_next_hop_host";
          v32 = 2082;
          v33 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v10)
        {
          goto LABEL_5;
        }

LABEL_56:
        free(v10);
        goto LABEL_5;
      }

      if (v19)
      {
        *buf = 136446210;
        v31 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v31 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_181A37000, v11, v25, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_54:

    goto LABEL_55;
  }

  if (!v4)
  {
    v13 = __nwlog_obj();
    *buf = 136446210;
    v31 = "nw_proxy_hop_add_next_hop_host";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v31 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null next_hop_host", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v28 != 1)
    {
      v11 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v31 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_181A37000, v11, v26, "%{public}s called with null next_hop_host, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    v20 = __nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v21 = type;
    v22 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v22)
      {
        *buf = 136446210;
        v31 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_181A37000, v11, v21, "%{public}s called with null next_hop_host, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *buf = 136446466;
      v31 = "nw_proxy_hop_add_next_hop_host";
      v32 = 2082;
      v33 = v20;
      _os_log_impl(&dword_181A37000, v11, v21, "%{public}s called with null next_hop_host, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_35;
  }

  v6 = v3[5];
  if (!v6)
  {
    v15 = __nwlog_obj();
    *buf = 136446210;
    v31 = "nw_proxy_hop_add_next_hop_host";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
    {
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v31 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null hop->options", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v28 != 1)
    {
      v11 = __nwlog_obj();
      v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v31 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_181A37000, v11, v27, "%{public}s called with null hop->options, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    v20 = __nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v23 = type;
    v24 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v24)
      {
        *buf = 136446210;
        v31 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_181A37000, v11, v23, "%{public}s called with null hop->options, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v24)
    {
      *buf = 136446466;
      v31 = "nw_proxy_hop_add_next_hop_host";
      v32 = 2082;
      v33 = v20;
      _os_log_impl(&dword_181A37000, v11, v23, "%{public}s called with null hop->options, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_35:

    free(v20);
    if (!v10)
    {
      goto LABEL_5;
    }

    goto LABEL_56;
  }

  v7 = v6;
  v8 = v5;
  _nw_protocol_options_add_proxy_next_hop(v7, v8);

LABEL_5:
}

void nw_proxy_hop_add_extra_header(void *a1, uint64_t a2, uint64_t a3)
{
  v37 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v34 = "nw_proxy_hop_add_extra_header";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31))
    {
      goto LABEL_72;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v31 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v18 = type;
      v19 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *buf = 136446466;
          v34 = "nw_proxy_hop_add_extra_header";
          v35 = 2082;
          v36 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_72:
        if (!v8)
        {
          goto LABEL_6;
        }

LABEL_73:
        free(v8);
        goto LABEL_6;
      }

      if (v19)
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v27 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_181A37000, v9, v27, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_71:

    goto LABEL_72;
  }

  if ((nw_protocol_options_is_masque(v5[5]) & 1) == 0)
  {
    v11 = __nwlog_obj();
    *buf = 136446210;
    v34 = "nw_proxy_hop_add_extra_header";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31))
    {
      goto LABEL_72;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null nw_protocol_options_is_masque(hop->options)", buf, 0xCu);
      }

      goto LABEL_71;
    }

    if (v31 != 1)
    {
      v9 = __nwlog_obj();
      v28 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_181A37000, v9, v28, "%{public}s called with null nw_protocol_options_is_masque(hop->options), backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_71;
    }

    v20 = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v21 = type;
    v22 = os_log_type_enabled(v9, type);
    if (!v20)
    {
      if (v22)
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_181A37000, v9, v21, "%{public}s called with null nw_protocol_options_is_masque(hop->options), no backtrace", buf, 0xCu);
      }

      goto LABEL_71;
    }

    if (v22)
    {
      *buf = 136446466;
      v34 = "nw_proxy_hop_add_extra_header";
      v35 = 2082;
      v36 = v20;
      _os_log_impl(&dword_181A37000, v9, v21, "%{public}s called with null nw_protocol_options_is_masque(hop->options), dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_46;
  }

  if (!a2)
  {
    v13 = __nwlog_obj();
    *buf = 136446210;
    v34 = "nw_proxy_hop_add_extra_header";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31))
    {
      goto LABEL_72;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null header", buf, 0xCu);
      }

      goto LABEL_71;
    }

    if (v31 != 1)
    {
      v9 = __nwlog_obj();
      v29 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_181A37000, v9, v29, "%{public}s called with null header, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_71;
    }

    v20 = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v23 = type;
    v24 = os_log_type_enabled(v9, type);
    if (!v20)
    {
      if (v24)
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_181A37000, v9, v23, "%{public}s called with null header, no backtrace", buf, 0xCu);
      }

      goto LABEL_71;
    }

    if (v24)
    {
      *buf = 136446466;
      v34 = "nw_proxy_hop_add_extra_header";
      v35 = 2082;
      v36 = v20;
      _os_log_impl(&dword_181A37000, v9, v23, "%{public}s called with null header, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_46;
  }

  if (!a3)
  {
    v15 = __nwlog_obj();
    *buf = 136446210;
    v34 = "nw_proxy_hop_add_extra_header";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31))
    {
      goto LABEL_72;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s called with null value", buf, 0xCu);
      }

      goto LABEL_71;
    }

    if (v31 != 1)
    {
      v9 = __nwlog_obj();
      v30 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_181A37000, v9, v30, "%{public}s called with null value, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_71;
    }

    v20 = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v25 = type;
    v26 = os_log_type_enabled(v9, type);
    if (!v20)
    {
      if (v26)
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_add_extra_header";
        _os_log_impl(&dword_181A37000, v9, v25, "%{public}s called with null value, no backtrace", buf, 0xCu);
      }

      goto LABEL_71;
    }

    if (v26)
    {
      *buf = 136446466;
      v34 = "nw_proxy_hop_add_extra_header";
      v35 = 2082;
      v36 = v20;
      _os_log_impl(&dword_181A37000, v9, v25, "%{public}s called with null value, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_46:

    free(v20);
    if (!v8)
    {
      goto LABEL_6;
    }

    goto LABEL_73;
  }

  nw_masque_options_add_extra_header(v6[5], a2, a3);
LABEL_6:
}

void nw_proxy_hop_add_token_header_with_agent_type(void *a1, uint64_t a2, const char *a3, const char *a4, const char *a5, const char *a6)
{
  v66 = *MEMORY[0x1E69E9840];
  v11 = a1;
  v12 = v11;
  if (!v11)
  {
    v14 = __nwlog_obj();
    *buf = 136446210;
    v63 = "nw_proxy_hop_add_token_header_with_agent_type";
    v15 = _os_log_send_and_compose_impl();

    LOBYTE(v60) = 16;
    v61 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v15, &v60, &v61))
    {
      goto LABEL_142;
    }

    if (v60 == 17)
    {
      v16 = __nwlog_obj();
      v17 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v17, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v61 == OS_LOG_TYPE_INFO)
    {
      backtrace_string = __nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v34 = v60;
      v35 = os_log_type_enabled(v16, v60);
      if (backtrace_string)
      {
        if (v35)
        {
          *buf = 136446466;
          v63 = "nw_proxy_hop_add_token_header_with_agent_type";
          v64 = 2082;
          v65 = backtrace_string;
          _os_log_impl(&dword_181A37000, v16, v34, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_142:
        if (!v15)
        {
          goto LABEL_11;
        }

        goto LABEL_143;
      }

      if (v35)
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v34, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v16 = __nwlog_obj();
      v51 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v51, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_138:

    goto LABEL_142;
  }

  if ((nw_protocol_options_is_masque(v11[5]) & 1) == 0)
  {
    v18 = __nwlog_obj();
    *buf = 136446210;
    v63 = "nw_proxy_hop_add_token_header_with_agent_type";
    v15 = _os_log_send_and_compose_impl();

    LOBYTE(v60) = 16;
    v61 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v15, &v60, &v61))
    {
      goto LABEL_142;
    }

    if (v60 == 17)
    {
      v16 = __nwlog_obj();
      v19 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v19, "%{public}s called with null nw_protocol_options_is_masque(hop->options)", buf, 0xCu);
      }

      goto LABEL_138;
    }

    if (v61 != OS_LOG_TYPE_INFO)
    {
      v16 = __nwlog_obj();
      v52 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v52, "%{public}s called with null nw_protocol_options_is_masque(hop->options), backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_138;
    }

    v36 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v37 = v60;
    v38 = os_log_type_enabled(v16, v60);
    if (!v36)
    {
      if (v38)
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v37, "%{public}s called with null nw_protocol_options_is_masque(hop->options), no backtrace", buf, 0xCu);
      }

      goto LABEL_138;
    }

    if (v38)
    {
      *buf = 136446466;
      v63 = "nw_proxy_hop_add_token_header_with_agent_type";
      v64 = 2082;
      v65 = v36;
      _os_log_impl(&dword_181A37000, v16, v37, "%{public}s called with null nw_protocol_options_is_masque(hop->options), dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_86;
  }

  if (!a2)
  {
    v20 = __nwlog_obj();
    *buf = 136446210;
    v63 = "nw_proxy_hop_add_token_header_with_agent_type";
    v15 = _os_log_send_and_compose_impl();

    LOBYTE(v60) = 16;
    v61 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v15, &v60, &v61))
    {
      goto LABEL_142;
    }

    if (v60 == 17)
    {
      v16 = __nwlog_obj();
      v21 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v21, "%{public}s called with null header", buf, 0xCu);
      }

      goto LABEL_138;
    }

    if (v61 != OS_LOG_TYPE_INFO)
    {
      v16 = __nwlog_obj();
      v53 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v53, "%{public}s called with null header, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_138;
    }

    v36 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v39 = v60;
    v40 = os_log_type_enabled(v16, v60);
    if (!v36)
    {
      if (v40)
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v39, "%{public}s called with null header, no backtrace", buf, 0xCu);
      }

      goto LABEL_138;
    }

    if (v40)
    {
      *buf = 136446466;
      v63 = "nw_proxy_hop_add_token_header_with_agent_type";
      v64 = 2082;
      v65 = v36;
      _os_log_impl(&dword_181A37000, v16, v39, "%{public}s called with null header, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_86;
  }

  if (!a3)
  {
    v22 = __nwlog_obj();
    *buf = 136446210;
    v63 = "nw_proxy_hop_add_token_header_with_agent_type";
    v15 = _os_log_send_and_compose_impl();

    LOBYTE(v60) = 16;
    v61 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v15, &v60, &v61))
    {
      goto LABEL_142;
    }

    if (v60 == 17)
    {
      v16 = __nwlog_obj();
      v23 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v23, "%{public}s called with null value_prefix", buf, 0xCu);
      }

      goto LABEL_138;
    }

    if (v61 != OS_LOG_TYPE_INFO)
    {
      v16 = __nwlog_obj();
      v54 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v54, "%{public}s called with null value_prefix, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_138;
    }

    v36 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v41 = v60;
    v42 = os_log_type_enabled(v16, v60);
    if (!v36)
    {
      if (v42)
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v41, "%{public}s called with null value_prefix, no backtrace", buf, 0xCu);
      }

      goto LABEL_138;
    }

    if (v42)
    {
      *buf = 136446466;
      v63 = "nw_proxy_hop_add_token_header_with_agent_type";
      v64 = 2082;
      v65 = v36;
      _os_log_impl(&dword_181A37000, v16, v41, "%{public}s called with null value_prefix, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_86;
  }

  if (!a4)
  {
    v24 = __nwlog_obj();
    *buf = 136446210;
    v63 = "nw_proxy_hop_add_token_header_with_agent_type";
    v15 = _os_log_send_and_compose_impl();

    LOBYTE(v60) = 16;
    v61 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v15, &v60, &v61))
    {
      goto LABEL_142;
    }

    if (v60 == 17)
    {
      v16 = __nwlog_obj();
      v25 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v25, "%{public}s called with null value_suffix", buf, 0xCu);
      }

      goto LABEL_138;
    }

    if (v61 != OS_LOG_TYPE_INFO)
    {
      v16 = __nwlog_obj();
      v55 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v55, "%{public}s called with null value_suffix, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_138;
    }

    v36 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v43 = v60;
    v44 = os_log_type_enabled(v16, v60);
    if (!v36)
    {
      if (v44)
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v43, "%{public}s called with null value_suffix, no backtrace", buf, 0xCu);
      }

      goto LABEL_138;
    }

    if (v44)
    {
      *buf = 136446466;
      v63 = "nw_proxy_hop_add_token_header_with_agent_type";
      v64 = 2082;
      v65 = v36;
      _os_log_impl(&dword_181A37000, v16, v43, "%{public}s called with null value_suffix, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_86;
  }

  if (!a5)
  {
    v26 = __nwlog_obj();
    *buf = 136446210;
    v63 = "nw_proxy_hop_add_token_header_with_agent_type";
    v15 = _os_log_send_and_compose_impl();

    LOBYTE(v60) = 16;
    v61 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v15, &v60, &v61))
    {
      goto LABEL_142;
    }

    if (v60 == 17)
    {
      v16 = __nwlog_obj();
      v27 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v27, "%{public}s called with null agent_domain", buf, 0xCu);
      }

      goto LABEL_138;
    }

    if (v61 != OS_LOG_TYPE_INFO)
    {
      v16 = __nwlog_obj();
      v56 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v56, "%{public}s called with null agent_domain, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_138;
    }

    v36 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v45 = v60;
    v46 = os_log_type_enabled(v16, v60);
    if (!v36)
    {
      if (v46)
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v45, "%{public}s called with null agent_domain, no backtrace", buf, 0xCu);
      }

      goto LABEL_138;
    }

    if (v46)
    {
      *buf = 136446466;
      v63 = "nw_proxy_hop_add_token_header_with_agent_type";
      v64 = 2082;
      v65 = v36;
      _os_log_impl(&dword_181A37000, v16, v45, "%{public}s called with null agent_domain, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_86;
  }

  if (!a6)
  {
    v28 = __nwlog_obj();
    *buf = 136446210;
    v63 = "nw_proxy_hop_add_token_header_with_agent_type";
    v15 = _os_log_send_and_compose_impl();

    LOBYTE(v60) = 16;
    v61 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v15, &v60, &v61))
    {
      goto LABEL_142;
    }

    if (v60 == 17)
    {
      v16 = __nwlog_obj();
      v29 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v29, "%{public}s called with null agent_type", buf, 0xCu);
      }

      goto LABEL_138;
    }

    if (v61 != OS_LOG_TYPE_INFO)
    {
      v16 = __nwlog_obj();
      v57 = v60;
      if (os_log_type_enabled(v16, v60))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v57, "%{public}s called with null agent_type, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_138;
    }

    v36 = __nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v47 = v60;
    v48 = os_log_type_enabled(v16, v60);
    if (!v36)
    {
      if (v48)
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v16, v47, "%{public}s called with null agent_type, no backtrace", buf, 0xCu);
      }

      goto LABEL_138;
    }

    if (v48)
    {
      *buf = 136446466;
      v63 = "nw_proxy_hop_add_token_header_with_agent_type";
      v64 = 2082;
      v65 = v36;
      _os_log_impl(&dword_181A37000, v16, v47, "%{public}s called with null agent_type, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_86:

    goto LABEL_92;
  }

  v60 = 0;
  asprintf(&v60, "%s%s%s%s%s%s%s%s%s%s", a3, "<token=", "{domain=", a5, "}", "[type=", a6, "]", ">", a4);
  if (!v60)
  {
    v30 = __nwlog_obj();
    *buf = 136446210;
    v63 = "nw_proxy_hop_add_token_header_with_agent_type";
    v15 = _os_log_send_and_compose_impl();

    v61 = OS_LOG_TYPE_ERROR;
    v59 = 0;
    if (!__nwlog_fault(v15, &v61, &v59))
    {
      goto LABEL_142;
    }

    if (v61 == OS_LOG_TYPE_FAULT)
    {
      v31 = __nwlog_obj();
      v32 = v61;
      if (os_log_type_enabled(v31, v61))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v31, v32, "%{public}s called with null value", buf, 0xCu);
      }

LABEL_141:

      goto LABEL_142;
    }

    if (v59 != 1)
    {
      v31 = __nwlog_obj();
      v58 = v61;
      if (os_log_type_enabled(v31, v61))
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v31, v58, "%{public}s called with null value, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_141;
    }

    v36 = __nw_create_backtrace_string();
    v31 = __nwlog_obj();
    v49 = v61;
    v50 = os_log_type_enabled(v31, v61);
    if (!v36)
    {
      if (v50)
      {
        *buf = 136446210;
        v63 = "nw_proxy_hop_add_token_header_with_agent_type";
        _os_log_impl(&dword_181A37000, v31, v49, "%{public}s called with null value, no backtrace", buf, 0xCu);
      }

      goto LABEL_141;
    }

    if (v50)
    {
      *buf = 136446466;
      v63 = "nw_proxy_hop_add_token_header_with_agent_type";
      v64 = 2082;
      v65 = v36;
      _os_log_impl(&dword_181A37000, v31, v49, "%{public}s called with null value, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_92:
    free(v36);
    if (!v15)
    {
      goto LABEL_11;
    }

LABEL_143:
    v13 = v15;
    goto LABEL_10;
  }

  nw_masque_options_add_extra_header(v12[5], a2, v60);
  v13 = v60;
  if (v60)
  {
LABEL_10:
    free(v13);
  }

LABEL_11:
}

void nw_proxy_hop_add_token_header(void *a1, uint64_t a2, const char *a3, const char *a4, const unsigned __int8 *a5)
{
  v60 = *MEMORY[0x1E69E9840];
  v9 = a1;
  v10 = v9;
  if (!v9)
  {
    v12 = __nwlog_obj();
    *out = 136446210;
    *&out[4] = "nw_proxy_hop_add_token_header";
    v13 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (!__nwlog_fault(v13, type, &v54))
    {
      goto LABEL_125;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null hop", out, 0xCu);
      }
    }

    else if (v54 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v30 = type[0];
      v31 = os_log_type_enabled(v14, type[0]);
      if (backtrace_string)
      {
        if (v31)
        {
          *out = 136446466;
          *&out[4] = "nw_proxy_hop_add_token_header";
          *&out[12] = 2082;
          *&out[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v14, v30, "%{public}s called with null hop, dumping backtrace:%{public}s", out, 0x16u);
        }

        free(backtrace_string);
LABEL_125:
        if (!v13)
        {
          goto LABEL_10;
        }

        goto LABEL_126;
      }

      if (v31)
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v30, "%{public}s called with null hop, no backtrace", out, 0xCu);
      }
    }

    else
    {
      v14 = __nwlog_obj();
      v45 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v45, "%{public}s called with null hop, backtrace limit exceeded", out, 0xCu);
      }
    }

LABEL_121:

    goto LABEL_125;
  }

  if ((nw_protocol_options_is_masque(v9[5]) & 1) == 0)
  {
    v16 = __nwlog_obj();
    *out = 136446210;
    *&out[4] = "nw_proxy_hop_add_token_header";
    v13 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (!__nwlog_fault(v13, type, &v54))
    {
      goto LABEL_125;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v17 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v17, "%{public}s called with null nw_protocol_options_is_masque(hop->options)", out, 0xCu);
      }

      goto LABEL_121;
    }

    if (v54 != 1)
    {
      v14 = __nwlog_obj();
      v46 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v46, "%{public}s called with null nw_protocol_options_is_masque(hop->options), backtrace limit exceeded", out, 0xCu);
      }

      goto LABEL_121;
    }

    v32 = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v33 = type[0];
    v34 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v34)
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v33, "%{public}s called with null nw_protocol_options_is_masque(hop->options), no backtrace", out, 0xCu);
      }

      goto LABEL_121;
    }

    if (v34)
    {
      *out = 136446466;
      *&out[4] = "nw_proxy_hop_add_token_header";
      *&out[12] = 2082;
      *&out[14] = v32;
      _os_log_impl(&dword_181A37000, v14, v33, "%{public}s called with null nw_protocol_options_is_masque(hop->options), dumping backtrace:%{public}s", out, 0x16u);
    }

    goto LABEL_75;
  }

  if (!a2)
  {
    v18 = __nwlog_obj();
    *out = 136446210;
    *&out[4] = "nw_proxy_hop_add_token_header";
    v13 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (!__nwlog_fault(v13, type, &v54))
    {
      goto LABEL_125;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v19 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v19, "%{public}s called with null header", out, 0xCu);
      }

      goto LABEL_121;
    }

    if (v54 != 1)
    {
      v14 = __nwlog_obj();
      v47 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v47, "%{public}s called with null header, backtrace limit exceeded", out, 0xCu);
      }

      goto LABEL_121;
    }

    v32 = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v35 = type[0];
    v36 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v36)
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v35, "%{public}s called with null header, no backtrace", out, 0xCu);
      }

      goto LABEL_121;
    }

    if (v36)
    {
      *out = 136446466;
      *&out[4] = "nw_proxy_hop_add_token_header";
      *&out[12] = 2082;
      *&out[14] = v32;
      _os_log_impl(&dword_181A37000, v14, v35, "%{public}s called with null header, dumping backtrace:%{public}s", out, 0x16u);
    }

    goto LABEL_75;
  }

  if (!a3)
  {
    v20 = __nwlog_obj();
    *out = 136446210;
    *&out[4] = "nw_proxy_hop_add_token_header";
    v13 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (!__nwlog_fault(v13, type, &v54))
    {
      goto LABEL_125;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v21 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v21, "%{public}s called with null value_prefix", out, 0xCu);
      }

      goto LABEL_121;
    }

    if (v54 != 1)
    {
      v14 = __nwlog_obj();
      v48 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v48, "%{public}s called with null value_prefix, backtrace limit exceeded", out, 0xCu);
      }

      goto LABEL_121;
    }

    v32 = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v37 = type[0];
    v38 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v38)
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v37, "%{public}s called with null value_prefix, no backtrace", out, 0xCu);
      }

      goto LABEL_121;
    }

    if (v38)
    {
      *out = 136446466;
      *&out[4] = "nw_proxy_hop_add_token_header";
      *&out[12] = 2082;
      *&out[14] = v32;
      _os_log_impl(&dword_181A37000, v14, v37, "%{public}s called with null value_prefix, dumping backtrace:%{public}s", out, 0x16u);
    }

    goto LABEL_75;
  }

  if (!a4)
  {
    v22 = __nwlog_obj();
    *out = 136446210;
    *&out[4] = "nw_proxy_hop_add_token_header";
    v13 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (!__nwlog_fault(v13, type, &v54))
    {
      goto LABEL_125;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v23 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v23, "%{public}s called with null value_suffix", out, 0xCu);
      }

      goto LABEL_121;
    }

    if (v54 != 1)
    {
      v14 = __nwlog_obj();
      v49 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v49, "%{public}s called with null value_suffix, backtrace limit exceeded", out, 0xCu);
      }

      goto LABEL_121;
    }

    v32 = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v39 = type[0];
    v40 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v40)
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v39, "%{public}s called with null value_suffix, no backtrace", out, 0xCu);
      }

      goto LABEL_121;
    }

    if (v40)
    {
      *out = 136446466;
      *&out[4] = "nw_proxy_hop_add_token_header";
      *&out[12] = 2082;
      *&out[14] = v32;
      _os_log_impl(&dword_181A37000, v14, v39, "%{public}s called with null value_suffix, dumping backtrace:%{public}s", out, 0x16u);
    }

    goto LABEL_75;
  }

  if (!a5)
  {
    v24 = __nwlog_obj();
    *out = 136446210;
    *&out[4] = "nw_proxy_hop_add_token_header";
    v13 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (!__nwlog_fault(v13, type, &v54))
    {
      goto LABEL_125;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v25 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v25, "%{public}s called with null token_agent", out, 0xCu);
      }

      goto LABEL_121;
    }

    if (v54 != 1)
    {
      v14 = __nwlog_obj();
      v50 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v50, "%{public}s called with null token_agent, backtrace limit exceeded", out, 0xCu);
      }

      goto LABEL_121;
    }

    v32 = __nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v41 = type[0];
    v42 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v42)
      {
        *out = 136446210;
        *&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v14, v41, "%{public}s called with null token_agent, no backtrace", out, 0xCu);
      }

      goto LABEL_121;
    }

    if (v42)
    {
      *out = 136446466;
      *&out[4] = "nw_proxy_hop_add_token_header";
      *&out[12] = 2082;
      *&out[14] = v32;
      _os_log_impl(&dword_181A37000, v14, v41, "%{public}s called with null token_agent, dumping backtrace:%{public}s", out, 0x16u);
    }

LABEL_75:

    goto LABEL_81;
  }

  memset(out, 0, sizeof(out));
  uuid_unparse(a5, out);
  v54 = 0;
  asprintf(&v54, "%s%s%s%s%s", a3, "<token=", out, ">", a4);
  if (!v54)
  {
    v26 = __nwlog_obj();
    *type = 136446210;
    v56 = "nw_proxy_hop_add_token_header";
    v13 = _os_log_send_and_compose_impl();

    v53 = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (!__nwlog_fault(v13, &v53, &v52))
    {
      goto LABEL_125;
    }

    if (v53 == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = v53;
      if (os_log_type_enabled(v27, v53))
      {
        *type = 136446210;
        v56 = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v27, v28, "%{public}s called with null value", type, 0xCu);
      }

LABEL_124:

      goto LABEL_125;
    }

    if (v52 != 1)
    {
      v27 = __nwlog_obj();
      v51 = v53;
      if (os_log_type_enabled(v27, v53))
      {
        *type = 136446210;
        v56 = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v27, v51, "%{public}s called with null value, backtrace limit exceeded", type, 0xCu);
      }

      goto LABEL_124;
    }

    v32 = __nw_create_backtrace_string();
    v27 = __nwlog_obj();
    v43 = v53;
    v44 = os_log_type_enabled(v27, v53);
    if (!v32)
    {
      if (v44)
      {
        *type = 136446210;
        v56 = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A37000, v27, v43, "%{public}s called with null value, no backtrace", type, 0xCu);
      }

      goto LABEL_124;
    }

    if (v44)
    {
      *type = 136446466;
      v56 = "nw_proxy_hop_add_token_header";
      v57 = 2082;
      v58 = v32;
      _os_log_impl(&dword_181A37000, v27, v43, "%{public}s called with null value, dumping backtrace:%{public}s", type, 0x16u);
    }

LABEL_81:
    free(v32);
    if (!v13)
    {
      goto LABEL_10;
    }

LABEL_126:
    v11 = v13;
    goto LABEL_9;
  }

  nw_masque_options_add_extra_header(v10[5], a2, v54);
  v11 = v54;
  if (v54)
  {
LABEL_9:
    free(v11);
  }

LABEL_10:
}

void nw_proxy_hop_add_server_raw_public_key(void *a1, const UInt8 *a2, CFIndex a3)
{
  v40 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    v10 = __nwlog_obj();
    *buf = 136446210;
    v37 = "nw_proxy_hop_add_server_raw_public_key";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v11, &type, &v34))
    {
      goto LABEL_75;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v37 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v12, v13, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v34 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v21 = type;
      v22 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *buf = 136446466;
          v37 = "nw_proxy_hop_add_server_raw_public_key";
          v38 = 2082;
          v39 = backtrace_string;
          _os_log_impl(&dword_181A37000, v12, v21, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_75:
        if (!v11)
        {
          goto LABEL_9;
        }

LABEL_76:
        free(v11);
        goto LABEL_9;
      }

      if (v22)
      {
        *buf = 136446210;
        v37 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v12, v21, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v12 = __nwlog_obj();
      v30 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v37 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v12, v30, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_74:

    goto LABEL_75;
  }

  if ((nw_protocol_options_is_masque(*(v5 + 5)) & 1) == 0)
  {
    v14 = __nwlog_obj();
    *buf = 136446210;
    v37 = "nw_proxy_hop_add_server_raw_public_key";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v11, &type, &v34))
    {
      goto LABEL_75;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v37 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v12, v15, "%{public}s called with null nw_protocol_options_is_masque(hop->options)", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v34 != 1)
    {
      v12 = __nwlog_obj();
      v31 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v37 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v12, v31, "%{public}s called with null nw_protocol_options_is_masque(hop->options), backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_74;
    }

    v23 = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v24 = type;
    v25 = os_log_type_enabled(v12, type);
    if (!v23)
    {
      if (v25)
      {
        *buf = 136446210;
        v37 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v12, v24, "%{public}s called with null nw_protocol_options_is_masque(hop->options), no backtrace", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v25)
    {
      *buf = 136446466;
      v37 = "nw_proxy_hop_add_server_raw_public_key";
      v38 = 2082;
      v39 = v23;
      _os_log_impl(&dword_181A37000, v12, v24, "%{public}s called with null nw_protocol_options_is_masque(hop->options), dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_49;
  }

  if (!a2)
  {
    v16 = __nwlog_obj();
    *buf = 136446210;
    v37 = "nw_proxy_hop_add_server_raw_public_key";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v11, &type, &v34))
    {
      goto LABEL_75;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v37 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v12, v17, "%{public}s called with null key_bytes", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v34 != 1)
    {
      v12 = __nwlog_obj();
      v32 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v37 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v12, v32, "%{public}s called with null key_bytes, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_74;
    }

    v23 = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v26 = type;
    v27 = os_log_type_enabled(v12, type);
    if (!v23)
    {
      if (v27)
      {
        *buf = 136446210;
        v37 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v12, v26, "%{public}s called with null key_bytes, no backtrace", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v27)
    {
      *buf = 136446466;
      v37 = "nw_proxy_hop_add_server_raw_public_key";
      v38 = 2082;
      v39 = v23;
      _os_log_impl(&dword_181A37000, v12, v26, "%{public}s called with null key_bytes, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_49;
  }

  if (!a3)
  {
    v18 = __nwlog_obj();
    *buf = 136446210;
    v37 = "nw_proxy_hop_add_server_raw_public_key";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v11, &type, &v34))
    {
      goto LABEL_75;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v37 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v12, v19, "%{public}s called with null key_length", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v34 != 1)
    {
      v12 = __nwlog_obj();
      v33 = type;
      if (os_log_type_enabled(v12, type))
      {
        *buf = 136446210;
        v37 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v12, v33, "%{public}s called with null key_length, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_74;
    }

    v23 = __nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v28 = type;
    v29 = os_log_type_enabled(v12, type);
    if (!v23)
    {
      if (v29)
      {
        *buf = 136446210;
        v37 = "nw_proxy_hop_add_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v12, v28, "%{public}s called with null key_length, no backtrace", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v29)
    {
      *buf = 136446466;
      v37 = "nw_proxy_hop_add_server_raw_public_key";
      v38 = 2082;
      v39 = v23;
      _os_log_impl(&dword_181A37000, v12, v28, "%{public}s called with null key_length, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_49:

    free(v23);
    if (!v11)
    {
      goto LABEL_9;
    }

    goto LABEL_76;
  }

  v7 = *MEMORY[0x1E695E480];
  if (!v6[7])
  {
    v8 = *MEMORY[0x1E695E480];
    v6[7] = CFArrayCreateMutable(v7, 0, MEMORY[0x1E695E9C0]);
    v7 = v8;
  }

  v9 = CFDataCreate(v7, a2, a3);
  CFArrayAppendValue(v6[7], v9);
  if (v9)
  {
    CFRelease(v9);
  }

LABEL_9:
}

void nw_proxy_hop_set_server_raw_public_key(void *a1, const UInt8 *a2, CFIndex a3)
{
  v37 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v34 = "nw_proxy_hop_set_server_raw_public_key";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31))
    {
      goto LABEL_72;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v31 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v18 = type;
      v19 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *buf = 136446466;
          v34 = "nw_proxy_hop_set_server_raw_public_key";
          v35 = 2082;
          v36 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_72:
        if (!v8)
        {
          goto LABEL_6;
        }

LABEL_73:
        free(v8);
        goto LABEL_6;
      }

      if (v19)
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v27 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v9, v27, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_71:

    goto LABEL_72;
  }

  if ((nw_protocol_options_is_masque(v5[5]) & 1) == 0)
  {
    v11 = __nwlog_obj();
    *buf = 136446210;
    v34 = "nw_proxy_hop_set_server_raw_public_key";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31))
    {
      goto LABEL_72;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null nw_protocol_options_is_masque(hop->options)", buf, 0xCu);
      }

      goto LABEL_71;
    }

    if (v31 != 1)
    {
      v9 = __nwlog_obj();
      v28 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v9, v28, "%{public}s called with null nw_protocol_options_is_masque(hop->options), backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_71;
    }

    v20 = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v21 = type;
    v22 = os_log_type_enabled(v9, type);
    if (!v20)
    {
      if (v22)
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v9, v21, "%{public}s called with null nw_protocol_options_is_masque(hop->options), no backtrace", buf, 0xCu);
      }

      goto LABEL_71;
    }

    if (v22)
    {
      *buf = 136446466;
      v34 = "nw_proxy_hop_set_server_raw_public_key";
      v35 = 2082;
      v36 = v20;
      _os_log_impl(&dword_181A37000, v9, v21, "%{public}s called with null nw_protocol_options_is_masque(hop->options), dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_46;
  }

  if (!a2)
  {
    v13 = __nwlog_obj();
    *buf = 136446210;
    v34 = "nw_proxy_hop_set_server_raw_public_key";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31))
    {
      goto LABEL_72;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null key_bytes", buf, 0xCu);
      }

      goto LABEL_71;
    }

    if (v31 != 1)
    {
      v9 = __nwlog_obj();
      v29 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v9, v29, "%{public}s called with null key_bytes, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_71;
    }

    v20 = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v23 = type;
    v24 = os_log_type_enabled(v9, type);
    if (!v20)
    {
      if (v24)
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v9, v23, "%{public}s called with null key_bytes, no backtrace", buf, 0xCu);
      }

      goto LABEL_71;
    }

    if (v24)
    {
      *buf = 136446466;
      v34 = "nw_proxy_hop_set_server_raw_public_key";
      v35 = 2082;
      v36 = v20;
      _os_log_impl(&dword_181A37000, v9, v23, "%{public}s called with null key_bytes, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_46;
  }

  if (!a3)
  {
    v15 = __nwlog_obj();
    *buf = 136446210;
    v34 = "nw_proxy_hop_set_server_raw_public_key";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v8, &type, &v31))
    {
      goto LABEL_72;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s called with null key_length", buf, 0xCu);
      }

      goto LABEL_71;
    }

    if (v31 != 1)
    {
      v9 = __nwlog_obj();
      v30 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v9, v30, "%{public}s called with null key_length, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_71;
    }

    v20 = __nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v25 = type;
    v26 = os_log_type_enabled(v9, type);
    if (!v20)
    {
      if (v26)
      {
        *buf = 136446210;
        v34 = "nw_proxy_hop_set_server_raw_public_key";
        _os_log_impl(&dword_181A37000, v9, v25, "%{public}s called with null key_length, no backtrace", buf, 0xCu);
      }

      goto LABEL_71;
    }

    if (v26)
    {
      *buf = 136446466;
      v34 = "nw_proxy_hop_set_server_raw_public_key";
      v35 = 2082;
      v36 = v20;
      _os_log_impl(&dword_181A37000, v9, v25, "%{public}s called with null key_length, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_46:

    free(v20);
    if (!v8)
    {
      goto LABEL_6;
    }

    goto LABEL_73;
  }

  nw_proxy_hop_add_server_raw_public_key(v6, a2, a3);
LABEL_6:
}

void nw_proxy_hop_set_client_identity_reference(void *a1, const void *a2)
{
  v26 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v6 = __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_proxy_hop_set_client_identity_reference";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
    {
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v23 = "nw_proxy_hop_set_client_identity_reference";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v23 = "nw_proxy_hop_set_client_identity_reference";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v7)
        {
          goto LABEL_6;
        }

LABEL_41:
        free(v7);
        goto LABEL_6;
      }

      if (v14)
      {
        *buf = 136446210;
        v23 = "nw_proxy_hop_set_client_identity_reference";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v23 = "nw_proxy_hop_set_client_identity_reference";
        _os_log_impl(&dword_181A37000, v8, v18, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_39:

    goto LABEL_40;
  }

  if (a2)
  {
    v5 = v3[8];
    if (v5)
    {
      CFRelease(v5);
      v4[8] = 0;
    }

    v4[8] = CFRetain(a2);
    goto LABEL_6;
  }

  v10 = __nwlog_obj();
  *buf = 136446210;
  v23 = "nw_proxy_hop_set_client_identity_reference";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20))
  {
    goto LABEL_40;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *buf = 136446210;
      v23 = "nw_proxy_hop_set_client_identity_reference";
      _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null persistent_reference", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v20 != 1)
  {
    v8 = __nwlog_obj();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *buf = 136446210;
      v23 = "nw_proxy_hop_set_client_identity_reference";
      _os_log_impl(&dword_181A37000, v8, v19, "%{public}s called with null persistent_reference, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_39;
  }

  v15 = __nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *buf = 136446210;
      v23 = "nw_proxy_hop_set_client_identity_reference";
      _os_log_impl(&dword_181A37000, v8, v16, "%{public}s called with null persistent_reference, no backtrace", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v17)
  {
    *buf = 136446466;
    v23 = "nw_proxy_hop_set_client_identity_reference";
    v24 = 2082;
    v25 = v15;
    _os_log_impl(&dword_181A37000, v8, v16, "%{public}s called with null persistent_reference, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
  {
    goto LABEL_41;
  }

LABEL_6:
}

void nw_proxy_hop_add_client_certificate_reference(void *a1, const void *a2)
{
  v26 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v6 = __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_proxy_hop_add_client_certificate_reference";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
    {
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v23 = "nw_proxy_hop_add_client_certificate_reference";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v23 = "nw_proxy_hop_add_client_certificate_reference";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v7)
        {
          goto LABEL_6;
        }

LABEL_41:
        free(v7);
        goto LABEL_6;
      }

      if (v14)
      {
        *buf = 136446210;
        v23 = "nw_proxy_hop_add_client_certificate_reference";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v23 = "nw_proxy_hop_add_client_certificate_reference";
        _os_log_impl(&dword_181A37000, v8, v18, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_39:

    goto LABEL_40;
  }

  if (a2)
  {
    Mutable = *(v3 + 9);
    if (!Mutable)
    {
      Mutable = CFArrayCreateMutable(*MEMORY[0x1E695E480], 0, MEMORY[0x1E695E9C0]);
      v4[9] = Mutable;
    }

    CFArrayAppendValue(Mutable, a2);
    goto LABEL_6;
  }

  v10 = __nwlog_obj();
  *buf = 136446210;
  v23 = "nw_proxy_hop_add_client_certificate_reference";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20))
  {
    goto LABEL_40;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *buf = 136446210;
      v23 = "nw_proxy_hop_add_client_certificate_reference";
      _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null persistent_reference", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v20 != 1)
  {
    v8 = __nwlog_obj();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *buf = 136446210;
      v23 = "nw_proxy_hop_add_client_certificate_reference";
      _os_log_impl(&dword_181A37000, v8, v19, "%{public}s called with null persistent_reference, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_39;
  }

  v15 = __nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *buf = 136446210;
      v23 = "nw_proxy_hop_add_client_certificate_reference";
      _os_log_impl(&dword_181A37000, v8, v16, "%{public}s called with null persistent_reference, no backtrace", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v17)
  {
    *buf = 136446466;
    v23 = "nw_proxy_hop_add_client_certificate_reference";
    v24 = 2082;
    v25 = v15;
    _os_log_impl(&dword_181A37000, v8, v16, "%{public}s called with null persistent_reference, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
  {
    goto LABEL_41;
  }

LABEL_6:
}

void nw_proxy_hop_set_use_x25519(void *a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    if (a2)
    {
      v4 = 0x80;
    }

    else
    {
      v4 = 0;
    }

    v3[84] = v4 & 0x80 | v3[84] & 0x7F;
    goto LABEL_6;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_proxy_hop_set_use_x25519";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_use_x25519";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_proxy_hop_set_use_x25519";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_use_x25519";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_use_x25519";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_6:
}

void nw_proxy_hop_set_client_identity_is_raw_public_key(void *a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    if (a2)
    {
      v4 = 4;
    }

    else
    {
      v4 = 0;
    }

    v3[85] = v3[85] & 0xFB | v4;
    goto LABEL_6;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_proxy_hop_set_client_identity_is_raw_public_key";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_client_identity_is_raw_public_key";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_proxy_hop_set_client_identity_is_raw_public_key";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_client_identity_is_raw_public_key";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_client_identity_is_raw_public_key";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_6:
}

void nw_proxy_hop_set_trust_certs(void *a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    if (a2)
    {
      v4 = 16;
    }

    else
    {
      v4 = 0;
    }

    v3[84] = v3[84] & 0xEF | v4;
    goto LABEL_6;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_proxy_hop_set_trust_certs";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_trust_certs";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_proxy_hop_set_trust_certs";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_trust_certs";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_trust_certs";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_6:
}

void nw_proxy_hop_set_enable_demux(void *a1, char a2)
{
  v18 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    v3[85] = v3[85] & 0xFE | a2;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_proxy_hop_set_enable_demux";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_proxy_hop_set_enable_demux";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_proxy_hop_set_enable_demux";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_proxy_hop_set_enable_demux";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_proxy_hop_set_enable_demux";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v3 = 0;
LABEL_3:
}

void nw_proxy_hop_set_idle_timeout(void *a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    v4 = v3[85];
    v3[85] = v4 & 0xDF;
    *(v3 + 20) = a2;
    if (!a2)
    {
      v3[85] = v4 | 0x20;
    }

    goto LABEL_4;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_proxy_hop_set_idle_timeout";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_idle_timeout";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_proxy_hop_set_idle_timeout";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_idle_timeout";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_idle_timeout";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_21:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_4:
}

void nw_proxy_hop_disable_keepalives(void *a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    if (a2)
    {
      v4 = 64;
    }

    else
    {
      v4 = 0;
    }

    v3[85] = v3[85] & 0xBF | v4;
    goto LABEL_6;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_proxy_hop_disable_keepalives";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_disable_keepalives";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_proxy_hop_disable_keepalives";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_disable_keepalives";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_disable_keepalives";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_6:
}

void nw_proxy_hop_set_ignore_path_errors(void *a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    if (a2)
    {
      v4 = 0x80;
    }

    else
    {
      v4 = 0;
    }

    v3[85] = v4 & 0x80 | v3[85] & 0x7F;
    goto LABEL_6;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_proxy_hop_set_ignore_path_errors";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_ignore_path_errors";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_proxy_hop_set_ignore_path_errors";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_ignore_path_errors";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_ignore_path_errors";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_6:
}

void nw_proxy_hop_supports_udp_proxying_over_http2(void *a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    if (a2)
    {
      v4 = 2;
    }

    else
    {
      v4 = 0;
    }

    v3[85] = v3[85] & 0xFD | v4;
    goto LABEL_6;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_proxy_hop_supports_udp_proxying_over_http2";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_supports_udp_proxying_over_http2";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_proxy_hop_supports_udp_proxying_over_http2";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_supports_udp_proxying_over_http2";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_supports_udp_proxying_over_http2";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_6:
}

void nw_proxy_hop_set_allow_redirects(void *a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    if (a2)
    {
      v4 = 16;
    }

    else
    {
      v4 = 0;
    }

    v3[85] = v3[85] & 0xEF | v4;
    goto LABEL_6;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_proxy_hop_set_allow_redirects";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_allow_redirects";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null hop", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_proxy_hop_set_allow_redirects";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_allow_redirects";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_proxy_hop_set_allow_redirects";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_6:
}

NWConcrete_nw_proxy_config *nw_proxy_config_create_default_privacy_proxy(void *a1)
{
  v1 = a1;
  v2 = networkd_settings_get_BOOL(nw_setting_disable_swift_tls_privacy_proxy);
  privacy_proxy_internal = nw_proxy_config_create_privacy_proxy_internal(v1, !v2);

  return privacy_proxy_internal;
}

NWConcrete_nw_proxy_config *nw_proxy_config_create_privacy_proxy_internal(void *a1, int a2)
{
  v128 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v101 = __nwlog_obj();
    *buf = 136446210;
    v125 = "nw_proxy_config_create_privacy_proxy_internal";
    v102 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v122 = 0;
    if (!__nwlog_fault(v102, &type, &v122))
    {
      goto LABEL_260;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v103 = __nwlog_obj();
      v104 = type;
      if (os_log_type_enabled(v103, type))
      {
        *buf = 136446210;
        v125 = "nw_proxy_config_create_privacy_proxy_internal";
        _os_log_impl(&dword_181A37000, v103, v104, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v122 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v103 = __nwlog_obj();
      v108 = type;
      v109 = os_log_type_enabled(v103, type);
      if (backtrace_string)
      {
        if (v109)
        {
          *buf = 136446466;
          v125 = "nw_proxy_config_create_privacy_proxy_internal";
          v126 = 2082;
          v127 = backtrace_string;
          _os_log_impl(&dword_181A37000, v103, v108, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v102)
        {
          goto LABEL_262;
        }

        goto LABEL_261;
      }

      if (v109)
      {
        *buf = 136446210;
        v125 = "nw_proxy_config_create_privacy_proxy_internal";
        _os_log_impl(&dword_181A37000, v103, v108, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v103 = __nwlog_obj();
      v113 = type;
      if (os_log_type_enabled(v103, type))
      {
        *buf = 136446210;
        v125 = "nw_proxy_config_create_privacy_proxy_internal";
        _os_log_impl(&dword_181A37000, v103, v113, "%{public}s called with null array, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_259;
  }

  count = _nw_array_get_count(v3);
  v7 = count;
  if (!count)
  {
    v105 = __nwlog_obj();
    *buf = 136446210;
    v125 = "nw_proxy_config_create_privacy_proxy_internal";
    v102 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v122 = 0;
    if (!__nwlog_fault(v102, &type, &v122))
    {
      goto LABEL_260;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v103 = __nwlog_obj();
      v106 = type;
      if (os_log_type_enabled(v103, type))
      {
        *buf = 136446210;
        v125 = "nw_proxy_config_create_privacy_proxy_internal";
        _os_log_impl(&dword_181A37000, v103, v106, "%{public}s called with null (hop_count > 0)", buf, 0xCu);
      }
    }

    else if (v122 == 1)
    {
      v110 = __nw_create_backtrace_string();
      v103 = __nwlog_obj();
      v111 = type;
      v112 = os_log_type_enabled(v103, type);
      if (v110)
      {
        if (v112)
        {
          *buf = 136446466;
          v125 = "nw_proxy_config_create_privacy_proxy_internal";
          v126 = 2082;
          v127 = v110;
          _os_log_impl(&dword_181A37000, v103, v111, "%{public}s called with null (hop_count > 0), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v110);
LABEL_260:
        if (!v102)
        {
LABEL_262:
          v22 = 0;
          goto LABEL_226;
        }

LABEL_261:
        free(v102);
        goto LABEL_262;
      }

      if (v112)
      {
        *buf = 136446210;
        v125 = "nw_proxy_config_create_privacy_proxy_internal";
        _os_log_impl(&dword_181A37000, v103, v111, "%{public}s called with null (hop_count > 0), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v103 = __nwlog_obj();
      v114 = type;
      if (os_log_type_enabled(v103, type))
      {
        *buf = 136446210;
        v125 = "nw_proxy_config_create_privacy_proxy_internal";
        _os_log_impl(&dword_181A37000, v103, v114, "%{public}s called with null (hop_count > 0), backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_259:

    goto LABEL_260;
  }

  empty = _nw_protocol_stack_create_empty(count, v6);
  if (v7 == 2)
  {
    v9 = _nw_array_get_object_at_index(v4, 0);
    v13 = _nw_array_get_object_at_index(v4, 1);
    if (nw_protocol_options_is_masque(*(v9 + 40)))
    {
      is_masque = nw_protocol_options_is_masque(*(v13 + 40));
      v15 = *(v13 + 40);
      v118 = v13;
      if (is_masque)
      {
        v121 = nw_protocol_options_copy(v15);
        nw_protocol_options_set_proxy_endpoint(v121, *(v13 + 24), 1);
        protocol = nw_protocol_options_copy(*(v9 + 40));
        nw_protocol_options_set_proxy_endpoint(protocol, *(v9 + 24), 0);
        nw_masque_options_set_forced_protocol(protocol, 2);
        nw_masque_options_set_target_endpoint(protocol, *(v13 + 24));
        if (nw_protocol_copy_http3_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_14_76056);
        }

        options = nw_protocol_create_options(nw_protocol_copy_http3_definition_http3_definition);
        v17 = options;
        if ((*(v13 + 84) & 2) != 0)
        {
          nw_http3_set_0rtt_enabled(options, 1);
          nw_http3_set_idle_timeout(v17, 30);
          nw_http3_set_keepalive_mode(v17, 2);
          if (!uuid_is_null((v13 + 8)))
          {
            nw_http3_set_resumable_session_agent(v17, v13 + 8);
          }
        }

        else
        {
          nw_http3_set_idle_timeout(options, 900);
          nw_http3_set_keepalive_mode(v17, 1);
        }

        v41 = *(v13 + 85);
        if ((v41 & 0x20) != 0)
        {
          v43 = 0;
        }

        else
        {
          v42 = *(v13 + 80);
          if (!v42)
          {
            goto LABEL_92;
          }

          v43 = v42 / 0x3E8uLL;
        }

        nw_http3_set_idle_timeout(v17, v43);
        v41 = *(v13 + 85);
LABEL_92:
        if ((v41 & 0x40) != 0)
        {
          nw_http3_set_keepalive_mode(v17, 0);
        }

        if (nw_protocol_copy_http3_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_14_76056);
        }

        v44 = nw_protocol_create_options(nw_protocol_copy_http3_definition_http3_definition);
        v117 = v44;
        if ((*(v9 + 84) & 2) != 0)
        {
          nw_http3_set_0rtt_enabled(v44, 1);
          nw_http3_set_idle_timeout(v117, 30);
          nw_http3_set_keepalive_mode(v117, 2);
          is_null = uuid_is_null((v9 + 8));
          if (!is_null)
          {
            nw_http3_set_resumable_session_agent(v117, v9 + 8);
          }
        }

        else
        {
          nw_http3_set_idle_timeout(v44, 60);
          nw_http3_set_keepalive_mode(v117, 1);
        }

        v47 = *(v9 + 85);
        if ((v47 & 0x20) != 0)
        {
          v49 = 0;
        }

        else
        {
          v48 = *(v9 + 80);
          if (!v48)
          {
LABEL_105:
            if ((v47 & 0x40) != 0)
            {
              nw_http3_set_keepalive_mode(v117, 0);
            }

            stream_options = _nw_quic_create_stream_options(is_null, v46);
            nw_protocol_options_set_prohibit_joining(stream_options);
            v50 = nw_quic_stream_copy_shared_connection_options(stream_options);
            v51 = v50;
            v52 = *(v13 + 84);
            if ((v52 & 4) != 0)
            {
              nw_quic_connection_set_enable_l4s(v50, 1);
              v52 = *(v13 + 84);
            }

            if ((v52 & 8) != 0)
            {
              nw_quic_connection_set_enable_multipath(v51, 1);
            }

            nw_quic_connection_set_idle_timeout(v51, 0);
            nw_quic_connection_set_max_datagram_frame_size(v51, 0xFFFF);
            nw_quic_connection_set_max_udp_payload_size(v51, 1472);
            nw_quic_connection_set_datagram_variant_flow_id_enabled(v51, 1);
            if (nw_masque_options_get_version(v121) == 2)
            {
              nw_quic_connection_set_datagram_quarter_stream_id(v51, 1);
              nw_quic_connection_set_datagram_context_id(v51, 1);
            }

            nw_quic_connection_set_source_connection_id_length(v51, 8);
            nw_quic_connection_set_initial_packet_size(v51, 1304);
            v53 = *(v13 + 48);
            if (v53)
            {
              v54 = v53;
              nw_quic_connection_set_sec_protocol_options(v51, v54);

              v13 = v118;
            }

            if (*(v13 + 56))
            {
              if (a2)
              {
                if ((*(v13 + 85) & 4) == 0)
                {
                  nw_quic_connection_set_use_swift_tls(v51, 1);
                  if (*(v13 + 84) < 0)
                  {
                    nw_quic_connection_set_use_x25519(v51, 1);
                  }
                }
              }

              nw_quic_connection_set_server_raw_public_keys(v51, *(v13 + 56));
            }

            v55 = *(v13 + 64);
            if (v55)
            {
              nw_quic_connection_set_client_identity_reference(v51, v55, *(v13 + 72));
            }

            if ((*(v13 + 84) & 0x10) != 0)
            {
              nw_quic_connection_set_override_trust_certs_for_tests(v51, 1);
            }

            v56 = *(v13 + 85);
            if ((v56 & 4) != 0)
            {
              nw_quic_connection_set_client_identity_is_raw_public_Key(v51, 1);
              v56 = *(v13 + 85);
            }

            if ((v56 & 8) != 0)
            {
              nw_quic_connection_set_pqtls_mode(v51, 2);
            }

            nw_quic_connection_add_h3_alpn(v51, 1);
            nw_quic_connection_set_keepalive_count(v51, 3);
            if (*(v13 + 85) < 0)
            {
              nw_quic_connection_set_ignore_path_errors(v51, 1);
            }

            v116 = _nw_quic_create_stream_options(v57, v58);
            nw_protocol_options_set_prohibit_joining(v116);
            v59 = nw_quic_stream_copy_shared_connection_options(v116);
            v60 = v59;
            v61 = *(v9 + 84);
            if ((v61 & 4) != 0)
            {
              nw_quic_connection_set_enable_l4s(v59, 1);
              v61 = *(v9 + 84);
            }

            if ((v61 & 8) != 0)
            {
              nw_quic_connection_set_enable_multipath(v60, 1);
            }

            nw_quic_connection_set_idle_timeout(v60, 0);
            nw_quic_connection_set_max_datagram_frame_size(v60, 0xFFFF);
            nw_quic_connection_set_max_udp_payload_size(v60, 1472);
            nw_quic_connection_set_datagram_variant_flow_id_enabled(v60, 1);
            if (nw_masque_options_get_version(protocol) == 2)
            {
              nw_quic_connection_set_datagram_quarter_stream_id(v60, 1);
              nw_quic_connection_set_datagram_context_id(v60, 1);
            }

            nw_quic_connection_set_source_connection_id_length(v60, 8);
            nw_quic_connection_set_initial_packet_size(v60, 1350);
            nw_quic_connection_set_pmtud_for_non_transport(v60, 1);
            nw_quic_connection_set_migration_for_non_transport(v60, 1);
            v62 = *(v9 + 48);
            if (v62)
            {
              v63 = v62;
              nw_quic_connection_set_sec_protocol_options(v60, v63);
            }

            if (*(v9 + 56))
            {
              if (a2)
              {
                if ((*(v9 + 85) & 4) == 0)
                {
                  nw_quic_connection_set_use_swift_tls(v60, 1);
                  if (*(v9 + 84) < 0)
                  {
                    nw_quic_connection_set_use_x25519(v60, 1);
                  }
                }
              }

              nw_quic_connection_set_server_raw_public_keys(v60, *(v9 + 56));
            }

            v64 = *(v9 + 64);
            if (v64)
            {
              nw_quic_connection_set_client_identity_reference(v60, v64, *(v9 + 72));
            }

            if ((*(v9 + 84) & 0x10) != 0)
            {
              nw_quic_connection_set_override_trust_certs_for_tests(v60, 1);
            }

            v65 = *(v9 + 85);
            if ((v65 & 4) != 0)
            {
              nw_quic_connection_set_client_identity_is_raw_public_Key(v60, 1);
              v65 = *(v9 + 85);
            }

            if ((v65 & 8) != 0)
            {
              nw_quic_connection_set_pqtls_mode(v60, 2);
            }

            nw_quic_connection_add_h3_alpn(v60, 1);
            nw_quic_connection_set_keepalive_count(v60, 3);
            if (*(v9 + 85) < 0)
            {
              nw_quic_connection_set_ignore_path_errors(v60, 1);
            }

            if (nw_protocol_demux_copy_definition::onceToken[0] != -1)
            {
              dispatch_once(nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_8_26041);
            }

            if (nw_protocol_demux_copy_definition::definition)
            {
              v66 = os_retain(nw_protocol_demux_copy_definition::definition);
              v115 = nw_protocol_create_options(v66);
              if (v66)
              {
                os_release(v66);
              }
            }

            else
            {
              v115 = nw_protocol_create_options(0);
            }

            v10 = v118;
            v79 = _nw_udp_create_options();
            _nw_udp_options_set_use_quic_stats(v79, 1);
            _nw_udp_options_set_no_metadata(v79, 1);
            nw_protocol_stack_append_application_protocol(empty, v121);
            nw_protocol_stack_append_application_protocol(empty, v17);
            nw_protocol_stack_append_application_protocol(empty, stream_options);
            nw_protocol_stack_append_application_protocol(empty, protocol);
            nw_protocol_stack_append_application_protocol(empty, v117);
            nw_protocol_stack_append_application_protocol(empty, v116);
            nw_protocol_stack_append_application_protocol(empty, v115);
            nw_protocol_stack_set_transport_protocol(empty, v79);
            v80 = nw_protocol_options_copy_proxy_endpoint_for_stack(protocol);
            v69 = nw_proxy_config_create_with_stack(v80, empty);

            if (nw_protocol_setup_udp_definition_onceToken != -1)
            {
              dispatch_once(&nw_protocol_setup_udp_definition_onceToken, &__block_literal_global_5_47888);
            }

            v81 = g_udp_definition;
            nw_proxy_config_set_alternate_protocol_stack(v69, 0, v81, 4u);

            if (nw_protocol_copy_quic_stream_definition_onceToken != -1)
            {
              dispatch_once(&nw_protocol_copy_quic_stream_definition_onceToken, &__block_literal_global_63);
            }

            v82 = nw_protocol_copy_quic_stream_definition_quic_definition;
            nw_proxy_config_set_alternate_protocol_stack(v69, 0, v82, 3u);

            v85 = v118[84];
            if (v85)
            {
              nw_proxy_config_set_alternate_protocol_stack(v69, 0, 0, 2u);
              v85 = v118[84];
            }

            if ((v85 & 0x40) != 0)
            {
              v86 = _nw_protocol_stack_create_empty(v83, v84);
              v87 = nw_masque_options_copy_listener_options(v121);
              nw_protocol_stack_append_application_protocol(v86, v87);

              nw_protocol_stack_append_application_protocol(v86, v17);
              nw_protocol_stack_append_application_protocol(v86, stream_options);
              nw_protocol_stack_append_application_protocol(v86, protocol);
              nw_protocol_stack_append_application_protocol(v86, v117);
              nw_protocol_stack_append_application_protocol(v86, v116);
              nw_protocol_stack_append_application_protocol(v86, v115);
              nw_protocol_stack_set_transport_protocol(v86, v79);
              if (nw_protocol_setup_udp_definition_onceToken != -1)
              {
                dispatch_once(&nw_protocol_setup_udp_definition_onceToken, &__block_literal_global_5_47888);
              }

              v88 = g_udp_definition;
              nw_proxy_config_set_listener_protocol_stack(v69, v86, v88, 4u);

              v10 = v118;
            }

            nw_proxy_config_set_is_privacy_proxy(v69, 1, 0);
            nw_proxy_config_set_multipath_service(v69, 1);

LABEL_223:
LABEL_224:

            nw_proxy_config_set_type(v69, 3006);
            v22 = v69;

            goto LABEL_225;
          }

          v49 = v48 / 0x3E8uLL;
        }

        nw_http3_set_idle_timeout(v117, v49);
        v47 = *(v9 + 85);
        goto LABEL_105;
      }

      if (nw_protocol_options_is_oblivious_http(v15))
      {
        v121 = nw_protocol_options_copy(*(v9 + 40));
        nw_protocol_options_set_proxy_endpoint(v121, *(v9 + 24), 0);
        protocol = nw_protocol_options_copy(*(v13 + 40));
        if (nw_protocol_copy_http3_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_14_76056);
        }

        v23 = nw_protocol_create_options(nw_protocol_copy_http3_definition_http3_definition);
        v17 = v23;
        if ((*(v9 + 84) & 2) != 0)
        {
          nw_http3_set_0rtt_enabled(v23, 1);
          nw_http3_set_idle_timeout(v17, 30);
          nw_http3_set_keepalive_mode(v17, 2);
          v24 = uuid_is_null((v9 + 8));
          if (!v24)
          {
            nw_http3_set_resumable_session_agent(v17, v9 + 8);
          }
        }

        else
        {
          nw_http3_set_idle_timeout(v23, 60);
          nw_http3_set_keepalive_mode(v17, 1);
        }

        v89 = *(v9 + 85);
        if ((v89 & 0x20) != 0)
        {
          v91 = 0;
        }

        else
        {
          v90 = *(v9 + 80);
          if (!v90)
          {
LABEL_192:
            if ((v89 & 0x40) != 0)
            {
              nw_http3_set_keepalive_mode(v17, 0);
            }

            v117 = _nw_quic_create_stream_options(v24, v25);
            nw_protocol_options_set_prohibit_joining(v117);
            stream_options = nw_quic_stream_copy_shared_connection_options(v117);
            v92 = *(v9 + 84);
            if ((v92 & 4) != 0)
            {
              nw_quic_connection_set_enable_l4s(stream_options, 1);
              v92 = *(v9 + 84);
            }

            if ((v92 & 8) != 0)
            {
              nw_quic_connection_set_enable_multipath(stream_options, 1);
            }

            nw_quic_connection_set_idle_timeout(stream_options, 0);
            nw_quic_connection_set_max_datagram_frame_size(stream_options, 0xFFFF);
            nw_quic_connection_set_datagram_variant_flow_id_enabled(stream_options, 1);
            if (nw_masque_options_get_version(v121) == 2)
            {
              nw_quic_connection_set_datagram_quarter_stream_id(stream_options, 1);
              nw_quic_connection_set_datagram_context_id(stream_options, 1);
            }

            nw_quic_connection_set_source_connection_id_length(stream_options, 8);
            nw_quic_connection_set_initial_packet_size(stream_options, 1350);
            v93 = *(v9 + 48);
            if (v93)
            {
              v94 = v93;
              nw_quic_connection_set_sec_protocol_options(stream_options, v94);
            }

            if (*(v9 + 56))
            {
              if (a2)
              {
                if ((*(v9 + 85) & 4) == 0)
                {
                  nw_quic_connection_set_use_swift_tls(stream_options, 1);
                  if (*(v9 + 84) < 0)
                  {
                    nw_quic_connection_set_use_x25519(stream_options, 1);
                  }
                }
              }

              nw_quic_connection_set_server_raw_public_keys(stream_options, *(v9 + 56));
            }

            else
            {
              v95 = *(v9 + 64);
              if (v95)
              {
                nw_quic_connection_set_client_identity_reference(stream_options, v95, *(v9 + 72));
              }

              else if ((*(v9 + 84) & 0x10) != 0)
              {
                nw_quic_connection_set_override_trust_certs_for_tests(stream_options, 1);
              }
            }

            v96 = *(v9 + 85);
            if ((v96 & 4) != 0)
            {
              nw_quic_connection_set_client_identity_is_raw_public_Key(stream_options, 1);
              v96 = *(v9 + 85);
            }

            if ((v96 & 8) != 0)
            {
              nw_quic_connection_set_pqtls_mode(stream_options, 2);
            }

            nw_quic_connection_add_h3_alpn(stream_options, 1);
            nw_quic_connection_set_keepalive_count(stream_options, 3);
            if (*(v9 + 85) < 0)
            {
              nw_quic_connection_set_ignore_path_errors(stream_options, 1);
            }

            nw_protocol_stack_append_application_protocol(empty, protocol);
            nw_protocol_stack_append_application_protocol(empty, v121);
            nw_protocol_stack_append_application_protocol(empty, v17);
            nw_protocol_stack_set_transport_protocol(empty, v117);
            v97 = nw_protocol_options_copy_proxy_endpoint_for_stack(v121);
            v69 = nw_proxy_config_create_with_stack(v97, empty);

            nw_proxy_config_set_is_privacy_proxy(v69, 1, 0);
            if (nw_protocol_copy_http_messaging_definition_onceToken != -1)
            {
              dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_94);
            }

            v98 = nw_protocol_copy_http_messaging_definition_definition;
            nw_proxy_config_add_required_protocol(v69, v98);

            if (nw_protocol_copy_http_messaging_definition_onceToken != -1)
            {
              dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_94);
            }

            v99 = nw_protocol_copy_http_messaging_definition_definition;
            nw_proxy_config_add_protocol_to_remove(v69, v99);

            v10 = v118;
            v51 = nw_protocol_boringssl_copy_definition();
            nw_proxy_config_add_protocol_to_remove(v69, v51);
            goto LABEL_223;
          }

          v91 = v90 / 0x3E8uLL;
        }

        nw_http3_set_idle_timeout(v17, v91);
        v89 = *(v9 + 85);
        goto LABEL_192;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446210;
        v125 = "nw_proxy_config_create_privacy_proxy_internal";
        v21 = "%{public}s Second hop must be MASQUE or OHTTP";
        goto LABEL_24;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446210;
        v125 = "nw_proxy_config_create_privacy_proxy_internal";
        v21 = "%{public}s First hop must be MASQUE";
LABEL_24:
        _os_log_impl(&dword_181A37000, v20, OS_LOG_TYPE_ERROR, v21, buf, 0xCu);
      }
    }

    goto LABEL_26;
  }

  if (v7 == 1)
  {
    v9 = _nw_array_get_object_at_index(v4, 0);
    if (nw_protocol_options_is_masque(*(v9 + 40)))
    {
      v10 = nw_protocol_options_copy(*(v9 + 40));
      nw_protocol_options_set_proxy_endpoint(v10, *(v9 + 24), 0);
      if (nw_protocol_copy_http3_definition_onceToken != -1)
      {
        dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_14_76056);
      }

      v121 = nw_protocol_create_options(nw_protocol_copy_http3_definition_http3_definition);
      if ((*(v9 + 84) & 2) != 0)
      {
        nw_http3_set_0rtt_enabled(v121, 1);
        nw_http3_set_idle_timeout(v121, 30);
        nw_http3_set_keepalive_mode(v121, 2);
        v11 = uuid_is_null((v9 + 8));
        if (!v11)
        {
          nw_http3_set_resumable_session_agent(v121, v9 + 8);
        }
      }

      else
      {
        nw_http3_set_idle_timeout(v121, 60);
        nw_http3_set_keepalive_mode(v121, 1);
      }

      v26 = *(v9 + 85);
      if ((v26 & 0x20) != 0)
      {
        v28 = 0;
      }

      else
      {
        v27 = *(v9 + 80);
        if (!v27)
        {
LABEL_39:
          if ((v26 & 0x40) != 0)
          {
            nw_http3_set_keepalive_mode(v121, 0);
          }

          protocol = _nw_quic_create_stream_options(v11, v12);
          nw_protocol_options_set_prohibit_joining(protocol);
          v29 = nw_quic_stream_copy_shared_connection_options(protocol);
          v17 = v29;
          v30 = *(v9 + 84);
          if ((v30 & 4) != 0)
          {
            nw_quic_connection_set_enable_l4s(v29, 1);
            v30 = *(v9 + 84);
          }

          if ((v30 & 8) != 0)
          {
            nw_quic_connection_set_enable_multipath(v17, 1);
          }

          nw_quic_connection_set_idle_timeout(v17, 0);
          nw_quic_connection_set_max_datagram_frame_size(v17, 0xFFFF);
          nw_quic_connection_set_datagram_variant_flow_id_enabled(v17, 1);
          if (nw_masque_options_get_version(v10) == 2)
          {
            nw_quic_connection_set_datagram_quarter_stream_id(v17, 1);
            nw_quic_connection_set_datagram_context_id(v17, 1);
          }

          nw_quic_connection_set_source_connection_id_length(v17, 8);
          nw_quic_connection_set_initial_packet_size(v17, 1350);
          v31 = *(v9 + 48);
          if (v31)
          {
            v32 = v10;
            v33 = v31;
            nw_quic_connection_set_sec_protocol_options(v17, v33);

            v10 = v32;
          }

          if (*(v9 + 56))
          {
            if (a2)
            {
              if ((*(v9 + 85) & 4) == 0)
              {
                nw_quic_connection_set_use_swift_tls(v17, 1);
                if (*(v9 + 84) < 0)
                {
                  nw_quic_connection_set_use_x25519(v17, 1);
                }
              }
            }

            nw_quic_connection_set_server_raw_public_keys(v17, *(v9 + 56));
          }

          v34 = *(v9 + 64);
          if (v34)
          {
            nw_quic_connection_set_client_identity_reference(v17, v34, *(v9 + 72));
          }

          if ((*(v9 + 85) & 4) != 0)
          {
            nw_quic_connection_set_client_identity_is_raw_public_Key(v17, 1);
          }

          if ((*(v9 + 84) & 0x10) != 0)
          {
            nw_quic_connection_set_override_trust_certs_for_tests(v17, 1);
          }

          if ((*(v9 + 85) & 8) != 0)
          {
            nw_quic_connection_set_pqtls_mode(v17, 2);
          }

          nw_quic_connection_add_h3_alpn(v17, 1);
          nw_quic_connection_set_keepalive_count(v17, 3);
          if (*(v9 + 85) < 0)
          {
            nw_quic_connection_set_ignore_path_errors(v17, 1);
          }

          nw_protocol_stack_append_application_protocol(empty, v10);
          if ((*(v9 + 85) & 0x10) != 0 && nw_protocol_options_is_http3(v121))
          {
            if (nw_protocol_copy_http_client_definition_onceToken != -1)
            {
              dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_85);
            }

            v35 = nw_protocol_create_options(nw_protocol_copy_http_client_definition_definition);
            nw_protocol_stack_append_application_protocol(empty, v35);
            if (nw_protocol_copy_http_redirect_definition_onceToken != -1)
            {
              dispatch_once(&nw_protocol_copy_http_redirect_definition_onceToken, &__block_literal_global_42_76791);
            }

            v36 = nw_protocol_create_options(nw_protocol_copy_http_redirect_definition_http_redirect_definition);
            nw_http_redirect_options_set_limit(v36, 20);
            nw_http_redirect_options_set_for_proxy(v36, 1);
            nw_protocol_stack_append_application_protocol(empty, v36);
            if (nw_protocol_copy_http_messaging_definition_onceToken != -1)
            {
              dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_94);
            }

            v37 = nw_protocol_create_options(nw_protocol_copy_http_messaging_definition_definition);
            nw_http_messaging_options_set_http3_options(v37, v121);
            nw_protocol_stack_append_application_protocol(empty, v37);
          }

          else
          {
            nw_protocol_stack_append_application_protocol(empty, v121);
          }

          if (*(v9 + 85))
          {
            nw_protocol_stack_append_application_protocol(empty, protocol);
            if (nw_protocol_demux_copy_definition::onceToken[0] != -1)
            {
              dispatch_once(nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_8_26041);
            }

            if (nw_protocol_demux_copy_definition::definition)
            {
              v38 = v10;
              v39 = os_retain(nw_protocol_demux_copy_definition::definition);
              v40 = nw_protocol_create_options(v39);
              if (v39)
              {
                os_release(v39);
              }

              v10 = v38;
            }

            else
            {
              v40 = nw_protocol_create_options(0);
            }

            nw_protocol_stack_append_application_protocol(empty, v40);
            v67 = _nw_udp_create_options();
            _nw_udp_options_set_use_quic_stats(v67, 1);
            _nw_udp_options_set_no_metadata(v67, 1);
            nw_protocol_stack_set_transport_protocol(empty, v67);
          }

          else
          {
            nw_protocol_stack_set_transport_protocol(empty, protocol);
          }

          v68 = nw_protocol_options_copy_proxy_endpoint_for_stack(v10);
          v69 = nw_proxy_config_create_with_stack(v68, empty);

          if (nw_protocol_setup_udp_definition_onceToken != -1)
          {
            dispatch_once(&nw_protocol_setup_udp_definition_onceToken, &__block_literal_global_5_47888);
          }

          v70 = g_udp_definition;
          nw_proxy_config_set_alternate_protocol_stack(v69, 0, v70, 4u);

          if (nw_protocol_copy_quic_stream_definition_onceToken != -1)
          {
            dispatch_once(&nw_protocol_copy_quic_stream_definition_onceToken, &__block_literal_global_63);
          }

          v71 = nw_protocol_copy_quic_stream_definition_quic_definition;
          nw_proxy_config_set_alternate_protocol_stack(v69, 0, v71, 3u);

          v74 = *(v9 + 84);
          if (v74)
          {
            nw_proxy_config_set_alternate_protocol_stack(v69, 0, 0, 2u);
            v74 = *(v9 + 84);
          }

          if ((v74 & 0x40) != 0)
          {
            v75 = _nw_protocol_stack_create_empty(v72, v73);
            v76 = v10;
            v77 = nw_masque_options_copy_listener_options(v10);
            nw_protocol_stack_append_application_protocol(v75, v77);

            nw_protocol_stack_append_application_protocol(v75, v121);
            nw_protocol_stack_set_transport_protocol(v75, protocol);
            v10 = v76;
            if (nw_protocol_setup_udp_definition_onceToken != -1)
            {
              dispatch_once(&nw_protocol_setup_udp_definition_onceToken, &__block_literal_global_5_47888);
            }

            v78 = g_udp_definition;
            nw_proxy_config_set_listener_protocol_stack(v69, v75, v78, 4u);
          }

          nw_proxy_config_set_is_privacy_proxy(v69, 1, 0);
          nw_proxy_config_set_multipath_service(v69, 1);
          goto LABEL_224;
        }

        v28 = v27 / 0x3E8uLL;
      }

      nw_http3_set_idle_timeout(v121, v28);
      v26 = *(v9 + 85);
      goto LABEL_39;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v125 = "nw_proxy_config_create_privacy_proxy_internal";
      _os_log_impl(&dword_181A37000, v19, OS_LOG_TYPE_ERROR, "%{public}s First hop must be MASQUE", buf, 0xCu);
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = gLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v125 = "nw_proxy_config_create_privacy_proxy_internal";
      _os_log_impl(&dword_181A37000, v18, OS_LOG_TYPE_ERROR, "%{public}s No more than two hops are currently supported", buf, 0xCu);
    }
  }

LABEL_26:
  v22 = 0;
LABEL_225:

LABEL_226:
  return v22;
}

NWConcrete_nw_proxy_config *nw_proxy_config_create_fallback_privacy_proxy(void *a1)
{
  v99 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v77 = __nwlog_obj();
    *buf = 136446210;
    v96 = "nw_proxy_config_create_fallback_privacy_proxy";
    v78 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (!__nwlog_fault(v78, &type, &v93))
    {
      goto LABEL_199;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v79 = __nwlog_obj();
      v80 = type;
      if (os_log_type_enabled(v79, type))
      {
        *buf = 136446210;
        v96 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl(&dword_181A37000, v79, v80, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v93 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v79 = __nwlog_obj();
      v84 = type;
      v85 = os_log_type_enabled(v79, type);
      if (backtrace_string)
      {
        if (v85)
        {
          *buf = 136446466;
          v96 = "nw_proxy_config_create_fallback_privacy_proxy";
          v97 = 2082;
          v98 = backtrace_string;
          _os_log_impl(&dword_181A37000, v79, v84, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v78)
        {
          goto LABEL_201;
        }

        goto LABEL_200;
      }

      if (v85)
      {
        *buf = 136446210;
        v96 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl(&dword_181A37000, v79, v84, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v79 = __nwlog_obj();
      v89 = type;
      if (os_log_type_enabled(v79, type))
      {
        *buf = 136446210;
        v96 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl(&dword_181A37000, v79, v89, "%{public}s called with null array, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_198;
  }

  count = _nw_array_get_count(v1);
  v5 = count;
  if (!count)
  {
    v81 = __nwlog_obj();
    *buf = 136446210;
    v96 = "nw_proxy_config_create_fallback_privacy_proxy";
    v78 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (!__nwlog_fault(v78, &type, &v93))
    {
      goto LABEL_199;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v79 = __nwlog_obj();
      v82 = type;
      if (os_log_type_enabled(v79, type))
      {
        *buf = 136446210;
        v96 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl(&dword_181A37000, v79, v82, "%{public}s called with null (hop_count > 0)", buf, 0xCu);
      }
    }

    else if (v93 == 1)
    {
      v86 = __nw_create_backtrace_string();
      v79 = __nwlog_obj();
      v87 = type;
      v88 = os_log_type_enabled(v79, type);
      if (v86)
      {
        if (v88)
        {
          *buf = 136446466;
          v96 = "nw_proxy_config_create_fallback_privacy_proxy";
          v97 = 2082;
          v98 = v86;
          _os_log_impl(&dword_181A37000, v79, v87, "%{public}s called with null (hop_count > 0), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v86);
LABEL_199:
        if (!v78)
        {
LABEL_201:
          v23 = 0;
          goto LABEL_165;
        }

LABEL_200:
        free(v78);
        goto LABEL_201;
      }

      if (v88)
      {
        *buf = 136446210;
        v96 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl(&dword_181A37000, v79, v87, "%{public}s called with null (hop_count > 0), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v79 = __nwlog_obj();
      v90 = type;
      if (os_log_type_enabled(v79, type))
      {
        *buf = 136446210;
        v96 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl(&dword_181A37000, v79, v90, "%{public}s called with null (hop_count > 0), backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_198:

    goto LABEL_199;
  }

  empty = _nw_protocol_stack_create_empty(count, v4);
  if (v5 == 2)
  {
    v7 = _nw_array_get_object_at_index(v2, 0);
    v9 = _nw_array_get_object_at_index(v2, 1);
    if (nw_protocol_options_is_masque(*(v7 + 40)))
    {
      if (nw_protocol_options_is_masque(*(v9 + 40)))
      {
        v15 = nw_protocol_options_copy(*(v7 + 40));
        v11 = v15;
        v16 = *(v7 + 32);
        if (!v16)
        {
          v16 = *(v7 + 24);
        }

        nw_protocol_options_set_proxy_endpoint(v15, v16, 0);
        if (nw_protocol_copy_http2_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_http2_definition_onceToken, &__block_literal_global_5_76055);
        }

        options = nw_protocol_create_options(nw_protocol_copy_http2_definition_http2_definition);
        nw_http2_set_idle_timeout(options, 60);
        v17 = *(v7 + 80);
        if (v17)
        {
          nw_http2_set_idle_timeout(options, v17 / 0x3E8uLL);
        }

        v18 = *(v7 + 48);
        if (v18)
        {
          v91 = v18;
          sec_protocol_options_add_tls_application_protocol(v91, "h2");
          sec_protocol_options_set_min_tls_protocol_version(v91, tls_protocol_version_TLSv13);
        }

        else
        {
          if (nw_protocol_copy_serializable_tls_definition::onceToken != -1)
          {
            dispatch_once(&nw_protocol_copy_serializable_tls_definition::onceToken, &__block_literal_global_75577);
          }

          v91 = nw_protocol_create_options(nw_protocol_copy_serializable_tls_definition::tls_definition);
          nw_serializable_tls_set_add_h2_alpn(v91);
          nw_serializable_tls_set_require_tls13(v91, 1);
          v30 = *(v7 + 56);
          if (v30)
          {
            nw_serializable_tls_set_server_raw_public_keys(v91, v30);
          }

          else
          {
            v34 = *(v7 + 64);
            if (v34)
            {
              nw_serializable_tls_set_client_identity_reference(v91, v34, *(v7 + 72));
            }

            else if ((*(v7 + 84) & 0x10) != 0)
            {
              nw_serializable_tls_set_trust_certs(v91);
            }
          }

          if ((*(v7 + 85) & 8) != 0)
          {
            nw_serializable_tls_set_pqtls_mode(v91);
          }
        }

        v43 = *(v9 + 32);
        if (!v43)
        {
          v43 = *(v9 + 24);
        }

        nw_masque_options_set_target_endpoint(v11, v43);
        v44 = nw_protocol_options_copy(*(v9 + 40));
        v45 = *(v9 + 32);
        if (!v45)
        {
          v45 = *(v9 + 24);
        }

        v92 = v44;
        nw_protocol_options_set_proxy_endpoint(v44, v45, 1);
        if ((*(v7 + 85) & 2) == 0)
        {
          nw_masque_options_set_forced_protocol(v11, 1);
          if (nw_protocol_copy_http2_definition_onceToken != -1)
          {
            dispatch_once(&nw_protocol_copy_http2_definition_onceToken, &__block_literal_global_5_76055);
          }

          v46 = nw_protocol_create_options(nw_protocol_copy_http2_definition_http2_definition);
          nw_http2_set_idle_timeout(v46, 900);
          v47 = *(v9 + 80);
          if (v47)
          {
            nw_http2_set_idle_timeout(v46, v47 / 0x3E8uLL);
          }

          v48 = *(v9 + 48);
          if (v48)
          {
            stream_options = v48;
            sec_protocol_options_add_tls_application_protocol(stream_options, "h2");
            sec_protocol_options_set_min_tls_protocol_version(stream_options, tls_protocol_version_TLSv13);
          }

          else
          {
            serializable_options = nw_tls_create_serializable_options();
            nw_serializable_tls_set_add_h2_alpn(serializable_options);
            nw_serializable_tls_set_require_tls13(serializable_options, 1);
            v63 = *(v9 + 56);
            if (v63)
            {
              nw_serializable_tls_set_server_raw_public_keys(serializable_options, v63);
            }

            else
            {
              v65 = *(v9 + 64);
              if (v65)
              {
                nw_serializable_tls_set_client_identity_reference(serializable_options, v65, *(v9 + 72));
              }

              else if ((*(v9 + 84) & 0x10) != 0)
              {
                nw_serializable_tls_set_trust_certs(serializable_options);
              }
            }

            stream_options = serializable_options;
            if ((*(v9 + 85) & 8) != 0)
            {
              nw_serializable_tls_set_pqtls_mode(serializable_options);
            }
          }

          nw_protocol_stack_append_application_protocol(empty, v92);
          nw_protocol_stack_append_application_protocol(empty, v46);
          nw_protocol_stack_append_application_protocol(empty, stream_options);
          nw_protocol_stack_append_application_protocol(empty, v11);
          nw_protocol_stack_append_application_protocol(empty, options);
          nw_protocol_stack_append_application_protocol(empty, v91);
          if (nw_protocol_demux_copy_definition::onceToken[0] != -1)
          {
            dispatch_once(nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_8_26041);
          }

          if (nw_protocol_demux_copy_definition::definition)
          {
            v71 = os_retain(nw_protocol_demux_copy_definition::definition);
            v72 = nw_protocol_create_options(v71);
            if (v71)
            {
              os_release(v71);
            }
          }

          else
          {
            v72 = nw_protocol_create_options(0);
          }

          nw_protocol_stack_append_application_protocol(empty, v72);

          v57 = _nw_tcp_create_options();
          nw_protocol_stack_set_transport_protocol(empty, v57);
LABEL_153:

          v73 = nw_protocol_options_copy_proxy_endpoint_for_stack(v11);
          v23 = nw_proxy_config_create_with_stack(v73, empty);

          if (nw_masque_options_get_version(v92) == 2 || (*(v7 + 85) & 2) != 0)
          {
            if (nw_protocol_setup_udp_definition_onceToken != -1)
            {
              dispatch_once(&nw_protocol_setup_udp_definition_onceToken, &__block_literal_global_5_47888);
            }

            v74 = g_udp_definition;
            nw_proxy_config_set_alternate_protocol_stack(v23, 0, v74, 4u);

            if (nw_protocol_copy_quic_stream_definition_onceToken != -1)
            {
              dispatch_once(&nw_protocol_copy_quic_stream_definition_onceToken, &__block_literal_global_63);
            }

            v75 = nw_protocol_copy_quic_stream_definition_quic_definition;
            nw_proxy_config_set_alternate_protocol_stack(v23, 0, v75, 3u);

            if (*(v9 + 84))
            {
              nw_proxy_config_set_alternate_protocol_stack(v23, 0, 0, 2u);
            }
          }

          nw_proxy_config_set_is_privacy_proxy(v23, 1, 0);
LABEL_162:

LABEL_163:
          nw_proxy_config_set_type(v23, 3006);
          goto LABEL_164;
        }

        nw_masque_options_set_forced_protocol(v11, 2);
        if (nw_protocol_copy_http3_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_14_76056);
        }

        v50 = nw_protocol_create_options(nw_protocol_copy_http3_definition_http3_definition);
        v46 = v50;
        if ((*(v9 + 84) & 2) != 0)
        {
          nw_http3_set_0rtt_enabled(v50, 1);
          nw_http3_set_idle_timeout(v46, 30);
          nw_http3_set_keepalive_mode(v46, 2);
          is_null = uuid_is_null((v9 + 8));
          if (!is_null)
          {
            nw_http3_set_resumable_session_agent(v46, v9 + 8);
          }
        }

        else
        {
          nw_http3_set_idle_timeout(v50, 900);
          nw_http3_set_keepalive_mode(v46, 1);
        }

        v53 = *(v9 + 85);
        if ((v53 & 0x20) != 0)
        {
          v55 = 0;
        }

        else
        {
          v54 = *(v9 + 80);
          if (!v54)
          {
LABEL_110:
            if ((v53 & 0x40) != 0)
            {
              nw_http3_set_keepalive_mode(v46, 0);
            }

            stream_options = _nw_quic_create_stream_options(is_null, v52);
            nw_protocol_options_set_prohibit_joining(stream_options);
            v56 = nw_quic_stream_copy_shared_connection_options(stream_options);
            v57 = v56;
            v58 = *(v9 + 84);
            if ((v58 & 4) != 0)
            {
              nw_quic_connection_set_enable_l4s(v56, 1);
              v58 = *(v9 + 84);
            }

            if ((v58 & 8) != 0)
            {
              nw_quic_connection_set_enable_multipath(v57, 1);
            }

            nw_quic_connection_set_idle_timeout(v57, 0);
            nw_quic_connection_set_max_datagram_frame_size(v57, 0xFFFF);
            nw_quic_connection_set_max_udp_payload_size(v57, 1472);
            nw_quic_connection_set_datagram_variant_flow_id_enabled(v57, 1);
            if (nw_masque_options_get_version(v92) == 2)
            {
              nw_quic_connection_set_datagram_quarter_stream_id(v57, 1);
              nw_quic_connection_set_datagram_context_id(v57, 1);
            }

            nw_quic_connection_set_source_connection_id_length(v57, 8);
            nw_quic_connection_set_initial_packet_size(v57, 1304);
            v59 = *(v9 + 48);
            if (v59)
            {
              v60 = v59;
              nw_quic_connection_set_sec_protocol_options(v57, v60);
            }

            v61 = *(v9 + 56);
            if (v61)
            {
              nw_quic_connection_set_server_raw_public_keys(v57, v61);
            }

            else
            {
              v64 = *(v9 + 64);
              if (v64)
              {
                nw_quic_connection_set_client_identity_reference(v57, v64, *(v9 + 72));
              }

              else if ((*(v9 + 84) & 0x10) != 0)
              {
                nw_quic_connection_set_override_trust_certs_for_tests(v57, 1);
              }
            }

            if ((*(v9 + 85) & 8) != 0)
            {
              nw_quic_connection_set_pqtls_mode(v57, 2);
            }

            nw_quic_connection_add_h3_alpn(v57, 1);
            nw_quic_connection_set_keepalive_count(v57, 3);
            nw_protocol_stack_append_application_protocol(empty, v92);
            nw_protocol_stack_append_application_protocol(empty, v46);
            nw_protocol_stack_append_application_protocol(empty, stream_options);
            nw_protocol_stack_append_application_protocol(empty, v11);
            nw_protocol_stack_append_application_protocol(empty, options);
            nw_protocol_stack_append_application_protocol(empty, v91);
            v66 = _nw_tcp_create_options();
            nw_protocol_stack_set_transport_protocol(empty, v66);

            goto LABEL_153;
          }

          v55 = v54 / 0x3E8uLL;
        }

        nw_http3_set_idle_timeout(v46, v55);
        v53 = *(v9 + 85);
        goto LABEL_110;
      }

      if (nw_protocol_options_is_oblivious_http(*(v9 + 40)))
      {
        v24 = nw_protocol_options_copy(*(v7 + 40));
        v11 = v24;
        v25 = *(v7 + 32);
        if (!v25)
        {
          v25 = *(v7 + 24);
        }

        nw_protocol_options_set_proxy_endpoint(v24, v25, 0);
        options = nw_protocol_options_copy(*(v9 + 40));
        if (nw_protocol_copy_http2_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_http2_definition_onceToken, &__block_literal_global_5_76055);
        }

        v91 = nw_protocol_create_options(nw_protocol_copy_http2_definition_http2_definition);
        nw_http2_set_idle_timeout(v91, 60);
        v26 = *(v9 + 80);
        if (v26)
        {
          nw_http2_set_idle_timeout(v91, v26 / 0x3E8uLL);
        }

        v27 = *(v7 + 48);
        if (v27)
        {
          v92 = v27;
          sec_protocol_options_add_tls_application_protocol(v92, "h2");
          sec_protocol_options_set_min_tls_protocol_version(v92, tls_protocol_version_TLSv13);
        }

        else
        {
          v32 = nw_tls_create_serializable_options();
          nw_serializable_tls_set_add_h2_alpn(v32);
          nw_serializable_tls_set_require_tls13(v32, 1);
          v33 = *(v7 + 56);
          if (v33)
          {
            nw_serializable_tls_set_server_raw_public_keys(v32, v33);
          }

          else
          {
            v42 = *(v7 + 64);
            if (v42)
            {
              nw_serializable_tls_set_client_identity_reference(v32, v42, *(v7 + 72));
            }

            else if ((*(v7 + 84) & 0x10) != 0)
            {
              nw_serializable_tls_set_trust_certs(v32);
            }
          }

          v92 = v32;
          if ((*(v7 + 85) & 8) != 0)
          {
            nw_serializable_tls_set_pqtls_mode(v32);
          }
        }

        nw_protocol_stack_append_application_protocol(empty, options);
        nw_protocol_stack_append_application_protocol(empty, v11);
        nw_protocol_stack_append_application_protocol(empty, v91);
        nw_protocol_stack_append_application_protocol(empty, v92);
        v67 = _nw_tcp_create_options();
        nw_protocol_stack_set_transport_protocol(empty, v67);

        v68 = nw_protocol_options_copy_proxy_endpoint_for_stack(v11);
        v23 = nw_proxy_config_create_with_stack(v68, empty);

        nw_proxy_config_set_is_privacy_proxy(v23, 1, 0);
        if (nw_protocol_copy_http_messaging_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_94);
        }

        v69 = nw_protocol_copy_http_messaging_definition_definition;
        nw_proxy_config_add_required_protocol(v23, v69);

        if (nw_protocol_copy_http_messaging_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_94);
        }

        v70 = nw_protocol_copy_http_messaging_definition_definition;
        nw_proxy_config_add_protocol_to_remove(v23, v70);

        v46 = nw_protocol_boringssl_copy_definition();
        nw_proxy_config_add_protocol_to_remove(v23, v46);
        goto LABEL_162;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = gLogObj;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446210;
        v96 = "nw_proxy_config_create_fallback_privacy_proxy";
        v22 = "%{public}s Second hop must be MASQUE or OHTTP";
        goto LABEL_32;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = gLogObj;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *buf = 136446210;
        v96 = "nw_proxy_config_create_fallback_privacy_proxy";
        v22 = "%{public}s First hop must be MASQUE";
LABEL_32:
        _os_log_impl(&dword_181A37000, v21, OS_LOG_TYPE_ERROR, v22, buf, 0xCu);
      }
    }

    goto LABEL_34;
  }

  if (v5 == 1)
  {
    v7 = _nw_array_get_object_at_index(v2, 0);
    if (nw_protocol_options_is_masque(*(v7 + 40)))
    {
      v8 = nw_protocol_options_copy(*(v7 + 40));
      v9 = v8;
      v10 = *(v7 + 32);
      if (!v10)
      {
        v10 = *(v7 + 24);
      }

      nw_protocol_options_set_proxy_endpoint(v8, v10, 0);
      if (nw_protocol_copy_http2_definition_onceToken != -1)
      {
        dispatch_once(&nw_protocol_copy_http2_definition_onceToken, &__block_literal_global_5_76055);
      }

      v11 = nw_protocol_create_options(nw_protocol_copy_http2_definition_http2_definition);
      nw_http2_set_idle_timeout(v11, 60);
      v12 = *(v7 + 80);
      if (v12)
      {
        nw_http2_set_idle_timeout(v11, v12 / 0x3E8uLL);
      }

      v13 = *(v7 + 48);
      if (v13)
      {
        options = v13;
        sec_protocol_options_add_tls_application_protocol(options, "h2");
        sec_protocol_options_set_min_tls_protocol_version(options, tls_protocol_version_TLSv13);
      }

      else
      {
        if (nw_protocol_copy_serializable_tls_definition::onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_serializable_tls_definition::onceToken, &__block_literal_global_75577);
        }

        v28 = nw_protocol_create_options(nw_protocol_copy_serializable_tls_definition::tls_definition);
        nw_serializable_tls_set_add_h2_alpn(v28);
        nw_serializable_tls_set_require_tls13(v28, 1);
        v29 = *(v7 + 56);
        if (v29)
        {
          nw_serializable_tls_set_server_raw_public_keys(v28, v29);
        }

        else
        {
          v31 = *(v7 + 64);
          if (v31)
          {
            nw_serializable_tls_set_client_identity_reference(v28, v31, *(v7 + 72));
          }

          else if ((*(v7 + 84) & 0x10) != 0)
          {
            nw_serializable_tls_set_trust_certs(v28);
          }
        }

        options = v28;
        if ((*(v7 + 85) & 8) != 0)
        {
          nw_serializable_tls_set_pqtls_mode(v28);
        }
      }

      nw_protocol_stack_append_application_protocol(empty, v9);
      if ((*(v7 + 85) & 0x10) != 0 && nw_protocol_options_is_http2(v11))
      {
        if (nw_protocol_copy_http_client_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_85);
        }

        v35 = nw_protocol_create_options(nw_protocol_copy_http_client_definition_definition);
        nw_protocol_stack_append_application_protocol(empty, v35);
        if (nw_protocol_copy_http_redirect_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_http_redirect_definition_onceToken, &__block_literal_global_42_76791);
        }

        v36 = nw_protocol_create_options(nw_protocol_copy_http_redirect_definition_http_redirect_definition);
        nw_http_redirect_options_set_limit(v36, 20);
        nw_http_redirect_options_set_for_proxy(v36, 1);
        nw_protocol_stack_append_application_protocol(empty, v36);
        if (nw_protocol_copy_http_messaging_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_94);
        }

        v37 = nw_protocol_create_options(nw_protocol_copy_http_messaging_definition_definition);
        nw_http_messaging_options_set_http2_options(v37, v11);
        nw_protocol_stack_append_application_protocol(empty, v37);
      }

      else
      {
        nw_protocol_stack_append_application_protocol(empty, v11);
      }

      nw_protocol_stack_append_application_protocol(empty, options);
      v38 = _nw_tcp_create_options();
      nw_protocol_stack_set_transport_protocol(empty, v38);

      v39 = nw_protocol_options_copy_proxy_endpoint_for_stack(v9);
      v23 = nw_proxy_config_create_with_stack(v39, empty);

      if (nw_masque_options_get_version(v9) == 2)
      {
        if (nw_protocol_setup_udp_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_setup_udp_definition_onceToken, &__block_literal_global_5_47888);
        }

        v40 = g_udp_definition;
        nw_proxy_config_set_alternate_protocol_stack(v23, 0, v40, 4u);

        if (nw_protocol_copy_quic_stream_definition_onceToken != -1)
        {
          dispatch_once(&nw_protocol_copy_quic_stream_definition_onceToken, &__block_literal_global_63);
        }

        v41 = nw_protocol_copy_quic_stream_definition_quic_definition;
        nw_proxy_config_set_alternate_protocol_stack(v23, 0, v41, 3u);

        if (*(v7 + 84))
        {
          nw_proxy_config_set_alternate_protocol_stack(v23, 0, 0, 2u);
        }
      }

      nw_proxy_config_set_is_privacy_proxy(v23, 1, 0);
      goto LABEL_163;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = gLogObj;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v96 = "nw_proxy_config_create_fallback_privacy_proxy";
      _os_log_impl(&dword_181A37000, v20, OS_LOG_TYPE_ERROR, "%{public}s First hop must be MASQUE", buf, 0xCu);
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v96 = "nw_proxy_config_create_fallback_privacy_proxy";
      _os_log_impl(&dword_181A37000, v19, OS_LOG_TYPE_ERROR, "%{public}s No more than two hops are currently supported", buf, 0xCu);
    }
  }

LABEL_34:
  v23 = 0;
LABEL_164:

LABEL_165:
  return v23;
}

void nw_mem_track_check_transaction_required(void)
{
  v9 = *MEMORY[0x1E69E9840];
  os_unfair_lock_lock(&g_track_lock);
  v0 = atomic_load(&g_track_mem_total_usage);
  if (v0 < 0x4B000)
  {
    v3 = atomic_load(&g_track_mem_total_usage);
    if (v3 <= 0x8000 && g_track_process_transaction != 0)
    {
      os_release(g_track_process_transaction);
      g_track_process_transaction = 0;
      g_track_transaction_touched = 0;
      os_unfair_lock_assert_owner(&g_track_lock);
      v6 = nw_mem_track_update_source;
      if (nw_mem_track_update_source)
      {
        if (*nw_mem_track_update_source)
        {
          dispatch_source_set_timer(*nw_mem_track_update_source, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
        }

        else
        {
          *(nw_mem_track_update_source + 32) = -1;
          *(v6 + 40) = -1;
          if (*(v6 + 48) == 1 && *(v6 + 49) == 1)
          {
            nw_queue_source_run_timer(v6, v5);
          }
        }

        g_timer_set = 0;
      }

      if (gLogDatapath == 1)
      {
        v1 = __nwlog_obj();
        if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
        {
          v7 = 136446210;
          v8 = "nw_mem_track_check_transaction_required";
          v2 = "%{public}s os transaction disabled";
          goto LABEL_21;
        }
      }
    }
  }

  else if (!g_track_process_transaction)
  {
    g_track_process_transaction = os_transaction_create();
    nw_mem_track_set_timer();
    if (gLogDatapath == 1)
    {
      v1 = __nwlog_obj();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
      {
        v7 = 136446210;
        v8 = "nw_mem_track_check_transaction_required";
        v2 = "%{public}s os transaction enabled";
LABEL_21:
        _os_log_impl(&dword_181A37000, v1, OS_LOG_TYPE_DEBUG, v2, &v7, 0xCu);
      }
    }
  }

  os_unfair_lock_unlock(&g_track_lock);
}

void nw_mem_track_set_timer(void)
{
  os_unfair_lock_assert_owner(&g_track_lock);
  source = nw_mem_track_update_source;
  if (!nw_mem_track_update_source)
  {
    if (nw_context_copy_implicit_context::onceToken[0] != -1)
    {
      dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
    }

    source = nw_queue_context_create_source(nw_context_copy_implicit_context::implicit_context, 2, 3, 0, &__block_literal_global_5_70222, 0);
    nw_mem_track_update_source = source;
  }

  if ((g_timer_set & 1) == 0)
  {
    if (source)
    {
      v1 = source;
      v2 = dispatch_time(0x8000000000000000, 11000000000);
      nw_queue_set_timer_values(v1, v2, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
      nw_queue_activate_source(nw_mem_track_update_source, v3);
      g_timer_set = 1;
    }
  }
}

void ___ZL22nw_mem_track_set_timerv_block_invoke()
{
  v8 = *MEMORY[0x1E69E9840];
  g_timer_set = 0;
  os_unfair_lock_lock(&g_track_lock);
  if (gLogDatapath == 1)
  {
    v2 = __nwlog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      v4 = 136446466;
      v5 = "nw_mem_track_timer_update";
      v6 = 2048;
      v7 = g_track_mem_total_usage[0];
      _os_log_impl(&dword_181A37000, v2, OS_LOG_TYPE_DEBUG, "%{public}s total memory usage %zu", &v4, 0x16u);
    }
  }

  if (g_track_process_transaction)
  {
    if (g_track_transaction_touched)
    {
      nw_mem_track_set_timer();
    }

    else
    {
      os_release(g_track_process_transaction);
      g_track_process_transaction = 0;
      g_track_transaction_touched = 0;
      os_unfair_lock_assert_owner(&g_track_lock);
      v1 = nw_mem_track_update_source;
      if (nw_mem_track_update_source)
      {
        if (*nw_mem_track_update_source)
        {
          dispatch_source_set_timer(*nw_mem_track_update_source, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
        }

        else
        {
          *(nw_mem_track_update_source + 32) = -1;
          *(v1 + 40) = -1;
          if (*(v1 + 48) == 1 && *(v1 + 49) == 1)
          {
            nw_queue_source_run_timer(v1, v0);
          }
        }

        g_timer_set = 0;
      }

      if (gLogDatapath == 1)
      {
        v3 = __nwlog_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        {
          v4 = 136446210;
          v5 = "nw_mem_track_timer_update";
          _os_log_impl(&dword_181A37000, v3, OS_LOG_TYPE_DEBUG, "%{public}s os transaction disabled after idle", &v4, 0xCu);
        }
      }
    }
  }

  g_track_transaction_touched = 0;
  os_unfair_lock_unlock(&g_track_lock);
}

uint64_t __Block_byref_object_copy__70274(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

uint64_t nw_listener_inbox_accept_udp(uint64_t a1)
{
  MEMORY[0x1EEE9AC00](a1);
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v326 = *MEMORY[0x1E69E9840];
  v14 = v13;
  v282 = v2;
  v283 = v14;
  if (!v14)
  {
    v141 = __nwlog_obj();
    buffer = 136446210;
    v323 = "nw_listener_inbox_accept_udp";
    v44 = _os_log_send_and_compose_impl();

    LOBYTE(v319[0]) = 16;
    LOBYTE(buf) = 0;
    if (!__nwlog_fault(v44, v319, &buf))
    {
      goto LABEL_76;
    }

    if (LOBYTE(v319[0]) == 17)
    {
      v142 = __nwlog_obj();
      v143 = v319[0];
      if (os_log_type_enabled(v142, v319[0]))
      {
        buffer = 136446210;
        v323 = "nw_listener_inbox_accept_udp";
        _os_log_impl(&dword_181A37000, v142, v143, "%{public}s called with null inbox", &buffer, 0xCu);
      }
    }

    else if (buf == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v142 = __nwlog_obj();
      v149 = v319[0];
      v150 = os_log_type_enabled(v142, v319[0]);
      if (backtrace_string)
      {
        if (v150)
        {
          buffer = 136446466;
          v323 = "nw_listener_inbox_accept_udp";
          v324 = 2082;
          v325 = backtrace_string;
          _os_log_impl(&dword_181A37000, v142, v149, "%{public}s called with null inbox, dumping backtrace:%{public}s", &buffer, 0x16u);
        }

        goto LABEL_299;
      }

      if (v150)
      {
        buffer = 136446210;
        v323 = "nw_listener_inbox_accept_udp";
        _os_log_impl(&dword_181A37000, v142, v149, "%{public}s called with null inbox, no backtrace", &buffer, 0xCu);
      }
    }

    else
    {
      v142 = __nwlog_obj();
      v167 = v319[0];
      if (os_log_type_enabled(v142, v319[0]))
      {
        buffer = 136446210;
        v323 = "nw_listener_inbox_accept_udp";
        _os_log_impl(&dword_181A37000, v142, v167, "%{public}s called with null inbox, backtrace limit exceeded", &buffer, 0xCu);
      }
    }

LABEL_312:

    goto LABEL_76;
  }

  if (v14[88] != 17)
  {
    v144 = __nwlog_obj();
    buffer = 136446210;
    v323 = "nw_listener_inbox_accept_udp";
    v44 = _os_log_send_and_compose_impl();

    LOBYTE(v319[0]) = 16;
    LOBYTE(buf) = 0;
    if (!__nwlog_fault(v44, v319, &buf))
    {
      goto LABEL_76;
    }

    if (LOBYTE(v319[0]) == 17)
    {
      v142 = __nwlog_obj();
      v145 = v319[0];
      if (os_log_type_enabled(v142, v319[0]))
      {
        buffer = 136446210;
        v323 = "nw_listener_inbox_accept_udp";
        _os_log_impl(&dword_181A37000, v142, v145, "%{public}s called with null (inbox->_ipProtocol == 17)", &buffer, 0xCu);
      }
    }

    else if (buf == 1)
    {
      v151 = __nw_create_backtrace_string();
      v142 = __nwlog_obj();
      v152 = v319[0];
      v153 = os_log_type_enabled(v142, v319[0]);
      if (v151)
      {
        if (v153)
        {
          buffer = 136446466;
          v323 = "nw_listener_inbox_accept_udp";
          v324 = 2082;
          v325 = v151;
          _os_log_impl(&dword_181A37000, v142, v152, "%{public}s called with null (inbox->_ipProtocol == 17), dumping backtrace:%{public}s", &buffer, 0x16u);
        }

        free(v151);
        goto LABEL_76;
      }

      if (v153)
      {
        buffer = 136446210;
        v323 = "nw_listener_inbox_accept_udp";
        _os_log_impl(&dword_181A37000, v142, v152, "%{public}s called with null (inbox->_ipProtocol == 17), no backtrace", &buffer, 0xCu);
      }
    }

    else
    {
      v142 = __nwlog_obj();
      v168 = v319[0];
      if (os_log_type_enabled(v142, v319[0]))
      {
        buffer = 136446210;
        v323 = "nw_listener_inbox_accept_udp";
        _os_log_impl(&dword_181A37000, v142, v168, "%{public}s called with null (inbox->_ipProtocol == 17), backtrace limit exceeded", &buffer, 0xCu);
      }
    }

    goto LABEL_312;
  }

  bzero(&buffer, 0x2400uLL);
  v320[0] = 0;
  v320[1] = 0;
  v321 = 0;
  *&v306.msg_iovlen = 1;
  memset(v319, 0, sizeof(v319));
  v306.msg_name = v6;
  *&v306.msg_namelen = 128;
  v307[0] = &buffer;
  v307[1] = 9216;
  v306.msg_iov = v307;
  v306.msg_control = v319;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  *&v306.msg_controllen = 0x8000000100;
  while (1)
  {
    v16 = recvmsg(v12, &v306, 0);
    if ((v16 & 0x8000000000000000) == 0)
    {
      break;
    }

    v17 = **(StatusReg + 8);
    if (v17 != 4)
    {
      if (v17 != 35)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          buf = 136446466;
          v309 = "nw_listener_inbox_accept_udp";
          v310 = 1024;
          *v311 = v17;
          _os_log_impl(&dword_181A37000, v18, OS_LOG_TYPE_ERROR, "%{public}s UDP listen socket recvmsg %{darwin.errno}d", &buf, 0x12u);
        }

        v19 = *(v283 + 1);
        posix_error = nw_error_create_posix_error(v17);
        [v19 handleInboxFailed:v283 error:posix_error];
      }

      goto LABEL_78;
    }
  }

  if (v8)
  {
    *v8 = 1;
  }

  memset(v304, 0, sizeof(v304));
  v305 = 0;
  if ((nw_endpoint_fillout_v4v6_address(*(v283 + 4), v304) & 1) == 0)
  {
    v163 = __nwlog_obj();
    buf = 136446210;
    v309 = "nw_listener_inbox_accept_udp";
    v44 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    __src[0].sa_len = 0;
    if (!__nwlog_fault(v44, type, __src))
    {
      goto LABEL_76;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v45 = __nwlog_obj();
      v164 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        buf = 136446210;
        v309 = "nw_listener_inbox_accept_udp";
        _os_log_impl(&dword_181A37000, v45, v164, "%{public}s called with null success", &buf, 0xCu);
      }

      goto LABEL_75;
    }

    if (__src[0].sa_len != 1)
    {
      v45 = __nwlog_obj();
      v173 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        buf = 136446210;
        v309 = "nw_listener_inbox_accept_udp";
        _os_log_impl(&dword_181A37000, v45, v173, "%{public}s called with null success, backtrace limit exceeded", &buf, 0xCu);
      }

      goto LABEL_75;
    }

    backtrace_string = __nw_create_backtrace_string();
    v45 = __nwlog_obj();
    v170 = type[0];
    v171 = os_log_type_enabled(v45, type[0]);
    if (!backtrace_string)
    {
      if (v171)
      {
        buf = 136446210;
        v309 = "nw_listener_inbox_accept_udp";
        _os_log_impl(&dword_181A37000, v45, v170, "%{public}s called with null success, no backtrace", &buf, 0xCu);
      }

      goto LABEL_75;
    }

    if (v171)
    {
      buf = 136446466;
      v309 = "nw_listener_inbox_accept_udp";
      v310 = 2082;
      *v311 = backtrace_string;
      _os_log_impl(&dword_181A37000, v45, v170, "%{public}s called with null success, dumping backtrace:%{public}s", &buf, 0x16u);
    }

LABEL_299:
    free(backtrace_string);
    if (!v44)
    {
      goto LABEL_78;
    }

    goto LABEL_77;
  }

  memset(__src, 0, 28);
  if (v306.msg_controllen < 0xC || (msg_control = v306.msg_control) == 0)
  {
LABEL_50:
    if (!if_indextoname(HIDWORD(v305), v320))
    {
      LOBYTE(v320[0]) = 0;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v42 = gLogObj;
    sa_len = v6->sa_len;
    buf = 136448002;
    v309 = "nw_listener_inbox_accept_udp";
    v310 = 1024;
    *v311 = v12;
    *&v311[4] = 2048;
    *&v311[6] = v16;
    *&v311[14] = 2080;
    *&v311[16] = v320;
    *&v311[24] = 1040;
    *v312 = sa_len;
    *&v312[4] = 2098;
    *&v312[6] = v6;
    v313 = 1040;
    v314 = __src[0].sa_len;
    v315 = 2098;
    v316 = __src;
    v44 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v293[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v44, type, v293))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v45 = gLogObj;
        v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          v47 = v6->sa_len;
          buf = 136448002;
          v309 = "nw_listener_inbox_accept_udp";
          v310 = 1024;
          *v311 = v12;
          *&v311[4] = 2048;
          *&v311[6] = v16;
          *&v311[14] = 2080;
          *&v311[16] = v320;
          *&v311[24] = 1040;
          *v312 = v47;
          *&v312[4] = 2098;
          *&v312[6] = v6;
          v313 = 1040;
          v314 = __src[0].sa_len;
          v315 = 2098;
          v316 = __src;
          _os_log_impl(&dword_181A37000, v45, v46, "%{public}s recvmsg(%d) got %ld bytes on %s from %{public,network:sockaddr}.*P with bad local address %{public,network:sockaddr}.*P", &buf, 0x46u);
        }

LABEL_75:

        goto LABEL_76;
      }

      if (v293[0] != OS_LOG_TYPE_INFO)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v45 = gLogObj;
        v52 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          v53 = v6->sa_len;
          buf = 136448002;
          v309 = "nw_listener_inbox_accept_udp";
          v310 = 1024;
          *v311 = v12;
          *&v311[4] = 2048;
          *&v311[6] = v16;
          *&v311[14] = 2080;
          *&v311[16] = v320;
          *&v311[24] = 1040;
          *v312 = v53;
          *&v312[4] = 2098;
          *&v312[6] = v6;
          v313 = 1040;
          v314 = __src[0].sa_len;
          v315 = 2098;
          v316 = __src;
          _os_log_impl(&dword_181A37000, v45, v52, "%{public}s recvmsg(%d) got %ld bytes on %s from %{public,network:sockaddr}.*P with bad local address %{public,network:sockaddr}.*P, backtrace limit exceeded", &buf, 0x46u);
        }

        goto LABEL_75;
      }

      v48 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v45 = gLogObj;
      v49 = type[0];
      v50 = os_log_type_enabled(v45, type[0]);
      if (!v48)
      {
        if (v50)
        {
          v59 = v6->sa_len;
          buf = 136448002;
          v309 = "nw_listener_inbox_accept_udp";
          v310 = 1024;
          *v311 = v12;
          *&v311[4] = 2048;
          *&v311[6] = v16;
          *&v311[14] = 2080;
          *&v311[16] = v320;
          *&v311[24] = 1040;
          *v312 = v59;
          *&v312[4] = 2098;
          *&v312[6] = v6;
          v313 = 1040;
          v314 = __src[0].sa_len;
          v315 = 2098;
          v316 = __src;
          _os_log_impl(&dword_181A37000, v45, v49, "%{public}s recvmsg(%d) got %ld bytes on %s from %{public,network:sockaddr}.*P with bad local address %{public,network:sockaddr}.*P, no backtrace", &buf, 0x46u);
        }

        goto LABEL_75;
      }

      if (v50)
      {
        v51 = v6->sa_len;
        buf = 136448258;
        v309 = "nw_listener_inbox_accept_udp";
        v310 = 1024;
        *v311 = v12;
        *&v311[4] = 2048;
        *&v311[6] = v16;
        *&v311[14] = 2080;
        *&v311[16] = v320;
        *&v311[24] = 1040;
        *v312 = v51;
        *&v312[4] = 2098;
        *&v312[6] = v6;
        v313 = 1040;
        v314 = __src[0].sa_len;
        v315 = 2098;
        v316 = __src;
        v317 = 2082;
        v318 = v48;
        _os_log_impl(&dword_181A37000, v45, v49, "%{public}s recvmsg(%d) got %ld bytes on %s from %{public,network:sockaddr}.*P with bad local address %{public,network:sockaddr}.*P, dumping backtrace:%{public}s", &buf, 0x50u);
      }

      free(v48);
      if (!v44)
      {
        goto LABEL_78;
      }

LABEL_77:
      free(v44);
      goto LABEL_78;
    }

LABEL_76:
    if (!v44)
    {
      goto LABEL_78;
    }

    goto LABEL_77;
  }

  v22 = 0;
  v23 = 0;
  v24 = HIBYTE(v304[0]);
  v25 = v304[1];
  v26 = (v306.msg_control + v306.msg_controllen);
  do
  {
    if (v24 == 2)
    {
      if (!msg_control[1])
      {
        v31 = msg_control[2];
        if (v31 == 20)
        {
          HIDWORD(v305) = *(msg_control + 7);
        }

        else if (v31 == 7)
        {
          *&__src[0].sa_len = 528;
          *&__src[0].sa_data[6] = 0;
          *&__src[0].sa_data[2] = msg_control[3];
          *__src[0].sa_data = v25;
          v23 = 16;
          v22 = 2;
        }
      }
    }

    else if (v24 == 30 && msg_control[1] == 41 && msg_control[2] == 46)
    {
      *&__src[0].sa_len = 7708;
      memset(&__src[0].sa_data[6], 0, 20);
      *&__src[0].sa_data[6] = *(msg_control + 3);
      v29 = msg_control[7];
      HIDWORD(v305) = v29;
      if (__src[0].sa_data[6] != 254 || (__src[0].sa_data[7] & 0xC0) != 0x80)
      {
        v29 = 0;
      }

      *&__src[1].sa_data[6] = v29;
      *__src[0].sa_data = v25;
      v23 = 28;
      v22 = 30;
    }

    if (v4)
    {
      v30 = msg_control[1];
      if (v30 != 41)
      {
        if (v30 || msg_control[2] != 27)
        {
          goto LABEL_17;
        }

LABEL_16:
        *v4 = msg_control[3];
        goto LABEL_17;
      }

      if (msg_control[2] == 36)
      {
        goto LABEL_16;
      }
    }

LABEL_17:
    v27 = (msg_control + ((*msg_control + 3) & 0x1FFFFFFFCLL));
    if (v27 + 3 <= v26)
    {
      v28 = v27 == msg_control;
    }

    else
    {
      v27 = 0;
      v28 = 1;
    }

    msg_control = v27;
  }

  while (!v28);
  if (!v23 || !v22)
  {
    goto LABEL_50;
  }

  if (![v283 multicast])
  {
    if (v16)
    {
      v54 = dispatch_data_create(&buffer, v16, 0, 0);

      if (!v54)
      {
        v55 = __nwlog_obj();
        buf = 136446210;
        v309 = "nw_listener_inbox_accept_udp";
        v56 = _os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v293[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v56, type, v293))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v57 = __nwlog_obj();
            v58 = type[0];
            if (os_log_type_enabled(v57, type[0]))
            {
              buf = 136446210;
              v309 = "nw_listener_inbox_accept_udp";
              _os_log_impl(&dword_181A37000, v57, v58, "%{public}s dispatch_data_create failed", &buf, 0xCu);
            }
          }

          else if (v293[0] == OS_LOG_TYPE_INFO)
          {
            v72 = __nw_create_backtrace_string();
            v57 = __nwlog_obj();
            v73 = type[0];
            v74 = os_log_type_enabled(v57, type[0]);
            if (v72)
            {
              if (v74)
              {
                buf = 136446466;
                v309 = "nw_listener_inbox_accept_udp";
                v310 = 2082;
                *v311 = v72;
                _os_log_impl(&dword_181A37000, v57, v73, "%{public}s dispatch_data_create failed, dumping backtrace:%{public}s", &buf, 0x16u);
              }

              free(v72);
              goto LABEL_199;
            }

            if (v74)
            {
              buf = 136446210;
              v309 = "nw_listener_inbox_accept_udp";
              _os_log_impl(&dword_181A37000, v57, v73, "%{public}s dispatch_data_create failed, no backtrace", &buf, 0xCu);
            }
          }

          else
          {
            v57 = __nwlog_obj();
            v100 = type[0];
            if (os_log_type_enabled(v57, type[0]))
            {
              buf = 136446210;
              v309 = "nw_listener_inbox_accept_udp";
              _os_log_impl(&dword_181A37000, v57, v100, "%{public}s dispatch_data_create failed, backtrace limit exceeded", &buf, 0xCu);
            }
          }
        }

LABEL_199:
        if (v56)
        {
          free(v56);
        }

        v64 = 0;
        goto LABEL_411;
      }
    }

    else
    {
      v54 = MEMORY[0x1E69E9668];
      v62 = MEMORY[0x1E69E9668];
    }

    v281 = v54;
    v63 = v283;
    if (v282)
    {
      if (_nw_array_get_count(v282))
      {
        aBlock[0] = MEMORY[0x1E69E9820];
        aBlock[1] = 3221225472;
        aBlock[2] = ___ZL28nw_listener_inbox_accept_udpP24nw_listener_inbox_socketiPiPbP8sockaddrjP16nw_ip_ecn_flag_tPU22objcproto11OS_nw_array8NSObject_block_invoke;
        aBlock[3] = &unk_1E6A39A48;
        v300 = v6;
        v302[0] = __src[0];
        *(v302 + 12) = *&__src[0].sa_data[10];
        v64 = v281;
        v299 = v64;
        v301 = v4;
        v65 = _nw_array_apply(v282, aBlock);

        v63 = v283;
        if (!v65)
        {
LABEL_411:
          v60 = 0;
          goto LABEL_412;
        }
      }
    }

    if (nw_parameters_get_upper_transport_protocol(*(v63 + 6)) != 253)
    {
LABEL_147:
      v101 = socket(HIBYTE(v304[0]), 2, 0);
      v102 = v101;
      v64 = v281;
      if ((v101 & 0x80000000) == 0)
      {
        *type = 1;
        if (setsockopt(v101, 0xFFFF, 4, type, 4u))
        {
          v103 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          v104 = __nwlog_obj();
          buf = 136446466;
          v309 = "nw_listener_inbox_accept_udp";
          v310 = 1024;
          *v311 = v103;
          v105 = _os_log_send_and_compose_impl();

          v293[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v297) = 0;
          if (!__nwlog_fault(v105, v293, &v297))
          {
            goto LABEL_408;
          }

          if (v293[0] == OS_LOG_TYPE_FAULT)
          {
            v106 = __nwlog_obj();
            v107 = v293[0];
            if (os_log_type_enabled(v106, v293[0]))
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v103;
              _os_log_impl(&dword_181A37000, v106, v107, "%{public}s SO_REUSEADDR failed %{darwin.errno}d", &buf, 0x12u);
            }

LABEL_407:

LABEL_408:
            v64 = v281;
            if (v105)
            {
              free(v105);
            }

            goto LABEL_410;
          }

          if (v297 != 1)
          {
            v106 = __nwlog_obj();
            v122 = v293[0];
            if (os_log_type_enabled(v106, v293[0]))
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v103;
              _os_log_impl(&dword_181A37000, v106, v122, "%{public}s SO_REUSEADDR failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x12u);
            }

            goto LABEL_407;
          }

          v116 = __nw_create_backtrace_string();
          v106 = __nwlog_obj();
          v117 = v293[0];
          v118 = os_log_type_enabled(v106, v293[0]);
          if (!v116)
          {
            if (v118)
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v103;
              _os_log_impl(&dword_181A37000, v106, v117, "%{public}s SO_REUSEADDR failed %{darwin.errno}d, no backtrace", &buf, 0x12u);
            }

            goto LABEL_407;
          }

          if (v118)
          {
            buf = 136446722;
            v309 = "nw_listener_inbox_accept_udp";
            v310 = 1024;
            *v311 = v103;
            *&v311[4] = 2082;
            *&v311[6] = v116;
            _os_log_impl(&dword_181A37000, v106, v117, "%{public}s SO_REUSEADDR failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x1Cu);
          }

LABEL_193:

          free(v116);
          goto LABEL_408;
        }

        if (setsockopt(v102, 0xFFFF, 512, type, 4u))
        {
          v113 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          v114 = __nwlog_obj();
          buf = 136446466;
          v309 = "nw_listener_inbox_accept_udp";
          v310 = 1024;
          *v311 = v113;
          v105 = _os_log_send_and_compose_impl();

          v293[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v297) = 0;
          if (!__nwlog_fault(v105, v293, &v297))
          {
            goto LABEL_408;
          }

          if (v293[0] == OS_LOG_TYPE_FAULT)
          {
            v106 = __nwlog_obj();
            v115 = v293[0];
            if (os_log_type_enabled(v106, v293[0]))
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v113;
              _os_log_impl(&dword_181A37000, v106, v115, "%{public}s SO_REUSEPORT failed %{darwin.errno}d", &buf, 0x12u);
            }

            goto LABEL_407;
          }

          if (v297 != 1)
          {
            v106 = __nwlog_obj();
            v134 = v293[0];
            if (os_log_type_enabled(v106, v293[0]))
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v113;
              _os_log_impl(&dword_181A37000, v106, v134, "%{public}s SO_REUSEPORT failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x12u);
            }

            goto LABEL_407;
          }

          v116 = __nw_create_backtrace_string();
          v106 = __nwlog_obj();
          v127 = v293[0];
          v128 = os_log_type_enabled(v106, v293[0]);
          if (!v116)
          {
            if (v128)
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v113;
              _os_log_impl(&dword_181A37000, v106, v127, "%{public}s SO_REUSEPORT failed %{darwin.errno}d, no backtrace", &buf, 0x12u);
            }

            goto LABEL_407;
          }

          if (v128)
          {
            buf = 136446722;
            v309 = "nw_listener_inbox_accept_udp";
            v310 = 1024;
            *v311 = v113;
            *&v311[4] = 2082;
            *&v311[6] = v116;
            _os_log_impl(&dword_181A37000, v106, v127, "%{public}s SO_REUSEPORT failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x1Cu);
          }

          goto LABEL_193;
        }

        if (ioctl(v102, 0x8004667EuLL, type) < 0)
        {
          v135 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          v136 = __nwlog_obj();
          buf = 136446466;
          v309 = "nw_listener_inbox_accept_udp";
          v310 = 1024;
          *v311 = v135;
          v105 = _os_log_send_and_compose_impl();

          v293[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v297) = 0;
          if (!__nwlog_fault(v105, v293, &v297))
          {
            goto LABEL_408;
          }

          if (v293[0] == OS_LOG_TYPE_FAULT)
          {
            v106 = __nwlog_obj();
            v137 = v293[0];
            if (os_log_type_enabled(v106, v293[0]))
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v135;
              _os_log_impl(&dword_181A37000, v106, v137, "%{public}s FIONBIO failed %{darwin.errno}d", &buf, 0x12u);
            }

            goto LABEL_407;
          }

          if (v297 != 1)
          {
            v106 = __nwlog_obj();
            v162 = v293[0];
            if (os_log_type_enabled(v106, v293[0]))
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v135;
              _os_log_impl(&dword_181A37000, v106, v162, "%{public}s FIONBIO failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x12u);
            }

            goto LABEL_407;
          }

          v116 = __nw_create_backtrace_string();
          v106 = __nwlog_obj();
          v146 = v293[0];
          v147 = os_log_type_enabled(v106, v293[0]);
          if (!v116)
          {
            if (v147)
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v135;
              _os_log_impl(&dword_181A37000, v106, v146, "%{public}s FIONBIO failed %{darwin.errno}d, no backtrace", &buf, 0x12u);
            }

            goto LABEL_407;
          }

          if (v147)
          {
            buf = 136446722;
            v309 = "nw_listener_inbox_accept_udp";
            v310 = 1024;
            *v311 = v135;
            *&v311[4] = 2082;
            *&v311[6] = v116;
            _os_log_impl(&dword_181A37000, v106, v146, "%{public}s FIONBIO failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x1Cu);
          }

          goto LABEL_193;
        }

        if (nw_parameters_get_use_awdl(*(v283 + 6)) && setsockopt(v102, 0xFFFF, 4356, type, 4u))
        {
          v124 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          v125 = __nwlog_obj();
          buf = 136446466;
          v309 = "nw_listener_inbox_accept_udp";
          v310 = 1024;
          *v311 = v124;
          v105 = _os_log_send_and_compose_impl();

          v293[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v297) = 0;
          if (!__nwlog_fault(v105, v293, &v297))
          {
            goto LABEL_408;
          }

          if (v293[0] == OS_LOG_TYPE_FAULT)
          {
            v106 = __nwlog_obj();
            v126 = v293[0];
            if (os_log_type_enabled(v106, v293[0]))
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v124;
              _os_log_impl(&dword_181A37000, v106, v126, "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d", &buf, 0x12u);
            }

            goto LABEL_407;
          }

          if (v297 != 1)
          {
            v106 = __nwlog_obj();
            v169 = v293[0];
            if (os_log_type_enabled(v106, v293[0]))
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v124;
              _os_log_impl(&dword_181A37000, v106, v169, "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x12u);
            }

            goto LABEL_407;
          }

          v116 = __nw_create_backtrace_string();
          v106 = __nwlog_obj();
          v160 = v293[0];
          v161 = os_log_type_enabled(v106, v293[0]);
          if (!v116)
          {
            if (v161)
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v124;
              _os_log_impl(&dword_181A37000, v106, v160, "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, no backtrace", &buf, 0x12u);
            }

            goto LABEL_407;
          }

          if (v161)
          {
            buf = 136446722;
            v309 = "nw_listener_inbox_accept_udp";
            v310 = 1024;
            *v311 = v124;
            *&v311[4] = 2082;
            *&v311[6] = v116;
            _os_log_impl(&dword_181A37000, v106, v160, "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x1Cu);
          }

          goto LABEL_193;
        }

        if (!nw_parameters_get_no_wake_from_sleep(*(v283 + 6)) || !setsockopt(v102, 0xFFFF, 0x10000, type, 4u))
        {
LABEL_324:
          v174 = *(v283 + 5);
          if (v174 && _nw_interface_get_subtype(v174) == 4001 && setsockopt(v102, 0xFFFF, 4376, type, 4u))
          {
            v175 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            v176 = __nwlog_obj();
            buf = 136446722;
            v309 = "nw_listener_inbox_accept_udp";
            v310 = 1024;
            *v311 = v102;
            *&v311[4] = 1024;
            *&v311[6] = v175;
            v105 = _os_log_send_and_compose_impl();

            v293[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v297) = 0;
            if (!__nwlog_fault(v105, v293, &v297))
            {
              goto LABEL_408;
            }

            if (v293[0] == OS_LOG_TYPE_FAULT)
            {
              v106 = __nwlog_obj();
              v177 = v293[0];
              if (os_log_type_enabled(v106, v293[0]))
              {
                buf = 136446722;
                v309 = "nw_listener_inbox_accept_udp";
                v310 = 1024;
                *v311 = v102;
                *&v311[4] = 1024;
                *&v311[6] = v175;
                _os_log_impl(&dword_181A37000, v106, v177, "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d", &buf, 0x18u);
              }

              goto LABEL_407;
            }

            if (v297 != 1)
            {
              v106 = __nwlog_obj();
              v198 = v293[0];
              if (os_log_type_enabled(v106, v293[0]))
              {
                buf = 136446722;
                v309 = "nw_listener_inbox_accept_udp";
                v310 = 1024;
                *v311 = v102;
                *&v311[4] = 1024;
                *&v311[6] = v175;
                _os_log_impl(&dword_181A37000, v106, v198, "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x18u);
              }

              goto LABEL_407;
            }

            v116 = __nw_create_backtrace_string();
            v106 = __nwlog_obj();
            v192 = v293[0];
            v193 = os_log_type_enabled(v106, v293[0]);
            if (!v116)
            {
              if (v193)
              {
                buf = 136446722;
                v309 = "nw_listener_inbox_accept_udp";
                v310 = 1024;
                *v311 = v102;
                *&v311[4] = 1024;
                *&v311[6] = v175;
                _os_log_impl(&dword_181A37000, v106, v192, "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, no backtrace", &buf, 0x18u);
              }

              goto LABEL_407;
            }

            if (v193)
            {
              buf = 136446978;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v102;
              *&v311[4] = 1024;
              *&v311[6] = v175;
              *&v311[10] = 2082;
              *&v311[12] = v116;
              _os_log_impl(&dword_181A37000, v106, v192, "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x22u);
            }

            goto LABEL_193;
          }

          if (HIDWORD(v305))
          {
            v178 = HIBYTE(v304[0]);
            if (HIBYTE(v304[0]) == 30)
            {
              if (setsockopt(v102, 41, 125, &v305 + 4, 4u))
              {
                v182 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                v183 = __nwlog_obj();
                v181 = v183;
                if (v182 == 6)
                {
                  if (os_log_type_enabled(v183, OS_LOG_TYPE_ERROR))
                  {
                    buf = 136446722;
                    v309 = "nw_listener_inbox_accept_udp";
                    v310 = 1024;
                    *v311 = HIDWORD(v305);
                    *&v311[4] = 1024;
                    *&v311[6] = 6;
                    _os_log_impl(&dword_181A37000, v181, OS_LOG_TYPE_ERROR, "%{public}s IPV6_BOUND_IF %u failed %{darwin.errno}d", &buf, 0x18u);
                  }

                  goto LABEL_339;
                }

                buf = 136446722;
                v309 = "nw_listener_inbox_accept_udp";
                v310 = 1024;
                *v311 = HIDWORD(v305);
                *&v311[4] = 1024;
                *&v311[6] = v182;
                v194 = _os_log_send_and_compose_impl();

                v293[0] = OS_LOG_TYPE_ERROR;
                LOBYTE(v297) = 0;
                if (!__nwlog_fault(v194, v293, &v297))
                {
                  goto LABEL_559;
                }

                if (v293[0] == OS_LOG_TYPE_FAULT)
                {
                  v195 = __nwlog_obj();
                  v197 = v293[0];
                  if (os_log_type_enabled(v195, v293[0]))
                  {
                    buf = 136446722;
                    v309 = "nw_listener_inbox_accept_udp";
                    v310 = 1024;
                    *v311 = HIDWORD(v305);
                    *&v311[4] = 1024;
                    *&v311[6] = v182;
                    _os_log_impl(&dword_181A37000, v195, v197, "%{public}s IPV6_BOUND_IF %u failed %{darwin.errno}d", &buf, 0x18u);
                  }

                  goto LABEL_558;
                }

                if (v297 != 1)
                {
                  v195 = __nwlog_obj();
                  v219 = v293[0];
                  if (os_log_type_enabled(v195, v293[0]))
                  {
                    buf = 136446722;
                    v309 = "nw_listener_inbox_accept_udp";
                    v310 = 1024;
                    *v311 = HIDWORD(v305);
                    *&v311[4] = 1024;
                    *&v311[6] = v182;
                    _os_log_impl(&dword_181A37000, v195, v219, "%{public}s IPV6_BOUND_IF %u failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x18u);
                  }

                  goto LABEL_558;
                }

                v203 = __nw_create_backtrace_string();
                v195 = __nwlog_obj();
                v206 = v293[0];
                v207 = os_log_type_enabled(v195, v293[0]);
                if (!v203)
                {
                  if (v207)
                  {
                    buf = 136446722;
                    v309 = "nw_listener_inbox_accept_udp";
                    v310 = 1024;
                    *v311 = HIDWORD(v305);
                    *&v311[4] = 1024;
                    *&v311[6] = v182;
                    _os_log_impl(&dword_181A37000, v195, v206, "%{public}s IPV6_BOUND_IF %u failed %{darwin.errno}d, no backtrace", &buf, 0x18u);
                  }

                  goto LABEL_558;
                }

                if (v207)
                {
                  buf = 136446978;
                  v309 = "nw_listener_inbox_accept_udp";
                  v310 = 1024;
                  *v311 = HIDWORD(v305);
                  *&v311[4] = 1024;
                  *&v311[6] = v182;
                  *&v311[10] = 2082;
                  *&v311[12] = v203;
                  _os_log_impl(&dword_181A37000, v195, v206, "%{public}s IPV6_BOUND_IF %u failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x22u);
                }

                goto LABEL_502;
              }
            }

            else
            {
              if (HIBYTE(v304[0]) != 2)
              {
                goto LABEL_346;
              }

              if (setsockopt(v102, 0, 25, &v305 + 4, 4u))
              {
                v179 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                v180 = __nwlog_obj();
                v181 = v180;
                if (v179 == 6)
                {
                  if (os_log_type_enabled(v180, OS_LOG_TYPE_ERROR))
                  {
                    buf = 136446722;
                    v309 = "nw_listener_inbox_accept_udp";
                    v310 = 1024;
                    *v311 = HIDWORD(v305);
                    *&v311[4] = 1024;
                    *&v311[6] = 6;
                    _os_log_impl(&dword_181A37000, v181, OS_LOG_TYPE_ERROR, "%{public}s IP_BOUND_IF %u failed %{darwin.errno}d", &buf, 0x18u);
                  }

LABEL_339:

LABEL_561:
                  v64 = v281;
LABEL_410:
                  close(v102);
                  goto LABEL_411;
                }

                buf = 136446722;
                v309 = "nw_listener_inbox_accept_udp";
                v310 = 1024;
                *v311 = HIDWORD(v305);
                *&v311[4] = 1024;
                *&v311[6] = v179;
                v194 = _os_log_send_and_compose_impl();

                v293[0] = OS_LOG_TYPE_ERROR;
                LOBYTE(v297) = 0;
                if (!__nwlog_fault(v194, v293, &v297))
                {
                  goto LABEL_559;
                }

                if (v293[0] == OS_LOG_TYPE_FAULT)
                {
                  v195 = __nwlog_obj();
                  v196 = v293[0];
                  if (os_log_type_enabled(v195, v293[0]))
                  {
                    buf = 136446722;
                    v309 = "nw_listener_inbox_accept_udp";
                    v310 = 1024;
                    *v311 = HIDWORD(v305);
                    *&v311[4] = 1024;
                    *&v311[6] = v179;
                    _os_log_impl(&dword_181A37000, v195, v196, "%{public}s IP_BOUND_IF %u failed %{darwin.errno}d", &buf, 0x18u);
                  }

                  goto LABEL_558;
                }

                if (v297 != 1)
                {
                  v195 = __nwlog_obj();
                  v218 = v293[0];
                  if (os_log_type_enabled(v195, v293[0]))
                  {
                    buf = 136446722;
                    v309 = "nw_listener_inbox_accept_udp";
                    v310 = 1024;
                    *v311 = HIDWORD(v305);
                    *&v311[4] = 1024;
                    *&v311[6] = v179;
                    _os_log_impl(&dword_181A37000, v195, v218, "%{public}s IP_BOUND_IF %u failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x18u);
                  }

                  goto LABEL_558;
                }

                v203 = __nw_create_backtrace_string();
                v195 = __nwlog_obj();
                v204 = v293[0];
                v205 = os_log_type_enabled(v195, v293[0]);
                if (!v203)
                {
                  if (v205)
                  {
                    buf = 136446722;
                    v309 = "nw_listener_inbox_accept_udp";
                    v310 = 1024;
                    *v311 = HIDWORD(v305);
                    *&v311[4] = 1024;
                    *&v311[6] = v179;
                    _os_log_impl(&dword_181A37000, v195, v204, "%{public}s IP_BOUND_IF %u failed %{darwin.errno}d, no backtrace", &buf, 0x18u);
                  }

                  goto LABEL_558;
                }

                if (v205)
                {
                  buf = 136446978;
                  v309 = "nw_listener_inbox_accept_udp";
                  v310 = 1024;
                  *v311 = HIDWORD(v305);
                  *&v311[4] = 1024;
                  *&v311[6] = v179;
                  *&v311[10] = 2082;
                  *&v311[12] = v203;
                  _os_log_impl(&dword_181A37000, v195, v204, "%{public}s IP_BOUND_IF %u failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x22u);
                }

LABEL_502:

                free(v203);
                if (!v194)
                {
                  goto LABEL_561;
                }

                goto LABEL_560;
              }
            }
          }

          v178 = HIBYTE(v304[0]);
LABEL_346:
          if (v178 == 2)
          {
            if (setsockopt(v102, 0, 27, type, 4u) < 0)
            {
              v189 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
              v190 = __nwlog_obj();
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v189;
              v186 = _os_log_send_and_compose_impl();

              v293[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v297) = 0;
              if (!__nwlog_fault(v186, v293, &v297))
              {
                goto LABEL_459;
              }

              if (v293[0] == OS_LOG_TYPE_FAULT)
              {
                v187 = __nwlog_obj();
                v191 = v293[0];
                if (os_log_type_enabled(v187, v293[0]))
                {
                  buf = 136446466;
                  v309 = "nw_listener_inbox_accept_udp";
                  v310 = 1024;
                  *v311 = v189;
                  _os_log_impl(&dword_181A37000, v187, v191, "%{public}s IP_RECVTOS failed %{darwin.errno}d", &buf, 0x12u);
                }
              }

              else if (v297 == 1)
              {
                v201 = __nw_create_backtrace_string();
                v187 = __nwlog_obj();
                v276 = v293[0];
                v202 = os_log_type_enabled(v187, v293[0]);
                if (v201)
                {
                  if (v202)
                  {
                    buf = 136446722;
                    v309 = "nw_listener_inbox_accept_udp";
                    v310 = 1024;
                    *v311 = v189;
                    *&v311[4] = 2082;
                    *&v311[6] = v201;
                    _os_log_impl(&dword_181A37000, v187, v276, "%{public}s IP_RECVTOS failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x1Cu);
                  }

                  free(v201);
LABEL_459:
                  if (!v186)
                  {
LABEL_461:
                    v64 = v281;
                    goto LABEL_462;
                  }

LABEL_460:
                  free(v186);
                  goto LABEL_461;
                }

                if (v202)
                {
                  buf = 136446466;
                  v309 = "nw_listener_inbox_accept_udp";
                  v310 = 1024;
                  *v311 = v189;
                  _os_log_impl(&dword_181A37000, v187, v276, "%{public}s IP_RECVTOS failed %{darwin.errno}d, no backtrace", &buf, 0x12u);
                }
              }

              else
              {
                v187 = __nwlog_obj();
                v209 = v293[0];
                if (os_log_type_enabled(v187, v293[0]))
                {
                  buf = 136446466;
                  v309 = "nw_listener_inbox_accept_udp";
                  v310 = 1024;
                  *v311 = v189;
                  _os_log_impl(&dword_181A37000, v187, v209, "%{public}s IP_RECVTOS failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x12u);
                }
              }

LABEL_458:

              goto LABEL_459;
            }
          }

          else if (v178 == 30 && setsockopt(v102, 41, 35, type, 4u) < 0)
          {
            v184 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            v185 = __nwlog_obj();
            buf = 136446466;
            v309 = "nw_listener_inbox_accept_udp";
            v310 = 1024;
            *v311 = v184;
            v186 = _os_log_send_and_compose_impl();

            v293[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v297) = 0;
            if (!__nwlog_fault(v186, v293, &v297))
            {
              goto LABEL_459;
            }

            if (v293[0] == OS_LOG_TYPE_FAULT)
            {
              v187 = __nwlog_obj();
              v188 = v293[0];
              if (os_log_type_enabled(v187, v293[0]))
              {
                buf = 136446466;
                v309 = "nw_listener_inbox_accept_udp";
                v310 = 1024;
                *v311 = v184;
                _os_log_impl(&dword_181A37000, v187, v188, "%{public}s IPV6_RECVTCLASS failed %{darwin.errno}d", &buf, 0x12u);
              }
            }

            else if (v297 == 1)
            {
              v199 = __nw_create_backtrace_string();
              v187 = __nwlog_obj();
              v275 = v293[0];
              v200 = os_log_type_enabled(v187, v293[0]);
              if (v199)
              {
                if (v200)
                {
                  buf = 136446722;
                  v309 = "nw_listener_inbox_accept_udp";
                  v310 = 1024;
                  *v311 = v184;
                  *&v311[4] = 2082;
                  *&v311[6] = v199;
                  _os_log_impl(&dword_181A37000, v187, v275, "%{public}s IPV6_RECVTCLASS failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x1Cu);
                }

                free(v199);
                if (!v186)
                {
                  goto LABEL_461;
                }

                goto LABEL_460;
              }

              if (v200)
              {
                buf = 136446466;
                v309 = "nw_listener_inbox_accept_udp";
                v310 = 1024;
                *v311 = v184;
                _os_log_impl(&dword_181A37000, v187, v275, "%{public}s IPV6_RECVTCLASS failed %{darwin.errno}d, no backtrace", &buf, 0x12u);
              }
            }

            else
            {
              v187 = __nwlog_obj();
              v208 = v293[0];
              if (os_log_type_enabled(v187, v293[0]))
              {
                buf = 136446466;
                v309 = "nw_listener_inbox_accept_udp";
                v310 = 1024;
                *v311 = v184;
                _os_log_impl(&dword_181A37000, v187, v208, "%{public}s IPV6_RECVTCLASS failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x12u);
              }
            }

            goto LABEL_458;
          }

LABEL_462:
          if (uuid_is_null(v283 + 89) || !setsockopt(v102, 0xFFFF, 4384, v283 + 89, 0x10u))
          {
LABEL_470:
            if (__src[0].sa_family == 2)
            {
              if ((__src[0].sa_data[2] & 0xF0) == 0xE0)
              {
                goto LABEL_478;
              }
            }

            else if (__src[0].sa_family == 30 && __src[0].sa_data[6] == 255)
            {
LABEL_479:
              *&__src[0].sa_data[6] = 0;
              *&__src[1].sa_len = 0;
LABEL_480:
              if (bind(v102, __src, __src[0].sa_len))
              {
                v230 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (v230 > 0x31 || ((1 << v230) & 0x3000000002002) == 0)
                {
                  v233 = __nwlog_obj();
                  buf = 136447234;
                  v309 = "nw_listener_inbox_accept_udp";
                  v310 = 1024;
                  *v311 = v102;
                  *&v311[4] = 1040;
                  *&v311[6] = __src[0].sa_len;
                  *&v311[10] = 2098;
                  *&v311[12] = __src;
                  *&v311[20] = 1024;
                  *&v311[22] = v230;
                  v194 = _os_log_send_and_compose_impl();

                  v293[0] = OS_LOG_TYPE_ERROR;
                  LOBYTE(v297) = 0;
                  if (!__nwlog_fault(v194, v293, &v297))
                  {
                    goto LABEL_559;
                  }

                  if (v293[0] == OS_LOG_TYPE_FAULT)
                  {
                    v195 = __nwlog_obj();
                    v234 = v293[0];
                    if (os_log_type_enabled(v195, v293[0]))
                    {
                      buf = 136447234;
                      v309 = "nw_listener_inbox_accept_udp";
                      v310 = 1024;
                      *v311 = v102;
                      *&v311[4] = 1040;
                      *&v311[6] = __src[0].sa_len;
                      *&v311[10] = 2098;
                      *&v311[12] = __src;
                      *&v311[20] = 1024;
                      *&v311[22] = v230;
                      _os_log_impl(&dword_181A37000, v195, v234, "%{public}s bind %d %{public,network:sockaddr}.*P failed %{darwin.errno}d", &buf, 0x28u);
                    }

                    goto LABEL_558;
                  }

                  if (v297 != 1)
                  {
                    v195 = __nwlog_obj();
                    v243 = v293[0];
                    if (os_log_type_enabled(v195, v293[0]))
                    {
                      buf = 136447234;
                      v309 = "nw_listener_inbox_accept_udp";
                      v310 = 1024;
                      *v311 = v102;
                      *&v311[4] = 1040;
                      *&v311[6] = __src[0].sa_len;
                      *&v311[10] = 2098;
                      *&v311[12] = __src;
                      *&v311[20] = 1024;
                      *&v311[22] = v230;
                      _os_log_impl(&dword_181A37000, v195, v243, "%{public}s bind %d %{public,network:sockaddr}.*P failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x28u);
                    }

                    goto LABEL_558;
                  }

                  v203 = __nw_create_backtrace_string();
                  v195 = __nwlog_obj();
                  v235 = v293[0];
                  v236 = os_log_type_enabled(v195, v293[0]);
                  if (!v203)
                  {
                    if (v236)
                    {
                      buf = 136447234;
                      v309 = "nw_listener_inbox_accept_udp";
                      v310 = 1024;
                      *v311 = v102;
                      *&v311[4] = 1040;
                      *&v311[6] = __src[0].sa_len;
                      *&v311[10] = 2098;
                      *&v311[12] = __src;
                      *&v311[20] = 1024;
                      *&v311[22] = v230;
                      _os_log_impl(&dword_181A37000, v195, v235, "%{public}s bind %d %{public,network:sockaddr}.*P failed %{darwin.errno}d, no backtrace", &buf, 0x28u);
                    }

                    goto LABEL_558;
                  }

                  if (v236)
                  {
                    buf = 136447490;
                    v309 = "nw_listener_inbox_accept_udp";
                    v310 = 1024;
                    *v311 = v102;
                    *&v311[4] = 1040;
                    *&v311[6] = __src[0].sa_len;
                    *&v311[10] = 2098;
                    *&v311[12] = __src;
                    *&v311[20] = 1024;
                    *&v311[22] = v230;
                    *v312 = 2082;
                    *&v312[2] = v203;
                    _os_log_impl(&dword_181A37000, v195, v235, "%{public}s bind %d %{public,network:sockaddr}.*P failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x32u);
                  }

                  goto LABEL_502;
                }

                v231 = __nwlog_obj();
                if (os_log_type_enabled(v231, OS_LOG_TYPE_ERROR))
                {
                  buf = 136447234;
                  v309 = "nw_listener_inbox_accept_udp";
                  v310 = 1024;
                  *v311 = v102;
                  *&v311[4] = 1040;
                  *&v311[6] = __src[0].sa_len;
                  *&v311[10] = 2098;
                  *&v311[12] = __src;
                  *&v311[20] = 1024;
                  *&v311[22] = v230;
                  _os_log_impl(&dword_181A37000, v231, OS_LOG_TYPE_ERROR, "%{public}s bind %d %{public,network:sockaddr}.*P failed %{darwin.errno}d", &buf, 0x28u);
                }
              }

              else
              {
                if (!connect(v102, v6, v6->sa_len))
                {
                  *v10 = v102;
                  v60 = v64;
                  goto LABEL_412;
                }

                v232 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (v232 > 0x31 || ((1 << v232) & 0x3000000002002) == 0)
                {
                  v241 = __nwlog_obj();
                  buf = 136446466;
                  v309 = "nw_listener_inbox_accept_udp";
                  v310 = 1024;
                  *v311 = v232;
                  v194 = _os_log_send_and_compose_impl();

                  v293[0] = OS_LOG_TYPE_ERROR;
                  LOBYTE(v297) = 0;
                  if (!__nwlog_fault(v194, v293, &v297))
                  {
                    goto LABEL_559;
                  }

                  if (v293[0] == OS_LOG_TYPE_FAULT)
                  {
                    v195 = __nwlog_obj();
                    v242 = v293[0];
                    if (os_log_type_enabled(v195, v293[0]))
                    {
                      buf = 136446466;
                      v309 = "nw_listener_inbox_accept_udp";
                      v310 = 1024;
                      *v311 = v232;
                      _os_log_impl(&dword_181A37000, v195, v242, "%{public}s connect failed %{darwin.errno}d", &buf, 0x12u);
                    }
                  }

                  else if (v297 == 1)
                  {
                    v246 = __nw_create_backtrace_string();
                    v195 = __nwlog_obj();
                    v247 = v293[0];
                    v248 = os_log_type_enabled(v195, v293[0]);
                    if (v246)
                    {
                      if (v248)
                      {
                        buf = 136446722;
                        v309 = "nw_listener_inbox_accept_udp";
                        v310 = 1024;
                        *v311 = v232;
                        *&v311[4] = 2082;
                        *&v311[6] = v246;
                        _os_log_impl(&dword_181A37000, v195, v247, "%{public}s connect failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x1Cu);
                      }

                      free(v246);
LABEL_559:
                      if (!v194)
                      {
                        goto LABEL_561;
                      }

LABEL_560:
                      free(v194);
                      goto LABEL_561;
                    }

                    if (v248)
                    {
                      buf = 136446466;
                      v309 = "nw_listener_inbox_accept_udp";
                      v310 = 1024;
                      *v311 = v232;
                      _os_log_impl(&dword_181A37000, v195, v247, "%{public}s connect failed %{darwin.errno}d, no backtrace", &buf, 0x12u);
                    }
                  }

                  else
                  {
                    v195 = __nwlog_obj();
                    v250 = v293[0];
                    if (os_log_type_enabled(v195, v293[0]))
                    {
                      buf = 136446466;
                      v309 = "nw_listener_inbox_accept_udp";
                      v310 = 1024;
                      *v311 = v232;
                      _os_log_impl(&dword_181A37000, v195, v250, "%{public}s connect failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x12u);
                    }
                  }

LABEL_558:

                  goto LABEL_559;
                }

                v231 = __nwlog_obj();
                if (os_log_type_enabled(v231, OS_LOG_TYPE_ERROR))
                {
                  buf = 136446466;
                  v309 = "nw_listener_inbox_accept_udp";
                  v310 = 1024;
                  *v311 = v232;
                  _os_log_impl(&dword_181A37000, v231, OS_LOG_TYPE_ERROR, "%{public}s connect failed %{darwin.errno}d", &buf, 0x12u);
                }
              }

              goto LABEL_561;
            }

            if (!nw_ip_is_broadcast(__src, *(v283 + 5)))
            {
              goto LABEL_480;
            }

            if (__src[0].sa_family == 30)
            {
              goto LABEL_479;
            }

            if (__src[0].sa_family != 2)
            {
              goto LABEL_480;
            }

LABEL_478:
            *&__src[0].sa_data[2] = 0;
            goto LABEL_480;
          }

          v228 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          if (v228 <= 0x2A && ((1 << v228) & 0x40000400004) != 0)
          {
            v229 = __nwlog_obj();
            if (os_log_type_enabled(v229, OS_LOG_TYPE_ERROR))
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v228;
              _os_log_impl(&dword_181A37000, v229, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d", &buf, 0x12u);
            }

LABEL_469:
            v64 = v281;
            goto LABEL_470;
          }

          v237 = __nwlog_obj();
          buf = 136446466;
          v309 = "nw_listener_inbox_accept_udp";
          v310 = 1024;
          *v311 = v228;
          v238 = _os_log_send_and_compose_impl();

          v293[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v297) = 0;
          if (__nwlog_fault(v238, v293, &v297))
          {
            if (v293[0] == OS_LOG_TYPE_FAULT)
            {
              v239 = __nwlog_obj();
              v240 = v293[0];
              if (os_log_type_enabled(v239, v293[0]))
              {
                buf = 136446466;
                v309 = "nw_listener_inbox_accept_udp";
                v310 = 1024;
                *v311 = v228;
                _os_log_impl(&dword_181A37000, v239, v240, "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d", &buf, 0x12u);
              }
            }

            else if (v297 == 1)
            {
              v244 = __nw_create_backtrace_string();
              v239 = __nwlog_obj();
              v277 = v293[0];
              v245 = os_log_type_enabled(v239, v293[0]);
              if (v244)
              {
                if (v245)
                {
                  buf = 136446722;
                  v309 = "nw_listener_inbox_accept_udp";
                  v310 = 1024;
                  *v311 = v228;
                  *&v311[4] = 2082;
                  *&v311[6] = v244;
                  _os_log_impl(&dword_181A37000, v239, v277, "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x1Cu);
                }

                free(v244);
                goto LABEL_554;
              }

              if (v245)
              {
                buf = 136446466;
                v309 = "nw_listener_inbox_accept_udp";
                v310 = 1024;
                *v311 = v228;
                _os_log_impl(&dword_181A37000, v239, v277, "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, no backtrace", &buf, 0x12u);
              }
            }

            else
            {
              v239 = __nwlog_obj();
              v249 = v293[0];
              if (os_log_type_enabled(v239, v293[0]))
              {
                buf = 136446466;
                v309 = "nw_listener_inbox_accept_udp";
                v310 = 1024;
                *v311 = v228;
                _os_log_impl(&dword_181A37000, v239, v249, "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x12u);
              }
            }
          }

LABEL_554:
          if (v238)
          {
            free(v238);
          }

          goto LABEL_469;
        }

        v129 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        v130 = __nwlog_obj();
        buf = 136446466;
        v309 = "nw_listener_inbox_accept_udp";
        v310 = 1024;
        *v311 = v129;
        v131 = _os_log_send_and_compose_impl();

        v293[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v297) = 0;
        if (__nwlog_fault(v131, v293, &v297))
        {
          if (v293[0] == OS_LOG_TYPE_FAULT)
          {
            v132 = __nwlog_obj();
            v133 = v293[0];
            if (os_log_type_enabled(v132, v293[0]))
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v129;
              _os_log_impl(&dword_181A37000, v132, v133, "%{public}s SO_NOWAKEFROMSLEEP failed %{darwin.errno}d", &buf, 0x12u);
            }
          }

          else if (v297 == 1)
          {
            v165 = __nw_create_backtrace_string();
            v132 = __nwlog_obj();
            v274 = v293[0];
            v166 = os_log_type_enabled(v132, v293[0]);
            if (v165)
            {
              if (v166)
              {
                buf = 136446722;
                v309 = "nw_listener_inbox_accept_udp";
                v310 = 1024;
                *v311 = v129;
                *&v311[4] = 2082;
                *&v311[6] = v165;
                _os_log_impl(&dword_181A37000, v132, v274, "%{public}s SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x1Cu);
              }

              free(v165);
              goto LABEL_322;
            }

            if (v166)
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v129;
              _os_log_impl(&dword_181A37000, v132, v274, "%{public}s SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, no backtrace", &buf, 0x12u);
            }
          }

          else
          {
            v132 = __nwlog_obj();
            v172 = v293[0];
            if (os_log_type_enabled(v132, v293[0]))
            {
              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v129;
              _os_log_impl(&dword_181A37000, v132, v172, "%{public}s SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x12u);
            }
          }
        }

LABEL_322:
        v64 = v281;
        if (v131)
        {
          free(v131);
        }

        goto LABEL_324;
      }

      v108 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      v109 = __nwlog_obj();
      buf = 136446466;
      v309 = "nw_listener_inbox_accept_udp";
      v310 = 1024;
      *v311 = v108;
      v110 = _os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v293[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v110, type, v293))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v111 = __nwlog_obj();
          v112 = type[0];
          if (os_log_type_enabled(v111, type[0]))
          {
            buf = 136446466;
            v309 = "nw_listener_inbox_accept_udp";
            v310 = 1024;
            *v311 = v108;
            _os_log_impl(&dword_181A37000, v111, v112, "%{public}s socket() failed %{darwin.errno}d", &buf, 0x12u);
          }
        }

        else if (v293[0] == OS_LOG_TYPE_INFO)
        {
          v119 = __nw_create_backtrace_string();
          v111 = __nwlog_obj();
          v120 = type[0];
          v121 = os_log_type_enabled(v111, type[0]);
          if (v119)
          {
            if (v121)
            {
              buf = 136446722;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 1024;
              *v311 = v108;
              *&v311[4] = 2082;
              *&v311[6] = v119;
              _os_log_impl(&dword_181A37000, v111, v120, "%{public}s socket() failed %{darwin.errno}d, dumping backtrace:%{public}s", &buf, 0x1Cu);
            }

            free(v119);
            goto LABEL_218;
          }

          if (v121)
          {
            buf = 136446466;
            v309 = "nw_listener_inbox_accept_udp";
            v310 = 1024;
            *v311 = v108;
            _os_log_impl(&dword_181A37000, v111, v120, "%{public}s socket() failed %{darwin.errno}d, no backtrace", &buf, 0x12u);
          }
        }

        else
        {
          v111 = __nwlog_obj();
          v123 = type[0];
          if (os_log_type_enabled(v111, type[0]))
          {
            buf = 136446466;
            v309 = "nw_listener_inbox_accept_udp";
            v310 = 1024;
            *v311 = v108;
            _os_log_impl(&dword_181A37000, v111, v123, "%{public}s socket() failed %{darwin.errno}d, backtrace limit exceeded", &buf, 0x12u);
          }
        }
      }

LABEL_218:
      v64 = v281;
      if (v110)
      {
        free(v110);
      }

      goto LABEL_411;
    }

    v297 = 0;
    v66 = nw_parameters_copy_upper_transport_protocol_options(*(v63 + 6));
    if (nw_protocol_options_is_quic_stream(v66))
    {
      source_connection_id_length = nw_quic_get_source_connection_id_length(v66);
    }

    else
    {
      if (!nw_protocol_options_is_quic_connection(v66))
      {
        v71 = 0;
        goto LABEL_122;
      }

      source_connection_id_length = nw_quic_connection_get_source_connection_id_length(v66);
    }

    v71 = source_connection_id_length;
LABEL_122:
    v81 = __nwlog_obj();
    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
    {
      buf = 136446466;
      v309 = "nw_listener_inbox_accept_udp";
      v310 = 1024;
      *v311 = v71;
      _os_log_impl(&dword_181A37000, v81, OS_LOG_TYPE_DEBUG, "%{public}s Using CID length %u", &buf, 0x12u);
    }

    if (nw_quic_parse_dispatch(v281, v71, &v297) && if_indextoname(HIDWORD(v305), v320))
    {
      v82 = __nwlog_obj();
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        buf = 136446722;
        v309 = "nw_listener_inbox_accept_udp";
        v310 = 2080;
        *v311 = v320;
        *&v311[8] = 2112;
        *&v311[10] = v297;
        _os_log_impl(&dword_181A37000, v82, OS_LOG_TYPE_DEFAULT, "%{public}s Received QUIC short header packet on interface %s with CID %@", &buf, 0x20u);
      }

      v83 = nw_protocol_copy_quic_definition();
      identifier = nw_protocol_definition_get_identifier(v83);
      *v293 = 0;
      v294 = 0;
      v296 = 0;
      v295 = 0;
      *&v293[2] = __rev16(nw_endpoint_get_port(*(v283 + 4)));
      *v293 = 7708;
      v85 = nw_parameters_copy_context(*(v283 + 6));
      address = _nw_endpoint_create_address(v293);
      v273 = nw_context_copy_registered_endpoint(v85, address);
      v86 = nw_endpoint_copy_registrar_for_identifier(v273, identifier, 0);
      if (v86)
      {
        v269 = v86;
        v270 = v83;
        v271 = v85;
        quic_instance_by_id = nw_protocol_instance_registrar_find_quic_instance_by_id(v86, v297);
        v88 = __nwlog_obj();
        v89 = os_log_type_enabled(v88, OS_LOG_TYPE_INFO);
        if (!quic_instance_by_id)
        {
          if (v89)
          {
            buf = 136446210;
            v309 = "nw_listener_inbox_accept_udp";
            _os_log_impl(&dword_181A37000, v88, OS_LOG_TYPE_INFO, "%{public}s Failed to find an existing QUIC connection, discarding", &buf, 0xCu);
          }

          goto LABEL_265;
        }

        if (v89)
        {
          buf = 136446210;
          v309 = "nw_listener_inbox_accept_udp";
          _os_log_impl(&dword_181A37000, v88, OS_LOG_TYPE_INFO, "%{public}s Found an existing QUIC connection, adding a new path", &buf, 0xCu);
        }

        v90 = quic_instance_by_id[3];
        if (!v90)
        {
          goto LABEL_266;
        }

        v91 = *(v90 + 120);
        if (!v91)
        {
          goto LABEL_266;
        }

        v88 = v91(quic_instance_by_id);
        v92 = __nwlog_obj();
        if (os_log_type_enabled(v92, OS_LOG_TYPE_INFO))
        {
          buf = 136446466;
          v309 = "nw_listener_inbox_accept_udp";
          v310 = 2112;
          *v311 = v88;
          _os_log_impl(&dword_181A37000, v92, OS_LOG_TYPE_INFO, "%{public}s QUIC protocol peer path %@", &buf, 0x16u);
        }

        v93 = _nw_interface_create_with_name(v320);
        v94 = v281;
        v268 = nw_endpoint_create_address(v6);
        *type = 0;
        v290 = type;
        v291 = 0x2020000000;
        v292 = 0;
        v95 = malloc_type_calloc(1uLL, 0x10uLL, 0x9AE2D36DuLL);
        if (!v95)
        {
          v96 = __nwlog_obj();
          os_log_type_enabled(v96, OS_LOG_TYPE_ERROR);
          buf = 136446722;
          v309 = "nw_listener_inbox_accept_udp";
          v310 = 2048;
          *v311 = 1;
          *&v311[8] = 2048;
          *&v311[10] = 16;
          v97 = _os_log_send_and_compose_impl();

          result = __nwlog_should_abort(v97);
          if (result)
          {
            __break(1u);
            return result;
          }

          free(v97);
          v95 = 0;
          v94 = v281;
        }

        *(v290 + 3) = v95;
        v286[0] = MEMORY[0x1E69E9820];
        v286[1] = 3221225472;
        v286[2] = ___ZL28nw_listener_inbox_accept_udpP24nw_listener_inbox_socketiPiPbP8sockaddrjP16nw_ip_ecn_flag_tPU22objcproto11OS_nw_array8NSObject_block_invoke_95;
        v286[3] = &unk_1E6A39A70;
        v98 = v93;
        v287 = v98;
        v288 = type;
        nw_path_enumerate_interface_options(v88, v286);
        if (uuid_is_null(*(v290 + 3)))
        {
          v99 = __nwlog_obj();
          if (os_log_type_enabled(v99, OS_LOG_TYPE_INFO))
          {
            buf = 136446210;
            v309 = "nw_listener_inbox_accept_udp";
            _os_log_impl(&dword_181A37000, v99, OS_LOG_TYPE_INFO, "%{public}s Did not find a matching interface", &buf, 0xCu);
          }

          goto LABEL_262;
        }

        v99 = nw_path_copy_flow_registration(v271, quic_instance_by_id);
        v138 = nw_interface_option_details_create(v98, *(v290 + 3), v268, 0, v94, v12);
        if (v138)
        {
          v139 = v138;
          nw_interface_option_details_set_injected(v138);
          v140 = v139;
          nw_path_flow_registration_add_extra_interface_option(v99, v139);
        }

        else
        {
          v140 = 0;
          v154 = __nwlog_obj();
          if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
          {
            v155 = *(v290 + 3);
            buf = 136446978;
            v309 = "nw_listener_inbox_accept_udp";
            v310 = 2112;
            *v311 = v98;
            *&v311[8] = 1042;
            *&v311[10] = 16;
            *&v311[14] = 2098;
            *&v311[16] = v155;
            _os_log_impl(&dword_181A37000, v154, OS_LOG_TYPE_ERROR, "%{public}s Unable to create interface option details with %@ [%{public,uuid_t}.16P]", &buf, 0x26u);
          }
        }

        v156 = nw_path_flow_registration_copy_path(v99);
        v157 = quic_instance_by_id[3];
        if (v157)
        {
          v158 = *(v157 + 168);
          if (v158)
          {
            v158(quic_instance_by_id, quic_instance_by_id[6], v156);
LABEL_261:

LABEL_262:
            v159 = *(v290 + 3);
            if (v159)
            {
              free(v159);
              *(v290 + 3) = 0;
            }

            _Block_object_dispose(type, 8);
LABEL_265:

LABEL_266:
            v60 = 0;
            v64 = v281;
LABEL_412:

            goto LABEL_79;
          }
        }

        v254 = __nwlog_obj();
        v255 = quic_instance_by_id[2];
        if (!v255)
        {
          v255 = "invalid";
        }

        buf = 136446466;
        v309 = "nw_listener_inbox_accept_udp";
        v310 = 2082;
        *v311 = v255;
        v267 = _os_log_send_and_compose_impl();

        v285 = OS_LOG_TYPE_ERROR;
        v284 = 0;
        if (__nwlog_fault(v267, &v285, &v284))
        {
          if (v285 == OS_LOG_TYPE_FAULT)
          {
            v256 = __nwlog_obj();
            v257 = v285;
            if (os_log_type_enabled(v256, v285))
            {
              v258 = quic_instance_by_id[2];
              if (!v258)
              {
                v258 = "invalid";
              }

              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 2082;
              *v311 = v258;
              _os_log_impl(&dword_181A37000, v256, v257, "%{public}s protocol %{public}s has invalid updated_path callback", &buf, 0x16u);
            }
          }

          else
          {
            if (v284 == 1)
            {
              v259 = __nw_create_backtrace_string();
              v260 = __nwlog_obj();
              v266 = v285;
              v261 = os_log_type_enabled(v260, v285);
              if (v259)
              {
                if (v261)
                {
                  v262 = quic_instance_by_id[2];
                  if (!v262)
                  {
                    v262 = "invalid";
                  }

                  buf = 136446722;
                  v309 = "nw_listener_inbox_accept_udp";
                  v310 = 2082;
                  *v311 = v262;
                  *&v311[8] = 2082;
                  *&v311[10] = v259;
                  _os_log_impl(&dword_181A37000, v260, v266, "%{public}s protocol %{public}s has invalid updated_path callback, dumping backtrace:%{public}s", &buf, 0x20u);
                }

                free(v259);
              }

              else
              {
                if (v261)
                {
                  v265 = quic_instance_by_id[2];
                  if (!v265)
                  {
                    v265 = "invalid";
                  }

                  buf = 136446466;
                  v309 = "nw_listener_inbox_accept_udp";
                  v310 = 2082;
                  *v311 = v265;
                  _os_log_impl(&dword_181A37000, v260, v266, "%{public}s protocol %{public}s has invalid updated_path callback, no backtrace", &buf, 0x16u);
                }
              }

              goto LABEL_599;
            }

            v256 = __nwlog_obj();
            v263 = v285;
            if (os_log_type_enabled(v256, v285))
            {
              v264 = quic_instance_by_id[2];
              if (!v264)
              {
                v264 = "invalid";
              }

              buf = 136446466;
              v309 = "nw_listener_inbox_accept_udp";
              v310 = 2082;
              *v311 = v264;
              _os_log_impl(&dword_181A37000, v256, v263, "%{public}s protocol %{public}s has invalid updated_path callback, backtrace limit exceeded", &buf, 0x16u);
            }
          }
        }

LABEL_599:
        if (v267)
        {
          free(v267);
        }

        goto LABEL_261;
      }
    }

    goto LABEL_147;
  }

  if (!v16)
  {
    goto LABEL_78;
  }

  v32 = nw_endpoint_create_address(v6);
  v33 = nw_interface_create_with_index(SHIDWORD(v305));
  v34 = _nw_endpoint_create_address(__src);
  v278 = v283;
  v272 = v34;
  v35 = v32;
  v280 = v33;
  if (!v16)
  {
    v210 = __nwlog_obj();
    buf = 136446210;
    v309 = "nw_listener_inbox_socket_handle_new_packet";
    v211 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v293[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v211, type, v293))
    {
      goto LABEL_571;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v212 = __nwlog_obj();
      v213 = type[0];
      if (os_log_type_enabled(v212, type[0]))
      {
        buf = 136446210;
        v309 = "nw_listener_inbox_socket_handle_new_packet";
        _os_log_impl(&dword_181A37000, v212, v213, "%{public}s called with null packet_length", &buf, 0xCu);
      }
    }

    else if (v293[0] == OS_LOG_TYPE_INFO)
    {
      v220 = __nw_create_backtrace_string();
      v212 = __nwlog_obj();
      v221 = type[0];
      v222 = os_log_type_enabled(v212, type[0]);
      if (v220)
      {
        if (v222)
        {
          buf = 136446466;
          v309 = "nw_listener_inbox_socket_handle_new_packet";
          v310 = 2082;
          *v311 = v220;
          _os_log_impl(&dword_181A37000, v212, v221, "%{public}s called with null packet_length, dumping backtrace:%{public}s", &buf, 0x16u);
        }

        free(v220);
LABEL_571:
        if (!v211)
        {
          goto LABEL_120;
        }

        goto LABEL_572;
      }

      if (v222)
      {
        buf = 136446210;
        v309 = "nw_listener_inbox_socket_handle_new_packet";
        _os_log_impl(&dword_181A37000, v212, v221, "%{public}s called with null packet_length, no backtrace", &buf, 0xCu);
      }
    }

    else
    {
      v212 = __nwlog_obj();
      v251 = type[0];
      if (os_log_type_enabled(v212, type[0]))
      {
        buf = 136446210;
        v309 = "nw_listener_inbox_socket_handle_new_packet";
        _os_log_impl(&dword_181A37000, v212, v251, "%{public}s called with null packet_length, backtrace limit exceeded", &buf, 0xCu);
      }
    }

LABEL_570:

    goto LABEL_571;
  }

  if (!v35)
  {
    v214 = __nwlog_obj();
    buf = 136446210;
    v309 = "nw_listener_inbox_socket_handle_new_packet";
    v211 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v293[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v211, type, v293))
    {
      goto LABEL_571;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v212 = __nwlog_obj();
      v215 = type[0];
      if (os_log_type_enabled(v212, type[0]))
      {
        buf = 136446210;
        v309 = "nw_listener_inbox_socket_handle_new_packet";
        _os_log_impl(&dword_181A37000, v212, v215, "%{public}s called with null peer", &buf, 0xCu);
      }

      goto LABEL_570;
    }

    if (v293[0] != OS_LOG_TYPE_INFO)
    {
      v212 = __nwlog_obj();
      v252 = type[0];
      if (os_log_type_enabled(v212, type[0]))
      {
        buf = 136446210;
        v309 = "nw_listener_inbox_socket_handle_new_packet";
        _os_log_impl(&dword_181A37000, v212, v252, "%{public}s called with null peer, backtrace limit exceeded", &buf, 0xCu);
      }

      goto LABEL_570;
    }

    v223 = __nw_create_backtrace_string();
    v212 = __nwlog_obj();
    v224 = type[0];
    v225 = os_log_type_enabled(v212, type[0]);
    if (!v223)
    {
      if (v225)
      {
        buf = 136446210;
        v309 = "nw_listener_inbox_socket_handle_new_packet";
        _os_log_impl(&dword_181A37000, v212, v224, "%{public}s called with null peer, no backtrace", &buf, 0xCu);
      }

      goto LABEL_570;
    }

    if (v225)
    {
      buf = 136446466;
      v309 = "nw_listener_inbox_socket_handle_new_packet";
      v310 = 2082;
      *v311 = v223;
      _os_log_impl(&dword_181A37000, v212, v224, "%{public}s called with null peer, dumping backtrace:%{public}s", &buf, 0x16u);
    }

    goto LABEL_451;
  }

  if (!v280)
  {
    v216 = __nwlog_obj();
    buf = 136446210;
    v309 = "nw_listener_inbox_socket_handle_new_packet";
    v211 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v293[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v211, type, v293))
    {
      goto LABEL_571;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v212 = __nwlog_obj();
      v217 = type[0];
      if (os_log_type_enabled(v212, type[0]))
      {
        buf = 136446210;
        v309 = "nw_listener_inbox_socket_handle_new_packet";
        _os_log_impl(&dword_181A37000, v212, v217, "%{public}s called with null interface", &buf, 0xCu);
      }

      goto LABEL_570;
    }

    if (v293[0] != OS_LOG_TYPE_INFO)
    {
      v212 = __nwlog_obj();
      v253 = type[0];
      if (os_log_type_enabled(v212, type[0]))
      {
        buf = 136446210;
        v309 = "nw_listener_inbox_socket_handle_new_packet";
        _os_log_impl(&dword_181A37000, v212, v253, "%{public}s called with null interface, backtrace limit exceeded", &buf, 0xCu);
      }

      goto LABEL_570;
    }

    v223 = __nw_create_backtrace_string();
    v212 = __nwlog_obj();
    v226 = type[0];
    v227 = os_log_type_enabled(v212, type[0]);
    if (!v223)
    {
      if (v227)
      {
        buf = 136446210;
        v309 = "nw_listener_inbox_socket_handle_new_packet";
        _os_log_impl(&dword_181A37000, v212, v226, "%{public}s called with null interface, no backtrace", &buf, 0xCu);
      }

      goto LABEL_570;
    }

    if (v227)
    {
      buf = 136446466;
      v309 = "nw_listener_inbox_socket_handle_new_packet";
      v310 = 2082;
      *v311 = v223;
      _os_log_impl(&dword_181A37000, v212, v226, "%{public}s called with null interface, dumping backtrace:%{public}s", &buf, 0x16u);
    }

LABEL_451:

    free(v223);
    if (!v211)
    {
      goto LABEL_120;
    }

LABEL_572:
    free(v211);
    goto LABEL_120;
  }

  v36 = _nw_parameters_copy(*(v278 + 6));
  v37 = nw_parameters_copy_context(v36);
  v38 = nw_context_copy_registered_endpoint(v37, v35);

  v39 = nw_endpoint_copy_association_with_evaluator(v38, v36, 0);
  v40 = v39;
  if (v39)
  {
    v41 = nw_association_copy_current_path(v39, v36);
  }

  else
  {
    v41 = 0;
  }

  if (!nw_parameters_get_local_only(v36))
  {
    goto LABEL_91;
  }

  if (v41)
  {
    if (nw_path_is_direct(v41))
    {
LABEL_91:
      v68 = *(v278 + 1);
      if (v68)
      {
        if (v38)
        {
          v69 = v38;
        }

        else
        {
          v69 = v35;
        }

        v70 = v272;
        if (!v272)
        {
          v70 = *(v283 + 4);
        }

        [v68 handleInboundPacket:&buffer length:v16 from:v69 to:v70 interface:v280 socket:*(v278 + 9)];
      }

      goto LABEL_119;
    }
  }

  else
  {
    v75 = __nwlog_obj();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
    {
      buf = 136446210;
      v309 = "nw_listener_inbox_socket_handle_new_packet";
      _os_log_impl(&dword_181A37000, v75, OS_LOG_TYPE_ERROR, "%{public}s nw_association has no path", &buf, 0xCu);
    }
  }

  v76 = __nwlog_obj();
  v77 = os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG);
  v78 = gLogFDOverride != -1 || v77;

  if (v41)
  {
    v79 = v78;
  }

  else
  {
    v79 = 0;
  }

  if (v79 == 1)
  {
    v80 = __nwlog_obj();
    if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
    {
      buf = 136446466;
      v309 = "nw_listener_inbox_socket_handle_new_packet";
      v310 = 2114;
      *v311 = v38;
      _os_log_impl(&dword_181A37000, v80, OS_LOG_TYPE_DEBUG, "%{public}s Ignoring data from non-local endpoint %{public}@", &buf, 0x16u);
    }
  }

LABEL_119:

LABEL_120:
LABEL_78:
  v60 = 0;
LABEL_79:

  return v60;
}

void sub_1829398B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19, uint64_t a20, uint64_t a21, void *a22, void *a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, void *a28, void *a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *a35, uint64_t a36, char a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, id a45)
{
  _Block_object_dispose(&a37, 8);

  _Unwind_Resume(a1);
}

uint64_t ___ZL28nw_listener_inbox_accept_udpP24nw_listener_inbox_socketiPiPbP8sockaddrjP16nw_ip_ecn_flag_tPU22objcproto11OS_nw_array8NSObject_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  v5 = nw_connection_copy_endpoint(v4);
  v6 = nw_connection_copy_parameters(v4);
  v7 = nw_parameters_copy_local_endpoint(v6);
  if (v5 && (v8 = v5, type = _nw_endpoint_get_type(v8), v8, type == 1) && ((v10 = nw_endpoint_address_endpoint_matches_address(v8, *(a1 + 40), 0, 0), v7) ? (v11 = v10) : (v11 = 0), v11 == 1 && (v12 = v7, v13 = _nw_endpoint_get_type(v12), v12, v13 == 1) && (v14 = v12, v15 = _nw_endpoint_address_endpoint_matches_address(v14, (a1 + 56), 0, 0), v14, v15)))
  {
    nw_connection_add_initial_inbound_data(v4, *(a1 + 32), **(a1 + 48));
    v16 = 0;
  }

  else
  {
    v16 = 1;
  }

  return v16;
}

void ___ZL28nw_listener_inbox_accept_udpP24nw_listener_inbox_socketiPiPbP8sockaddrjP16nw_ip_ecn_flag_tPU22objcproto11OS_nw_array8NSObject_block_invoke_95(uint64_t a1, void *a2, _OWORD *a3)
{
  v16 = *MEMORY[0x1E69E9840];
  v5 = a2;
  if (_nw_interface_shallow_compare(v5, *(a1 + 32)))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      if (v5)
      {
        name = _nw_interface_get_name(v5);
      }

      else
      {
        name = 0;
      }

      v8 = 136446978;
      v9 = "nw_listener_inbox_accept_udp_block_invoke";
      v10 = 2080;
      v11 = name;
      v12 = 1040;
      v13 = 16;
      v14 = 2096;
      v15 = a3;
      _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_INFO, "%{public}s Found interface %s, using agent ID %{uuid_t}.16P", &v8, 0x26u);
    }

    **(*(*(a1 + 40) + 8) + 24) = *a3;
  }
}

BOOL nw_ip_is_broadcast(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = *(a1 + 1);
  if (v4 == 2)
  {
    v5 = 4;
  }

  else
  {
    if (v4 != 30 || *(a1 + 8) || *(a1 + 12) || *(a1 + 16) != -65536)
    {
LABEL_15:
      v10 = 0;
      goto LABEL_16;
    }

    v5 = 20;
  }

  v6 = *(a1 + v5);
  if (v6 == -1)
  {
    v10 = 1;
    goto LABEL_16;
  }

  if (!v3)
  {
    goto LABEL_15;
  }

  v12 = 0;
  v7 = v3;
  ipv4_netmask = _nw_interface_get_ipv4_netmask(v3, &v12 + 1);
  ipv4_broadcast = _nw_interface_get_ipv4_broadcast(v7, &v12);
  v10 = v12 == 1 && (v6 == ipv4_broadcast || HIBYTE(v12) == 1 && (ipv4_broadcast & ipv4_netmask) == v6);
  v3 = v7;
LABEL_16:

  return v10;
}

void nw_listen_protocol_disconnected(nw_listen_protocol *a1, nw_protocol *a2, int a3)
{
  v33 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v6 = a1->handle;
    if (v6)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        *buf = 136446722;
        v28 = "nw_listen_protocol_disconnected";
        v29 = 2114;
        v30 = v6;
        v31 = 1024;
        v32 = a3;
        _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_INFO, "%{public}s Listener %{public}@ disconnected with error %d", buf, 0x1Cu);
      }

      (a2->callbacks->remove_listen_handler)(a2, a1);
      if (a3)
      {
        posix_error = nw_error_create_posix_error(a3);
      }

      else
      {
        posix_error = 0;
      }

      [v6[1] handleInboxFailed:v6 error:posix_error];

LABEL_9:
      return;
    }

    v13 = __nwlog_obj();
    *buf = 136446210;
    v28 = "nw_listen_protocol_disconnected";
    v14 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v14, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v15 = __nwlog_obj();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *buf = 136446210;
          v28 = "nw_listen_protocol_disconnected";
          _os_log_impl(&dword_181A37000, v15, v16, "%{public}s called with null inbox", buf, 0xCu);
        }
      }

      else if (v25 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v15 = __nwlog_obj();
        v21 = type;
        v22 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *buf = 136446466;
            v28 = "nw_listen_protocol_disconnected";
            v29 = 2082;
            v30 = backtrace_string;
            _os_log_impl(&dword_181A37000, v15, v21, "%{public}s called with null inbox, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_45;
        }

        if (v22)
        {
          *buf = 136446210;
          v28 = "nw_listen_protocol_disconnected";
          _os_log_impl(&dword_181A37000, v15, v21, "%{public}s called with null inbox, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v15 = __nwlog_obj();
        v24 = type;
        if (os_log_type_enabled(v15, type))
        {
          *buf = 136446210;
          v28 = "nw_listen_protocol_disconnected";
          _os_log_impl(&dword_181A37000, v15, v24, "%{public}s called with null inbox, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_45:
    if (v14)
    {
      free(v14);
    }

    goto LABEL_9;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v28 = "nw_listen_protocol_disconnected";
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (__nwlog_fault(v10, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v28 = "nw_listen_protocol_disconnected";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null listener", buf, 0xCu);
      }
    }

    else if (v25 == 1)
    {
      v17 = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (v17)
      {
        if (v19)
        {
          *buf = 136446466;
          v28 = "nw_listen_protocol_disconnected";
          v29 = 2082;
          v30 = v17;
          _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v17);
        goto LABEL_40;
      }

      if (v19)
      {
        *buf = 136446210;
        v28 = "nw_listen_protocol_disconnected";
        _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v23 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v28 = "nw_listen_protocol_disconnected";
        _os_log_impl(&dword_181A37000, v11, v23, "%{public}s called with null listener, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_40:
  if (v10)
  {
    free(v10);
  }
}

BOOL nw_listen_protocol_new_flow(uint64_t a1, void *a2, void *a3)
{
  v42 = *MEMORY[0x1E69E9840];
  v5 = a2;
  v6 = a3;
  if (a1)
  {
    v7 = *(a1 + 24);
    if (v7)
    {
      v8 = nw_endpoint_copy(v5);

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446978;
        v35 = "nw_listen_protocol_new_flow";
        v36 = 2114;
        v37 = v7;
        v38 = 2114;
        v39 = v8;
        v40 = 2114;
        v41 = v6;
        _os_log_impl(&dword_181A37000, v9, OS_LOG_TYPE_DEBUG, "%{public}s Listener %{public}@ received new flow %{public}@ : %{public}@", buf, 0x2Au);
      }

      nw_parameters_set_server_mode(v6);
      [v7[1] updateParametersForNewConnection:v6];
      v10 = [v7[1] copyPeerDeviceID];
      if (v10)
      {
        nw_endpoint_set_device_id(v8, v10);
        free(v10);
      }

      v11 = [v7[1] copyPeerTXTRecord];
      if (v11)
      {
        nw_endpoint_set_txt_record(v8, v11);
      }

      v12 = nw_connection_create_from_protocol_on_nw_queue(v8, v6, *(a1 + 8));
      v13 = v12 != 0;
      if (v12)
      {
        [v7[1] handleInbound:v12 addProtocolInbox:0];
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *buf = 136446210;
          v35 = "nw_listen_protocol_new_flow";
          _os_log_impl(&dword_181A37000, v14, OS_LOG_TYPE_ERROR, "%{public}s nw_connection_create_from_protocol_on_nw_queue failed", buf, 0xCu);
        }
      }

      v5 = v8;
LABEL_15:

      goto LABEL_16;
    }

    v20 = __nwlog_obj();
    *buf = 136446210;
    v35 = "nw_listen_protocol_new_flow";
    v21 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (__nwlog_fault(v21, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v35 = "nw_listen_protocol_new_flow";
          _os_log_impl(&dword_181A37000, v22, v23, "%{public}s called with null inbox", buf, 0xCu);
        }
      }

      else if (v32 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v22 = __nwlog_obj();
        v28 = type;
        v29 = os_log_type_enabled(v22, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *buf = 136446466;
            v35 = "nw_listen_protocol_new_flow";
            v36 = 2082;
            v37 = backtrace_string;
            _os_log_impl(&dword_181A37000, v22, v28, "%{public}s called with null inbox, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_52;
        }

        if (v29)
        {
          *buf = 136446210;
          v35 = "nw_listen_protocol_new_flow";
          _os_log_impl(&dword_181A37000, v22, v28, "%{public}s called with null inbox, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v22 = __nwlog_obj();
        v31 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v35 = "nw_listen_protocol_new_flow";
          _os_log_impl(&dword_181A37000, v22, v31, "%{public}s called with null inbox, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_52:
    if (v21)
    {
      free(v21);
    }

    v13 = 0;
    goto LABEL_15;
  }

  v16 = __nwlog_obj();
  *buf = 136446210;
  v35 = "nw_listen_protocol_new_flow";
  v17 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v32 = 0;
  if (__nwlog_fault(v17, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *buf = 136446210;
        v35 = "nw_listen_protocol_new_flow";
        _os_log_impl(&dword_181A37000, v18, v19, "%{public}s called with null listener", buf, 0xCu);
      }
    }

    else if (v32 == 1)
    {
      v24 = __nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v25 = type;
      v26 = os_log_type_enabled(v18, type);
      if (v24)
      {
        if (v26)
        {
          *buf = 136446466;
          v35 = "nw_listen_protocol_new_flow";
          v36 = 2082;
          v37 = v24;
          _os_log_impl(&dword_181A37000, v18, v25, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v24);
        goto LABEL_46;
      }

      if (v26)
      {
        *buf = 136446210;
        v35 = "nw_listen_protocol_new_flow";
        _os_log_impl(&dword_181A37000, v18, v25, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v18 = __nwlog_obj();
      v30 = type;
      if (os_log_type_enabled(v18, type))
      {
        *buf = 136446210;
        v35 = "nw_listen_protocol_new_flow";
        _os_log_impl(&dword_181A37000, v18, v30, "%{public}s called with null listener, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_46:
  if (v17)
  {
    free(v17);
  }

  v13 = 0;
LABEL_16:

  return v13;
}

uint64_t nw_path_evaluator_copy_description_level(void *a1, int a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *type = 0;
    v5 = *(v3 + 2);
    if (v5)
    {
      v6 = v5;
      v7 = v6;
      if (a2 == 1)
      {
        description = _nw_endpoint_get_description(v6);
      }

      else
      {
        description = _nw_endpoint_get_logging_description(v6);
      }

      v9 = description;

      memset(out, 0, sizeof(out));
      uuid_unparse(v4 + 80, out);
      asprintf(type, "Evaluator %s to %s", out, v9);
    }

    else
    {
      asprintf(type, "Default evaluator");
    }

    v10 = *type;
    goto LABEL_9;
  }

  v12 = __nwlog_obj();
  *out = 136446210;
  *&out[4] = "nw_path_evaluator_copy_description_level";
  v13 = _os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (__nwlog_fault(v13, type, &v21))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_path_evaluator_copy_description_level";
        _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null evaluator", out, 0xCu);
      }
    }

    else if (v21 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v17 = type[0];
      v18 = os_log_type_enabled(v14, type[0]);
      if (backtrace_string)
      {
        if (v18)
        {
          *out = 136446466;
          *&out[4] = "nw_path_evaluator_copy_description_level";
          *&out[12] = 2082;
          *&out[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v14, v17, "%{public}s called with null evaluator, dumping backtrace:%{public}s", out, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v18)
      {
        *out = 136446210;
        *&out[4] = "nw_path_evaluator_copy_description_level";
        _os_log_impl(&dword_181A37000, v14, v17, "%{public}s called with null evaluator, no backtrace", out, 0xCu);
      }
    }

    else
    {
      v14 = __nwlog_obj();
      v19 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *out = 136446210;
        *&out[4] = "nw_path_evaluator_copy_description_level";
        _os_log_impl(&dword_181A37000, v14, v19, "%{public}s called with null evaluator, backtrace limit exceeded", out, 0xCu);
      }
    }
  }

LABEL_26:
  if (v13)
  {
    free(v13);
  }

  v10 = 0;
LABEL_9:

  return v10;
}

uint64_t nw_path_evaluator_copy_description(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = nw_path_evaluator_copy_description_level(v1, 1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_evaluator_copy_description";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_evaluator_copy_description";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_evaluator_copy_description";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_evaluator_copy_description";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_evaluator_copy_description";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

double ___ZL19nw_path_get_globalsPU24objcproto13OS_nw_context8NSObject_block_invoke(uint64_t a1, uint64_t a2)
{
  *(a2 + 112) = 0u;
  *(a2 + 128) = 0u;
  *(a2 + 144) = 0;
  *(a2 + 80) = 0u;
  *(a2 + 96) = 0u;
  *(a2 + 48) = 0u;
  *(a2 + 64) = 0u;
  *(a2 + 16) = 0u;
  *(a2 + 32) = 0u;
  *a2 = 0u;
  result = NAN;
  *(a2 + 124) = -1;
  return result;
}

void __nw_path_flow_registration_close_block_invoke(uint64_t a1)
{
  v39 = *MEMORY[0x1E69E9840];
  v1 = *(a1 + 32);
  if (!v1)
  {
    v19 = __nwlog_obj();
    *buf = 136446210;
    v30 = "nw_context_decrement_channel_flow_count";
    v20 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v20, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v21 = __nwlog_obj();
        v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *buf = 136446210;
          v30 = "nw_context_decrement_channel_flow_count";
          _os_log_impl(&dword_181A37000, v21, v22, "%{public}s called with null context", buf, 0xCu);
        }
      }

      else if (v27 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v21 = __nwlog_obj();
        v24 = type;
        v25 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *buf = 136446466;
            v30 = "nw_context_decrement_channel_flow_count";
            v31 = 2082;
            v32 = backtrace_string;
            _os_log_impl(&dword_181A37000, v21, v24, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_40;
        }

        if (v25)
        {
          *buf = 136446210;
          v30 = "nw_context_decrement_channel_flow_count";
          _os_log_impl(&dword_181A37000, v21, v24, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v21 = __nwlog_obj();
        v26 = type;
        if (os_log_type_enabled(v21, type))
        {
          *buf = 136446210;
          v30 = "nw_context_decrement_channel_flow_count";
          _os_log_impl(&dword_181A37000, v21, v26, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_40:
    if (v20)
    {
      free(v20);
    }

    v3 = 0;
    goto LABEL_11;
  }

  v2 = v1;
  v3 = nw_context_copy_globals_context(v1);

  nw_context_assert_queue(v3);
  v4 = *(v3 + 4);
  v5 = *(v4 + 84);
  *(v4 + 84) = v5 - 1;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    v7 = *(*(v3 + 4) + 84);
    *buf = 136446978;
    v30 = "nw_context_decrement_channel_flow_count";
    v31 = 2082;
    v32 = "context->globals->flow_count";
    v33 = 2048;
    v34 = 1;
    v35 = 2048;
    v36 = v7;
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v8, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          v11 = *(*(v3 + 4) + 84);
          *buf = 136446978;
          v30 = "nw_context_decrement_channel_flow_count";
          v31 = 2082;
          v32 = "context->globals->flow_count";
          v33 = 2048;
          v34 = 1;
          v35 = 2048;
          v36 = v11;
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
        }
      }

      else if (v27 == 1)
      {
        v12 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v13 = type;
        v14 = os_log_type_enabled(v9, type);
        if (v12)
        {
          if (v14)
          {
            v15 = *(*(v3 + 4) + 84);
            *buf = 136447234;
            v30 = "nw_context_decrement_channel_flow_count";
            v31 = 2082;
            v32 = "context->globals->flow_count";
            v33 = 2048;
            v34 = 1;
            v35 = 2048;
            v36 = v15;
            v37 = 2082;
            v38 = v12;
            _os_log_impl(&dword_181A37000, v9, v13, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }

          free(v12);
          if (!v8)
          {
            goto LABEL_10;
          }

          goto LABEL_9;
        }

        if (v14)
        {
          v18 = *(*(v3 + 4) + 84);
          *buf = 136446978;
          v30 = "nw_context_decrement_channel_flow_count";
          v31 = 2082;
          v32 = "context->globals->flow_count";
          v33 = 2048;
          v34 = 1;
          v35 = 2048;
          v36 = v18;
          _os_log_impl(&dword_181A37000, v9, v13, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace", buf, 0x2Au);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          v17 = *(*(v3 + 4) + 84);
          *buf = 136446978;
          v30 = "nw_context_decrement_channel_flow_count";
          v31 = 2082;
          v32 = "context->globals->flow_count";
          v33 = 2048;
          v34 = 1;
          v35 = 2048;
          v36 = v17;
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded", buf, 0x2Au);
        }
      }
    }

    if (!v8)
    {
LABEL_10:
      *(*(v3 + 4) + 84) = 0;
      goto LABEL_11;
    }

LABEL_9:
    free(v8);
    goto LABEL_10;
  }

LABEL_11:
}

uint64_t nw_path_globals_copy_sec_identity(void *a1, uint64_t a2, uint64_t a3)
{
  v19 = *MEMORY[0x1E69E9840];
  v5 = a1;
  Pid = NEHelperGetPid();
  globals_for_path = nw_context_get_globals_for_path(v5);
  os_unfair_lock_lock((globals_for_path + 116));
  if (!*(globals_for_path + 96))
  {
LABEL_7:
    v9 = 0;
    goto LABEL_8;
  }

  if (*(globals_for_path + 132) != Pid)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = *(globals_for_path + 132);
      v13 = 136446722;
      v14 = "nw_path_globals_copy_sec_identity";
      v15 = 1024;
      v16 = v11;
      v17 = 1024;
      v18 = Pid;
      _os_log_impl(&dword_181A37000, v10, OS_LOG_TYPE_INFO, "%{public}s SecIdentity cache flushed (nehelper pid changed from %d to %d)", &v13, 0x18u);
    }

    *(globals_for_path + 132) = Pid;
    [*(globals_for_path + 96) removeAllObjects];
    goto LABEL_7;
  }

  v8 = [objc_alloc(MEMORY[0x1E695DEF0]) initWithBytes:a2 length:a3];
  v9 = [*(globals_for_path + 96) objectForKeyedSubscript:v8];

LABEL_8:
  os_unfair_lock_unlock((globals_for_path + 116));

  return v9;
}

void nw_path_globals_set_sec_identity(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  v19 = *MEMORY[0x1E69E9840];
  v7 = a1;
  v8 = a4;
  globals_for_path = nw_context_get_globals_for_path(v7);
  os_unfair_lock_lock((globals_for_path + 116));
  if (!*(globals_for_path + 96))
  {
    v10 = objc_alloc_init(MEMORY[0x1E695DF90]);
    v11 = *(globals_for_path + 96);
    *(globals_for_path + 96) = v10;
  }

  v12 = [objc_alloc(MEMORY[0x1E695DEF0]) initWithBytes:a2 length:a3];
  [*(globals_for_path + 96) setObject:v8 forKeyedSubscript:v12];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v13 = gLogObj;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    v14 = *(globals_for_path + 132);
    v15 = 136446466;
    v16 = "nw_path_globals_set_sec_identity";
    v17 = 1024;
    v18 = v14;
    _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_DEBUG, "%{public}s Stored SecIdentity (nehelper %d)", &v15, 0x12u);
  }

  os_unfair_lock_unlock((globals_for_path + 116));
}

uint64_t nw_path_create_bridged_flow_director(void *a1, _BYTE *a2)
{
  v77 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    globals_for_path = nw_context_get_globals_for_path(v3);
    os_unfair_lock_lock((globals_for_path + 116));
    v6 = v4;
    if (globals_for_path)
    {
      if (*(globals_for_path + 104))
      {
        if (a2)
        {
          *a2 = 0;
        }

        v8 = 1;
        goto LABEL_74;
      }

      gotLoadHelper_x8__NEFlowDirectorCreateBridge(v7);
      if (!*(v9 + 2168))
      {
LABEL_73:
        v8 = 0;
LABEL_74:

        os_unfair_lock_unlock((globals_for_path + 116));
        goto LABEL_75;
      }

      v10 = socket(32, 2, 2);
      v11 = v10;
      if ((v10 & 0x80000000) == 0)
      {
        v70 = 0;
        *&v71[20] = 0;
        v76 = 0;
        v74 = 0u;
        v75 = 0u;
        v72 = 0u;
        v73 = 0u;
        strcpy(v71, "com.apple.flow-divert");
        if (ioctl(v10, 0xC0644E03uLL, &v70))
        {
          v12 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v13 = gLogObj;
          *buf = 136446466;
          v66 = "nw_path_open_in_process_flow_divert_socket";
          LOWORD(v67) = 1024;
          *(&v67 + 2) = v12;
          v14 = _os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v58 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v14, type, &v58))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v15 = gLogObj;
              v16 = type[0];
              if (os_log_type_enabled(v15, type[0]))
              {
                *buf = 136446466;
                v66 = "nw_path_open_in_process_flow_divert_socket";
                LOWORD(v67) = 1024;
                *(&v67 + 2) = v12;
                _os_log_impl(&dword_181A37000, v15, v16, "%{public}s ioctl(CTLIOCGINFO) failed %{darwin.errno}d", buf, 0x12u);
              }
            }

            else if (v58 == OS_LOG_TYPE_INFO)
            {
              backtrace_string = __nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v15 = gLogObj;
              v29 = type[0];
              v30 = os_log_type_enabled(v15, type[0]);
              if (backtrace_string)
              {
                if (v30)
                {
                  *buf = 136446722;
                  v66 = "nw_path_open_in_process_flow_divert_socket";
                  LOWORD(v67) = 1024;
                  *(&v67 + 2) = v12;
                  HIWORD(v67) = 2082;
                  v68 = backtrace_string;
                  _os_log_impl(&dword_181A37000, v15, v29, "%{public}s ioctl(CTLIOCGINFO) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                }

                free(backtrace_string);
                if (!v14)
                {
                  goto LABEL_57;
                }

                goto LABEL_56;
              }

              if (v30)
              {
                *buf = 136446466;
                v66 = "nw_path_open_in_process_flow_divert_socket";
                LOWORD(v67) = 1024;
                *(&v67 + 2) = v12;
                _os_log_impl(&dword_181A37000, v15, v29, "%{public}s ioctl(CTLIOCGINFO) failed %{darwin.errno}d, no backtrace", buf, 0x12u);
              }
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v15 = gLogObj;
              v34 = type[0];
              if (os_log_type_enabled(v15, type[0]))
              {
                *buf = 136446466;
                v66 = "nw_path_open_in_process_flow_divert_socket";
                LOWORD(v67) = 1024;
                *(&v67 + 2) = v12;
                _os_log_impl(&dword_181A37000, v15, v34, "%{public}s ioctl(CTLIOCGINFO) failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
              }
            }
          }

          if (!v14)
          {
LABEL_57:
            close(v11);
            goto LABEL_73;
          }

LABEL_56:
          free(v14);
          goto LABEL_57;
        }

        v68 = 0;
        v67 = 0;
        v69 = 0;
        *buf = 139296;
        v66 = (v70 | 0xFFFFFFF00000000);
        if (!connect(v11, buf, 0x20u))
        {
          Bridge_delayInitStub = NEFlowDirectorCreateBridge_delayInitStub(v22);
          *(globals_for_path + 104) = Bridge_delayInitStub;
          if (Bridge_delayInitStub)
          {
            NEFlowDirectorStart_delayInitStub(v37);
            v8 = 1;
            if (a2)
            {
              *a2 = 1;
            }

            goto LABEL_74;
          }

          close(v11);
          goto LABEL_73;
        }

        v23 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = gLogObj;
        *type = 136446466;
        v60 = "nw_path_open_in_process_flow_divert_socket";
        v61 = 1024;
        v62 = v23;
        v25 = _os_log_send_and_compose_impl();

        v58 = OS_LOG_TYPE_ERROR;
        v57 = 0;
        if (__nwlog_fault(v25, &v58, &v57))
        {
          if (v58 == OS_LOG_TYPE_FAULT)
          {
            v26 = __nwlog_obj();
            v27 = v58;
            if (os_log_type_enabled(v26, v58))
            {
              *type = 136446466;
              v60 = "nw_path_open_in_process_flow_divert_socket";
              v61 = 1024;
              v62 = v23;
              _os_log_impl(&dword_181A37000, v26, v27, "%{public}s connect failed on kernel control socket %{darwin.errno}d", type, 0x12u);
            }
          }

          else if (v57 == 1)
          {
            v38 = __nw_create_backtrace_string();
            v26 = __nwlog_obj();
            v39 = v58;
            v40 = os_log_type_enabled(v26, v58);
            if (v38)
            {
              if (v40)
              {
                *type = 136446722;
                v60 = "nw_path_open_in_process_flow_divert_socket";
                v61 = 1024;
                v62 = v23;
                v63 = 2082;
                v64 = v38;
                _os_log_impl(&dword_181A37000, v26, v39, "%{public}s connect failed on kernel control socket %{darwin.errno}d, dumping backtrace:%{public}s", type, 0x1Cu);
              }

              free(v38);
              goto LABEL_70;
            }

            if (v40)
            {
              *type = 136446466;
              v60 = "nw_path_open_in_process_flow_divert_socket";
              v61 = 1024;
              v62 = v23;
              _os_log_impl(&dword_181A37000, v26, v39, "%{public}s connect failed on kernel control socket %{darwin.errno}d, no backtrace", type, 0x12u);
            }
          }

          else
          {
            v26 = __nwlog_obj();
            v41 = v58;
            if (os_log_type_enabled(v26, v58))
            {
              *type = 136446466;
              v60 = "nw_path_open_in_process_flow_divert_socket";
              v61 = 1024;
              v62 = v23;
              _os_log_impl(&dword_181A37000, v26, v41, "%{public}s connect failed on kernel control socket %{darwin.errno}d, backtrace limit exceeded", type, 0x12u);
            }
          }
        }

LABEL_70:
        if (v25)
        {
          free(v25);
        }

        close(v11);
        goto LABEL_73;
      }

      v17 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = gLogObj;
      v70 = 136446466;
      *v71 = "nw_path_open_in_process_flow_divert_socket";
      *&v71[8] = 1024;
      *&v71[10] = v17;
      v19 = _os_log_send_and_compose_impl();

      buf[0] = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v19, buf, type))
      {
        goto LABEL_64;
      }

      if (buf[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = gLogObj;
        v21 = buf[0];
        if (os_log_type_enabled(v20, buf[0]))
        {
          v70 = 136446466;
          *v71 = "nw_path_open_in_process_flow_divert_socket";
          *&v71[8] = 1024;
          *&v71[10] = v17;
          _os_log_impl(&dword_181A37000, v20, v21, "%{public}s Cannot create kernel control socket %{darwin.errno}d", &v70, 0x12u);
        }
      }

      else if (type[0] == OS_LOG_TYPE_INFO)
      {
        v31 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = gLogObj;
        v32 = buf[0];
        v33 = os_log_type_enabled(v20, buf[0]);
        if (v31)
        {
          if (v33)
          {
            v70 = 136446722;
            *v71 = "nw_path_open_in_process_flow_divert_socket";
            *&v71[8] = 1024;
            *&v71[10] = v17;
            *&v71[14] = 2082;
            *&v71[16] = v31;
            _os_log_impl(&dword_181A37000, v20, v32, "%{public}s Cannot create kernel control socket %{darwin.errno}d, dumping backtrace:%{public}s", &v70, 0x1Cu);
          }

          free(v31);
          if (!v19)
          {
            goto LABEL_73;
          }

          goto LABEL_65;
        }

        if (v33)
        {
          v70 = 136446466;
          *v71 = "nw_path_open_in_process_flow_divert_socket";
          *&v71[8] = 1024;
          *&v71[10] = v17;
          _os_log_impl(&dword_181A37000, v20, v32, "%{public}s Cannot create kernel control socket %{darwin.errno}d, no backtrace", &v70, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = gLogObj;
        v35 = buf[0];
        if (os_log_type_enabled(v20, buf[0]))
        {
          v70 = 136446466;
          *v71 = "nw_path_open_in_process_flow_divert_socket";
          *&v71[8] = 1024;
          *&v71[10] = v17;
          _os_log_impl(&dword_181A37000, v20, v35, "%{public}s Cannot create kernel control socket %{darwin.errno}d, backtrace limit exceeded", &v70, 0x12u);
        }
      }

      goto LABEL_63;
    }

    v47 = __nwlog_obj();
    v70 = 136446210;
    *v71 = "nw_path_create_bridged_flow_director_locked";
    v19 = _os_log_send_and_compose_impl();

    buf[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v19, buf, type))
    {
      if (buf[0] == 17)
      {
        v20 = __nwlog_obj();
        v48 = buf[0];
        if (os_log_type_enabled(v20, buf[0]))
        {
          v70 = 136446210;
          *v71 = "nw_path_create_bridged_flow_director_locked";
          _os_log_impl(&dword_181A37000, v20, v48, "%{public}s called with null globals", &v70, 0xCu);
        }

LABEL_63:

        goto LABEL_64;
      }

      if (type[0] != OS_LOG_TYPE_INFO)
      {
        v20 = __nwlog_obj();
        v56 = buf[0];
        if (os_log_type_enabled(v20, buf[0]))
        {
          v70 = 136446210;
          *v71 = "nw_path_create_bridged_flow_director_locked";
          _os_log_impl(&dword_181A37000, v20, v56, "%{public}s called with null globals, backtrace limit exceeded", &v70, 0xCu);
        }

        goto LABEL_63;
      }

      v52 = __nw_create_backtrace_string();
      v20 = __nwlog_obj();
      v53 = buf[0];
      v54 = os_log_type_enabled(v20, buf[0]);
      if (!v52)
      {
        if (v54)
        {
          v70 = 136446210;
          *v71 = "nw_path_create_bridged_flow_director_locked";
          _os_log_impl(&dword_181A37000, v20, v53, "%{public}s called with null globals, no backtrace", &v70, 0xCu);
        }

        goto LABEL_63;
      }

      if (v54)
      {
        v70 = 136446466;
        *v71 = "nw_path_create_bridged_flow_director_locked";
        *&v71[8] = 2082;
        *&v71[10] = v52;
        _os_log_impl(&dword_181A37000, v20, v53, "%{public}s called with null globals, dumping backtrace:%{public}s", &v70, 0x16u);
      }

      free(v52);
    }

LABEL_64:
    if (!v19)
    {
      goto LABEL_73;
    }

LABEL_65:
    free(v19);
    goto LABEL_73;
  }

  v43 = __nwlog_obj();
  v70 = 136446210;
  *v71 = "nw_path_create_bridged_flow_director";
  v44 = _os_log_send_and_compose_impl();

  buf[0] = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v44, buf, type))
  {
    if (buf[0] == 17)
    {
      v45 = __nwlog_obj();
      v46 = buf[0];
      if (os_log_type_enabled(v45, buf[0]))
      {
        v70 = 136446210;
        *v71 = "nw_path_create_bridged_flow_director";
        _os_log_impl(&dword_181A37000, v45, v46, "%{public}s called with null context", &v70, 0xCu);
      }
    }

    else if (type[0] == OS_LOG_TYPE_INFO)
    {
      v49 = __nw_create_backtrace_string();
      v45 = __nwlog_obj();
      v50 = buf[0];
      v51 = os_log_type_enabled(v45, buf[0]);
      if (v49)
      {
        if (v51)
        {
          v70 = 136446466;
          *v71 = "nw_path_create_bridged_flow_director";
          *&v71[8] = 2082;
          *&v71[10] = v49;
          _os_log_impl(&dword_181A37000, v45, v50, "%{public}s called with null context, dumping backtrace:%{public}s", &v70, 0x16u);
        }

        free(v49);
        goto LABEL_105;
      }

      if (v51)
      {
        v70 = 136446210;
        *v71 = "nw_path_create_bridged_flow_director";
        _os_log_impl(&dword_181A37000, v45, v50, "%{public}s called with null context, no backtrace", &v70, 0xCu);
      }
    }

    else
    {
      v45 = __nwlog_obj();
      v55 = buf[0];
      if (os_log_type_enabled(v45, buf[0]))
      {
        v70 = 136446210;
        *v71 = "nw_path_create_bridged_flow_director";
        _os_log_impl(&dword_181A37000, v45, v55, "%{public}s called with null context, backtrace limit exceeded", &v70, 0xCu);
      }
    }
  }

LABEL_105:
  if (v44)
  {
    free(v44);
  }

  v8 = 0;
LABEL_75:

  return v8;
}

void nw_path_release_globals(uint64_t a1, uint64_t a2)
{
  *&v39[5] = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v2 = a2;
    v4 = *(a1 + 40);
    if (v4)
    {
      _nw_hash_table_release(v4, a2);
      *(a1 + 40) = 0;
    }

    v5 = *(a1 + 32);
    *(a1 + 32) = 0;

    v6 = *(a1 + 48);
    *(a1 + 48) = 0;

    v7 = *(a1 + 64);
    *(a1 + 64) = 0;

    v8 = *(a1 + 72);
    *(a1 + 72) = 0;

    v9 = *(a1 + 88);
    *(a1 + 88) = 0;

    v10 = *(a1 + 96);
    *(a1 + 96) = 0;

    if (*(a1 + 104))
    {
      NEFlowDirectorDestroy_delayInitStub(v12);
      *(a1 + 104) = 0;
    }

    if ((v2 & 1) == 0)
    {
      v13 = *(a1 + 56);
      if (v13)
      {
        nw_queue_cancel_source(v13, v11);
        *(a1 + 56) = 0;
      }
    }

    *(a1 + 112) = 0;
    *(a1 + 116) = 0;
    pthread_once(&nw_settings_setup_atfork::pOnce, nw_settings_setup_atfork_inner);
    os_unfair_lock_lock((a1 + 112));
    v14 = *(a1 + 124);
    if ((v14 & 0x80000000) == 0)
    {
      if ((*(a1 + 136) & 2) != 0)
      {
        if (guarded_close_np() && (v2 & 1) == 0)
        {
          v15 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          v16 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v16);
          v17 = gLogObj;
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            v18 = *(a1 + 124);
            *buf = 136446722;
            v37 = "nw_path_close_fd";
            v38 = 1024;
            *v39 = v18;
            v39[2] = 1024;
            *&v39[3] = v15;
            _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_ERROR, "%{public}s Failed to close guarded necp fd %d %{darwin.errno}d", buf, 0x18u);
          }
        }
      }

      else
      {
        close(v14);
      }

      *(a1 + 124) = -1;
    }

    v19 = *(a1 + 128);
    if ((v19 & 0x80000000) == 0)
    {
      if ((*(a1 + 136) & 4) != 0)
      {
        if (guarded_close_np() && (v2 & 1) == 0)
        {
          v20 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          v21 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v21);
          v22 = gLogObj;
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            v23 = *(a1 + 128);
            *buf = 136446722;
            v37 = "nw_path_close_fd";
            v38 = 1024;
            *v39 = v23;
            v39[2] = 1024;
            *&v39[3] = v20;
            _os_log_impl(&dword_181A37000, v22, OS_LOG_TYPE_ERROR, "%{public}s Failed to close guarded necp observer fd %d %{darwin.errno}d", buf, 0x18u);
          }
        }
      }

      else
      {
        close(v19);
      }

      *(a1 + 128) = -1;
    }

    os_unfair_lock_unlock((a1 + 112));
    uuid_clear(a1);

    return;
  }

  v24 = __nwlog_obj(0, a2);
  *buf = 136446210;
  v37 = "nw_path_release_globals";
  v25 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v34 = 0;
  v26 = __nwlog_fault(v25, &type, &v34);
  if (v26)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj(v26, v27);
      v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *buf = 136446210;
        v37 = "nw_path_release_globals";
        v30 = "%{public}s called with null globals";
LABEL_42:
        _os_log_impl(&dword_181A37000, v28, v29, v30, buf, 0xCu);
      }
    }

    else
    {
      if (v34 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v28 = __nwlog_obj(backtrace_string, v32);
        v29 = type;
        v33 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *buf = 136446466;
            v37 = "nw_path_release_globals";
            v38 = 2082;
            *v39 = backtrace_string;
            _os_log_impl(&dword_181A37000, v28, v29, "%{public}s called with null globals, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_44;
        }

        if (!v33)
        {
          goto LABEL_43;
        }

        *buf = 136446210;
        v37 = "nw_path_release_globals";
        v30 = "%{public}s called with null globals, no backtrace";
        goto LABEL_42;
      }

      v28 = __nwlog_obj(v26, v27);
      v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *buf = 136446210;
        v37 = "nw_path_release_globals";
        v30 = "%{public}s called with null globals, backtrace limit exceeded";
        goto LABEL_42;
      }
    }

LABEL_43:
  }

LABEL_44:
  if (v25)
  {
    free(v25);
  }
}

const char *nw_path_status_get_description(unsigned int a1)
{
  if (a1 > 3)
  {
    return "unknown";
  }

  else
  {
    return off_1E6A39D08[a1];
  }
}

char *nw_path_flow_registration_copy_description(uint64_t a1)
{
  v4 = *MEMORY[0x1E69E9840];
  memset(out, 0, 37);
  uuid_unparse_upper((a1 + 32), out);
  v2 = 0;
  asprintf(&v2, "%s", out);
  return v2;
}

uint64_t nw_path_get_tcp_flow_statistics(void *a1, void *a2)
{
  v45 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v19 = __nwlog_obj();
    LODWORD(__src[0]) = 136446210;
    *(__src + 4) = "nw_path_get_tcp_flow_statistics";
    v12 = _os_log_send_and_compose_impl();

    buf[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v12, buf, &type))
    {
      goto LABEL_29;
    }

    if (buf[0] == 17)
    {
      v20 = __nwlog_obj();
      v21 = buf[0];
      if (os_log_type_enabled(v20, buf[0]))
      {
        LODWORD(__src[0]) = 136446210;
        *(__src + 4) = "nw_path_get_tcp_flow_statistics";
        _os_log_impl(&dword_181A37000, v20, v21, "%{public}s called with null registration", __src, 0xCu);
      }

      goto LABEL_78;
    }

    if (type != OS_LOG_TYPE_INFO)
    {
      v20 = __nwlog_obj();
      v31 = buf[0];
      if (os_log_type_enabled(v20, buf[0]))
      {
        LODWORD(__src[0]) = 136446210;
        *(__src + 4) = "nw_path_get_tcp_flow_statistics";
        _os_log_impl(&dword_181A37000, v20, v31, "%{public}s called with null registration, backtrace limit exceeded", __src, 0xCu);
      }

      goto LABEL_78;
    }

    backtrace_string = __nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v25 = buf[0];
    v26 = os_log_type_enabled(v20, buf[0]);
    if (!backtrace_string)
    {
      if (v26)
      {
        LODWORD(__src[0]) = 136446210;
        *(__src + 4) = "nw_path_get_tcp_flow_statistics";
        _os_log_impl(&dword_181A37000, v20, v25, "%{public}s called with null registration, no backtrace", __src, 0xCu);
      }

      goto LABEL_78;
    }

    if (v26)
    {
      LODWORD(__src[0]) = 136446466;
      *(__src + 4) = "nw_path_get_tcp_flow_statistics";
      WORD6(__src[0]) = 2082;
      *(__src + 14) = backtrace_string;
      _os_log_impl(&dword_181A37000, v20, v25, "%{public}s called with null registration, dumping backtrace:%{public}s", __src, 0x16u);
    }

    goto LABEL_66;
  }

  if (!a2)
  {
    v22 = __nwlog_obj();
    LODWORD(__src[0]) = 136446210;
    *(__src + 4) = "nw_path_get_tcp_flow_statistics";
    v12 = _os_log_send_and_compose_impl();

    buf[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v12, buf, &type))
    {
      goto LABEL_29;
    }

    if (buf[0] == 17)
    {
      v20 = __nwlog_obj();
      v23 = buf[0];
      if (os_log_type_enabled(v20, buf[0]))
      {
        LODWORD(__src[0]) = 136446210;
        *(__src + 4) = "nw_path_get_tcp_flow_statistics";
        _os_log_impl(&dword_181A37000, v20, v23, "%{public}s called with null info", __src, 0xCu);
      }

      goto LABEL_78;
    }

    if (type != OS_LOG_TYPE_INFO)
    {
      v20 = __nwlog_obj();
      v32 = buf[0];
      if (os_log_type_enabled(v20, buf[0]))
      {
        LODWORD(__src[0]) = 136446210;
        *(__src + 4) = "nw_path_get_tcp_flow_statistics";
        _os_log_impl(&dword_181A37000, v20, v32, "%{public}s called with null info, backtrace limit exceeded", __src, 0xCu);
      }

      goto LABEL_78;
    }

    backtrace_string = __nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v29 = buf[0];
    v30 = os_log_type_enabled(v20, buf[0]);
    if (!backtrace_string)
    {
      if (v30)
      {
        LODWORD(__src[0]) = 136446210;
        *(__src + 4) = "nw_path_get_tcp_flow_statistics";
        _os_log_impl(&dword_181A37000, v20, v29, "%{public}s called with null info, no backtrace", __src, 0xCu);
      }

      goto LABEL_78;
    }

    if (v30)
    {
      LODWORD(__src[0]) = 136446466;
      *(__src + 4) = "nw_path_get_tcp_flow_statistics";
      WORD6(__src[0]) = 2082;
      *(__src + 14) = backtrace_string;
      _os_log_impl(&dword_181A37000, v20, v29, "%{public}s called with null info, dumping backtrace:%{public}s", __src, 0x16u);
    }

    goto LABEL_66;
  }

  if (v3[148])
  {
    v6 = *(v3 + 1);
    if (v6)
    {
      v7 = nw_parameters_copy_context(*(v6 + 8));
      v8 = nw_path_shared_necp_fd(v7);

      if (v8 < 0 || uuid_is_null(v4 + 32))
      {
        goto LABEL_8;
      }

      memset(__src, 0, 428);
      BYTE8(__src[26]) = 6;
      if (!necp_client_action())
      {
        memcpy(a2, __src, 0x1A8uLL);
LABEL_8:
        v5 = 1;
        goto LABEL_9;
      }

      v10 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      *buf = 136446466;
      v39 = "nw_path_get_tcp_flow_statistics";
      v40 = 1024;
      v41 = v10;
      v12 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v36 = 0;
      if (__nwlog_fault(v12, &type, &v36))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v13 = gLogObj;
          v14 = type;
          if (os_log_type_enabled(v13, type))
          {
            *buf = 136446466;
            v39 = "nw_path_get_tcp_flow_statistics";
            v40 = 1024;
            v41 = v10;
            _os_log_impl(&dword_181A37000, v13, v14, "%{public}s NECP_CLIENT_ACTION_GET_FLOW_STATISTICS error %{darwin.errno}d", buf, 0x12u);
          }
        }

        else if (v36 == 1)
        {
          v15 = __nw_create_backtrace_string();
          v13 = __nwlog_obj();
          v16 = type;
          v17 = os_log_type_enabled(v13, type);
          if (v15)
          {
            if (v17)
            {
              *buf = 136446722;
              v39 = "nw_path_get_tcp_flow_statistics";
              v40 = 1024;
              v41 = v10;
              v42 = 2082;
              v43 = v15;
              _os_log_impl(&dword_181A37000, v13, v16, "%{public}s NECP_CLIENT_ACTION_GET_FLOW_STATISTICS error %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v15);
            if (!v12)
            {
              goto LABEL_4;
            }

            goto LABEL_30;
          }

          if (v17)
          {
            *buf = 136446466;
            v39 = "nw_path_get_tcp_flow_statistics";
            v40 = 1024;
            v41 = v10;
            _os_log_impl(&dword_181A37000, v13, v16, "%{public}s NECP_CLIENT_ACTION_GET_FLOW_STATISTICS error %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }

        else
        {
          v13 = __nwlog_obj();
          v18 = type;
          if (os_log_type_enabled(v13, type))
          {
            *buf = 136446466;
            v39 = "nw_path_get_tcp_flow_statistics";
            v40 = 1024;
            v41 = v10;
            _os_log_impl(&dword_181A37000, v13, v18, "%{public}s NECP_CLIENT_ACTION_GET_FLOW_STATISTICS error %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }
      }

LABEL_29:
      if (!v12)
      {
        goto LABEL_4;
      }

LABEL_30:
      free(v12);
      goto LABEL_4;
    }

    v27 = __nwlog_obj();
    LODWORD(__src[0]) = 136446210;
    *(__src + 4) = "nw_path_get_tcp_flow_statistics";
    v12 = _os_log_send_and_compose_impl();

    buf[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v12, buf, &type))
    {
      goto LABEL_29;
    }

    if (buf[0] == 17)
    {
      v20 = __nwlog_obj();
      v28 = buf[0];
      if (os_log_type_enabled(v20, buf[0]))
      {
        LODWORD(__src[0]) = 136446210;
        *(__src + 4) = "nw_path_get_tcp_flow_statistics";
        _os_log_impl(&dword_181A37000, v20, v28, "%{public}s called with null registration->parent_evaluator", __src, 0xCu);
      }

LABEL_78:

      goto LABEL_29;
    }

    if (type != OS_LOG_TYPE_INFO)
    {
      v20 = __nwlog_obj();
      v35 = buf[0];
      if (os_log_type_enabled(v20, buf[0]))
      {
        LODWORD(__src[0]) = 136446210;
        *(__src + 4) = "nw_path_get_tcp_flow_statistics";
        _os_log_impl(&dword_181A37000, v20, v35, "%{public}s called with null registration->parent_evaluator, backtrace limit exceeded", __src, 0xCu);
      }

      goto LABEL_78;
    }

    backtrace_string = __nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v33 = buf[0];
    v34 = os_log_type_enabled(v20, buf[0]);
    if (!backtrace_string)
    {
      if (v34)
      {
        LODWORD(__src[0]) = 136446210;
        *(__src + 4) = "nw_path_get_tcp_flow_statistics";
        _os_log_impl(&dword_181A37000, v20, v33, "%{public}s called with null registration->parent_evaluator, no backtrace", __src, 0xCu);
      }

      goto LABEL_78;
    }

    if (v34)
    {
      LODWORD(__src[0]) = 136446466;
      *(__src + 4) = "nw_path_get_tcp_flow_statistics";
      WORD6(__src[0]) = 2082;
      *(__src + 14) = backtrace_string;
      _os_log_impl(&dword_181A37000, v20, v33, "%{public}s called with null registration->parent_evaluator, dumping backtrace:%{public}s", __src, 0x16u);
    }

LABEL_66:

    free(backtrace_string);
    goto LABEL_29;
  }

LABEL_4:
  v5 = 0;
LABEL_9:

  return v5;
}

void nw_path_set_reason(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  v43 = *MEMORY[0x1E69E9840];
  v11 = a1;
  v12 = v11;
  if (!v11)
  {
    v23 = __nwlog_obj();
    *buf = 136446210;
    v36 = "nw_path_set_reason";
    v24 = _os_log_send_and_compose_impl();

    v34[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v33) = 0;
    if (__nwlog_fault(v24, v34, &v33))
    {
      if (v34[0] == OS_LOG_TYPE_FAULT)
      {
        v25 = __nwlog_obj();
        v26 = v34[0];
        if (os_log_type_enabled(v25, v34[0]))
        {
          *buf = 136446210;
          v36 = "nw_path_set_reason";
          _os_log_impl(&dword_181A37000, v25, v26, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v33 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v25 = __nwlog_obj();
        v28 = v34[0];
        v29 = os_log_type_enabled(v25, v34[0]);
        if (backtrace_string)
        {
          if (v29)
          {
            *buf = 136446466;
            v36 = "nw_path_set_reason";
            v37 = 2082;
            v38 = backtrace_string;
            _os_log_impl(&dword_181A37000, v25, v28, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_45;
        }

        if (v29)
        {
          *buf = 136446210;
          v36 = "nw_path_set_reason";
          _os_log_impl(&dword_181A37000, v25, v28, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v25 = __nwlog_obj();
        v30 = v34[0];
        if (os_log_type_enabled(v25, v34[0]))
        {
          *buf = 136446210;
          v36 = "nw_path_set_reason";
          _os_log_impl(&dword_181A37000, v25, v30, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_45:
    if (!v24)
    {
      goto LABEL_16;
    }

    v18 = v24;
    goto LABEL_15;
  }

  if (!a3)
  {
    _nw_path_set_reason(v11, a2, 0);
    goto LABEL_16;
  }

  v33 = &a9;
  *v34 = 0;
  v13 = vasprintf(v34, a3, &a9);
  if ((v13 & 0x80000000) == 0 && *v34)
  {
    _nw_path_set_reason(v12, a2, *v34);
    goto LABEL_14;
  }

  _nw_path_set_reason(v12, a2, 0);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v14 = gLogObj;
  *buf = 136446722;
  v36 = "nw_path_set_reason";
  v37 = 2082;
  v38 = a3;
  v39 = 1024;
  v40 = v13;
  v15 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (!__nwlog_fault(v15, &type, &v31))
  {
LABEL_12:
    if (!v15)
    {
      goto LABEL_14;
    }

    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = gLogObj;
    v17 = type;
    if (os_log_type_enabled(v16, type))
    {
      *buf = 136446722;
      v36 = "nw_path_set_reason";
      v37 = 2082;
      v38 = a3;
      v39 = 1024;
      v40 = v13;
      _os_log_impl(&dword_181A37000, v16, v17, "%{public}s vasprintf(%{public}s) returned %d failed", buf, 0x1Cu);
    }

LABEL_11:

    goto LABEL_12;
  }

  if (v31 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = gLogObj;
    v22 = type;
    if (os_log_type_enabled(v16, type))
    {
      *buf = 136446722;
      v36 = "nw_path_set_reason";
      v37 = 2082;
      v38 = a3;
      v39 = 1024;
      v40 = v13;
      _os_log_impl(&dword_181A37000, v16, v22, "%{public}s vasprintf(%{public}s) returned %d failed, backtrace limit exceeded", buf, 0x1Cu);
    }

    goto LABEL_11;
  }

  v19 = __nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v16 = gLogObj;
  v20 = type;
  v21 = os_log_type_enabled(v16, type);
  if (!v19)
  {
    if (v21)
    {
      *buf = 136446722;
      v36 = "nw_path_set_reason";
      v37 = 2082;
      v38 = a3;
      v39 = 1024;
      v40 = v13;
      _os_log_impl(&dword_181A37000, v16, v20, "%{public}s vasprintf(%{public}s) returned %d failed, no backtrace", buf, 0x1Cu);
    }

    goto LABEL_11;
  }

  if (v21)
  {
    *buf = 136446978;
    v36 = "nw_path_set_reason";
    v37 = 2082;
    v38 = a3;
    v39 = 1024;
    v40 = v13;
    v41 = 2082;
    v42 = v19;
    _os_log_impl(&dword_181A37000, v16, v20, "%{public}s vasprintf(%{public}s) returned %d failed, dumping backtrace:%{public}s", buf, 0x26u);
  }

  free(v19);
  if (v15)
  {
LABEL_13:
    free(v15);
  }

LABEL_14:
  v18 = *v34;
  if (*v34)
  {
LABEL_15:
    free(v18);
  }

LABEL_16:
}

void nw_path_prepare_fork()
{
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
  {
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }

  v0 = nw_context_copy_implicit_context::implicit_context;
  globals_for_path = nw_context_get_globals_for_path(v0);

  os_unfair_lock_lock(globals_for_path + 29);

  os_unfair_lock_lock(globals_for_path + 28);
}

void nw_path_parent_has_forked()
{
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
  {
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }

  v0 = nw_context_copy_implicit_context::implicit_context;
  globals_for_path = nw_context_get_globals_for_path(v0);

  os_unfair_lock_unlock(globals_for_path + 28);

  os_unfair_lock_unlock(globals_for_path + 29);
}

BOOL nw_path_endpoint_is_always_satisfied(void *a1)
{
  v1 = a1;
  v2 = v1;
  if (v1 && (v3 = v1, type = _nw_endpoint_get_type(v3), v3, type == 1))
  {
    v5 = v3;
    address_family = _nw_endpoint_get_address_family(v5);

    v8 = address_family != 2 && address_family != 30;
  }

  else
  {
    v8 = 0;
  }

  return v8;
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_group(void *a1, void *a2)
{
  v39 = *MEMORY[0x1E69E9840];
  v4 = a1;
  v5 = a2;
  if (v4)
  {
    v6 = objc_alloc_init(NWConcrete_nw_path_evaluator);
    v7 = v6;
    if (v6)
    {
      objc_storeStrong(v6 + 3, a1);
      if (v5)
      {
        v8 = v5;
      }

      else
      {
        v8 = _nw_parameters_create();
      }

      v13 = *(v7 + 1);
      *(v7 + 1) = v8;

      if (nw_path_evaluator_evaluate(v7, 0))
      {
        v14 = v7;
LABEL_44:

        goto LABEL_45;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      *buf = 136446210;
      v36 = "nw_path_create_evaluator_for_group";
      v10 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v33 = 0;
      if (!__nwlog_fault(v10, &type, &v33))
      {
LABEL_41:
        if (!v10)
        {
LABEL_43:
          v14 = 0;
          goto LABEL_44;
        }

LABEL_42:
        free(v10);
        goto LABEL_43;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          v36 = "nw_path_create_evaluator_for_group";
          _os_log_impl(&dword_181A37000, v11, v16, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
        }

LABEL_40:

        goto LABEL_41;
      }

      if (v33 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v23 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          v36 = "nw_path_create_evaluator_for_group";
          _os_log_impl(&dword_181A37000, v11, v23, "%{public}s nw_path_evaluator_evaluate failed, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v20 = type;
      v21 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *buf = 136446210;
          v36 = "nw_path_create_evaluator_for_group";
          _os_log_impl(&dword_181A37000, v11, v20, "%{public}s nw_path_evaluator_evaluate failed, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v21)
      {
        *buf = 136446466;
        v36 = "nw_path_create_evaluator_for_group";
        v37 = 2082;
        v38 = backtrace_string;
        _os_log_impl(&dword_181A37000, v11, v20, "%{public}s nw_path_evaluator_evaluate failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      *buf = 136446210;
      v36 = "nw_path_create_evaluator_for_group";
      v10 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v33 = 0;
      if (!__nwlog_fault(v10, &type, &v33))
      {
        goto LABEL_41;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          v36 = "nw_path_create_evaluator_for_group";
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v33 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v22 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          v36 = "nw_path_create_evaluator_for_group";
          _os_log_impl(&dword_181A37000, v11, v22, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_40;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *buf = 136446210;
          v36 = "nw_path_create_evaluator_for_group";
          _os_log_impl(&dword_181A37000, v11, v18, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
        }

        goto LABEL_40;
      }

      if (v19)
      {
        *buf = 136446466;
        v36 = "nw_path_create_evaluator_for_group";
        v37 = 2082;
        v38 = backtrace_string;
        _os_log_impl(&dword_181A37000, v11, v18, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(backtrace_string);
    if (!v10)
    {
      goto LABEL_43;
    }

    goto LABEL_42;
  }

  v25 = __nwlog_obj();
  *buf = 136446210;
  v36 = "nw_path_create_evaluator_for_group";
  v26 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v33 = 0;
  if (__nwlog_fault(v26, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *buf = 136446210;
        v36 = "nw_path_create_evaluator_for_group";
        _os_log_impl(&dword_181A37000, v27, v28, "%{public}s called with null group_descriptor", buf, 0xCu);
      }
    }

    else if (v33 == 1)
    {
      v29 = __nw_create_backtrace_string();
      v27 = __nwlog_obj();
      v30 = type;
      v31 = os_log_type_enabled(v27, type);
      if (v29)
      {
        if (v31)
        {
          *buf = 136446466;
          v36 = "nw_path_create_evaluator_for_group";
          v37 = 2082;
          v38 = v29;
          _os_log_impl(&dword_181A37000, v27, v30, "%{public}s called with null group_descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v29);
        goto LABEL_62;
      }

      if (v31)
      {
        *buf = 136446210;
        v36 = "nw_path_create_evaluator_for_group";
        _os_log_impl(&dword_181A37000, v27, v30, "%{public}s called with null group_descriptor, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v27 = __nwlog_obj();
      v32 = type;
      if (os_log_type_enabled(v27, type))
      {
        *buf = 136446210;
        v36 = "nw_path_create_evaluator_for_group";
        _os_log_impl(&dword_181A37000, v27, v32, "%{public}s called with null group_descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_62:
  if (v26)
  {
    free(v26);
  }

  v14 = 0;
LABEL_45:

  return v14;
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_advertise(void *a1, void *a2)
{
  v31 = *MEMORY[0x1E69E9840];
  v4 = a1;
  v5 = a2;
  if (!v4)
  {
    v19 = __nwlog_obj();
    *buf = 136446210;
    v28 = "nw_path_create_evaluator_for_advertise";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v9, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v10 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v28 = "nw_path_create_evaluator_for_advertise";
          _os_log_impl(&dword_181A37000, v10, v20, "%{public}s called with null advertise_descriptor", buf, 0xCu);
        }

LABEL_26:

        goto LABEL_27;
      }

      if (v25 != 1)
      {
        v10 = __nwlog_obj();
        v24 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v28 = "nw_path_create_evaluator_for_advertise";
          _os_log_impl(&dword_181A37000, v10, v24, "%{public}s called with null advertise_descriptor, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_26;
      }

      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v22 = type;
      v23 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *buf = 136446210;
          v28 = "nw_path_create_evaluator_for_advertise";
          _os_log_impl(&dword_181A37000, v10, v22, "%{public}s called with null advertise_descriptor, no backtrace", buf, 0xCu);
        }

        goto LABEL_26;
      }

      if (v23)
      {
        *buf = 136446466;
        v28 = "nw_path_create_evaluator_for_advertise";
        v29 = 2082;
        v30 = backtrace_string;
        _os_log_impl(&dword_181A37000, v10, v22, "%{public}s called with null advertise_descriptor, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }

LABEL_27:
    if (!v9)
    {
LABEL_29:
      v6 = 0;
      goto LABEL_30;
    }

LABEL_28:
    free(v9);
    goto LABEL_29;
  }

  v6 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    *buf = 136446210;
    v28 = "nw_path_create_evaluator_for_advertise";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v9, &type, &v25))
    {
      goto LABEL_27;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v28 = "nw_path_create_evaluator_for_advertise";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
    }

    else if (v25 == 1)
    {
      v14 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (v14)
      {
        if (v16)
        {
          *buf = 136446466;
          v28 = "nw_path_create_evaluator_for_advertise";
          v29 = 2082;
          v30 = v14;
          _os_log_impl(&dword_181A37000, v10, v15, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v14);
        if (!v9)
        {
          goto LABEL_29;
        }

        goto LABEL_28;
      }

      if (v16)
      {
        *buf = 136446210;
        v28 = "nw_path_create_evaluator_for_advertise";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v17 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v28 = "nw_path_create_evaluator_for_advertise";
        _os_log_impl(&dword_181A37000, v10, v17, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_26;
  }

  if (v5)
  {
    v7 = v5;
  }

  else
  {
    v7 = _nw_parameters_create();
  }

  v12 = *(v6 + 1);
  *(v6 + 1) = v7;

  objc_storeStrong(v6 + 5, a1);
  if ((nw_path_evaluator_evaluate(v6, 0) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = gLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v28 = "nw_path_create_evaluator_for_advertise";
      _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    goto LABEL_29;
  }

LABEL_30:

  return v6;
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_custom_ether(void *a1, __int16 a2)
{
  v29 = *MEMORY[0x1E69E9840];
  v4 = a1;
  if (!v4)
  {
    v17 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_path_create_evaluator_for_custom_ether";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v9, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v10 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v26 = "nw_path_create_evaluator_for_custom_ether";
          _os_log_impl(&dword_181A37000, v10, v18, "%{public}s called with null parameters", buf, 0xCu);
        }

LABEL_23:

        goto LABEL_24;
      }

      if (v23 != 1)
      {
        v10 = __nwlog_obj();
        v22 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v26 = "nw_path_create_evaluator_for_custom_ether";
          _os_log_impl(&dword_181A37000, v10, v22, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_23;
      }

      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v20 = type;
      v21 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *buf = 136446210;
          v26 = "nw_path_create_evaluator_for_custom_ether";
          _os_log_impl(&dword_181A37000, v10, v20, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }

        goto LABEL_23;
      }

      if (v21)
      {
        *buf = 136446466;
        v26 = "nw_path_create_evaluator_for_custom_ether";
        v27 = 2082;
        v28 = backtrace_string;
        _os_log_impl(&dword_181A37000, v10, v20, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }

LABEL_24:
    if (!v9)
    {
LABEL_26:
      v6 = 0;
      goto LABEL_27;
    }

LABEL_25:
    free(v9);
    goto LABEL_26;
  }

  v5 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    *buf = 136446210;
    v26 = "nw_path_create_evaluator_for_custom_ether";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v9, &type, &v23))
    {
      goto LABEL_24;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v26 = "nw_path_create_evaluator_for_custom_ether";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
    }

    else if (v23 == 1)
    {
      v12 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (v12)
      {
        if (v14)
        {
          *buf = 136446466;
          v26 = "nw_path_create_evaluator_for_custom_ether";
          v27 = 2082;
          v28 = v12;
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v12);
        if (!v9)
        {
          goto LABEL_26;
        }

        goto LABEL_25;
      }

      if (v14)
      {
        *buf = 136446210;
        v26 = "nw_path_create_evaluator_for_custom_ether";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v26 = "nw_path_create_evaluator_for_custom_ether";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_23;
  }

  objc_storeStrong(v5 + 1, a1);
  *(v6 + 52) = a2;
  if ((nw_path_evaluator_evaluate(v6, 0) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v26 = "nw_path_create_evaluator_for_custom_ether";
      _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    goto LABEL_26;
  }

LABEL_27:

  return v6;
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_all_custom_ether_interfaces(void *a1)
{
  v27 = *MEMORY[0x1E69E9840];
  v2 = a1;
  if (!v2)
  {
    v15 = __nwlog_obj();
    *buf = 136446210;
    v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v7, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v8 = __nwlog_obj();
        v16 = type;
        if (os_log_type_enabled(v8, type))
        {
          *buf = 136446210;
          v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
          _os_log_impl(&dword_181A37000, v8, v16, "%{public}s called with null parameters", buf, 0xCu);
        }

LABEL_23:

        goto LABEL_24;
      }

      if (v21 != 1)
      {
        v8 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          *buf = 136446210;
          v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
          _os_log_impl(&dword_181A37000, v8, v20, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_23;
      }

      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v18 = type;
      v19 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *buf = 136446210;
          v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
          _os_log_impl(&dword_181A37000, v8, v18, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }

        goto LABEL_23;
      }

      if (v19)
      {
        *buf = 136446466;
        v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_181A37000, v8, v18, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }

LABEL_24:
    if (!v7)
    {
      goto LABEL_26;
    }

LABEL_25:
    free(v7);
    goto LABEL_26;
  }

  v3 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    *buf = 136446210;
    v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v7, &type, &v21))
    {
      goto LABEL_24;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
    }

    else if (v21 == 1)
    {
      v10 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (v10)
      {
        if (v12)
        {
          *buf = 136446466;
          v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
          v25 = 2082;
          v26 = v10;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v10);
        if (!v7)
        {
          goto LABEL_26;
        }

        goto LABEL_25;
      }

      if (v12)
      {
        *buf = 136446210;
        v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_23;
  }

  objc_storeStrong(v3 + 1, a1);
  *(v4 + 107) |= 0xAu;
  if (nw_path_evaluator_evaluate(v4, 0))
  {
    goto LABEL_27;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *buf = 136446210;
    v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
    _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
  }

LABEL_26:
  v4 = 0;
LABEL_27:

  return v4;
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_custom_ip(void *a1, char a2)
{
  v29 = *MEMORY[0x1E69E9840];
  v4 = a1;
  if (!v4)
  {
    v17 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_path_create_evaluator_for_custom_ip";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v9, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v10 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v26 = "nw_path_create_evaluator_for_custom_ip";
          _os_log_impl(&dword_181A37000, v10, v18, "%{public}s called with null parameters", buf, 0xCu);
        }

LABEL_23:

        goto LABEL_24;
      }

      if (v23 != 1)
      {
        v10 = __nwlog_obj();
        v22 = type;
        if (os_log_type_enabled(v10, type))
        {
          *buf = 136446210;
          v26 = "nw_path_create_evaluator_for_custom_ip";
          _os_log_impl(&dword_181A37000, v10, v22, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_23;
      }

      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v20 = type;
      v21 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *buf = 136446210;
          v26 = "nw_path_create_evaluator_for_custom_ip";
          _os_log_impl(&dword_181A37000, v10, v20, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }

        goto LABEL_23;
      }

      if (v21)
      {
        *buf = 136446466;
        v26 = "nw_path_create_evaluator_for_custom_ip";
        v27 = 2082;
        v28 = backtrace_string;
        _os_log_impl(&dword_181A37000, v10, v20, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }

LABEL_24:
    if (!v9)
    {
LABEL_26:
      v6 = 0;
      goto LABEL_27;
    }

LABEL_25:
    free(v9);
    goto LABEL_26;
  }

  v5 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    *buf = 136446210;
    v26 = "nw_path_create_evaluator_for_custom_ip";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v9, &type, &v23))
    {
      goto LABEL_24;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v26 = "nw_path_create_evaluator_for_custom_ip";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
    }

    else if (v23 == 1)
    {
      v12 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (v12)
      {
        if (v14)
        {
          *buf = 136446466;
          v26 = "nw_path_create_evaluator_for_custom_ip";
          v27 = 2082;
          v28 = v12;
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v12);
        if (!v9)
        {
          goto LABEL_26;
        }

        goto LABEL_25;
      }

      if (v14)
      {
        *buf = 136446210;
        v26 = "nw_path_create_evaluator_for_custom_ip";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v26 = "nw_path_create_evaluator_for_custom_ip";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_23;
  }

  objc_storeStrong(v5 + 1, a1);
  *(v6 + 106) = a2;
  if ((nw_path_evaluator_evaluate(v6, 0) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v26 = "nw_path_create_evaluator_for_custom_ip";
      _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    goto LABEL_26;
  }

LABEL_27:

  return v6;
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_interpose(void *a1)
{
  v27 = *MEMORY[0x1E69E9840];
  v2 = a1;
  if (!v2)
  {
    v15 = __nwlog_obj();
    *buf = 136446210;
    v24 = "nw_path_create_evaluator_for_interpose";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v7, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v8 = __nwlog_obj();
        v16 = type;
        if (os_log_type_enabled(v8, type))
        {
          *buf = 136446210;
          v24 = "nw_path_create_evaluator_for_interpose";
          _os_log_impl(&dword_181A37000, v8, v16, "%{public}s called with null parameters", buf, 0xCu);
        }

LABEL_23:

        goto LABEL_24;
      }

      if (v21 != 1)
      {
        v8 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          *buf = 136446210;
          v24 = "nw_path_create_evaluator_for_interpose";
          _os_log_impl(&dword_181A37000, v8, v20, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_23;
      }

      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v18 = type;
      v19 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *buf = 136446210;
          v24 = "nw_path_create_evaluator_for_interpose";
          _os_log_impl(&dword_181A37000, v8, v18, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }

        goto LABEL_23;
      }

      if (v19)
      {
        *buf = 136446466;
        v24 = "nw_path_create_evaluator_for_interpose";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_181A37000, v8, v18, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }

LABEL_24:
    if (!v7)
    {
LABEL_26:
      v4 = 0;
      goto LABEL_27;
    }

LABEL_25:
    free(v7);
    goto LABEL_26;
  }

  v3 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    *buf = 136446210;
    v24 = "nw_path_create_evaluator_for_interpose";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v7, &type, &v21))
    {
      goto LABEL_24;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v24 = "nw_path_create_evaluator_for_interpose";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
    }

    else if (v21 == 1)
    {
      v10 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (v10)
      {
        if (v12)
        {
          *buf = 136446466;
          v24 = "nw_path_create_evaluator_for_interpose";
          v25 = 2082;
          v26 = v10;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v10);
        if (!v7)
        {
          goto LABEL_26;
        }

        goto LABEL_25;
      }

      if (v12)
      {
        *buf = 136446210;
        v24 = "nw_path_create_evaluator_for_interpose";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v24 = "nw_path_create_evaluator_for_interpose";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_23;
  }

  objc_storeStrong(v3 + 1, a1);
  *(v4 + 107) |= 6u;
  if ((nw_path_evaluator_evaluate(v4, 0) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446210;
      v24 = "nw_path_create_evaluator_for_interpose";
      _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    goto LABEL_26;
  }

LABEL_27:

  return v4;
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_client_id(const unsigned __int8 *a1, void *a2)
{
  v88 = *MEMORY[0x1E69E9840];
  v3 = a2;
  if (!v3)
  {
    v57 = __nwlog_obj();
    *buf = 136446210;
    v84 = "nw_path_create_evaluator_for_client_id";
    v58 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v87) = 0;
    if (!__nwlog_fault(v58, type, &v87))
    {
      goto LABEL_146;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v59 = __nwlog_obj();
      v60 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *buf = 136446210;
        v84 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_181A37000, v59, v60, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v87 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v59 = __nwlog_obj();
      v64 = type[0];
      v65 = os_log_type_enabled(v59, type[0]);
      if (backtrace_string)
      {
        if (v65)
        {
          *buf = 136446466;
          v84 = "nw_path_create_evaluator_for_client_id";
          v85 = 2082;
          v86[0] = backtrace_string;
          _os_log_impl(&dword_181A37000, v59, v64, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v58)
        {
          goto LABEL_148;
        }

        goto LABEL_147;
      }

      if (v65)
      {
        *buf = 136446210;
        v84 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_181A37000, v59, v64, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v59 = __nwlog_obj();
      v69 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *buf = 136446210;
        v84 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_181A37000, v59, v69, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_145;
  }

  if (uuid_is_null(a1))
  {
    v61 = __nwlog_obj();
    *buf = 136446210;
    v84 = "nw_path_create_evaluator_for_client_id";
    v58 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v87) = 0;
    if (!__nwlog_fault(v58, type, &v87))
    {
      goto LABEL_146;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v59 = __nwlog_obj();
      v62 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *buf = 136446210;
        v84 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_181A37000, v59, v62, "%{public}s called with null !uuid_is_null(client_id)", buf, 0xCu);
      }
    }

    else if (v87 == 1)
    {
      v66 = __nw_create_backtrace_string();
      v59 = __nwlog_obj();
      v67 = type[0];
      v68 = os_log_type_enabled(v59, type[0]);
      if (v66)
      {
        if (v68)
        {
          *buf = 136446466;
          v84 = "nw_path_create_evaluator_for_client_id";
          v85 = 2082;
          v86[0] = v66;
          _os_log_impl(&dword_181A37000, v59, v67, "%{public}s called with null !uuid_is_null(client_id), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v66);
LABEL_146:
        if (!v58)
        {
LABEL_148:
          v18 = 0;
          goto LABEL_98;
        }

LABEL_147:
        free(v58);
        goto LABEL_148;
      }

      if (v68)
      {
        *buf = 136446210;
        v84 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_181A37000, v59, v67, "%{public}s called with null !uuid_is_null(client_id), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v59 = __nwlog_obj();
      v70 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *buf = 136446210;
        v84 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl(&dword_181A37000, v59, v70, "%{public}s called with null !uuid_is_null(client_id), backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_145:

    goto LABEL_146;
  }

  v4 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  if (v4)
  {
    v5 = _nw_parameters_create();
    v6 = *(v4 + 1);
    *(v4 + 1) = v5;

    nw_parameters_set_context(*(v4 + 1), v3);
    nw_path_shared_necp_fd(v3);
    v87 = *a1;
    if (necp_client_action())
    {
      v7 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = v8;
      if (v7 == 2)
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *buf = 136446466;
          v84 = "nw_path_create_evaluator_for_client_id";
          v85 = 1024;
          LODWORD(v86[0]) = 2;
          _os_log_impl(&dword_181A37000, v9, OS_LOG_TYPE_ERROR, "%{public}s NECP_CLIENT_ACTION_CLAIM %{darwin.errno}d", buf, 0x12u);
        }

        goto LABEL_96;
      }

      *buf = 136446466;
      v84 = "nw_path_create_evaluator_for_client_id";
      v85 = 1024;
      LODWORD(v86[0]) = v7;
      v11 = _os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v78) = 0;
      if (__nwlog_fault(v11, type, &v78))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v19 = gLogObj;
          v20 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *buf = 136446466;
            v84 = "nw_path_create_evaluator_for_client_id";
            v85 = 1024;
            LODWORD(v86[0]) = v7;
            _os_log_impl(&dword_181A37000, v19, v20, "%{public}s NECP_CLIENT_ACTION_CLAIM %{darwin.errno}d", buf, 0x12u);
          }
        }

        else if (v78 == 1)
        {
          v24 = __nw_create_backtrace_string();
          if (v24)
          {
            v25 = v24;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v26 = gLogObj;
            v27 = type[0];
            if (os_log_type_enabled(v26, type[0]))
            {
              *buf = 136446722;
              v84 = "nw_path_create_evaluator_for_client_id";
              v85 = 1024;
              LODWORD(v86[0]) = v7;
              WORD2(v86[0]) = 2082;
              *(v86 + 6) = v25;
              _os_log_impl(&dword_181A37000, v26, v27, "%{public}s NECP_CLIENT_ACTION_CLAIM %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v25);
            if (!v11)
            {
              goto LABEL_96;
            }

            goto LABEL_95;
          }

          v19 = __nwlog_obj();
          v53 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *buf = 136446466;
            v84 = "nw_path_create_evaluator_for_client_id";
            v85 = 1024;
            LODWORD(v86[0]) = v7;
            _os_log_impl(&dword_181A37000, v19, v53, "%{public}s NECP_CLIENT_ACTION_CLAIM %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v19 = gLogObj;
          v37 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *buf = 136446466;
            v84 = "nw_path_create_evaluator_for_client_id";
            v85 = 1024;
            LODWORD(v86[0]) = v7;
            _os_log_impl(&dword_181A37000, v19, v37, "%{public}s NECP_CLIENT_ACTION_CLAIM %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }
      }

      goto LABEL_94;
    }

    *(v4 + 5) = v87;
    bzero(buf, 0x400uLL);
    v14 = necp_client_action();
    if (v14 >= 1)
    {
      v15 = _nw_parameters_create();
      v16 = v15;
      if (v15)
      {
        obj = 0;
        v78 = 0;
        v76 = 0;
        v75 = 0;
        v74 = 0;
        v73 = 0;
        if (nw_path_parse_necp_parameters(v15, &v78, &obj, &v76, 0, &v75, &v74, &v73 + 1, &v73, buf, v14))
        {
          _nw_parameters_set_context(v16, v3);
          objc_storeStrong(v4 + 3, obj);
          objc_storeStrong(v4 + 4, v76);
          objc_storeStrong(v4 + 2, v78);
          objc_storeStrong(v4 + 1, v16);
          v17 = *(v4 + 107) & 0xF9 | (2 * v75);
          *(v4 + 52) = v74;
          *(v4 + 106) = HIBYTE(v73);
          *(v4 + 107) = v17 | (4 * v73);
          if (nw_path_evaluator_evaluate(v4, 0))
          {
            v18 = v4;
LABEL_111:

LABEL_112:
            goto LABEL_97;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v48 = gLogObj;
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
          {
            *type = 136446210;
            v80 = "nw_path_create_evaluator_for_client_id";
            _os_log_impl(&dword_181A37000, v48, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", type, 0xCu);
          }

LABEL_110:
          v18 = 0;
          goto LABEL_111;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v38 = gLogObj;
        *type = 136446210;
        v80 = "nw_path_create_evaluator_for_client_id";
        v39 = _os_log_send_and_compose_impl();

        v72 = OS_LOG_TYPE_ERROR;
        v71 = 0;
        if (__nwlog_fault(v39, &v72, &v71))
        {
          if (v72 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v40 = gLogObj;
            v41 = v72;
            if (os_log_type_enabled(v40, v72))
            {
              *type = 136446210;
              v80 = "nw_path_create_evaluator_for_client_id";
              _os_log_impl(&dword_181A37000, v40, v41, "%{public}s nw_path_parse_necp_parameters failed", type, 0xCu);
            }
          }

          else if (v71 == 1)
          {
            v49 = __nw_create_backtrace_string();
            v40 = __nwlog_obj();
            v50 = v72;
            v51 = os_log_type_enabled(v40, v72);
            if (v49)
            {
              if (v51)
              {
                *type = 136446466;
                v80 = "nw_path_create_evaluator_for_client_id";
                v81 = 2082;
                v82[0] = v49;
                _os_log_impl(&dword_181A37000, v40, v50, "%{public}s nw_path_parse_necp_parameters failed, dumping backtrace:%{public}s", type, 0x16u);
              }

              free(v49);
              goto LABEL_108;
            }

            if (v51)
            {
              *type = 136446210;
              v80 = "nw_path_create_evaluator_for_client_id";
              _os_log_impl(&dword_181A37000, v40, v50, "%{public}s nw_path_parse_necp_parameters failed, no backtrace", type, 0xCu);
            }
          }

          else
          {
            v40 = __nwlog_obj();
            v55 = v72;
            if (os_log_type_enabled(v40, v72))
            {
              *type = 136446210;
              v80 = "nw_path_create_evaluator_for_client_id";
              _os_log_impl(&dword_181A37000, v40, v55, "%{public}s nw_path_parse_necp_parameters failed, backtrace limit exceeded", type, 0xCu);
            }
          }
        }

LABEL_108:
        if (v39)
        {
          free(v39);
        }

        goto LABEL_110;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v33 = gLogObj;
      *type = 136446210;
      v80 = "nw_path_create_evaluator_for_client_id";
      v34 = _os_log_send_and_compose_impl();

      LOBYTE(v78) = 16;
      LOBYTE(obj) = 0;
      if (__nwlog_fault(v34, &v78, &obj))
      {
        if (v78 == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v35 = gLogObj;
          v36 = v78;
          if (os_log_type_enabled(v35, v78))
          {
            *type = 136446210;
            v80 = "nw_path_create_evaluator_for_client_id";
            _os_log_impl(&dword_181A37000, v35, v36, "%{public}s nw_parameters_create failed", type, 0xCu);
          }
        }

        else if (obj == 1)
        {
          v45 = __nw_create_backtrace_string();
          v35 = __nwlog_obj();
          v46 = v78;
          v47 = os_log_type_enabled(v35, v78);
          if (v45)
          {
            if (v47)
            {
              *type = 136446466;
              v80 = "nw_path_create_evaluator_for_client_id";
              v81 = 2082;
              v82[0] = v45;
              _os_log_impl(&dword_181A37000, v35, v46, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", type, 0x16u);
            }

            free(v45);
            goto LABEL_102;
          }

          if (v47)
          {
            *type = 136446210;
            v80 = "nw_path_create_evaluator_for_client_id";
            _os_log_impl(&dword_181A37000, v35, v46, "%{public}s nw_parameters_create failed, no backtrace", type, 0xCu);
          }
        }

        else
        {
          v35 = __nwlog_obj();
          v54 = v78;
          if (os_log_type_enabled(v35, v78))
          {
            *type = 136446210;
            v80 = "nw_path_create_evaluator_for_client_id";
            _os_log_impl(&dword_181A37000, v35, v54, "%{public}s nw_parameters_create failed, backtrace limit exceeded", type, 0xCu);
          }
        }
      }

LABEL_102:
      if (v34)
      {
        free(v34);
      }

      v18 = 0;
      goto LABEL_112;
    }

    v29 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v30 = gLogObj;
    *type = 136446466;
    v80 = "nw_path_create_evaluator_for_client_id";
    v81 = 1024;
    LODWORD(v82[0]) = v29;
    v11 = _os_log_send_and_compose_impl();

    LOBYTE(v78) = 16;
    LOBYTE(obj) = 0;
    if (__nwlog_fault(v11, &v78, &obj))
    {
      if (v78 == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v31 = gLogObj;
        v32 = v78;
        if (os_log_type_enabled(v31, v78))
        {
          *type = 136446466;
          v80 = "nw_path_create_evaluator_for_client_id";
          v81 = 1024;
          LODWORD(v82[0]) = v29;
          _os_log_impl(&dword_181A37000, v31, v32, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS %{darwin.errno}d", type, 0x12u);
        }
      }

      else if (obj == 1)
      {
        v42 = __nw_create_backtrace_string();
        v31 = __nwlog_obj();
        v43 = v78;
        v44 = os_log_type_enabled(v31, v78);
        if (v42)
        {
          if (v44)
          {
            *type = 136446722;
            v80 = "nw_path_create_evaluator_for_client_id";
            v81 = 1024;
            LODWORD(v82[0]) = v29;
            WORD2(v82[0]) = 2082;
            *(v82 + 6) = v42;
            _os_log_impl(&dword_181A37000, v31, v43, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS %{darwin.errno}d, dumping backtrace:%{public}s", type, 0x1Cu);
          }

          free(v42);
          if (!v11)
          {
            goto LABEL_96;
          }

          goto LABEL_95;
        }

        if (v44)
        {
          *type = 136446466;
          v80 = "nw_path_create_evaluator_for_client_id";
          v81 = 1024;
          LODWORD(v82[0]) = v29;
          _os_log_impl(&dword_181A37000, v31, v43, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS %{darwin.errno}d, no backtrace", type, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v31 = gLogObj;
        v52 = v78;
        if (os_log_type_enabled(v31, v78))
        {
          *type = 136446466;
          v80 = "nw_path_create_evaluator_for_client_id";
          v81 = 1024;
          LODWORD(v82[0]) = v29;
          _os_log_impl(&dword_181A37000, v31, v52, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS %{darwin.errno}d, backtrace limit exceeded", type, 0x12u);
        }
      }
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    *buf = 136446210;
    v84 = "nw_path_create_evaluator_for_client_id";
    v11 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v87) = 0;
    if (__nwlog_fault(v11, type, &v87))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *buf = 136446210;
          v84 = "nw_path_create_evaluator_for_client_id";
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
        }
      }

      else if (v87 == 1)
      {
        v21 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v22 = type[0];
        v23 = os_log_type_enabled(v12, type[0]);
        if (v21)
        {
          if (v23)
          {
            *buf = 136446466;
            v84 = "nw_path_create_evaluator_for_client_id";
            v85 = 2082;
            v86[0] = v21;
            _os_log_impl(&dword_181A37000, v12, v22, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v21);
          if (!v11)
          {
            goto LABEL_96;
          }

          goto LABEL_95;
        }

        if (v23)
        {
          *buf = 136446210;
          v84 = "nw_path_create_evaluator_for_client_id";
          _os_log_impl(&dword_181A37000, v12, v22, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v28 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *buf = 136446210;
          v84 = "nw_path_create_evaluator_for_client_id";
          _os_log_impl(&dword_181A37000, v12, v28, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
  }

LABEL_94:
  if (v11)
  {
LABEL_95:
    free(v11);
  }

LABEL_96:
  v18 = 0;
LABEL_97:

LABEL_98:
  return v18;
}

void nw_path_libinfo_path_check(uint64_t a1, const char *a2)
{
  v38 = *MEMORY[0x1E69E9840];
  pthread_once(&nw_settings_setup_atfork::pOnce, nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec != 1 || (sNWParentAllowedDispatch & 1) == 0)
  {
    if (sNWDispatchAllowedNow)
    {
      v4 = 1;
      if (!a1)
      {
        return;
      }
    }

    else if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0 || (getpid(), sandbox_check() == 1))
    {
      v4 = 1;
      sNWDispatchAllowedNow = 1;
      if (!a1)
      {
        return;
      }
    }

    else
    {
      v4 = sNWDispatchAllowedNow;
      if (!a1)
      {
        return;
      }
    }

    if (v4)
    {
      if (a2)
      {
        v5 = a2;
      }

      else
      {
        v5 = "0";
      }

      host = _nw_endpoint_create_host(a1, v5);
      if (host)
      {
        v7 = &__block_literal_global_2;

        legacy_tcp_socket = _nw_parameters_create_legacy_tcp_socket(0);
        evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(host, legacy_tcp_socket);
        v10 = evaluator_for_endpoint;
        if (evaluator_for_endpoint)
        {
          v11 = nw_parameters_copy_context(*(evaluator_for_endpoint + 1));
          nw_path_watch_necp_changes(v11);
          os_unfair_lock_lock(v10 + 24);
          if ((*(v10 + 107) & 0x40) != 0 && (!v11 || v11[33] != 4))
          {
            if (__nwlog_path_log::onceToken != -1)
            {
              dispatch_once(&__nwlog_path_log::onceToken, &__block_literal_global_52);
            }

            v12 = gpathLogObj;
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              v13 = *(v10 + 2);
              v14 = v13;
              if (v13)
              {
                logging_description = _nw_endpoint_get_logging_description(v13);
              }

              else
              {
                logging_description = "<NULL>";
              }

              v16 = *(v10 + 1);
              v17 = *(v10 + 6);
              *buf = 136447490;
              v29 = "nw_path_libinfo_path_check";
              v30 = 1042;
              *v31 = 16;
              *&v31[4] = 2098;
              *&v31[6] = v10 + 80;
              v32 = 2082;
              v33 = logging_description;
              v34 = 2112;
              v35 = v16;
              v36 = 2112;
              v37 = v17;
              _os_log_impl(&dword_181A37000, v12, OS_LOG_TYPE_DEFAULT, "%{public}s [%{public,uuid_t}.16P %{public}s %@]\n\tlibinfo check path: %@", buf, 0x3Au);
            }
          }

          os_unfair_lock_unlock(v10 + 24);
        }

LABEL_31:
        return;
      }

      v18 = __nwlog_obj();
      *buf = 136446210;
      v29 = "nw_path_libinfo_path_check";
      v19 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v26 = 0;
      if (__nwlog_fault(v19, &type, &v26))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v20 = __nwlog_obj();
          v21 = type;
          if (os_log_type_enabled(v20, type))
          {
            *buf = 136446210;
            v29 = "nw_path_libinfo_path_check";
            _os_log_impl(&dword_181A37000, v20, v21, "%{public}s called with null endpoint", buf, 0xCu);
          }
        }

        else if (v26 == 1)
        {
          backtrace_string = __nw_create_backtrace_string();
          v20 = __nwlog_obj();
          v23 = type;
          v24 = os_log_type_enabled(v20, type);
          if (backtrace_string)
          {
            if (v24)
            {
              *buf = 136446466;
              v29 = "nw_path_libinfo_path_check";
              v30 = 2082;
              *v31 = backtrace_string;
              _os_log_impl(&dword_181A37000, v20, v23, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_49;
          }

          if (v24)
          {
            *buf = 136446210;
            v29 = "nw_path_libinfo_path_check";
            _os_log_impl(&dword_181A37000, v20, v23, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          v20 = __nwlog_obj();
          v25 = type;
          if (os_log_type_enabled(v20, type))
          {
            *buf = 136446210;
            v29 = "nw_path_libinfo_path_check";
            _os_log_impl(&dword_181A37000, v20, v25, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }

LABEL_49:
      if (v19)
      {
        free(v19);
      }

      goto LABEL_31;
    }
  }
}

uint64_t ___ZL30nw_path_necp_check_for_updatesPU24objcproto13OS_nw_context8NSObjectPA16_hj_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  v5 = v4;
  if (v4)
  {
    v6 = *(a1 + 40);
    if (*(v4 + 10) == *v6 && *(v4 + 11) == v6[1])
    {
      nw_path_necp_update_evaluator(v4, *(a1 + 48), *(a1 + 56), *(*(*(a1 + 32) + 8) + 24));
      *(*(*(a1 + 32) + 8) + 24) = 0;
    }
  }

  return 1;
}

xpc_object_t nw_path_copy_all_client_ids()
{
  v26 = *MEMORY[0x1E69E9840];
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
  {
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }

  v0 = nw_context_copy_implicit_context::implicit_context;
  v1 = nw_path_shared_necp_observer_fd(v0);

  if (v1 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    *buf = 136446210;
    v23 = "nw_path_copy_all_client_ids";
    v4 = _os_log_send_and_compose_impl();

    v20[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v4, v20, &type) & 1) == 0)
    {
      goto LABEL_40;
    }

    if (v20[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = v20[0];
      if (os_log_type_enabled(v8, v20[0]))
      {
        *buf = 136446210;
        v23 = "nw_path_copy_all_client_ids";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s nw_path_shared_necp_observer_fd failed", buf, 0xCu);
      }
    }

    else if (type == OS_LOG_TYPE_INFO)
    {
      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v13 = v20[0];
      v14 = os_log_type_enabled(v8, v20[0]);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v23 = "nw_path_copy_all_client_ids";
          v24 = 2082;
          *v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v13, "%{public}s nw_path_shared_necp_observer_fd failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        goto LABEL_26;
      }

      if (v14)
      {
        *buf = 136446210;
        v23 = "nw_path_copy_all_client_ids";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s nw_path_shared_necp_observer_fd failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v16 = v20[0];
      if (os_log_type_enabled(v8, v20[0]))
      {
        *buf = 136446210;
        v23 = "nw_path_copy_all_client_ids";
        _os_log_impl(&dword_181A37000, v8, v16, "%{public}s nw_path_shared_necp_observer_fd failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_40:
    if (!v4)
    {
      return 0;
    }

LABEL_41:
    free(v4);
    return 0;
  }

  *v20 = 0;
  if (necp_client_action())
  {
    v2 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = gLogObj;
    *buf = 136446466;
    v23 = "nw_path_copy_all_client_ids";
    v24 = 1024;
    *v25 = v2;
    v4 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v4, &type, &v19))
    {
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446466;
        v23 = "nw_path_copy_all_client_ids";
        v24 = 1024;
        *v25 = v2;
        _os_log_impl(&dword_181A37000, v5, v6, "%{public}s NECP_CLIENT_ACTION_COPY_LIST %{darwin.errno}d", buf, 0x12u);
      }

LABEL_36:

      goto LABEL_40;
    }

    if (v19 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v15 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446466;
        v23 = "nw_path_copy_all_client_ids";
        v24 = 1024;
        *v25 = v2;
        _os_log_impl(&dword_181A37000, v5, v15, "%{public}s NECP_CLIENT_ACTION_COPY_LIST %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
      }

      goto LABEL_36;
    }

    backtrace_string = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    v11 = type;
    v12 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *buf = 136446466;
        v23 = "nw_path_copy_all_client_ids";
        v24 = 1024;
        *v25 = v2;
        _os_log_impl(&dword_181A37000, v5, v11, "%{public}s NECP_CLIENT_ACTION_COPY_LIST %{darwin.errno}d, no backtrace", buf, 0x12u);
      }

      goto LABEL_36;
    }

    if (v12)
    {
      *buf = 136446722;
      v23 = "nw_path_copy_all_client_ids";
      v24 = 1024;
      *v25 = v2;
      *&v25[4] = 2082;
      *&v25[6] = backtrace_string;
      _os_log_impl(&dword_181A37000, v5, v11, "%{public}s NECP_CLIENT_ACTION_COPY_LIST %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }

LABEL_26:
    free(backtrace_string);
    if (!v4)
    {
      return 0;
    }

    goto LABEL_41;
  }

  return xpc_array_create(0, 0);
}

NWConcrete_nw_path_observer *nw_path_create_observer(void *a1, void *a2)
{
  *&v58[13] = *MEMORY[0x1E69E9840];
  v4 = a1;
  v5 = a2;
  nw_allow_use_of_dispatch_internal();
  if (v5)
  {
    v6 = objc_alloc_init(NWConcrete_nw_path_observer);
    if (v6)
    {
      v7 = necp_open();
      if ((v7 & 0x80000000) == 0)
      {
        v8 = _Block_copy(v5);
        v9 = *(v6 + 2);
        *(v6 + 2) = v8;

        objc_storeStrong(v6 + 1, a1);
        v10 = nw_dictionary_create();
        v11 = *(v6 + 3);
        *(v6 + 3) = v10;

        v12 = nw_fd_wrapper_create(v7);
        v13 = *(v6 + 4);
        *(v6 + 4) = v12;

        v14 = *(v6 + 4);
        if (v14)
        {
          nw_fd_wrapper_guard(v14);
          if (nw_context_copy_implicit_context::onceToken[0] != -1)
          {
            dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
          }

          v15 = nw_context_copy_implicit_context::implicit_context;
          v51[0] = MEMORY[0x1E69E9820];
          v51[1] = 3221225472;
          v51[2] = __nw_path_create_observer_block_invoke;
          v51[3] = &unk_1E6A3D868;
          v16 = v6;
          v52 = v16;
          *(v16 + 5) = nw_queue_context_create_source(v15, v7, 1, 0, v51, 0);

          v18 = *(v16 + 5);
          if (v18)
          {
            nw_queue_activate_source(v18, v17);
            v19 = v16;
LABEL_65:

            goto LABEL_66;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = gLogObj;
          *buf = 136446210;
          v56 = "nw_path_create_observer";
          v34 = _os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v53 = 0;
          if (__nwlog_fault(v34, &type, &v53))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v35 = gLogObj;
              v36 = type;
              if (os_log_type_enabled(v35, type))
              {
                *buf = 136446210;
                v56 = "nw_path_create_observer";
                _os_log_impl(&dword_181A37000, v35, v36, "%{public}s nw_queue_context_create_source failed", buf, 0xCu);
              }
            }

            else if (v53 == 1)
            {
              backtrace_string = __nw_create_backtrace_string();
              v35 = __nwlog_obj();
              v39 = type;
              v40 = os_log_type_enabled(v35, type);
              if (backtrace_string)
              {
                if (v40)
                {
                  *buf = 136446466;
                  v56 = "nw_path_create_observer";
                  v57 = 2082;
                  *v58 = backtrace_string;
                  _os_log_impl(&dword_181A37000, v35, v39, "%{public}s nw_queue_context_create_source failed, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(backtrace_string);
                if (!v34)
                {
                  goto LABEL_64;
                }

                goto LABEL_63;
              }

              if (v40)
              {
                *buf = 136446210;
                v56 = "nw_path_create_observer";
                _os_log_impl(&dword_181A37000, v35, v39, "%{public}s nw_queue_context_create_source failed, no backtrace", buf, 0xCu);
              }
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v35 = gLogObj;
              v41 = type;
              if (os_log_type_enabled(v35, type))
              {
                *buf = 136446210;
                v56 = "nw_path_create_observer";
                _os_log_impl(&dword_181A37000, v35, v41, "%{public}s nw_queue_context_create_source failed, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }

          if (!v34)
          {
LABEL_64:
            v19 = 0;
            goto LABEL_65;
          }

LABEL_63:
          free(v34);
          goto LABEL_64;
        }

LABEL_58:
        v19 = 0;
LABEL_66:

        goto LABEL_67;
      }

      v24 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v25 = gLogObj;
      *buf = 136446466;
      v56 = "nw_path_create_observer";
      v57 = 1024;
      *v58 = v24;
      v21 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v53 = 0;
      if (!__nwlog_fault(v21, &type, &v53))
      {
        goto LABEL_56;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v26 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446466;
          v56 = "nw_path_create_observer";
          v57 = 1024;
          *v58 = v24;
          _os_log_impl(&dword_181A37000, v22, v26, "%{public}s necp_open(NECP_OPEN_FLAG_OBSERVER | NECP_OPEN_FLAG_PUSH_OBSERVER) %{darwin.errno}d", buf, 0x12u);
        }

LABEL_55:

LABEL_56:
        if (!v21)
        {
          goto LABEL_58;
        }

LABEL_57:
        free(v21);
        goto LABEL_58;
      }

      if (v53 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v37 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446466;
          v56 = "nw_path_create_observer";
          v57 = 1024;
          *v58 = v24;
          _os_log_impl(&dword_181A37000, v22, v37, "%{public}s necp_open(NECP_OPEN_FLAG_OBSERVER | NECP_OPEN_FLAG_PUSH_OBSERVER) %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }

        goto LABEL_55;
      }

      v27 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      v30 = type;
      v31 = os_log_type_enabled(v22, type);
      if (!v27)
      {
        if (v31)
        {
          *buf = 136446466;
          v56 = "nw_path_create_observer";
          v57 = 1024;
          *v58 = v24;
          _os_log_impl(&dword_181A37000, v22, v30, "%{public}s necp_open(NECP_OPEN_FLAG_OBSERVER | NECP_OPEN_FLAG_PUSH_OBSERVER) %{darwin.errno}d, no backtrace", buf, 0x12u);
        }

        goto LABEL_55;
      }

      if (v31)
      {
        *buf = 136446722;
        v56 = "nw_path_create_observer";
        v57 = 1024;
        *v58 = v24;
        v58[2] = 2082;
        *&v58[3] = v27;
        _os_log_impl(&dword_181A37000, v22, v30, "%{public}s necp_open(NECP_OPEN_FLAG_OBSERVER | NECP_OPEN_FLAG_PUSH_OBSERVER) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      *buf = 136446210;
      v56 = "nw_path_create_observer";
      v21 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v53 = 0;
      if (!__nwlog_fault(v21, &type, &v53))
      {
        goto LABEL_56;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v56 = "nw_path_create_observer";
          _os_log_impl(&dword_181A37000, v22, v23, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_observer) alloc] init] failed", buf, 0xCu);
        }

        goto LABEL_55;
      }

      if (v53 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v32 = type;
        if (os_log_type_enabled(v22, type))
        {
          *buf = 136446210;
          v56 = "nw_path_create_observer";
          _os_log_impl(&dword_181A37000, v22, v32, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_observer) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_55;
      }

      v27 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      v28 = type;
      v29 = os_log_type_enabled(v22, type);
      if (!v27)
      {
        if (v29)
        {
          *buf = 136446210;
          v56 = "nw_path_create_observer";
          _os_log_impl(&dword_181A37000, v22, v28, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_observer) alloc] init] failed, no backtrace", buf, 0xCu);
        }

        goto LABEL_55;
      }

      if (v29)
      {
        *buf = 136446466;
        v56 = "nw_path_create_observer";
        v57 = 2082;
        *v58 = v27;
        _os_log_impl(&dword_181A37000, v22, v28, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_observer) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(v27);
    if (!v21)
    {
      goto LABEL_58;
    }

    goto LABEL_57;
  }

  v43 = __nwlog_obj();
  *buf = 136446210;
  v56 = "nw_path_create_observer";
  v44 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v53 = 0;
  if (__nwlog_fault(v44, &type, &v53))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v45 = __nwlog_obj();
      v46 = type;
      if (os_log_type_enabled(v45, type))
      {
        *buf = 136446210;
        v56 = "nw_path_create_observer";
        _os_log_impl(&dword_181A37000, v45, v46, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v53 == 1)
    {
      v47 = __nw_create_backtrace_string();
      v45 = __nwlog_obj();
      v48 = type;
      v49 = os_log_type_enabled(v45, type);
      if (v47)
      {
        if (v49)
        {
          *buf = 136446466;
          v56 = "nw_path_create_observer";
          v57 = 2082;
          *v58 = v47;
          _os_log_impl(&dword_181A37000, v45, v48, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v47);
        goto LABEL_84;
      }

      if (v49)
      {
        *buf = 136446210;
        v56 = "nw_path_create_observer";
        _os_log_impl(&dword_181A37000, v45, v48, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v45 = __nwlog_obj();
      v50 = type;
      if (os_log_type_enabled(v45, type))
      {
        *buf = 136446210;
        v56 = "nw_path_create_observer";
        _os_log_impl(&dword_181A37000, v45, v50, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_84:
  if (v44)
  {
    free(v44);
  }

  v19 = 0;
LABEL_67:

  return v19;
}

void __nw_path_create_observer_block_invoke(uint64_t a1)
{
  v47 = *MEMORY[0x1E69E9840];
  v1 = *(a1 + 32);
  v2 = v1;
  if (!v1)
  {
    v14 = __nwlog_obj();
    *block = 136446210;
    *&block[4] = "nw_path_observer_update";
    v15 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v33) = 0;
    if (__nwlog_fault(v15, type, &v33))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v16 = __nwlog_obj();
        v17 = type[0];
        if (os_log_type_enabled(v16, type[0]))
        {
          *block = 136446210;
          *&block[4] = "nw_path_observer_update";
          _os_log_impl(&dword_181A37000, v16, v17, "%{public}s called with null observer", block, 0xCu);
        }
      }

      else if (v33 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v16 = __nwlog_obj();
        v19 = type[0];
        v20 = os_log_type_enabled(v16, type[0]);
        if (backtrace_string)
        {
          if (v20)
          {
            *block = 136446466;
            *&block[4] = "nw_path_observer_update";
            *&block[12] = 2082;
            *&block[14] = backtrace_string;
            _os_log_impl(&dword_181A37000, v16, v19, "%{public}s called with null observer, dumping backtrace:%{public}s", block, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_31;
        }

        if (v20)
        {
          *block = 136446210;
          *&block[4] = "nw_path_observer_update";
          _os_log_impl(&dword_181A37000, v16, v19, "%{public}s called with null observer, no backtrace", block, 0xCu);
        }
      }

      else
      {
        v16 = __nwlog_obj();
        v21 = type[0];
        if (os_log_type_enabled(v16, type[0]))
        {
          *block = 136446210;
          *&block[4] = "nw_path_observer_update";
          _os_log_impl(&dword_181A37000, v16, v21, "%{public}s called with null observer, backtrace limit exceeded", block, 0xCu);
        }
      }
    }

LABEL_31:
    if (v15)
    {
      free(v15);
    }

    goto LABEL_14;
  }

  v46 = 0uLL;
  v39[0] = 0;
  v39[1] = v39;
  v39[2] = 0x2020000000;
  v39[3] = &v46;
  v33 = 0;
  v34 = &v33;
  v35 = 0x3032000000;
  v36 = __Block_byref_object_copy__71486;
  v37 = __Block_byref_object_dispose__71487;
  v38 = 0;
  os_unfair_lock_lock(v1 + 12);
  v3 = *&v2[8]._os_unfair_lock_opaque;
  *type = MEMORY[0x1E69E9820];
  v27 = 3221225472;
  v28 = ___ZL23nw_path_observer_updateP27NWConcrete_nw_path_observer_block_invoke;
  v29 = &unk_1E6A39C48;
  v4 = v2;
  v30 = v4;
  v31 = &v33;
  v32 = v39;
  fd = nw_fd_wrapper_get_fd(v3, type);
  v6 = _Block_copy(*&v4[4]._os_unfair_lock_opaque);
  v7 = *&v4[2]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v2 + 12);
  if (v6)
  {
    v8 = fd;
  }

  else
  {
    v8 = 0;
  }

  if (v8 != 1)
  {
    goto LABEL_13;
  }

  if (!v7)
  {
    v12 = v4;
    os_unfair_lock_lock(v2 + 12);
    v13 = *&v4[4]._os_unfair_lock_opaque == 0;
    os_unfair_lock_unlock(v2 + 12);

    if (!v13)
    {
      v6[2](v6, &v46, v34[5]);
    }

    goto LABEL_13;
  }

  v22 = 0;
  v23 = &v22;
  v24 = 0x2020000000;
  v25 = 0;
  v9 = malloc_type_malloc(0x10uLL, 0xC605D6CDuLL);
  if (v9)
  {
LABEL_10:
    v23[3] = v9;
    *v9 = v46;
    *block = MEMORY[0x1E69E9820];
    *&block[8] = 3221225472;
    *&block[16] = ___ZL23nw_path_observer_updateP27NWConcrete_nw_path_observer_block_invoke_298;
    v41 = &unk_1E6A39C70;
    v42 = v4;
    v43 = v6;
    v44 = &v22;
    v45 = &v33;
    dispatch_async(v7, block);

    _Block_object_dispose(&v22, 8);
LABEL_13:

    _Block_object_dispose(&v33, 8);
    _Block_object_dispose(v39, 8);
LABEL_14:

    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v10 = gLogObj;
  os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  *block = 136446210;
  *&block[4] = "nw_path_observer_update";
  v11 = _os_log_send_and_compose_impl();

  if (!__nwlog_should_abort(v11))
  {
    free(v11);
    v9 = 0;
    goto LABEL_10;
  }

  __break(1u);
}

void sub_182945BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, id a30, char a31)
{
  _Block_object_dispose(&a25, 8);

  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__71486(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

uint64_t ___ZL23nw_path_observer_updateP27NWConcrete_nw_path_observer_block_invoke(void *a1)
{
  v99 = *MEMORY[0x1E69E9840];
  memset(uu, 0, sizeof(uu));
  bzero(&v96, 0x604uLL);
  v2 = necp_client_action();
  v3 = v2;
  if (v2 < 4)
  {
    if (v2 < 0)
    {
      v13 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      *out = 136446466;
      *&out[4] = "nw_path_observer_update_block_invoke";
      *&out[12] = 1024;
      *&out[14] = v13;
      v10 = _os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v90[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v10, type, v90))
      {
        goto LABEL_88;
      }

      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v15 = type[0];
        if (os_log_type_enabled(v11, type[0]))
        {
          *out = 136446466;
          *&out[4] = "nw_path_observer_update_block_invoke";
          *&out[12] = 1024;
          *&out[14] = v13;
          _os_log_impl(&dword_181A37000, v11, v15, "%{public}s necp_client_action(NECP_CLIENT_ACTION_COPY_CLIENT_UPDATE) %{darwin.errno}d", out, 0x12u);
        }

        goto LABEL_87;
      }

      if (v90[0] != OS_LOG_TYPE_INFO)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v35 = type[0];
        if (os_log_type_enabled(v11, type[0]))
        {
          *out = 136446466;
          *&out[4] = "nw_path_observer_update_block_invoke";
          *&out[12] = 1024;
          *&out[14] = v13;
          _os_log_impl(&dword_181A37000, v11, v35, "%{public}s necp_client_action(NECP_CLIENT_ACTION_COPY_CLIENT_UPDATE) %{darwin.errno}d, backtrace limit exceeded", out, 0x12u);
        }

        goto LABEL_87;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v28 = type[0];
      v29 = os_log_type_enabled(v11, type[0]);
      if (!backtrace_string)
      {
        if (v29)
        {
          *out = 136446466;
          *&out[4] = "nw_path_observer_update_block_invoke";
          *&out[12] = 1024;
          *&out[14] = v13;
          _os_log_impl(&dword_181A37000, v11, v28, "%{public}s necp_client_action(NECP_CLIENT_ACTION_COPY_CLIENT_UPDATE) %{darwin.errno}d, no backtrace", out, 0x12u);
        }

        goto LABEL_87;
      }

      if (v29)
      {
        *out = 136446722;
        *&out[4] = "nw_path_observer_update_block_invoke";
        *&out[12] = 1024;
        *&out[14] = v13;
        *&out[18] = 2082;
        *&out[20] = backtrace_string;
        _os_log_impl(&dword_181A37000, v11, v28, "%{public}s necp_client_action(NECP_CLIENT_ACTION_COPY_CLIENT_UPDATE) %{darwin.errno}d, dumping backtrace:%{public}s", out, 0x1Cu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      *out = 136446466;
      *&out[4] = "nw_path_observer_update_block_invoke";
      *&out[12] = 1024;
      *&out[14] = v3;
      v10 = _os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v90[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v10, type, v90))
      {
        goto LABEL_88;
      }

      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v12 = type[0];
        if (os_log_type_enabled(v11, type[0]))
        {
          *out = 136446466;
          *&out[4] = "nw_path_observer_update_block_invoke";
          *&out[12] = 1024;
          *&out[14] = v3;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s Path observer result cannot hold update header (%d)", out, 0x12u);
        }

LABEL_87:

LABEL_88:
        if (!v10)
        {
          return 0;
        }

LABEL_89:
        free(v10);
        return 0;
      }

      if (v90[0] != OS_LOG_TYPE_INFO)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v30 = type[0];
        if (os_log_type_enabled(v11, type[0]))
        {
          *out = 136446466;
          *&out[4] = "nw_path_observer_update_block_invoke";
          *&out[12] = 1024;
          *&out[14] = v3;
          _os_log_impl(&dword_181A37000, v11, v30, "%{public}s Path observer result cannot hold update header (%d), backtrace limit exceeded", out, 0x12u);
        }

        goto LABEL_87;
      }

      backtrace_string = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v17 = type[0];
      v18 = os_log_type_enabled(v11, type[0]);
      if (!backtrace_string)
      {
        if (v18)
        {
          *out = 136446466;
          *&out[4] = "nw_path_observer_update_block_invoke";
          *&out[12] = 1024;
          *&out[14] = v3;
          _os_log_impl(&dword_181A37000, v11, v17, "%{public}s Path observer result cannot hold update header (%d), no backtrace", out, 0x12u);
        }

        goto LABEL_87;
      }

      if (v18)
      {
        *out = 136446722;
        *&out[4] = "nw_path_observer_update_block_invoke";
        *&out[12] = 1024;
        *&out[14] = v3;
        *&out[18] = 2082;
        *&out[20] = backtrace_string;
        _os_log_impl(&dword_181A37000, v11, v17, "%{public}s Path observer result cannot hold update header (%d), dumping backtrace:%{public}s", out, 0x1Cu);
      }
    }

    free(backtrace_string);
    if (!v10)
    {
      return 0;
    }

    goto LABEL_89;
  }

  memset(out, 0, sizeof(out));
  uuid_unparse(uu, out);
  if (v96 != 3)
  {
    if (v96 != 2)
    {
      if (v96 == 1)
      {
        v89 = 0;
        *v90 = 0;
        v87 = 0;
        v88 = 0;
        v4 = _nw_parameters_create();
        v5 = v4;
        if (v4)
        {
          v86 = 0;
          *v85 = 0;
          v84 = 0;
          if (nw_path_parse_necp_parameters(v4, v90, &v89, &v88, &v87, &v86, v85, &v84 + 1, &v84, v97, v3 - 4))
          {
            if (v88)
            {
              v6 = v88;
              v7 = _nw_path_create(0, v5);
              v8 = v7;
              if (v7)
              {
                _nw_path_set_browse_descriptor(v7, v6);
              }
            }

            else
            {
              v8 = _nw_path_create(*v90, v5);
            }

            if (v8)
            {
              _nw_path_set_group_descriptor(v8, v89);
              _nw_path_set_advertise_descriptor(v8, v87);
              _nw_path_set_is_listener(v8, v86);
              _nw_path_set_custom_ethertype(v8, *v85);
              _nw_path_set_custom_ip_protocol(v8, SHIBYTE(v84));
              _nw_path_set_is_interpose(v8, v84);
              _nw_path_set_client_id(v8, uu);
              nw_dictionary_set_value(*(a1[4] + 24), out, v8);
LABEL_153:

LABEL_154:
              return 0;
            }

            v64 = __nwlog_obj();
            *type = 136446210;
            v92 = "nw_path_observer_update_block_invoke";
            v65 = _os_log_send_and_compose_impl();

            v83 = OS_LOG_TYPE_ERROR;
            v82 = 0;
            if (__nwlog_fault(v65, &v83, &v82))
            {
              if (v83 == OS_LOG_TYPE_FAULT)
              {
                v66 = __nwlog_obj();
                v67 = v83;
                if (os_log_type_enabled(v66, v83))
                {
                  *type = 136446210;
                  v92 = "nw_path_observer_update_block_invoke";
                  _os_log_impl(&dword_181A37000, v66, v67, "%{public}s nw_path_create failed", type, 0xCu);
                }
              }

              else if (v82 == 1)
              {
                v75 = __nw_create_backtrace_string();
                v66 = __nwlog_obj();
                v76 = v83;
                v77 = os_log_type_enabled(v66, v83);
                if (v75)
                {
                  if (v77)
                  {
                    *type = 136446466;
                    v92 = "nw_path_observer_update_block_invoke";
                    v93 = 2082;
                    v94 = v75;
                    _os_log_impl(&dword_181A37000, v66, v76, "%{public}s nw_path_create failed, dumping backtrace:%{public}s", type, 0x16u);
                  }

                  free(v75);
                  goto LABEL_151;
                }

                if (v77)
                {
                  *type = 136446210;
                  v92 = "nw_path_observer_update_block_invoke";
                  _os_log_impl(&dword_181A37000, v66, v76, "%{public}s nw_path_create failed, no backtrace", type, 0xCu);
                }
              }

              else
              {
                v66 = __nwlog_obj();
                v80 = v83;
                if (os_log_type_enabled(v66, v83))
                {
                  *type = 136446210;
                  v92 = "nw_path_observer_update_block_invoke";
                  _os_log_impl(&dword_181A37000, v66, v80, "%{public}s nw_path_create failed, backtrace limit exceeded", type, 0xCu);
                }
              }
            }

LABEL_151:
            if (v65)
            {
              free(v65);
            }

            goto LABEL_153;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v36 = gLogObj;
          *type = 136446210;
          v92 = "nw_path_observer_update_block_invoke";
          v32 = _os_log_send_and_compose_impl();

          v83 = OS_LOG_TYPE_ERROR;
          v82 = 0;
          if (!__nwlog_fault(v32, &v83, &v82))
          {
LABEL_131:
            if (v32)
            {
              free(v32);
            }

            goto LABEL_154;
          }

          if (v83 == OS_LOG_TYPE_FAULT)
          {
            v37 = __nwlog_obj();
            v38 = v83;
            if (os_log_type_enabled(v37, v83))
            {
              *type = 136446210;
              v92 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_181A37000, v37, v38, "%{public}s nw_path_parse_necp_parameters failed", type, 0xCu);
            }

LABEL_130:

            goto LABEL_131;
          }

          if (v82 != 1)
          {
            v37 = __nwlog_obj();
            v74 = v83;
            if (os_log_type_enabled(v37, v83))
            {
              *type = 136446210;
              v92 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_181A37000, v37, v74, "%{public}s nw_path_parse_necp_parameters failed, backtrace limit exceeded", type, 0xCu);
            }

            goto LABEL_130;
          }

          v59 = __nw_create_backtrace_string();
          v37 = __nwlog_obj();
          v62 = v83;
          v63 = os_log_type_enabled(v37, v83);
          if (!v59)
          {
            if (v63)
            {
              *type = 136446210;
              v92 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_181A37000, v37, v62, "%{public}s nw_path_parse_necp_parameters failed, no backtrace", type, 0xCu);
            }

            goto LABEL_130;
          }

          if (v63)
          {
            *type = 136446466;
            v92 = "nw_path_observer_update_block_invoke";
            v93 = 2082;
            v94 = v59;
            _os_log_impl(&dword_181A37000, v37, v62, "%{public}s nw_path_parse_necp_parameters failed, dumping backtrace:%{public}s", type, 0x16u);
          }

LABEL_84:
          free(v59);
          goto LABEL_131;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v31 = gLogObj;
        *type = 136446210;
        v92 = "nw_path_observer_update_block_invoke";
        v32 = _os_log_send_and_compose_impl();

        v85[0] = OS_LOG_TYPE_ERROR;
        v86 = 0;
        if (!__nwlog_fault(v32, v85, &v86))
        {
          goto LABEL_131;
        }

        if (v85[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = gLogObj;
          v34 = v85[0];
          if (os_log_type_enabled(v33, v85[0]))
          {
            *type = 136446210;
            v92 = "nw_path_observer_update_block_invoke";
            _os_log_impl(&dword_181A37000, v33, v34, "%{public}s nw_parameters_create failed", type, 0xCu);
          }
        }

        else if (v86 == 1)
        {
          v59 = __nw_create_backtrace_string();
          v33 = __nwlog_obj();
          v60 = v85[0];
          v61 = os_log_type_enabled(v33, v85[0]);
          if (v59)
          {
            if (v61)
            {
              *type = 136446466;
              v92 = "nw_path_observer_update_block_invoke";
              v93 = 2082;
              v94 = v59;
              _os_log_impl(&dword_181A37000, v33, v60, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", type, 0x16u);
            }

            goto LABEL_84;
          }

          if (v61)
          {
            *type = 136446210;
            v92 = "nw_path_observer_update_block_invoke";
            _os_log_impl(&dword_181A37000, v33, v60, "%{public}s nw_parameters_create failed, no backtrace", type, 0xCu);
          }
        }

        else
        {
          v33 = __nwlog_obj();
          v73 = v85[0];
          if (os_log_type_enabled(v33, v85[0]))
          {
            *type = 136446210;
            v92 = "nw_path_observer_update_block_invoke";
            _os_log_impl(&dword_181A37000, v33, v73, "%{public}s nw_parameters_create failed, backtrace limit exceeded", type, 0xCu);
          }
        }

        goto LABEL_131;
      }

      return 0;
    }

    v19 = nw_dictionary_copy_value(*(a1[4] + 24), out);
    v20 = v19;
    if (v19)
    {
      v21 = _nw_path_copy_endpoint(v19);
      v22 = _nw_path_get_browse_descriptor(v20);
      v23 = _nw_path_copy_parameters(v20);
      if (v22)
      {
        v24 = v22;
        v25 = _nw_path_create(0, v23);
        v26 = v25;
        if (v25)
        {
          _nw_path_set_browse_descriptor(v25, v24);
        }
      }

      else
      {
        v26 = _nw_path_create(v21, v23);
      }

      v39 = *(a1[5] + 8);
      v40 = *(v39 + 40);
      *(v39 + 40) = v26;

      v41 = *(*(a1[5] + 8) + 40);
      if (v41)
      {
        v42 = _nw_path_get_group_descriptor(v20);
        _nw_path_set_group_descriptor(v41, v42);

        v43 = *(*(a1[5] + 8) + 40);
        v44 = _nw_path_get_advertise_descriptor(v20);
        _nw_path_set_advertise_descriptor(v43, v44);

        v45 = *(*(a1[5] + 8) + 40);
        v46 = _nw_path_is_listener(v20);
        _nw_path_set_is_listener(v45, v46);
        v47 = *(*(a1[5] + 8) + 40);
        custom_ethertype = _nw_path_get_custom_ethertype(v20);
        _nw_path_set_custom_ethertype(v47, custom_ethertype);
        v49 = *(*(a1[5] + 8) + 40);
        custom_ip_protocol = _nw_path_get_custom_ip_protocol(v20);
        _nw_path_set_custom_ip_protocol(v49, custom_ip_protocol);
        v51 = *(*(a1[5] + 8) + 40);
        v52 = _nw_path_is_interpose(v20);
        _nw_path_set_is_interpose(v51, v52);
        _nw_path_set_client_id(*(*(a1[5] + 8) + 40), uu);
        if (nw_path_parse_necp_result(*(*(a1[5] + 8) + 40), v97, (v3 - 4)))
        {
          nw_path_snapshot_path(*(*(a1[5] + 8) + 40));
          **(*(a1[6] + 8) + 24) = *uu;
          v27 = 1;
LABEL_146:

          goto LABEL_147;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v57 = gLogObj;
        *type = 136446210;
        v92 = "nw_path_observer_update_block_invoke";
        v54 = _os_log_send_and_compose_impl();

        v90[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v89) = 0;
        if (__nwlog_fault(v54, v90, &v89))
        {
          if (v90[0] == OS_LOG_TYPE_FAULT)
          {
            v55 = __nwlog_obj();
            v58 = v90[0];
            if (os_log_type_enabled(v55, v90[0]))
            {
              *type = 136446210;
              v92 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_181A37000, v55, v58, "%{public}s nw_path_parse_necp_result failed", type, 0xCu);
            }

LABEL_142:

            goto LABEL_143;
          }

          if (v89 != 1)
          {
            v55 = __nwlog_obj();
            v79 = v90[0];
            if (os_log_type_enabled(v55, v90[0]))
            {
              *type = 136446210;
              v92 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_181A37000, v55, v79, "%{public}s nw_path_parse_necp_result failed, backtrace limit exceeded", type, 0xCu);
            }

            goto LABEL_142;
          }

          v68 = __nw_create_backtrace_string();
          v55 = __nwlog_obj();
          v71 = v90[0];
          v72 = os_log_type_enabled(v55, v90[0]);
          if (!v68)
          {
            if (v72)
            {
              *type = 136446210;
              v92 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_181A37000, v55, v71, "%{public}s nw_path_parse_necp_result failed, no backtrace", type, 0xCu);
            }

            goto LABEL_142;
          }

          if (v72)
          {
            *type = 136446466;
            v92 = "nw_path_observer_update_block_invoke";
            v93 = 2082;
            v94 = v68;
            _os_log_impl(&dword_181A37000, v55, v71, "%{public}s nw_path_parse_necp_result failed, dumping backtrace:%{public}s", type, 0x16u);
          }

          goto LABEL_107;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v53 = gLogObj;
        *type = 136446210;
        v92 = "nw_path_observer_update_block_invoke";
        v54 = _os_log_send_and_compose_impl();

        v90[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v89) = 0;
        if (__nwlog_fault(v54, v90, &v89))
        {
          if (v90[0] == OS_LOG_TYPE_FAULT)
          {
            v55 = __nwlog_obj();
            v56 = v90[0];
            if (os_log_type_enabled(v55, v90[0]))
            {
              *type = 136446210;
              v92 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_181A37000, v55, v56, "%{public}s nw_path_create failed", type, 0xCu);
            }

            goto LABEL_142;
          }

          if (v89 != 1)
          {
            v55 = __nwlog_obj();
            v78 = v90[0];
            if (os_log_type_enabled(v55, v90[0]))
            {
              *type = 136446210;
              v92 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_181A37000, v55, v78, "%{public}s nw_path_create failed, backtrace limit exceeded", type, 0xCu);
            }

            goto LABEL_142;
          }

          v68 = __nw_create_backtrace_string();
          v55 = __nwlog_obj();
          v69 = v90[0];
          v70 = os_log_type_enabled(v55, v90[0]);
          if (!v68)
          {
            if (v70)
            {
              *type = 136446210;
              v92 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_181A37000, v55, v69, "%{public}s nw_path_create failed, no backtrace", type, 0xCu);
            }

            goto LABEL_142;
          }

          if (v70)
          {
            *type = 136446466;
            v92 = "nw_path_observer_update_block_invoke";
            v93 = 2082;
            v94 = v68;
            _os_log_impl(&dword_181A37000, v55, v69, "%{public}s nw_path_create failed, dumping backtrace:%{public}s", type, 0x16u);
          }

LABEL_107:

          free(v68);
        }
      }

LABEL_143:
      if (v54)
      {
        free(v54);
      }

      v27 = 0;
      goto LABEL_146;
    }

    goto LABEL_34;
  }

  v20 = nw_dictionary_copy_value(*(a1[4] + 24), out);
  if (!v20)
  {
LABEL_34:
    v27 = 0;
    goto LABEL_147;
  }

  nw_dictionary_set_value(*(a1[4] + 24), out, 0);
  **(*(a1[6] + 8) + 24) = *uu;
  v27 = 1;
LABEL_147:

  return v27;
}

void ___ZL23nw_path_observer_updateP27NWConcrete_nw_path_observer_block_invoke_298(void *a1)
{
  v2 = a1[4];
  v3 = v2;
  os_unfair_lock_lock(v2 + 12);
  v4 = *&v3[4]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v2 + 12);

  if (v4)
  {
    (*(a1[5] + 16))();
  }

  v5 = *(*(a1[6] + 8) + 24);
  if (v5)
  {
    free(v5);
    *(*(a1[6] + 8) + 24) = 0;
  }
}

void nw_path_observer_cancel(void *a1)
{
  v22 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 12);
    v3 = *&v2[4]._os_unfair_lock_opaque;
    *&v2[4]._os_unfair_lock_opaque = 0;

    v4 = *&v2[2]._os_unfair_lock_opaque;
    *&v2[2]._os_unfair_lock_opaque = 0;

    nw_queue_cancel_source(*&v2[10]._os_unfair_lock_opaque, v5);
    v6 = *&v2[8]._os_unfair_lock_opaque;
    *&v2[8]._os_unfair_lock_opaque = 0;
    *&v2[10]._os_unfair_lock_opaque = 0;

    v7 = *&v2[6]._os_unfair_lock_opaque;
    *&v2[6]._os_unfair_lock_opaque = 0;

    os_unfair_lock_unlock(v2 + 12);
    goto LABEL_3;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  v19 = "nw_path_observer_cancel";
  v9 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v19 = "nw_path_observer_cancel";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null observer", buf, 0xCu);
      }
    }

    else if (v16 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v19 = "nw_path_observer_cancel";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null observer, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *buf = 136446210;
        v19 = "nw_path_observer_cancel";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null observer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v19 = "nw_path_observer_cancel";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null observer, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v9)
  {
    free(v9);
  }

LABEL_3:
}

void *nw_path_copy_all_local_paths(void *a1)
{
  v28 = *MEMORY[0x1E69E9840];
  v1 = a1;
  pthread_once(&nw_settings_setup_atfork::pOnce, nw_settings_setup_atfork_inner);
  globals_for_path = nw_context_get_globals_for_path(v1);
  os_unfair_lock_lock((globals_for_path + 116));
  v3 = *(globals_for_path + 32);
  if (v3)
  {
    v4 = nw_dictionary_copy(v3);
    os_unfair_lock_unlock((globals_for_path + 116));
    if (v4)
    {
      v5 = nw_dictionary_create();
      v6 = v5;
      if (v5)
      {
        v20[0] = MEMORY[0x1E69E9820];
        v20[1] = 3221225472;
        v20[2] = __nw_path_copy_all_local_paths_block_invoke;
        v20[3] = &unk_1E6A39A98;
        v7 = v5;
        v21 = v7;
        nw_dictionary_apply(v4, v20);
        v8 = v7;

LABEL_26:
        goto LABEL_27;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      *buf = 136446210;
      v25 = "nw_path_copy_all_local_paths";
      v10 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v22 = 0;
      if (__nwlog_fault(v10, &type, &v22))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v11 = gLogObj;
          v12 = type;
          if (os_log_type_enabled(v11, type))
          {
            *buf = 136446210;
            v25 = "nw_path_copy_all_local_paths";
            _os_log_impl(&dword_181A37000, v11, v12, "%{public}s nw_dictionary_create failed", buf, 0xCu);
          }
        }

        else if (v22 == 1)
        {
          backtrace_string = __nw_create_backtrace_string();
          if (backtrace_string)
          {
            v14 = backtrace_string;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v15 = gLogObj;
            v16 = type;
            if (os_log_type_enabled(v15, type))
            {
              *buf = 136446466;
              v25 = "nw_path_copy_all_local_paths";
              v26 = 2082;
              v27 = v14;
              _os_log_impl(&dword_181A37000, v15, v16, "%{public}s nw_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v14);
            if (!v10)
            {
              goto LABEL_26;
            }

            goto LABEL_25;
          }

          v11 = __nwlog_obj();
          v18 = type;
          if (os_log_type_enabled(v11, type))
          {
            *buf = 136446210;
            v25 = "nw_path_copy_all_local_paths";
            _os_log_impl(&dword_181A37000, v11, v18, "%{public}s nw_dictionary_create failed, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v11 = gLogObj;
          v17 = type;
          if (os_log_type_enabled(v11, type))
          {
            *buf = 136446210;
            v25 = "nw_path_copy_all_local_paths";
            _os_log_impl(&dword_181A37000, v11, v17, "%{public}s nw_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }

      if (!v10)
      {
        goto LABEL_26;
      }

LABEL_25:
      free(v10);
      goto LABEL_26;
    }
  }

  else
  {
    os_unfair_lock_unlock((globals_for_path + 116));
  }

  v6 = 0;
LABEL_27:

  return v6;
}

uint64_t __nw_path_copy_all_local_paths_block_invoke(uint64_t a1, const char *a2, void *a3)
{
  v5 = a3;
  v6 = v5;
  if (v5)
  {
    os_unfair_lock_lock(v5 + 24);
    v7 = *&v6[12]._os_unfair_lock_opaque;
    if (v7)
    {
      nw_dictionary_set_value(*(a1 + 32), a2, v7);
    }

    os_unfair_lock_unlock(v6 + 24);
  }

  return 1;
}

unint64_t nw_path_get_nexus_instance(void *a1, unsigned __int8 *a2, _DWORD *a3)
{
  v23 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = v5;
  if (v5)
  {
    nexus_instance = _nw_path_get_nexus_instance(v5, a2, a3);
    goto LABEL_3;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_path_get_nexus_instance";
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v20 = "nw_path_get_nexus_instance";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v20 = "nw_path_get_nexus_instance";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v15)
      {
        *buf = 136446210;
        v20 = "nw_path_get_nexus_instance";
        _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v20 = "nw_path_get_nexus_instance";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v10)
  {
    free(v10);
  }

  nexus_instance = 0;
LABEL_3:

  return nexus_instance;
}

uint64_t nw_path_get_nexus_key(void *a1, uint64_t a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nexus_key = _nw_path_get_nexus_key(v3, a2);
    goto LABEL_3;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_path_get_nexus_key";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_get_nexus_key";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v18 = "nw_path_get_nexus_key";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *buf = 136446210;
        v18 = "nw_path_get_nexus_key";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_get_nexus_key";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v8)
  {
    free(v8);
  }

  nexus_key = 0;
LABEL_3:

  return nexus_key;
}

uint64_t nw_path_get_nexus_flow_index(void *a1, _DWORD *a2)
{
  v26 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
    {
      nexus_flow_index = _nw_path_get_nexus_flow_index(v3, a2);
      goto LABEL_4;
    }

    v11 = __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_path_get_nexus_flow_index";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v23 = "nw_path_get_nexus_flow_index";
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null nexus_flow_index", buf, 0xCu);
        }

LABEL_36:

        goto LABEL_37;
      }

      if (v20 != 1)
      {
        v9 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v23 = "nw_path_get_nexus_flow_index";
          _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null nexus_flow_index, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_36;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          v23 = "nw_path_get_nexus_flow_index";
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s called with null nexus_flow_index, no backtrace", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v17)
      {
        *buf = 136446466;
        v23 = "nw_path_get_nexus_flow_index";
        v24 = 2082;
        v25 = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s called with null nexus_flow_index, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_24;
    }
  }

  else
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_path_get_nexus_flow_index";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v23 = "nw_path_get_nexus_flow_index";
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null path", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v20 != 1)
      {
        v9 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v23 = "nw_path_get_nexus_flow_index";
          _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_36;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *buf = 136446210;
          v23 = "nw_path_get_nexus_flow_index";
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v15)
      {
        *buf = 136446466;
        v23 = "nw_path_get_nexus_flow_index";
        v24 = 2082;
        v25 = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_24:

      free(backtrace_string);
    }
  }

LABEL_37:
  if (v8)
  {
    free(v8);
  }

  nexus_flow_index = 0;
LABEL_4:

  return nexus_flow_index;
}

uint64_t nw_path_flow_get_nexus_instance(void *a1, unsigned __int8 *a2, _DWORD *a3)
{
  v23 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = v5;
  if (v5)
  {
    nexus_instance = _nw_path_flow_get_nexus_instance(v5, a2, a3);
    goto LABEL_3;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_path_flow_get_nexus_instance";
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v20 = "nw_path_flow_get_nexus_instance";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v20 = "nw_path_flow_get_nexus_instance";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v15)
      {
        *buf = 136446210;
        v20 = "nw_path_flow_get_nexus_instance";
        _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v20 = "nw_path_flow_get_nexus_instance";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v10)
  {
    free(v10);
  }

  nexus_instance = 0;
LABEL_3:

  return nexus_instance;
}

uint64_t nw_path_flow_registration_can_use_nexus(void *a1, void *a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    v5 = nw_path_copy_flow_for_registration(v3, v4);
    v6 = v5;
    if (v5)
    {
      can_use_nexus = _nw_path_flow_can_use_nexus(v5);
    }

    else
    {
      can_use_nexus = 0;
    }

    goto LABEL_6;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v20 = "nw_path_flow_registration_can_use_nexus";
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v20 = "nw_path_flow_registration_can_use_nexus";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v17 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v20 = "nw_path_flow_registration_can_use_nexus";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v15)
      {
        *buf = 136446210;
        v20 = "nw_path_flow_registration_can_use_nexus";
        _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v20 = "nw_path_flow_registration_can_use_nexus";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v10)
  {
    free(v10);
  }

  can_use_nexus = 0;
LABEL_6:

  return can_use_nexus;
}

uint64_t nw_path_flow_nexus_can_support_user_packet_pool(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    can_support_user_packet_pool = _nw_path_flow_nexus_can_support_user_packet_pool(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_nexus_can_support_user_packet_pool";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_nexus_can_support_user_packet_pool";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_nexus_can_support_user_packet_pool";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_nexus_can_support_user_packet_pool";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_nexus_can_support_user_packet_pool";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  can_support_user_packet_pool = 0;
LABEL_3:

  return can_support_user_packet_pool;
}

uint64_t nw_path_flow_nexus_should_use_event_ring(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    should_use_event_ring = _nw_path_flow_nexus_should_use_event_ring(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_nexus_should_use_event_ring";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_nexus_should_use_event_ring";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_nexus_should_use_event_ring";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_nexus_should_use_event_ring";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_nexus_should_use_event_ring";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  should_use_event_ring = 0;
LABEL_3:

  return should_use_event_ring;
}

BOOL nw_path_flow_registration_get_unique_flow_tag(void *a1, void *a2, _DWORD *a3)
{
  v25 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a2;
  if (a3)
  {
    v7 = nw_path_copy_flow_for_registration(v5, v6);
    v8 = v7;
    v9 = v7 != 0;
    if (v7)
    {
      *a3 = _nw_path_flow_get_unique_flow_tag(v7);
    }

    goto LABEL_5;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v22 = "nw_path_flow_registration_get_unique_flow_tag";
  v12 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *buf = 136446210;
        v22 = "nw_path_flow_registration_get_unique_flow_tag";
        _os_log_impl(&dword_181A37000, v13, v14, "%{public}s called with null unique_flow_tag", buf, 0xCu);
      }
    }

    else if (v19 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *buf = 136446466;
          v22 = "nw_path_flow_registration_get_unique_flow_tag";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_181A37000, v13, v16, "%{public}s called with null unique_flow_tag, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v17)
      {
        *buf = 136446210;
        v22 = "nw_path_flow_registration_get_unique_flow_tag";
        _os_log_impl(&dword_181A37000, v13, v16, "%{public}s called with null unique_flow_tag, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v13 = __nwlog_obj();
      v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *buf = 136446210;
        v22 = "nw_path_flow_registration_get_unique_flow_tag";
        _os_log_impl(&dword_181A37000, v13, v18, "%{public}s called with null unique_flow_tag, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v12)
  {
    free(v12);
  }

  v9 = 0;
LABEL_5:

  return v9;
}

BOOL nw_path_flow_registration_get_flow_stats_index(void *a1, void *a2, _DWORD *a3)
{
  v25 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a2;
  if (a3)
  {
    v7 = nw_path_copy_flow_for_registration(v5, v6);
    v8 = v7;
    v9 = v7 != 0;
    if (v7)
    {
      *a3 = _nw_path_flow_get_flow_stats_index(v7);
    }

    goto LABEL_5;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v22 = "nw_path_flow_registration_get_flow_stats_index";
  v12 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *buf = 136446210;
        v22 = "nw_path_flow_registration_get_flow_stats_index";
        _os_log_impl(&dword_181A37000, v13, v14, "%{public}s called with null flow_stats_index", buf, 0xCu);
      }
    }

    else if (v19 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *buf = 136446466;
          v22 = "nw_path_flow_registration_get_flow_stats_index";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_181A37000, v13, v16, "%{public}s called with null flow_stats_index, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v17)
      {
        *buf = 136446210;
        v22 = "nw_path_flow_registration_get_flow_stats_index";
        _os_log_impl(&dword_181A37000, v13, v16, "%{public}s called with null flow_stats_index, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v13 = __nwlog_obj();
      v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *buf = 136446210;
        v22 = "nw_path_flow_registration_get_flow_stats_index";
        _os_log_impl(&dword_181A37000, v13, v18, "%{public}s called with null flow_stats_index, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v12)
  {
    free(v12);
  }

  v9 = 0;
LABEL_5:

  return v9;
}

BOOL nw_path_get_flow_registration_id(void *a1, unsigned __int8 *a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    _nw_path_get_flow_registration_id(v3, a2);
    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_path_get_flow_registration_id";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_path_get_flow_registration_id";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v17 = "nw_path_get_flow_registration_id";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v17 = "nw_path_get_flow_registration_id";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_path_get_flow_registration_id";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

LABEL_3:

  return v4 != 0;
}

BOOL nw_path_evaluator_get_client_id(void *a1, _OWORD *a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    *a2 = v3[5];
    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_path_evaluator_get_client_id";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_path_evaluator_get_client_id";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v17 = "nw_path_evaluator_get_client_id";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v17 = "nw_path_evaluator_get_client_id";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_path_evaluator_get_client_id";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

  v3 = 0;
LABEL_3:
  v4 = v3 != 0;

  return v4;
}

void nw_path_flow_registration_remove_extra_interface_option(void *a1, void *a2)
{
  v33 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    v10 = __nwlog_obj();
    *buf = 136446210;
    v30 = "nw_path_flow_registration_remove_extra_interface_option";
    v11 = _os_log_send_and_compose_impl();

    v28 = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v11, &v28, &v27))
    {
      goto LABEL_42;
    }

    if (v28 == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = v28;
      if (os_log_type_enabled(v12, v28))
      {
        *buf = 136446210;
        v30 = "nw_path_flow_registration_remove_extra_interface_option";
        _os_log_impl(&dword_181A37000, v12, v13, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v27 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v17 = v28;
      v18 = os_log_type_enabled(v12, v28);
      if (backtrace_string)
      {
        if (v18)
        {
          *buf = 136446466;
          v30 = "nw_path_flow_registration_remove_extra_interface_option";
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_181A37000, v12, v17, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v11)
        {
          goto LABEL_8;
        }

LABEL_43:
        free(v11);
        goto LABEL_8;
      }

      if (v18)
      {
        *buf = 136446210;
        v30 = "nw_path_flow_registration_remove_extra_interface_option";
        _os_log_impl(&dword_181A37000, v12, v17, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v12 = __nwlog_obj();
      v22 = v28;
      if (os_log_type_enabled(v12, v28))
      {
        *buf = 136446210;
        v30 = "nw_path_flow_registration_remove_extra_interface_option";
        _os_log_impl(&dword_181A37000, v12, v22, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_41:

    goto LABEL_42;
  }

  if (v4)
  {
    v6 = v3[3];
    if (v6)
    {
      v24[0] = MEMORY[0x1E69E9820];
      v24[1] = 3221225472;
      v24[2] = __nw_path_flow_registration_remove_extra_interface_option_block_invoke;
      v24[3] = &unk_1E6A39AC0;
      v25 = v4;
      v26 = v3;
      v7 = v6;
      v8 = v24;
      _nw_array_remove_objects(v7, v8);
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446210;
        v30 = "nw_path_flow_registration_remove_extra_interface_option";
        _os_log_impl(&dword_181A37000, v9, OS_LOG_TYPE_DEBUG, "%{public}s No extra interface options", buf, 0xCu);
      }
    }

    goto LABEL_8;
  }

  v14 = __nwlog_obj();
  *buf = 136446210;
  v30 = "nw_path_flow_registration_remove_extra_interface_option";
  v11 = _os_log_send_and_compose_impl();

  v28 = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (!__nwlog_fault(v11, &v28, &v27))
  {
    goto LABEL_42;
  }

  if (v28 == OS_LOG_TYPE_FAULT)
  {
    v12 = __nwlog_obj();
    v15 = v28;
    if (os_log_type_enabled(v12, v28))
    {
      *buf = 136446210;
      v30 = "nw_path_flow_registration_remove_extra_interface_option";
      _os_log_impl(&dword_181A37000, v12, v15, "%{public}s called with null details", buf, 0xCu);
    }

    goto LABEL_41;
  }

  if (v27 != 1)
  {
    v12 = __nwlog_obj();
    v23 = v28;
    if (os_log_type_enabled(v12, v28))
    {
      *buf = 136446210;
      v30 = "nw_path_flow_registration_remove_extra_interface_option";
      _os_log_impl(&dword_181A37000, v12, v23, "%{public}s called with null details, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_41;
  }

  v19 = __nw_create_backtrace_string();
  v12 = __nwlog_obj();
  v20 = v28;
  v21 = os_log_type_enabled(v12, v28);
  if (!v19)
  {
    if (v21)
    {
      *buf = 136446210;
      v30 = "nw_path_flow_registration_remove_extra_interface_option";
      _os_log_impl(&dword_181A37000, v12, v20, "%{public}s called with null details, no backtrace", buf, 0xCu);
    }

    goto LABEL_41;
  }

  if (v21)
  {
    *buf = 136446466;
    v30 = "nw_path_flow_registration_remove_extra_interface_option";
    v31 = 2082;
    v32 = v19;
    _os_log_impl(&dword_181A37000, v12, v20, "%{public}s called with null details, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11)
  {
    goto LABEL_43;
  }

LABEL_8:
}

uint64_t __nw_path_flow_registration_remove_extra_interface_option_block_invoke(uint64_t a1, void *a2)
{
  v16 = *MEMORY[0x1E69E9840];
  v3 = a2;
  v4 = [*(a1 + 32) isEqual:v3];
  if (v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      v6 = *(a1 + 40) + 32;
      v8 = 136446978;
      v9 = "nw_path_flow_registration_remove_extra_interface_option_block_invoke";
      v10 = 2112;
      v11 = v3;
      v12 = 1042;
      v13 = 16;
      v14 = 2098;
      v15 = v6;
      _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_INFO, "%{public}s Removing %@ from %{public,uuid_t}.16P", &v8, 0x26u);
    }
  }

  return v4;
}

void nw_path_flow_registration_remove_all_interface_options(void *a1)
{
  *&v17[13] = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *buf = 136446722;
      v15 = "nw_path_flow_registration_remove_all_interface_options";
      v16 = 1042;
      *v17 = 16;
      v17[2] = 2098;
      *&v17[3] = v1 + 4;
      _os_log_impl(&dword_181A37000, v2, OS_LOG_TYPE_INFO, "%{public}s Removing all interface option_details from flow %{public,uuid_t}.16P", buf, 0x1Cu);
    }

    v3 = v1[3];
    v1[3] = 0;

    goto LABEL_5;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_path_flow_registration_remove_all_interface_options";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_remove_all_interface_options";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_path_flow_registration_remove_all_interface_options";
          v16 = 2082;
          *v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_remove_all_interface_options";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_remove_all_interface_options";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_22:
  if (v5)
  {
    free(v5);
  }

LABEL_5:
}

void nw_path_flow_registration_override_traffic_class(void *a1, int a2)
{
  v18 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    v3[36] = a2;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_path_flow_registration_override_traffic_class";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_override_traffic_class";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_path_flow_registration_override_traffic_class";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_override_traffic_class";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_override_traffic_class";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v3 = 0;
LABEL_3:
}

void nw_path_flow_registration_override_interface_types(void *a1, int a2, int a3, int a4, int a5, int a6)
{
  v31 = *MEMORY[0x1E69E9840];
  v11 = a1;
  if (v11)
  {
    if (a2)
    {
      v12 = 8;
    }

    else
    {
      v12 = 0;
    }

    if (a4)
    {
      v13 = 32;
    }

    else
    {
      v13 = 0;
    }

    if (a5)
    {
      v14 = 64;
    }

    else
    {
      v14 = 0;
    }

    if (a3)
    {
      v15 = 16;
    }

    else
    {
      v15 = 0;
    }

    if (a6)
    {
      v16 = 0x80;
    }

    else
    {
      v16 = 0;
    }

    v11[148] = (v15 | v12 | v13 | v14 | v16) & 0xF8 | v11[148] & 7;
    goto LABEL_18;
  }

  v17 = __nwlog_obj();
  *buf = 136446210;
  v28 = "nw_path_flow_registration_override_interface_types";
  v18 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (__nwlog_fault(v18, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *buf = 136446210;
        v28 = "nw_path_flow_registration_override_interface_types";
        _os_log_impl(&dword_181A37000, v19, v20, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v25 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v19 = __nwlog_obj();
      v22 = type;
      v23 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v23)
        {
          *buf = 136446466;
          v28 = "nw_path_flow_registration_override_interface_types";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_181A37000, v19, v22, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }

      if (v23)
      {
        *buf = 136446210;
        v28 = "nw_path_flow_registration_override_interface_types";
        _os_log_impl(&dword_181A37000, v19, v22, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v19 = __nwlog_obj();
      v24 = type;
      if (os_log_type_enabled(v19, type))
      {
        *buf = 136446210;
        v28 = "nw_path_flow_registration_override_interface_types";
        _os_log_impl(&dword_181A37000, v19, v24, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_35:
  if (v18)
  {
    free(v18);
  }

  v11 = 0;
LABEL_18:
}

void nw_path_flow_registration_override_evaluator(void *a1, void *a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 17, a2);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_registration_override_evaluator";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_registration_override_evaluator";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_registration_override_evaluator";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_registration_override_evaluator";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_registration_override_evaluator";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

LABEL_3:
}

void nw_path_override_local_endpoint(void *a1, void *a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    _nw_path_set_override_local_endpoint(v3, v4);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_override_local_endpoint";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_override_local_endpoint";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_override_local_endpoint";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_override_local_endpoint";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_override_local_endpoint";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

LABEL_3:
}

void nw_path_override_interface(void *a1, void *a2, uint64_t a3)
{
  v21 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a2;
  if (v5)
  {
    _nw_path_override_interface(v5, v6, a3);
    goto LABEL_3;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_path_override_interface";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_override_interface";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v18 = "nw_path_override_interface";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *buf = 136446210;
        v18 = "nw_path_override_interface";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_override_interface";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v8)
  {
    free(v8);
  }

LABEL_3:
}

uint64_t nw_path_copy_override_interface(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_copy_override_interface(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_copy_override_interface";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_copy_override_interface";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_copy_override_interface";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_copy_override_interface";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_copy_override_interface";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

void nw_path_override_viable(void *a1, uint64_t a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    _nw_path_set_override_viable(v3, a2);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_override_viable";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_override_viable";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_override_viable";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_override_viable";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_override_viable";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

LABEL_3:
}

id nw_path_create_from_tlv(uint64_t a1, uint64_t a2, NSObject *a3)
{
  v28 = *MEMORY[0x1E69E9840];
  v5 = _nw_path_create(a1, 0);
  v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    *buf = 136446210;
    v25 = "nw_path_create_from_tlv";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
    {
      goto LABEL_37;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v25 = "nw_path_create_from_tlv";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s nw_path_create failed", buf, 0xCu);
      }

      goto LABEL_36;
    }

    if (v22 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v25 = "nw_path_create_from_tlv";
        _os_log_impl(&dword_181A37000, v10, v19, "%{public}s nw_path_create failed, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_36;
    }

    backtrace_string = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    v15 = type;
    v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *buf = 136446210;
        v25 = "nw_path_create_from_tlv";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s nw_path_create failed, no backtrace", buf, 0xCu);
      }

      goto LABEL_36;
    }

    if (v16)
    {
      *buf = 136446466;
      v25 = "nw_path_create_from_tlv";
      v26 = 2082;
      v27 = backtrace_string;
      _os_log_impl(&dword_181A37000, v10, v15, "%{public}s nw_path_create failed, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_23;
  }

  if ((nw_path_parse_necp_result(v5, a2, a3) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    *buf = 136446210;
    v25 = "nw_path_create_from_tlv";
    v9 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
    {
      goto LABEL_37;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v25 = "nw_path_create_from_tlv";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s nw_path_parse_necp_result failed", buf, 0xCu);
      }

LABEL_36:

LABEL_37:
      if (!v9)
      {
LABEL_39:
        v7 = 0;
        goto LABEL_40;
      }

LABEL_38:
      free(v9);
      goto LABEL_39;
    }

    if (v22 != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v25 = "nw_path_create_from_tlv";
        _os_log_impl(&dword_181A37000, v10, v20, "%{public}s nw_path_parse_necp_result failed, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_36;
    }

    backtrace_string = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    v17 = type;
    v18 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *buf = 136446210;
        v25 = "nw_path_create_from_tlv";
        _os_log_impl(&dword_181A37000, v10, v17, "%{public}s nw_path_parse_necp_result failed, no backtrace", buf, 0xCu);
      }

      goto LABEL_36;
    }

    if (v18)
    {
      *buf = 136446466;
      v25 = "nw_path_create_from_tlv";
      v26 = 2082;
      v27 = backtrace_string;
      _os_log_impl(&dword_181A37000, v10, v17, "%{public}s nw_path_parse_necp_result failed, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_23:

    free(backtrace_string);
    if (!v9)
    {
      goto LABEL_39;
    }

    goto LABEL_38;
  }

  _nw_path_snapshot_path(v6);
  v7 = v6;
LABEL_40:

  return v7;
}

BOOL nw_path_is_preferred(void *a1, void *a2, char a3)
{
  v29 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a2;
  v7 = v6;
  if (!v5)
  {
    v9 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_path_is_preferred";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23))
    {
      goto LABEL_37;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v26 = "nw_path_is_preferred";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }

      goto LABEL_36;
    }

    if (v23 != 1)
    {
      v11 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v26 = "nw_path_is_preferred";
        _os_log_impl(&dword_181A37000, v11, v20, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_36;
    }

    backtrace_string = __nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v16 = type;
    v17 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *buf = 136446210;
        v26 = "nw_path_is_preferred";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }

      goto LABEL_36;
    }

    if (v17)
    {
      *buf = 136446466;
      v26 = "nw_path_is_preferred";
      v27 = 2082;
      v28 = backtrace_string;
      _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_24;
  }

  if (!v6)
  {
    v13 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_path_is_preferred";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23))
    {
      goto LABEL_37;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v26 = "nw_path_is_preferred";
        _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null other_path", buf, 0xCu);
      }

LABEL_36:

LABEL_37:
      if (v10)
      {
        free(v10);
      }

      goto LABEL_39;
    }

    if (v23 != 1)
    {
      v11 = __nwlog_obj();
      v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v26 = "nw_path_is_preferred";
        _os_log_impl(&dword_181A37000, v11, v21, "%{public}s called with null other_path, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_36;
    }

    backtrace_string = __nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v18 = type;
    v19 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *buf = 136446210;
        v26 = "nw_path_is_preferred";
        _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null other_path, no backtrace", buf, 0xCu);
      }

      goto LABEL_36;
    }

    if (v19)
    {
      *buf = 136446466;
      v26 = "nw_path_is_preferred";
      v27 = 2082;
      v28 = backtrace_string;
      _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null other_path, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_24:

    free(backtrace_string);
    goto LABEL_37;
  }

  if (v5 == v6)
  {
LABEL_39:
    is_preferred = 0;
    goto LABEL_40;
  }

  is_preferred = _nw_path_is_preferred(v5, v6, a3);
LABEL_40:

  return is_preferred;
}

void nw_path_evaluator_set_cancel_handler(os_unfair_lock_s *a1, void *a2)
{
  if (a1)
  {
    v3 = a2;
    v6 = a1;
    os_unfair_lock_lock(a1 + 24);
    v4 = _Block_copy(v3);

    v5 = *&v6[18]._os_unfair_lock_opaque;
    *&v6[18]._os_unfair_lock_opaque = v4;

    os_unfair_lock_unlock(a1 + 24);
  }
}

uint64_t nw_path_get_custom_ethertype(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    custom_ethertype = _nw_path_get_custom_ethertype(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_get_custom_ethertype";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_get_custom_ethertype";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_get_custom_ethertype";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_get_custom_ethertype";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_get_custom_ethertype";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  custom_ethertype = 0;
LABEL_3:

  return custom_ethertype;
}

uint64_t nw_path_get_flow_divert_aggregate_unit(void *a1)
{
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    flow_divert_aggregate_unit = _nw_path_get_flow_divert_aggregate_unit(v1);
  }

  else
  {
    flow_divert_aggregate_unit = 0;
  }

  return flow_divert_aggregate_unit;
}

uint64_t nw_path_get_filter_unit(void *a1)
{
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    filter_unit = _nw_path_get_filter_unit(v1);
  }

  else
  {
    filter_unit = 0;
  }

  return filter_unit;
}

uint64_t nw_path_flow_registration_fast_open_blocked(NWConcrete_nw_path *a1, NWConcrete_nw_path_flow_registration *a2)
{
  v2 = nw_path_copy_flow_for_registration(a1, a2);
  v3 = v2;
  if (v2)
  {
    v4 = _nw_path_flow_fast_open_blocked(v2);
  }

  else
  {
    v4 = 0;
  }

  return v4;
}

uint64_t nw_path_policy_abort(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_policy_abort(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_policy_abort";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_policy_abort";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_policy_abort";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_policy_abort";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_policy_abort";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

unint64_t nw_path_get_connected_interface_index(void *a1)
{
  v21 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_copy_connected_interface(v1);
    v4 = v3;
    if (v3)
    {
      index = _nw_interface_get_index(v3);
    }

    else
    {
      index = 0;
    }

    goto LABEL_6;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_path_get_connected_interface_index";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_get_connected_interface_index";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v18 = "nw_path_get_connected_interface_index";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v13)
      {
        *buf = 136446210;
        v18 = "nw_path_get_connected_interface_index";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_get_connected_interface_index";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v8)
  {
    free(v8);
  }

  index = 0;
LABEL_6:

  return index;
}

uint64_t nw_path_nat64_prefixes(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_nat64_prefixes(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_nat64_prefixes";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_nat64_prefixes";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_nat64_prefixes";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_nat64_prefixes";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_nat64_prefixes";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_is_eligible_for_CrazyIvan46(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_copy_resolver_configs(v1, 0);
    if ((_nw_path_has_ipv4(v2) & 1) != 0 || !_nw_path_has_ipv6(v2))
    {
      v4 = 0;
    }

    else if (v3 && _nw_array_get_count(v3))
    {
      v4 = 1;
    }

    else
    {
      v4 = _nw_path_has_nat64_prefixes(v2);
    }

    goto LABEL_9;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_path_is_eligible_for_CrazyIvan46";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_path_is_eligible_for_CrazyIvan46";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v17 = "nw_path_is_eligible_for_CrazyIvan46";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v12)
      {
        *buf = 136446210;
        v17 = "nw_path_is_eligible_for_CrazyIvan46";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_path_is_eligible_for_CrazyIvan46";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_27:
  if (v7)
  {
    free(v7);
  }

  v4 = 0;
LABEL_9:

  return v4;
}

char *nw_path_is_override_expensive(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_is_override_expensive(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_is_override_expensive";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_is_override_expensive";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_is_override_expensive";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_is_override_expensive";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_is_override_expensive";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

char *nw_path_is_override_constrained(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_is_override_constrained(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_is_override_constrained";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_is_override_constrained";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_is_override_constrained";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_is_override_constrained";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_is_override_constrained";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_is_ultra_constrained_allowed()
{
  if (nw_path_is_ultra_constrained_allowed::onceToken != -1)
  {
    dispatch_once(&nw_path_is_ultra_constrained_allowed::onceToken, &__block_literal_global_171);
  }

  return nw_path_is_ultra_constrained_allowed::is_allowed;
}

void __nw_path_is_ultra_constrained_allowed_block_invoke()
{
  v0 = nw_utilities_copy_local_entitlement_value("com.apple.private.network.ultraconstrained");
  v1 = v0;
  if (v0)
  {
    xBOOL = v0;
    Class = object_getClass(v0);
    v1 = xBOOL;
    if (Class == MEMORY[0x1E69E9E58])
    {
      value = xpc_BOOL_get_value(xBOOL);
      v1 = xBOOL;
      if (value)
      {
        nw_path_is_ultra_constrained_allowed::is_allowed = 1;
      }
    }
  }
}

uint64_t __nw_path_copy_interface_with_generation_block_invoke(uint64_t a1, const char *a2)
{
  uint64 = xpc_dictionary_get_uint64(*(a1 + 32), a2);
  if (nw_delta_nanos(uint64, *(a1 + 48)) >= 0x77359401)
  {
    xpc_array_set_string(*(a1 + 40), 0xFFFFFFFFFFFFFFFFLL, a2);
  }

  return 1;
}

uint64_t __nw_path_copy_interface_with_generation_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a3;
  string_ptr = xpc_string_get_string_ptr(v4);
  if (string_ptr)
  {
    nw_dictionary_set_value(*(a1 + 32), string_ptr, 0);
    xpc_dictionary_set_value(*(a1 + 40), string_ptr, 0);
  }

  return 1;
}

id nw_path_copy_interface_from_cache(int a1)
{
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
  {
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }

  v2 = nw_context_copy_implicit_context::implicit_context;
  v3 = nw_path_copy_interface_with_generation(v2, a1, 0);

  return v3;
}

const char *nw_path_evaluator_get_error_string(unsigned int a1)
{
  if (a1 > 2)
  {
    return "unknown error";
  }

  else
  {
    return off_1E6A39D28[a1];
  }
}

char *nw_path_evaluator_trigger_agents(uint64_t a1, char a2, char a3, void *a4)
{
  v7 = a4;
  if (a1 && (v8 = *(a1 + 48)) != 0)
  {
    v9 = _nw_path_evaluator_trigger_agents(v8, a2, a3, v7);
  }

  else
  {
    v9 = 0;
  }

  return v9;
}

BOOL ___ZL47nw_path_flow_registration_copy_parent_evaluatorP36NWConcrete_nw_path_flow_registration_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a3 + 8);
  if (v3)
  {
    objc_storeStrong((*(*(a1 + 32) + 8) + 40), *(a3 + 8));
  }

  return v3 == 0;
}

void nw_path_flow_registration_set_tfo_cache(void *a1, void *a2, uint64_t a3)
{
  *&v47[13] = *MEMORY[0x1E69E9840];
  v5 = a1;
  v6 = a2;
  v7 = v6;
  if (!v5)
  {
    v23 = __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_path_flow_registration_set_tfo_cache";
    v14 = _os_log_send_and_compose_impl();

    v41[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v14, v41, &type))
    {
      goto LABEL_27;
    }

    if (v41[0] == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = v41[0];
      if (os_log_type_enabled(v24, v41[0]))
      {
        *buf = 136446210;
        v45 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_181A37000, v24, v25, "%{public}s called with null path", buf, 0xCu);
      }

      goto LABEL_78;
    }

    if (type != OS_LOG_TYPE_INFO)
    {
      v24 = __nwlog_obj();
      v37 = v41[0];
      if (os_log_type_enabled(v24, v41[0]))
      {
        *buf = 136446210;
        v45 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_181A37000, v24, v37, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_78;
    }

    backtrace_string = __nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v31 = v41[0];
    v32 = os_log_type_enabled(v24, v41[0]);
    if (!backtrace_string)
    {
      if (v32)
      {
        *buf = 136446210;
        v45 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_181A37000, v24, v31, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }

      goto LABEL_78;
    }

    if (v32)
    {
      *buf = 136446466;
      v45 = "nw_path_flow_registration_set_tfo_cache";
      v46 = 2082;
      *v47 = backtrace_string;
      _os_log_impl(&dword_181A37000, v24, v31, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_59;
  }

  if (!v6)
  {
    v26 = __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_path_flow_registration_set_tfo_cache";
    v14 = _os_log_send_and_compose_impl();

    v41[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v14, v41, &type))
    {
      goto LABEL_27;
    }

    if (v41[0] == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v27 = v41[0];
      if (os_log_type_enabled(v24, v41[0]))
      {
        *buf = 136446210;
        v45 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_181A37000, v24, v27, "%{public}s called with null flow_registration", buf, 0xCu);
      }

      goto LABEL_78;
    }

    if (type != OS_LOG_TYPE_INFO)
    {
      v24 = __nwlog_obj();
      v38 = v41[0];
      if (os_log_type_enabled(v24, v41[0]))
      {
        *buf = 136446210;
        v45 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_181A37000, v24, v38, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_78;
    }

    backtrace_string = __nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v33 = v41[0];
    v34 = os_log_type_enabled(v24, v41[0]);
    if (!backtrace_string)
    {
      if (v34)
      {
        *buf = 136446210;
        v45 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_181A37000, v24, v33, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }

      goto LABEL_78;
    }

    if (v34)
    {
      *buf = 136446466;
      v45 = "nw_path_flow_registration_set_tfo_cache";
      v46 = 2082;
      *v47 = backtrace_string;
      _os_log_impl(&dword_181A37000, v24, v33, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_59;
  }

  if (!a3)
  {
    v28 = __nwlog_obj();
    *buf = 136446210;
    v45 = "nw_path_flow_registration_set_tfo_cache";
    v14 = _os_log_send_and_compose_impl();

    v41[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v14, v41, &type))
    {
      goto LABEL_27;
    }

    if (v41[0] == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v29 = v41[0];
      if (os_log_type_enabled(v24, v41[0]))
      {
        *buf = 136446210;
        v45 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_181A37000, v24, v29, "%{public}s called with null tfo_cache_buffer", buf, 0xCu);
      }

LABEL_78:

LABEL_27:
      if (!v14)
      {
        goto LABEL_29;
      }

LABEL_28:
      free(v14);
      goto LABEL_29;
    }

    if (type != OS_LOG_TYPE_INFO)
    {
      v24 = __nwlog_obj();
      v39 = v41[0];
      if (os_log_type_enabled(v24, v41[0]))
      {
        *buf = 136446210;
        v45 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_181A37000, v24, v39, "%{public}s called with null tfo_cache_buffer, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_78;
    }

    backtrace_string = __nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v35 = v41[0];
    v36 = os_log_type_enabled(v24, v41[0]);
    if (!backtrace_string)
    {
      if (v36)
      {
        *buf = 136446210;
        v45 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl(&dword_181A37000, v24, v35, "%{public}s called with null tfo_cache_buffer, no backtrace", buf, 0xCu);
      }

      goto LABEL_78;
    }

    if (v36)
    {
      *buf = 136446466;
      v45 = "nw_path_flow_registration_set_tfo_cache";
      v46 = 2082;
      *v47 = backtrace_string;
      _os_log_impl(&dword_181A37000, v24, v35, "%{public}s called with null tfo_cache_buffer, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_59:

    free(backtrace_string);
    if (!v14)
    {
      goto LABEL_29;
    }

    goto LABEL_28;
  }

  *v41 = 0;
  v8 = _nw_path_copy_parameters(v5);
  v9 = nw_parameters_copy_context(v8);
  v10 = nw_path_shared_necp_fd(v9);

  if (v10 < 0)
  {
    goto LABEL_29;
  }

  *v41 = 258;
  v42 = a3;
  *&v41[4] = 18;
  if (!necp_client_action())
  {
    goto LABEL_29;
  }

  v11 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v12 = gLogObj;
  v13 = v12;
  if (v11 == 2)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *buf = 136446466;
      v45 = "nw_path_flow_registration_set_tfo_cache";
      v46 = 1024;
      *v47 = 2;
      _os_log_impl(&dword_181A37000, v13, OS_LOG_TYPE_ERROR, "%{public}s necp update cache failed for tfo %{darwin.errno}d", buf, 0x12u);
    }

    goto LABEL_29;
  }

  *buf = 136446466;
  v45 = "nw_path_flow_registration_set_tfo_cache";
  v46 = 1024;
  *v47 = v11;
  v14 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v40 = 0;
  if (!__nwlog_fault(v14, &type, &v40))
  {
    goto LABEL_27;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = gLogObj;
    v16 = type;
    if (os_log_type_enabled(v15, type))
    {
      *buf = 136446466;
      v45 = "nw_path_flow_registration_set_tfo_cache";
      v46 = 1024;
      *v47 = v11;
      _os_log_impl(&dword_181A37000, v15, v16, "%{public}s necp update cache failed for tfo %{darwin.errno}d", buf, 0x12u);
    }

LABEL_26:

    goto LABEL_27;
  }

  if (v40 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = gLogObj;
    v21 = type;
    if (os_log_type_enabled(v15, type))
    {
      *buf = 136446466;
      v45 = "nw_path_flow_registration_set_tfo_cache";
      v46 = 1024;
      *v47 = v11;
      _os_log_impl(&dword_181A37000, v15, v21, "%{public}s necp update cache failed for tfo %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
    }

    goto LABEL_26;
  }

  v17 = __nw_create_backtrace_string();
  if (!v17)
  {
    v15 = __nwlog_obj();
    v22 = type;
    if (os_log_type_enabled(v15, type))
    {
      *buf = 136446466;
      v45 = "nw_path_flow_registration_set_tfo_cache";
      v46 = 1024;
      *v47 = v11;
      _os_log_impl(&dword_181A37000, v15, v22, "%{public}s necp update cache failed for tfo %{darwin.errno}d, no backtrace", buf, 0x12u);
    }

    goto LABEL_26;
  }

  v18 = v17;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v19 = gLogObj;
  v20 = type;
  if (os_log_type_enabled(v19, type))
  {
    *buf = 136446722;
    v45 = "nw_path_flow_registration_set_tfo_cache";
    v46 = 1024;
    *v47 = v11;
    v47[2] = 2082;
    *&v47[3] = v18;
    _os_log_impl(&dword_181A37000, v19, v20, "%{public}s necp update cache failed for tfo %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
  }

  free(v18);
  if (v14)
  {
    goto LABEL_28;
  }

LABEL_29:
}

void nw_path_flow_registration_set_specific_use_only(void *a1, char a2)
{
  v18 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    v3[149] = v3[149] & 0xFE | a2;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_path_flow_registration_set_specific_use_only";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_set_specific_use_only";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_path_flow_registration_set_specific_use_only";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_set_specific_use_only";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_set_specific_use_only";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v3 = 0;
LABEL_3:
}

BOOL nw_path_request_nexus(void *a1)
{
  v27 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    nw_allow_use_of_dispatch_internal();
    v2 = _nw_path_copy_parameters(v1);
    v3 = nw_parameters_copy_context(v2);

    if ((nw_path_shared_necp_fd(v3) & 0x80000000) != 0)
    {
      v5 = 0;
    }

    else
    {
      *type = 0;
      v22 = 0;
      _nw_path_get_client_id(v1, type);
      v4 = necp_client_action();
      v5 = v4 == 0;
      if (v4)
      {
        v6 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          *buf = 136446466;
          v24 = "nw_path_request_nexus";
          v25 = 1024;
          LODWORD(v26) = v6;
          _os_log_impl(&dword_181A37000, v7, OS_LOG_TYPE_ERROR, "%{public}s NECP_CLIENT_ACTION_REQUEST_NEXUS_INSTANCE %{darwin.errno}d", buf, 0x12u);
        }
      }

      else
      {
        v17[0] = MEMORY[0x1E69E9820];
        v17[1] = 3221225472;
        v17[2] = __nw_path_request_nexus_block_invoke;
        v17[3] = &unk_1E6A3D760;
        v18 = v1;
        v19 = v3;
        nw_queue_context_async_if_needed(v19, v17);

        v7 = v18;
      }
    }

    goto LABEL_10;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v24 = "nw_path_request_nexus";
  v10 = _os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v10, type, &v20))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *buf = 136446210;
        v24 = "nw_path_request_nexus";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v14 = type[0];
      v15 = os_log_type_enabled(v11, type[0]);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v24 = "nw_path_request_nexus";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v15)
      {
        *buf = 136446210;
        v24 = "nw_path_request_nexus";
        _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v16 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *buf = 136446210;
        v24 = "nw_path_request_nexus";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_27:
  if (v10)
  {
    free(v10);
  }

  v5 = 0;
LABEL_10:

  return v5;
}

void __nw_path_request_nexus_block_invoke(uint64_t a1)
{
  v3 = *MEMORY[0x1E69E9840];
  v2 = 0uLL;
  _nw_path_get_client_id(*(a1 + 32), &v2);
  nw_path_necp_check_for_updates(*(a1 + 40), &v2, 0);
}

BOOL nw_path_evaluator_request_nexus(void *a1)
{
  v27 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    nw_allow_use_of_dispatch_internal();
    v2 = nw_parameters_copy_context(*(v1 + 1));
    if ((nw_path_shared_necp_fd(v2) & 0x80000000) != 0)
    {
      v4 = 0;
    }

    else
    {
      v3 = necp_client_action();
      v4 = v3 == 0;
      if (v3)
      {
        v5 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = gLogObj;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *buf = 136446466;
          v24 = "nw_path_evaluator_request_nexus";
          v25 = 1024;
          LODWORD(v26) = v5;
          _os_log_impl(&dword_181A37000, v6, OS_LOG_TYPE_ERROR, "%{public}s NECP_CLIENT_ACTION_REQUEST_NEXUS_INSTANCE %{darwin.errno}d", buf, 0x12u);
        }
      }

      else
      {
        os_unfair_lock_lock(v1 + 24);
        v7 = *(v1 + 25);
        os_unfair_lock_unlock(v1 + 24);
        v17[0] = MEMORY[0x1E69E9820];
        v17[1] = 3221225472;
        v17[2] = __nw_path_evaluator_request_nexus_block_invoke;
        v17[3] = &unk_1E6A3D7F8;
        v18 = v2;
        v19 = v1;
        v20 = v7;
        nw_queue_context_async_if_needed(v18, v17);

        v6 = v18;
      }
    }

    goto LABEL_10;
  }

  v9 = __nwlog_obj();
  *buf = 136446210;
  v24 = "nw_path_evaluator_request_nexus";
  v10 = _os_log_send_and_compose_impl();

  v22 = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (__nwlog_fault(v10, &v22, &v21))
  {
    if (v22 == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = v22;
      if (os_log_type_enabled(v11, v22))
      {
        *buf = 136446210;
        v24 = "nw_path_evaluator_request_nexus";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }

    else if (v21 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v14 = v22;
      v15 = os_log_type_enabled(v11, v22);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v24 = "nw_path_evaluator_request_nexus";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v15)
      {
        *buf = 136446210;
        v24 = "nw_path_evaluator_request_nexus";
        _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v16 = v22;
      if (os_log_type_enabled(v11, v22))
      {
        *buf = 136446210;
        v24 = "nw_path_evaluator_request_nexus";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_27:
  if (v10)
  {
    free(v10);
  }

  v4 = 0;
LABEL_10:

  return v4;
}

NWConcrete_nw_path_flow_registration *nw_path_flow_registration_create_new_flow_from_evaluator(void *a1, void *a2)
{
  v38 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v4)
  {
    os_unfair_lock_lock(v4 + 24);
    v6 = *&v5[12]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v5 + 24);
    if (v6)
    {
      v37 = 0uLL;
      _nw_path_get_nexus_agent_uuid_check_assertion(v6, &v37, 0);
      v7 = nw_path_evaluator_create_flow_inner(v5, 1, 1, 0, 0, &v37, 0, 0, 0, 0, 0);
      if (v3)
      {
        v8 = v3[2];
        if (v8 || (v9 = _nw_array_create(), v10 = v3[2], v3[2] = v9, v10, (v8 = v3[2]) != 0))
        {
          if (v7)
          {
            _nw_array_append(v8, v7);
          }
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          v12 = v3[2];
          *buf = 136446722;
          v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
          v33 = 2112;
          v34 = v12;
          v35 = 2112;
          v36 = v3;
          _os_log_impl(&dword_181A37000, v11, OS_LOG_TYPE_INFO, "%{public}s Added subflow registration %@ to %@", buf, 0x20u);
        }
      }

LABEL_11:

      goto LABEL_12;
    }

    v18 = __nwlog_obj();
    *buf = 136446210;
    v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
    v19 = _os_log_send_and_compose_impl();

    LOBYTE(v37) = 16;
    v30 = 0;
    if (__nwlog_fault(v19, &v37, &v30))
    {
      if (v37 == 17)
      {
        v20 = __nwlog_obj();
        v21 = v37;
        if (os_log_type_enabled(v20, v37))
        {
          *buf = 136446210;
          v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
          _os_log_impl(&dword_181A37000, v20, v21, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v30 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v20 = __nwlog_obj();
        v26 = v37;
        v27 = os_log_type_enabled(v20, v37);
        if (backtrace_string)
        {
          if (v27)
          {
            *buf = 136446466;
            v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
            v33 = 2082;
            v34 = backtrace_string;
            _os_log_impl(&dword_181A37000, v20, v26, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }

        if (v27)
        {
          *buf = 136446210;
          v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
          _os_log_impl(&dword_181A37000, v20, v26, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v20 = __nwlog_obj();
        v29 = v37;
        if (os_log_type_enabled(v20, v37))
        {
          *buf = 136446210;
          v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
          _os_log_impl(&dword_181A37000, v20, v29, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_48:
    if (v19)
    {
      free(v19);
    }

    v7 = 0;
    goto LABEL_11;
  }

  v14 = __nwlog_obj();
  *buf = 136446210;
  v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
  v15 = _os_log_send_and_compose_impl();

  LOBYTE(v37) = 16;
  v30 = 0;
  if (__nwlog_fault(v15, &v37, &v30))
  {
    if (v37 == 17)
    {
      v16 = __nwlog_obj();
      v17 = v37;
      if (os_log_type_enabled(v16, v37))
      {
        *buf = 136446210;
        v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
        _os_log_impl(&dword_181A37000, v16, v17, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }

    else if (v30 == 1)
    {
      v22 = __nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v23 = v37;
      v24 = os_log_type_enabled(v16, v37);
      if (v22)
      {
        if (v24)
        {
          *buf = 136446466;
          v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
          v33 = 2082;
          v34 = v22;
          _os_log_impl(&dword_181A37000, v16, v23, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v22);
        goto LABEL_42;
      }

      if (v24)
      {
        *buf = 136446210;
        v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
        _os_log_impl(&dword_181A37000, v16, v23, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v16 = __nwlog_obj();
      v28 = v37;
      if (os_log_type_enabled(v16, v37))
      {
        *buf = 136446210;
        v32 = "nw_path_flow_registration_create_new_flow_from_evaluator";
        _os_log_impl(&dword_181A37000, v16, v28, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_42:
  if (v15)
  {
    free(v15);
  }

  v7 = 0;
LABEL_12:

  return v7;
}

uint64_t nw_path_get_nexus_agent_uuid(void *a1, unsigned __int8 *a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = _nw_path_get_nexus_agent_uuid_check_assertion(v3, a2, 0);
    goto LABEL_3;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_path_get_nexus_agent_uuid";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_get_nexus_agent_uuid";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v18 = "nw_path_get_nexus_agent_uuid";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *buf = 136446210;
        v18 = "nw_path_get_nexus_agent_uuid";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_get_nexus_agent_uuid";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v8)
  {
    free(v8);
  }

  v5 = 0;
LABEL_3:

  return v5;
}

uint64_t nw_path_group_member_action(void *a1, const unsigned __int8 *a2, int a3, void *a4)
{
  v126 = *MEMORY[0x1E69E9840];
  v7 = a1;
  v92 = a4;
  if (!v7)
  {
    v72 = __nwlog_obj();
    *buf = 136446210;
    v118 = "nw_path_group_member_action";
    v9 = _os_log_send_and_compose_impl();

    LOBYTE(v110) = 16;
    aBlock[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v9, &v110, aBlock))
    {
      goto LABEL_111;
    }

    if (v110 == 17)
    {
      v10 = __nwlog_obj();
      v73 = v110;
      if (os_log_type_enabled(v10, v110))
      {
        *buf = 136446210;
        v118 = "nw_path_group_member_action";
        _os_log_impl(&dword_181A37000, v10, v73, "%{public}s called with null path", buf, 0xCu);
      }

      goto LABEL_136;
    }

    if (aBlock[0] != OS_LOG_TYPE_INFO)
    {
      v10 = __nwlog_obj();
      v77 = v110;
      if (os_log_type_enabled(v10, v110))
      {
        *buf = 136446210;
        v118 = "nw_path_group_member_action";
        _os_log_impl(&dword_181A37000, v10, v77, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_136;
    }

    backtrace_string = __nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v75 = v110;
    v76 = os_log_type_enabled(v23, v110);
    if (!backtrace_string)
    {
      if (v76)
      {
        *buf = 136446210;
        v118 = "nw_path_group_member_action";
        _os_log_impl(&dword_181A37000, v23, v75, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }

      goto LABEL_49;
    }

    if (v76)
    {
      *buf = 136446466;
      v118 = "nw_path_group_member_action";
      v119 = 2082;
      *v120 = backtrace_string;
      _os_log_impl(&dword_181A37000, v23, v75, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
    goto LABEL_111;
  }

  if (uuid_is_null(a2))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    *buf = 136446210;
    v118 = "nw_path_group_member_action";
    v9 = _os_log_send_and_compose_impl();

    LOBYTE(v110) = 16;
    aBlock[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v9, &v110, aBlock))
    {
      goto LABEL_111;
    }

    if (v110 == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v11 = v110;
      if (os_log_type_enabled(v10, v110))
      {
        *buf = 136446210;
        v118 = "nw_path_group_member_action";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null agent_uuid", buf, 0xCu);
      }

LABEL_136:

      goto LABEL_111;
    }

    if (aBlock[0] != OS_LOG_TYPE_INFO)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v26 = v110;
      if (os_log_type_enabled(v10, v110))
      {
        *buf = 136446210;
        v118 = "nw_path_group_member_action";
        _os_log_impl(&dword_181A37000, v10, v26, "%{public}s called with null agent_uuid, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_136;
    }

    v22 = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = gLogObj;
    v24 = v110;
    v25 = os_log_type_enabled(v23, v110);
    if (v22)
    {
      if (v25)
      {
        *buf = 136446466;
        v118 = "nw_path_group_member_action";
        v119 = 2082;
        *v120 = v22;
        _os_log_impl(&dword_181A37000, v23, v24, "%{public}s called with null agent_uuid, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_18;
    }

    if (v25)
    {
      *buf = 136446210;
      v118 = "nw_path_group_member_action";
      _os_log_impl(&dword_181A37000, v23, v24, "%{public}s called with null agent_uuid, no backtrace", buf, 0xCu);
    }

LABEL_49:

    goto LABEL_111;
  }

  v12 = _nw_path_copy_parameters(v7);
  v13 = nw_parameters_copy_context(v12);
  v14 = nw_path_shared_necp_fd(v13);

  if (v14 < 0)
  {
    goto LABEL_113;
  }

  v15 = v92;
  v16 = v15;
  v104 = 0;
  v105 = &v104;
  v106 = 0x2020000000;
  v107 = 0;
  v100 = 0;
  v101 = &v100;
  v102 = 0x2020000000;
  v103 = 0;
  *aBlock = MEMORY[0x1E69E9820];
  v95 = 3221225472;
  v96 = __nw_path_create_necp_agent_group_action_block_invoke;
  v97 = &unk_1E6A39C00;
  v98 = &v104;
  v99 = &v100;
  v91 = v15;
  if (v15)
  {
    _nw_array_apply(v15, aBlock);
    v17 = v105[3];
    v18 = v17 + 18;
    if (v17 == -18)
    {
      v19 = __nwlog_obj();
      os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
      *buf = 136446210;
      v118 = "nw_path_create_necp_agent_group_action";
      v20 = _os_log_send_and_compose_impl();

      result = __nwlog_should_abort(v20);
      if (result)
      {
        goto LABEL_161;
      }

      free(v20);
      v16 = v91;
    }
  }

  else
  {
    v17 = 0;
    v18 = 18;
  }

  v27 = malloc_type_calloc(1uLL, v18, 0x310C8D63uLL);
  v28 = v27;
  if (v27)
  {
    *v27 = *a2;
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v29 = gLogObj;
    os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v118 = "nw_path_create_necp_agent_group_action";
    v119 = 2048;
    *v120 = 1;
    *&v120[8] = 2048;
    *&v120[10] = v18;
    v30 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v30);
    v16 = v91;
    if (result)
    {
      goto LABEL_161;
    }

    free(v30);
    MEMORY[0] = *a2;
  }

  v28[8] = *(v101 + 12);
  v93[0] = 0;
  v93[1] = v93;
  v93[2] = 0x2020000000;
  v93[3] = v28 + 9;
  v110 = MEMORY[0x1E69E9820];
  v111 = 3221225472;
  v112 = __nw_path_create_necp_agent_group_action_block_invoke_25;
  v113 = &unk_1E6A3B328;
  v114 = v93;
  v115 = &v104;
  v116 = v28;
  if (v16)
  {
    _nw_array_apply(v16, &v110);
  }

  v31 = v17 + 23;
  if (!v31)
  {
    v78 = __nwlog_obj();
    os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
    *buf = 136446210;
    v118 = "nw_path_create_necp_agent_group_action";
    v79 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v79);
    if (result)
    {
      goto LABEL_161;
    }

    free(v79);
    v16 = v91;
  }

  v32 = malloc_type_calloc(1uLL, v31, 0x111F31D5uLL);
  v33 = v32;
  if (v32)
  {
    v90 = &v32[v31];
    if (v31 > 0)
    {
      if (v31 >= v18 + 5)
      {
        *v32 = a3;
        *(v32 + 1) = v18;
        if (v18)
        {
          memcpy(v32 + 5, v28, v18);
        }

        goto LABEL_78;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v34 = gLogObj;
      *buf = 136447490;
      v118 = "nw_necp_append_tlv";
      v119 = 2048;
      *v120 = v33;
      *&v120[8] = 2048;
      *&v120[10] = v18 + 5;
      v121 = 2048;
      *v122 = v90;
      *&v122[8] = 1024;
      *v123 = a3;
      *&v123[4] = 1024;
      *&v123[6] = v18;
      v35 = _os_log_send_and_compose_impl();

      v109 = OS_LOG_TYPE_ERROR;
      v108 = 0;
      if (__nwlog_fault(v35, &v109, &v108))
      {
        if (v109 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v36 = gLogObj;
          v37 = v109;
          if (os_log_type_enabled(v36, v109))
          {
            *buf = 136447490;
            v118 = "nw_necp_append_tlv";
            v119 = 2048;
            *v120 = v33;
            *&v120[8] = 2048;
            *&v120[10] = v18 + 5;
            v121 = 2048;
            *v122 = v90;
            *&v122[8] = 1024;
            *v123 = a3;
            *&v123[4] = 1024;
            *&v123[6] = v18;
            _os_log_impl(&dword_181A37000, v36, v37, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
          }
        }

        else
        {
          if (v108 == 1)
          {
            v48 = __nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v49 = gLogObj;
            type = v109;
            v50 = os_log_type_enabled(v49, v109);
            if (v48)
            {
              if (v50)
              {
                *buf = 136447746;
                v118 = "nw_necp_append_tlv";
                v119 = 2048;
                *v120 = v33;
                *&v120[8] = 2048;
                *&v120[10] = v18 + 5;
                v121 = 2048;
                *v122 = v90;
                *&v122[8] = 1024;
                *v123 = a3;
                *&v123[4] = 1024;
                *&v123[6] = v18;
                v124 = 2082;
                v125 = v48;
                _os_log_impl(&dword_181A37000, v49, type, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
              }

              free(v48);
              v16 = v91;
              if (!v35)
              {
                goto LABEL_78;
              }

              goto LABEL_77;
            }

            if (v50)
            {
              *buf = 136447490;
              v118 = "nw_necp_append_tlv";
              v119 = 2048;
              *v120 = v33;
              *&v120[8] = 2048;
              *&v120[10] = v18 + 5;
              v121 = 2048;
              *v122 = v90;
              *&v122[8] = 1024;
              *v123 = a3;
              *&v123[4] = 1024;
              *&v123[6] = v18;
              _os_log_impl(&dword_181A37000, v49, type, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
            }

            goto LABEL_76;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v36 = gLogObj;
          v52 = v109;
          if (os_log_type_enabled(v36, v109))
          {
            *buf = 136447490;
            v118 = "nw_necp_append_tlv";
            v119 = 2048;
            *v120 = v33;
            *&v120[8] = 2048;
            *&v120[10] = v18 + 5;
            v121 = 2048;
            *v122 = v90;
            *&v122[8] = 1024;
            *v123 = a3;
            *&v123[4] = 1024;
            *&v123[6] = v18;
            _os_log_impl(&dword_181A37000, v36, v52, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
          }
        }
      }

LABEL_76:
      v16 = v91;
      if (v35)
      {
LABEL_77:
        free(v35);
      }

LABEL_78:
      free(v28);
      _Block_object_dispose(v93, 8);
      _Block_object_dispose(&v100, 8);
      _Block_object_dispose(&v104, 8);

      if (v33)
      {
        v110 = 0;
        v111 = 0;
        _nw_path_get_client_id(v7, &v110);
        v53 = necp_client_action();
        v54 = v53 == 0;
        if (!v53)
        {
LABEL_123:
          free(v33);
          goto LABEL_114;
        }

        v55 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if (v55 == 45 || v55 == 2)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v56 = gLogObj;
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
          {
            *buf = 136446466;
            v118 = "nw_path_group_member_action";
            v119 = 1024;
            *v120 = v55;
            _os_log_impl(&dword_181A37000, v56, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d", buf, 0x12u);
          }

          goto LABEL_123;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v63 = gLogObj;
        *buf = 136446466;
        v118 = "nw_path_group_member_action";
        v119 = 1024;
        *v120 = v55;
        v64 = _os_log_send_and_compose_impl();

        aBlock[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v104) = 0;
        if (__nwlog_fault(v64, aBlock, &v104))
        {
          if (aBlock[0] == OS_LOG_TYPE_FAULT)
          {
            v65 = __nwlog_obj();
            v66 = aBlock[0];
            if (os_log_type_enabled(v65, aBlock[0]))
            {
              *buf = 136446466;
              v118 = "nw_path_group_member_action";
              v119 = 1024;
              *v120 = v55;
              _os_log_impl(&dword_181A37000, v65, v66, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d", buf, 0x12u);
            }
          }

          else if (v104 == 1)
          {
            v68 = __nw_create_backtrace_string();
            v65 = __nwlog_obj();
            v69 = aBlock[0];
            v70 = os_log_type_enabled(v65, aBlock[0]);
            if (v68)
            {
              if (v70)
              {
                *buf = 136446722;
                v118 = "nw_path_group_member_action";
                v119 = 1024;
                *v120 = v55;
                *&v120[4] = 2082;
                *&v120[6] = v68;
                _os_log_impl(&dword_181A37000, v65, v69, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
              }

              free(v68);
              goto LABEL_121;
            }

            if (v70)
            {
              *buf = 136446466;
              v118 = "nw_path_group_member_action";
              v119 = 1024;
              *v120 = v55;
              _os_log_impl(&dword_181A37000, v65, v69, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, no backtrace", buf, 0x12u);
            }
          }

          else
          {
            v65 = __nwlog_obj();
            v71 = aBlock[0];
            if (os_log_type_enabled(v65, aBlock[0]))
            {
              *buf = 136446466;
              v118 = "nw_path_group_member_action";
              v119 = 1024;
              *v120 = v55;
              _os_log_impl(&dword_181A37000, v65, v71, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
            }
          }
        }

LABEL_121:
        if (v64)
        {
          free(v64);
        }

        goto LABEL_123;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v57 = gLogObj;
      *buf = 136446210;
      v118 = "nw_path_group_member_action";
      v9 = _os_log_send_and_compose_impl();

      LOBYTE(v110) = 16;
      aBlock[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v9, &v110, aBlock))
      {
        goto LABEL_111;
      }

      if (v110 == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v58 = gLogObj;
        v59 = v110;
        if (os_log_type_enabled(v58, v110))
        {
          *buf = 136446210;
          v118 = "nw_path_group_member_action";
          _os_log_impl(&dword_181A37000, v58, v59, "%{public}s nw_path_create_necp_agent_group_action failed", buf, 0xCu);
        }

LABEL_89:

        goto LABEL_111;
      }

      if (aBlock[0] != OS_LOG_TYPE_INFO)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v58 = gLogObj;
        v67 = v110;
        if (os_log_type_enabled(v58, v110))
        {
          *buf = 136446210;
          v118 = "nw_path_group_member_action";
          _os_log_impl(&dword_181A37000, v58, v67, "%{public}s nw_path_create_necp_agent_group_action failed, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_89;
      }

      v22 = __nw_create_backtrace_string();
      v60 = __nwlog_obj();
      v61 = v110;
      v62 = os_log_type_enabled(v60, v110);
      if (v22)
      {
        if (v62)
        {
          *buf = 136446466;
          v118 = "nw_path_group_member_action";
          v119 = 2082;
          *v120 = v22;
          _os_log_impl(&dword_181A37000, v60, v61, "%{public}s nw_path_create_necp_agent_group_action failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

LABEL_18:
        free(v22);
        if (!v9)
        {
          goto LABEL_113;
        }

        goto LABEL_112;
      }

      if (v62)
      {
        *buf = 136446210;
        v118 = "nw_path_group_member_action";
        _os_log_impl(&dword_181A37000, v60, v61, "%{public}s nw_path_create_necp_agent_group_action failed, no backtrace", buf, 0xCu);
      }

LABEL_111:
      if (v9)
      {
LABEL_112:
        free(v9);
      }

LABEL_113:
      v54 = 0;
LABEL_114:

      return v54;
    }

    v80 = __nwlog_obj();
    *buf = 136447234;
    v118 = "nw_necp_append_tlv";
    v119 = 2048;
    *v120 = v33;
    *&v120[8] = 2048;
    *&v120[10] = v90;
    v121 = 1024;
    *v122 = a3;
    *&v122[4] = 1024;
    *&v122[6] = v18;
    v81 = _os_log_send_and_compose_impl();

    v109 = OS_LOG_TYPE_ERROR;
    v108 = 0;
    if (__nwlog_fault(v81, &v109, &v108))
    {
      if (v109 == OS_LOG_TYPE_FAULT)
      {
        v82 = __nwlog_obj();
        v83 = v109;
        if (os_log_type_enabled(v82, v109))
        {
          *buf = 136447234;
          v118 = "nw_necp_append_tlv";
          v119 = 2048;
          *v120 = v33;
          *&v120[8] = 2048;
          *&v120[10] = v90;
          v121 = 1024;
          *v122 = a3;
          *&v122[4] = 1024;
          *&v122[6] = v18;
          _os_log_impl(&dword_181A37000, v82, v83, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
        }
      }

      else
      {
        if (v108 == 1)
        {
          v84 = __nw_create_backtrace_string();
          v85 = __nwlog_obj();
          v88 = v109;
          v86 = os_log_type_enabled(v85, v109);
          if (v84)
          {
            if (v86)
            {
              *buf = 136447490;
              v118 = "nw_necp_append_tlv";
              v119 = 2048;
              *v120 = v33;
              *&v120[8] = 2048;
              *&v120[10] = v90;
              v121 = 1024;
              *v122 = a3;
              *&v122[4] = 1024;
              *&v122[6] = v18;
              *v123 = 2082;
              *&v123[2] = v84;
              _os_log_impl(&dword_181A37000, v85, v88, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
            }

            free(v84);
          }

          else
          {
            if (v86)
            {
              *buf = 136447234;
              v118 = "nw_necp_append_tlv";
              v119 = 2048;
              *v120 = v33;
              *&v120[8] = 2048;
              *&v120[10] = v90;
              v121 = 1024;
              *v122 = a3;
              *&v122[4] = 1024;
              *&v122[6] = v18;
              _os_log_impl(&dword_181A37000, v85, v88, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
            }
          }

          goto LABEL_158;
        }

        v82 = __nwlog_obj();
        v87 = v109;
        if (os_log_type_enabled(v82, v109))
        {
          *buf = 136447234;
          v118 = "nw_necp_append_tlv";
          v119 = 2048;
          *v120 = v33;
          *&v120[8] = 2048;
          *&v120[10] = v90;
          v121 = 1024;
          *v122 = a3;
          *&v122[4] = 1024;
          *&v122[6] = v18;
          _os_log_impl(&dword_181A37000, v82, v87, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
        }
      }
    }

LABEL_158:
    if (v81)
    {
      free(v81);
    }

    v16 = v91;
    goto LABEL_78;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v38 = gLogObj;
  os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
  *buf = 136446722;
  v118 = "nw_path_create_necp_agent_group_action";
  v119 = 2048;
  *v120 = 1;
  *&v120[8] = 2048;
  *&v120[10] = v31;
  v39 = _os_log_send_and_compose_impl();

  result = __nwlog_should_abort(v39);
  if ((result & 1) == 0)
  {
    free(v39);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v40 = gLogObj;
    *buf = 136446210;
    v118 = "nw_necp_append_tlv";
    v41 = _os_log_send_and_compose_impl();

    v109 = OS_LOG_TYPE_ERROR;
    v108 = 0;
    if (!__nwlog_fault(v41, &v109, &v108))
    {
      goto LABEL_71;
    }

    if (v109 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v42 = gLogObj;
      v43 = v109;
      if (os_log_type_enabled(v42, v109))
      {
        *buf = 136446210;
        v118 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A37000, v42, v43, "%{public}s called with null tlv_start", buf, 0xCu);
      }
    }

    else
    {
      if (v108 == 1)
      {
        v44 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v45 = gLogObj;
        v46 = v109;
        v47 = os_log_type_enabled(v45, v109);
        if (v44)
        {
          if (v47)
          {
            *buf = 136446466;
            v118 = "nw_necp_append_tlv";
            v119 = 2082;
            *v120 = v44;
            _os_log_impl(&dword_181A37000, v45, v46, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v44);
          v16 = v91;
          if (!v41)
          {
            goto LABEL_78;
          }

          goto LABEL_72;
        }

        if (v47)
        {
          *buf = 136446210;
          v118 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A37000, v45, v46, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
        }

LABEL_71:
        v16 = v91;
        if (!v41)
        {
          goto LABEL_78;
        }

LABEL_72:
        free(v41);
        goto LABEL_78;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v42 = gLogObj;
      v51 = v109;
      if (os_log_type_enabled(v42, v109))
      {
        *buf = 136446210;
        v118 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A37000, v42, v51, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_71;
  }

LABEL_161:
  __break(1u);
  return result;
}

void sub_182951488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, void *a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose(&a37, 8);

  _Unwind_Resume(a1);
}

void nw_path_flow_registration_clear_stats_regions(void *a1)
{
  v16 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    *(v1 + 120) = 0u;
    *(v1 + 104) = 0u;
    *(v1 + 88) = 0u;
    goto LABEL_3;
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v13 = "nw_path_flow_registration_clear_stats_regions";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v13 = "nw_path_flow_registration_clear_stats_regions";
        _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v10 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v7 = type;
      v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *buf = 136446466;
          v13 = "nw_path_flow_registration_clear_stats_regions";
          v14 = 2082;
          v15 = backtrace_string;
          _os_log_impl(&dword_181A37000, v4, v7, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v8)
      {
        *buf = 136446210;
        v13 = "nw_path_flow_registration_clear_stats_regions";
        _os_log_impl(&dword_181A37000, v4, v7, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v4 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v13 = "nw_path_flow_registration_clear_stats_regions";
        _os_log_impl(&dword_181A37000, v4, v9, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  v1 = 0;
LABEL_3:
}

void nw_path_flow_registration_set_partial_checksum_offload(void *a1, int a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    if (a2)
    {
      v4 = 2;
    }

    else
    {
      v4 = 0;
    }

    v3[148] = v3[148] & 0xFD | v4;
    goto LABEL_6;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_registration_set_partial_checksum_offload";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_registration_set_partial_checksum_offload";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_registration_set_partial_checksum_offload";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_registration_set_partial_checksum_offload";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_registration_set_partial_checksum_offload";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_6:
}

uint64_t nw_path_flow_registration_get_partial_checksum_offload(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = (v1[148] >> 1) & 1;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_path_flow_registration_get_partial_checksum_offload";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_get_partial_checksum_offload";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_path_flow_registration_get_partial_checksum_offload";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_get_partial_checksum_offload";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_get_partial_checksum_offload";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
  v1 = 0;
LABEL_3:

  return v2;
}

BOOL nw_path_increment_agent_use_count(void *a1, const unsigned __int8 *a2, void *a3)
{
  v46 = *MEMORY[0x1E69E9840];
  v5 = a1;
  v44 = 0uLL;
  v45 = 0;
  *a3 = 0;
  if (!v5)
  {
    v30 = __nwlog_obj();
    *buf = 136446210;
    v39 = "nw_path_increment_agent_use_count";
    v7 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v37 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v7, type, &v37))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v8 = __nwlog_obj();
        v31 = type[0];
        if (os_log_type_enabled(v8, type[0]))
        {
          *buf = 136446210;
          v39 = "nw_path_increment_agent_use_count";
          _os_log_impl(&dword_181A37000, v8, v31, "%{public}s called with null path", buf, 0xCu);
        }

LABEL_31:

        goto LABEL_32;
      }

      if (v37 != OS_LOG_TYPE_INFO)
      {
        v8 = __nwlog_obj();
        v35 = type[0];
        if (os_log_type_enabled(v8, type[0]))
        {
          *buf = 136446210;
          v39 = "nw_path_increment_agent_use_count";
          _os_log_impl(&dword_181A37000, v8, v35, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_31;
      }

      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v33 = type[0];
      v34 = os_log_type_enabled(v8, type[0]);
      if (!backtrace_string)
      {
        if (v34)
        {
          *buf = 136446210;
          v39 = "nw_path_increment_agent_use_count";
          _os_log_impl(&dword_181A37000, v8, v33, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }

        goto LABEL_31;
      }

      if (v34)
      {
        *buf = 136446466;
        v39 = "nw_path_increment_agent_use_count";
        v40 = 2082;
        v41[0] = backtrace_string;
        _os_log_impl(&dword_181A37000, v8, v33, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }

LABEL_32:
    if (v7)
    {
LABEL_33:
      free(v7);
    }

LABEL_34:
    v14 = 0;
    goto LABEL_35;
  }

  if (uuid_is_null(a2))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    *buf = 136446210;
    v39 = "nw_path_increment_agent_use_count";
    v7 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v37 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v7, type, &v37))
    {
      goto LABEL_32;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *buf = 136446210;
        v39 = "nw_path_increment_agent_use_count";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null agent_uuid", buf, 0xCu);
      }
    }

    else if (v37 == OS_LOG_TYPE_INFO)
    {
      v18 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v19 = type[0];
      v20 = os_log_type_enabled(v8, type[0]);
      if (v18)
      {
        if (v20)
        {
          *buf = 136446466;
          v39 = "nw_path_increment_agent_use_count";
          v40 = 2082;
          v41[0] = v18;
          _os_log_impl(&dword_181A37000, v8, v19, "%{public}s called with null agent_uuid, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v18);
        if (!v7)
        {
          goto LABEL_34;
        }

        goto LABEL_33;
      }

      if (v20)
      {
        *buf = 136446210;
        v39 = "nw_path_increment_agent_use_count";
        _os_log_impl(&dword_181A37000, v8, v19, "%{public}s called with null agent_uuid, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v21 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *buf = 136446210;
        v39 = "nw_path_increment_agent_use_count";
        _os_log_impl(&dword_181A37000, v8, v21, "%{public}s called with null agent_uuid, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_31;
  }

  v10 = _nw_path_copy_parameters(v5);
  v11 = nw_parameters_copy_context(v10);
  v12 = nw_path_shared_necp_fd(v11);

  if (v12 < 0)
  {
    goto LABEL_34;
  }

  v45 = 0;
  v44 = *a2;
  *type = 0;
  v43 = 0;
  _nw_path_get_client_id(v5, type);
  v13 = necp_client_action();
  v14 = v13 == 0;
  if (!v13)
  {
    *a3 = v45;
    goto LABEL_35;
  }

  v15 = **(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v16 = gLogObj;
  v17 = v16;
  if (v15 == 2)
  {
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *buf = 136446466;
      v39 = "nw_path_increment_agent_use_count";
      v40 = 1024;
      LODWORD(v41[0]) = 2;
      _os_log_impl(&dword_181A37000, v17, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d", buf, 0x12u);
    }

    goto LABEL_35;
  }

  *buf = 136446466;
  v39 = "nw_path_increment_agent_use_count";
  v40 = 1024;
  LODWORD(v41[0]) = v15;
  v22 = _os_log_send_and_compose_impl();

  v37 = OS_LOG_TYPE_ERROR;
  v36 = 0;
  if (!__nwlog_fault(v22, &v37, &v36))
  {
    goto LABEL_48;
  }

  if (v37 == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = gLogObj;
    v24 = v37;
    if (os_log_type_enabled(v23, v37))
    {
      *buf = 136446466;
      v39 = "nw_path_increment_agent_use_count";
      v40 = 1024;
      LODWORD(v41[0]) = v15;
      _os_log_impl(&dword_181A37000, v23, v24, "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d", buf, 0x12u);
    }

LABEL_47:

LABEL_48:
    if (!v22)
    {
      goto LABEL_35;
    }

LABEL_49:
    free(v22);
    goto LABEL_35;
  }

  if (v36 != 1)
  {
    v23 = __nwlog_obj();
    v29 = v37;
    if (os_log_type_enabled(v23, v37))
    {
      *buf = 136446466;
      v39 = "nw_path_increment_agent_use_count";
      v40 = 1024;
      LODWORD(v41[0]) = v15;
      _os_log_impl(&dword_181A37000, v23, v29, "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
    }

    goto LABEL_47;
  }

  v26 = __nw_create_backtrace_string();
  v23 = __nwlog_obj();
  v27 = v37;
  v28 = os_log_type_enabled(v23, v37);
  if (!v26)
  {
    if (v28)
    {
      *buf = 136446466;
      v39 = "nw_path_increment_agent_use_count";
      v40 = 1024;
      LODWORD(v41[0]) = v15;
      _os_log_impl(&dword_181A37000, v23, v27, "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d, no backtrace", buf, 0x12u);
    }

    goto LABEL_47;
  }

  if (v28)
  {
    *buf = 136446722;
    v39 = "nw_path_increment_agent_use_count";
    v40 = 1024;
    LODWORD(v41[0]) = v15;
    WORD2(v41[0]) = 2082;
    *(v41 + 6) = v26;
    _os_log_impl(&dword_181A37000, v23, v27, "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
  }

  free(v26);
  if (v22)
  {
    goto LABEL_49;
  }

LABEL_35:

  return v14;
}

uint64_t __nw_path_uses_companion_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  is_companion_proxy = nw_proxy_config_get_is_companion_proxy(a3);
  if (is_companion_proxy)
  {
    *(*(*(a1 + 32) + 8) + 24) = 1;
  }

  return is_companion_proxy ^ 1u;
}

uint64_t __nw_path_uses_companion_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (strcmp((a2 + 16), "com.apple.networkrelay") || strcmp((a2 + 48), "ASResolver") && strcmp((a2 + 48), "ASListener"))
  {
    return 1;
  }

  result = 0;
  *(*(*(a1 + 32) + 8) + 24) = 1;
  return result;
}

uint64_t nw_path_flow_registration_get_tfo_cookie(void *a1, void *a2, void *a3, _BYTE *a4)
{
  v45 = *MEMORY[0x1E69E9840];
  v7 = a1;
  v8 = a2;
  if (!a3)
  {
    v25 = __nwlog_obj();
    *buf = 136446210;
    v40 = "nw_path_flow_registration_get_tfo_cookie";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v11, &type, &v37))
    {
      goto LABEL_22;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *buf = 136446210;
        v40 = "nw_path_flow_registration_get_tfo_cookie";
        _os_log_impl(&dword_181A37000, v26, v27, "%{public}s called with null cookie", buf, 0xCu);
      }

      goto LABEL_57;
    }

    if (v37 != 1)
    {
      v26 = __nwlog_obj();
      v35 = type;
      if (os_log_type_enabled(v26, type))
      {
        *buf = 136446210;
        v40 = "nw_path_flow_registration_get_tfo_cookie";
        _os_log_impl(&dword_181A37000, v26, v35, "%{public}s called with null cookie, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_57;
    }

    backtrace_string = __nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v31 = type;
    v32 = os_log_type_enabled(v26, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *buf = 136446210;
        v40 = "nw_path_flow_registration_get_tfo_cookie";
        _os_log_impl(&dword_181A37000, v26, v31, "%{public}s called with null cookie, no backtrace", buf, 0xCu);
      }

      goto LABEL_57;
    }

    if (v32)
    {
      *buf = 136446466;
      v40 = "nw_path_flow_registration_get_tfo_cookie";
      v41 = 2082;
      *v42 = backtrace_string;
      _os_log_impl(&dword_181A37000, v26, v31, "%{public}s called with null cookie, dumping backtrace:%{public}s", buf, 0x16u);
    }

    goto LABEL_45;
  }

  if (!a4)
  {
    v28 = __nwlog_obj();
    *buf = 136446210;
    v40 = "nw_path_flow_registration_get_tfo_cookie";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v11, &type, &v37))
    {
      goto LABEL_22;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v29 = type;
      if (os_log_type_enabled(v26, type))
      {
        *buf = 136446210;
        v40 = "nw_path_flow_registration_get_tfo_cookie";
        _os_log_impl(&dword_181A37000, v26, v29, "%{public}s called with null len", buf, 0xCu);
      }

LABEL_57:

      goto LABEL_22;
    }

    if (v37 != 1)
    {
      v26 = __nwlog_obj();
      v36 = type;
      if (os_log_type_enabled(v26, type))
      {
        *buf = 136446210;
        v40 = "nw_path_flow_registration_get_tfo_cookie";
        _os_log_impl(&dword_181A37000, v26, v36, "%{public}s called with null len, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_57;
    }

    backtrace_string = __nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v33 = type;
    v34 = os_log_type_enabled(v26, type);
    if (!backtrace_string)
    {
      if (v34)
      {
        *buf = 136446210;
        v40 = "nw_path_flow_registration_get_tfo_cookie";
        _os_log_impl(&dword_181A37000, v26, v33, "%{public}s called with null len, no backtrace", buf, 0xCu);
      }

      goto LABEL_57;
    }

    if (v34)
    {
      *buf = 136446466;
      v40 = "nw_path_flow_registration_get_tfo_cookie";
      v41 = 2082;
      *v42 = backtrace_string;
      _os_log_impl(&dword_181A37000, v26, v33, "%{public}s called with null len, dumping backtrace:%{public}s", buf, 0x16u);
    }

LABEL_45:

    free(backtrace_string);
    goto LABEL_22;
  }

  if (*a4 <= 0xFu)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    v10 = *a4;
    *buf = 136446722;
    v40 = "nw_path_flow_registration_get_tfo_cookie";
    v41 = 1024;
    *v42 = v10;
    *&v42[4] = 1024;
    *&v42[6] = 16;
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault(v11, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          v14 = *a4;
          *buf = 136446722;
          v40 = "nw_path_flow_registration_get_tfo_cookie";
          v41 = 1024;
          *v42 = v14;
          *&v42[4] = 1024;
          *&v42[6] = 16;
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s cookie buffer invalid, length is %u expected %d", buf, 0x18u);
        }
      }

      else if (v37 == 1)
      {
        v17 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v18 = type;
        v19 = os_log_type_enabled(v12, type);
        if (v17)
        {
          if (v19)
          {
            v20 = *a4;
            *buf = 136446978;
            v40 = "nw_path_flow_registration_get_tfo_cookie";
            v41 = 1024;
            *v42 = v20;
            *&v42[4] = 1024;
            *&v42[6] = 16;
            v43 = 2082;
            v44 = v17;
            _os_log_impl(&dword_181A37000, v12, v18, "%{public}s cookie buffer invalid, length is %u expected %d, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(v17);
          if (!v11)
          {
            goto LABEL_24;
          }

          goto LABEL_23;
        }

        if (v19)
        {
          v23 = *a4;
          *buf = 136446722;
          v40 = "nw_path_flow_registration_get_tfo_cookie";
          v41 = 1024;
          *v42 = v23;
          *&v42[4] = 1024;
          *&v42[6] = 16;
          _os_log_impl(&dword_181A37000, v12, v18, "%{public}s cookie buffer invalid, length is %u expected %d, no backtrace", buf, 0x18u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          v22 = *a4;
          *buf = 136446722;
          v40 = "nw_path_flow_registration_get_tfo_cookie";
          v41 = 1024;
          *v42 = v22;
          *&v42[4] = 1024;
          *&v42[6] = 16;
          _os_log_impl(&dword_181A37000, v12, v21, "%{public}s cookie buffer invalid, length is %u expected %d, backtrace limit exceeded", buf, 0x18u);
        }
      }
    }

LABEL_22:
    if (!v11)
    {
LABEL_24:
      tfo_cookie = 0;
      goto LABEL_25;
    }

LABEL_23:
    free(v11);
    goto LABEL_24;
  }

  v15 = nw_path_copy_flow_for_registration(v7, v8);
  tfo_cookie = _nw_path_flow_get_tfo_cookie(v15, a3, a4);

LABEL_25:
  return tfo_cookie;
}

uint64_t nw_path_flow_registration_get_tfo_cookie_len(NWConcrete_nw_path *a1, NWConcrete_nw_path_flow_registration *a2)
{
  v2 = nw_path_copy_flow_for_registration(a1, a2);
  tfo_cookie_len = _nw_path_flow_get_tfo_cookie_len(v2);

  return tfo_cookie_len;
}

uint64_t nw_path_get_recommended_mss(void *a1)
{
  v22 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    recommended_mss = _nw_path_get_recommended_mss(v1);
    if (recommended_mss == 2)
    {
      v4 = 512;
    }

    else
    {
      v4 = recommended_mss;
    }

    if (recommended_mss == 4)
    {
      v5 = 1200;
    }

    else
    {
      v5 = v4;
    }

    if (recommended_mss == 1)
    {
      v6 = 0;
    }

    else
    {
      v6 = v5;
    }

    goto LABEL_11;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  v19 = "nw_path_get_recommended_mss";
  v9 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v19 = "nw_path_get_recommended_mss";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v16 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v19 = "nw_path_get_recommended_mss";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }

      if (v14)
      {
        *buf = 136446210;
        v19 = "nw_path_get_recommended_mss";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v19 = "nw_path_get_recommended_mss";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_28:
  if (v9)
  {
    free(v9);
  }

  v6 = 0;
LABEL_11:

  return v6;
}

uint64_t nw_path_copy_flow_divert_token(void *a1)
{
  v64 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v47 = __nwlog_obj();
    LODWORD(bytes[0]) = 136446210;
    *(bytes + 4) = "nw_path_copy_flow_divert_token";
    v48 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    uu[0] = 0;
    if (__nwlog_fault(v48, type, uu))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v49 = __nwlog_obj();
        v50 = type[0];
        if (os_log_type_enabled(v49, type[0]))
        {
          LODWORD(bytes[0]) = 136446210;
          *(bytes + 4) = "nw_path_copy_flow_divert_token";
          _os_log_impl(&dword_181A37000, v49, v50, "%{public}s called with null path", bytes, 0xCu);
        }
      }

      else if (uu[0] == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v49 = __nwlog_obj();
        v52 = type[0];
        v53 = os_log_type_enabled(v49, type[0]);
        if (backtrace_string)
        {
          if (v53)
          {
            LODWORD(bytes[0]) = 136446466;
            *(bytes + 4) = "nw_path_copy_flow_divert_token";
            WORD2(bytes[1]) = 2082;
            *(&bytes[1] + 6) = backtrace_string;
            _os_log_impl(&dword_181A37000, v49, v52, "%{public}s called with null path, dumping backtrace:%{public}s", bytes, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_97;
        }

        if (v53)
        {
          LODWORD(bytes[0]) = 136446210;
          *(bytes + 4) = "nw_path_copy_flow_divert_token";
          _os_log_impl(&dword_181A37000, v49, v52, "%{public}s called with null path, no backtrace", bytes, 0xCu);
        }
      }

      else
      {
        v49 = __nwlog_obj();
        v54 = type[0];
        if (os_log_type_enabled(v49, type[0]))
        {
          LODWORD(bytes[0]) = 136446210;
          *(bytes + 4) = "nw_path_copy_flow_divert_token";
          _os_log_impl(&dword_181A37000, v49, v54, "%{public}s called with null path, backtrace limit exceeded", bytes, 0xCu);
        }
      }
    }

LABEL_97:
    if (v48)
    {
      free(v48);
    }

    goto LABEL_3;
  }

  flow_divert_unit = _nw_path_get_flow_divert_unit(v1);
  flow_divert_aggregate_unit = _nw_path_get_flow_divert_aggregate_unit(v2);
  if (flow_divert_unit | flow_divert_aggregate_unit)
  {
    v6 = xpc_dictionary_create(0, 0, 0);
    if (v6)
    {
      memset(uu, 0, sizeof(uu));
      if ((nw_path_get_vpn_config_uuid(v2, uu, 0, 0, 0) & 1) == 0)
      {
        uuid_clear(uu);
      }

      v7 = _nw_path_copy_endpoint(v2);
      v8 = v7;
      if (!v7)
      {
        goto LABEL_74;
      }

      v9 = v7;
      v10 = _nw_endpoint_get_type(v9);

      if ((v10 - 1) > 1)
      {
        goto LABEL_74;
      }

      if (v10 == 1)
      {
        memset(bytes, 0, sizeof(bytes));
        v62 = 0;
        if (nw_endpoint_fillout_v4v6_address(v9, bytes))
        {
          xpc_dictionary_set_data(v6, "flow-host-address", bytes, LOBYTE(bytes[0]));
LABEL_65:
          v39 = v9;
          parent_endpoint_domain = _nw_endpoint_get_parent_endpoint_domain(v39);

          if (parent_endpoint_domain)
          {
            xpc_dictionary_set_string(v6, "flow-host-name", parent_endpoint_domain);
          }

          goto LABEL_72;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        *type = 136446210;
        v58 = "nw_path_copy_flow_divert_token";
        v23 = _os_log_send_and_compose_impl();

        v56 = OS_LOG_TYPE_ERROR;
        v55 = 0;
        if (__nwlog_fault(v23, &v56, &v55))
        {
          if (v56 == OS_LOG_TYPE_FAULT)
          {
            v24 = __nwlog_obj();
            v25 = v56;
            if (os_log_type_enabled(v24, v56))
            {
              *type = 136446210;
              v58 = "nw_path_copy_flow_divert_token";
              _os_log_impl(&dword_181A37000, v24, v25, "%{public}s nw_endpoint_get_address failed", type, 0xCu);
            }
          }

          else if (v55 == 1)
          {
            v31 = __nw_create_backtrace_string();
            v24 = __nwlog_obj();
            v32 = v56;
            v33 = os_log_type_enabled(v24, v56);
            if (v31)
            {
              if (v33)
              {
                *type = 136446466;
                v58 = "nw_path_copy_flow_divert_token";
                v59 = 2082;
                v60 = v31;
                _os_log_impl(&dword_181A37000, v24, v32, "%{public}s nw_endpoint_get_address failed, dumping backtrace:%{public}s", type, 0x16u);
              }

              free(v31);
              goto LABEL_63;
            }

            if (v33)
            {
              *type = 136446210;
              v58 = "nw_path_copy_flow_divert_token";
              _os_log_impl(&dword_181A37000, v24, v32, "%{public}s nw_endpoint_get_address failed, no backtrace", type, 0xCu);
            }
          }

          else
          {
            v24 = __nwlog_obj();
            v37 = v56;
            if (os_log_type_enabled(v24, v56))
            {
              *type = 136446210;
              v58 = "nw_path_copy_flow_divert_token";
              _os_log_impl(&dword_181A37000, v24, v37, "%{public}s nw_endpoint_get_address failed, backtrace limit exceeded", type, 0xCu);
            }
          }
        }

LABEL_63:
        if (v23)
        {
          free(v23);
        }

        goto LABEL_65;
      }

      v19 = v9;
      hostname = _nw_endpoint_get_hostname(v19);

      if (hostname)
      {
        xpc_dictionary_set_string(v6, "flow-host-name", hostname);
LABEL_72:
        v41 = v9;
        port = _nw_endpoint_get_port(v41);

        if (port)
        {
          xpc_dictionary_set_int64(v6, "flow-host-port", port);
        }

LABEL_74:
        v43 = _nw_path_copy_parameters(v2);
        nw_parameters_get_effective_bundle_id(v43);
        multipath = nw_parameters_get_multipath(v43);
        xpc_dictionary_set_BOOL(v6, "flow-multipath-requested", multipath);
        v45 = nw_parameters_copy_metadata(v43);
        if (v45)
        {
          xpc_dictionary_set_value(v6, "app-data", v45);
        }

        if (flow_divert_aggregate_unit)
        {
          xpc_dictionary_set_uint64(v6, "aggregate_unit", flow_divert_aggregate_unit);
        }

        v5 = ne_session_policy_copy_flow_divert_token();

        goto LABEL_79;
      }

      v26 = __nwlog_obj();
      LODWORD(bytes[0]) = 136446210;
      *(bytes + 4) = "nw_path_copy_flow_divert_token";
      v27 = _os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v56 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v27, type, &v56))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v28 = __nwlog_obj();
          v29 = type[0];
          if (os_log_type_enabled(v28, type[0]))
          {
            LODWORD(bytes[0]) = 136446210;
            *(bytes + 4) = "nw_path_copy_flow_divert_token";
            _os_log_impl(&dword_181A37000, v28, v29, "%{public}s nw_endpoint_get_hostname failed", bytes, 0xCu);
          }
        }

        else if (v56 == OS_LOG_TYPE_INFO)
        {
          v34 = __nw_create_backtrace_string();
          v28 = __nwlog_obj();
          v35 = type[0];
          v36 = os_log_type_enabled(v28, type[0]);
          if (v34)
          {
            if (v36)
            {
              LODWORD(bytes[0]) = 136446466;
              *(bytes + 4) = "nw_path_copy_flow_divert_token";
              WORD2(bytes[1]) = 2082;
              *(&bytes[1] + 6) = v34;
              _os_log_impl(&dword_181A37000, v28, v35, "%{public}s nw_endpoint_get_hostname failed, dumping backtrace:%{public}s", bytes, 0x16u);
            }

            free(v34);
            goto LABEL_70;
          }

          if (v36)
          {
            LODWORD(bytes[0]) = 136446210;
            *(bytes + 4) = "nw_path_copy_flow_divert_token";
            _os_log_impl(&dword_181A37000, v28, v35, "%{public}s nw_endpoint_get_hostname failed, no backtrace", bytes, 0xCu);
          }
        }

        else
        {
          v28 = __nwlog_obj();
          v38 = type[0];
          if (os_log_type_enabled(v28, type[0]))
          {
            LODWORD(bytes[0]) = 136446210;
            *(bytes + 4) = "nw_path_copy_flow_divert_token";
            _os_log_impl(&dword_181A37000, v28, v38, "%{public}s nw_endpoint_get_hostname failed, backtrace limit exceeded", bytes, 0xCu);
          }
        }
      }

LABEL_70:
      if (v27)
      {
        free(v27);
      }

      goto LABEL_72;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = gLogObj;
    LODWORD(bytes[0]) = 136446210;
    *(bytes + 4) = "nw_path_copy_flow_divert_token";
    v12 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    uu[0] = 0;
    if (__nwlog_fault(v12, type, uu))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v14 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          LODWORD(bytes[0]) = 136446210;
          *(bytes + 4) = "nw_path_copy_flow_divert_token";
          _os_log_impl(&dword_181A37000, v13, v14, "%{public}s xpc_dictionary_create failed", bytes, 0xCu);
        }
      }

      else if (uu[0] == 1)
      {
        v15 = __nw_create_backtrace_string();
        if (v15)
        {
          v16 = v15;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v17 = gLogObj;
          v18 = type[0];
          if (os_log_type_enabled(v17, type[0]))
          {
            LODWORD(bytes[0]) = 136446466;
            *(bytes + 4) = "nw_path_copy_flow_divert_token";
            WORD2(bytes[1]) = 2082;
            *(&bytes[1] + 6) = v16;
            _os_log_impl(&dword_181A37000, v17, v18, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", bytes, 0x16u);
          }

          free(v16);
          if (!v12)
          {
            goto LABEL_43;
          }

          goto LABEL_42;
        }

        v13 = __nwlog_obj();
        v30 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          LODWORD(bytes[0]) = 136446210;
          *(bytes + 4) = "nw_path_copy_flow_divert_token";
          _os_log_impl(&dword_181A37000, v13, v30, "%{public}s xpc_dictionary_create failed, no backtrace", bytes, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v21 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          LODWORD(bytes[0]) = 136446210;
          *(bytes + 4) = "nw_path_copy_flow_divert_token";
          _os_log_impl(&dword_181A37000, v13, v21, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", bytes, 0xCu);
        }
      }
    }

    if (!v12)
    {
LABEL_43:
      v5 = 0;
LABEL_79:

      goto LABEL_80;
    }

LABEL_42:
    free(v12);
    goto LABEL_43;
  }

LABEL_3:
  v5 = 0;
LABEL_80:

  return v5;
}

uint64_t nw_path_has_unsatisfied_fallback_agent(NWConcrete_nw_path *a1)
{
  v4 = *MEMORY[0x1E69E9840];
  v2 = 0;
  memset(v3, 0, sizeof(v3));
  return nw_path_get_vpn_config_uuid(a1, v3, &v2, 1, 1);
}

uint64_t nw_path_voluntary_agent_matches_address(void *a1, uint64_t a2)
{
  v30 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v12 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_path_voluntary_agent_matches_address";
    v13 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v13, type, &v28))
    {
      goto LABEL_43;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_path_voluntary_agent_matches_address";
        _os_log_impl(&dword_181A37000, v14, v15, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v28 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v19 = type[0];
      v20 = os_log_type_enabled(v14, type[0]);
      if (backtrace_string)
      {
        if (v20)
        {
          *buf = 136446466;
          *&buf[4] = "nw_path_voluntary_agent_matches_address";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v14, v19, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v13)
        {
          goto LABEL_45;
        }

        goto LABEL_44;
      }

      if (v20)
      {
        *buf = 136446210;
        *&buf[4] = "nw_path_voluntary_agent_matches_address";
        _os_log_impl(&dword_181A37000, v14, v19, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v14 = __nwlog_obj();
      v24 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_path_voluntary_agent_matches_address";
        _os_log_impl(&dword_181A37000, v14, v24, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_42;
  }

  if (!a2)
  {
    v16 = __nwlog_obj();
    *buf = 136446210;
    *&buf[4] = "nw_path_voluntary_agent_matches_address";
    v13 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v13, type, &v28))
    {
      goto LABEL_43;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v17 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_path_voluntary_agent_matches_address";
        _os_log_impl(&dword_181A37000, v14, v17, "%{public}s called with null address", buf, 0xCu);
      }
    }

    else if (v28 == 1)
    {
      v21 = __nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v22 = type[0];
      v23 = os_log_type_enabled(v14, type[0]);
      if (v21)
      {
        if (v23)
        {
          *buf = 136446466;
          *&buf[4] = "nw_path_voluntary_agent_matches_address";
          *&buf[12] = 2082;
          *&buf[14] = v21;
          _os_log_impl(&dword_181A37000, v14, v22, "%{public}s called with null address, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v21);
LABEL_43:
        if (!v13)
        {
LABEL_45:
          v11 = 0;
          goto LABEL_46;
        }

LABEL_44:
        free(v13);
        goto LABEL_45;
      }

      if (v23)
      {
        *buf = 136446210;
        *&buf[4] = "nw_path_voluntary_agent_matches_address";
        _os_log_impl(&dword_181A37000, v14, v22, "%{public}s called with null address, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v14 = __nwlog_obj();
      v25 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *buf = 136446210;
        *&buf[4] = "nw_path_voluntary_agent_matches_address";
        _os_log_impl(&dword_181A37000, v14, v25, "%{public}s called with null address, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_42:

    goto LABEL_43;
  }

  v5 = _nw_path_copy_endpoint(v3);
  v6 = nw_endpoint_get_type(v5);

  if (v6 != nw_endpoint_type_host)
  {
    goto LABEL_45;
  }

  v7 = _nw_path_copy_endpoint(v4);
  hostname = nw_endpoint_get_hostname(v7);

  if (!hostname)
  {
    goto LABEL_45;
  }

  *type = 0;
  *buf = 0;
  *&buf[8] = 0;
  if ((nw_path_get_vpn_config_uuid(v4, buf, type, 1, 1) & 1) == 0)
  {
    goto LABEL_45;
  }

  v9 = _nw_path_copy_direct_interface(v4);
  v10 = v9;
  if (v9)
  {
    _nw_interface_get_name(v9);
    v11 = ne_session_service_matches_address_for_interface();
  }

  else
  {
    v11 = 0;
  }

LABEL_46:
  return v11;
}

uint64_t nw_path_get_fallback_agent(void *a1, _OWORD *a2)
{
  v18 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *buf = 0;
    *&buf[8] = 0;
    fallback_agent = _nw_path_get_fallback_agent(v3, buf);
    if (fallback_agent)
    {
      *a2 = *buf;
    }

    goto LABEL_4;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  *&buf[4] = "nw_path_get_fallback_agent";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_path_get_fallback_agent";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          *&buf[4] = "nw_path_get_fallback_agent";
          *&buf[12] = 2082;
          *&buf[14] = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v13)
      {
        *buf = 136446210;
        *&buf[4] = "nw_path_get_fallback_agent";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        *&buf[4] = "nw_path_get_fallback_agent";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_21:
  if (v8)
  {
    free(v8);
  }

  fallback_agent = 0;
LABEL_4:

  return fallback_agent;
}

uint64_t nw_path_get_fallback_generation(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    fallback_generation = _nw_path_get_fallback_generation(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_get_fallback_generation";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_get_fallback_generation";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_get_fallback_generation";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_get_fallback_generation";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_get_fallback_generation";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  fallback_generation = 0;
LABEL_3:

  return fallback_generation;
}

id nw_path_bridge_config_agent_update_proxy_information(void *a1)
{
  v1 = a1;
  v2 = config_agent_update_proxy_information();
  v3 = v2;
  if (v2)
  {
    v4 = v2;

    v1 = v4;
  }

  if (object_getClass(v1) == MEMORY[0x1E69E9E50])
  {
    v5 = nw_proxy_configs_create_with_schema_array(v1);
  }

  else
  {
    v5 = 0;
  }

  return v5;
}

void nw_path_set_proxy_settings(void *a1, void *a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    _nw_path_set_proxy_settings(v3, v4);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_set_proxy_settings";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_set_proxy_settings";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_set_proxy_settings";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_set_proxy_settings";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_set_proxy_settings";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

LABEL_3:
}

uint64_t nw_path_allows_multipath(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_allows_multipath(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_allows_multipath";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_allows_multipath";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_allows_multipath";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_allows_multipath";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_allows_multipath";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_path_has_gateways(void *a1)
{
  v21 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_copy_gateways(v1);
    v4 = v3;
    if (v3)
    {
      v5 = !_nw_array_is_empty(v3);
    }

    else
    {
      v5 = 0;
    }

    goto LABEL_6;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_path_has_gateways";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_has_gateways";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v18 = "nw_path_has_gateways";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v13)
      {
        *buf = 136446210;
        v18 = "nw_path_has_gateways";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_has_gateways";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v8)
  {
    free(v8);
  }

  v5 = 0;
LABEL_6:

  return v5;
}

uint64_t nw_path_copy_resolver_config_for_identifier()
{
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
  {
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }

  v0 = nw_context_copy_implicit_context::implicit_context;
  v1 = nw_path_shared_necp_fd(v0);

  if ((v1 & 0x80000000) != 0)
  {
    return 0;
  }

  result = nw_network_agent_copy_data(v1);
  if (result)
  {
    v3 = result;
    v4 = xpc_create_from_plist();
    v5 = v4;
    if (v4)
    {
      v6 = nw_resolver_config_create_with_dictionary(v4);
    }

    else
    {
      v6 = 0;
    }

    free(v3);
    return v6;
  }

  return result;
}

BOOL nw_path_has_browse_descriptor(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_get_browse_descriptor(v1);
    v4 = v3 != 0;

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_path_has_browse_descriptor";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_path_has_browse_descriptor";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v17 = "nw_path_has_browse_descriptor";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v17 = "nw_path_has_browse_descriptor";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_path_has_browse_descriptor";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

  v4 = 0;
LABEL_3:

  return v4;
}

BOOL nw_path_has_advertise_descriptor(void *a1)
{
  v20 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_get_advertise_descriptor(v1);
    v4 = v3 != 0;

    goto LABEL_3;
  }

  v6 = __nwlog_obj();
  *buf = 136446210;
  v17 = "nw_path_has_advertise_descriptor";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_path_has_advertise_descriptor";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v14 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *buf = 136446466;
          v17 = "nw_path_has_advertise_descriptor";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *buf = 136446210;
        v17 = "nw_path_has_advertise_descriptor";
        _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v17 = "nw_path_has_advertise_descriptor";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v7)
  {
    free(v7);
  }

  v4 = 0;
LABEL_3:

  return v4;
}

char *nw_path_flow_copy_resolved_endpoints(void *a1, uint64_t a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = _nw_path_flow_copy_resolved_endpoints(v3, a2);
    goto LABEL_3;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_path_flow_copy_resolved_endpoints";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_flow_copy_resolved_endpoints";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v18 = "nw_path_flow_copy_resolved_endpoints";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *buf = 136446210;
        v18 = "nw_path_flow_copy_resolved_endpoints";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_flow_copy_resolved_endpoints";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v8)
  {
    free(v8);
  }

  v5 = 0;
LABEL_3:

  return v5;
}

void nw_path_enumerate_group_options(void *a1, void *a2)
{
  v26 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    v6 = __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_path_enumerate_group_options";
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
    {
      goto LABEL_38;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v23 = "nw_path_enumerate_group_options";
        _os_log_impl(&dword_181A37000, v8, v9, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v23 = "nw_path_enumerate_group_options";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7)
        {
          goto LABEL_4;
        }

LABEL_39:
        free(v7);
        goto LABEL_4;
      }

      if (v14)
      {
        *buf = 136446210;
        v23 = "nw_path_enumerate_group_options";
        _os_log_impl(&dword_181A37000, v8, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v8 = __nwlog_obj();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *buf = 136446210;
        v23 = "nw_path_enumerate_group_options";
        _os_log_impl(&dword_181A37000, v8, v18, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_37:

    goto LABEL_38;
  }

  if (v4)
  {
    _nw_path_enumerate_group_options(v3, v4);
    goto LABEL_4;
  }

  v10 = __nwlog_obj();
  *buf = 136446210;
  v23 = "nw_path_enumerate_group_options";
  v7 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20))
  {
    goto LABEL_38;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *buf = 136446210;
      v23 = "nw_path_enumerate_group_options";
      _os_log_impl(&dword_181A37000, v8, v11, "%{public}s called with null enumerate_block", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v20 != 1)
  {
    v8 = __nwlog_obj();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *buf = 136446210;
      v23 = "nw_path_enumerate_group_options";
      _os_log_impl(&dword_181A37000, v8, v19, "%{public}s called with null enumerate_block, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_37;
  }

  v15 = __nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *buf = 136446210;
      v23 = "nw_path_enumerate_group_options";
      _os_log_impl(&dword_181A37000, v8, v16, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
    }

    goto LABEL_37;
  }

  if (v17)
  {
    *buf = 136446466;
    v23 = "nw_path_enumerate_group_options";
    v24 = 2082;
    v25 = v15;
    _os_log_impl(&dword_181A37000, v8, v16, "%{public}s called with null enumerate_block, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
  {
    goto LABEL_39;
  }

LABEL_4:
}

uint64_t nw_path_has_flow_for_nexus_agent(void *a1, unsigned __int8 *a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    has_flow_for_nexus_agent = _nw_path_has_flow_for_nexus_agent(v3, a2);
    goto LABEL_3;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_path_has_flow_for_nexus_agent";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_has_flow_for_nexus_agent";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v18 = "nw_path_has_flow_for_nexus_agent";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *buf = 136446210;
        v18 = "nw_path_has_flow_for_nexus_agent";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_has_flow_for_nexus_agent";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v8)
  {
    free(v8);
  }

  has_flow_for_nexus_agent = 0;
LABEL_3:

  return has_flow_for_nexus_agent;
}

uint64_t nw_path_interface_prohibited_by_parameters(void *a1, void *a2)
{
  v36 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3)
  {
    if (v4)
    {
      v6 = _nw_path_copy_parameters(v3);
      if (v6)
      {
        v7 = _nw_path_interface_prohibited_by_parameters(v3, v5);
LABEL_5:

        goto LABEL_6;
      }

      v15 = __nwlog_obj();
      *buf = 136446210;
      v33 = "nw_path_interface_prohibited_by_parameters";
      v16 = _os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v30 = 0;
      if (__nwlog_fault(v16, &type, &v30))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v17 = __nwlog_obj();
          v18 = type;
          if (os_log_type_enabled(v17, type))
          {
            *buf = 136446210;
            v33 = "nw_path_interface_prohibited_by_parameters";
            _os_log_impl(&dword_181A37000, v17, v18, "%{public}s called with null parameters", buf, 0xCu);
          }
        }

        else if (v30 == 1)
        {
          backtrace_string = __nw_create_backtrace_string();
          v17 = __nwlog_obj();
          v25 = type;
          v26 = os_log_type_enabled(v17, type);
          if (backtrace_string)
          {
            if (v26)
            {
              *buf = 136446466;
              v33 = "nw_path_interface_prohibited_by_parameters";
              v34 = 2082;
              v35 = backtrace_string;
              _os_log_impl(&dword_181A37000, v17, v25, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_58;
          }

          if (v26)
          {
            *buf = 136446210;
            v33 = "nw_path_interface_prohibited_by_parameters";
            _os_log_impl(&dword_181A37000, v17, v25, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          v17 = __nwlog_obj();
          v29 = type;
          if (os_log_type_enabled(v17, type))
          {
            *buf = 136446210;
            v33 = "nw_path_interface_prohibited_by_parameters";
            _os_log_impl(&dword_181A37000, v17, v29, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }

LABEL_58:
      if (v16)
      {
        free(v16);
      }

      v7 = 0;
      goto LABEL_5;
    }

    v13 = __nwlog_obj();
    *buf = 136446210;
    v33 = "nw_path_interface_prohibited_by_parameters";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v10, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          v33 = "nw_path_interface_prohibited_by_parameters";
          _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null interface", buf, 0xCu);
        }

LABEL_51:

        goto LABEL_52;
      }

      if (v30 != 1)
      {
        v11 = __nwlog_obj();
        v28 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          v33 = "nw_path_interface_prohibited_by_parameters";
          _os_log_impl(&dword_181A37000, v11, v28, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_51;
      }

      v19 = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v22 = type;
      v23 = os_log_type_enabled(v11, type);
      if (!v19)
      {
        if (v23)
        {
          *buf = 136446210;
          v33 = "nw_path_interface_prohibited_by_parameters";
          _os_log_impl(&dword_181A37000, v11, v22, "%{public}s called with null interface, no backtrace", buf, 0xCu);
        }

        goto LABEL_51;
      }

      if (v23)
      {
        *buf = 136446466;
        v33 = "nw_path_interface_prohibited_by_parameters";
        v34 = 2082;
        v35 = v19;
        _os_log_impl(&dword_181A37000, v11, v22, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_31;
    }
  }

  else
  {
    v9 = __nwlog_obj();
    *buf = 136446210;
    v33 = "nw_path_interface_prohibited_by_parameters";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v10, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          v33 = "nw_path_interface_prohibited_by_parameters";
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null path", buf, 0xCu);
        }

        goto LABEL_51;
      }

      if (v30 != 1)
      {
        v11 = __nwlog_obj();
        v27 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          v33 = "nw_path_interface_prohibited_by_parameters";
          _os_log_impl(&dword_181A37000, v11, v27, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_51;
      }

      v19 = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v20 = type;
      v21 = os_log_type_enabled(v11, type);
      if (!v19)
      {
        if (v21)
        {
          *buf = 136446210;
          v33 = "nw_path_interface_prohibited_by_parameters";
          _os_log_impl(&dword_181A37000, v11, v20, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }

        goto LABEL_51;
      }

      if (v21)
      {
        *buf = 136446466;
        v33 = "nw_path_interface_prohibited_by_parameters";
        v34 = 2082;
        v35 = v19;
        _os_log_impl(&dword_181A37000, v11, v20, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_31:

      free(v19);
    }
  }

LABEL_52:
  if (v10)
  {
    free(v10);
  }

  v7 = 0;
LABEL_6:

  return v7;
}

uint64_t nw_path_get_estimated_upload_throughput_internal(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_throughput_estimates_up(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_get_estimated_upload_throughput_internal";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_get_estimated_upload_throughput_internal";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_get_estimated_upload_throughput_internal";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_get_estimated_upload_throughput_internal";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_get_estimated_upload_throughput_internal";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_get_estimated_download_throughput_internal(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_throughput_estimates_down(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_get_estimated_download_throughput_internal";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_get_estimated_download_throughput_internal";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_get_estimated_download_throughput_internal";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_get_estimated_download_throughput_internal";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_get_estimated_download_throughput_internal";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_get_estimated_upload_throughput(void *a1)
{
  v37 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    v4 = v3;
    if (nw_path_report_estimated_throughput_usage(NWConcrete_nw_path *,BOOL)::usage_report_count > 0x3E7)
    {
      if (gLogDatapath != 1)
      {
LABEL_20:

        v14 = _nw_path_throughput_estimates_up(v4);
        goto LABEL_21;
      }

      v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446210;
        v34 = "nw_path_report_estimated_throughput_usage";
        _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_DEBUG, "%{public}s Estimated throughput usage exceeded cap, ignoring", buf, 0xCu);
      }

LABEL_19:

      goto LABEL_20;
    }

    ++nw_path_report_estimated_throughput_usage(NWConcrete_nw_path *,BOOL)::usage_report_count;
    v5 = nw_path_prepare_report_usage_dictionary(v3);
    if (v5)
    {
      v6 = _nw_path_throughput_estimates_down(v4);
      v7 = _nw_path_throughput_estimates_up(v4);
      xpc_dictionary_set_uint64(v5, "download_estimate", v6);
      xpc_dictionary_set_uint64(v5, "upload_estimate", v7);
      xpc_dictionary_set_string(v5, "direction", "upload");
      v8 = xpc_dictionary_copy_basic_description();
      if (gLogDatapath == 1)
      {
        v29 = __nwlog_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          *buf = 136446466;
          v34 = "nw_path_report_estimated_throughput_usage";
          v35 = 2080;
          v36 = v8;
          _os_log_impl(&dword_181A37000, v29, OS_LOG_TYPE_DEBUG, "%{public}s Estimated throughput: %s", buf, 0x16u);
        }
      }

      if (v8)
      {
        free(v8);
      }

      analytics_send_event_delayInitStub(v9);
      goto LABEL_19;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    *buf = 136446210;
    v34 = "nw_path_report_estimated_throughput_usage";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v11, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v34 = "nw_path_report_estimated_throughput_usage";
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }

      else if (v31 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          v17 = backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v18 = gLogObj;
          v19 = type;
          if (os_log_type_enabled(v18, type))
          {
            *buf = 136446466;
            v34 = "nw_path_report_estimated_throughput_usage";
            v35 = 2082;
            v36 = v17;
            _os_log_impl(&dword_181A37000, v18, v19, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v17);
          if (!v11)
          {
            goto LABEL_18;
          }

          goto LABEL_17;
        }

        v12 = __nwlog_obj();
        v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v34 = "nw_path_report_estimated_throughput_usage";
          _os_log_impl(&dword_181A37000, v12, v21, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v20 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v34 = "nw_path_report_estimated_throughput_usage";
          _os_log_impl(&dword_181A37000, v12, v20, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v11)
    {
LABEL_18:
      v5 = 0;
      goto LABEL_19;
    }

LABEL_17:
    free(v11);
    goto LABEL_18;
  }

  v22 = __nwlog_obj();
  *buf = 136446210;
  v34 = "nw_path_get_estimated_upload_throughput";
  v23 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (__nwlog_fault(v23, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *buf = 136446210;
        v34 = "nw_path_get_estimated_upload_throughput";
        _os_log_impl(&dword_181A37000, v24, v25, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v31 == 1)
    {
      v26 = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v27 = type;
      v28 = os_log_type_enabled(v24, type);
      if (v26)
      {
        if (v28)
        {
          *buf = 136446466;
          v34 = "nw_path_get_estimated_upload_throughput";
          v35 = 2082;
          v36 = v26;
          _os_log_impl(&dword_181A37000, v24, v27, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v26);
        goto LABEL_53;
      }

      if (v28)
      {
        *buf = 136446210;
        v34 = "nw_path_get_estimated_upload_throughput";
        _os_log_impl(&dword_181A37000, v24, v27, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v24 = __nwlog_obj();
      v30 = type;
      if (os_log_type_enabled(v24, type))
      {
        *buf = 136446210;
        v34 = "nw_path_get_estimated_upload_throughput";
        _os_log_impl(&dword_181A37000, v24, v30, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_53:
  if (v23)
  {
    free(v23);
  }

  v14 = 0;
LABEL_21:

  return v14;
}

xpc_object_t nw_path_prepare_report_usage_dictionary(NWConcrete_nw_path *a1)
{
  v30 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = xpc_dictionary_create(0, 0, 0);
  if (v2)
  {
    v3 = nw_path_copy_interface(v1);
    v4 = v3;
    if (!v3)
    {
      goto LABEL_33;
    }

    v5 = _nw_interface_get_type(v3);
    if (v5 > 4)
    {
      v6 = "unknown";
    }

    else
    {
      v6 = off_1E6A357B8[v5];
    }

    subtype = _nw_interface_get_subtype(v4);
    if (subtype <= 1001)
    {
      if (!subtype)
      {
        v12 = "other";
        goto LABEL_32;
      }

      if (subtype == 1001)
      {
        v12 = "wifi_infrastructure";
        goto LABEL_32;
      }
    }

    else
    {
      switch(subtype)
      {
        case 1002:
          v12 = "wifi_awdl";
          goto LABEL_32;
        case 4001:
          v12 = "coprocessor";
          goto LABEL_32;
        case 5001:
          v12 = "companion";
LABEL_32:
          radio_type = _nw_interface_get_radio_type(v4);
          v18 = nw_interface_radio_type_to_string(radio_type);
          xpc_dictionary_set_string(v2, "interface_type", v6);
          xpc_dictionary_set_string(v2, "interface_subtype", v12);
          xpc_dictionary_set_string(v2, "interface_radio_type", v18);
LABEL_33:
          v19 = _nw_path_copy_parameters(v1);
          v20 = v19;
          if (v19)
          {
            effective_process_name = nw_parameters_get_effective_process_name(v19);
            if (effective_process_name)
            {
              xpc_dictionary_set_string(v2, "effective_bundle_id", effective_process_name);
            }
          }

          if (nw_utilities_get_self_name::onceToken != -1)
          {
            dispatch_once(&nw_utilities_get_self_name::onceToken, &__block_literal_global_11_47232);
          }

          if (nw_utilities_get_self_name::name)
          {
            xpc_dictionary_set_string(v2, "bundle_id", nw_utilities_get_self_name::name);
          }

          v22 = v2;

          goto LABEL_46;
      }
    }

    v12 = "unknown";
    goto LABEL_32;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = gLogObj;
  *buf = 136446210;
  v27 = "nw_path_prepare_report_usage_dictionary";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (!__nwlog_fault(v8, &type, &v24))
  {
    goto LABEL_44;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v27 = "nw_path_prepare_report_usage_dictionary";
      _os_log_impl(&dword_181A37000, v9, v10, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
    }

LABEL_43:

LABEL_44:
    if (!v8)
    {
      goto LABEL_46;
    }

LABEL_45:
    free(v8);
    goto LABEL_46;
  }

  if (v24 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    v16 = type;
    if (os_log_type_enabled(v9, type))
    {
      *buf = 136446210;
      v27 = "nw_path_prepare_report_usage_dictionary";
      _os_log_impl(&dword_181A37000, v9, v16, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_43;
  }

  backtrace_string = __nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v9 = gLogObj;
  v14 = type;
  v15 = os_log_type_enabled(v9, type);
  if (!backtrace_string)
  {
    if (v15)
    {
      *buf = 136446210;
      v27 = "nw_path_prepare_report_usage_dictionary";
      _os_log_impl(&dword_181A37000, v9, v14, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
    }

    goto LABEL_43;
  }

  if (v15)
  {
    *buf = 136446466;
    v27 = "nw_path_prepare_report_usage_dictionary";
    v28 = 2082;
    v29 = backtrace_string;
    _os_log_impl(&dword_181A37000, v9, v14, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v8)
  {
    goto LABEL_45;
  }

LABEL_46:

  return v2;
}

uint64_t nw_path_get_estimated_download_throughput(void *a1)
{
  v37 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    v4 = v3;
    if (nw_path_report_estimated_throughput_usage(NWConcrete_nw_path *,BOOL)::usage_report_count > 0x3E7)
    {
      if (gLogDatapath != 1)
      {
LABEL_20:

        v14 = _nw_path_throughput_estimates_down(v4);
        goto LABEL_21;
      }

      v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446210;
        v34 = "nw_path_report_estimated_throughput_usage";
        _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_DEBUG, "%{public}s Estimated throughput usage exceeded cap, ignoring", buf, 0xCu);
      }

LABEL_19:

      goto LABEL_20;
    }

    ++nw_path_report_estimated_throughput_usage(NWConcrete_nw_path *,BOOL)::usage_report_count;
    v5 = nw_path_prepare_report_usage_dictionary(v3);
    if (v5)
    {
      v6 = _nw_path_throughput_estimates_down(v4);
      v7 = _nw_path_throughput_estimates_up(v4);
      xpc_dictionary_set_uint64(v5, "download_estimate", v6);
      xpc_dictionary_set_uint64(v5, "upload_estimate", v7);
      xpc_dictionary_set_string(v5, "direction", "download");
      v8 = xpc_dictionary_copy_basic_description();
      if (gLogDatapath == 1)
      {
        v29 = __nwlog_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          *buf = 136446466;
          v34 = "nw_path_report_estimated_throughput_usage";
          v35 = 2080;
          v36 = v8;
          _os_log_impl(&dword_181A37000, v29, OS_LOG_TYPE_DEBUG, "%{public}s Estimated throughput: %s", buf, 0x16u);
        }
      }

      if (v8)
      {
        free(v8);
      }

      analytics_send_event_delayInitStub(v9);
      goto LABEL_19;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    *buf = 136446210;
    v34 = "nw_path_report_estimated_throughput_usage";
    v11 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v11, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v34 = "nw_path_report_estimated_throughput_usage";
          _os_log_impl(&dword_181A37000, v12, v13, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }

      else if (v31 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          v17 = backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v18 = gLogObj;
          v19 = type;
          if (os_log_type_enabled(v18, type))
          {
            *buf = 136446466;
            v34 = "nw_path_report_estimated_throughput_usage";
            v35 = 2082;
            v36 = v17;
            _os_log_impl(&dword_181A37000, v18, v19, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v17);
          if (!v11)
          {
            goto LABEL_18;
          }

          goto LABEL_17;
        }

        v12 = __nwlog_obj();
        v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v34 = "nw_path_report_estimated_throughput_usage";
          _os_log_impl(&dword_181A37000, v12, v21, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        v20 = type;
        if (os_log_type_enabled(v12, type))
        {
          *buf = 136446210;
          v34 = "nw_path_report_estimated_throughput_usage";
          _os_log_impl(&dword_181A37000, v12, v20, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v11)
    {
LABEL_18:
      v5 = 0;
      goto LABEL_19;
    }

LABEL_17:
    free(v11);
    goto LABEL_18;
  }

  v22 = __nwlog_obj();
  *buf = 136446210;
  v34 = "nw_path_get_estimated_download_throughput";
  v23 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (__nwlog_fault(v23, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *buf = 136446210;
        v34 = "nw_path_get_estimated_download_throughput";
        _os_log_impl(&dword_181A37000, v24, v25, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v31 == 1)
    {
      v26 = __nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v27 = type;
      v28 = os_log_type_enabled(v24, type);
      if (v26)
      {
        if (v28)
        {
          *buf = 136446466;
          v34 = "nw_path_get_estimated_download_throughput";
          v35 = 2082;
          v36 = v26;
          _os_log_impl(&dword_181A37000, v24, v27, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v26);
        goto LABEL_53;
      }

      if (v28)
      {
        *buf = 136446210;
        v34 = "nw_path_get_estimated_download_throughput";
        _os_log_impl(&dword_181A37000, v24, v27, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v24 = __nwlog_obj();
      v30 = type;
      if (os_log_type_enabled(v24, type))
      {
        *buf = 136446210;
        v34 = "nw_path_get_estimated_download_throughput";
        _os_log_impl(&dword_181A37000, v24, v30, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_53:
  if (v23)
  {
    free(v23);
  }

  v14 = 0;
LABEL_21:

  return v14;
}

uint64_t nw_path_get_link_quality_internal(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    link_quality = _nw_path_get_link_quality(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_get_link_quality_internal";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_get_link_quality_internal";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_get_link_quality_internal";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_get_link_quality_internal";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_get_link_quality_internal";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  link_quality = 0;
LABEL_3:

  return link_quality;
}

uint64_t nw_path_get_link_quality(void *a1)
{
  v26 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    v4 = v3;
    if (nw_path_report_link_quality_usage(NWConcrete_nw_path *)::usage_report_count > 0x3E7)
    {
      if (gLogDatapath != 1)
      {
        goto LABEL_10;
      }

      v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        *buf = 136446210;
        v23 = "nw_path_report_link_quality_usage";
        _os_log_impl(&dword_181A37000, v5, OS_LOG_TYPE_DEBUG, "%{public}s Link quality usage exceeded cap, ignoring", buf, 0xCu);
      }
    }

    else
    {
      ++nw_path_report_link_quality_usage(NWConcrete_nw_path *)::usage_report_count;
      v5 = nw_path_prepare_report_usage_dictionary(v3);
      if (!v5)
      {
LABEL_10:

        link_quality = _nw_path_get_link_quality(v4);
        goto LABEL_11;
      }

      v6 = _nw_path_get_link_quality(v4);
      xpc_dictionary_set_int64(v5, "link_quality", v6);
      v7 = xpc_dictionary_copy_basic_description();
      if (gLogDatapath == 1)
      {
        v18 = __nwlog_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *buf = 136446466;
          v23 = "nw_path_report_link_quality_usage";
          v24 = 2080;
          v25 = v7;
          _os_log_impl(&dword_181A37000, v18, OS_LOG_TYPE_DEBUG, "%{public}s Link quality: %s", buf, 0x16u);
        }
      }

      if (v7)
      {
        free(v7);
      }

      analytics_send_event_delayInitStub(v8);
    }

    goto LABEL_10;
  }

  v11 = __nwlog_obj();
  *buf = 136446210;
  v23 = "nw_path_get_link_quality";
  v12 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v12, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *buf = 136446210;
        v23 = "nw_path_get_link_quality";
        _os_log_impl(&dword_181A37000, v13, v14, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v20 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *buf = 136446466;
          v23 = "nw_path_get_link_quality";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_181A37000, v13, v16, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_33;
      }

      if (v17)
      {
        *buf = 136446210;
        v23 = "nw_path_get_link_quality";
        _os_log_impl(&dword_181A37000, v13, v16, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v13 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v13, type))
      {
        *buf = 136446210;
        v23 = "nw_path_get_link_quality";
        _os_log_impl(&dword_181A37000, v13, v19, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_33:
  if (v12)
  {
    free(v12);
  }

  link_quality = 0;
LABEL_11:

  return link_quality;
}

id nw_path_flow_copy_local_endpoint(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_flow_copy_local_endpoint(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_copy_local_endpoint";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_copy_local_endpoint";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_copy_local_endpoint";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_copy_local_endpoint";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_copy_local_endpoint";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

id nw_path_flow_copy_remote_endpoint(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_flow_copy_remote_endpoint(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_copy_remote_endpoint";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_copy_remote_endpoint";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_copy_remote_endpoint";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_copy_remote_endpoint";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_copy_remote_endpoint";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_flow_copy_interface(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_flow_copy_interface(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_copy_interface";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_copy_interface";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_copy_interface";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_copy_interface";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_copy_interface";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_flow_get_protocol_level(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    protocol_level = _nw_path_flow_get_protocol_level(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_get_protocol_level";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_get_protocol_level";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_get_protocol_level";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_get_protocol_level";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_get_protocol_level";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  protocol_level = 0;
LABEL_3:

  return protocol_level;
}

uint64_t nw_path_flow_get_nexus_agent_uuid(void *a1, unsigned __int8 *a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nexus_agent_uuid = _nw_path_flow_get_nexus_agent_uuid(v3, a2);
    goto LABEL_3;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_path_flow_get_nexus_agent_uuid";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_flow_get_nexus_agent_uuid";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v18 = "nw_path_flow_get_nexus_agent_uuid";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *buf = 136446210;
        v18 = "nw_path_flow_get_nexus_agent_uuid";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_path_flow_get_nexus_agent_uuid";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v8)
  {
    free(v8);
  }

  nexus_agent_uuid = 0;
LABEL_3:

  return nexus_agent_uuid;
}

uint64_t nw_path_flow_get_nexus_key(void *a1, uint64_t a2)
{
  v26 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
    {
      nexus_key = _nw_path_flow_get_nexus_key(v3, a2);
      goto LABEL_4;
    }

    v11 = __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_path_flow_get_nexus_key";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v23 = "nw_path_flow_get_nexus_key";
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null length", buf, 0xCu);
        }

LABEL_36:

        goto LABEL_37;
      }

      if (v20 != 1)
      {
        v9 = __nwlog_obj();
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v23 = "nw_path_flow_get_nexus_key";
          _os_log_impl(&dword_181A37000, v9, v19, "%{public}s called with null length, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_36;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          v23 = "nw_path_flow_get_nexus_key";
          _os_log_impl(&dword_181A37000, v9, v16, "%{public}s called with null length, no backtrace", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v17)
      {
        *buf = 136446466;
        v23 = "nw_path_flow_get_nexus_key";
        v24 = 2082;
        v25 = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v16, "%{public}s called with null length, dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_24;
    }
  }

  else
  {
    v7 = __nwlog_obj();
    *buf = 136446210;
    v23 = "nw_path_flow_get_nexus_key";
    v8 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v23 = "nw_path_flow_get_nexus_key";
          _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null flow", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v20 != 1)
      {
        v9 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *buf = 136446210;
          v23 = "nw_path_flow_get_nexus_key";
          _os_log_impl(&dword_181A37000, v9, v18, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_36;
      }

      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *buf = 136446210;
          v23 = "nw_path_flow_get_nexus_key";
          _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null flow, no backtrace", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v15)
      {
        *buf = 136446466;
        v23 = "nw_path_flow_get_nexus_key";
        v24 = 2082;
        v25 = backtrace_string;
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_24:

      free(backtrace_string);
    }
  }

LABEL_37:
  if (v8)
  {
    free(v8);
  }

  nexus_key = 0;
LABEL_4:

  return nexus_key;
}

uint64_t nw_path_flow_is_viable(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    is_viable = _nw_path_flow_is_viable(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_is_viable";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_is_viable";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_is_viable";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_is_viable";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_is_viable";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  is_viable = 0;
LABEL_3:

  return is_viable;
}

uint64_t nw_path_flow_ecn_enabled(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_flow_ecn_enabled(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_ecn_enabled";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_ecn_enabled";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_ecn_enabled";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_ecn_enabled";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_ecn_enabled";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_flow_fast_open_blocked(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _nw_path_flow_fast_open_blocked(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_fast_open_blocked";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_fast_open_blocked";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_fast_open_blocked";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_fast_open_blocked";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_fast_open_blocked";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_flow_is_local(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    is_local = _nw_path_flow_is_local(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_is_local";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_is_local";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_is_local";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_is_local";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_is_local";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  is_local = 0;
LABEL_3:

  return is_local;
}

uint64_t nw_path_flow_is_direct(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    is_direct = _nw_path_flow_is_direct(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_is_direct";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_is_direct";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_is_direct";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_is_direct";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_is_direct";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  is_direct = 0;
LABEL_3:

  return is_direct;
}

uint64_t nw_path_flow_has_ipv4(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    has_ipv4 = _nw_path_flow_has_ipv4(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_has_ipv4";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_has_ipv4";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_has_ipv4";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_has_ipv4";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_has_ipv4";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  has_ipv4 = 0;
LABEL_3:

  return has_ipv4;
}

uint64_t nw_path_flow_has_ipv6(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    has_ipv6 = _nw_path_flow_has_ipv6(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_flow_has_ipv6";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_has_ipv6";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_flow_has_ipv6";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_flow_has_ipv6";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_flow_has_ipv6";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  has_ipv6 = 0;
LABEL_3:

  return has_ipv6;
}

void nw_path_flow_registration_set_advisory_region(void *a1, uint64_t a2)
{
  v18 = *MEMORY[0x1E69E9840];
  v3 = a1;
  if (v3)
  {
    v3[10] = a2;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_path_flow_registration_set_advisory_region";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_set_advisory_region";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_path_flow_registration_set_advisory_region";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_set_advisory_region";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_set_advisory_region";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v3 = 0;
LABEL_3:
}

uint64_t nw_path_flow_registration_get_advisory_region(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = v1[10];
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_path_flow_registration_get_advisory_region";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_get_advisory_region";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_path_flow_registration_get_advisory_region";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_get_advisory_region";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_flow_registration_get_advisory_region";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
  v1 = 0;
LABEL_3:

  return v2;
}

BOOL nw_path_is_multilayer_packet_logging_enabled(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    is_multilayer_packet_logging_enabled = _nw_path_is_multilayer_packet_logging_enabled(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_is_multilayer_packet_logging_enabled";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_is_multilayer_packet_logging_enabled";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_is_multilayer_packet_logging_enabled";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_is_multilayer_packet_logging_enabled";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_is_multilayer_packet_logging_enabled";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  is_multilayer_packet_logging_enabled = 0;
LABEL_3:

  return is_multilayer_packet_logging_enabled;
}

NWConcrete_nw_path_override_info *nw_path_override_info_create()
{
  v18 = *MEMORY[0x1E69E9840];
  v0 = objc_alloc_init(NWConcrete_nw_path_override_info);
  v1 = v0;
  if (v0)
  {
    v2 = v0;
    goto LABEL_10;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = gLogObj;
  *buf = 136446210;
  v15 = "nw_path_override_info_create";
  v4 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12))
  {
    goto LABEL_8;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    v6 = type;
    if (os_log_type_enabled(v5, type))
    {
      *buf = 136446210;
      v15 = "nw_path_override_info_create";
      _os_log_impl(&dword_181A37000, v5, v6, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_override_info) alloc] init] failed", buf, 0xCu);
    }

LABEL_7:

LABEL_8:
    if (!v4)
    {
      goto LABEL_10;
    }

LABEL_9:
    free(v4);
    goto LABEL_10;
  }

  if (v12 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    v11 = type;
    if (os_log_type_enabled(v5, type))
    {
      *buf = 136446210;
      v15 = "nw_path_override_info_create";
      _os_log_impl(&dword_181A37000, v5, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_override_info) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_7;
  }

  backtrace_string = __nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = gLogObj;
  v9 = type;
  v10 = os_log_type_enabled(v5, type);
  if (!backtrace_string)
  {
    if (v10)
    {
      *buf = 136446210;
      v15 = "nw_path_override_info_create";
      _os_log_impl(&dword_181A37000, v5, v9, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_override_info) alloc] init] failed, no backtrace", buf, 0xCu);
    }

    goto LABEL_7;
  }

  if (v10)
  {
    *buf = 136446466;
    v15 = "nw_path_override_info_create";
    v16 = 2082;
    v17 = backtrace_string;
    _os_log_impl(&dword_181A37000, v5, v9, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_override_info) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v4)
  {
    goto LABEL_9;
  }

LABEL_10:

  return v1;
}

void nw_path_override_info_update_flag(void *a1, uint64_t a2, int a3)
{
  v22 = *MEMORY[0x1E69E9840];
  v5 = a1;
  if (v5)
  {
    v6 = v5[1];
    if (a3)
    {
      v7 = v6 | a2;
    }

    else
    {
      v7 = v6 & ~a2;
    }

    v5[1] = v7;
    goto LABEL_6;
  }

  v8 = __nwlog_obj();
  *buf = 136446210;
  v19 = "nw_path_override_info_update_flag";
  v9 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v19 = "nw_path_override_info_update_flag";
        _os_log_impl(&dword_181A37000, v10, v11, "%{public}s called with null override_info", buf, 0xCu);
      }
    }

    else if (v16 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *buf = 136446466;
          v19 = "nw_path_override_info_update_flag";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null override_info, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v14)
      {
        *buf = 136446210;
        v19 = "nw_path_override_info_update_flag";
        _os_log_impl(&dword_181A37000, v10, v13, "%{public}s called with null override_info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v10 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *buf = 136446210;
        v19 = "nw_path_override_info_update_flag";
        _os_log_impl(&dword_181A37000, v10, v15, "%{public}s called with null override_info, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_23:
  if (v9)
  {
    free(v9);
  }

  v5 = 0;
LABEL_6:
}

void nw_path_override_info_add_resolver_config(void *a1, void *a2)
{
  v29 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    v9 = __nwlog_obj();
    *buf = 136446210;
    v26 = "nw_path_override_info_add_resolver_config";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23))
    {
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v26 = "nw_path_override_info_add_resolver_config";
        _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null override_info", buf, 0xCu);
      }
    }

    else if (v23 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *buf = 136446466;
          v26 = "nw_path_override_info_add_resolver_config";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null override_info, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v10)
        {
          goto LABEL_6;
        }

LABEL_41:
        free(v10);
        goto LABEL_6;
      }

      if (v17)
      {
        *buf = 136446210;
        v26 = "nw_path_override_info_add_resolver_config";
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null override_info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v11 = __nwlog_obj();
      v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *buf = 136446210;
        v26 = "nw_path_override_info_add_resolver_config";
        _os_log_impl(&dword_181A37000, v11, v21, "%{public}s called with null override_info, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_39:

    goto LABEL_40;
  }

  if (v4)
  {
    v6 = v3[2];
    if (v6 || (v7 = _nw_array_create(), v8 = v3[2], v3[2] = v7, v8, (v6 = v3[2]) != 0))
    {
      _nw_array_append(v6, v5);
    }

    goto LABEL_6;
  }

  v13 = __nwlog_obj();
  *buf = 136446210;
  v26 = "nw_path_override_info_add_resolver_config";
  v10 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v10, &type, &v23))
  {
    goto LABEL_40;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    v11 = __nwlog_obj();
    v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *buf = 136446210;
      v26 = "nw_path_override_info_add_resolver_config";
      _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null resolver_config", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v23 != 1)
  {
    v11 = __nwlog_obj();
    v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *buf = 136446210;
      v26 = "nw_path_override_info_add_resolver_config";
      _os_log_impl(&dword_181A37000, v11, v22, "%{public}s called with null resolver_config, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_39;
  }

  v18 = __nw_create_backtrace_string();
  v11 = __nwlog_obj();
  v19 = type;
  v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *buf = 136446210;
      v26 = "nw_path_override_info_add_resolver_config";
      _os_log_impl(&dword_181A37000, v11, v19, "%{public}s called with null resolver_config, no backtrace", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v20)
  {
    *buf = 136446466;
    v26 = "nw_path_override_info_add_resolver_config";
    v27 = 2082;
    v28 = v18;
    _os_log_impl(&dword_181A37000, v11, v19, "%{public}s called with null resolver_config, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10)
  {
    goto LABEL_41;
  }

LABEL_6:
}

NWConcrete_nw_path_override_info *nw_path_override_info_create_from_data(uint64_t a1, unint64_t a2)
{
  v73 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v49 = __nwlog_obj();
    *buf = 136446210;
    v68 = "nw_path_override_info_create_from_data";
    v50 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v65 = 0;
    if (!__nwlog_fault(v50, &type, &v65))
    {
      goto LABEL_142;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v51 = __nwlog_obj();
      v52 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        v68 = "nw_path_override_info_create_from_data";
        _os_log_impl(&dword_181A37000, v51, v52, "%{public}s called with null override_info_data", buf, 0xCu);
      }
    }

    else if (v65 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v51 = __nwlog_obj();
      v56 = type;
      v57 = os_log_type_enabled(v51, type);
      if (backtrace_string)
      {
        if (v57)
        {
          *buf = 136446466;
          v68 = "nw_path_override_info_create_from_data";
          v69 = 2082;
          *v70 = backtrace_string;
          _os_log_impl(&dword_181A37000, v51, v56, "%{public}s called with null override_info_data, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v50)
        {
          goto LABEL_144;
        }

        goto LABEL_143;
      }

      if (v57)
      {
        *buf = 136446210;
        v68 = "nw_path_override_info_create_from_data";
        _os_log_impl(&dword_181A37000, v51, v56, "%{public}s called with null override_info_data, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v51 = __nwlog_obj();
      v61 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        v68 = "nw_path_override_info_create_from_data";
        _os_log_impl(&dword_181A37000, v51, v61, "%{public}s called with null override_info_data, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_141;
  }

  if (a2)
  {
    v64 = objc_alloc_init(NWConcrete_nw_path_override_info);
    if (v64)
    {
      if (a2 < 5)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v4 = gLogObj;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          *buf = 136446722;
          v68 = "nw_path_override_info_create_from_data";
          v69 = 2048;
          *v70 = a2;
          *&v70[8] = 2048;
          *&v70[10] = 5;
          _os_log_impl(&dword_181A37000, v4, OS_LOG_TYPE_ERROR, "%{public}s invalid length for override info %zu != %zu", buf, 0x20u);
        }

        goto LABEL_93;
      }

      if (a2 != 5)
      {
        v9 = 0;
        allocator = *MEMORY[0x1E695E480];
        do
        {
          v10 = *(a1 + v9);
          v11 = *(a1 + 1 + v9);
          if (!v11)
          {
            goto LABEL_43;
          }

          if (v11 <= 0xFFFFFFF9 && a2 >= v11 + 5 && a2 - (v11 + 5) >= v9)
          {
            v21 = (a1 + 5 + v9);
            goto LABEL_44;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v13 = gLogObj;
          *buf = 136446978;
          v68 = "nw_necp_buffer_get_tlv_value";
          v69 = 2048;
          *v70 = v9;
          *&v70[8] = 2048;
          *&v70[10] = a2;
          *&v70[18] = 1024;
          *&v70[20] = v11;
          v14 = _os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v65 = 0;
          if (__nwlog_fault(v14, &type, &v65))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v15 = gLogObj;
              v16 = type;
              if (os_log_type_enabled(v15, type))
              {
                *buf = 136446978;
                v68 = "nw_necp_buffer_get_tlv_value";
                v69 = 2048;
                *v70 = v9;
                *&v70[8] = 2048;
                *&v70[10] = a2;
                *&v70[18] = 1024;
                *&v70[20] = v11;
                _os_log_impl(&dword_181A37000, v15, v16, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u", buf, 0x26u);
              }
            }

            else
            {
              if (v65 == 1)
              {
                v17 = __nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v18 = gLogObj;
                v19 = type;
                v20 = os_log_type_enabled(v18, type);
                if (v17)
                {
                  if (v20)
                  {
                    *buf = 136447234;
                    v68 = "nw_necp_buffer_get_tlv_value";
                    v69 = 2048;
                    *v70 = v9;
                    *&v70[8] = 2048;
                    *&v70[10] = a2;
                    *&v70[18] = 1024;
                    *&v70[20] = v11;
                    v71 = 2082;
                    v72 = v17;
                    _os_log_impl(&dword_181A37000, v18, v19, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, dumping backtrace:%{public}s", buf, 0x30u);
                  }

                  free(v17);
                  if (!v14)
                  {
                    goto LABEL_43;
                  }

LABEL_42:
                  free(v14);
                  goto LABEL_43;
                }

                if (v20)
                {
                  *buf = 136446978;
                  v68 = "nw_necp_buffer_get_tlv_value";
                  v69 = 2048;
                  *v70 = v9;
                  *&v70[8] = 2048;
                  *&v70[10] = a2;
                  *&v70[18] = 1024;
                  *&v70[20] = v11;
                  _os_log_impl(&dword_181A37000, v18, v19, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, no backtrace", buf, 0x26u);
                }

                goto LABEL_41;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v15 = gLogObj;
              v22 = type;
              if (os_log_type_enabled(v15, type))
              {
                *buf = 136446978;
                v68 = "nw_necp_buffer_get_tlv_value";
                v69 = 2048;
                *v70 = v9;
                *&v70[8] = 2048;
                *&v70[10] = a2;
                *&v70[18] = 1024;
                *&v70[20] = v11;
                _os_log_impl(&dword_181A37000, v15, v22, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, backtrace limit exceeded", buf, 0x26u);
              }
            }
          }

LABEL_41:
          if (v14)
          {
            goto LABEL_42;
          }

LABEL_43:
          v21 = 0;
LABEL_44:
          v9 += v11 + 5;
          if (v9 > a2)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v38 = gLogObj;
            *buf = 136446978;
            v68 = "nw_path_override_info_create_from_data";
            v69 = 1024;
            *v70 = v11;
            *&v70[4] = 2048;
            *&v70[6] = v9;
            *&v70[14] = 2048;
            *&v70[16] = a2;
            v39 = _os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v65 = 0;
            if (__nwlog_fault(v39, &type, &v65))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v40 = gLogObj;
                v41 = type;
                if (os_log_type_enabled(v40, type))
                {
                  *buf = 136446978;
                  v68 = "nw_path_override_info_create_from_data";
                  v69 = 1024;
                  *v70 = v11;
                  *&v70[4] = 2048;
                  *&v70[6] = v9;
                  *&v70[14] = 2048;
                  *&v70[16] = a2;
                  _os_log_impl(&dword_181A37000, v40, v41, "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu)", buf, 0x26u);
                }

                goto LABEL_106;
              }

              if (v65 == 1)
              {
                v42 = __nw_create_backtrace_string();
                v40 = __nwlog_obj();
                v43 = type;
                v44 = os_log_type_enabled(v40, type);
                if (v42)
                {
                  if (v44)
                  {
                    *buf = 136447234;
                    v68 = "nw_path_override_info_create_from_data";
                    v69 = 1024;
                    *v70 = v11;
                    *&v70[4] = 2048;
                    *&v70[6] = v9;
                    *&v70[14] = 2048;
                    *&v70[16] = a2;
                    v71 = 2082;
                    v72 = v42;
                    _os_log_impl(&dword_181A37000, v40, v43, "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), dumping backtrace:%{public}s", buf, 0x30u);
                  }

                  free(v42);
                  if (!v39)
                  {
                    goto LABEL_93;
                  }

LABEL_108:
                  v45 = v39;
                  goto LABEL_92;
                }

                if (v44)
                {
                  *buf = 136446978;
                  v68 = "nw_path_override_info_create_from_data";
                  v69 = 1024;
                  *v70 = v11;
                  *&v70[4] = 2048;
                  *&v70[6] = v9;
                  *&v70[14] = 2048;
                  *&v70[16] = a2;
                  _os_log_impl(&dword_181A37000, v40, v43, "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), no backtrace", buf, 0x26u);
                }
              }

              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v40 = gLogObj;
                v47 = type;
                if (os_log_type_enabled(v40, type))
                {
                  *buf = 136446978;
                  v68 = "nw_path_override_info_create_from_data";
                  v69 = 1024;
                  *v70 = v11;
                  *&v70[4] = 2048;
                  *&v70[6] = v9;
                  *&v70[14] = 2048;
                  *&v70[16] = a2;
                  _os_log_impl(&dword_181A37000, v40, v47, "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), backtrace limit exceeded", buf, 0x26u);
                }
              }

LABEL_106:
            }

            if (!v39)
            {
              goto LABEL_93;
            }

            goto LABEL_108;
          }

          if (v11)
          {
            v23 = v21 == 0;
          }

          else
          {
            v23 = 1;
          }

          if (!v23)
          {
            if (v10 == 2)
            {
              v24 = CFDataCreate(allocator, v21, v11);
              if (v24)
              {
                v25 = CFPropertyListCreateWithData(allocator, v24, 0, 0, 0);
                if (v25)
                {
                  v26 = _CFXPCCreateXPCObjectFromCFObject();
                  v27 = v26;
                  if (v26)
                  {
                    v28 = nw_resolver_config_create_with_dictionary(v26);
                    resolver_configs = v64->resolver_configs;
                    if (!resolver_configs)
                    {
                      v30 = _nw_array_create();
                      v31 = v64->resolver_configs;
                      v64->resolver_configs = v30;

                      resolver_configs = v64->resolver_configs;
                    }

                    if (resolver_configs && v28)
                    {
                      _nw_array_append(resolver_configs, v28);
                    }
                  }

                  CFRelease(v25);
                }

                CFRelease(v24);
              }
            }

            else if (v10 == 1)
            {
              if (v11 != 8)
              {
                v48 = __nwlog_obj();
                if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
                {
                  *buf = 136446722;
                  v68 = "nw_path_override_info_create_from_data";
                  v69 = 1024;
                  *v70 = v11;
                  *&v70[4] = 2048;
                  *&v70[6] = 8;
                  _os_log_impl(&dword_181A37000, v48, OS_LOG_TYPE_ERROR, "%{public}s received invalid size for flags (%u != %zu)", buf, 0x1Cu);
                }

                goto LABEL_93;
              }

              v64->override_flags = *v21;
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v32 = gLogObj;
              if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              {
                *buf = 136446466;
                v68 = "nw_path_override_info_create_from_data";
                v69 = 1024;
                *v70 = v10;
                _os_log_impl(&dword_181A37000, v32, OS_LOG_TYPE_ERROR, "%{public}s received unknown TLV (type %d)", buf, 0x12u);
              }
            }
          }
        }

        while (v9 < a2 - 5);
      }

      v33 = v64;
      goto LABEL_94;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    *buf = 136446210;
    v68 = "nw_path_override_info_create_from_data";
    v6 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v65 = 0;
    if (__nwlog_fault(v6, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *buf = 136446210;
          v68 = "nw_path_override_info_create_from_data";
          _os_log_impl(&dword_181A37000, v7, v8, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) nw_path_override_info] init] failed", buf, 0xCu);
        }
      }

      else if (v65 == 1)
      {
        v34 = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v35 = type;
        v36 = os_log_type_enabled(v7, type);
        if (v34)
        {
          if (v36)
          {
            *buf = 136446466;
            v68 = "nw_path_override_info_create_from_data";
            v69 = 2082;
            *v70 = v34;
            _os_log_impl(&dword_181A37000, v7, v35, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) nw_path_override_info] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v34);
          if (!v6)
          {
LABEL_93:
            v33 = 0;
LABEL_94:

            goto LABEL_95;
          }

LABEL_91:
          v45 = v6;
LABEL_92:
          free(v45);
          goto LABEL_93;
        }

        if (v36)
        {
          *buf = 136446210;
          v68 = "nw_path_override_info_create_from_data";
          _os_log_impl(&dword_181A37000, v7, v35, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) nw_path_override_info] init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v37 = type;
        if (os_log_type_enabled(v7, type))
        {
          *buf = 136446210;
          v68 = "nw_path_override_info_create_from_data";
          _os_log_impl(&dword_181A37000, v7, v37, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) nw_path_override_info] init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v6)
    {
      goto LABEL_93;
    }

    goto LABEL_91;
  }

  v53 = __nwlog_obj();
  *buf = 136446210;
  v68 = "nw_path_override_info_create_from_data";
  v50 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v65 = 0;
  if (__nwlog_fault(v50, &type, &v65))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v51 = __nwlog_obj();
      v54 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        v68 = "nw_path_override_info_create_from_data";
        _os_log_impl(&dword_181A37000, v51, v54, "%{public}s called with null (data_length > 0)", buf, 0xCu);
      }

LABEL_141:

      goto LABEL_142;
    }

    if (v65 != 1)
    {
      v51 = __nwlog_obj();
      v62 = type;
      if (os_log_type_enabled(v51, type))
      {
        *buf = 136446210;
        v68 = "nw_path_override_info_create_from_data";
        _os_log_impl(&dword_181A37000, v51, v62, "%{public}s called with null (data_length > 0), backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_141;
    }

    v58 = __nw_create_backtrace_string();
    v51 = __nwlog_obj();
    v59 = type;
    v60 = os_log_type_enabled(v51, type);
    if (!v58)
    {
      if (v60)
      {
        *buf = 136446210;
        v68 = "nw_path_override_info_create_from_data";
        _os_log_impl(&dword_181A37000, v51, v59, "%{public}s called with null (data_length > 0), no backtrace", buf, 0xCu);
      }

      goto LABEL_141;
    }

    if (v60)
    {
      *buf = 136446466;
      v68 = "nw_path_override_info_create_from_data";
      v69 = 2082;
      *v70 = v58;
      _os_log_impl(&dword_181A37000, v51, v59, "%{public}s called with null (data_length > 0), dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v58);
  }

LABEL_142:
  if (v50)
  {
LABEL_143:
    free(v50);
  }

LABEL_144:
  v33 = 0;
LABEL_95:

  return v33;
}

uint64_t nw_path_override_info_uses_wifi(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = v1[8] & 1;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_path_override_info_uses_wifi";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_uses_wifi";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null override_info", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_path_override_info_uses_wifi";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null override_info, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_uses_wifi";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null override_info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_uses_wifi";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null override_info, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
  v1 = 0;
LABEL_3:

  return v2;
}

uint64_t nw_path_override_info_uses_cellular(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = (v1[8] >> 1) & 1;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_path_override_info_uses_cellular";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_uses_cellular";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null override_info", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_path_override_info_uses_cellular";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null override_info, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_uses_cellular";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null override_info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_uses_cellular";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null override_info, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
  v1 = 0;
LABEL_3:

  return v2;
}

uint64_t nw_path_override_info_expensive(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = (v1[8] >> 2) & 1;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_path_override_info_expensive";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_expensive";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null override_info", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_path_override_info_expensive";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null override_info, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_expensive";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null override_info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_expensive";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null override_info, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
  v1 = 0;
LABEL_3:

  return v2;
}

uint64_t nw_path_override_info_roaming(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = (v1[8] >> 4) & 1;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_path_override_info_roaming";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_roaming";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null override_info", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_path_override_info_roaming";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null override_info, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_roaming";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null override_info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_roaming";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null override_info, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
  v1 = 0;
LABEL_3:

  return v2;
}

uint64_t nw_path_override_info_constrained(void *a1)
{
  v18 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (v1)
  {
    v2 = (v1[8] >> 3) & 1;
    goto LABEL_3;
  }

  v4 = __nwlog_obj();
  *buf = 136446210;
  v15 = "nw_path_override_info_constrained";
  v5 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_constrained";
        _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null override_info", buf, 0xCu);
      }
    }

    else if (v12 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v15 = "nw_path_override_info_constrained";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null override_info, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_constrained";
        _os_log_impl(&dword_181A37000, v6, v9, "%{public}s called with null override_info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v6 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v15 = "nw_path_override_info_constrained";
        _os_log_impl(&dword_181A37000, v6, v11, "%{public}s called with null override_info, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v5)
  {
    free(v5);
  }

  v2 = 0;
  v1 = 0;
LABEL_3:

  return v2;
}

id nw_path_override_info_copy_resolver_configs(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[2];
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_path_override_info_copy_resolver_configs";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_override_info_copy_resolver_configs";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null override_info", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_path_override_info_copy_resolver_configs";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null override_info, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_path_override_info_copy_resolver_configs";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null override_info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_path_override_info_copy_resolver_configs";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null override_info, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_override_info_copy_data(void *a1)
{
  v74 = *MEMORY[0x1E69E9840];
  v1 = a1;
  if (!v1)
  {
    v29 = __nwlog_obj();
    *buf = 136446210;
    v64 = "nw_path_override_info_copy_data";
    v30 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v57) = 0;
    if (__nwlog_fault(v30, type, &v57))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v31 = __nwlog_obj();
        v32 = type[0];
        if (os_log_type_enabled(v31, type[0]))
        {
          *buf = 136446210;
          v64 = "nw_path_override_info_copy_data";
          _os_log_impl(&dword_181A37000, v31, v32, "%{public}s called with null override_info", buf, 0xCu);
        }
      }

      else if (v57 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v31 = __nwlog_obj();
        v38 = type[0];
        v39 = os_log_type_enabled(v31, type[0]);
        if (backtrace_string)
        {
          if (v39)
          {
            *buf = 136446466;
            v64 = "nw_path_override_info_copy_data";
            v65 = 2082;
            v66 = backtrace_string;
            _os_log_impl(&dword_181A37000, v31, v38, "%{public}s called with null override_info, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_85;
        }

        if (v39)
        {
          *buf = 136446210;
          v64 = "nw_path_override_info_copy_data";
          _os_log_impl(&dword_181A37000, v31, v38, "%{public}s called with null override_info, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v31 = __nwlog_obj();
        v43 = type[0];
        if (os_log_type_enabled(v31, type[0]))
        {
          *buf = 136446210;
          v64 = "nw_path_override_info_copy_data";
          _os_log_impl(&dword_181A37000, v31, v43, "%{public}s called with null override_info, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

LABEL_85:
    if (v30)
    {
      free(v30);
    }

    v20 = 0;
    goto LABEL_53;
  }

  v57 = 0;
  v58 = &v57;
  v59 = 0x2020000000;
  v2 = 13;
  v60 = 13;
  *type = 0;
  v52 = type;
  v53 = 0x3032000000;
  v54 = __Block_byref_object_copy__71486;
  v55 = __Block_byref_object_dispose__71487;
  v56 = 0;
  v3 = v1[2];
  if (v3)
  {
    aBlock[0] = MEMORY[0x1E69E9820];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_path_override_info_copy_data_block_invoke;
    aBlock[3] = &unk_1E6A39C00;
    aBlock[4] = type;
    aBlock[5] = &v57;
    _nw_array_apply(v3, aBlock);
    v2 = v58[3];
    if (!v2)
    {
      v33 = __nwlog_obj();
      os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
      *buf = 136446210;
      v64 = "nw_path_override_info_copy_data";
      v34 = _os_log_send_and_compose_impl();

      result = __nwlog_should_abort(v34);
      if (result)
      {
        goto LABEL_91;
      }

      free(v34);
      v2 = 0;
    }
  }

  v4 = malloc_type_malloc(v2, 0xDA28BD50uLL);
  v5 = v4;
  if (v4)
  {
    v46 = 0;
    v47 = &v46;
    v48 = 0x2020000000;
    v49 = v4;
    v6 = v58[3];
    v7 = &v4[v6];
    if (v6 > 0)
    {
      if (v6 <= 0xC)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        *buf = 136447490;
        v64 = "nw_necp_append_tlv";
        v65 = 2048;
        v66 = v5;
        v67 = 2048;
        v68 = 13;
        v69 = 2048;
        *v70 = v7;
        *&v70[8] = 1024;
        *v71 = 1;
        *&v71[4] = 1024;
        *&v71[6] = 8;
        v9 = _os_log_send_and_compose_impl();

        v62 = OS_LOG_TYPE_ERROR;
        v61 = 0;
        if (!__nwlog_fault(v9, &v62, &v61))
        {
          goto LABEL_48;
        }

        if (v62 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = gLogObj;
          v11 = v62;
          if (os_log_type_enabled(v10, v62))
          {
            *buf = 136447490;
            v64 = "nw_necp_append_tlv";
            v65 = 2048;
            v66 = v5;
            v67 = 2048;
            v68 = 13;
            v69 = 2048;
            *v70 = v7;
            *&v70[8] = 1024;
            *v71 = 1;
            *&v71[4] = 1024;
            *&v71[6] = 8;
            _os_log_impl(&dword_181A37000, v10, v11, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
          }
        }

        else if (v61 == 1)
        {
          v24 = __nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = gLogObj;
          v25 = v62;
          v26 = os_log_type_enabled(v10, v62);
          if (v24)
          {
            if (v26)
            {
              *buf = 136447746;
              v64 = "nw_necp_append_tlv";
              v65 = 2048;
              v66 = v5;
              v67 = 2048;
              v68 = 13;
              v69 = 2048;
              *v70 = v7;
              *&v70[8] = 1024;
              *v71 = 1;
              *&v71[4] = 1024;
              *&v71[6] = 8;
              v72 = 2082;
              v73 = v24;
              _os_log_impl(&dword_181A37000, v10, v25, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
            }

            free(v24);
            if (!v9)
            {
              goto LABEL_50;
            }

            goto LABEL_49;
          }

          if (v26)
          {
            *buf = 136447490;
            v64 = "nw_necp_append_tlv";
            v65 = 2048;
            v66 = v5;
            v67 = 2048;
            v68 = 13;
            v69 = 2048;
            *v70 = v7;
            *&v70[8] = 1024;
            *v71 = 1;
            *&v71[4] = 1024;
            *&v71[6] = 8;
            _os_log_impl(&dword_181A37000, v10, v25, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = gLogObj;
          v28 = v62;
          if (os_log_type_enabled(v10, v62))
          {
            *buf = 136447490;
            v64 = "nw_necp_append_tlv";
            v65 = 2048;
            v66 = v5;
            v67 = 2048;
            v68 = 13;
            v69 = 2048;
            *v70 = v7;
            *&v70[8] = 1024;
            *v71 = 1;
            *&v71[4] = 1024;
            *&v71[6] = 8;
            _os_log_impl(&dword_181A37000, v10, v28, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
          }
        }

        goto LABEL_47;
      }

      *v4 = 1;
      *(v4 + 1) = 8;
      *(v4 + 5) = v1[1];
      v47[3] = (v4 + 13);
      v19 = *(v52 + 5);
      if (v19)
      {
        v45[0] = MEMORY[0x1E69E9820];
        v45[1] = 3221225472;
        v45[2] = __nw_path_override_info_copy_data_block_invoke_282;
        v45[3] = &unk_1E6A3B328;
        v45[4] = &v46;
        v45[5] = &v57;
        v45[6] = v5;
        _nw_array_apply(v19, v45);
        if (!v47[3])
        {
          goto LABEL_51;
        }
      }

      v20 = dispatch_data_create(v5, v58[3], 0, 0);
      free(v5);
LABEL_52:
      _Block_object_dispose(&v46, 8);
      _Block_object_dispose(type, 8);

      _Block_object_dispose(&v57, 8);
LABEL_53:

      return v20;
    }

    v35 = __nwlog_obj();
    *buf = 136447234;
    v64 = "nw_necp_append_tlv";
    v65 = 2048;
    v66 = v5;
    v67 = 2048;
    v68 = v7;
    v69 = 1024;
    *v70 = 1;
    *&v70[4] = 1024;
    *&v70[6] = 8;
    v9 = _os_log_send_and_compose_impl();

    v62 = OS_LOG_TYPE_ERROR;
    v61 = 0;
    if (__nwlog_fault(v9, &v62, &v61))
    {
      if (v62 == OS_LOG_TYPE_FAULT)
      {
        v10 = __nwlog_obj();
        v36 = v62;
        if (os_log_type_enabled(v10, v62))
        {
          *buf = 136447234;
          v64 = "nw_necp_append_tlv";
          v65 = 2048;
          v66 = v5;
          v67 = 2048;
          v68 = v7;
          v69 = 1024;
          *v70 = 1;
          *&v70[4] = 1024;
          *&v70[6] = 8;
          _os_log_impl(&dword_181A37000, v10, v36, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
        }

LABEL_47:

        goto LABEL_48;
      }

      if (v61 != 1)
      {
        v10 = __nwlog_obj();
        v44 = v62;
        if (os_log_type_enabled(v10, v62))
        {
          *buf = 136447234;
          v64 = "nw_necp_append_tlv";
          v65 = 2048;
          v66 = v5;
          v67 = 2048;
          v68 = v7;
          v69 = 1024;
          *v70 = 1;
          *&v70[4] = 1024;
          *&v70[6] = 8;
          _os_log_impl(&dword_181A37000, v10, v44, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
        }

        goto LABEL_47;
      }

      v40 = __nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v41 = v62;
      v42 = os_log_type_enabled(v10, v62);
      if (!v40)
      {
        if (v42)
        {
          *buf = 136447234;
          v64 = "nw_necp_append_tlv";
          v65 = 2048;
          v66 = v5;
          v67 = 2048;
          v68 = v7;
          v69 = 1024;
          *v70 = 1;
          *&v70[4] = 1024;
          *&v70[6] = 8;
          _os_log_impl(&dword_181A37000, v10, v41, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
        }

        goto LABEL_47;
      }

      if (v42)
      {
        *buf = 136447490;
        v64 = "nw_necp_append_tlv";
        v65 = 2048;
        v66 = v5;
        v67 = 2048;
        v68 = v7;
        v69 = 1024;
        *v70 = 1;
        *&v70[4] = 1024;
        *&v70[6] = 8;
        *v71 = 2082;
        *&v71[2] = v40;
        _os_log_impl(&dword_181A37000, v10, v41, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
      }

      free(v40);
    }

LABEL_48:
    if (!v9)
    {
LABEL_50:
      v47[3] = 0;
LABEL_51:
      free(v5);
      v20 = 0;
      goto LABEL_52;
    }

LABEL_49:
    free(v9);
    goto LABEL_50;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v12 = gLogObj;
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  *buf = 136446210;
  v64 = "nw_path_override_info_copy_data";
  v13 = _os_log_send_and_compose_impl();

  result = __nwlog_should_abort(v13);
  if (!result)
  {
    free(v13);
    v46 = 0;
    v47 = &v46;
    v48 = 0x2020000000;
    v49 = 0;
    v15 = __nwlog_obj();
    *buf = 136446210;
    v64 = "nw_necp_append_tlv";
    v16 = _os_log_send_and_compose_impl();

    v62 = OS_LOG_TYPE_ERROR;
    v61 = 0;
    if (__nwlog_fault(v16, &v62, &v61))
    {
      if (v62 == OS_LOG_TYPE_FAULT)
      {
        v17 = __nwlog_obj();
        v18 = v62;
        if (os_log_type_enabled(v17, v62))
        {
          *buf = 136446210;
          v64 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A37000, v17, v18, "%{public}s called with null tlv_start", buf, 0xCu);
        }
      }

      else if (v61 == 1)
      {
        v21 = __nw_create_backtrace_string();
        v17 = __nwlog_obj();
        v22 = v62;
        v23 = os_log_type_enabled(v17, v62);
        if (v21)
        {
          if (v23)
          {
            *buf = 136446466;
            v64 = "nw_necp_append_tlv";
            v65 = 2082;
            v66 = v21;
            _os_log_impl(&dword_181A37000, v17, v22, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v21);
          if (!v16)
          {
            goto LABEL_44;
          }

          goto LABEL_43;
        }

        if (v23)
        {
          *buf = 136446210;
          v64 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A37000, v17, v22, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        v17 = __nwlog_obj();
        v27 = v62;
        if (os_log_type_enabled(v17, v62))
        {
          *buf = 136446210;
          v64 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A37000, v17, v27, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    if (!v16)
    {
LABEL_44:
      v20 = 0;
      v47[3] = 0;
      goto LABEL_52;
    }

LABEL_43:
    free(v16);
    goto LABEL_44;
  }

LABEL_91:
  __break(1u);
  return result;
}

void sub_18295F1E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, id a35, char a36)
{
  _Block_object_dispose(&a20, 8);
  _Block_object_dispose(&a30, 8);

  _Block_object_dispose(&a36, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_path_override_info_copy_data_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = nw_resolver_config_copy_plist_data(a3);
  if (v4)
  {
    v5 = *(*(*(a1 + 32) + 8) + 40);
    if (v5 || (v6 = _nw_array_create(), v7 = *(*(a1 + 32) + 8), v8 = *(v7 + 40), *(v7 + 40) = v6, v8, (v5 = *(*(*(a1 + 32) + 8) + 40)) != 0))
    {
      _nw_array_append(v5, v4);
    }

    *(*(*(a1 + 40) + 8) + 24) += dispatch_data_get_size(v4) + 5;
  }

  return 1;
}

uint64_t __nw_path_override_info_copy_data_block_invoke_282(void *a1, uint64_t a2, void *a3)
{
  v66 = *MEMORY[0x1E69E9840];
  v4 = a3;
  size = dispatch_data_get_size(v4);
  if (!size)
  {
    v25 = a1;
    v26 = __nwlog_obj();
    os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
    *applier = 136446210;
    *&applier[4] = "nw_path_override_info_copy_data_block_invoke";
    v27 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v27);
    if (result)
    {
      goto LABEL_113;
    }

    free(v27);
    a1 = v25;
  }

  v6 = malloc_type_malloc(size, 0x3E5E02C7uLL);
  if (v6)
  {
    goto LABEL_5;
  }

  v7 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = gLogObj;
  os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  *applier = 136446210;
  *&applier[4] = "nw_path_override_info_copy_data_block_invoke";
  v9 = _os_log_send_and_compose_impl();

  result = __nwlog_should_abort(v9);
  if (result)
  {
LABEL_113:
    __break(1u);
    return result;
  }

  free(v9);
  a1 = v7;
LABEL_5:
  *type = 0;
  v60 = type;
  v61 = 0x2000000000;
  v62 = 0;
  v58[0] = 0;
  v58[1] = v58;
  v58[2] = 0x2000000000;
  v58[3] = v6;
  if (v4)
  {
    *applier = MEMORY[0x1E69E9820];
    *&applier[8] = 0x40000000;
    *&applier[16] = __nw_dispatch_data_copyout_block_invoke;
    *v64 = &unk_1E6A34348;
    *&v64[16] = v58;
    *&v64[24] = size;
    *&v64[8] = type;
    dispatch_data_apply(v4, applier);
    v11 = *(v60 + 3);
  }

  else
  {
    v11 = 0;
  }

  _Block_object_dispose(v58, 8);
  _Block_object_dispose(type, 8);
  if (v11 != size)
  {
    goto LABEL_38;
  }

  v12 = *(*(a1[4] + 8) + 24);
  if (!v12)
  {
    v28 = a1;
    v29 = __nwlog_obj();
    *applier = 136446210;
    *&applier[4] = "nw_necp_append_tlv";
    v30 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v58[0]) = 0;
    if (__nwlog_fault(v30, type, v58))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v31 = __nwlog_obj();
        v32 = type[0];
        if (os_log_type_enabled(v31, type[0]))
        {
          *applier = 136446210;
          *&applier[4] = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A37000, v31, v32, "%{public}s called with null tlv_start", applier, 0xCu);
        }

        goto LABEL_97;
      }

      if (LOBYTE(v58[0]) != 1)
      {
        v31 = __nwlog_obj();
        v50 = type[0];
        if (os_log_type_enabled(v31, type[0]))
        {
          *applier = 136446210;
          *&applier[4] = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A37000, v31, v50, "%{public}s called with null tlv_start, backtrace limit exceeded", applier, 0xCu);
        }

        goto LABEL_97;
      }

      backtrace_string = __nw_create_backtrace_string();
      v31 = __nwlog_obj();
      v38 = type[0];
      v39 = os_log_type_enabled(v31, type[0]);
      if (!backtrace_string)
      {
        if (v39)
        {
          *applier = 136446210;
          *&applier[4] = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A37000, v31, v38, "%{public}s called with null tlv_start, no backtrace", applier, 0xCu);
        }

        goto LABEL_97;
      }

      if (v39)
      {
        *applier = 136446466;
        *&applier[4] = "nw_necp_append_tlv";
        *&applier[12] = 2082;
        *&applier[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v31, v38, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", applier, 0x16u);
      }

LABEL_67:

      free(backtrace_string);
    }

LABEL_98:
    a1 = v28;
    if (v30)
    {
      free(v30);
    }

    v20 = 0;
    goto LABEL_37;
  }

  v13 = a1[6];
  if (!v13)
  {
    v28 = a1;
    v33 = __nwlog_obj();
    *applier = 136446210;
    *&applier[4] = "nw_necp_append_tlv";
    v30 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v58[0]) = 0;
    if (__nwlog_fault(v30, type, v58))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v31 = __nwlog_obj();
        v34 = type[0];
        if (os_log_type_enabled(v31, type[0]))
        {
          *applier = 136446210;
          *&applier[4] = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A37000, v31, v34, "%{public}s called with null beyond", applier, 0xCu);
        }

LABEL_97:

        goto LABEL_98;
      }

      if (LOBYTE(v58[0]) != 1)
      {
        v31 = __nwlog_obj();
        v51 = type[0];
        if (os_log_type_enabled(v31, type[0]))
        {
          *applier = 136446210;
          *&applier[4] = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A37000, v31, v51, "%{public}s called with null beyond, backtrace limit exceeded", applier, 0xCu);
        }

        goto LABEL_97;
      }

      backtrace_string = __nw_create_backtrace_string();
      v31 = __nwlog_obj();
      v40 = type[0];
      v41 = os_log_type_enabled(v31, type[0]);
      if (!backtrace_string)
      {
        if (v41)
        {
          *applier = 136446210;
          *&applier[4] = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A37000, v31, v40, "%{public}s called with null beyond, no backtrace", applier, 0xCu);
        }

        goto LABEL_97;
      }

      if (v41)
      {
        *applier = 136446466;
        *&applier[4] = "nw_necp_append_tlv";
        *&applier[12] = 2082;
        *&applier[14] = backtrace_string;
        _os_log_impl(&dword_181A37000, v31, v40, "%{public}s called with null beyond, dumping backtrace:%{public}s", applier, 0x16u);
      }

      goto LABEL_67;
    }

    goto LABEL_98;
  }

  v14 = v13 + *(*(a1[5] + 8) + 24);
  if (v12 >= v14)
  {
    v57 = a1;
    v35 = __nwlog_obj();
    *applier = 136447234;
    *&applier[4] = "nw_necp_append_tlv";
    *&applier[12] = 2048;
    *&applier[14] = v12;
    *&applier[22] = 2048;
    *v64 = v14;
    *&v64[8] = 1024;
    *&v64[10] = 2;
    *&v64[14] = 1024;
    *&v64[16] = size;
    v17 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v58[0]) = 0;
    if (__nwlog_fault(v17, type, v58))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v18 = __nwlog_obj();
        v36 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *applier = 136447234;
          *&applier[4] = "nw_necp_append_tlv";
          *&applier[12] = 2048;
          *&applier[14] = v12;
          *&applier[22] = 2048;
          *v64 = v14;
          *&v64[8] = 1024;
          *&v64[10] = 2;
          *&v64[14] = 1024;
          *&v64[16] = size;
          _os_log_impl(&dword_181A37000, v18, v36, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", applier, 0x2Cu);
        }

LABEL_33:

        goto LABEL_34;
      }

      if (LOBYTE(v58[0]) != 1)
      {
        v18 = __nwlog_obj();
        v52 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *applier = 136447234;
          *&applier[4] = "nw_necp_append_tlv";
          *&applier[12] = 2048;
          *&applier[14] = v12;
          *&applier[22] = 2048;
          *v64 = v14;
          *&v64[8] = 1024;
          *&v64[10] = 2;
          *&v64[14] = 1024;
          *&v64[16] = size;
          _os_log_impl(&dword_181A37000, v18, v52, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", applier, 0x2Cu);
        }

        goto LABEL_33;
      }

      v42 = __nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v43 = type[0];
      v44 = os_log_type_enabled(v18, type[0]);
      if (!v42)
      {
        if (v44)
        {
          *applier = 136447234;
          *&applier[4] = "nw_necp_append_tlv";
          *&applier[12] = 2048;
          *&applier[14] = v12;
          *&applier[22] = 2048;
          *v64 = v14;
          *&v64[8] = 1024;
          *&v64[10] = 2;
          *&v64[14] = 1024;
          *&v64[16] = size;
          _os_log_impl(&dword_181A37000, v18, v43, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", applier, 0x2Cu);
        }

        goto LABEL_33;
      }

      if (v44)
      {
        *applier = 136447490;
        *&applier[4] = "nw_necp_append_tlv";
        *&applier[12] = 2048;
        *&applier[14] = v12;
        *&applier[22] = 2048;
        *v64 = v14;
        *&v64[8] = 1024;
        *&v64[10] = 2;
        *&v64[14] = 1024;
        *&v64[16] = size;
        *&v64[20] = 2082;
        *&v64[22] = v42;
        _os_log_impl(&dword_181A37000, v18, v43, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", applier, 0x36u);
      }

      free(v42);
    }

LABEL_34:
    if (!v17)
    {
LABEL_36:
      v20 = 0;
      a1 = v57;
      goto LABEL_37;
    }

LABEL_35:
    free(v17);
    goto LABEL_36;
  }

  v15 = size + 5;
  if (v14 - v12 < v15)
  {
    v57 = a1;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = gLogObj;
    *applier = 136447490;
    *&applier[4] = "nw_necp_append_tlv";
    *&applier[12] = 2048;
    *&applier[14] = v12;
    *&applier[22] = 2048;
    *v64 = size + 5;
    *&v64[8] = 2048;
    *&v64[10] = v14;
    *&v64[18] = 1024;
    *&v64[20] = 2;
    *&v64[24] = 1024;
    *&v64[26] = size;
    v17 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v58[0]) = 0;
    if (!__nwlog_fault(v17, type, v58))
    {
      goto LABEL_34;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = gLogObj;
      v19 = type[0];
      if (os_log_type_enabled(v18, type[0]))
      {
        *applier = 136447490;
        *&applier[4] = "nw_necp_append_tlv";
        *&applier[12] = 2048;
        *&applier[14] = v12;
        *&applier[22] = 2048;
        *v64 = size + 5;
        *&v64[8] = 2048;
        *&v64[10] = v14;
        *&v64[18] = 1024;
        *&v64[20] = 2;
        *&v64[24] = 1024;
        *&v64[26] = size;
        _os_log_impl(&dword_181A37000, v18, v19, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", applier, 0x36u);
      }
    }

    else if (LOBYTE(v58[0]) == 1)
    {
      v21 = __nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = gLogObj;
      v22 = type[0];
      v23 = os_log_type_enabled(v18, type[0]);
      if (v21)
      {
        if (v23)
        {
          *applier = 136447746;
          *&applier[4] = "nw_necp_append_tlv";
          *&applier[12] = 2048;
          *&applier[14] = v12;
          *&applier[22] = 2048;
          *v64 = size + 5;
          *&v64[8] = 2048;
          *&v64[10] = v14;
          *&v64[18] = 1024;
          *&v64[20] = 2;
          *&v64[24] = 1024;
          *&v64[26] = size;
          *&v64[30] = 2082;
          v65 = v21;
          _os_log_impl(&dword_181A37000, v18, v22, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", applier, 0x40u);
        }

        free(v21);
        if (!v17)
        {
          goto LABEL_36;
        }

        goto LABEL_35;
      }

      if (v23)
      {
        *applier = 136447490;
        *&applier[4] = "nw_necp_append_tlv";
        *&applier[12] = 2048;
        *&applier[14] = v12;
        *&applier[22] = 2048;
        *v64 = size + 5;
        *&v64[8] = 2048;
        *&v64[10] = v14;
        *&v64[18] = 1024;
        *&v64[20] = 2;
        *&v64[24] = 1024;
        *&v64[26] = size;
        _os_log_impl(&dword_181A37000, v18, v22, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", applier, 0x36u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = gLogObj;
      v24 = type[0];
      if (os_log_type_enabled(v18, type[0]))
      {
        *applier = 136447490;
        *&applier[4] = "nw_necp_append_tlv";
        *&applier[12] = 2048;
        *&applier[14] = v12;
        *&applier[22] = 2048;
        *v64 = size + 5;
        *&v64[8] = 2048;
        *&v64[10] = v14;
        *&v64[18] = 1024;
        *&v64[20] = 2;
        *&v64[24] = 1024;
        *&v64[26] = size;
        _os_log_impl(&dword_181A37000, v18, v24, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", applier, 0x36u);
      }
    }

    goto LABEL_33;
  }

  *v12 = 2;
  *(v12 + 1) = size;
  if (size)
  {
    if (v6)
    {
      memcpy((v12 + 5), v6, size);
      goto LABEL_21;
    }

    v45 = a1;
    v46 = __nwlog_obj();
    *applier = 136446722;
    *&applier[4] = "nw_necp_append_tlv";
    *&applier[12] = 1024;
    *&applier[14] = 2;
    *&applier[18] = 1024;
    *&applier[20] = size;
    v47 = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v58[0]) = 0;
    if (__nwlog_fault(v47, type, v58))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v48 = __nwlog_obj();
        v49 = type[0];
        if (os_log_type_enabled(v48, type[0]))
        {
          *applier = 136446722;
          *&applier[4] = "nw_necp_append_tlv";
          *&applier[12] = 1024;
          *&applier[14] = 2;
          *&applier[18] = 1024;
          *&applier[20] = size;
          _os_log_impl(&dword_181A37000, v48, v49, "%{public}s type=%u length=%u but value is NULL", applier, 0x18u);
        }
      }

      else if (LOBYTE(v58[0]) == 1)
      {
        v53 = __nw_create_backtrace_string();
        v48 = __nwlog_obj();
        v54 = type[0];
        v55 = os_log_type_enabled(v48, type[0]);
        if (v53)
        {
          if (v55)
          {
            *applier = 136446978;
            *&applier[4] = "nw_necp_append_tlv";
            *&applier[12] = 1024;
            *&applier[14] = 2;
            *&applier[18] = 1024;
            *&applier[20] = size;
            *v64 = 2082;
            *&v64[2] = v53;
            _os_log_impl(&dword_181A37000, v48, v54, "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s", applier, 0x22u);
          }

          free(v53);
          goto LABEL_110;
        }

        if (v55)
        {
          *applier = 136446722;
          *&applier[4] = "nw_necp_append_tlv";
          *&applier[12] = 1024;
          *&applier[14] = 2;
          *&applier[18] = 1024;
          *&applier[20] = size;
          _os_log_impl(&dword_181A37000, v48, v54, "%{public}s type=%u length=%u but value is NULL, no backtrace", applier, 0x18u);
        }
      }

      else
      {
        v48 = __nwlog_obj();
        v56 = type[0];
        if (os_log_type_enabled(v48, type[0]))
        {
          *applier = 136446722;
          *&applier[4] = "nw_necp_append_tlv";
          *&applier[12] = 1024;
          *&applier[14] = 2;
          *&applier[18] = 1024;
          *&applier[20] = size;
          _os_log_impl(&dword_181A37000, v48, v56, "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded", applier, 0x18u);
        }
      }
    }

LABEL_110:
    if (v47)
    {
      free(v47);
    }

    v20 = 0;
    a1 = v45;
    goto LABEL_37;
  }

LABEL_21:
  v20 = v12 + v15;
LABEL_37:
  *(*(a1[4] + 8) + 24) = v20;
LABEL_38:
  if (v6)
  {
    free(v6);
  }

  return 1;
}

uint64_t NWPBPathReadFrom(uint64_t a1, void *a2)
{
  v4 = [a2 position];
  if (v4 < [a2 length])
  {
    do
    {
      if ([a2 hasError])
      {
        return [a2 hasError] ^ 1;
      }

      v6 = 0;
      v7 = 0;
      v8 = 0;
      while (1)
      {
        LOBYTE(v58) = 0;
        v9 = [a2 position] + 1;
        if (v9 >= [a2 position] && (v10 = objc_msgSend(a2, "position") + 1, v10 <= objc_msgSend(a2, "length")))
        {
          v11 = [a2 data];
          [v11 getBytes:&v58 range:{objc_msgSend(a2, "position"), 1}];

          [a2 setPosition:{objc_msgSend(a2, "position") + 1}];
        }

        else
        {
          [a2 _setError];
        }

        v8 |= (v58 & 0x7F) << v6;
        if ((v58 & 0x80) == 0)
        {
          break;
        }

        v6 += 7;
        v12 = v7++ >= 9;
        if (v12)
        {
          v13 = 0;
          goto LABEL_18;
        }
      }

      v13 = [a2 hasError] ? 0 : v8;
LABEL_18:
      if (([a2 hasError] & 1) != 0 || (v13 & 7) == 4)
      {
        return [a2 hasError] ^ 1;
      }

      v14 = v13 >> 3;
      if ((v13 >> 3) <= 5)
      {
        if (v14 <= 2)
        {
          if (v14 == 1)
          {
            v22 = objc_alloc_init(NWPBEndpoint);
            objc_storeStrong((a1 + 40), v22);
            v58 = 0;
            v59 = 0;
            if (!PBReaderPlaceMark() || !NWPBEndpointReadFrom(v22, a2))
            {
              goto LABEL_113;
            }

            goto LABEL_3;
          }

          if (v14 == 2)
          {
            v22 = objc_alloc_init(NWPBParameters);
            objc_storeStrong((a1 + 48), v22);
            v58 = 0;
            v59 = 0;
            if (!PBReaderPlaceMark() || !NWPBParametersReadFrom(v22, a2))
            {
              goto LABEL_113;
            }

            goto LABEL_3;
          }
        }

        else
        {
          switch(v14)
          {
            case 3:
              v48 = PBReaderReadString();
              v49 = *(a1 + 16);
              *(a1 + 16) = v48;

              goto LABEL_4;
            case 4:
              v31 = 0;
              v32 = 0;
              v33 = 0;
              *(a1 + 64) |= 1u;
              while (1)
              {
                LOBYTE(v58) = 0;
                v34 = [a2 position] + 1;
                if (v34 >= [a2 position] && (v35 = objc_msgSend(a2, "position") + 1, v35 <= objc_msgSend(a2, "length")))
                {
                  v36 = [a2 data];
                  [v36 getBytes:&v58 range:{objc_msgSend(a2, "position"), 1}];

                  [a2 setPosition:{objc_msgSend(a2, "position") + 1}];
                }

                else
                {
                  [a2 _setError];
                }

                v33 |= (v58 & 0x7F) << v31;
                if ((v58 & 0x80) == 0)
                {
                  break;
                }

                v31 += 7;
                v12 = v32++ >= 9;
                if (v12)
                {
                  v37 = 0;
                  goto LABEL_103;
                }
              }

              if ([a2 hasError])
              {
                v37 = 0;
              }

              else
              {
                v37 = v33;
              }

LABEL_103:
              *(a1 + 56) = v37;
              goto LABEL_4;
            case 5:
              v22 = objc_alloc_init(NWPBInterface);
              v23 = 32;
              goto LABEL_86;
          }
        }
      }

      else if (v14 > 8)
      {
        switch(v14)
        {
          case 9:
            v50 = 0;
            v51 = 0;
            v52 = 0;
            *(a1 + 64) |= 8u;
            while (1)
            {
              LOBYTE(v58) = 0;
              v53 = [a2 position] + 1;
              if (v53 >= [a2 position] && (v54 = objc_msgSend(a2, "position") + 1, v54 <= objc_msgSend(a2, "length")))
              {
                v55 = [a2 data];
                [v55 getBytes:&v58 range:{objc_msgSend(a2, "position"), 1}];

                [a2 setPosition:{objc_msgSend(a2, "position") + 1}];
              }

              else
              {
                [a2 _setError];
              }

              v52 |= (v58 & 0x7F) << v50;
              if ((v58 & 0x80) == 0)
              {
                break;
              }

              v50 += 7;
              v12 = v51++ >= 9;
              if (v12)
              {
                LOBYTE(v56) = 0;
                goto LABEL_111;
              }
            }

            v56 = (v52 != 0) & ~[a2 hasError];
LABEL_111:
            *(a1 + 62) = v56;
            goto LABEL_4;
          case 0xA:
            v41 = 0;
            v42 = 0;
            v43 = 0;
            *(a1 + 64) |= 0x10u;
            while (1)
            {
              LOBYTE(v58) = 0;
              v44 = [a2 position] + 1;
              if (v44 >= [a2 position] && (v45 = objc_msgSend(a2, "position") + 1, v45 <= objc_msgSend(a2, "length")))
              {
                v46 = [a2 data];
                [v46 getBytes:&v58 range:{objc_msgSend(a2, "position"), 1}];

                [a2 setPosition:{objc_msgSend(a2, "position") + 1}];
              }

              else
              {
                [a2 _setError];
              }

              v43 |= (v58 & 0x7F) << v41;
              if ((v58 & 0x80) == 0)
              {
                break;
              }

              v41 += 7;
              v12 = v42++ >= 9;
              if (v12)
              {
                LOBYTE(v47) = 0;
                goto LABEL_105;
              }
            }

            v47 = (v43 != 0) & ~[a2 hasError];
LABEL_105:
            *(a1 + 63) = v47;
            goto LABEL_4;
          case 0xB:
            v24 = 0;
            v25 = 0;
            v26 = 0;
            *(a1 + 64) |= 2u;
            while (1)
            {
              LOBYTE(v58) = 0;
              v27 = [a2 position] + 1;
              if (v27 >= [a2 position] && (v28 = objc_msgSend(a2, "position") + 1, v28 <= objc_msgSend(a2, "length")))
              {
                v29 = [a2 data];
                [v29 getBytes:&v58 range:{objc_msgSend(a2, "position"), 1}];

                [a2 setPosition:{objc_msgSend(a2, "position") + 1}];
              }

              else
              {
                [a2 _setError];
              }

              v26 |= (v58 & 0x7F) << v24;
              if ((v58 & 0x80) == 0)
              {
                break;
              }

              v24 += 7;
              v12 = v25++ >= 9;
              if (v12)
              {
                LOBYTE(v30) = 0;
                goto LABEL_109;
              }
            }

            v30 = (v26 != 0) & ~[a2 hasError];
LABEL_109:
            *(a1 + 60) = v30;
            goto LABEL_4;
        }
      }

      else
      {
        switch(v14)
        {
          case 6:
            v22 = objc_alloc_init(NWPBInterface);
            v23 = 24;
LABEL_86:
            objc_storeStrong((a1 + v23), v22);
            v58 = 0;
            v59 = 0;
            if (!PBReaderPlaceMark() || !NWPBInterfaceReadFrom(v22, a2))
            {
              goto LABEL_113;
            }

LABEL_3:
            PBReaderRecallMark();

            goto LABEL_4;
          case 7:
            v22 = objc_alloc_init(NWPBAgent);
            if (a1)
            {
              v38 = *(a1 + 8);
              if (!v38)
              {
                v39 = objc_alloc_init(MEMORY[0x1E695DF70]);
                v40 = *(a1 + 8);
                *(a1 + 8) = v39;

                v38 = *(a1 + 8);
              }

              [v38 addObject:v22];
            }

            v58 = 0;
            v59 = 0;
            if (!PBReaderPlaceMark() || !NWPBAgentReadFrom(v22, a2))
            {
LABEL_113:

              return 0;
            }

            goto LABEL_3;
          case 8:
            v15 = 0;
            v16 = 0;
            v17 = 0;
            *(a1 + 64) |= 4u;
            while (1)
            {
              LOBYTE(v58) = 0;
              v18 = [a2 position] + 1;
              if (v18 >= [a2 position] && (v19 = objc_msgSend(a2, "position") + 1, v19 <= objc_msgSend(a2, "length")))
              {
                v20 = [a2 data];
                [v20 getBytes:&v58 range:{objc_msgSend(a2, "position"), 1}];

                [a2 setPosition:{objc_msgSend(a2, "position") + 1}];
              }

              else
              {
                [a2 _setError];
              }

              v17 |= (v58 & 0x7F) << v15;
              if ((v58 & 0x80) == 0)
              {
                break;
              }

              v15 += 7;
              v12 = v16++ >= 9;
              if (v12)
              {
                LOBYTE(v21) = 0;
                goto LABEL_107;
              }
            }

            v21 = (v17 != 0) & ~[a2 hasError];
LABEL_107:
            *(a1 + 61) = v21;
            goto LABEL_4;
        }
      }

      if ((PBReaderSkipValueWithTag() & 1) == 0)
      {
        return 0;
      }

LABEL_4:
      v5 = [a2 position];
    }

    while (v5 < [a2 length]);
  }

  return [a2 hasError] ^ 1;
}

void ___ZL47nw_protocol_http_connection_state_get_callbacksv_block_invoke()
{
  nw_protocol_http_connection_state_get_callbacks(void)::protocol_callbacks = nw_protocol_common_add_input_handler;
  qword_1EA83F780 = nw_protocol_common_replace_input_handler;
  qword_1EA83F7C8 = nw_protocol_common_get_output_frames;
  qword_1EA83F7D0 = nw_protocol_common_finalize_output_frames;
  qword_1EA83F7E0 = nw_protocol_common_get_parameters;
  qword_1EA83F7E8 = nw_protocol_common_get_path;
  qword_1EA83F7F0 = nw_protocol_common_get_local_endpoint;
  qword_1EA83F838 = nw_protocol_common_get_output_local_endpoint;
  qword_1EA83F840 = nw_protocol_common_get_output_interface;
  qword_1EA83F798 = nw_protocol_common_connected;
  qword_1EA83F790 = nw_protocol_common_disconnect;
  qword_1EA83F7A0 = nw_protocol_common_disconnected;
  qword_1EA83F7B0 = nw_protocol_common_input_available;
  qword_1EA83F7B8 = nw_protocol_common_output_available;
  qword_1EA83F828 = nw_protocol_common_input_finished;
  qword_1EA83F830 = nw_protocol_common_output_finished;
  qword_1EA83F878 = nw_protocol_common_input_flush;
  qword_1EA83F7A8 = nw_protocol_common_error;
  qword_1EA83F870 = nw_protocol_common_reset;
  qword_1EA83F868 = nw_protocol_common_get_message_properties;
  qword_1EA83F820 = nw_protocol_common_supports_external_data;
  qword_1EA83F848 = nw_protocol_common_waiting_for_output;
  qword_1EA83F800 = nw_protocol_common_register_notification;
  qword_1EA83F808 = nw_protocol_common_unregister_notification;
  qword_1EA83F810 = nw_protocol_common_notify;
  qword_1EA83F818 = nw_protocol_common_updated_path;
  qword_1EA83F7D8 = nw_protocol_common_link_state;
  qword_1EA83F788 = nw_protocol_http_connection_state_connect;
  qword_1EA83F7F8 = nw_protocol_http_connection_state_get_remote_endpoint;
  qword_1EA83F778 = nw_protocol_http_connection_state_remove_input_handler;
  qword_1EA83F7C0 = nw_protocol_http_connection_state_get_input_frames;
  qword_1EA83F850 = nw_protocol_http_connection_state_copy_info;
}

uint64_t nw_protocol_http_connection_state_get_input_frames(nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  v27 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    __nwlog_obj();
    *buf = 136446210;
    v24 = "nw_protocol_http_connection_state_get_input_frames";
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v10, &type, &v21))
    {
      goto LABEL_62;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v24 = "nw_protocol_http_connection_state_get_input_frames";
      v13 = "%{public}s called with null protocol";
    }

    else if (v21 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *buf = 136446466;
          v24 = "nw_protocol_http_connection_state_get_input_frames";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_62:
        if (!v10)
        {
          return 0;
        }

LABEL_63:
        free(v10);
        return 0;
      }

      if (!v15)
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v24 = "nw_protocol_http_connection_state_get_input_frames";
      v13 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v24 = "nw_protocol_http_connection_state_get_input_frames";
      v13 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_61;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *buf = 136446210;
    v24 = "nw_protocol_http_connection_state_get_input_frames";
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v10, &type, &v21))
    {
      goto LABEL_62;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v21 != 1)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
        {
          goto LABEL_62;
        }

        *buf = 136446210;
        v24 = "nw_protocol_http_connection_state_get_input_frames";
        v13 = "%{public}s called with null http_connection_state, backtrace limit exceeded";
        goto LABEL_61;
      }

      v16 = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v17 = os_log_type_enabled(v11, type);
      if (!v16)
      {
        if (!v17)
        {
          goto LABEL_62;
        }

        *buf = 136446210;
        v24 = "nw_protocol_http_connection_state_get_input_frames";
        v13 = "%{public}s called with null http_connection_state, no backtrace";
        goto LABEL_61;
      }

      if (!v17)
      {
        goto LABEL_43;
      }

      *buf = 136446466;
      v24 = "nw_protocol_http_connection_state_get_input_frames";
      v25 = 2082;
      v26 = v16;
      v18 = "%{public}s called with null http_connection_state, dumping backtrace:%{public}s";
      goto LABEL_42;
    }

    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
    {
      goto LABEL_62;
    }

    *buf = 136446210;
    v24 = "nw_protocol_http_connection_state_get_input_frames";
    v13 = "%{public}s called with null http_connection_state";
LABEL_61:
    _os_log_impl(&dword_181A37000, v11, v12, v13, buf, 0xCu);
    goto LABEL_62;
  }

  if (!a2)
  {
    __nwlog_obj();
    *buf = 136446210;
    v24 = "nw_protocol_http_connection_state_get_input_frames";
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v10, &type, &v21))
    {
      goto LABEL_62;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v24 = "nw_protocol_http_connection_state_get_input_frames";
      v13 = "%{public}s called with null input_protocol";
      goto LABEL_61;
    }

    if (v21 != 1)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v24 = "nw_protocol_http_connection_state_get_input_frames";
      v13 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_61;
    }

    v16 = __nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v12 = type;
    v19 = os_log_type_enabled(v11, type);
    if (!v16)
    {
      if (!v19)
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v24 = "nw_protocol_http_connection_state_get_input_frames";
      v13 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_61;
    }

    if (!v19)
    {
      goto LABEL_43;
    }

    *buf = 136446466;
    v24 = "nw_protocol_http_connection_state_get_input_frames";
    v25 = 2082;
    v26 = v16;
    v18 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
LABEL_42:
    _os_log_impl(&dword_181A37000, v11, v12, v18, buf, 0x16u);
    goto LABEL_43;
  }

  if (!a6)
  {
    __nwlog_obj();
    *buf = 136446210;
    v24 = "nw_protocol_http_connection_state_get_input_frames";
    v10 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v10, &type, &v21))
    {
      goto LABEL_62;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v24 = "nw_protocol_http_connection_state_get_input_frames";
      v13 = "%{public}s called with null return_array";
      goto LABEL_61;
    }

    if (v21 != 1)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v24 = "nw_protocol_http_connection_state_get_input_frames";
      v13 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_61;
    }

    v16 = __nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v12 = type;
    v20 = os_log_type_enabled(v11, type);
    if (!v16)
    {
      if (!v20)
      {
        goto LABEL_62;
      }

      *buf = 136446210;
      v24 = "nw_protocol_http_connection_state_get_input_frames";
      v13 = "%{public}s called with null return_array, no backtrace";
      goto LABEL_61;
    }

    if (v20)
    {
      *buf = 136446466;
      v24 = "nw_protocol_http_connection_state_get_input_frames";
      v25 = 2082;
      v26 = v16;
      v18 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
      goto LABEL_42;
    }

LABEL_43:
    free(v16);
    if (!v10)
    {
      return 0;
    }

    goto LABEL_63;
  }

  v8 = handle[4];
  if (!v8)
  {
    return 0;
  }

  return nw_protocol_get_input_frames(v8, handle, a3, a4, a5, a6);
}

uint64_t __Block_byref_object_copy__74065(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(result + 48) = *(result + 48) & 0xFE | *(a2 + 48) & 1;
  *(a2 + 40) = 0;
  *(a2 + 48) &= ~1u;
  return result;
}

uint64_t __Block_byref_object_dispose__74066(uint64_t result)
{
  if ((*(result + 48) & 1) != 0 && *(result + 40))
  {
    v1 = result;
    os_release(*(result + 40));
    result = v1;
  }

  *(result + 40) = 0;
  return result;
}

uint64_t __Block_byref_object_copy__19_74067(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(result + 48) = *(result + 48) & 0xFE | *(a2 + 48) & 1;
  *(a2 + 40) = 0;
  *(a2 + 48) &= ~1u;
  return result;
}

uint64_t __Block_byref_object_dispose__20_74068(uint64_t result)
{
  if ((*(result + 48) & 1) != 0 && *(result + 40))
  {
    v1 = result;
    os_release(*(result + 40));
    result = v1;
  }

  *(result + 40) = 0;
  return result;
}

uint64_t __Block_byref_object_copy__21_74069(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(result + 48) = *(result + 48) & 0xFE | *(a2 + 48) & 1;
  *(a2 + 40) = 0;
  *(a2 + 48) &= ~1u;
  return result;
}

uint64_t __Block_byref_object_dispose__22_74070(uint64_t result)
{
  if ((*(result + 48) & 1) != 0 && *(result + 40))
  {
    v1 = result;
    os_release(*(result + 40));
    result = v1;
  }

  *(result + 40) = 0;
  return result;
}

double __nw_protocol_http_connection_state_identifier_block_invoke()
{
  strcpy(&nw_protocol_http_connection_state_identifier::protocol_identifier, "http_connection_state");
  *&result = 0x100000005;
  qword_1EA83F9B0 = 0x100000005;
  return result;
}

uint64_t nw_endpoint_create_address_with_ethernet(uint64_t a1, uint64_t a2)
{
  v16 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_endpoint_create_address_with_ethernet(a1, a2);
  }

  v3 = __nwlog_obj();
  *buf = 136446210;
  v13 = "nw_endpoint_create_address_with_ethernet";
  v4 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v13 = "nw_endpoint_create_address_with_ethernet";
        v7 = "%{public}s called with null address";
LABEL_18:
        _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0xCu);
      }
    }

    else
    {
      if (v10 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v5 = __nwlog_obj();
        v6 = type;
        v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *buf = 136446466;
            v13 = "nw_endpoint_create_address_with_ethernet";
            v14 = 2082;
            v15 = backtrace_string;
            _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null address, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v9)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v13 = "nw_endpoint_create_address_with_ethernet";
        v7 = "%{public}s called with null address, no backtrace";
        goto LABEL_18;
      }

      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v13 = "nw_endpoint_create_address_with_ethernet";
        v7 = "%{public}s called with null address, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v4)
  {
    free(v4);
  }

  return 0;
}

uint64_t nw_endpoint_create_unix(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if (a1)
  {

    return _nw_endpoint_create_unix();
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_endpoint_create_unix";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_endpoint_create_unix";
        v6 = "%{public}s called with null path";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_endpoint_create_unix";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_endpoint_create_unix";
        v6 = "%{public}s called with null path, no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_endpoint_create_unix";
        v6 = "%{public}s called with null path, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

uint64_t nw_endpoint_create_address_with_port(uint64_t a1, uint64_t a2)
{
  v19 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v3 = __nwlog_obj();
    *buf = 136446210;
    v16 = "nw_endpoint_create_address_with_port";
    v4 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v4, &type, &v13))
    {
      goto LABEL_35;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_create_address_with_port";
        v7 = "%{public}s called with null address";
LABEL_33:
        _os_log_impl(&dword_181A37000, v5, v6, v7, buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v10 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *buf = 136446466;
          v16 = "nw_endpoint_create_address_with_port";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null address, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_35:
        if (!v4)
        {
          return 0;
        }

LABEL_36:
        free(v4);
        return 0;
      }

      if (v10)
      {
        *buf = 136446210;
        v16 = "nw_endpoint_create_address_with_port";
        v7 = "%{public}s called with null address, no backtrace";
        goto LABEL_33;
      }
    }

    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_create_address_with_port";
        v7 = "%{public}s called with null address, backtrace limit exceeded";
        goto LABEL_33;
      }
    }

LABEL_34:

    goto LABEL_35;
  }

  if (!a2)
  {
    v8 = __nwlog_obj();
    *buf = 136446210;
    v16 = "nw_endpoint_create_address_with_port";
    v4 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v4, &type, &v13))
    {
      goto LABEL_35;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_create_address_with_port";
        v7 = "%{public}s called with null port";
        goto LABEL_33;
      }
    }

    else
    {
      if (v13 == 1)
      {
        v11 = __nw_create_backtrace_string();
        v5 = __nwlog_obj();
        v6 = type;
        v12 = os_log_type_enabled(v5, type);
        if (v11)
        {
          if (v12)
          {
            *buf = 136446466;
            v16 = "nw_endpoint_create_address_with_port";
            v17 = 2082;
            v18 = v11;
            _os_log_impl(&dword_181A37000, v5, v6, "%{public}s called with null port, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v11);
          if (!v4)
          {
            return 0;
          }

          goto LABEL_36;
        }

        if (!v12)
        {
          goto LABEL_34;
        }

        *buf = 136446210;
        v16 = "nw_endpoint_create_address_with_port";
        v7 = "%{public}s called with null port, no backtrace";
        goto LABEL_33;
      }

      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_create_address_with_port";
        v7 = "%{public}s called with null port, backtrace limit exceeded";
        goto LABEL_33;
      }
    }

    goto LABEL_34;
  }

  return _nw_endpoint_create_address_with_port();
}

id nw_endpoint_create_with_peer_name(uint64_t a1)
{
  v15 = *MEMORY[0x1E69E9840];
  if ((a1 & 0x80000000) == 0)
  {

    return _nw_endpoint_create_with_peer_name(a1);
  }

  v2 = __nwlog_obj();
  *buf = 136446210;
  v12 = "nw_endpoint_create_with_peer_name";
  v3 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_endpoint_create_with_peer_name";
        v6 = "%{public}s called with null (sockfd >= 0)";
LABEL_18:
        _os_log_impl(&dword_181A37000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *buf = 136446466;
            v12 = "nw_endpoint_create_with_peer_name";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_181A37000, v4, v5, "%{public}s called with null (sockfd >= 0), dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v8)
        {
          goto LABEL_19;
        }

        *buf = 136446210;
        v12 = "nw_endpoint_create_with_peer_name";
        v6 = "%{public}s called with null (sockfd >= 0), no backtrace";
        goto LABEL_18;
      }

      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *buf = 136446210;
        v12 = "nw_endpoint_create_with_peer_name";
        v6 = "%{public}s called with null (sockfd >= 0), backtrace limit exceeded";
        goto LABEL_18;
      }
    }

LABEL_19:
  }

LABEL_20:
  if (v3)
  {
    free(v3);
  }

  return 0;
}

uint64_t nw_endpoint_fillout_v4_address(void *a1, uint64_t a2)
{
  v28 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = v3;
    v6 = _nw_endpoint_get_type(v5);

    if (v6 == 1)
    {
      v7 = _nw_endpoint_fillout_v4_address(v5, a2);
      goto LABEL_4;
    }

    v13 = __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_endpoint_fillout_v4_address";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (__nwlog_fault(v10, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          v25 = "nw_endpoint_fillout_v4_address";
          _os_log_impl(&dword_181A37000, v11, v14, "%{public}s called with null (nw_endpoint_get_type(endpoint) == nw_endpoint_type_address)", buf, 0xCu);
        }

LABEL_36:

        goto LABEL_37;
      }

      if (v22 != 1)
      {
        v11 = __nwlog_obj();
        v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          v25 = "nw_endpoint_fillout_v4_address";
          _os_log_impl(&dword_181A37000, v11, v21, "%{public}s called with null (nw_endpoint_get_type(endpoint) == nw_endpoint_type_address), backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_36;
      }

      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *buf = 136446210;
          v25 = "nw_endpoint_fillout_v4_address";
          _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null (nw_endpoint_get_type(endpoint) == nw_endpoint_type_address), no backtrace", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v19)
      {
        *buf = 136446466;
        v25 = "nw_endpoint_fillout_v4_address";
        v26 = 2082;
        v27 = backtrace_string;
        _os_log_impl(&dword_181A37000, v11, v18, "%{public}s called with null (nw_endpoint_get_type(endpoint) == nw_endpoint_type_address), dumping backtrace:%{public}s", buf, 0x16u);
      }

      goto LABEL_24;
    }
  }

  else
  {
    v9 = __nwlog_obj();
    *buf = 136446210;
    v25 = "nw_endpoint_fillout_v4_address";
    v10 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (__nwlog_fault(v10, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          v25 = "nw_endpoint_fillout_v4_address";
          _os_log_impl(&dword_181A37000, v11, v12, "%{public}s called with null endpoint", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v22 != 1)
      {
        v11 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *buf = 136446210;
          v25 = "nw_endpoint_fillout_v4_address";
          _os_log_impl(&dword_181A37000, v11, v20, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_36;
      }

      backtrace_string = __nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *buf = 136446210;
          v25 = "nw_endpoint_fillout_v4_address";
          _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }

        goto LABEL_36;
      }

      if (v17)
      {
        *buf = 136446466;
        v25 = "nw_endpoint_fillout_v4_address";
        v26 = 2082;
        v27 = backtrace_string;
        _os_log_impl(&dword_181A37000, v11, v16, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }

LABEL_24:

      free(backtrace_string);
    }
  }

LABEL_37:
  if (v10)
  {
    free(v10);
  }

  v7 = 0;
LABEL_4:

  return v7;
}

uint64_t nw_endpoint_is_broadcast(void *a1, void *a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    is_broadcast = _nw_endpoint_is_broadcast(v3);
    goto LABEL_3;
  }

  v7 = __nwlog_obj();
  *buf = 136446210;
  v18 = "nw_endpoint_is_broadcast";
  v8 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_endpoint_is_broadcast";
        _os_log_impl(&dword_181A37000, v9, v10, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v15 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *buf = 136446466;
          v18 = "nw_endpoint_is_broadcast";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *buf = 136446210;
        v18 = "nw_endpoint_is_broadcast";
        _os_log_impl(&dword_181A37000, v9, v12, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v9 = __nwlog_obj();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *buf = 136446210;
        v18 = "nw_endpoint_is_broadcast";
        _os_log_impl(&dword_181A37000, v9, v14, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v8)
  {
    free(v8);
  }

  is_broadcast = 0;
LABEL_3:

  return is_broadcast;
}

BOOL nw_endpoint_is_multicast(void *a1)
{
  v19 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    is_multicast = _nw_endpoint_is_multicast(v1);
    goto LABEL_3;
  }

  v5 = __nwlog_obj();
  *buf = 136446210;
  v16 = "nw_endpoint_is_multicast";
  v6 = _os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_is_multicast";
        _os_log_impl(&dword_181A37000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13 == 1)
    {
      backtrace_string = __nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *buf = 136446466;
          v16 = "nw_endpoint_is_multicast";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *buf = 136446210;
        v16 = "nw_endpoint_is_multicast";
        _os_log_impl(&dword_181A37000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      v7 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *buf = 136446210;
        v16 = "nw_endpoint_is_multicast";
        _os_log_impl(&dword_181A37000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

LABEL_20:
  if (v6)
  {
    free(v6);
  }

  is_multicast = 0;
LABEL_3:

  return is_multicast;
}

uint64_t nw_endpoint_create_address_from_string(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v23 = *MEMORY[0x1E69E9840];
  if (!a1)
  {
    v4 = __nwlog_obj();
    *buf = 136446210;
    v20 = "nw_endpoint_create_address_from_string";
    v5 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v5, &type, &v17))
    {
      goto LABEL_49;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v17 == 1)
      {
        backtrace_string = __nw_create_backtrace_string();
        v6 = __nwlog_obj();
        v7 = type;
        v12 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *buf = 136446466;
            v20 = "nw_endpoint_create_address_from_string";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_181A37000, v6, v7, "%{public}s called with null address_string, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
LABEL_49:
          if (!v5)
          {
            return 0;
          }

LABEL_50:
          free(v5);
          return 0;
        }

        if (v12)
        {
          *buf = 136446210;
          v20 = "nw_endpoint_create_address_from_string";
          v8 = "%{public}s called with null address_string, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        v6 = __nwlog_obj();
        v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *buf = 136446210;
          v20 = "nw_endpoint_create_address_from_string";
          v8 = "%{public}s called with null address_string, backtrace limit exceeded";
          goto LABEL_47;
        }
      }

      goto LABEL_48;
    }

    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
    {
      goto LABEL_48;
    }

    *buf = 136446210;
    v20 = "nw_endpoint_create_address_from_string";
    v8 = "%{public}s called with null address_string";
    goto LABEL_47;
  }

  if (!a2)
  {
    v9 = __nwlog_obj();
    *buf = 136446210;
    v20 = "nw_endpoint_create_address_from_string";
    v5 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v5, &type, &v17))
    {
      goto LABEL_49;
    }

    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v17 != 1)
      {
        v6 = __nwlog_obj();
        v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *buf = 136446210;
          v20 = "nw_endpoint_create_address_from_string";
          v8 = "%{public}s called with null port, backtrace limit exceeded";
          goto LABEL_47;
        }

        goto LABEL_48;
      }

      v13 = __nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v14 = os_log_type_enabled(v6, type);
      if (!v13)
      {
        if (v14)
        {
          *buf = 136446210;
          v20 = "nw_endpoint_create_address_from_string";
          v8 = "%{public}s called with null port, no backtrace";
          goto LABEL_47;
        }

        goto LABEL_48;
      }

      if (v14)
      {
        *buf = 136446466;
        v20 = "nw_endpoint_create_address_from_string";
        v21 = 2082;
        v22 = v13;
        v15 = "%{public}s called with null port, dumping backtrace:%{public}s";
LABEL_32:
        _os_log_impl(&dword_181A37000, v6, v7, v15, buf, 0x16u);
      }

LABEL_33:

      free(v13);
      if (!v5)
      {
        return 0;
      }

      goto LABEL_50;
    }

    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
    {
      goto LABEL_48;
    }

    *buf = 136446210;
    v20 = "nw_endpoint_create_address_from_string";
    v8 = "%{public}s called with null port";
LABEL_47:
    _os_log_impl(&dword_181A37000, v6, v7, v8, buf, 0xCu);
    goto LABEL_48;
  }

  if (!a3)
  {
    v10 = __nwlog_obj();
    *buf = 136446210;
    v20 = "nw_endpoint_create_address_from_string";
    v5 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v5, &type, &v17))
    {
      goto LABEL_49;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v20 = "nw_endpoint_create_address_from_string";
        v8 = "%{public}s called with null out_prefix";
        goto LABEL_47;
      }

LABEL_48:

      goto LABEL_49;
    }

    if (v17 != 1)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *buf = 136446210;
        v20 = "nw_endpoint_create_address_from_string";
        v8 = "%{public}s called with null out_prefix, backtrace limit exceeded";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    v13 = __nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v16 = os_log_type_enabled(v6, type);
    if (!v13)
    {
      if (v16)
      {
        *buf = 136446210;
        v20 = "nw_endpoint_create_address_from_string";
        v8 = "%{public}s called with null out_prefix, no backtrace";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    if (v16)
    {
      *buf = 136446466;
      v20 = "nw_endpoint_create_address_from_string";
      v21 = 2082;
      v22 = v13;
      v15 = "%{public}s called with null out_prefix, dumping backtrace:%{public}s";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  return _nw_endpoint_create_address_from_string();
}

void sub_18296E468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __HTTPNotificationCenter_block_invoke()
{
  v0 = objc_alloc_init(MEMORY[0x1E696AD88]);
  v1 = HTTPNotificationCenter_center;
  HTTPNotificationCenter_center = v0;
}

void sub_182970820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__75382(uint64_t result, uint64_t a2)
{
  *(result + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  return result;
}

id fixInvalidURLRequest(void *a1)
{
  v36 = *MEMORY[0x1E69E9840];
  v1 = a1;
  v2 = [v1 URL];
  v3 = [v2 absoluteURL];

  rangeIncludingSeparators.location = 0;
  rangeIncludingSeparators.length = 0;
  v4 = CFURLGetByteRangeForComponent(v3, kCFURLComponentScheme, &rangeIncludingSeparators);
  if (v4.location != -1 && v4.length + 3 != rangeIncludingSeparators.length)
  {
    if (__nwlog_url_log::onceToken != -1)
    {
      dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_72);
    }

    v6 = gurlLogObj;
    *buf = 136446466;
    v31 = "fixInvalidURLRequest";
    v32 = 2112;
    v33 = v2;
    LODWORD(v26) = 22;
    v7 = _os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v7, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_url_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_72);
        }

        v8 = gurlLogObj;
        v9 = type;
        if (!os_log_type_enabled(v8, type))
        {
          goto LABEL_25;
        }

        *buf = 136446466;
        v31 = "fixInvalidURLRequest";
        v32 = 2112;
        v33 = v2;
        v10 = "%{public}s Invalid URL (missing slash): %@";
        goto LABEL_23;
      }

      if (v27 != 1)
      {
        if (__nwlog_url_log::onceToken != -1)
        {
          dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_72);
        }

        v8 = gurlLogObj;
        v9 = type;
        if (!os_log_type_enabled(v8, type))
        {
          goto LABEL_25;
        }

        *buf = 136446466;
        v31 = "fixInvalidURLRequest";
        v32 = 2112;
        v33 = v2;
        v10 = "%{public}s Invalid URL (missing slash): %@, backtrace limit exceeded";
LABEL_23:
        v14 = v8;
        v15 = v9;
        goto LABEL_24;
      }

      backtrace_string = __nw_create_backtrace_string();
      if (__nwlog_url_log::onceToken != -1)
      {
        dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_72);
      }

      v8 = gurlLogObj;
      v12 = type;
      v13 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
          goto LABEL_25;
        }

        *buf = 136446466;
        v31 = "fixInvalidURLRequest";
        v32 = 2112;
        v33 = v2;
        v10 = "%{public}s Invalid URL (missing slash): %@, no backtrace";
        v14 = v8;
        v15 = v12;
LABEL_24:
        _os_log_impl(&dword_181A37000, v14, v15, v10, buf, 0x16u);
LABEL_25:

        goto LABEL_26;
      }

      if (v13)
      {
        *buf = 136446722;
        v31 = "fixInvalidURLRequest";
        v32 = 2112;
        v33 = v2;
        v34 = 2082;
        v35 = backtrace_string;
        _os_log_impl(&dword_181A37000, v8, v12, "%{public}s Invalid URL (missing slash): %@, dumping backtrace:%{public}s", buf, 0x20u);
      }

      free(backtrace_string);
    }

LABEL_26:
    if (v7)
    {
      free(v7);
    }

    v16 = CFURLGetBytes(v3, 0, 0);
    if (v16 == -3)
    {
      v24 = __nwlog_obj();
      os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
      *buf = 136446210;
      v31 = "fixInvalidURLRequest";
      LODWORD(v26) = 12;
      v25 = _os_log_send_and_compose_impl();

      result = __nwlog_should_abort(v25);
      if (result)
      {
        goto LABEL_43;
      }

      free(v25);
    }

    v17 = malloc_type_calloc(v16 + 3, 1uLL, 0xB8A8EEF5uLL);
    if (v17)
    {
LABEL_32:
      CFURLGetBytes(v3, v17, v16);
      v21 = &v17[rangeIncludingSeparators.length + rangeIncludingSeparators.location];
      if (*v21 == 47)
      {
        v22 = 1;
      }

      else
      {
        v22 = 2;
      }

      memmove(&v21[v22], &v17[rangeIncludingSeparators.length + rangeIncludingSeparators.location], v16 - (rangeIncludingSeparators.length + rangeIncludingSeparators.location) + 1);
      memset(v21, 47, v22);
      v23 = CFURLCreateAbsoluteURLWithBytes(*MEMORY[0x1E695E480], v17, v22 + v16, 0x600u, 0, 0);
      free(v17);
      v5 = [v1 mutableCopy];
      [v5 setURL:v23];

      goto LABEL_36;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = gLogObj;
    os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    *buf = 136446722;
    v31 = "fixInvalidURLRequest";
    v32 = 2048;
    v33 = (v16 + 3);
    v34 = 2048;
    v35 = 1;
    LODWORD(v26) = 32;
    v19 = _os_log_send_and_compose_impl();

    result = __nwlog_should_abort(v19);
    if (!result)
    {
      free(v19);
      goto LABEL_32;
    }

LABEL_43:
    __break(1u);
    return result;
  }

  v5 = v1;
LABEL_36:

  return v5;
}