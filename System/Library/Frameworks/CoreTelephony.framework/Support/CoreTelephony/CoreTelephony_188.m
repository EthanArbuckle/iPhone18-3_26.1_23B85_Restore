void sub_1015EA624(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015EA660(void **a1, uint64_t a2, uint64_t a3)
{
  v6 = (*(*a1[15] + 16))(a1[15], *(a2 + 16));
  v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000BA468(&v16, a2);
    printUuid();
    v8 = v18;
    v9 = *v17;
    v10 = CSIBOOLAsString(*(a2 + 340));
    v11 = *(a2 + 340);
    v12 = v17;
    if (v8 < 0)
    {
      v12 = v9;
    }

    *buf = 136315650;
    *&buf[4] = v12;
    *&buf[12] = 2080;
    *&buf[14] = v10;
    v20 = 1024;
    v21 = v11;
    _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Ending this call: %s is a merged call: %s is call of multi-party: %d.", buf, 0x1Cu);
    if (v18 < 0)
    {
      operator delete(*v17);
    }

    sub_1000475BC(&v16);
  }

  *buf = 0;
  *&buf[8] = 0;
  ((*a1)[7])(buf, a1, *(a2 + 16));
  v13 = *buf;
  if (*buf)
  {
    sub_100E03FE8(v15, a2);
    (*(*v13 + 280))(v13, v15, a3);
    sub_1000BFE80(v15);
  }

  else
  {
    v14 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *v17 = 0;
      _os_log_error_impl(&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "IMS Call model not found!", v17, 2u);
    }
  }

  if (*&buf[8])
  {
    sub_100004A34(*&buf[8]);
  }
}

void sub_1015EA88C(_Unwind_Exception *a1)
{
  if (*(v1 - 121) < 0)
  {
    operator delete(*(v1 - 144));
  }

  sub_1000475BC((v1 - 152));
  _Unwind_Resume(a1);
}

uint64_t sub_1015EA8E4(uint64_t a1, uint64_t a2)
{
  *(a1 + 40) = 0;
  *(a1 + 48) = 0;
  v2 = a1 + 40;
  *(v2 + 16) = 0;
  return sub_1015F2538(v2, *(a2 + 40), *(a2 + 48), 0x6FB586FB586FB587 * ((*(a2 + 48) - *(a2 + 40)) >> 3));
}

void sub_1015EA940(void *a1, uint64_t a2, uint64_t a3)
{
  if ((*(**(a2 + 136) + 416))(*(a2 + 136), a3))
  {

    sub_1015EF604(a1, a2);
  }

  else
  {
    v6 = *(a3 + 16);

    sub_1015ED378(a1, a2, v6);
  }
}

uint64_t sub_1015EA9EC(uint64_t a1)
{
  result = *(a1 + 32);
  if (result)
  {
    return (*(*result + 328))();
  }

  return result;
}

void sub_1015EAA24(uint64_t a1)
{
  v2 = *(a1 + 32);
  v5 = 0;
  v6 = 0;
  (*(*v2 + 56))(&v5);
  v3 = v5;
  if (v5)
  {
    sub_100E03FE8(v4, a1 + 40);
    (*(*v3 + 328))(v3, v4);
    sub_1000BFE80(v4);
  }

  if (v6)
  {
    sub_100004A34(v6);
  }
}

void sub_1015EAAE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000BFE80(va);
  v4 = *(v2 - 40);
  if (v4)
  {
    sub_100004A34(v4);
  }

  _Unwind_Resume(a1);
}

const void **sub_1015EAB14(void *a1, uint64_t a2)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  v9[2] = sub_1015EAC44;
  v9[3] = &unk_101F54F88;
  v9[4] = a1;
  sub_100E03FE8(v10, a2);
  v3 = a1[3];
  if (!v3 || (v4 = a1[2], (v5 = std::__shared_weak_count::lock(v3)) == 0))
  {
    sub_100013CC4();
  }

  v6 = v5;
  v7 = a1[4];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1015F284C;
  block[3] = &unk_101F551C8;
  block[5] = v4;
  v12 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v7, block);
  if (v12)
  {
    sub_100004A34(v12);
  }

  sub_100004A34(v6);
  return sub_1000BFE80(v10);
}

void sub_1015EAC44(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = v2[6];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (a1 + 64);
    if (*(a1 + 87) < 0)
    {
      v4 = *v4;
    }

    CallInfo::toString(&v8, (a1 + 40));
    if (v10 >= 0)
    {
      v5 = &v8;
    }

    else
    {
      v5 = v8;
    }

    *buf = 136315394;
    v12 = v4;
    v13 = 2080;
    v14 = v5;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I IMSCallCommandDriver::answerIncomingCall number: %s %s", buf, 0x16u);
    if (v10 < 0)
    {
      operator delete(v8);
    }
  }

  v8 = 0;
  v9 = 0;
  (*(*v2 + 56))(&v8, v2, *(a1 + 56));
  v6 = v8;
  if (v8)
  {
    sub_100E03FE8(v7, a1 + 40);
    (*(*v6 + 41))(v6, v7);
    sub_1000BFE80(v7);
  }

  if (v9)
  {
    sub_100004A34(v9);
  }
}

void sub_1015EADD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000BFE80(&a9);
  v11 = *(v9 - 96);
  if (v11)
  {
    sub_100004A34(v11);
  }

  _Unwind_Resume(a1);
}

const void **sub_1015EAE20(void *a1, const void **a2)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  v9[2] = sub_1015EAF48;
  v9[3] = &unk_101F54FB8;
  v9[4] = a1;
  sub_1000BA468(&v10, a2);
  v3 = a1[3];
  if (!v3 || (v4 = a1[2], (v5 = std::__shared_weak_count::lock(v3)) == 0))
  {
    sub_100013CC4();
  }

  v6 = v5;
  v7 = a1[4];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1015F284C;
  block[3] = &unk_101F551C8;
  block[5] = v4;
  v12 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v7, block);
  if (v12)
  {
    sub_100004A34(v12);
  }

  sub_100004A34(v6);
  return sub_1000475BC(&v10);
}

const void **sub_1015EAF48(uint64_t a1)
{
  v2 = *(a1 + 32);
  v45 = 0;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  sub_1000BA174(&v18);
  v3 = *(v2 + 136);
  sub_1000BA468(&v17, (a1 + 40));
  LOBYTE(v3) = (*(*v3 + 272))(v3, &v17, &v18);
  sub_1000475BC(&v17);
  if (v3)
  {
    v4 = (*(**(v2 + 120) + 16))(*(v2 + 120), v19);
    v15 = 0;
    __p = 0;
    (*(*v2 + 56))(&__p, v2, v19);
    v5 = __p;
    if (__p)
    {
      if (DWORD1(v19))
      {
        if (DWORD1(v19) != 1)
        {
          v9 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
          {
            *buf = 0;
            _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No Active or Held call found!", buf, 2u);
          }

          goto LABEL_17;
        }

        sub_100E03FE8(v12, &v18);
        (*(*v5 + 352))(v5, v12);
        v6 = v12;
      }

      else
      {
        sub_100E03FE8(v11, &v18);
        (*(*v5 + 344))(v5, v11);
        v6 = v11;
      }

      sub_1000BFE80(v6);
    }

LABEL_17:
    if (v15)
    {
      sub_100004A34(v15);
    }

    return sub_1000BFE80(&v18);
  }

  v7 = *(v2 + 48);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    sub_1000BA468(&v13, (a1 + 40));
    printUuid();
    if (v16 >= 0)
    {
      p_p = &__p;
    }

    else
    {
      p_p = __p;
    }

    *buf = 136315138;
    v47 = p_p;
    _os_log_error_impl(&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No Active Calls to hold..: %s", buf, 0xCu);
    if (v16 < 0)
    {
      operator delete(__p);
    }

    sub_1000475BC(&v13);
  }

  return sub_1000BFE80(&v18);
}

void sub_1015EB244(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000BFE80(va);
  if (STACK[0x388])
  {
    sub_100004A34(STACK[0x388]);
  }

  sub_1000BFE80(&STACK[0x3A0]);
  _Unwind_Resume(a1);
}

const void **sub_1015EB2B8(void *a1, const void **a2)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  v9[2] = sub_1015EB3E0;
  v9[3] = &unk_101F54FE8;
  v9[4] = a1;
  sub_1000BA468(&v10, a2);
  v3 = a1[3];
  if (!v3 || (v4 = a1[2], (v5 = std::__shared_weak_count::lock(v3)) == 0))
  {
    sub_100013CC4();
  }

  v6 = v5;
  v7 = a1[4];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1015F284C;
  block[3] = &unk_101F551C8;
  block[5] = v4;
  v12 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v7, block);
  if (v12)
  {
    sub_100004A34(v12);
  }

  sub_100004A34(v6);
  return sub_1000475BC(&v10);
}

void sub_1015EB3E0(uint64_t a1)
{
  v1 = *(a1 + 32);
  v37 = 0;
  v38 = 0;
  v39 = 0;
  (*(**(v1 + 136) + 264))(&v37);
  if (v38 == v37)
  {
    v3 = *(v1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      LOWORD(cf[0]) = 0;
      _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "No held calls to resume.", cf, 2u);
    }
  }

  else
  {
    v36 = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    v10 = 0u;
    v11 = 0u;
    *cf = 0u;
    sub_100E03FE8(cf, v37);
    v7 = 0;
    v8 = 0;
    (*(*v1 + 56))(&v7, v1, v10);
    v2 = v7;
    if (v7)
    {
      v4 = cf[0];
      if (cf[0])
      {
        CFRetain(cf[0]);
      }

      sub_1001DB8CC(&v4, __p);
      (*(*v2 + 272))(v2, __p);
      if (v6 < 0)
      {
        operator delete(__p[0]);
      }

      sub_1000475BC(&v4);
    }

    if (v8)
    {
      sub_100004A34(v8);
    }

    sub_1000BFE80(cf);
  }

  cf[0] = &v37;
  sub_1000B42B0(cf);
}

void sub_1015EB5B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  sub_1000475BC(&a9);
  if (a17)
  {
    sub_100004A34(a17);
  }

  sub_1000BFE80(&a18);
  a18 = v18 - 40;
  sub_1000B42B0(&a18);
  _Unwind_Resume(a1);
}

const void **sub_1015EB61C(void *a1, uint64_t a2)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  v10[2] = sub_1015EB7A0;
  v10[3] = &unk_101F55018;
  v10[4] = a1;
  sub_100E03FE8(v11, a2);
  if (*(a2 + 463) < 0)
  {
    sub_100005F2C(__p, *(a2 + 440), *(a2 + 448));
  }

  else
  {
    *__p = *(a2 + 440);
    v13 = *(a2 + 456);
  }

  v4 = a1[3];
  if (!v4 || (v5 = a1[2], (v6 = std::__shared_weak_count::lock(v4)) == 0))
  {
    sub_100013CC4();
  }

  v7 = v6;
  v8 = a1[4];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1015F284C;
  block[3] = &unk_101F551C8;
  block[5] = v5;
  v15 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v10;
  dispatch_async(v8, block);
  if (v15)
  {
    sub_100004A34(v15);
  }

  sub_100004A34(v7);
  if (SHIBYTE(v13) < 0)
  {
    operator delete(__p[0]);
  }

  return sub_1000BFE80(v11);
}

void sub_1015EB7A0(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = v2[6];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I IMSCallCommandDriver::mergeCalls", buf, 2u);
  }

  sub_1015EA940(buf, v2, a1 + 40);
  if (*buf)
  {
  }

  else
  {
    v4 = 0;
  }

  if (v10)
  {
    sub_100004A34(v10);
  }

  if (v4)
  {
    (*(*v4 + 320))(v4);
  }

  *buf = 0;
  v10 = 0;
  (*(*v2 + 56))(buf, v2, *(a1 + 56));
  v5 = *buf;
  if (*buf)
  {
    sub_100E03FE8(v6, a1 + 40);
    if (*(a1 + 503) < 0)
    {
      sub_100005F2C(&__p, *(a1 + 480), *(a1 + 488));
    }

    else
    {
      __p = *(a1 + 480);
      v8 = *(a1 + 496);
    }

    (*(*v5 + 496))(v5, v6);
    if (SHIBYTE(v8) < 0)
    {
      operator delete(__p);
    }

    sub_1000BFE80(v6);
  }

  if (v10)
  {
    sub_100004A34(v10);
  }
}

void sub_1015EB980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000BFE80(&a9);
  v11 = *(v9 - 40);
  if (v11)
  {
    sub_100004A34(v11);
  }

  _Unwind_Resume(a1);
}

void *sub_1015EB9B8(uint64_t a1, uint64_t a2)
{
  result = sub_100E03FE8(a1 + 40, a2 + 40);
  if (*(a2 + 503) < 0)
  {
    return sub_100005F2C((a1 + 480), *(a2 + 480), *(a2 + 488));
  }

  v5 = *(a2 + 480);
  *(a1 + 496) = *(a2 + 496);
  *(a1 + 480) = v5;
  return result;
}

const void **sub_1015EBA24(uint64_t a1)
{
  if (*(a1 + 503) < 0)
  {
    operator delete(*(a1 + 480));
  }

  return sub_1000BFE80(a1 + 40);
}

const void **sub_1015EBA78(void *a1, uint64_t a2, int a3)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  v10[2] = sub_1015EBBAC;
  v10[3] = &unk_101F55048;
  v10[4] = a1;
  v11[110] = a3;
  sub_100E03FE8(v11, a2);
  v4 = a1[3];
  if (!v4 || (v5 = a1[2], (v6 = std::__shared_weak_count::lock(v4)) == 0))
  {
    sub_100013CC4();
  }

  v7 = v6;
  v8 = a1[4];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1015F284C;
  block[3] = &unk_101F551C8;
  block[5] = v5;
  v13 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v10;
  dispatch_async(v8, block);
  if (v13)
  {
    sub_100004A34(v13);
  }

  sub_100004A34(v7);
  return sub_1000BFE80(v11);
}

void sub_1015EBBAC(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(a1 + 480) - 2;
  if (v3 > 2)
  {
    v4 = 0;
  }

  else
  {
    v4 = dword_10199BDB8[v3];
  }

  v5 = v2[6];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = (a1 + 64);
    if (*(a1 + 87) < 0)
    {
      v6 = *v6;
    }

    v7 = asString();
    CallInfo::toString(v11, (a1 + 40));
    if (v12 >= 0)
    {
      v8 = v11;
    }

    else
    {
      v8 = v11[0];
    }

    *buf = 136315650;
    *&buf[4] = v6;
    *&buf[12] = 2080;
    *&buf[14] = v7;
    v14 = 2080;
    v15 = v8;
    _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I IMSCallCommandDriver::sendToVoicemail number: %s reason: %s %s", buf, 0x20u);
    if (v12 < 0)
    {
      operator delete(v11[0]);
    }
  }

  *buf = 0;
  *&buf[8] = 0;
  (*(*v2 + 56))(buf, v2, *(a1 + 56));
  v9 = *buf;
  if (*buf)
  {
    sub_100E03FE8(v10, a1 + 40);
    (*(*v9 + 280))(v9, v10, v4);
    sub_1000BFE80(v10);
  }

  if (*&buf[8])
  {
    sub_100004A34(*&buf[8]);
  }
}

void sub_1015EBD80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000BFE80(&a9);
  v11 = *(v9 - 104);
  if (v11)
  {
    sub_100004A34(v11);
  }

  _Unwind_Resume(a1);
}

void sub_1015EBDB8(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_1015EBED0;
  v7[3] = &unk_101F55078;
  v7[4] = a1;
  v2 = a1[3];
  if (!v2 || (v3 = a1[2], (v4 = std::__shared_weak_count::lock(v2)) == 0))
  {
    sub_100013CC4();
  }

  v5 = v4;
  v6 = a1[4];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1015F284C;
  block[3] = &unk_101F551C8;
  block[5] = v3;
  v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9)
  {
    sub_100004A34(v9);
  }

  sub_100004A34(v5);
}

void sub_1015EBED0(uint64_t a1)
{
  v1 = *(a1 + 32);
  v39 = 0;
  v40 = 0;
  v41 = 0;
  (*(**(v1 + 136) + 264))(&v39);
  v2 = v39;
  for (i = v40; v2 != i; v2 += 440)
  {
    v38 = 0;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    v11 = 0u;
    sub_100E03FE8(&v11, v2);
    v4 = *(v1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = SHIBYTE(v13);
      v6 = *(&v12 + 1);
      CallInfo::toString(__p, &v11);
      if (v5 >= 0)
      {
        v7 = &v12 + 8;
      }

      else
      {
        v7 = v6;
      }

      v8 = __p;
      if (v10 < 0)
      {
        v8 = __p[0];
      }

      *buf = 136315394;
      v43 = v7;
      v44 = 2080;
      v45 = v8;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Ending held call with number: %s %s", buf, 0x16u);
      if (v10 < 0)
      {
        operator delete(__p[0]);
      }
    }

    sub_1015EA660(v1, &v11, 0);
    sub_1000BFE80(&v11);
  }

  *&v11 = &v39;
  sub_1000B42B0(&v11);
}

const void **sub_1015EC108(void *a1, uint64_t a2)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  v9[2] = sub_1015EC238;
  v9[3] = &unk_101F55098;
  v9[4] = a1;
  sub_100E03FE8(v10, a2);
  v3 = a1[3];
  if (!v3 || (v4 = a1[2], (v5 = std::__shared_weak_count::lock(v3)) == 0))
  {
    sub_100013CC4();
  }

  v6 = v5;
  v7 = a1[4];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1015F284C;
  block[3] = &unk_101F551C8;
  block[5] = v4;
  v12 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v7, block);
  if (v12)
  {
    sub_100004A34(v12);
  }

  sub_100004A34(v6);
  return sub_1000BFE80(v10);
}

void sub_1015EC238(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(v2 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (a1 + 64);
    if (*(a1 + 87) < 0)
    {
      v4 = *v4;
    }

    CallInfo::toString(__p, (a1 + 40));
    if (SHIBYTE(__p[2]) >= 0)
    {
      v5 = __p;
    }

    else
    {
      v5 = __p[0];
    }

    *buf = 136315394;
    *&buf[4] = v4;
    *&buf[12] = 2080;
    *&buf[14] = v5;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Ending call with number: %s %s", buf, 0x16u);
    if (SHIBYTE(__p[2]) < 0)
    {
      operator delete(__p[0]);
    }
  }

  if (*(v2 + 634) == 1)
  {
    v6 = *(v2 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Removing call pended for sim control results!", __p, 2u);
    }

    *(v2 + 634) = 0;
    v35 = 0;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    memset(v28, 0, sizeof(v28));
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    memset(v23, 0, sizeof(v23));
    v20 = 0u;
    v21 = 0u;
    v19 = 0u;
    memset(__p, 0, sizeof(__p));
    sub_100E03FE8(__p, a1 + 40);
    DWORD1(v30) = 0;
    BYTE8(v30) = 1;
    (*(**(v2 + 136) + 72))(*(v2 + 136), __p, 1, 1);
LABEL_13:
    sub_1000BFE80(__p);
    return;
  }

  if (*(v2 + 184) == 1)
  {
    sub_1000BA468(&v17, (a1 + 40));
    sub_1001DB8CC(&v17, __p);
    sub_1000BA468(&v16, (v2 + 192));
    sub_1001DB8CC(&v16, buf);
    if (SHIBYTE(__p[2]) >= 0)
    {
      v7 = HIBYTE(__p[2]);
    }

    else
    {
      v7 = __p[1];
    }

    v8 = v37;
    v9 = v37;
    if ((v37 & 0x80u) != 0)
    {
      v8 = *&buf[8];
    }

    if (v7 == v8)
    {
      if (SHIBYTE(__p[2]) >= 0)
      {
        v10 = __p;
      }

      else
      {
        v10 = __p[0];
      }

      if ((v37 & 0x80u) == 0)
      {
        v11 = buf;
      }

      else
      {
        v11 = *buf;
      }

      v12 = memcmp(v10, v11, v7) == 0;
      if ((v9 & 0x80000000) == 0)
      {
LABEL_31:
        sub_1000475BC(&v16);
        if (SHIBYTE(__p[2]) < 0)
        {
          operator delete(__p[0]);
        }

        sub_1000475BC(&v17);
        if (v12)
        {
          v13 = *(v2 + 48);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p[0]) = 0;
            _os_log_impl(&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Removing the pended call with location!", __p, 2u);
          }

          *(v2 + 184) = 0;
          __p[0] = 0;
          v14 = CallInfo::kDefaultCallId;
          LODWORD(__p[1]) = CallInfo::kDefaultCallId;
          *(&__p[1] + 4) = (&_mh_execute_header + 1);
          HIDWORD(__p[2]) = 9;
          sub_10000501C(&__p[3], kCallerIdDefaultValue);
          LODWORD(v20) = 1;
          BYTE4(v20) = 1;
          *(&v20 + 1) = 0x200000004;
          LODWORD(v21) = 0;
          BYTE4(v21) = 0;
          DWORD2(v21) = 0;
          sub_10000501C(&v22, "");
          memset(v23 + 8, 0, 34);
          sub_10000501C(&v24, "");
          BYTE8(v25) = 0;
          HIDWORD(v25) = 0;
          LOBYTE(v26) = 0;
          BYTE8(v26) = 0;
          LOBYTE(v28[0]) = 0;
          memset(v28 + 8, 0, 32);
          *(&v28[2] + 1) = 0u;
          memset(&v28[3] + 4, 0, 64);
          BYTE4(v28[7]) = 1;
          BYTE8(v28[7]) = 0;
          BYTE12(v28[7]) = 0;
          LOWORD(v30) = 0;
          BYTE4(v30) = 0;
          BYTE8(v30) = 0;
          LOBYTE(v31) = 0;
          LOBYTE(v34) = 0;
          BYTE8(v34) = 0;
          BYTE4(v35) = 0;
          *(&v29 + 3) = 0;
          LODWORD(v29) = 0;
          *(&v29 + 11) = 0;
          DWORD2(v29) = 0;
          sub_1015E89D4(v2 + 192, __p);
          sub_1000BFE80(__p);
          *(v2 + 632) = 0;
          *(v2 + 633) = v14;
          v15 = *(v2 + 640);
          *(v2 + 640) = 0;
          if (v15)
          {
            (*(*v15 + 8))(v15);
          }

          v35 = 0;
          v33 = 0u;
          v34 = 0u;
          v31 = 0u;
          v32 = 0u;
          v29 = 0u;
          v30 = 0u;
          memset(v28, 0, sizeof(v28));
          v26 = 0u;
          v27 = 0u;
          v24 = 0u;
          v25 = 0u;
          v22 = 0u;
          memset(v23, 0, sizeof(v23));
          v20 = 0u;
          v21 = 0u;
          v19 = 0u;
          memset(__p, 0, sizeof(__p));
          sub_100E03FE8(__p, a1 + 40);
          DWORD1(v30) = 0;
          BYTE8(v30) = 1;
          (*(**(v2 + 136) + 72))(*(v2 + 136), __p, 1, 1);
          goto LABEL_13;
        }

        goto LABEL_39;
      }
    }

    else
    {
      v12 = 0;
      if ((v37 & 0x80000000) == 0)
      {
        goto LABEL_31;
      }
    }

    operator delete(*buf);
    goto LABEL_31;
  }

LABEL_39:
  sub_1015EA660(v2, a1 + 40, 0);
}

const void **sub_1015EC7CC(void *a1, const void **a2)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  v9[2] = sub_1015EC8F4;
  v9[3] = &unk_101F550C8;
  v9[4] = a1;
  sub_1000BA468(&v10, a2);
  v3 = a1[3];
  if (!v3 || (v4 = a1[2], (v5 = std::__shared_weak_count::lock(v3)) == 0))
  {
    sub_100013CC4();
  }

  v6 = v5;
  v7 = a1[4];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1015F284C;
  block[3] = &unk_101F551C8;
  block[5] = v4;
  v12 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v7, block);
  if (v12)
  {
    sub_100004A34(v12);
  }

  sub_100004A34(v6);
  return sub_1000475BC(&v10);
}

const void **sub_1015EC8F4(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(v2 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Ending the conference call.", buf, 2u);
  }

  v41 = 0;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v20 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  *buf = 0u;
  v15 = 0u;
  sub_1000BA174(buf);
  v4 = *(v2 + 136);
  sub_1000BA468(&v13, (a1 + 40));
  LOBYTE(v4) = (*(*v4 + 272))(v4, &v13, buf);
  sub_1000475BC(&v13);
  if (v4)
  {
    sub_1015EA940(&lpsrc, v2, buf);
    if (lpsrc)
    {
    }

    else
    {
      v5 = 0;
    }

    if (v11)
    {
      sub_100004A34(v11);
    }

    if (v5)
    {
      (*(*v5 + 328))(v5);
    }
  }

  else
  {
    v6 = *(v2 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      sub_1000BA468(&v9, (a1 + 40));
      printUuid();
      if (v12 >= 0)
      {
        p_lpsrc = &lpsrc;
      }

      else
      {
        p_lpsrc = lpsrc;
      }

      *v42 = 136315138;
      v43 = p_lpsrc;
      _os_log_error_impl(&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "No conference call found to end..: %s", v42, 0xCu);
      if (v12 < 0)
      {
        operator delete(lpsrc);
      }

      sub_1000475BC(&v9);
    }
  }

  return sub_1000BFE80(buf);
}

void sub_1015ECB78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1000BFE80(va);
  _Unwind_Resume(a1);
}

void sub_1015ECBBC(uint64_t a1, uint64_t a2)
{
  v3 = *(a1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    v4 = *(a2 + 8);
    v5[0] = 67109120;
    v5[1] = v4;
    _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Unexpected CallCommandDriver::endCallDueToHandover %d", v5, 8u);
  }
}

void sub_1015ECC68(void *a1, int a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_1015ECD84;
  v8[3] = &unk_101F550F8;
  v8[4] = a1;
  v9 = a2;
  v3 = a1[3];
  if (!v3 || (v4 = a1[2], (v5 = std::__shared_weak_count::lock(v3)) == 0))
  {
    sub_100013CC4();
  }

  v6 = v5;
  v7 = a1[4];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1015F284C;
  block[3] = &unk_101F551C8;
  block[5] = v4;
  v11 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v11)
  {
    sub_100004A34(v11);
  }

  sub_100004A34(v6);
}

void sub_1015ECD84(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = (*(**(v2 + 120) + 16))(*(v2 + 120), *(a1 + 40));
  v4 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I IMSCallCommandDriver::endAllCalls", buf, 2u);
  }

  v5 = *(v2 + 656);
  if (v5 != (v2 + 664))
  {
    do
    {
      v6 = v5[7];
      if (v6)
      {
        *buf = 0;
        v24 = 0;
        v25 = 0;
        (*(*v6 + 248))(buf);
        v7 = HIBYTE(v25);
        if (v25 < 0)
        {
          v7 = v24;
        }

        if (v7)
        {
          v8 = (*(*v5[7] + 256))(v5[7]);
          v9 = *(a1 + 40);
          v10 = v9 == 3 || v9 == v8;
          if (v10)
          {
            v26 = 0uLL;
            v27 = 0;
            (*(**(v2 + 136) + 320))(&v26);
            v11 = *(&v26 + 1);
            v12 = v26;
            if (v26 != *(&v26 + 1))
            {
              v13 = 0;
              do
              {
                if (isCallSubTypeIMS())
                {
                  if (*(v12 + 340) == 1)
                  {
                    if ((v13 & 1) == 0)
                    {
                      v14 = *v3;
                      if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
                      {
                        *v21 = 0;
                        _os_log_impl(&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Ending the conference call", v21, 2u);
                      }

                      sub_1015EA940(v21, v2, v12);
                      if (*v21)
                      {
                      }

                      else
                      {
                        v15 = 0;
                      }

                      if (v22)
                      {
                        sub_100004A34(v22);
                      }

                      if (v15)
                      {
                        (*(*v15 + 328))(v15);
                      }
                    }

                    v13 = 1;
                  }

                  else
                  {
                    v16 = v5[7];
                    sub_100E03FE8(v20, v12);
                    (*(*v16 + 280))(v16, v20, 0);
                    sub_1000BFE80(v20);
                  }
                }

                v12 += 440;
              }

              while (v12 != v11);
            }

            *v21 = &v26;
            sub_1000B42B0(v21);
          }
        }

        else
        {
          v17 = *(v2 + 48);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            LODWORD(v26) = 136315138;
            *(&v26 + 4) = "<invalid>";
            _os_log_error_impl(&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid models not cleaned up! :%s", &v26, 0xCu);
          }
        }

        if (SHIBYTE(v25) < 0)
        {
          operator delete(*buf);
        }
      }

      v18 = v5[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = *v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          v19 = v5[2];
          v10 = *v19 == v5;
          v5 = v19;
        }

        while (!v10);
      }

      v5 = v19;
    }

    while (v19 != (v2 + 664));
  }
}

void sub_1015ED178(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (*(v12 - 137) < 0)
  {
    operator delete(*(v12 - 160));
  }

  _Unwind_Resume(exception_object);
}

void sub_1015ED1D8(uint64_t a1, uint64_t a2)
{
  v4 = (*(**(a1 + 120) + 16))(*(a1 + 120));
  lpsrc = 0uLL;
  sub_1015ED378(&lpsrc, a1, a2);
  if (lpsrc)
  {
    if (v5)
    {
      v6 = v5;
      v7 = *v4;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = subscriber::asString();
        *buf = 136315138;
        v11 = v8;
        _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Transferring IMS calls on sim %s", buf, 0xCu);
      }

      (*(*v6 + 384))(v6);
    }
  }

  if (*(&lpsrc + 1))
  {
    sub_100004A34(*(&lpsrc + 1));
  }
}

void sub_1015ED354(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015ED378(_OWORD *a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(**(a2 + 120) + 16))(*(a2 + 120), a3);
  __p[0] = 0;
  __p[1] = 0;
  v18 = 0;
  PersonalityIdFromSlotIdEx();
  v6 = *v5;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 136315138;
    *&buf[4] = "<invalid>";
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Looking up Normal IMS client for %s", buf, 0xCu);
  }

  ServiceMap = Registry::getServiceMap(*(a2 + 56));
  v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    v10 = (v9 & 0x7FFFFFFFFFFFFFFFLL);
    v11 = 5381;
    do
    {
      v9 = v11;
      v12 = *v10++;
      v11 = (33 * v11) ^ v12;
    }

    while (v12);
  }

  std::mutex::lock(ServiceMap);
  v19 = v9;
  v13 = sub_100009510(&v8[1].__m_.__sig, &v19);
  if (v13)
  {
    v15 = v13[3];
    v14 = v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v14);
      v16 = 0;
      goto LABEL_11;
    }
  }

  else
  {
    v15 = 0;
  }

  std::mutex::unlock(v8);
  v14 = 0;
  v16 = 1;
LABEL_11:
  (*(*v15 + 24))(buf, v15, __p);
  *a1 = *buf;
  memset(buf, 0, 16);
  if ((v16 & 1) == 0)
  {
    sub_100004A34(v14);
  }

  if (SHIBYTE(v18) < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_1015ED590(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((v14 & 1) == 0)
  {
    sub_100004A34(v15);
  }

  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015ED5E0(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *v2 = 0;
    _os_log_error_impl(&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "IMSCallCommandDriver::enableVoicePrivacy is not supported", v2, 2u);
  }
}

uint64_t sub_1015ED658(uint64_t a1, CallInfo *this)
{
  CallInfo::getLegacyFlags(this);
  v3 = *(**(a1 + 136) + 200);

  return v3();
}

uint64_t sub_1015ED6C8(uint64_t a1, CallInfo *this)
{
  CallInfo::getLegacyFlags(this);
  v3 = *(**(a1 + 128) + 200);

  return v3();
}

void sub_1015ED790(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  v6 = (*(**(a1 + 120) + 16))(*(a1 + 120), *(a3 + 16));
  v19 = 0;
  v20 = 0;
  (*(*a1 + 56))(&v19, a1, *(a3 + 16));
  v7 = v19;
  if (v19)
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
    sub_100034C50(&v16, *a2, a2[1], a2[1] - *a2);
    sub_1000BA468(&v13, a3);
    sub_1001DB8CC(&v13, __p);
    (*(*v7 + 288))(v7, &v16, __p);
    if (v15 < 0)
    {
      operator delete(__p[0]);
    }

    sub_1000475BC(&v13);
    if (v16)
    {
      v17 = v16;
      operator delete(v16);
    }
  }

  else
  {
    v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "IMSCallCommandDriver::sendDTMFDigits: No IMS model found.", buf, 2u);
    }
  }

  *buf = 0;
  v12 = 0;
  (*(**(a1 + 136) + 304))(buf);
  if (*buf)
  {
    (*(**buf + 56))(*buf, a2, 0);
  }

  else
  {
    v9 = *(a1 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *v10 = 0;
      _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "IMSCallCommandDriver::sendDTMFDigits Did not get a valid CallAudioDriver", v10, 2u);
    }
  }

  if (v12)
  {
    sub_100004A34(v12);
  }

  if (v20)
  {
    sub_100004A34(v20);
  }
}

void sub_1015ED9D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22)
{
  if (a12)
  {
    sub_100004A34(a12);
  }

  v24 = *(v22 - 56);
  if (v24)
  {
    sub_100004A34(v24);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015EDA48(uint64_t a1, uint64_t a2, char a3)
{
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    v6 = *(a2 + 16);
  }

  v7 = a3;
  sub_1000F537C(a1 + 80, __p);
  if (SHIBYTE(v6) < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_1015EDAC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015EDAE4(void **a1, uint64_t a2, uint64_t a3)
{
  v6 = (*(*a1[15] + 16))(a1[15], *(a3 + 16));
  v13 = 0;
  v14 = 0;
  ((*a1)[7])(&v13, a1, *(a3 + 16));
  v7 = v13;
  if (v13)
  {
    sub_1000BA468(&v10, a3);
    sub_1001DB8CC(&v10, __p);
    (*(*v7 + 296))(v7, a2, __p);
    if (v12 < 0)
    {
      operator delete(__p[0]);
    }

    sub_1000475BC(&v10);
  }

  else
  {
    v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *v9 = 0;
      _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "IMSCallCommandDriver::startDTMFTone: No IMS model found!", v9, 2u);
    }
  }

  if (v14)
  {
    sub_100004A34(v14);
  }
}

void sub_1015EDC40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a17 < 0)
  {
    operator delete(__p);
  }

  sub_1000475BC(&a11);
  if (a19)
  {
    sub_100004A34(a19);
  }

  _Unwind_Resume(a1);
}

void sub_1015EDC80(void **a1, uint64_t a2)
{
  v4 = (*(*a1[15] + 16))(a1[15], *(a2 + 16));
  v11 = 0;
  v12 = 0;
  ((*a1)[7])(&v11, a1, *(a2 + 16));
  v5 = v11;
  if (v11)
  {
    sub_1000BA468(&v8, a2);
    sub_1001DB8CC(&v8, __p);
    (*(*v5 + 304))(v5, __p);
    if (v10 < 0)
    {
      operator delete(__p[0]);
    }

    sub_1000475BC(&v8);
  }

  else
  {
    v6 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *v7 = 0;
      _os_log_error_impl(&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "IMSCallCommandDriver::startDTMFTone: No IMS model found!", v7, 2u);
    }
  }

  if (v12)
  {
    sub_100004A34(v12);
  }
}

void sub_1015EDDD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a17 < 0)
  {
    operator delete(__p);
  }

  sub_1000475BC(&a11);
  if (a19)
  {
    sub_100004A34(a19);
  }

  _Unwind_Resume(a1);
}

void sub_1015EDE14(uint64_t a1, uint64_t a2)
{
  v4 = (*(**(a1 + 120) + 16))(*(a1 + 120));
  lpsrc = 0uLL;
  sub_1015ED378(&lpsrc, a1, a2);
  {
    v6 = v5;
    v7 = *v4;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *v9 = 0;
      _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I canceling USSD session...", v9, 2u);
    }

    (*(*v6 + 312))(v6);
  }

  else
  {
    v8 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *v9 = 0;
      _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "client is NULL! Failed to cancel USSD session!", v9, 2u);
    }
  }

  if (*(&lpsrc + 1))
  {
    sub_100004A34(*(&lpsrc + 1));
  }
}

void sub_1015EDF94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    sub_100004A34(a12);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015EDFB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = (*(**(a1 + 120) + 16))(*(a1 + 120), a3);
  lpsrc = 0uLL;
  sub_1015ED378(&lpsrc, a1, a3);
  {
    v8 = v7;
    v9 = *v6;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *v11 = 0;
      _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I sending USSD procedure...", v11, 2u);
    }

    (*(*v8 + 304))(v8, a2);
  }

  else
  {
    v10 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *v11 = 0;
      _os_log_error_impl(&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "client is NULL! Failed to send USSD procedure!", v11, 2u);
    }
  }

  if (*(&lpsrc + 1))
  {
    sub_100004A34(*(&lpsrc + 1));
  }
}

void sub_1015EE140(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    sub_100004A34(a12);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015EE160(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = (*(**(a1 + 120) + 16))(*(a1 + 120), a3);
  lpsrc = 0uLL;
  sub_1015ED378(&lpsrc, a1, a3);
  {
    v8 = v7;
    v9 = *v6;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *v11 = 0;
      _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I sending USSD user reply...", v11, 2u);
    }

    (*(*v8 + 304))(v8, a2);
  }

  else
  {
    v10 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *v11 = 0;
      _os_log_error_impl(&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "client is NULL! Failed to send USSD user reply!", v11, 2u);
    }
  }

  if (*(&lpsrc + 1))
  {
    sub_100004A34(*(&lpsrc + 1));
  }
}

void sub_1015EE2EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    sub_100004A34(a12);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1015EE30C(uint64_t a1, uint64_t a2)
{
  ServiceMap = Registry::getServiceMap(*(a1 + 56));
  v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    v7 = (v6 & 0x7FFFFFFFFFFFFFFFLL);
    v8 = 5381;
    do
    {
      v6 = v8;
      v9 = *v7++;
      v8 = (33 * v8) ^ v9;
    }

    while (v9);
  }

  std::mutex::lock(ServiceMap);
  v18 = v6;
  v10 = sub_100009510(&v5[1].__m_.__sig, &v18);
  if (v10)
  {
    v12 = v10[3];
    v11 = v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v11);
      v13 = 0;
      if (!v12)
      {
        goto LABEL_7;
      }

      goto LABEL_11;
    }
  }

  else
  {
    v12 = 0;
  }

  std::mutex::unlock(v5);
  v11 = 0;
  v13 = 1;
  if (!v12)
  {
LABEL_7:
    v14 = 0;
    if (v13)
    {
      goto LABEL_13;
    }

    goto LABEL_12;
  }

LABEL_11:
  v14 = (*(*v12 + 408))(v12, a2);
  if ((v13 & 1) == 0)
  {
LABEL_12:
    sub_100004A34(v11);
  }

LABEL_13:
  if ((v14 & 1) == 0)
  {
    v15 = *(a1 + 48);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *v17 = 0;
      _os_log_impl(&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I We are CDMA technology; USSD is not supported", v17, 2u);
    }
  }

  return v14;
}

void sub_1015EE480(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0)
  {
    sub_100004A34(v2);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1015EE4A4(uint64_t a1)
{
  PersonalityIdFromSlotIdEx();
  ServiceMap = Registry::getServiceMap(*(a1 + 56));
  v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    v5 = (v4 & 0x7FFFFFFFFFFFFFFFLL);
    v6 = 5381;
    do
    {
      v4 = v6;
      v7 = *v5++;
      v6 = (33 * v6) ^ v7;
    }

    while (v7);
  }

  std::mutex::lock(ServiceMap);
  v21 = v4;
  v8 = sub_100009510(&v3[1].__m_.__sig, &v21);
  if (!v8)
  {
    std::mutex::unlock(v3);
    goto LABEL_9;
  }

  v10 = v8[3];
  v9 = v8[4];
  if (!v9)
  {
    std::mutex::unlock(v3);
    if (v10)
    {
      goto LABEL_11;
    }

LABEL_9:
    LOBYTE(v11) = 0;
    goto LABEL_23;
  }

  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_100004A34(v9);
  if (!v10)
  {
    LOBYTE(v11) = 0;
LABEL_22:
    sub_100004A34(v9);
    goto LABEL_23;
  }

LABEL_11:
  v21 = 0;
  v22 = 0;
  (*(*v10 + 40))(&v21, v10, __p);
  if (v21)
  {
    *cf = 0;
    (*(*v21 + 40))(cf);
    v11 = *cf;
    v23 = 0;
    if (*cf)
    {
      v12 = CFGetTypeID(*cf);
      if (v12 == CFBooleanGetTypeID())
      {
        ctu::cf::assign(&v23, v11, v13);
        LOBYTE(v11) = v23;
      }

      else
      {
        LOBYTE(v11) = 0;
      }
    }

    sub_10000A1EC(cf);
  }

  else
  {
    v14 = *(a1 + 48);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v16 = v20;
      if ((v20 & 0x80u) != 0)
      {
        v16 = __p[1];
      }

      v17 = __p;
      if ((v20 & 0x80u) != 0)
      {
        v17 = __p[0];
      }

      if (v16)
      {
        v18 = v17;
      }

      else
      {
        v18 = "<invalid>";
      }

      *cf = 136315138;
      *&cf[4] = v18;
      _os_log_error_impl(&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "IMS config not found for pid %s", cf, 0xCu);
    }

    LOBYTE(v11) = 0;
  }

  if (v22)
  {
    sub_100004A34(v22);
  }

  if (v9)
  {
    goto LABEL_22;
  }

LABEL_23:
  if (v20 < 0)
  {
    operator delete(__p[0]);
  }

  return v11 & 1;
}

void sub_1015EE734(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, char a18)
{
  if (a16)
  {
    sub_100004A34(a16);
  }

  if (v18)
  {
    sub_100004A34(v18);
  }

  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015EE7A8(uint64_t a1)
{
  CallCommandDriver::dumpState((a1 + 8));
  v2 = *(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10) = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I ----------------DUMP STATE:: IMSCommandDriver----------------", &v10, 2u);
  }

  v3 = *(a1 + 656);
  if (v3 != (a1 + 664))
  {
    do
    {
      v4 = v3[7];
      if (v4)
      {
        (*(*v4 + 504))(v4);
      }

      v5 = v3[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = *v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          v6 = v3[2];
          v7 = *v6 == v3;
          v3 = v6;
        }

        while (!v7);
      }

      v3 = v6;
    }

    while (v6 != (a1 + 664));
  }

  v8 = *(a1 + 48);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v9 = CSIBOOLAsString(*(a1 + 634));
    v10 = 136315138;
    v11 = v9;
    _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Have call pended for sim call control result: %s", &v10, 0xCu);
  }
}

void sub_1015EE91C(uint64_t a1, uint64_t a2)
{
  v5 = 0uLL;
  sub_1015ED378(&v5, a1, a2);
  if (v5)
  {
    *v4 = 16;
    (*(*v5 + 56))(v5, v4);
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *v4 = 0;
      _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Send SRVCC started event succeeded!", v4, 2u);
    }
  }

  if (*(&v5 + 1))
  {
    sub_100004A34(*(&v5 + 1));
  }
}

void sub_1015EE9D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    sub_100004A34(a12);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015EE9F0(void **a1)
{
  v8 = 0;
  v9 = 0;
  v10 = 0;
  (*(*a1[17] + 320))(&v8);
  v2 = v8;
  for (i = v9; v2 != i; v2 += 440)
  {
    v4 = *(v2 + 20);
    v5 = v4 > 8;
    v6 = (1 << v4) & 0x1B3;
    if (!v5 && v6 != 0)
    {
      sub_1015EA660(a1, v2, 3);
    }
  }

  v11 = &v8;
  sub_1000B42B0(&v11);
}

void sub_1015EEABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = &a9;
  sub_1000B42B0(&a12);
  _Unwind_Resume(a1);
}

void sub_1015EEAD8(uint64_t a1, uint64_t a2)
{
  v3 = 0;
  v4 = 0;
  (*(*a1 + 56))(&v3);
  if (v3)
  {
    (*(*v3 + 360))(v3, a2);
  }

  if (v4)
  {
    sub_100004A34(v4);
  }
}

void sub_1015EEB74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015EEB8C(uint64_t a1, CallInfo *this)
{
  v4 = *(this + 16);
  v8 = 0;
  v9 = 0;
  v5 = CallInfo::isEmergencyCallEmergencySetup(this);
  sub_1015E8644(&v8, a1, this, v5);
  if (v8)
  {
    (*(*v8 + 48))();
    (*(*v8 + 56))(v8, (v4 & 0xFFFFFFFE) == 2);
  }

  else
  {
    v6 = *(a1 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *v7 = 0;
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#E applyCallSource: Cannot create an ims call object", v7, 2u);
    }
  }

  if (v9)
  {
    sub_100004A34(v9);
  }
}

void sub_1015EEC98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    sub_100004A34(a12);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1015EECEC(uint64_t a1)
{
  v1 = *(a1 - 8);
  *(a1 + 672) = 1;
  return (*(v1 + 392))();
}

void sub_1015EED20(uint64_t a1)
{
  v2 = *(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Sending audio ready event to IMS clients of current calls", buf, 2u);
  }

  if ((*(a1 + 680) & 1) == 0)
  {
    v17 = *(a1 + 48);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Media session is not activated. Not sending audio ready event.", buf, 2u);
    }

    return;
  }

  *buf = 0u;
  v23 = 0u;
  v24 = 1065353216;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  (*(**(a1 + 136) + 312))(&v19);
  v3 = v19;
  v4 = v20;
  if (v19 == v20)
  {
    goto LABEL_49;
  }

  do
  {
    if ((isCallSubTypeIMS() & 1) == 0)
    {
      goto LABEL_43;
    }

    v5 = (*(**(a1 + 136) + 416))(*(a1 + 136), v3);
    v6 = *(v3 + 16);
    if (v5)
    {
      if (!*&buf[8])
      {
        goto LABEL_28;
      }

      v7 = vcnt_s8(*&buf[8]);
      v7.i16[0] = vaddlv_u8(v7);
      if (v7.u32[0] > 1uLL)
      {
        v8 = *(v3 + 16);
        if (*&buf[8] <= v6)
        {
          v8 = v6 % *&buf[8];
        }
      }

      else
      {
        v8 = (*&buf[8] - 1) & v6;
      }

      v11 = *(*buf + 8 * v8);
      if (!v11 || (v12 = *v11) == 0)
      {
LABEL_28:
        operator new();
      }

      while (1)
      {
        v13 = v12[1];
        if (v13 == v6)
        {
          if (*(v12 + 4) == v6)
          {
            v12[3] = v3;
            goto LABEL_43;
          }
        }

        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v13 >= *&buf[8])
            {
              v13 %= *&buf[8];
            }
          }

          else
          {
            v13 &= *&buf[8] - 1;
          }

          if (v13 != v8)
          {
            goto LABEL_28;
          }
        }

        v12 = *v12;
        if (!v12)
        {
          goto LABEL_28;
        }
      }
    }

    if (!*&buf[8])
    {
      goto LABEL_42;
    }

    v9 = vcnt_s8(*&buf[8]);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v10 = *(v3 + 16);
      if (*&buf[8] <= v6)
      {
        v10 = v6 % *&buf[8];
      }
    }

    else
    {
      v10 = (*&buf[8] - 1) & v6;
    }

    v14 = *(*buf + 8 * v10);
    if (!v14 || (v15 = *v14) == 0)
    {
LABEL_42:
      operator new();
    }

    while (1)
    {
      v16 = v15[1];
      if (v16 == v6)
      {
        break;
      }

      if (v9.u32[0] > 1uLL)
      {
        if (v16 >= *&buf[8])
        {
          v16 %= *&buf[8];
        }
      }

      else
      {
        v16 &= *&buf[8] - 1;
      }

      if (v16 != v10)
      {
        goto LABEL_42;
      }

LABEL_41:
      v15 = *v15;
      if (!v15)
      {
        goto LABEL_42;
      }
    }

    if (*(v15 + 4) != v6)
    {
      goto LABEL_41;
    }

LABEL_43:
    v3 += 440;
  }

  while (v3 != v4);
  for (i = v23; i; i = *i)
  {
    (*(*a1 + 400))(a1, i[3]);
  }

LABEL_49:
  v25 = &v19;
  sub_1000B42B0(&v25);
  sub_10063098C(buf);
}

void sub_1015EF214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10063098C(va);
  _Unwind_Resume(a1);
}

void sub_1015EF260(uint64_t a1, uint64_t a2)
{
  v4 = *(a1 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000BA468(&v14, a2);
    sub_1001DB8CC(&v14, __p);
    if (v16 >= 0)
    {
      v5 = __p;
    }

    else
    {
      v5 = __p[0];
    }

    *buf = 136315138;
    v18 = v5;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sending audio ready event to IMS clients of call %s", buf, 0xCu);
    if (v16 < 0)
    {
      operator delete(__p[0]);
    }

    sub_1000475BC(&v14);
  }

  if (*(a1 + 680))
  {
    v6 = (*(**(a1 + 120) + 16))(*(a1 + 120), *(a2 + 16));
    if ((*(**(a1 + 136) + 416))(*(a1 + 136), a2))
    {
      __p[0] = 0;
      __p[1] = 0;
      sub_1015EF604(__p, a1);
      v7 = __p[0];
      v8 = *(a1 + 48);
      if (__p[0])
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 0;
          _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Sending audio ready event on Emergency IMS client", buf, 2u);
        }

        *buf = 8;
        (*(*v7 + 56))(v7, buf);
      }

      else if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *buf = 0;
        _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Sending audio ready event failed: Emergency IMS client not found", buf, 2u);
      }

      if (__p[1])
      {
        sub_100004A34(__p[1]);
      }
    }

    __p[0] = 0;
    __p[1] = 0;
    sub_1015ED378(__p, a1, *(a2 + 16));
    v10 = __p[0];
    v11 = *v6;
    v12 = *v6;
    if (__p[0])
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        if (v10[48])
        {
          v13 = "Emergency";
        }

        else
        {
          v13 = "normal";
        }

        *buf = 136315138;
        v18 = v13;
        _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Sending audio ready event on %s IMS client", buf, 0xCu);
      }

      *buf = 8;
      (*(*v10 + 56))(v10, buf);
    }

    else if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Sending audio ready event failed: normal IMS client not found", buf, 2u);
    }

    if (__p[1])
    {
      sub_100004A34(__p[1]);
    }
  }

  else
  {
    v9 = *(a1 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Media session is not activated. Not sending audio ready event.", __p, 2u);
    }
  }
}

void sub_1015EF5D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    sub_100004A34(a12);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015EF604(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  ServiceMap = Registry::getServiceMap(*(a2 + 56));
  v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    v7 = (v6 & 0x7FFFFFFFFFFFFFFFLL);
    v8 = 5381;
    do
    {
      v6 = v8;
      v9 = *v7++;
      v8 = (33 * v8) ^ v9;
    }

    while (v9);
  }

  std::mutex::lock(ServiceMap);
  v18 = v6;
  v10 = sub_100009510(&v5[1].__m_.__sig, &v18);
  if (v10)
  {
    v12 = v10[3];
    v11 = v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v11);
      v13 = 0;
      goto LABEL_9;
    }
  }

  else
  {
    v12 = 0;
  }

  std::mutex::unlock(v5);
  v11 = 0;
  v13 = 1;
LABEL_9:
  (*(*v12 + 16))(buf, v12);
  v14 = *buf;
  *a1 = *buf;
  memset(buf, 0, 16);
  if ((v13 & 1) == 0)
  {
    v16 = v14;
    sub_100004A34(v11);
    v14 = v16;
  }

  if (!v14)
  {
    v15 = *(a2 + 48);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "getEmergencyIMSCallClient: emergency client is NULL!!", buf, 2u);
    }
  }
}

void sub_1015EF778(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0)
  {
    sub_100004A34(v2);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015EF7AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10 = 0;
  v11 = 0;
  sub_1015E4B14(&v10, a1, a3);
  v5 = v10;
  if (v10)
  {
    v6 = *(a1 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = (*(*v5 + 376))(v5);
      v8 = CSIBOOLAsString(v7);
      v9 = CSIBOOLAsString(a2);
      *buf = 136315394;
      v13 = v8;
      v14 = 2080;
      v15 = v9;
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Switching IMS Voice registration from %s to %s", buf, 0x16u);
    }

    (*(*v5 + 432))(v5, a2);
  }

  if (v11)
  {
    sub_100004A34(v11);
  }
}

void sub_1015EF90C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015EF928(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10 = 0;
  v11 = 0;
  sub_1015E4B14(&v10, a1, a3);
  v5 = v10;
  if (v10)
  {
    v6 = *(a1 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = (*(*v5 + 384))(v5);
      v8 = CSIBOOLAsString(v7);
      v9 = CSIBOOLAsString(a2);
      *buf = 136315394;
      v13 = v8;
      v14 = 2080;
      v15 = v9;
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I IMSCallCommandDriver switching Wifi Mode from %s to %s", buf, 0x16u);
    }

    (*(*v5 + 408))(v5, a2);
  }

  if (v11)
  {
    sub_100004A34(v11);
  }
}

void sub_1015EFA88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015EFAA4(uint64_t a1, int a2)
{
  if (*(a1 + 856) != a2)
  {
    v4 = *(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = CSIBOOLAsString(a2);
      v6 = CSIBOOLAsString(*(a1 + 856));
      v12 = 136315394;
      v13 = v5;
      v14 = 2080;
      v15 = v6;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Airplane mode changed from %s to %s", &v12, 0x16u);
    }

    v7 = *(a1 + 656);
    if (v7 != (a1 + 664))
    {
      do
      {
        v8 = v7[7];
        if (v8)
        {
          (*(*v8 + 416))(v8, *(a1 + 856));
        }

        v9 = v7[1];
        if (v9)
        {
          do
          {
            v10 = v9;
            v9 = *v9;
          }

          while (v9);
        }

        else
        {
          do
          {
            v10 = v7[2];
            v11 = *v10 == v7;
            v7 = v10;
          }

          while (!v11);
        }

        v7 = v10;
      }

      while (v10 != (a1 + 664));
    }
  }
}

void sub_1015EFBF8(uint64_t a1, uint64_t a2)
{
  if ((operator==() & 1) == 0)
  {
    v4 = *(a1 + 888);
    if (v4 != (a1 + 896))
    {
      v5 = (a2 + 8);
      while (1)
      {
        v6 = *(v4 + 28);
        v17 = v6;
        v7 = *v5;
        if (!*v5)
        {
          goto LABEL_13;
        }

        v8 = a2 + 8;
        do
        {
          if (*(v7 + 28) >= v6)
          {
            v8 = v7;
          }

          v7 = *(v7 + 8 * (*(v7 + 28) < v6));
        }

        while (v7);
        if (v8 == v5 || *(v8 + 28) > v6)
        {
          goto LABEL_13;
        }

        v9 = sub_1000A8C4C(a2, &v17);
        if (*v9 != HIDWORD(v17))
        {
          break;
        }

LABEL_19:
        v14 = v4[1];
        if (v14)
        {
          do
          {
            v15 = v14;
            v14 = *v14;
          }

          while (v14);
        }

        else
        {
          do
          {
            v15 = v4[2];
            v16 = *v15 == v4;
            v4 = v15;
          }

          while (!v16);
        }

        v4 = v15;
        if (v15 == (a1 + 896))
        {
          return;
        }
      }

      v6 = v17;
LABEL_13:
      v10 = (*(**(a1 + 120) + 16))(*(a1 + 120), v6);
      v11 = HIDWORD(v17);
      v12 = *v10;
      if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
      {
        v13 = asString();
        *buf = 136315138;
        *&buf[4] = v13;
        _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Registration status changed to %s", buf, 0xCu);
      }

      *buf = 0uLL;
      (*(*a1 + 56))(buf, a1, v6);
      if (*buf)
      {
        (*(**buf + 424))(*buf, v11);
      }

      if (*&buf[8])
      {
        sub_100004A34(*&buf[8]);
      }

      goto LABEL_19;
    }
  }
}

void sub_1015EFE34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14)
  {
    sub_100004A34(a14);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1015EFE54(uint64_t a1)
{
  v2 = *(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *v4 = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I VoLTE E911EmergencyMode Exited!", v4, 2u);
  }

  return (*(**(a1 + 136) + 328))(*(a1 + 136), 0);
}

void sub_1015EFEFC(void **a1, uint64_t a2)
{
  v4 = *(*(*a1[15] + 16))(a1[15]);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5) = 0;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Reset fBasebandCallId..", &v5, 2u);
  }

  v5 = 0;
  v6 = 0;
  ((*a1)[7])(&v5, a1, a2);
  if (v5)
  {
    (*(*v5 + 480))(v5);
  }

  if (v6)
  {
    sub_100004A34(v6);
  }
}

void sub_1015F0008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015F0028(uint64_t a1)
{
  v1 = 0;
  v2 = 0;
  (*(*a1 + 56))(&v1);
  if (v1)
  {
    (*(*v1 + 400))(v1);
  }

  if (v2)
  {
    sub_100004A34(v2);
  }
}

void sub_1015F00B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015F00E0(uint64_t a1, NSObject **a2)
{
  v4 = *(a1 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Bootstraping IMSCallCommandDriver", buf, 2u);
  }

  v5 = *a2;
  group = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }

  v6.var0.fObj = &group;
  CallCommandDriver::bootstrap((a1 + 8), v6);
  if (group)
  {
    dispatch_group_leave(group);
    if (group)
    {
      dispatch_release(group);
    }
  }

  ServiceMap = Registry::getServiceMap(*(a1 + 56));
  v8 = ServiceMap;
  if (v9 < 0)
  {
    v10 = (v9 & 0x7FFFFFFFFFFFFFFFLL);
    v11 = 5381;
    do
    {
      v9 = v11;
      v12 = *v10++;
      v11 = (33 * v11) ^ v12;
    }

    while (v12);
  }

  std::mutex::lock(ServiceMap);
  *buf = v9;
  v13 = sub_100009510(&v8[1].__m_.__sig, buf);
  if (v13)
  {
    v15 = v13[3];
    v14 = v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v14);
      goto LABEL_16;
    }
  }

  else
  {
    v15 = 0;
  }

  std::mutex::unlock(v8);
  v14 = 0;
LABEL_16:
  v16 = *(a1 + 160);
  *(a1 + 152) = v15;
  *(a1 + 160) = v14;
  if (v16)
  {
    sub_100004A34(v16);
  }

  sub_10000501C(&__p, "/cc/props/ims_client_state");
  operator new();
}

void sub_1015F098C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27)
{
  if (a2)
  {
    sub_100101814(v28 - 96);
    if (a25)
    {
      (*(*a25 + 8))(a25);
    }

    std::__shared_weak_count::__release_weak(v27);
    sub_1007E6358(&a26);
    sub_10070F9E8(&a23);
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1015F0AE4(uint64_t result)
{
  v2 = *(result + 656);
  v3 = (result + 664);
  if (v2 != (result + 664))
  {
    v4 = (result + 840);
    do
    {
      result = PersonalityIDToSimSlot();
      v5 = *v4;
      if (*v4)
      {
        v6 = v4;
        do
        {
          if (*(v5 + 28) >= result)
          {
            v6 = v5;
          }

          v5 = *(v5 + 8 * (*(v5 + 28) < result));
        }

        while (v5);
        if (v6 != v4 && result >= *(v6 + 7))
        {
          v1 = v1 & 0xFFFFFFFF00000000 | *(v6 + 10);
          result = (*(*v2[7] + 440))(v2[7], v6[4], v1);
        }
      }

      v7 = v2[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          v8 = v2[2];
          v9 = *v8 == v2;
          v2 = v8;
        }

        while (!v9);
      }

      v2 = v8;
    }

    while (v8 != v3);
  }

  return result;
}

void sub_1015F0BF0(uint64_t a1, NSObject **a2)
{
  v3 = *a2;
  group = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }

  v4.var0.fObj = &group;
  CallCommandDriver::shutdown((a1 + 8), v4);
  if (group)
  {
    dispatch_group_leave(group);
    if (group)
    {
      dispatch_release(group);
    }
  }

  v5 = (a1 + 688);
  for (i = *(a1 + 696); i != v5; i = *(i + 8))
  {
    sub_1001039A0((i + 16));
  }

  sub_1000FEFCC(v5);
}

void sub_1015F0C80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015F0CAC(uint64_t a1, const void **a2, uint64_t a3)
{
  v47 = 0uLL;
  v48 = 0;
  v6 = sub_1000BA468(&v46, a2);
  sub_1001DB8CC(v6, &v47);
  sub_1000475BC(&v46);
  v45 = 0;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  sub_1000BA174(&v18);
  if (sub_1015E42AC(a1, &v47, &v18))
  {
    v7 = (*(**(a1 + 120) + 16))(*(a1 + 120), v19);
    __p = 0;
    v16 = 0;
    (*(*a1 + 56))(&__p, a1, v19);
    v8 = __p;
    if (__p)
    {
      if (SHIBYTE(v48) < 0)
      {
        sub_100005F2C(v12, v47, *(&v47 + 1));
      }

      else
      {
        *v12 = v47;
        v13 = v48;
      }

      (*(*v8 + 264))(v8, v12, a3);
      if (SHIBYTE(v13) < 0)
      {
        operator delete(v12[0]);
      }
    }

    else
    {
      v11 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
      {
        *buf = 0;
        _os_log_error_impl(&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "IMSCallCommandDriver::setTTYModeForCall: No Model found!", buf, 2u);
      }
    }

    if (v16)
    {
      sub_100004A34(v16);
    }
  }

  else
  {
    v9 = *(a1 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      sub_1000BA468(&v14, a2);
      printUuid();
      if (v17 >= 0)
      {
        p_p = &__p;
      }

      else
      {
        p_p = __p;
      }

      *buf = 136315138;
      v50 = p_p;
      _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No IMS call found with uuid: %s! Cannot upgrade to TTY.", buf, 0xCu);
      if (v17 < 0)
      {
        operator delete(__p);
      }

      sub_1000475BC(&v14);
    }
  }

  sub_1000BFE80(&v18);
  if (SHIBYTE(v48) < 0)
  {
    operator delete(v47);
  }
}

void sub_1015F0F68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, char a20)
{
  if (a18)
  {
    sub_100004A34(a18);
  }

  sub_1000BFE80(&a20);
  if (*(v20 - 81) < 0)
  {
    operator delete(*(v20 - 104));
  }

  _Unwind_Resume(a1);
}

void sub_1015F0FF0(uint64_t a1@<X0>, void *a2@<X8>)
{
  PersonalityIdFromSlotIdEx();
  sub_1015E4B14(a2, a1, &__p);
  if (v5 < 0)
  {
    operator delete(__p);
  }
}

void sub_1015F1048(void *a1, uint64_t *a2)
{
  v3 = *a2;
  if (*a2)
  {
    if (*(v3 + 49) >= 2u)
    {
      v6 = a1[6];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Ignoring the personality as it has a type other than kSim and KCloud!", &buf, 2u);
      }
    }

    else
    {
      __p[0] = 0;
      __p[1] = 0;
      v20 = 0;
      if (*(v3 + 47) < 0)
      {
        sub_100005F2C(__p, *(v3 + 24), *(v3 + 32));
        v3 = *a2;
      }

      else
      {
        *__p = *(v3 + 24);
        v20 = *(v3 + 40);
      }

      v7 = *(v3 + 52);
      v17 = 0;
      v18 = 0;
      sub_1015E4B14(&v17, a1, __p);
      v8 = v17;
      v9 = a1[6];
      v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
      if (!v8)
      {
        if (v10)
        {
          v14 = HIBYTE(v20);
          if (v20 < 0)
          {
            v14 = __p[1];
          }

          v15 = __p;
          if (v20 < 0)
          {
            v15 = __p[0];
          }

          if (v14)
          {
            v16 = v15;
          }

          else
          {
            v16 = "<invalid>";
          }

          buf = 136315138;
          *buf_4 = v16;
          _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Creating a new IMS call model for %s", &buf, 0xCu);
        }

        operator new();
      }

      if (v10)
      {
        v11 = HIBYTE(v20);
        if (v20 < 0)
        {
          v11 = __p[1];
        }

        v12 = __p;
        if (v20 < 0)
        {
          v12 = __p[0];
        }

        if (v11)
        {
          v13 = v12;
        }

        else
        {
          v13 = "<invalid>";
        }

        buf = 136315138;
        *buf_4 = v13;
        _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Updating personality info for %s", &buf, 0xCu);
      }

      (*(*v8 + 512))(v8, a2);
      sub_1015E4654(a1, __p);
      (*(*a1 + 488))(a1, v7);
      if (v18)
      {
        sub_100004A34(v18);
      }

      if (SHIBYTE(v20) < 0)
      {
        operator delete(__p[0]);
      }
    }
  }

  else
  {
    v5 = a1[6];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "IMSCallCommandDriver::handlePersonalityAdded: Invalid PersonalityInfo!", &buf, 2u);
    }
  }
}

void sub_1015F1880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, void *a26, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
  sub_1000D57A8(&a26);
  if (a16)
  {
    sub_100004A34(a16);
  }

  sub_100004A34(v32);
  sub_100004A34(v31);
  if (a18)
  {
    sub_100004A34(a18);
  }

  if (a24 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1015F1944(uint64_t a1, uint64_t a2)
{
  v22 = 0;
  v23 = 0;
  sub_1015E4B14(&v22, a1, a2);
  if (v22)
  {
    v4 = *(a1 + 664);
    if (v4)
    {
      v5 = a1 + 664;
      do
      {
        v6 = sub_1000068BC((v4 + 32), a2);
        if ((v6 & 0x80u) == 0)
        {
          v5 = v4;
        }

        v4 = *(v4 + ((v6 >> 4) & 8));
      }

      while (v4);
      if (v5 != a1 + 664 && (sub_1000068BC(a2, (v5 + 32)) & 0x80) == 0)
      {
        v7 = *(v5 + 8);
        if (v7)
        {
          do
          {
            v8 = v7;
            v7 = *v7;
          }

          while (v7);
        }

        else
        {
          v14 = v5;
          do
          {
            v8 = v14[2];
            v15 = *v8 == v14;
            v14 = v8;
          }

          while (!v15);
        }

        if (*(a1 + 656) == v5)
        {
          *(a1 + 656) = v8;
        }

        --*(a1 + 672);
        sub_100018288(*(a1 + 664), v5);
        sub_1000D57F4(v5 + 32);
        operator delete(v5);
      }
    }

    v16 = *(a1 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = *(a2 + 23);
      v18 = (v17 & 0x80u) != 0;
      if ((v17 & 0x80u) != 0)
      {
        v17 = *(a2 + 8);
      }

      if (v18)
      {
        v19 = *a2;
      }

      else
      {
        v19 = a2;
      }

      if (v17)
      {
        v20 = v19;
      }

      else
      {
        v20 = "<invalid>";
      }

      v21 = *(a1 + 672);
      *buf = 136315394;
      v25 = v20;
      v26 = 2048;
      v27 = v21;
      _os_log_impl(&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Removed IMS call model for personality ID: %s Current model count: %lu.", buf, 0x16u);
    }
  }

  else
  {
    v9 = *(a1 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = *(a2 + 23);
      v11 = (v10 & 0x80u) != 0;
      if ((v10 & 0x80u) != 0)
      {
        v10 = *(a2 + 8);
      }

      if (v11)
      {
        v12 = *a2;
      }

      else
      {
        v12 = a2;
      }

      if (v10)
      {
        v13 = v12;
      }

      else
      {
        v13 = "<invalid>";
      }

      *buf = 136315138;
      v25 = v13;
      _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "IIMSCallCommandDriver::handlePersonalityGone: No Model found for PID: %s", buf, 0xCu);
    }
  }

  if (v23)
  {
    sub_100004A34(v23);
  }
}

void sub_1015F1B88(uint64_t a1@<X0>, void *a2@<X8>)
{
  v3 = 0;
  v4 = 0;
  (*(*a1 + 56))(&v3);
  if (v3)
  {
    (*(*v3 + 368))(v3);
  }

  else
  {
    a2[2] = 0;
    a2[1] = 0;
    *a2 = a2 + 1;
  }

  if (v4)
  {
    sub_100004A34(v4);
  }
}

void sub_1015F1C34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015F1C54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = 0;
  v6 = 0;
  (*(*a1 + 56))(&v5);
  if (v5)
  {
    (*(*v5 + 528))(v5, a2, a3);
  }

  if (v6)
  {
    sub_100004A34(v6);
  }
}

void sub_1015F1CF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1015F1D18(uint64_t a1, uint64_t a2)
{
  v5 = 0;
  v6 = 0;
  (*(*a1 + 56))(&v5);
  if (v5)
  {
    v3 = (*(*v5 + 520))(v5, a2);
  }

  else
  {
    v3 = 0;
  }

  if (v6)
  {
    sub_100004A34(v6);
  }

  return v3;
}

void sub_1015F1DC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1015F1E74(uint64_t a1)
{
  v3 = (a1 + 272);
  sub_1000087B4(&v3);
  if (*(a1 + 271) < 0)
  {
    operator delete(*(a1 + 248));
  }

  if (*(a1 + 247) < 0)
  {
    operator delete(*(a1 + 224));
  }

  if (*(a1 + 191) < 0)
  {
    operator delete(*(a1 + 168));
  }

  if (*(a1 + 167) < 0)
  {
    operator delete(*(a1 + 144));
  }

  if (*(a1 + 119) < 0)
  {
    operator delete(*(a1 + 96));
  }

  if (*(a1 + 95) < 0)
  {
    operator delete(*(a1 + 72));
  }

  if (*(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  if (*(a1 + 23) < 0)
  {
    operator delete(*a1);
  }

  return a1;
}

uint64_t sub_1015F1F30(uint64_t a1)
{
  if (*(a1 + 191) < 0)
  {
    operator delete(*(a1 + 168));
  }

  if (*(a1 + 167) < 0)
  {
    operator delete(*(a1 + 144));
  }

  if (*(a1 + 119) < 0)
  {
    operator delete(*(a1 + 96));
  }

  if (*(a1 + 95) < 0)
  {
    operator delete(*(a1 + 72));
  }

  if (*(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  if (*(a1 + 23) < 0)
  {
    operator delete(*a1);
  }

  return a1;
}

void sub_1015F1FB4(uint64_t a1)
{
  v2 = *a1;
  if (v2)
  {
    CFRelease(v2);
  }

  v3 = *(a1 + 8);
  if (v3)
  {

    CFRelease(v3);
  }
}

uint64_t sub_1015F2004(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  if (*(a2 + 31) < 0)
  {
    sub_100005F2C((a1 + 8), *(a2 + 8), *(a2 + 16));
  }

  else
  {
    v4 = *(a2 + 8);
    *(a1 + 24) = *(a2 + 24);
    *(a1 + 8) = v4;
  }

  *(a1 + 32) = *(a2 + 32);
  if (*(a2 + 63) < 0)
  {
    sub_100005F2C((a1 + 40), *(a2 + 40), *(a2 + 48));
  }

  else
  {
    v5 = *(a2 + 40);
    *(a1 + 56) = *(a2 + 56);
    *(a1 + 40) = v5;
  }

  v6 = *(a2 + 64);
  v7 = *(a2 + 96);
  *(a1 + 80) = *(a2 + 80);
  *(a1 + 96) = v7;
  *(a1 + 64) = v6;
  if (*(a2 + 135) < 0)
  {
    sub_100005F2C((a1 + 112), *(a2 + 112), *(a2 + 120));
  }

  else
  {
    v8 = *(a2 + 112);
    *(a1 + 128) = *(a2 + 128);
    *(a1 + 112) = v8;
  }

  if (*(a2 + 159) < 0)
  {
    sub_100005F2C((a1 + 136), *(a2 + 136), *(a2 + 144));
  }

  else
  {
    v9 = *(a2 + 136);
    *(a1 + 152) = *(a2 + 152);
    *(a1 + 136) = v9;
  }

  if (*(a2 + 183) < 0)
  {
    sub_100005F2C((a1 + 160), *(a2 + 160), *(a2 + 168));
  }

  else
  {
    v10 = *(a2 + 160);
    *(a1 + 176) = *(a2 + 176);
    *(a1 + 160) = v10;
  }

  if (*(a2 + 207) < 0)
  {
    sub_100005F2C((a1 + 184), *(a2 + 184), *(a2 + 192));
  }

  else
  {
    v11 = *(a2 + 184);
    *(a1 + 200) = *(a2 + 200);
    *(a1 + 184) = v11;
  }

  *(a1 + 208) = *(a2 + 208);
  if (*(a2 + 239) < 0)
  {
    sub_100005F2C((a1 + 216), *(a2 + 216), *(a2 + 224));
  }

  else
  {
    v12 = *(a2 + 216);
    *(a1 + 232) = *(a2 + 232);
    *(a1 + 216) = v12;
  }

  sub_10006F264(a1 + 240, (a2 + 240));
  *(a1 + 272) = *(a2 + 272);
  return a1;
}

void sub_1015F218C(_Unwind_Exception *a1)
{
  sub_1015F2230(v1 + 64);
  if (*(v1 + 63) < 0)
  {
    operator delete(*(v1 + 40));
  }

  if (*(v1 + 31) < 0)
  {
    operator delete(*v2);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1015F2230(uint64_t a1)
{
  if (*(a1 + 143) < 0)
  {
    operator delete(*(a1 + 120));
  }

  if (*(a1 + 119) < 0)
  {
    operator delete(*(a1 + 96));
  }

  if (*(a1 + 95) < 0)
  {
    operator delete(*(a1 + 72));
  }

  if (*(a1 + 71) < 0)
  {
    operator delete(*(a1 + 48));
  }

  return a1;
}

uint64_t sub_1015F2294(uint64_t a1)
{
  if (*(a1 + 583) < 0)
  {
    operator delete(*(a1 + 560));
  }

  if (*(a1 + 559) < 0)
  {
    operator delete(*(a1 + 536));
  }

  if (*(a1 + 527) < 0)
  {
    operator delete(*(a1 + 504));
  }

  v3 = (a1 + 480);
  sub_1000087B4(&v3);
  v3 = (a1 + 456);
  sub_1000087B4(&v3);
  if (*(a1 + 455) < 0)
  {
    operator delete(*(a1 + 432));
  }

  if (*(a1 + 431) < 0)
  {
    operator delete(*(a1 + 408));
  }

  if (*(a1 + 407) < 0)
  {
    operator delete(*(a1 + 384));
  }

  if (*(a1 + 383) < 0)
  {
    operator delete(*(a1 + 360));
  }

  if (*(a1 + 359) < 0)
  {
    operator delete(*(a1 + 336));
  }

  if (*(a1 + 335) < 0)
  {
    operator delete(*(a1 + 312));
  }

  v3 = (a1 + 272);
  sub_1000087B4(&v3);
  if (*(a1 + 271) < 0)
  {
    operator delete(*(a1 + 248));
  }

  if (*(a1 + 247) < 0)
  {
    operator delete(*(a1 + 224));
  }

  if (*(a1 + 191) < 0)
  {
    operator delete(*(a1 + 168));
  }

  if (*(a1 + 167) < 0)
  {
    operator delete(*(a1 + 144));
  }

  if (*(a1 + 119) < 0)
  {
    operator delete(*(a1 + 96));
  }

  if (*(a1 + 95) < 0)
  {
    operator delete(*(a1 + 72));
  }

  if (*(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  if (*(a1 + 23) < 0)
  {
    operator delete(*a1);
  }

  return a1;
}

uint64_t sub_1015F2400(uint64_t a1)
{
  v2 = *a1;
  if (v2)
  {
    CFRelease(v2);
  }

  if (*(a1 + 711) < 0)
  {
    operator delete(*(a1 + 688));
  }

  if (*(a1 + 687) < 0)
  {
    operator delete(*(a1 + 664));
  }

  if (*(a1 + 663) < 0)
  {
    operator delete(*(a1 + 640));
  }

  if (*(a1 + 639) < 0)
  {
    operator delete(*(a1 + 616));
  }

  sub_1015F2294(a1 + 24);
  sub_1015F1FB4(a1 + 8);
  return a1;
}

uint64_t sub_1015F2488(uint64_t a1)
{
  if (*(a1 + 264) == 1 && *(a1 + 263) < 0)
  {
    operator delete(*(a1 + 240));
  }

  if (*(a1 + 239) < 0)
  {
    operator delete(*(a1 + 216));
  }

  if (*(a1 + 207) < 0)
  {
    operator delete(*(a1 + 184));
  }

  if (*(a1 + 183) < 0)
  {
    operator delete(*(a1 + 160));
  }

  if (*(a1 + 159) < 0)
  {
    operator delete(*(a1 + 136));
  }

  if (*(a1 + 135) < 0)
  {
    operator delete(*(a1 + 112));
  }

  if (*(a1 + 63) < 0)
  {
    operator delete(*(a1 + 40));
  }

  if (*(a1 + 31) < 0)
  {
    operator delete(*(a1 + 8));
  }

  return a1;
}

uint64_t sub_1015F2538(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 < 0x94F2094F2094F3)
    {
      sub_1000FA76C(result, a4);
    }

    sub_1000CE3D4();
  }

  return result;
}

uint64_t sub_1015F2630(uint64_t a1)
{
  v3 = (a1 + 96);
  sub_1000087B4(&v3);
  v3 = (a1 + 72);
  sub_1000087B4(&v3);
  if (*(a1 + 71) < 0)
  {
    operator delete(*(a1 + 48));
  }

  v3 = (a1 + 24);
  sub_1000087B4(&v3);
  if (*(a1 + 23) < 0)
  {
    operator delete(*a1);
  }

  return a1;
}

void sub_1015F26D0(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  v6 = *(*(**(a1 + 120) + 16))(*(a1 + 120));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v11 = 136315138;
    v12 = asString();
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Received Carrier Bundle setup event. bundleChangeType: %s", &v11, 0xCu);
  }

  v7 = *a3;
  if (v7)
  {
    v8 = v7 == 5;
  }

  else
  {
    v8 = 1;
  }

  if (v8 || v7 == 255)
  {
    v9 = *(a1 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = asString();
      v11 = 136315138;
      v12 = v10;
      _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Ignoring %s", &v11, 0xCu);
    }
  }

  else
  {
    (*(*a1 + 488))(a1, a2);
  }
}

uint64_t sub_1015F285C(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 48);
  *(result + 40) = *(a2 + 40);
  *(result + 48) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_1015F2878(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (v1)
  {
    sub_100004A34(v1);
  }
}

void *sub_1015F2888(void *a1)
{
  *a1 = off_101F55208;
  v2 = a1[58];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  sub_1000BFE80((a1 + 2));
  return a1;
}

void sub_1015F28DC(void *a1)
{
  *a1 = off_101F55208;
  v2 = a1[58];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  sub_1000BFE80((a1 + 2));

  operator delete();
}

uint64_t sub_1015F29E4(void *a1, void *a2)
{
  v4 = a1[1];
  *a2 = off_101F55208;
  a2[1] = v4;
  result = sub_100E03FE8((a2 + 2), (a1 + 2));
  v6 = a1[58];
  a2[57] = a1[57];
  a2[58] = v6;
  if (v6)
  {
    atomic_fetch_add_explicit((v6 + 16), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_1015F2A54(void *a1)
{
  sub_1015F301C(a1 + 8);

  operator delete(a1);
}

void sub_1015F2A90(uint64_t a1, int *a2, uint64_t a3)
{
  v4 = *a2;
  v28 = *a3;
  *(a3 + 8) = 0;
  *(a3 + 16) = 0;
  *v29 = *(a3 + 32);
  *(a3 + 24) = 0;
  *(a3 + 32) = 0;
  v5 = *(a3 + 48);
  v6 = *(a3 + 56);
  *(a3 + 40) = 0;
  *(a3 + 48) = 0;
  v30 = v5;
  v31 = v6;
  *v32 = *(a3 + 64);
  *(a3 + 64) = 0;
  *(a3 + 72) = 0;
  v35 = *(a3 + 96);
  v7 = *(a3 + 80);
  v8 = *(a3 + 88);
  *(a3 + 80) = 0;
  v33 = v7;
  v34 = v8;
  v9 = *(a3 + 104);
  v37 = *(a3 + 120);
  *v36 = v9;
  *(a3 + 104) = 0;
  *(a3 + 112) = 0;
  v10 = *(a3 + 128);
  v39 = *(a3 + 144);
  *v38 = v10;
  *(a3 + 120) = 0;
  *(a3 + 128) = 0;
  *(a3 + 136) = 0;
  *(a3 + 144) = 0;
  v40 = *(a3 + 152);
  v11 = *(a1 + 464);
  if (v11)
  {
    v12 = *(a1 + 8);
    v13 = std::__shared_weak_count::lock(v11);
    if (v13)
    {
      v14 = v13;
      if (!*(a1 + 456))
      {
LABEL_43:
        sub_100004A34(v14);
        goto LABEL_44;
      }

      v41[0] = 0;
      v41[1] = 0;
      v42 = 0;
      if (v4 == 2)
      {
        HIBYTE(v42) = 8;
        v16 = 0x696669646F4DLL;
      }

      else
      {
        if (v4 != 1)
        {
          HIBYTE(v42) = 7;
          if (v4)
          {
            LODWORD(v41[0]) = 1852534357;
            v15 = 1853321070;
          }

          else
          {
            LODWORD(v41[0]) = 1869376577;
            v15 = 1684371311;
          }

          *(v41 + 3) = v15;
          goto LABEL_13;
        }

        HIBYTE(v42) = 8;
        v16 = 0x7463656A6552;
      }

      v41[0] = (v16 & 0xFFFFFFFFFFFFLL | 0x6465000000000000);
LABEL_13:
      v17 = *(v12 + 48);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0]) = 136315138;
        *(buf + 4) = v41;
        _os_log_impl(&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I IMSCallCommandDriver::performSimCallControlAndDial - Result - %s", buf, 0xCu);
      }

      if (*(v12 + 634))
      {
        *(v12 + 634) = 0;
        if (v4 == 1)
        {
          v18 = *(v12 + 48);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf[0]) = 0;
            _os_log_error_impl(&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Call control result is rejected so ending the call", buf, 2u);
          }

          (*(**(v12 + 136) + 72))(*(v12 + 136), a1 + 16, 1, 1);
        }

        else
        {
          v74 = 0;
          v72 = 0u;
          v73 = 0u;
          v70 = 0u;
          v71 = 0u;
          v68 = 0u;
          v69 = 0u;
          v66 = 0u;
          v67 = 0u;
          v64 = 0u;
          v65 = 0u;
          v62 = 0u;
          v63 = 0u;
          v60 = 0u;
          v61 = 0u;
          v58 = 0u;
          v59 = 0u;
          v56 = 0u;
          v57 = 0u;
          v54 = 0u;
          v55 = 0u;
          v52 = 0u;
          v53 = 0u;
          v50 = 0u;
          v51 = 0u;
          memset(buf, 0, sizeof(buf));
          sub_100E03FE8(buf, a1 + 16);
          if (v4 == 2)
          {
            v21 = *(v12 + 48);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              v24 = *(a1 + 40);
              v22 = a1 + 40;
              v23 = v24;
              v25 = *(v22 + 23);
              CSIPhoneNumber::getBaseNumber(&v43, &v28);
              v26 = v25 >= 0 ? v22 : v23;
              v27 = v44 >= 0 ? &v43 : v43;
              *v45 = 136315394;
              v46 = v26;
              v47 = 2080;
              v48 = v27;
              _os_log_impl(&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I IMSCallCommandDriver::performSimCallControlAndDial - Modified Destination Number from %s to %s", v45, 0x16u);
              if (SHIBYTE(v44) < 0)
              {
                operator delete(v43);
              }
            }

            CSIPhoneNumber::getBaseNumber(&v43, &v28);
            if (SHIBYTE(buf[2]) < 0)
            {
              operator delete(*(&buf[1] + 1));
            }

            *(&buf[1] + 8) = v43;
            *(&buf[2] + 1) = v44;
            LODWORD(v50) = CSIPhoneNumber::getTypeOfNumber(&v28);
          }

          sub_100E03FE8(&v43, buf);
          sub_1015E5E1C(v12, &v43, 0);
          sub_1000BFE80(&v43);
          sub_1000BFE80(buf);
        }
      }

      else
      {
        v19 = *(v12 + 48);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          sub_1000BA468(v45, (a1 + 16));
          printUuid();
          if ((SBYTE7(buf[1]) & 0x80u) == 0)
          {
            v20 = buf;
          }

          else
          {
            v20 = *&buf[0];
          }

          LODWORD(v43) = 136315138;
          *(&v43 + 4) = v20;
          _os_log_impl(&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Call %s has been ended at the request of user, ignoring the sim control result.", &v43, 0xCu);
          if (SBYTE7(buf[1]) < 0)
          {
            operator delete(*&buf[0]);
          }

          sub_1000475BC(v45);
        }
      }

      if (SHIBYTE(v42) < 0)
      {
        operator delete(v41[0]);
      }

      goto LABEL_43;
    }
  }

LABEL_44:
  if (SHIBYTE(v39) < 0)
  {
    operator delete(v38[0]);
  }

  if (SHIBYTE(v37) < 0)
  {
    operator delete(v36[0]);
  }

  if (SHIBYTE(v33) < 0)
  {
    operator delete(v32[0]);
  }

  if (SHIBYTE(v30) < 0)
  {
    operator delete(v29[0]);
  }

  if (*(&v28.var2.__rep_.__l + 23) < 0)
  {
    operator delete(v28.var2.__rep_.__l.__data_);
  }
}

void sub_1015F2F68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *__p, uint64_t a31, int a32, __int16 a33, char a34, char a35)
{
  sub_1000BFE80(&STACK[0x2A0]);
  if (a35 < 0)
  {
    operator delete(__p);
  }

  sub_100004A34(v35);
  sub_10034F8E8(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1015F2FD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

const void **sub_1015F301C(uint64_t a1)
{
  v2 = *(a1 + 456);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return sub_1000BFE80(a1 + 8);
}

void sub_1015F305C(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    prime = 2;
  }

  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
    {
      prime = std::__next_prime(__n);
    }
  }

  v4 = *(a1 + 8);
  if (prime > *&v4)
  {
LABEL_6:
    if (!(prime >> 61))
    {
      operator new();
    }

    sub_100013D10();
  }

  if (prime < *&v4)
  {
    v5 = vcvtps_u32_f32(*(a1 + 24) / *(a1 + 32));
    if (*&v4 < 3uLL || (v6 = vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }

    else
    {
      v7 = 1 << -__clz(v5 - 1);
      if (v5 >= 2)
      {
        v5 = v7;
      }
    }

    if (prime <= v5)
    {
      prime = v5;
    }

    if (prime < *&v4)
    {
      if (prime)
      {
        goto LABEL_6;
      }

      v8 = *a1;
      *a1 = 0;
      if (v8)
      {
        operator delete(v8);
      }

      *(a1 + 8) = 0;
    }
  }
}

__n128 sub_1015F32DC(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F55298;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_1015F3314(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v4 = v3 + 1;
  v5 = v3[1];
  v9 = *v3;
  v10 = v5;
  if (v3[2])
  {
    *(v5 + 16) = &v10;
    *v3 = v4;
    *v4 = 0;
    v3[2] = 0;
  }

  else
  {
    v9 = &v10;
  }

  sub_100901888(v3, a2);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  v6(v8, &v9);
  sub_100009970(&v9, v10);
}

uint64_t sub_1015F33EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1015F34AC(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F55318;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

void sub_1015F34DC(uint64_t a1, xpc_object_t *a2)
{
  v3 = *(a1 + 8);
  v4 = &v64;
  v5 = v3 + 1;
  v6 = v3[1];
  v63 = *v3;
  v64 = v6;
  if (v3[2])
  {
    *(v6 + 16) = &v64;
    *v3 = v5;
    *v5 = 0;
    v3[2] = 0;
  }

  else
  {
    v63 = &v64;
  }

  read_rest_value(v3, a2);
  v7 = *(a1 + 16);
  v8 = *(v7 + 736);
  v9 = (v7 + 744);
  if (v8 != (v7 + 744))
  {
    do
    {
      v66 = 0;
      v67 = 0;
      ServiceMap = Registry::getServiceMap(*(v7 + 56));
      v11 = ServiceMap;
      if (v12 < 0)
      {
        v13 = (v12 & 0x7FFFFFFFFFFFFFFFLL);
        v14 = 5381;
        do
        {
          v12 = v14;
          v15 = *v13++;
          v14 = (33 * v14) ^ v15;
        }

        while (v15);
      }

      std::mutex::lock(ServiceMap);
      *&__p = v12;
      v16 = sub_100009510(&v11[1].__m_.__sig, &__p);
      if (v16)
      {
        v17 = v16[3];
        v18 = v16[4];
        if (v18)
        {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_100004A34(v18);
          v19 = 0;
          goto LABEL_13;
        }
      }

      else
      {
        v17 = 0;
      }

      std::mutex::unlock(v11);
      v18 = 0;
      v19 = 1;
LABEL_13:
      v20 = (v8 + 4);
      (**v17)(&v66, v17, (v8 + 4));
      if ((v19 & 1) == 0)
      {
        sub_100004A34(v18);
      }

      if (v66)
      {
        v21 = SlotIdFromPersonalityIdEx();
        if (subscriber::isValidSimSlot())
        {
          if (v21 == 1)
          {
            v22 = v4;
            __p = 0uLL;
            v73 = 0;
            PersonalityIdFromSlotIdEx();
            v23 = *(v8 + 55);
            if (v23 >= 0)
            {
              v24 = *(v8 + 55);
            }

            else
            {
              v24 = v8[5];
            }

            v25 = SHIBYTE(v73);
            if (v73 >= 0)
            {
              v26 = HIBYTE(v73);
            }

            else
            {
              v26 = *(&__p + 1);
            }

            if (v24 != v26 || (v23 >= 0 ? (v27 = (v8 + 4)) : (v27 = *v20), (v28 = __p, v73 >= 0) ? (v29 = &__p) : (v29 = __p), memcmp(v27, v29, v24)))
            {
              v30 = *(v7 + 48);
              if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
              {
                v31 = *v20;
                if (v23 >= 0)
                {
                  v31 = (v8 + 4);
                }

                p_p = __p;
                if (v25 >= 0)
                {
                  p_p = &__p;
                }

                if (!v24)
                {
                  v31 = "<invalid>";
                }

                *buf = 136315394;
                v69 = v31;
                if (v26)
                {
                  v33 = p_p;
                }

                else
                {
                  v33 = "<invalid>";
                }

                v70 = 2080;
                v71 = v33;
                _os_log_impl(&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Skip updating call capabilities here. The personality ID: %s is not for Thumper service: %s.", buf, 0x16u);
                LOBYTE(v25) = HIBYTE(v73);
              }

              if ((v25 & 0x80) != 0)
              {
                operator delete(__p);
              }

              v4 = v22;
              v9 = (v7 + 744);
              goto LABEL_85;
            }

            if (v25 < 0)
            {
              operator delete(v28);
            }

            v4 = v22;
            v9 = (v7 + 744);
          }

          v47 = sub_100007A6C(&v63, v8 + 4);
          v48 = (*(**(v7 + 120) + 16))(*(v7 + 120), v21);
          v49 = v48;
          if (v4 == v47)
          {
            v53 = *v48;
            if (os_log_type_enabled(*v48, OS_LOG_TYPE_DEFAULT))
            {
              v54 = *(v8 + 55);
              v55 = (v54 & 0x80u) != 0;
              if ((v54 & 0x80u) != 0)
              {
                v54 = v8[5];
              }

              if (v55)
              {
                v56 = v8[4];
              }

              else
              {
                v56 = (v8 + 4);
              }

              v38 = v54 == 0;
              v57 = "<invalid>";
              if (!v38)
              {
                v57 = v56;
              }

              LODWORD(__p) = 136315138;
              *(&__p + 4) = v57;
              v58 = v53;
              v59 = "#I New voice over Wifi provisioning added, update call capabilities for PID: %s.";
              v60 = 12;
LABEL_83:
              _os_log_impl(&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, v59, &__p, v60);
            }
          }

          else
          {
            v50 = sub_1011D44D8(v47 + 56, (v8 + 7));
            v51 = *v49;
            v52 = os_log_type_enabled(*v49, OS_LOG_TYPE_DEFAULT);
            if (v50)
            {
              if (v52)
              {
                LOWORD(__p) = 0;
                _os_log_impl(&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Voice over Wifi provisioning did NOT change, ignoring.", &__p, 2u);
              }

              goto LABEL_85;
            }

            if (v52)
            {
              LOWORD(__p) = 0;
              v58 = v51;
              v59 = "#I Voice over Wifi provisioning changed, update call capabilities";
              v60 = 2;
              goto LABEL_83;
            }
          }

          (*(*v7 + 488))(v7, v21);
          goto LABEL_85;
        }

        v42 = *(v7 + 48);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        {
          v43 = *(v8 + 55);
          v44 = (v43 & 0x80u) != 0;
          if ((v43 & 0x80u) != 0)
          {
            v43 = v8[5];
          }

          if (v44)
          {
            v45 = v8[4];
          }

          else
          {
            v45 = (v8 + 4);
          }

          v38 = v43 == 0;
          v46 = "<invalid>";
          if (!v38)
          {
            v46 = v45;
          }

          LODWORD(__p) = 136315138;
          *(&__p + 4) = v46;
          v40 = v42;
          v41 = "Sim slot found for PersonalityID :%s is not valid!";
LABEL_64:
          _os_log_error_impl(&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, v41, &__p, 0xCu);
        }
      }

      else
      {
        v34 = *(v7 + 48);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          v35 = *(v8 + 55);
          v36 = (v35 & 0x80u) != 0;
          if ((v35 & 0x80u) != 0)
          {
            v35 = v8[5];
          }

          if (v36)
          {
            v37 = v8[4];
          }

          else
          {
            v37 = (v8 + 4);
          }

          v38 = v35 == 0;
          v39 = "<invalid>";
          if (!v38)
          {
            v39 = v37;
          }

          LODWORD(__p) = 136315138;
          *(&__p + 4) = v39;
          v40 = v34;
          v41 = "PersonalityInfo not found for PID:%s.";
          goto LABEL_64;
        }
      }

LABEL_85:
      if (v67)
      {
        sub_100004A34(v67);
      }

      v61 = v8[1];
      if (v61)
      {
        do
        {
          v62 = v61;
          v61 = *v61;
        }

        while (v61);
      }

      else
      {
        do
        {
          v62 = v8[2];
          v38 = *v62 == v8;
          v8 = v62;
        }

        while (!v38);
      }

      v8 = v62;
    }

    while (v62 != v9);
  }

  sub_1001A904C(&v63, v64);
}

uint64_t sub_1015F3AF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1015F3BC0(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F55398;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_1015F3BF8(void *a1, xpc *this, BOOL a3)
{
  v4 = a1[1];
  v5 = *v4;
  *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  return v6(v8, v5);
}

uint64_t sub_1015F3C90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1015F3D58(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F55418;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_1015F3D90(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v4 = v3 + 1;
  v5 = v3[1];
  v11 = *v3;
  v12 = v5;
  v13 = v3[2];
  if (v13)
  {
    v5[2] = &v12;
    *v3 = v4;
    *v4 = 0;
    v3[2] = 0;
  }

  else
  {
    v11 = &v12;
  }

  sub_100109E38(v3, a2);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  v9 = v11;
  v10[0] = v12;
  v10[1] = v13;
  if (v13)
  {
    v12[2] = v10;
    v11 = &v12;
    v12 = 0;
    v13 = 0;
  }

  else
  {
    v9 = v10;
  }

  v6(v8, &v9);
  sub_10006DCAC(&v9, v10[0]);
  sub_10006DCAC(&v11, v12);
}

void sub_1015F3E8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13)
{
  sub_10006DCAC(&a9, a10);
  sub_10006DCAC(&a12, a13);
  _Unwind_Resume(a1);
}

uint64_t sub_1015F3EB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1015F3F80(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F55498;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_1015F3FB8(void *a1)
{
  v1 = a1[2];
  v2 = a1[3];
  v3 = (a1[1] + (v2 >> 1));
  if (v2)
  {
    return (*(*v3 + v1))();
  }

  else
  {
    return v1(v3);
  }
}

uint64_t sub_1015F4000(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1015F404C(void *a1)
{
  v1 = a1[5];
  v2 = a1[6];
  v3 = (a1[4] + (v2 >> 1) - 16);
  if (v2)
  {
    return (*(*v3 + v1))();
  }

  else
  {
    return v1(v3);
  }
}

void *sub_1015F4098(void *a1)
{
  *a1 = off_101F55538;
  v2 = a1[2];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return a1;
}

void sub_1015F40E4(void *a1)
{
  *a1 = off_101F55538;
  v1 = a1[2];
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_1015F4150(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    std::__shared_weak_count::lock(v1);
  }

  operator new();
}

void sub_1015F4200(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

void *sub_1015F42A4(void *a1)
{
  *a1 = off_101F55588;
  v2 = a1[2];
  if (v2)
  {
    sub_100004A34(v2);
  }

  return a1;
}

void sub_1015F42F0(void *a1)
{
  *a1 = off_101F55588;
  v1 = a1[2];
  if (v1)
  {
    sub_100004A34(v1);
  }

  operator delete();
}

__n128 sub_1015F4444(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F555C8;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_1015F447C(void *a1)
{
  v14 = 0u;
  v15 = 0u;
  *v12 = 0u;
  *__p = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  *v9 = 0u;
  *v6 = 0u;
  *v7 = 0u;
  v5 = 0u;
  CSIPhoneNumber::CSIPhoneNumber((&v5 + 8));
  DWORD2(v15) = 0;
  rest::read_rest_value();
  v2 = a1[2];
  v3 = a1[3];
  v4 = (a1[1] + (v3 >> 1));
  if (v3)
  {
    v2 = *(*v4 + v2);
  }

  v2(v4, &v5);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__p[1]);
  }

  if (SHIBYTE(__p[0]) < 0)
  {
    operator delete(v12[0]);
  }

  if (SHIBYTE(v10) < 0)
  {
    operator delete(v9[1]);
  }

  if (SHIBYTE(v8) < 0)
  {
    operator delete(v7[1]);
  }

  if (SHIBYTE(v7[0]) < 0)
  {
    operator delete(v6[0]);
  }
}

uint64_t sub_1015F4590(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1015F4658(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F55648;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_1015F4690(void *a1)
{
  v14 = 0u;
  v15 = 0u;
  *v12 = 0u;
  *__p = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  *v9 = 0u;
  *v6 = 0u;
  *v7 = 0u;
  v5 = 0u;
  CSIPhoneNumber::CSIPhoneNumber((&v5 + 8));
  DWORD2(v15) = 0;
  rest::read_rest_value();
  v2 = a1[2];
  v3 = a1[3];
  v4 = (a1[1] + (v3 >> 1));
  if (v3)
  {
    v2 = *(*v4 + v2);
  }

  v2(v4, &v5);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__p[1]);
  }

  if (SHIBYTE(__p[0]) < 0)
  {
    operator delete(v12[0]);
  }

  if (SHIBYTE(v10) < 0)
  {
    operator delete(v9[1]);
  }

  if (SHIBYTE(v8) < 0)
  {
    operator delete(v7[1]);
  }

  if (SHIBYTE(v7[0]) < 0)
  {
    operator delete(v6[0]);
  }
}

uint64_t sub_1015F47A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1015F486C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F556C8;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_1015F48A4(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v4 = v3 + 1;
  v5 = v3[1];
  v9 = *v3;
  v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *v3 = v4;
    *v4 = 0;
    v3[2] = 0;
  }

  else
  {
    v9 = &v10;
  }

  sub_10032CF1C(v3, a2);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  v6(v8, &v9);
  sub_10032D3A4(&v9, v10);
}

uint64_t sub_1015F497C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1015F4A44(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F55748;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_1015F4A7C(uint64_t *a1, xpc_object_t *a2)
{
  sub_100AF1E40(a1[1], a2);
  v3 = a1[3];
  v4 = a1[4];
  v5 = (a1[2] + (v4 >> 1));
  if (v4)
  {
    v3 = *(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1015F4AF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_1015F4B64(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F557C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_1015F4BE0(void *a1)
{
  *a1 = off_101F55818;
  v2 = a1[2];
  if (v2)
  {
    sub_100004A34(v2);
  }

  return a1;
}

void sub_1015F4C2C(void *a1)
{
  *a1 = off_101F55818;
  v1 = a1[2];
  if (v1)
  {
    sub_100004A34(v1);
  }

  operator delete();
}

uint64_t sub_1015F4C98(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 16))();
  }

  return result;
}

uint64_t sub_1015F4CC8(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 24))();
  }

  return result;
}

uint64_t sub_1015F4CF8(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 32))();
  }

  return result;
}

const void **sub_1015F4D28(const void **result, const void **a2)
{
  v2 = result[1];
  if (v2)
  {
    sub_1000BA468(&v3, a2);
    (*(*v2 + 40))(v2, &v3);
    return sub_1000475BC(&v3);
  }

  return result;
}

void sub_1015F4D90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000475BC(va);
  _Unwind_Resume(a1);
}

uint64_t sub_1015F4DA4(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 48))();
  }

  return result;
}

uint64_t sub_1015F4DD4(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 56))();
  }

  return result;
}

uint64_t sub_1015F4E04(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 64))();
  }

  return result;
}

uint64_t sub_1015F4E34(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 72))();
  }

  return result;
}

uint64_t sub_1015F4E64(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 88))();
  }

  return result;
}

uint64_t sub_1015F4E94(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 80))();
  }

  return result;
}

uint64_t sub_1015F4EC4(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 96))();
  }

  return result;
}

uint64_t sub_1015F4EF4(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 104))();
  }

  return result;
}

uint64_t sub_1015F4F24(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 112))();
  }

  return result;
}

uint64_t sub_1015F4F54(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 128))();
  }

  return result;
}

uint64_t sub_1015F4F84(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 136))();
  }

  return result;
}

uint64_t sub_1015F4FB4(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 144))();
  }

  return result;
}

uint64_t sub_1015F4FE4(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 152))();
  }

  return result;
}

uint64_t sub_1015F5014(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 168))();
  }

  return result;
}

uint64_t sub_1015F5044(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 176))();
  }

  return result;
}

uint64_t sub_1015F5074(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 184))();
  }

  return result;
}

uint64_t sub_1015F50A4(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 208))();
  }

  return result;
}

uint64_t sub_1015F50D4(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 192))();
  }

  return result;
}

const void **sub_1015F5104(const void **result, uint64_t a2, const void **a3, uint64_t a4)
{
  v4 = result[1];
  if (v4)
  {
    sub_1000BA468(&v7, a3);
    (*(*v4 + 160))(v4, a2, &v7, a4);
    return sub_1000475BC(&v7);
  }

  return result;
}

void sub_1015F5188(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000475BC(va);
  _Unwind_Resume(a1);
}

uint64_t sub_1015F519C(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 216))();
  }

  return result;
}

void sub_1015F51CC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *a2 = 0;
  *(a2 + 8) = 0;
  *(a2 + 16) = 0;
  v2 = *(a1 + 8);
  if (v2)
  {
    (*(*v2 + 240))(&v4);
    sub_100AF8E58(a2);
    *a2 = v4;
    *(a2 + 16) = v5;
    v5 = 0;
    v4 = 0uLL;
    v6 = &v4;
    sub_1000B42B0(&v6);
  }
}

uint64_t sub_1015F5274(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 248))();
  }

  return result;
}

uint64_t sub_1015F52A4(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 256))();
  }

  return result;
}

void sub_1015F52DC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *a2 = 0;
  *(a2 + 8) = 0;
  *(a2 + 16) = 0;
  v2 = *(a1 + 8);
  if (v2)
  {
    (*(*v2 + 264))(&v4);
    sub_100AF8E58(a2);
    *a2 = v4;
    *(a2 + 16) = v5;
    v5 = 0;
    v4 = 0uLL;
    v6 = &v4;
    sub_1000B42B0(&v6);
  }
}

uint64_t sub_1015F538C(uint64_t a1, const void **a2, uint64_t a3)
{
  v3 = *(a1 + 8);
  if (!v3)
  {
    return 0;
  }

  sub_1000BA468(&v7, a2);
  v5 = (*(*v3 + 272))(v3, &v7, a3);
  sub_1000475BC(&v7);
  return v5;
}

void sub_1015F5414(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000475BC(va);
  _Unwind_Resume(a1);
}

const void **sub_1015F5428(const void **result, uint64_t a2, uint64_t a3)
{
  v3 = result[1];
  if (v3)
  {
    sub_100E03FE8(v5, a2);
    (*(*v3 + 288))(v3, v5, a3);
    return sub_1000BFE80(v5);
  }

  return result;
}

void sub_1015F54A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000BFE80(va);
  _Unwind_Resume(a1);
}

uint64_t sub_1015F54BC(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 296))();
  }

  return result;
}

uint64_t sub_1015F54F4(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 344))();
  }

  return result;
}

_BYTE *sub_1015F552C@<X0>(uint64_t a1@<X0>, _BYTE *a2@<X8>)
{
  v2 = *(a1 + 8);
  if (v2)
  {
    return (*(*v2 + 352))();
  }

  else
  {
    return sub_10000501C(a2, "");
  }
}

uint64_t sub_1015F5570(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 360))();
  }

  return result;
}

uint64_t sub_1015F55A8(uint64_t a1)
{
  v1 = *(a1 + 8);
  if (v1)
  {
    return (*(*v1 + 368))();
  }

  else
  {
    return 1;
  }
}

uint64_t sub_1015F55E4(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 376))();
  }

  return result;
}

uint64_t sub_1015F561C(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 384))();
  }

  return result;
}

uint64_t sub_1015F5654(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 392))();
  }

  return result;
}

uint64_t sub_1015F568C(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 400))();
  }

  return result;
}

uint64_t sub_1015F56C4(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 408))();
  }

  return result;
}

uint64_t sub_1015F56FC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 312))();
  }

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

uint64_t sub_1015F573C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 320))();
  }

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

uint64_t sub_1015F577C(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 416))();
  }

  return result;
}

uint64_t sub_1015F57B4(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 424))();
  }

  return result;
}

uint64_t sub_1015F57EC(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 432))();
  }

  return result;
}

void sub_1015F5844(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F559B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_1015F58C0(void *a1)
{
  *a1 = off_101F55A08;
  v2 = a1[2];
  if (v2)
  {
    sub_100004A34(v2);
  }

  return a1;
}

void sub_1015F590C(void *a1)
{
  *a1 = off_101F55A08;
  v1 = a1[2];
  if (v1)
  {
    sub_100004A34(v1);
  }

  operator delete();
}

CallCommandDriver *sub_1015F5978(uint64_t a1, BOOL a2, const CallInfo *a3)
{
  result = *(a1 + 8);
  if (result)
  {
    return CallCommandDriver::shouldMTCallContinue(result, a2, a3);
  }

  return result;
}

uint64_t sub_1015F5988(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 376))();
  }

  return result;
}

uint64_t sub_1015F59C0(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 488))();
  }

  return result;
}

uint64_t sub_1015F59F8(uint64_t a1)
{
  result = *(a1 + 8);
  if (result)
  {
    return (*(*result + 496))();
  }

  return result;
}

void sub_1015F5A30(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1015F5D10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17)
  {
    (*(a17->isa + 1))(a17);
  }

  if (a12)
  {
    sub_100004A34(a12);
  }

  sub_100004A34(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_1015F5E5C(uint64_t a1)
{
  *a1 = off_101F55A78;
  v2 = *(a1 + 128);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(a1 + 112);
  if (v3)
  {
    sub_100004A34(v3);
  }

  sub_10006DCAC(a1 + 80, *(a1 + 88));
  v4 = *(a1 + 72);
  if (v4)
  {
    sub_100004A34(v4);
  }

  v5 = *(a1 + 56);
  if (v5)
  {
    sub_100004A34(v5);
  }

  CDMARoamingInterface::~CDMARoamingInterface(a1);
  ctu::OsLogLogger::~OsLogLogger((a1 + 40));
  sub_1000C0544((a1 + 8));
  return a1;
}

void sub_1015F5EF4(uint64_t a1)
{
  sub_1015F5E5C(a1);

  operator delete();
}

void sub_1015F5F2C(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_1015F602C(uint64_t a1)
{
  v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_1015F787C;
  v5[3] = &unk_101F55CC0;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  v6 = v5;
  v2 = a1 + 24;
  v1 = *(a1 + 24);
  if (*(v2 + 8))
  {
    v13 = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_10006A788;
    v10 = &unk_101F55D00;
    v11 = &v13;
    v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }

  else
  {
    v13 = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_10005982C;
    v10 = &unk_101F55CE0;
    v11 = &v13;
    v12 = &v6;
    dispatch_sync(v1, &block);
  }

  return v13 & 1;
}

uint64_t sub_1015F6158(uint64_t a1)
{
  v13 = 0;
  (*(**(a1 + 104) + 40))(&v12);
  sub_100010180(&v13, &v12);
  sub_10000A1EC(&v12);
  if (!v13)
  {
    v2 = *(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      v3 = "#I CDMA International functionality is not present in the carrier bundle, assuming not allowed";
      goto LABEL_24;
    }

LABEL_25:
    v9 = 0;
    goto LABEL_26;
  }

  if ((*(**(a1 + 120) + 296))(*(a1 + 120)))
  {
    v2 = *(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      v3 = "#N Voice roaming is disabled, and that overrides CDMA International Roaming";
LABEL_24:
      _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, v3, &v12, 2u);
      goto LABEL_25;
    }

    goto LABEL_25;
  }

  v4 = *(a1 + 88);
  if (!v4)
  {
    goto LABEL_22;
  }

  v5 = a1 + 88;
  do
  {
    if (*(v4 + 28) >= 1)
    {
      v5 = v4;
    }

    v4 = *(v4 + 8 * (*(v4 + 28) < 1));
  }

  while (v4);
  if (v5 == a1 + 88 || *(v5 + 28) > 1)
  {
LABEL_22:
    v2 = *(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      v3 = "#N Could not find device type";
      goto LABEL_24;
    }

    goto LABEL_25;
  }

  v6 = *(v5 + 32);
  if (v6)
  {
    v7 = v6 == 3;
  }

  else
  {
    v7 = 1;
  }

  if (!v7)
  {
    v2 = *(a1 + 40);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_25;
    }

    LOWORD(v12) = 0;
    v3 = "#N Device is not CDMA based";
    goto LABEL_24;
  }

  v8 = *(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v12) = 0;
    _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Device is CDMA based, CDMA International Roaming is allowed", &v12, 2u);
  }

  v9 = 1;
LABEL_26:
  sub_10001021C(&v13);
  return v9;
}

void sub_1015F637C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10001021C(va);
  _Unwind_Resume(a1);
}

void sub_1015F63A0(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      v6 = v5;
      (*(*v3 + 24))(v3, v5);
    }

    else
    {
      v6 = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    v6 = 0;
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_1015F658C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1015F65A8(uint64_t a1)
{
  v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_1015F7A24;
  v5[3] = &unk_101F55D20;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  v6 = v5;
  v2 = a1 + 24;
  v1 = *(a1 + 24);
  if (*(v2 + 8))
  {
    v13 = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_10006A788;
    v10 = &unk_101F55D00;
    v11 = &v13;
    v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }

  else
  {
    v13 = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_10005982C;
    v10 = &unk_101F55CE0;
    v11 = &v13;
    v12 = &v6;
    dispatch_sync(v1, &block);
  }

  return v13 & 1;
}

uint64_t sub_1015F66D4(uint64_t a1)
{
  if (sub_1015F6158(a1))
  {
    v20 = 1;
    v2 = sub_10005D028();
    sub_10000501C(buf, "EURQMIC2KRegistrationController::fCDMAInternationalRoaming");
    v3 = sub_10005D0D8(v2, buf, &v20);
    v4 = v3;
    if (v22 < 0)
    {
      operator delete(*buf);
      if (v4)
      {
        goto LABEL_20;
      }
    }

    else if (v3)
    {
LABEL_20:
      if (v20)
      {
        return 1;
      }

      else
      {
        return 2;
      }
    }

    theDict = 0;
    (*(**(a1 + 104) + 40))(buf);
    sub_100010180(&theDict, buf);
    sub_10000A1EC(buf);
    if (theDict)
    {
      Value = CFDictionaryGetValue(theDict, @"EnabledByDefault");
      v8 = Value;
      if (Value && (v9 = CFGetTypeID(Value), v9 == CFBooleanGetTypeID()))
      {
        buf[0] = 0;
        ctu::cf::assign(buf, v8, v10);
        v11 = buf[0];
      }

      else
      {
        v11 = 1;
      }

      v12 = v11 & 1;
      v20 = v11 & 1;
      v13 = *(a1 + 40);
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        goto LABEL_19;
      }

      v14 = CSIBOOLAsString(v12);
      *buf = 136315138;
      *&buf[4] = v14;
      v15 = "#I CDMA Intl roaming enabled by default in Carrier Bundle: %s";
      v16 = v13;
      v17 = 12;
    }

    else
    {
      v18 = *(a1 + 40);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
LABEL_19:
        sub_10001021C(&theDict);
        goto LABEL_20;
      }

      *buf = 0;
      v15 = "#N Cannot retrieve CDMAInternationalRoamingEnabledByDefault from the carrier bundle";
      v16 = v18;
      v17 = 2;
    }

    _os_log_impl(&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
    goto LABEL_19;
  }

  v5 = *(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I The device is not a CDMA based one, not handling the request", buf, 2u);
  }

  return 3;
}

uint64_t sub_1015F6970(uint64_t a1, char a2)
{
  v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_1015F7A4C;
  v7[3] = &unk_101F55D40;
  v7[4] = a1 + 8;
  v7[5] = v5;
  v8 = v7;
  v3 = a1 + 24;
  v2 = *(a1 + 24);
  if (*(v3 + 8))
  {
    v15 = 0;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_10006A788;
    v12 = &unk_101F55D00;
    v13 = &v15;
    v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    v15 = 0;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_10005982C;
    v12 = &unk_101F55CE0;
    v13 = &v15;
    v14 = &v8;
    dispatch_sync(v2, &block);
  }

  return v15 & 1;
}

void sub_1015F6AA8(uint64_t a1, char a2)
{
  ServiceMap = Registry::getServiceMap(*(a1 + 48));
  v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    v7 = (v6 & 0x7FFFFFFFFFFFFFFFLL);
    v8 = 5381;
    do
    {
      v6 = v8;
      v9 = *v7++;
      v8 = (33 * v8) ^ v9;
    }

    while (v9);
  }

  std::mutex::lock(ServiceMap);
  v15 = v6;
  v10 = sub_100009510(&v5[1].__m_.__sig, &v15);
  if (v10)
  {
    v12 = v10[3];
    v11 = v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v11);
      v13 = 0;
      if (!v12)
      {
        goto LABEL_7;
      }

LABEL_11:
      v16[0] = off_101F55E70;
      v16[1] = a1;
      LOBYTE(v17[0]) = a2;
      v17[1] = v16;
      memset(v17 + 1, 0, 7);
      (*(*v12 + 136))(v12, 1, v16);
      sub_100627050(v16);
      goto LABEL_12;
    }
  }

  else
  {
    v12 = 0;
  }

  std::mutex::unlock(v5);
  v11 = 0;
  v13 = 1;
  if (v12)
  {
    goto LABEL_11;
  }

LABEL_7:
  v14 = *(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v15) = 0;
    _os_log_error_impl(&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not get Max Data Rate Manager to change RAT selection", &v15, 2u);
  }

LABEL_12:
  if ((v13 & 1) == 0)
  {
    sub_100004A34(v11);
  }
}

void sub_1015F6C68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100627050(va);
  if ((v3 & 1) == 0)
  {
    sub_100004A34(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1015F6C9C(uint64_t a1)
{
  v2 = *(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = sub_1015F6158(a1);
    v13 = 136315138;
    v14 = CSIBOOLAsString(v3);
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Is CDMA International Roaming Allowed?: %s", &v13, 0xCu);
    v2 = *(a1 + 40);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_1015F66D4(a1);
    v4 = asString();
    v13 = 136315138;
    v14 = v4;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Current CDMA International Roaming Status: %s", &v13, 0xCu);
  }

  v5 = *(a1 + 88);
  if (!v5)
  {
    goto LABEL_14;
  }

  v6 = a1 + 88;
  do
  {
    if (*(v5 + 28) >= 1)
    {
      v6 = v5;
    }

    v5 = *(v5 + 8 * (*(v5 + 28) < 1));
  }

  while (v5);
  if (v6 == a1 + 88 || *(v6 + 28) > 1)
  {
LABEL_14:
    v12 = *(a1 + 40);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }

    LOWORD(v13) = 0;
    v9 = "#N Could not find device type";
    v10 = v12;
    v11 = 2;
  }

  else
  {
    v7 = *(a1 + 40);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }

    v8 = sub_100072578(*(v6 + 32));
    v13 = 136315138;
    v14 = v8;
    v9 = "#I Device type: %s";
    v10 = v7;
    v11 = 12;
  }

  _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, &v13, v11);
}

void sub_1015F6E60(uint64_t a1, dispatch_object_t *a2)
{
  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_1015F6F8C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1015F6FE0(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1015F7020(uint64_t result)
{
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void sub_1015F704C(ServiceManager::Service *this)
{
  *this = off_101F55BD0;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1015F70A8(ServiceManager::Service *this)
{
  *this = off_101F55BD0;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_1015F7128@<X0>(void *a1@<X8>)
{
  v2 = 2;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  return sub_1000FF040(a1, &v2, &vars0, 1);
}

void sub_1015F716C(uint64_t a1, dispatch_object_t *a2)
{
  v2 = *(a1 + 8);
  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1015F5F2C(v2, v3);
  }

  v4 = *(a1 + 8);

  sub_1015F5F2C(v4, 0);
}

void sub_1015F7210(uint64_t a1, int a2, ServiceStage *this)
{
  v3 = *(a1 + 8);
  ServiceStage::holdOffStage(&group[1], this);
  v4 = *(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t *sub_1015F7324(uint64_t *a1)
{
  v1 = *a1;
  v5 = a1;
  v6 = v1;
  v2 = *v1;
  v3 = *(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }

  ctu::RestModule::disconnect((v2 + 64));
  sub_1000FF844(&v6);
  return sub_1000049E0(&v5);
}

void sub_1015F73A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_1015F73C4(uint64_t **a1)
{
  v1 = **a1;
  v2 = *(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }

  ServiceMap = Registry::getServiceMap(*(v1 + 48));
  v4 = ServiceMap;
  if (v5 < 0)
  {
    v6 = (v5 & 0x7FFFFFFFFFFFFFFFLL);
    v7 = 5381;
    do
    {
      v5 = v7;
      v8 = *v6++;
      v7 = (33 * v7) ^ v8;
    }

    while (v8);
  }

  std::mutex::lock(ServiceMap);
  *buf = v5;
  v9 = sub_100009510(&v4[1].__m_.__sig, buf);
  if (v9)
  {
    v11 = v9[3];
    v10 = v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v10);
      goto LABEL_11;
    }
  }

  else
  {
    v11 = 0;
  }

  std::mutex::unlock(v4);
  v10 = 0;
LABEL_11:
  v12 = *(v1 + 112);
  *(v1 + 104) = v11;
  *(v1 + 112) = v10;
  if (v12)
  {
    sub_100004A34(v12);
  }

  v13 = Registry::getServiceMap(*(v1 + 48));
  v14 = v13;
  if (v15 < 0)
  {
    v16 = (v15 & 0x7FFFFFFFFFFFFFFFLL);
    v17 = 5381;
    do
    {
      v15 = v17;
      v18 = *v16++;
      v17 = (33 * v17) ^ v18;
    }

    while (v18);
  }

  std::mutex::lock(v13);
  *buf = v15;
  v19 = sub_100009510(&v14[1].__m_.__sig, buf);
  if (v19)
  {
    v21 = v19[3];
    v20 = v19[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v14);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v20);
      goto LABEL_21;
    }
  }

  else
  {
    v21 = 0;
  }

  std::mutex::unlock(v14);
  v20 = 0;
LABEL_21:
  v22 = *(v1 + 128);
  *(v1 + 120) = v21;
  *(v1 + 128) = v20;
  if (v22)
  {
    sub_100004A34(v22);
  }

  *buf = _NSConcreteStackBlock;
  v27 = 0x40000000;
  v28 = sub_100DB5CE8;
  v29 = &unk_101ED9908;
  v30 = v1;
  sub_10079D8A0();
  Registry::createRestModuleOneTimeUseConnection(&v23, *(v1 + 48));
  ctu::RestModule::connect();
  if (v24)
  {
    sub_100004A34(v24);
  }

  sub_1008E6D7C(v1 + 80);
  sub_10000501C(&__p, "/cc/events/dump_state");
  operator new();
}

void sub_1015F76C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20)
{
  sub_1000062D4(&a20);
  if (a19 < 0)
  {
    operator delete(__p);
  }

  sub_1000FF844(&a11);
  sub_1000049E0(&a10);
  _Unwind_Resume(a1);
}

__n128 sub_1015F77B0(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F55C50;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_1015F77E8(void *a1)
{
  v1 = a1[2];
  v2 = a1[3];
  v3 = (a1[1] + (v2 >> 1));
  if (v2)
  {
    return (*(*v3 + v1))();
  }

  else
  {
    return v1(v3);
  }
}

uint64_t sub_1015F7830(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1015F787C(uint64_t a1)
{
  v1 = **(a1 + 40);
  v2 = sub_1015F6158(v1);
  v3 = *(v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 136315138;
    v6 = CSIBOOLAsString(v2);
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Received query whether CDMA International Roaming is allowed or not, returning: %s", &v5, 0xCu);
  }

  return v2;
}

uint64_t *sub_1015F7934(uint64_t **a1)
{
  v1 = *a1;
  v5 = a1;
  v6 = v1;
  v2 = sub_1015F66D4(*v1);
  v3 = v1[4];
  v7 = v2;
  if (!v3)
  {
    sub_100022DB4();
  }

  (*(*v3 + 48))(v3, &v7);
  sub_1015F79D4(&v6);
  return sub_1000049E0(&v5);
}

void sub_1015F79B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  sub_1015F79D4(va1);
  sub_1000049E0(va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1015F79D4(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_101321024(v1 + 8);
    operator delete();
  }

  return result;
}

BOOL sub_1015F7A4C(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v12 = **(v1 + 8);
  if ((sub_1015F6158(v2) & 1) == 0)
  {
    v9 = *(v2 + 40);
    result = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    if (!result)
    {
      return result;
    }

    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I The device is not a CDMA based one, not handling the request", &__p, 2u);
    return 0;
  }

  v3 = sub_10005D028();
  sub_10000501C(&__p, "EURQMIC2KRegistrationController::fCDMAInternationalRoaming");
  v4 = sub_1006197F4(v3, &__p, &v12);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v5 = *(v2 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = CSIBOOLAsString(v12);
    v7 = CSIBOOLAsString(v4);
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
    *(__p.__r_.__value_.__r.__words + 4) = v6;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(&__p.__r_.__value_.__r.__words[1] + 6) = v7;
    _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Received request to set CDMA International Roaming to: %s, returning: %s", &__p, 0x16u);
  }

  if (!v4)
  {
    return 0;
  }

  __p.__r_.__value_.__r.__words[0] = _NSConcreteStackBlock;
  __p.__r_.__value_.__l.__size_ = 0x40000000;
  __p.__r_.__value_.__r.__words[2] = sub_100DB5F0C;
  p_p = &unk_101ED9928;
  v15 = v2;
  v8 = sub_100DB5D60(0x80051);
  if (capabilities::ct::supportsSystemSelectionInternationalCDMARoaming(v8))
  {
    (*(**(v2 + 120) + 456))(*(v2 + 120), 1, v12);
  }

  else
  {
    sub_100052008(v2);
    if (v12)
    {
      v11 = *(v2 + 120);
      __p.__r_.__value_.__r.__words[0] = off_101F55D70;
      __p.__r_.__value_.__l.__size_ = v2;
      p_p = &__p;
      (*(*v11 + 96))(v11, 1, &__p);
      sub_10062FB08(&__p);
    }
  }

  return 1;
}

uint64_t sub_1015F7D60(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F55D70;
  a2[1] = v2;
  return result;
}

void sub_1015F7D8C(uint64_t a1)
{
  v1 = *(*(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_1015F7E84(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_1015F7ED0(uint64_t **a1)
{
  v5 = a1;
  v1 = *a1;
  v2 = **a1;
  v3 = *(*a1 + 8);
  if ((v3 & 4) == 0 || ((*a1)[1] & 8) == 0 || (*(v1 + 9) & 0xC) != 0xC)
  {
    v4 = *(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I CDMA International Roaming has been enabled, now setting the RAT back to Automatic", buf, 2u);
      v3 = *(v1 + 8);
    }

    *(v1 + 8) = v3 | 0xC;
    sub_1015F6AA8(v2, v3 | 0xC);
  }

  operator delete();
}

uint64_t sub_1015F8034(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F55DF0;
  a2[1] = v2;
  return result;
}

void sub_1015F8060(uint64_t a1)
{
  v1 = *(*(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_1015F8158(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_1015F81A4(uint64_t **a1)
{
  v1 = *a1;
  v2 = **a1;
  if (sub_1015F66D4(v2) != 2)
  {
    goto LABEL_26;
  }

  ServiceMap = Registry::getServiceMap(*(v2 + 48));
  v4 = ServiceMap;
  if (v5 < 0)
  {
    v6 = (v5 & 0x7FFFFFFFFFFFFFFFLL);
    v7 = 5381;
    do
    {
      v5 = v7;
      v8 = *v6++;
      v7 = (33 * v7) ^ v8;
    }

    while (v8);
  }

  std::mutex::lock(ServiceMap);
  *buf = v5;
  v9 = sub_100009510(&v4[1].__m_.__sig, buf);
  if (v9)
  {
    v11 = v9[3];
    v10 = v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v10);
      v12 = 0;
LABEL_10:
      v13 = (*(*v11 + 88))(v11, 1);
      if ((v12 & 1) == 0)
      {
        sub_100004A34(v10);
      }

      if (!v13)
      {
        v15 = (v1 + 1);
        v19 = *(v1 + 8);
        if ((~v19 & 0xC) != 0 || (~*(v1 + 9) & 0xC) != 0)
        {
          v16 = v19 | 0xC;
          *v15 = v19 | 0xC;
          v17 = *(v2 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *buf = 0;
            v18 = "#I CDMA International Roaming has been enabled, now adding back CDMA bits";
            goto LABEL_22;
          }

LABEL_23:
          sub_1015F6AA8(v2, v16);
        }

LABEL_32:
        operator delete();
      }

      if (v13 == 1)
      {
        v15 = (v1 + 1);
        v14 = *(v1 + 8);
        if ((~v14 & 0xC) == 0 && (~*(v1 + 9) & 0xC) == 0)
        {
          v16 = v14 & 0xF3;
          *v15 = v14 & 0xF3;
          v17 = *(v2 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *buf = 0;
            v18 = "#I CDMA International Roaming is disabled, and the device is currently roaming, removing CDMA from mode pref";
LABEL_22:
            _os_log_impl(&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v18, buf, 2u);
            v16 = *v15;
            goto LABEL_23;
          }

          goto LABEL_23;
        }

        goto LABEL_32;
      }

      v20 = *(v2 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 0;
        _os_log_impl(&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I CDMA International Roaming is disabled, and the device is neither home nor roaming, doing nothing", buf, 2u);
      }

LABEL_26:
      v21 = *(v2 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        ratSelectionAsStr(buf, *(v1 + 8));
        if (v24 >= 0)
        {
          v22 = buf;
        }

        else
        {
          v22 = *buf;
        }

        *v25 = 136446210;
        v26 = v22;
        _os_log_impl(&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Not necessary to change RAT selection from %{public}s", v25, 0xCu);
        if (v24 < 0)
        {
          operator delete(*buf);
        }
      }

      goto LABEL_32;
    }
  }

  else
  {
    v11 = 0;
  }

  std::mutex::unlock(v4);
  v10 = 0;
  v12 = 1;
  goto LABEL_10;
}

void sub_1015F84A8()
{
  if ((v1 & 1) == 0)
  {
    sub_100004A34(v0);
  }

  operator delete();
}

__n128 sub_1015F8574(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F55E70;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  *(a2 + 20) = 0;
  *(a2 + 17) = 0;
  return result;
}

void sub_1015F85AC(uint64_t a1)
{
  v1 = *(*(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_1015F86A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_1015F86F4(void **a1)
{
  v8 = a1;
  v1 = *a1;
  v2 = **a1;
  if (*(*a1 + 9) == 1 && *(v1 + 8) == 1)
  {
    v3 = v2[5];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Carrier and device are LTE capable, adding LTE", buf, 2u);
    }

    *(v1 + 10) |= 0x10u;
  }

  v9 = 0;
  RatSelectionType::RatSelectionType(&v9);
  RatSelectionType::setSelection(&v9, *(v1 + 10));
  RatSelectionType::setPreferredSelection(&v9, *(v1 + 10));
  v4 = v2[2];
  if (v4)
  {
    v5 = v2[1];
    v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      v7 = v6;
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v6);
      v13 = 0;
      sub_100DAF290(&v9, &v13);
      sub_10000501C(&__p, "/cc/requests/rat_selection");
      object = v13;
      v13 = xpc_null_create();
      *buf = off_101F55EE0;
      v15 = v5;
      v16 = v7;
      v17 = buf;
      ctu::RestModule::sendRequest();
      sub_1000062D4(buf);
      xpc_release(object);
      object = 0;
      if (v12 < 0)
      {
        operator delete(__p);
      }

      xpc_release(v13);
      operator delete();
    }
  }

  sub_100013CC4();
}

void sub_1015F88C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, xpc_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, xpc_object_t a19, char a20)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

void *sub_1015F8960(void *a1)
{
  *a1 = off_101F55EE0;
  v2 = a1[2];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return a1;
}

void sub_1015F89AC(void *a1)
{
  *a1 = off_101F55EE0;
  v1 = a1[2];
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

uint64_t sub_1015F8A84(uint64_t result, void *a2)
{
  v3 = *(result + 8);
  v2 = *(result + 16);
  *a2 = off_101F55EE0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 16), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_1015F8ABC(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1015F8ACC(void *__p)
{
  v2 = __p[2];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1015F8B0C(uint64_t a1, xpc_object_t *a2)
{
  object = *a2;
  *a2 = xpc_null_create();
  v4 = xpc::dyn_cast_or_default(&object, 0, v3);
  v5 = *(a1 + 16);
  if (v5)
  {
    v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      v7 = v6;
      v8 = *(a1 + 8);
      if (v8)
      {
        v9 = *(v8 + 40);
        if (v4)
        {
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *buf = 0;
            _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I RAT selection change success", buf, 2u);
          }
        }

        else if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *v11 = 0;
          _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "RAT selection change failed", v11, 2u);
        }
      }

      sub_100004A34(v7);
    }
  }

  xpc_release(object);
}

uint64_t sub_1015F8C28(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F55F40))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_1015F8C74(uint64_t *a1)
{
  v1 = *a1;
  v5 = a1;
  v6 = v1;
  v2 = *(*v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Resetting International CDMA Roaming preference as network settings have been reset", buf, 2u);
  }

  v3 = sub_10005D028();
  sub_10000501C(buf, "EURQMIC2KRegistrationController::fCDMAInternationalRoaming");
  sub_10033220C(v3, buf);
  if (v8 < 0)
  {
    operator delete(*buf);
  }

  sub_1000FF844(&v6);
  return sub_1000049E0(&v5);
}

void sub_1015F8D24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
  {
    operator delete(__p);
  }

  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_1015F8D58(void *a1, void *a2, NSObject **a3)
{
  v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 8), 1uLL, memory_order_relaxed);
  }

  v5 = *a3;
  a1[2] = *a3;
  if (v5)
  {
    dispatch_retain(v5);
  }

  operator new();
}

void sub_1015F8E3C(uint64_t a1)
{
  v2 = *(a1 + 32);
  *(a1 + 32) = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  if (*(a1 + 40))
  {
    v3 = *(a1 + 48);
    *(a1 + 40) = 0;
    *(a1 + 48) = 0;
    if (v3)
    {
      sub_100004A34(v3);
    }

    v4 = **(a1 + 24);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *v5 = 0;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I AssertionWithTimeout: Assertion released", v5, 2u);
    }
  }
}

void sub_1015F8EEC(uint64_t a1, uint64_t a2)
{
  v4 = *(a1 + 32);
  *(a1 + 32) = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  v5 = *(a1 + 40);
  if (v5)
  {
    v6[0] = a1;
    v6[1] = a2;
    if (*(v5 + 68) != 2)
    {
      operator new();
    }

    sub_1015F9010(v6);
  }
}

void sub_1015F8FF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10000FF50(va);
  _Unwind_Resume(a1);
}

void sub_1015F9010(uint64_t *a1)
{
  v2 = *a1;
  if (a1[1] >= 1)
  {
    *buf = 0uLL;
    Registry::getTimerService(buf, *v2);
    v3 = *buf;
    if (*buf)
    {
      v16 = 20;
      strcpy(__p, "AssertionWithTimeout");
      v4 = a1[1];
      v5 = *(v2 + 16);
      object = v5;
      if (v5)
      {
        dispatch_retain(v5);
        v6 = a1[1];
      }

      else
      {
        v6 = v4;
      }

      v12[0] = _NSConcreteStackBlock;
      v12[1] = 0x40000000;
      v12[2] = sub_1015F92B8;
      v12[3] = &unk_101F55F60;
      v12[4] = v2;
      v12[5] = v6;
      aBlock = _Block_copy(v12);
      sub_100D23364(v3, __p, 1, 1000000 * v4, &object, &aBlock);
      v7 = v17;
      v17 = 0;
      v8 = *(v2 + 32);
      *(v2 + 32) = v7;
      if (v8)
      {
        (*(*v8 + 8))(v8);
        v9 = v17;
        v17 = 0;
        if (v9)
        {
          (*(*v9 + 8))(v9);
        }
      }

      if (aBlock)
      {
        _Block_release(aBlock);
      }

      if (object)
      {
        dispatch_release(object);
      }

      if (v16 < 0)
      {
        operator delete(*__p);
      }
    }

    if (*&buf[8])
    {
      sub_100004A34(*&buf[8]);
    }
  }

  if (!*(v2 + 32))
  {
    v10 = **(v2 + 24);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = a1[1];
      *buf = 134217984;
      *&buf[4] = v11;
      _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I AssertionWithTimeout: Timer was NOT scheduled for %lld secs", buf, 0xCu);
    }
  }
}

void sub_1015F9248(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *aBlock, dispatch_object_t object, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015F92B8(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = **(v2 + 24);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(a1 + 40);
    v5 = 134217984;
    v6 = v4;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I AssertionWithTimeout: expired after %lld secs", &v5, 0xCu);
  }

  sub_1015F8E3C(v2);
}

__n128 sub_1015F93EC(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F55F90;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_1015F9424(uint64_t a1, unsigned __int8 *a2)
{
  v2 = *a2;
  v3 = *(a1 + 8);
  if (v2 == 1)
  {
    sub_1015F9010((a1 + 16));
  }

  if (*(v3 + 80))
  {

    sub_10000FFD0(v3 + 56, v2);
  }
}

uint64_t sub_1015F9484(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_1015F95CC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_release(v1);
  }

  if (v2)
  {
    operator delete();
  }

  _Unwind_Resume(exception_object);
}

void RoamingNetworkHandler::RoamingNetworkHandler(uint64_t a1, void *a2, int a3, NSObject **a4)
{
  v8 = (a1 + 8);
  v9 = "roam.nw.?";
  if (a3 == 2)
  {
    v9 = "roam.nw.2";
  }

  if (a3 == 1)
  {
    v10 = "roam.nw.1";
  }

  else
  {
    v10 = v9;
  }

  ctu::OsLogContext::OsLogContext(&v19, kCtLoggingSystemName, v10);
  *v8 = 0;
  v8[1] = 0;
  v11 = *a4;
  *(a1 + 24) = *a4;
  if (v11)
  {
    dispatch_retain(v11);
  }

  *(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger(v20, &v19);
  ctu::OsLogLogger::OsLogLogger((a1 + 40), v20);
  ctu::OsLogLogger::~OsLogLogger(v20);
  ctu::OsLogContext::~OsLogContext(&v19);
  *a1 = off_101F56010;
  v12 = a2[1];
  *(a1 + 48) = *a2;
  *(a1 + 56) = v12;
  if (v12)
  {
    atomic_fetch_add_explicit((v12 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 64) = a3;
  v13 = "RoamingHandler.?";
  if (a3 == 2)
  {
    v13 = "RoamingHandler.2";
  }

  if (a3 == 1)
  {
    v14 = "RoamingHandler.1";
  }

  else
  {
    v14 = v13;
  }

  sub_10000501C(&__p, v14);
  v15 = *(a1 + 24);
  v16 = v15;
  if (v15)
  {
    dispatch_retain(v15);
  }

  ctu::RestModule::RestModule();
  if (v16)
  {
    dispatch_release(v16);
  }

  if (v18 < 0)
  {
    operator delete(__p);
  }

  *(a1 + 88) = 0;
  *(a1 + 96) = 0;
  *(a1 + 104) = 0;
  RegisteredNetworkInfo::RegisteredNetworkInfo((a1 + 112));
  *(a1 + 920) = 0;
  *(a1 + 927) = 0;
  *(a1 + 936) = 0;
  *(a1 + 952) = 0u;
  *(a1 + 944) = a1 + 952;
  *(a1 + 968) = 0;
  *(a1 + 970) = 0;
  *(a1 + 972) = -1;
  *(a1 + 992) = 0;
  *(a1 + 1008) = 0;
  *(a1 + 1000) = 0;
  *(a1 + 976) = 0;
  *(a1 + 984) = 0;
  sub_1016212CC((a1 + 1016));
}

void sub_1015F985C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  v23 = *(v19 + 1040);
  if (v23)
  {
    sub_100004A34(v23);
  }

  v24 = *(v19 + 1024);
  if (v24)
  {
    sub_100004A34(v24);
  }

  if (*(v19 + 1015) < 0)
  {
    operator delete(*(v19 + 992));
  }

  sub_1015FC450(*v21);
  sub_10004543C(v19 + 112);
  v25 = *(v19 + 96);
  if (v25)
  {
    sub_100004A34(v25);
  }

  v26 = *(v19 + 80);
  if (v26)
  {
    sub_100004A34(v26);
  }

  v27 = *(v19 + 56);
  if (v27)
  {
    sub_100004A34(v27);
  }

  ctu::OsLogLogger::~OsLogLogger((v19 + 40));
  sub_1000C0544(v20);
  RoamingNetworkInterface::~RoamingNetworkInterface(v19);
  _Unwind_Resume(a1);
}

void sub_1015F9960(uint64_t a1)
{
  *a1 = off_101F56010;
  v2 = *(a1 + 1088);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(a1 + 1072);
  if (v3)
  {
    sub_100004A34(v3);
  }

  v4 = *(a1 + 1056);
  if (v4)
  {
    sub_100004A34(v4);
  }

  v5 = *(a1 + 1040);
  if (v5)
  {
    sub_100004A34(v5);
  }

  v6 = *(a1 + 1024);
  if (v6)
  {
    sub_100004A34(v6);
  }

  if (*(a1 + 1015) < 0)
  {
    operator delete(*(a1 + 992));
  }

  sub_1015FC450(*(a1 + 952));
  sub_10004543C(a1 + 112);
  v7 = *(a1 + 96);
  if (v7)
  {
    sub_100004A34(v7);
  }

  v8 = *(a1 + 80);
  if (v8)
  {
    sub_100004A34(v8);
  }

  v9 = *(a1 + 56);
  if (v9)
  {
    sub_100004A34(v9);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 40));
  sub_1000C0544((a1 + 8));

  RoamingNetworkInterface::~RoamingNetworkInterface(a1);
}

void sub_1015F9A44(uint64_t a1)
{
  sub_1015F9960(a1);

  operator delete();
}

void sub_1015F9A7C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v5 = *a3;
  v4 = a3[1];
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 8), 1uLL, memory_order_relaxed);
  }

  v6 = *(a1 + 96);
  *(a1 + 88) = v5;
  *(a1 + 96) = v4;
  if (v6)
  {
    sub_100004A34(v6);
  }

  if (*(a1 + 64) == 1)
  {
    v7 = "/cc/props/reg_net_info1";
  }

  else
  {
    v7 = "/cc/props/reg_net_info2";
  }

  if (*(a1 + 64) == 1)
  {
    v8 = "/cc/props/reg_rat_selection1";
  }

  else
  {
    v8 = "/cc/props/reg_rat_selection2";
  }

  *(a1 + 104) = v7;
  *(a1 + 920) = v8;
  sub_10000501C(&__p, v7);
  operator new();
}

void sub_1015F9CC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a11)
  {
    sub_100004A34(a11);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015F9D18(uint64_t a1, uint64_t a2)
{
  sub_101621F8C(*(a1 + 1016), a1 + 112);
  sub_1016236F0(*(a1 + 1032), (a1 + 112));
  if (*(a2 + 8) != *(a1 + 120))
  {
    RoamingNetworkHandler::submitOperatorRoamingAwdMetric(a1);
    v4 = *(*a1 + 120);

    v4(a1, 1);
  }
}

void sub_1015F9DB0(uint64_t a1)
{
  v2 = *(a1 + 928);
  if (*(a1 + 928))
  {
    v3 = *(a1 + 929);
    v4 = *(a1 + 984);
    if (v4 != v2)
    {
      v5 = *(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        ratSelectionAsStr(v15, v4);
        v6 = v18;
        v7 = *v15;
        ratSelectionAsStr(__p, v2);
        v8 = v15;
        if (v6 < 0)
        {
          v8 = v7;
        }

        if (v14 >= 0)
        {
          v9 = __p;
        }

        else
        {
          v9 = __p[0];
        }

        *buf = 136446466;
        v20 = v8;
        v21 = 2082;
        v22 = v9;
        _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Changing RAT selection from %{public}s to %{public}s", buf, 0x16u);
        if (v14 < 0)
        {
          operator delete(__p[0]);
        }

        if (v18 < 0)
        {
          operator delete(*v15);
        }
      }

      *(a1 + 984) = v2;
    }

    v10 = *(a1 + 985);
    if (v10 != v3)
    {
      v11 = *(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *v15 = 67109376;
        *&v15[4] = v10;
        v16 = 1024;
        v17 = v3;
        _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Internal RAT Selection in progress is changing from %d to %d", v15, 0xEu);
      }

      *(a1 + 985) = v3;
    }

    sub_10004111C(a1);
  }

  else
  {
    v12 = *(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *v15 = 0;
      _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I RAT selection is still unknown, cannot validate the state", v15, 2u);
    }
  }
}

void sub_1015F9F98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1015F9FBC(uint64_t a1)
{
  sub_1015FA02C(a1);
  sub_1016213F4(*(a1 + 1016));
  sub_101621D5C(*(a1 + 1032));
  sub_100DF0B2C(*(a1 + 1048));
  v2 = *(**(a1 + 1080) + 16);

  return v2();
}

const void **sub_1015FA02C(uint64_t a1)
{
  v2 = (a1 + 952);
  sub_1015FC450(*(a1 + 952));
  *(a1 + 944) = v2;
  *v2 = 0u;
  v43 = 0;
  ServiceMap = Registry::getServiceMap(*(a1 + 48));
  v4 = ServiceMap;
  if (v5 < 0)
  {
    v6 = (v5 & 0x7FFFFFFFFFFFFFFFLL);
    v7 = 5381;
    do
    {
      v5 = v7;
      v8 = *v6++;
      v7 = (33 * v7) ^ v8;
    }

    while (v8);
  }

  std::mutex::lock(ServiceMap);
  v35[0] = v5;
  v9 = sub_100009510(&v4[1].__m_.__sig, v35);
  if (v9)
  {
    v11 = v9[3];
    v10 = v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v10);
      v12 = 0;
      goto LABEL_9;
    }
  }

  else
  {
    v11 = 0;
  }

  std::mutex::unlock(v4);
  v10 = 0;
  v12 = 1;
LABEL_9:
  (*(*v11 + 80))(v33, v11, *(a1 + 64), 1, @"CDMAInternationalRoaming", 0, 0);
  sub_100010180(&v43, v33);
  sub_10000A1EC(v33);
  if ((v12 & 1) == 0)
  {
    sub_100004A34(v10);
  }

  if (v43)
  {
    Value = CFDictionaryGetValue(v43, @"OverrideNetworkMCC");
    v14 = Value;
    if (Value)
    {
      v15 = CFGetTypeID(Value);
      if (v15 == CFDictionaryGetTypeID())
      {
        Count = CFDictionaryGetCount(v14);
        keys = 0;
        v41 = 0;
        v42 = 0;
        sub_10007D780(&keys, Count);
        values = 0;
        v38 = 0;
        v39 = 0;
        sub_10007D780(&values, Count);
        CFDictionaryGetKeysAndValues(v14, keys, values);
        if (Count >= 1)
        {
          for (i = 0; i != Count; ++i)
          {
            v18 = keys[i];
            if (v18)
            {
              v19 = CFGetTypeID(keys[i]);
              if (v19 == CFStringGetTypeID())
              {
                v20 = v18;
              }

              else
              {
                v20 = 0;
              }
            }

            else
            {
              v20 = 0;
            }

            *v35 = 0u;
            v36 = 0u;
            v33[0] = 0;
            v33[1] = 0;
            *&v34 = 0;
            ctu::cf::assign();
            v44 = *v33;
            v45 = v34;
            MCC::MCC();
            if (SHIBYTE(v45) < 0)
            {
              operator delete(v44);
            }

            v21 = values[i];
            if (v21)
            {
              v22 = CFGetTypeID(values[i]);
              TypeID = CFArrayGetTypeID();
              if (v20)
              {
                if (v22 == TypeID)
                {
                  v24 = CFArrayGetCount(v21);
                  if (v24 >= 1)
                  {
                    for (j = 0; j != v24; ++j)
                    {
                      ValueAtIndex = CFArrayGetValueAtIndex(v21, j);
                      if (ValueAtIndex)
                      {
                        CFGetTypeID(ValueAtIndex);
                        CFStringGetTypeID();
                      }

                      *v33 = 0u;
                      v34 = 0u;
                      v44 = 0uLL;
                      v45 = 0;
                      ctu::cf::assign();
                      __p = v44;
                      v32 = HIBYTE(v45);
                      MCC::MCC();
                      if (v32 < 0)
                      {
                        operator delete(__p);
                      }

                      v27 = *v2;
                      if (!*v2)
                      {
                        goto LABEL_41;
                      }

                      v28 = v2;
                      while (1)
                      {
                        while (1)
                        {
                          v29 = v27;
                          if (!MCC::operator<())
                          {
                            break;
                          }

                          v27 = *v29;
                          v28 = v29;
                          if (!*v29)
                          {
                            goto LABEL_41;
                          }
                        }

                        if (!MCC::operator<())
                        {
                          break;
                        }

                        v28 = v29 + 1;
                        v27 = v29[1];
                        if (!v27)
                        {
                          goto LABEL_41;
                        }
                      }

                      if (!*v28)
                      {
LABEL_41:
                        operator new();
                      }

                      MCC::operator=();
                      if (SHIBYTE(v34) < 0)
                      {
                        operator delete(v33[1]);
                      }
                    }
                  }
                }
              }
            }

            if (SHIBYTE(v36) < 0)
            {
              operator delete(v35[1]);
            }
          }
        }

        if (values)
        {
          v38 = values;
          operator delete(values);
        }

        if (keys)
        {
          v41 = keys;
          operator delete(keys);
        }
      }
    }
  }

  return sub_10001021C(&v43);
}

void sub_1015FA49C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, void *a19, int a20, __int16 a21, char a22, char a23, int a24, __int16 a25, char a26, char a27, uint64_t a28, void *a29, uint64_t a30, int a31, __int16 a32, char a33, char a34, uint64_t a35, void *__p, uint64_t a37, uint64_t a38, void *a39, uint64_t a40)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a39)
  {
    operator delete(a39);
  }

  sub_10001021C((v40 - 120));
  _Unwind_Resume(a1);
}

const void **sub_1015FA5D8(const void **result, _BYTE *a2)
{
  if (*a2)
  {
    v2 = result;
    v3 = result[5];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *v4 = 0;
      _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle setup event received, checking for network overrides", v4, 2u);
    }

    return sub_1015FA02C(v2);
  }

  return result;
}

uint64_t sub_1015FA650(RoamingNetworkHandler *a1, uint64_t a2)
{
  v4 = *(a1 + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(a2 + 23) >= 0)
    {
      v5 = a2;
    }

    else
    {
      v5 = *a2;
    }

    if (*(a2 + 47) >= 0)
    {
      v6 = a2 + 24;
    }

    else
    {
      v6 = *(a2 + 24);
    }

    v8 = 136446466;
    v9 = v5;
    v10 = 2082;
    v11 = v6;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Mcc/Mnc updated: mcc=%{public}s mnc=%{public}s", &v8, 0x16u);
  }

  sub_100DF0FE8(*(a1 + 131), a2, a2 + 24);
  RoamingNetworkHandler::submitOperatorRoamingAwdMetric(a1);
  return (*(*a1 + 120))(a1, 1);
}

BOOL sub_1015FA784(char **a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    v3 = a3;
    v4 = a2;
    while (1)
    {
      v30 = 0;
      v31 = 0;
      v32 = 0;
      if (*(v4 + 48) == 1)
      {
        v6 = *(v4 + 47);
        if (v6 < 0)
        {
          v8 = *(v4 + 24);
          v9 = *(v4 + 32);
          if (v9 != 3 || (*v8 == 20033 ? (v10 = v8[2] == 89) : (v10 = 0), !v10))
          {
            sub_100005F2C(__p, v8, v9);
            goto LABEL_18;
          }
        }

        else if (v6 != 3 || (*(v4 + 24) == 20033 ? (v7 = *(v4 + 26) == 89) : (v7 = 0), !v7))
        {
          *__p = *(v4 + 24);
          v29 = *(v4 + 40);
          goto LABEL_18;
        }
      }

      sub_10000501C(__p, "");
LABEL_18:
      sub_100168A48(v4, __p, &v30);
      if (SHIBYTE(v29) < 0)
      {
        operator delete(__p[0]);
      }

      v11 = *(a1 + 23);
      if (v11 >= 0)
      {
        v12 = a1;
      }

      else
      {
        v12 = *a1;
      }

      if (v11 < 0)
      {
        v11 = a1[1];
      }

      v13 = SHIBYTE(v32);
      v14 = v30;
      if (v32 >= 0)
      {
        v15 = &v30;
      }

      else
      {
        v15 = v30;
      }

      if (v32 >= 0)
      {
        v16 = HIBYTE(v32);
      }

      else
      {
        v16 = v31;
      }

      if (v16)
      {
        v17 = &v11[v12];
        if (v11 >= v16)
        {
          v20 = *v15;
          v21 = v12;
          do
          {
            v22 = &v11[-v16];
            if (v22 == -1)
            {
              break;
            }

            v23 = memchr(v21, v20, (v22 + 1));
            if (!v23)
            {
              break;
            }

            v18 = v23;
            if (!memcmp(v23, v15, v16))
            {
              goto LABEL_42;
            }

            v21 = v18 + 1;
            v11 = (v17 - (v18 + 1));
          }

          while (v11 >= v16);
          v18 = v17;
LABEL_42:
          v3 = a3;
        }

        else
        {
          v18 = &v11[v12];
        }

        v19 = v18 != v17 && v18 == v12;
        if ((v13 & 0x80000000) == 0)
        {
          goto LABEL_51;
        }

LABEL_50:
        operator delete(v14);
        goto LABEL_51;
      }

      v19 = 1;
      if (SHIBYTE(v32) < 0)
      {
        goto LABEL_50;
      }

LABEL_51:
      v4 += 72;
      v25 = v4 == v3 || v19;
      if (v25)
      {
        return v19;
      }
    }
  }

  return 0;
}

void sub_1015FA970(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015FA9AC(uint64_t a1, unsigned int a2)
{
  ServiceMap = Registry::getServiceMap(*(a1 + 48));
  v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    v7 = (v6 & 0x7FFFFFFFFFFFFFFFLL);
    v8 = 5381;
    do
    {
      v6 = v8;
      v9 = *v7++;
      v8 = (33 * v8) ^ v9;
    }

    while (v9);
  }

  std::mutex::lock(ServiceMap);
  v16 = v6;
  v10 = sub_100009510(&v5[1].__m_.__sig, &v16);
  if (v10)
  {
    v12 = v10[3];
    v11 = v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v11);
      v13 = 0;
      if (!v12)
      {
        goto LABEL_7;
      }

LABEL_11:
      v15 = *(a1 + 64);
      v17[0] = off_101F562D0;
      v17[1] = a1;
      v18 = (a2 >> 4) & 1 | (a2 << 8);
      v21 = v17;
      v19 = 0;
      v20 = 0;
      (*(*v12 + 136))(v12, v15, v17);
      sub_100627050(v17);
      goto LABEL_12;
    }
  }

  else
  {
    v12 = 0;
  }

  std::mutex::unlock(v5);
  v11 = 0;
  v13 = 1;
  if (v12)
  {
    goto LABEL_11;
  }

LABEL_7:
  v14 = *(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v16) = 0;
    _os_log_impl(&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N Could not get Max Data Rate Manager to change RAT selection", &v16, 2u);
  }

LABEL_12:
  if ((v13 & 1) == 0)
  {
    sub_100004A34(v11);
  }
}

void sub_1015FAB74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100627050(va);
  if ((v3 & 1) == 0)
  {
    sub_100004A34(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1015FABA8(uint64_t a1, uint64_t a2)
{
  __src = 0;
  v26 = 0;
  v27 = 0;
  v4 = *(a1 + 944);
  v5 = (a1 + 952);
  if (v4 != (a1 + 952))
  {
    do
    {
      *__p = 0u;
      v31 = 0u;
      *buf = 0u;
      v29 = 0u;
      sub_1015FC230(buf, (v4 + 4));
      IntValue = MCC::getIntValue(buf);
      v7 = v26;
      if (v26 >= v27)
      {
        v9 = __src;
        v10 = v26 - __src;
        v11 = (v26 - __src) >> 1;
        if (v11 <= -2)
        {
          sub_1000CE3D4();
        }

        if (v27 - __src <= v11 + 1)
        {
          v12 = v11 + 1;
        }

        else
        {
          v12 = v27 - __src;
        }

        if (v27 - __src >= 0x7FFFFFFFFFFFFFFELL)
        {
          v13 = 0x7FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v13 = v12;
        }

        if (v13)
        {
          sub_1001B9700(&__src, v13);
        }

        *(2 * v11) = IntValue;
        v8 = (2 * v11 + 2);
        memcpy(0, v9, v10);
        v14 = __src;
        __src = 0;
        v26 = v8;
        v27 = 0;
        if (v14)
        {
          operator delete(v14);
        }
      }

      else
      {
        *v26 = IntValue;
        v8 = v7 + 1;
      }

      v26 = v8;
      if (SHIBYTE(v31) < 0)
      {
        operator delete(__p[1]);
      }

      if (SHIBYTE(v29) < 0)
      {
        operator delete(*&buf[8]);
      }

      v15 = v4[1];
      if (v15)
      {
        do
        {
          v16 = v15;
          v15 = *v15;
        }

        while (v15);
      }

      else
      {
        do
        {
          v16 = v4[2];
          v17 = *v16 == v4;
          v4 = v16;
        }

        while (!v17);
      }

      v4 = v16;
    }

    while (v16 != v5);
  }

  if (*(a2 + 24))
  {
    v18 = *(a1 + 40);
    v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
    v20 = __src;
    if (v19)
    {
      *buf = 134217984;
      *&buf[4] = (v26 - __src) >> 1;
      _os_log_impl(&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Calling back with %zu equivalent countries", buf, 0xCu);
      v20 = __src;
    }

    v22 = 0;
    v23 = 0;
    v24 = 0;
    sub_1001B964C(&v22, v20, v26, (v26 - v20) >> 1);
    v21 = *(a2 + 24);
    if (!v21)
    {
      sub_100022DB4();
    }

    (*(*v21 + 48))(v21, &v22);
    if (v22)
    {
      v23 = v22;
      operator delete(v22);
    }
  }

  if (__src)
  {
    v26 = __src;
    operator delete(__src);
  }
}

void sub_1015FAE38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015FAE84(uint64_t a1, unsigned int a2)
{
  v2 = *(a1 + 936);
  if (v2 != a2)
  {
    v5 = *(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136315394;
      v7 = sub_100072578(v2);
      v8 = 2080;
      v9 = sub_100072578(a2);
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Device type is changing from %s to %s", &v6, 0x16u);
    }

    *(a1 + 936) = a2;
    sub_10004111C(a1);
  }
}

void sub_1015FAFB4(uint64_t a1, NSObject **a2)
{
  v2 = *(a1 + 1080);
  v3 = *a2;
  group = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }

  (*(*v2 + 48))(v2, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group)
    {
      dispatch_release(group);
    }
  }
}

void sub_1015FB03C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1015FB088(uint64_t a1)
{
  if (*(a1 + 960))
  {
    v2 = *(a1 + 944);
    v3 = (a1 + 952);
    if (v2 != (a1 + 952))
    {
      do
      {
        *__p = 0u;
        v30 = 0u;
        memset(v28, 0, sizeof(v28));
        sub_1015FC230(v28, (v2 + 4));
        v4 = *(a1 + 40);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          IntValue = MCC::getIntValue(v28);
          v6 = MCC::getIntValue(__p);
          *buf = 67109376;
          v25 = IntValue;
          v26 = 1024;
          v27 = v6;
          _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I MCC %03d is overridden to %03d", buf, 0xEu);
        }

        if (SHIBYTE(v30) < 0)
        {
          operator delete(__p[1]);
        }

        if (v28[31] < 0)
        {
          operator delete(*&v28[8]);
        }

        v7 = v2[1];
        if (v7)
        {
          do
          {
            v8 = v7;
            v7 = *v7;
          }

          while (v7);
        }

        else
        {
          do
          {
            v8 = v2[2];
            v9 = *v8 == v2;
            v2 = v8;
          }

          while (!v9);
        }

        v2 = v8;
      }

      while (v8 != v3);
    }
  }

  else
  {
    v10 = *(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *v28 = 0;
      _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I There are no MCC overrides mentioned in carrier bundle", v28, 2u);
    }
  }

  v11 = *(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = asString();
    *v28 = 136315138;
    *&v28[4] = v12;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Data mode: %s", v28, 0xCu);
    v11 = *(a1 + 40);
  }

  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v13 = sub_100072578(*(a1 + 936));
    *v28 = 136315138;
    *&v28[4] = v13;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Device type: %s", v28, 0xCu);
    v11 = *(a1 + 40);
  }

  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v14 = asString();
    *v28 = 136315138;
    *&v28[4] = v14;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Roaming result: %s", v28, 0xCu);
    v11 = *(a1 + 40);
  }

  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v15 = asString();
    *v28 = 136315138;
    *&v28[4] = v15;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Roaming result (with overrides): %s", v28, 0xCu);
    v11 = *(a1 + 40);
  }

  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v16 = CSIBOOLAsString(*(a1 + 968));
    *v28 = 136315138;
    *&v28[4] = v16;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Is in home country: %s", v28, 0xCu);
    v11 = *(a1 + 40);
  }

  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v17 = CSIBOOLAsString(*(a1 + 969));
    *v28 = 136315138;
    *&v28[4] = v17;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Is in home country (definite): %s", v28, 0xCu);
    v11 = *(a1 + 40);
  }

  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v18 = CSIBOOLAsString(*(a1 + 970));
    *v28 = 136315138;
    *&v28[4] = v18;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Is in home country raw: %s", v28, 0xCu);
    v11 = *(a1 + 40);
  }

  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v19 = CSIBOOLAsString(*(a1 + 985));
    *v28 = 136315138;
    *&v28[4] = v19;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Internal RAT selection in progress: %s", v28, 0xCu);
    v11 = *(a1 + 40);
  }

  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v20 = (a1 + 992);
    if (*(a1 + 1015) < 0)
    {
      v20 = *v20;
    }

    *v28 = 136315138;
    *&v28[4] = v20;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I ISO network MCC: %s", v28, 0xCu);
    v11 = *(a1 + 40);
  }

  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *buf = (*(*a1 + 144))(a1);
    v21 = printers::asString();
    (*(**(a1 + 1080) + 40))(*(a1 + 1080));
    v22 = asString();
    *v28 = 136315394;
    *&v28[4] = v21;
    *&v28[12] = 2080;
    *&v28[14] = v22;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Data roaming setting: %s, reason: %s", v28, 0x16u);
  }

  sub_10130C99C(*(a1 + 1016));
  sub_10130C99C(*(a1 + 1032));
  return sub_10130C99C(*(a1 + 1048));
}

void sub_1015FB5E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1002FECBC(va);
  _Unwind_Resume(a1);
}

void sub_1015FB604(uint64_t a1, _BOOL4 a2)
{
  ServiceMap = Registry::getServiceMap(*(a1 + 48));
  v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    v7 = (v6 & 0x7FFFFFFFFFFFFFFFLL);
    v8 = 5381;
    do
    {
      v6 = v8;
      v9 = *v7++;
      v8 = (33 * v8) ^ v9;
    }

    while (v9);
  }

  std::mutex::lock(ServiceMap);
  v95.__r_.__value_.__r.__words[0] = v6;
  v10 = sub_100009510(&v5[1].__m_.__sig, &v95);
  if (!v10)
  {
    v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    v11 = 0;
    v13 = 1;
    if (!v12)
    {
      goto LABEL_140;
    }

    goto LABEL_10;
  }

  v12 = v10[3];
  v11 = v10[4];
  if (!v11)
  {
    goto LABEL_9;
  }

  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_100004A34(v11);
  v13 = 0;
  if (!v12)
  {
    goto LABEL_140;
  }

LABEL_10:
  if (a2 && (*(a1 + 120) & 0xFFFFFFFE) != 4)
  {
    goto LABEL_140;
  }

  v96[0] = 0;
  v14 = xpc_dictionary_create(0, 0, 0);
  v15 = v14;
  if (v14)
  {
    v96[0] = v14;
  }

  else
  {
    v15 = xpc_null_create();
    v96[0] = v15;
    if (!v15)
    {
      v16 = xpc_null_create();
      v15 = 0;
      goto LABEL_19;
    }
  }

  if (xpc_get_type(v15) == &_xpc_type_dictionary)
  {
    xpc_retain(v15);
    goto LABEL_20;
  }

  v16 = xpc_null_create();
LABEL_19:
  v96[0] = v16;
LABEL_20:
  xpc_release(v15);
  memset(&v95, 0, sizeof(v95));
  v93 = 0uLL;
  v94 = 0;
  v17 = analytics::simSlotAsSubsId();
  v91 = xpc_int64_create(v17);
  if (!v91)
  {
    v91 = xpc_null_create();
  }

  __p[0] = v96;
  __p[1] = "subs_id";
  sub_10000F688(__p, &v91, &v92);
  xpc_release(v92);
  v92 = 0;
  xpc_release(v91);
  v91 = 0;
  v18 = *(a1 + 120) - 1;
  if (v18 > 5)
  {
    v19 = "Unknown";
  }

  else
  {
    v19 = off_101F563C0[v18];
  }

  v89 = xpc_string_create(v19);
  if (!v89)
  {
    v89 = xpc_null_create();
  }

  __p[0] = v96;
  __p[1] = "registrationStatus";
  sub_10000F688(__p, &v89, &v90);
  xpc_release(v90);
  v90 = 0;
  xpc_release(v89);
  v89 = 0;
  v87 = xpc_BOOL_create(a2);
  if (!v87)
  {
    v87 = xpc_null_create();
  }

  __p[0] = v96;
  __p[1] = "isEventTrigger";
  sub_10000F688(__p, &v87, &v88);
  xpc_release(v88);
  v88 = 0;
  xpc_release(v87);
  v87 = 0;
  v20 = Registry::getServiceMap(*(a1 + 48));
  v21 = v20;
  if (v22 < 0)
  {
    v23 = (v22 & 0x7FFFFFFFFFFFFFFFLL);
    v24 = 5381;
    do
    {
      v22 = v24;
      v25 = *v23++;
      v24 = (33 * v24) ^ v25;
    }

    while (v25);
  }

  std::mutex::lock(v20);
  __p[0] = v22;
  v26 = sub_100009510(&v21[1].__m_.__sig, __p);
  if (v26)
  {
    v28 = v26[3];
    v27 = v26[4];
    if (v27)
    {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v21);
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v27);
      v29 = 0;
      goto LABEL_37;
    }
  }

  else
  {
    v28 = 0;
  }

  std::mutex::unlock(v21);
  v27 = 0;
  v29 = 1;
LABEL_37:
  v30 = *(a1 + 1048);
  if (v30[2].__r_.__value_.__s.__data_[16] == 1)
  {
    std::string::operator=(&v95, v30 + 3);
    v31 = *(a1 + 1048);
    v34 = *(v31 + 120);
    v32 = v31 + 120;
    v33 = v34;
    if (*(v32 + 23) >= 0)
    {
      v35 = v32;
    }

    else
    {
      v35 = v33;
    }

    object = xpc_string_create(v35);
    if (!object)
    {
      object = xpc_null_create();
    }

    __p[0] = v96;
    __p[1] = "carrierBundleID";
    sub_10000F688(__p, &object, &v86);
    xpc_release(v86);
    v86 = 0;
    xpc_release(object);
    object = 0;
    if (v28)
    {
      (*(*v28 + 16))(__p, v28, *(a1 + 64));
    }

    else
    {
      sub_10000501C(__p, "");
    }

    if (v82 >= 0)
    {
      v36 = __p;
    }

    else
    {
      v36 = __p[0];
    }

    v83 = xpc_string_create(v36);
    if (!v83)
    {
      v83 = xpc_null_create();
    }

    v74 = v96;
    v75 = "hmCarriername";
    sub_10000F688(&v74, &v83, &v84);
    xpc_release(v84);
    v84 = 0;
    xpc_release(v83);
    v83 = 0;
    if (SHIBYTE(v82) < 0)
    {
      operator delete(__p[0]);
    }
  }

  v37 = *(a1 + 1016);
  if (*(v37 + 64) == 1)
  {
    MCC::getStringValue(__p, (v37 + 72));
    if (SHIBYTE(v94) < 0)
    {
      operator delete(v93);
    }

    v93 = *__p;
    v94 = v82;
    __p[0] = 0;
    __p[1] = 0;
    v82 = 0;
    v38 = *(a1 + 1016);
    if (*(v38 + 159) < 0)
    {
      sub_100005F2C(__p, *(v38 + 136), *(v38 + 144));
    }

    else
    {
      *__p = *(v38 + 136);
      v82 = *(v38 + 152);
    }

    if (a2)
    {
      if ((SHIBYTE(v82) & 0x80000000) == 0)
      {
        if (!HIBYTE(v82))
        {
          goto LABEL_133;
        }

        goto LABEL_70;
      }

      if (!__p[1])
      {
        operator delete(__p[0]);
        if (v29)
        {
          goto LABEL_135;
        }

        goto LABEL_134;
      }
    }

    else if ((SHIBYTE(v82) & 0x80000000) == 0)
    {
LABEL_70:
      v41 = __p;
LABEL_73:
      v79 = xpc_string_create(v41);
      if (!v79)
      {
        v79 = xpc_null_create();
      }

      v74 = v96;
      v75 = "operatorBundleID";
      sub_10000F688(&v74, &v79, &v80);
      xpc_release(v80);
      v80 = 0;
      xpc_release(v79);
      v79 = 0;
      if (v28)
      {
        (*(*v28 + 24))(&v74, v28, *(a1 + 64));
      }

      else
      {
        sub_10000501C(&v74, "");
      }

      if (v76 >= 0)
      {
        v42 = &v74;
      }

      else
      {
        v42 = v74;
      }

      v77 = xpc_string_create(v42);
      if (!v77)
      {
        v77 = xpc_null_create();
      }

      v73[0] = v96;
      v73[1] = "opCarriername";
      sub_10000F688(v73, &v77, &v78);
      xpc_release(v78);
      v78 = 0;
      xpc_release(v77);
      v77 = 0;
      if (SHIBYTE(v76) < 0)
      {
        operator delete(v74);
      }

      v71 = xpc_int64_create(*(*(a1 + 1016) + 164));
      if (!v71)
      {
        v71 = xpc_null_create();
      }

      v74 = v96;
      v75 = "rat";
      sub_10000F688(&v74, &v71, &v72);
      xpc_release(v72);
      v72 = 0;
      xpc_release(v71);
      v71 = 0;
      v43 = mapRoamingResultToTriBOOL() == 1;
      v69 = xpc_BOOL_create(v43);
      if (!v69)
      {
        v69 = xpc_null_create();
      }

      v74 = v96;
      v75 = "isRoaming";
      sub_10000F688(&v74, &v69, &v70);
      xpc_release(v70);
      v70 = 0;
      xpc_release(v69);
      v69 = 0;
      if (SHIBYTE(v82) < 0)
      {
        operator delete(__p[0]);
      }

      goto LABEL_91;
    }

    v41 = __p[0];
    goto LABEL_73;
  }

  v39 = *(a1 + 1032);
  if (*(v39 + 64) == 1)
  {
    v67 = xpc_int64_create(*(v39 + 108));
    if (!v67)
    {
      v67 = xpc_null_create();
    }

    __p[0] = v96;
    __p[1] = "rat";
    sub_10000F688(__p, &v67, &v68);
    xpc_release(v68);
    v68 = 0;
    xpc_release(v67);
    v67 = 0;
    v40 = mapRoamingResultToTriBOOL() == 1;
    v65 = xpc_BOOL_create(v40);
    if (!v65)
    {
      v65 = xpc_null_create();
    }

    __p[0] = v96;
    __p[1] = "isRoaming";
    sub_10000F688(__p, &v65, &v66);
    xpc_release(v66);
    v66 = 0;
    xpc_release(v65);
    v65 = 0;
  }

LABEL_91:
  size = HIBYTE(v95.__r_.__value_.__r.__words[2]);
  if ((v95.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    size = v95.__r_.__value_.__l.__size_;
  }

  if (size)
  {
    v45 = HIBYTE(v94);
    if (v94 < 0)
    {
      v45 = *(&v93 + 1);
    }

    if (v45)
    {
      v46 = Registry::getServiceMap(*(a1 + 48));
      v47 = v46;
      if (v48 < 0)
      {
        v49 = (v48 & 0x7FFFFFFFFFFFFFFFLL);
        v50 = 5381;
        do
        {
          v48 = v50;
          v51 = *v49++;
          v50 = (33 * v50) ^ v51;
        }

        while (v51);
      }

      std::mutex::lock(v46);
      __p[0] = v48;
      v52 = sub_100009510(&v47[1].__m_.__sig, __p);
      if (v52)
      {
        v54 = v52[3];
        v53 = v52[4];
        if (v53)
        {
          atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v47);
          atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_100004A34(v53);
          v55 = 0;
          if (!v54)
          {
LABEL_125:
            if ((v55 & 1) == 0)
            {
              sub_100004A34(v53);
            }

            goto LABEL_127;
          }

LABEL_107:
          __p[0] = 0;
          __p[1] = 0;
          v82 = 0;
          (*(*v54 + 24))(__p, v54, &v95);
          v74 = 0;
          v75 = 0;
          v76 = 0;
          (*(*v54 + 24))(&v74, v54, &v93);
          v56 = HIBYTE(v82);
          if (v82 >= 0)
          {
            v57 = HIBYTE(v82);
          }

          else
          {
            v57 = __p[1];
          }

          v58 = HIBYTE(v76);
          v59 = SHIBYTE(v76);
          if (v76 < 0)
          {
            v58 = v75;
          }

          if (v57 == v58)
          {
            if (v82 >= 0)
            {
              v60 = __p;
            }

            else
            {
              v60 = __p[0];
            }

            if (v76 >= 0)
            {
              v61 = &v74;
            }

            else
            {
              v61 = v74;
            }

            LOBYTE(v54) = memcmp(v60, v61, v57) != 0;
            if ((v59 & 0x80000000) == 0)
            {
LABEL_123:
              if (v56 < 0)
              {
                operator delete(__p[0]);
              }

              goto LABEL_125;
            }
          }

          else
          {
            LOBYTE(v54) = 1;
            if ((SHIBYTE(v76) & 0x80000000) == 0)
            {
              goto LABEL_123;
            }
          }

          operator delete(v74);
          v56 = HIBYTE(v82);
          goto LABEL_123;
        }
      }

      else
      {
        v54 = 0;
      }

      std::mutex::unlock(v47);
      v53 = 0;
      v55 = 1;
      if (!v54)
      {
        goto LABEL_125;
      }

      goto LABEL_107;
    }
  }

  LOBYTE(v54) = 0;
LABEL_127:
  v63 = xpc_BOOL_create(v54);
  if (!v63)
  {
    v63 = xpc_null_create();
  }

  __p[0] = v96;
  __p[1] = "isInternationalRoaming";
  sub_10000F688(__p, &v63, &v64);
  xpc_release(v64);
  v64 = 0;
  xpc_release(v63);
  v62 = v96[0];
  v63 = 0;
  if (v96[0])
  {
    xpc_retain(v96[0]);
  }

  else
  {
    v62 = xpc_null_create();
  }

  (*(*v12 + 16))(v12, "commCenterRoamingInfo", &v62);
  xpc_release(v62);
  v62 = 0;
LABEL_133:
  if ((v29 & 1) == 0)
  {
LABEL_134:
    sub_100004A34(v27);
  }

LABEL_135:
  if (SHIBYTE(v94) < 0)
  {
    operator delete(v93);
  }

  if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v95.__r_.__value_.__l.__data_);
  }

  xpc_release(v96[0]);
LABEL_140:
  if ((v13 & 1) == 0)
  {
    sub_100004A34(v11);
  }
}

void sub_1015FC088(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *__p, uint64_t a30, int a31, __int16 a32, char a33, char a34)
{
  if ((v36 & 1) == 0)
  {
    sub_100004A34(v35);
  }

  if (*(v38 - 121) < 0)
  {
    operator delete(*(v38 - 144));
  }

  if (*(v38 - 97) < 0)
  {
    operator delete(*(v38 - 120));
  }

  xpc_release(*(v38 - 96));
  if ((v37 & 1) == 0)
  {
    sub_100004A34(v34);
  }

  _Unwind_Resume(a1);
}

MCC *sub_1015FC230(MCC *a1, uint64_t a2)
{
  MCC::MCC(a1, a2);
  MCC::MCC((v4 + 32), (a2 + 32));
  return a1;
}

void sub_1015FC268(_Unwind_Exception *exception_object)
{
  if (*(v1 + 31) < 0)
  {
    operator delete(*(v1 + 8));
  }

  _Unwind_Resume(exception_object);
}

void sub_1015FC350(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, sub_1015FC424);
  __cxa_rethrow();
}

void sub_1015FC390(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1015FC3E4(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1015FC424(uint64_t result)
{
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void sub_1015FC450(void *a1)
{
  if (a1)
  {
    sub_1015FC450(*a1);
    sub_1015FC450(a1[1]);
    sub_100B7713C((a1 + 4));

    operator delete(a1);
  }
}

__n128 sub_1015FC520(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F561D0;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_1015FC558(void *a1, const xpc::object *a2)
{
  v4 = a1[1];
  bzero(v9, 0x328uLL);
  RegisteredNetworkInfo::RegisteredNetworkInfo(v9, (v4 + 8));
  read_rest_value((v4 + 8), a2);
  v5 = a1[3];
  v6 = a1[4];
  v7 = (a1[2] + (v6 >> 1));
  if (v6)
  {
    v5 = *(*v7 + v5);
  }

  v5(v7, v9);
  return sub_10004543C(v9);
}

uint64_t sub_1015FC650(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1015FC718(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F56250;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_1015FC750(void *a1)
{
  read_rest_value();
  v2 = a1[3];
  v3 = a1[4];
  v4 = (a1[2] + (v3 >> 1));
  if (v3)
  {
    v2 = *(*v4 + v2);
  }

  return v2(v4);
}

uint64_t sub_1015FC7D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1015FC898(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F562D0;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  *(a2 + 22) = 0;
  *(a2 + 18) = 0;
  return result;
}

void sub_1015FC8D0(uint64_t a1)
{
  v1 = *(a1 + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_100004AA0(v2, (v1 + 8));
  operator new();
}

uint64_t sub_1015FC9CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_1015FCA18(uint64_t a1)
{
  v3 = a1;
  v1 = *a1;
  if ((*(*a1 + 8) & 1) == 0 && v1[10] == 1 && v1[9] == 1)
  {
    v2 = *(**a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Carrier and device are LTE capable, adding LTE", buf, 2u);
    }

    v1[11] |= 0x10u;
  }

  v4 = 0;
  RatSelectionType::RatSelectionType(&v4);
  RatSelectionType::setSelection(&v4, v1[11]);
  RatSelectionType::setPreferredSelection(&v4, v1[11]);
  RatSelectionType::setSimSlot();
  v8 = 0;
  sub_100DAF290(&v4, &v8);
  sub_10000501C(&__p, "/cc/requests/rat_selection");
  object = v8;
  v8 = xpc_null_create();
  *buf = off_101F56340;
  v10 = 0;
  v11 = buf;
  ctu::RestModule::sendRequest();
  sub_1000062D4(buf);
  xpc_release(object);
  object = 0;
  if (v7 < 0)
  {
    operator delete(__p);
  }

  xpc_release(v8);
  operator delete();
}

void sub_1015FCBC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, xpc_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, xpc_object_t a19, char a20)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1015FCCC4(uint64_t result, uint64_t a2)
{
  *a2 = off_101F56340;
  *(a2 + 8) = *(result + 8);
  return result;
}

void sub_1015FCCF4(uint64_t a1, xpc_object_t *a2)
{
  object = *a2;
  *a2 = xpc_null_create();
  xpc::dyn_cast_or_default(&object, 0, v2);
  xpc_release(object);
}

uint64_t sub_1015FCD60(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F563A0))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_1015FCDAC(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

uint64_t sub_1015FCE34(uint64_t a1, void *a2)
{
  v4 = ctu::OsLogLogger::OsLogLogger((a1 + 8), "com.apple.telephony", "wea");
  v7[0] = off_101E2B528;
  v7[1] = sub_1000A85BC;
  v7[3] = v7;
  *(a1 + 16) = 0;
  if ((capabilities::ct::supportsGemini(v4) & 1) == 0)
  {
    operator new();
  }

  if (!*(a1 + 16))
  {
    operator new();
  }

  sub_1000A8744(v7);
  *(a1 + 24) = 0;
  *(a1 + 32) = 0;
  *(a1 + 48) = 0;
  *a1 = off_101F56400;
  *(a1 + 40) = a1 + 48;
  *(a1 + 80) = 0;
  *(a1 + 72) = 0;
  *(a1 + 56) = 0;
  *(a1 + 64) = a1 + 72;
  v5 = a2[1];
  *(a1 + 88) = *a2;
  *(a1 + 96) = v5;
  if (v5)
  {
    atomic_fetch_add_explicit((v5 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 104) = 850045863;
  *(a1 + 112) = 0u;
  *(a1 + 128) = 0u;
  *(a1 + 144) = 0u;
  *(a1 + 160) = 0;
  return a1;
}

void sub_1015FD048(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000A8744(va);
  operator delete();
}

unint64_t sub_1015FD0C4(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 64);
  v3 = (a1 + 72);
  if (v2 != (a1 + 72))
  {
    do
    {
      v5 = v2[5];
      v6 = v2[6];
      while (v5 != v6)
      {
        v7 = *v5;
        if (v7 == sub_1000D3314(&v12, a2))
        {
          return (*(v5 + 2) << 32) | 1;
        }

        v5 += 2;
      }

      v8 = v2[1];
      if (v8)
      {
        do
        {
          v9 = v8;
          v8 = *v8;
        }

        while (v8);
      }

      else
      {
        do
        {
          v9 = v2[2];
          v10 = *v9 == v2;
          v2 = v9;
        }

        while (!v10);
      }

      v2 = v9;
    }

    while (v9 != v3);
  }

  return 0;
}

uint64_t sub_1015FD184(uint64_t a1, int a2, uint64_t a3)
{
  v4 = a1;
  v147 = a2;
  v5 = (*(**(a1 + 16) + 16))(*(a1 + 16));
  v142 = sub_1000D3314(buf, a3);
  v6 = (v4 + 88);
  ServiceMap = Registry::getServiceMap(*(v4 + 88));
  v8 = ServiceMap;
  v10 = v9;
  if (v9 < 0)
  {
    v11 = (v9 & 0x7FFFFFFFFFFFFFFFLL);
    v12 = 5381;
    do
    {
      v10 = v12;
      v13 = *v11++;
      v12 = (33 * v12) ^ v13;
    }

    while (v13);
  }

  std::mutex::lock(ServiceMap);
  *buf = v10;
  v14 = sub_100009510(&v8[1].__m_.__sig, buf);
  if (v14)
  {
    v15 = v14[3];
    v16 = v14[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v16);
      v17 = 0;
      goto LABEL_9;
    }
  }

  else
  {
    v15 = 0;
  }

  std::mutex::unlock(v8);
  v16 = 0;
  v17 = 1;
LABEL_9:
  v143 = (*(*v15 + 88))(v15);
  if ((v17 & 1) == 0)
  {
    sub_100004A34(v16);
  }

  v18 = Registry::getServiceMap(*v6);
  v19 = v18;
  v21 = v20;
  if (v20 < 0)
  {
    v22 = (v20 & 0x7FFFFFFFFFFFFFFFLL);
    v23 = 5381;
    do
    {
      v21 = v23;
      v24 = *v22++;
      v23 = (33 * v23) ^ v24;
    }

    while (v24);
  }

  std::mutex::lock(v18);
  *buf = v21;
  v25 = sub_100009510(&v19[1].__m_.__sig, buf);
  v140 = v20;
  if (v25)
  {
    v27 = v25[3];
    v26 = v25[4];
    if (v26)
    {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v19);
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v26);
      v28 = 0;
      goto LABEL_19;
    }
  }

  else
  {
    v27 = 0;
  }

  std::mutex::unlock(v19);
  v26 = 0;
  v28 = 1;
LABEL_19:
  v137 = v5;
  if (v27)
  {
    v152 = 0;
    (*(*v27 + 104))(buf, v27, v147, 2, &qword_101FCAE28, 0, 0);
    sub_10010B240(&v152, buf);
    v29 = sub_10000A1EC(buf);
    if (v152)
    {
      *buf = 0;
      v138 = v26;
      ctu::cf::assign(v29, v152, v30);
      v136 = v27;
      v31 = 60 * *buf;
      if (v31 >= 0xE10)
      {
        v31 = 3600;
      }

      v145 = v31;
      v133 = v28;
      v32 = Registry::getServiceMap(*v6);
      v33 = v32;
      if (v9 < 0)
      {
        v34 = (v9 & 0x7FFFFFFFFFFFFFFFLL);
        v35 = 5381;
        do
        {
          v9 = v35;
          v36 = *v34++;
          v35 = (33 * v35) ^ v36;
        }

        while (v36);
      }

      std::mutex::lock(v32);
      *buf = v9;
      v37 = sub_100009510(&v33[1].__m_.__sig, buf);
      if (v37)
      {
        v39 = v37[3];
        v38 = v37[4];
        if (v38)
        {
          atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v33);
          atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_100004A34(v38);
          v40 = 0;
          goto LABEL_37;
        }
      }

      else
      {
        v39 = 0;
      }

      std::mutex::unlock(v33);
      v38 = 0;
      v40 = 1;
LABEL_37:
      v144 = (*(*v39 + 88))(v39);
      if ((v40 & 1) == 0)
      {
        sub_100004A34(v38);
      }

      subscriber::makeSimSlotRange();
      v132 = (v4 + 88);
      v43 = v149;
      v44 = v150;
      if (v149 != v150)
      {
        v45 = v151;
        do
        {
          if (v151(*v43))
          {
            break;
          }

          ++v43;
        }

        while (v43 != v150);
        v46 = v150;
        if (v43 != v150)
        {
          v47 = (v4 + 72);
          v134 = (v4 + 72);
          v135 = v150;
          do
          {
            v48 = *v43;
            v148 = *v43;
            v49 = *v47;
            if (*v47)
            {
              v50 = v47;
              do
              {
                if (*(v49 + 32) >= v48)
                {
                  v50 = v49;
                }

                v49 = *(v49 + 8 * (*(v49 + 32) < v48));
              }

              while (v49);
              if (v50 != v47 && v48 >= *(v50 + 8))
              {
                *buf = &v148;
                v141 = sub_1015FF210(v4 + 64, v48);
                *buf = &v148;
                v51 = sub_1015FF210(v4 + 64, v148)[5];
                *buf = &v148;
                v52 = sub_1015FF210(v4 + 64, v148)[6];
                if (v51 != v52)
                {
                  while (1)
                  {
                    v53 = *v51;
                    v54 = v51[2];
                    v55 = *(v4 + 8);
                    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
                    {
                      *buf = 67109632;
                      *&buf[4] = v144;
                      *&buf[8] = 1024;
                      *&buf[10] = v54;
                      *&buf[14] = 2048;
                      *&buf[16] = v145;
                      _os_log_impl(&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I now: [%d] alertMessage.fTimestamp [%d], window = %lld", buf, 0x18u);
                    }

                    if (v144 - v54 >= v145)
                    {
                      break;
                    }

                    v51 += 4;
                    if (v51 == v52)
                    {
                      v51 = v52;
                      goto LABEL_70;
                    }
                  }

                  v56 = *(v4 + 8);
                  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
                  {
                    *buf = 134217984;
                    *&buf[4] = v53;
                    _os_log_impl(&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Erasing content: [%lx]", buf, 0xCu);
                  }

                  if (v51 != v52)
                  {
                    for (i = (v51 + 4); i != v52; i += 16)
                    {
                      v58 = *i;
                      v59 = v4;
                      v60 = *(i + 2);
                      v61 = v59;
                      v62 = *(v59 + 8);
                      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
                      {
                        *buf = 67109632;
                        *&buf[4] = v144;
                        *&buf[8] = 1024;
                        *&buf[10] = v60;
                        *&buf[14] = 2048;
                        *&buf[16] = v145;
                        _os_log_impl(&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I now: [%d] alertMessage.fTimestamp [%d], window = %lld", buf, 0x18u);
                      }

                      if (v145 <= (v144 - v60))
                      {
                        v4 = v61;
                        v64 = *(v61 + 8);
                        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
                        {
                          *buf = 134217984;
                          *&buf[4] = v58;
                          _os_log_impl(&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I Erasing content: [%lx]", buf, 0xCu);
                        }
                      }

                      else
                      {
                        v63 = *i;
                        v51[2] = *(i + 2);
                        *v51 = v63;
                        v51 += 4;
                        v4 = v61;
                      }
                    }
                  }
                }

LABEL_70:
                *buf = &v148;
                v65 = sub_1015FF210(v4 + 64, v148);
                v47 = v134;
                v46 = v135;
                if (v51 != v65[6])
                {
                  v66 = v65[6];
                  v67 = v141[6];
                  v68 = v67 - v66;
                  if (v67 != v66)
                  {
                    memmove(v51, v66, v68 - 4);
                  }

                  v141[6] = v51 + v68;
                }
              }
            }

            do
            {
              ++v43;
            }

            while (v43 != v44 && (v45(*v43) & 1) == 0);
          }

          while (v43 != v46);
        }
      }

      (*(*v136 + 104))(buf);
      v69 = *buf;
      LOBYTE(v149) = 0;
      v70 = v137;
      v6 = v132;
      if (*buf)
      {
        v71 = CFGetTypeID(*buf);
        if (v71 == CFBooleanGetTypeID())
        {
          ctu::cf::assign(&v149, v69, v72);
        }
      }

      v73 = v149;
      sub_10000A1EC(buf);
      v26 = v138;
      v28 = v133;
      (*(*v136 + 104))(buf);
      v74 = *buf;
      LOBYTE(v149) = 0;
      if (*buf)
      {
        v75 = CFGetTypeID(*buf);
        if (v75 == CFBooleanGetTypeID())
        {
          ctu::cf::assign(&v149, v74, v76);
        }
      }

      v77 = v149;
      sub_10000A1EC(buf);
      if (v73)
      {
        v78 = *(v4 + 72);
        if (v78)
        {
          v79 = v4 + 72;
          do
          {
            if (*(v78 + 32) >= v147)
            {
              v79 = v78;
            }

            v78 = *(v78 + 8 * (*(v78 + 32) < v147));
          }

          while (v78);
          if (v79 != v4 + 72 && v147 >= *(v79 + 32))
          {
            v92 = *(v79 + 40);
            v93 = *(v79 + 48);
            while (v92 != v93)
            {
              v94 = *(v92 + 8);
              if (v145 >= v143 - v94 && v142 == *v92)
              {
                v131 = *v137;
                if (!os_log_type_enabled(*v137, OS_LOG_TYPE_DEFAULT))
                {
                  v146 = 1;
                  goto LABEL_132;
                }

                *buf = 136446978;
                *&buf[4] = "intra-sim";
                *&buf[12] = 1024;
                *&buf[14] = v143;
                *&buf[18] = 1024;
                *&buf[20] = v94;
                v154 = 2048;
                v155 = v145;
                _os_log_impl(&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, "#I Alert filtered : [content based: %{public}s] currentTS = %u matchedTS = %u window = %lld", buf, 0x22u);
                sub_100029A48(&v152);
                v146 = 1;
                if ((v133 & 1) == 0)
                {
                  goto LABEL_133;
                }

                goto LABEL_134;
              }

              v92 += 16;
            }
          }
        }

        v80 = *v137;
        if (os_log_type_enabled(*v137, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 0;
          _os_log_impl(&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I Alert not filtered : [content based: intra-sim]", buf, 2u);
        }
      }

      if (v77)
      {
        subscriber::makeSimSlotRange();
        v81 = v149;
        v82 = v150;
        if (v149 == v150)
        {
          v146 = 0;
        }

        else
        {
          v83 = v151;
          do
          {
            if (v83(*v81))
            {
              break;
            }

            ++v81;
          }

          while (v81 != v82);
          v84 = v150;
          if (v81 == v150)
          {
            v146 = 0;
            v70 = v137;
            v26 = v138;
          }

          else
          {
            v85 = (v4 + 72);
            do
            {
              v86 = *v81;
              if (*v81 != v147)
              {
                v87 = *v85;
                if (*v85)
                {
                  v88 = v4 + 72;
                  do
                  {
                    if (*(v87 + 32) >= v86)
                    {
                      v88 = v87;
                    }

                    v87 = *(v87 + 8 * (*(v87 + 32) < v86));
                  }

                  while (v87);
                  if (v88 != v85 && v86 >= *(v88 + 32))
                  {
                    v89 = *(v88 + 40);
                    v90 = *(v88 + 48);
                    while (v89 != v90)
                    {
                      v91 = *(v89 + 8);
                      if (v145 >= v143 - v91 && v142 == *v89)
                      {
                        v70 = v137;
                        v95 = *v137;
                        if (os_log_type_enabled(*v137, OS_LOG_TYPE_DEFAULT))
                        {
                          *buf = 136446978;
                          *&buf[4] = "inter-sim";
                          *&buf[12] = 1024;
                          *&buf[14] = v143;
                          *&buf[18] = 1024;
                          *&buf[20] = v91;
                          v154 = 2048;
                          v155 = v145;
                          _os_log_impl(&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "#I Alert filtered : [content based: %{public}s] currentTS = %u matchedTS = %u window = %lld", buf, 0x22u);
                          v95 = *v137;
                        }

                        v26 = v138;
                        v28 = v133;
                        if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
                        {
                          v96 = subscriber::asString();
                          *buf = 136315138;
                          *&buf[4] = v96;
                          _os_log_impl(&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "#I Duplicated from slot: %s", buf, 0xCu);
                        }

                        v146 = 1;
                        goto LABEL_130;
                      }

                      v89 += 16;
                    }
                  }
                }
              }

              do
              {
                ++v81;
              }

              while (v81 != v82 && (v83(*v81) & 1) == 0);
            }

            while (v81 != v84);
            v146 = 0;
            v70 = v137;
            v26 = v138;
            v28 = v133;
          }
        }

LABEL_130:
        v97 = *v70;
        if (os_log_type_enabled(*v70, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 0;
          _os_log_impl(&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "#I Alert not filtered : [content based: inter-sim]", buf, 2u);
        }

LABEL_132:
        sub_100029A48(&v152);
        if (v28)
        {
          goto LABEL_134;
        }

        goto LABEL_133;
      }

LABEL_117:
      v146 = 0;
      goto LABEL_132;
    }

    v42 = *v5;
    if (!os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_117;
    }

    *buf = 0;
    _os_log_impl(&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Content based duplicate detection disabled", buf, 2u);
    sub_100029A48(&v152);
  }

  else
  {
    v41 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "Carrier settings interface missing", buf, 2u);
    }
  }

  v146 = 0;
  if ((v28 & 1) == 0)
  {
LABEL_133:
    sub_100004A34(v26);
  }

LABEL_134:
  v98 = Registry::getServiceMap(*v6);
  v99 = v140;
  v100 = v98;
  if (v140 < 0)
  {
    v101 = (v140 & 0x7FFFFFFFFFFFFFFFLL);
    v102 = 5381;
    do
    {
      v99 = v102;
      v103 = *v101++;
      v102 = (33 * v102) ^ v103;
    }

    while (v103);
  }

  std::mutex::lock(v98);
  *buf = v99;
  v104 = sub_100009510(&v100[1].__m_.__sig, buf);
  if (!v104)
  {
    v105 = 0;
LABEL_144:
    std::mutex::unlock(v100);
    v106 = 0;
    v107 = 1;
    if (!v105)
    {
      goto LABEL_140;
    }

LABEL_145:
    v139 = v106;
    subscriber::makeSimSlotRange();
    v109 = v4;
    v110 = *buf;
    v111 = *&buf[8];
    if (*buf == *&buf[8])
    {
      goto LABEL_157;
    }

    v112 = *&buf[16];
    do
    {
      if (v112(*v110))
      {
        break;
      }

      ++v110;
    }

    while (v110 != v111);
    v113 = *&buf[8];
    if (v110 == *&buf[8])
    {
LABEL_157:
      v116 = 0;
      if (v107)
      {
        goto LABEL_155;
      }
    }

    else
    {
      do
      {
        v114 = *v110;
        v149 = 0;
        (*(*v105 + 104))(&v152, v105, v114, 2, &qword_101FCAE28, 0, 0);
        sub_10010B240(&v149, &v152);
        sub_10000A1EC(&v152);
        v115 = v149;
        v116 = v149 != 0;
        sub_100029A48(&v149);
        if (v115)
        {
          break;
        }

        do
        {
          ++v110;
        }

        while (v110 != v111 && (v112(*v110) & 1) == 0);
      }

      while (v110 != v113);
      if (v107)
      {
LABEL_155:
        if (!v116)
        {
          return v146;
        }

LABEL_159:
        v117 = *v137;
        if (os_log_type_enabled(*v137, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 134217984;
          *&buf[4] = v142;
          _os_log_impl(&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "#I Storing WEA (for content based filtering): %lx", buf, 0xCu);
        }

        *buf = &v147;
        v118 = sub_1015FF210(v109 + 64, v147);
        v119 = v118;
        v120 = v118[6];
        v121 = v118[7];
        if (v120 >= v121)
        {
          v123 = v118[5];
          v124 = v120 - v123;
          v125 = (v120 - v123) >> 4;
          v126 = v125 + 1;
          if ((v125 + 1) >> 60)
          {
            sub_1000CE3D4();
          }

          v127 = v121 - v123;
          if (v127 >> 3 > v126)
          {
            v126 = v127 >> 3;
          }

          if (v127 >= 0x7FFFFFFFFFFFFFF0)
          {
            v128 = 0xFFFFFFFFFFFFFFFLL;
          }

          else
          {
            v128 = v126;
          }

          if (v128)
          {
            if (!(v128 >> 60))
            {
              operator new();
            }

            sub_100013D10();
          }

          v129 = (16 * v125);
          *v129 = v142;
          v129[1] = v143;
          v122 = 16 * v125 + 16;
          memcpy(0, v123, v124);
          v119[5] = 0;
          v119[6] = v122;
          v119[7] = 0;
          if (v123)
          {
            operator delete(v123);
          }
        }

        else
        {
          *v120 = v142;
          v122 = (v120 + 2);
          v120[1] = v143;
        }

        v119[6] = v122;
        return v146;
      }
    }

    sub_100004A34(v139);
    if (!v116)
    {
      return v146;
    }

    goto LABEL_159;
  }

  v105 = v104[3];
  v106 = v104[4];
  if (!v106)
  {
    goto LABEL_144;
  }

  atomic_fetch_add_explicit(&v106->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v100);
  atomic_fetch_add_explicit(&v106->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_100004A34(v106);
  v107 = 0;
  if (v105)
  {
    goto LABEL_145;
  }

LABEL_140:
  v108 = *(v4 + 8);
  if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
  {
    *buf = 0;
    _os_log_error_impl(&_mh_execute_header, v108, OS_LOG_TYPE_ERROR, "Carrier settings interface missing", buf, 2u);
    if (v107)
    {
      return v146;
    }

    goto LABEL_142;
  }

  if ((v107 & 1) == 0)
  {
LABEL_142:
    sub_100004A34(v106);
  }

  return v146;
}

void sub_1015FE0FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  sub_100029A48((v19 - 152));
  if ((v18 & 1) == 0)
  {
    sub_100004A34(a18);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1015FE1FC(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  v88 = a2;
  v84 = (*(**(a1 + 16) + 16))(*(a1 + 16));
  std::mutex::lock((a1 + 104));
  v89 = a2;
  v9 = (*(**(a1 + 16) + 16))(*(a1 + 16), a2);
  ServiceMap = Registry::getServiceMap(*(a1 + 88));
  v11 = ServiceMap;
  v13 = v12;
  if (v12 < 0)
  {
    v14 = (v12 & 0x7FFFFFFFFFFFFFFFLL);
    v15 = 5381;
    do
    {
      v13 = v15;
      v16 = *v14++;
      v15 = (33 * v15) ^ v16;
    }

    while (v16);
  }

  std::mutex::lock(ServiceMap);
  __src = v13;
  v17 = sub_100009510(&v11[1].__m_.__sig, &__src);
  v87 = a3;
  v85 = a5;
  if (v17)
  {
    v19 = v17[3];
    v18 = v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v18);
      v20 = 0;
      goto LABEL_9;
    }
  }

  else
  {
    v19 = 0;
  }

  std::mutex::unlock(v11);
  v18 = 0;
  v20 = 1;
LABEL_9:
  v21 = (*(*v19 + 88))(v19);
  if ((v20 & 1) == 0)
  {
    sub_100004A34(v18);
  }

  __src = 0;
  v94 = 0;
  v95 = 0;
  *buf = &v89;
  v22 = sub_101476DE4(a1 + 40, v89);
  v24 = v22[5];
  for (i = v22[6]; v24 != i; v24 += 4)
  {
    if ((sub_1015FEAD0(a1, v89, v21, v24[2]) & 1) == 0)
    {
      v25 = *v9;
      if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
      {
        v26 = *v24;
        v27 = v24[2];
        *buf = 67109376;
        *&buf[4] = v26;
        v91 = 1024;
        v92 = v27;
        _os_log_impl(&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Message with ID: %u and timestamp: %u is not valid anymore, erasing it", buf, 0xEu);
      }

      v28 = v94;
      if (v94 >= v95)
      {
        v30 = __src;
        v31 = v94 - __src;
        v32 = (v94 - __src) >> 2;
        v33 = v32 + 1;
        if ((v32 + 1) >> 62)
        {
          sub_1000CE3D4();
        }

        v34 = v95 - __src;
        if ((v95 - __src) >> 1 > v33)
        {
          v33 = v34 >> 1;
        }

        if (v34 >= 0x7FFFFFFFFFFFFFFCLL)
        {
          v35 = 0x3FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v35 = v33;
        }

        if (v35)
        {
          sub_100016740(&__src, v35);
        }

        *(4 * v32) = *v24;
        v29 = 4 * v32 + 4;
        memcpy(0, v30, v31);
        v36 = __src;
        __src = 0;
        v94 = v29;
        v95 = 0;
        if (v36)
        {
          operator delete(v36);
        }
      }

      else
      {
        *v94 = *v24;
        v29 = (v28 + 4);
      }

      v94 = v29;
    }
  }

  v38 = __src;
  v37 = v94;
  if (__src != v94)
  {
    do
    {
      *buf = &v89;
      v39 = sub_101476DE4(a1 + 40, v89)[5];
      *buf = &v89;
      v40 = sub_101476DE4(a1 + 40, v89);
      v41 = v40[6];
      if (v39 != v41)
      {
        while (*v39 != *v38)
        {
          v39 += 16;
          if (v39 == v41)
          {
            v39 = v40[6];
            break;
          }
        }
      }

      *buf = &v89;
      v42 = sub_101476DE4(a1 + 40, v89);
      v43 = v42[6];
      v44 = v43 - (v39 + 16);
      if (v43 != v39 + 16)
      {
        memmove(v39, v39 + 16, v43 - (v39 + 16));
      }

      v42[6] = &v39[v44];
      v38 += 4;
    }

    while (v38 != v37);
    v38 = __src;
  }

  if (v38)
  {
    v94 = v38;
    operator delete(v38);
  }

  __src = &v88;
  v45 = sub_101476DE4(a1 + 40, v88);
  for (j = v45[5]; j != v45[6]; j += 4)
  {
    v47 = j[1];
    if (v87 == 1 && j[3] == 1)
    {
      if (v47 == v85 && *j == a4)
      {
        v72 = *v84;
        if (os_log_type_enabled(*v84, OS_LOG_TYPE_DEFAULT))
        {
          v74 = j[2];
          LODWORD(__src) = 67109632;
          HIDWORD(__src) = a4;
          LOWORD(v94) = 1024;
          *(&v94 + 2) = v85;
          HIWORD(v94) = 1024;
          LODWORD(v95) = v74;
          v75 = "#I CMAS Message ID: %u, Serial No: %u has been processed before on 3GPP at %u";
          v76 = v72;
          v77 = 20;
          goto LABEL_78;
        }

        goto LABEL_79;
      }
    }

    else if (v47 == v85)
    {
      v78 = *v84;
      if (os_log_type_enabled(*v84, OS_LOG_TYPE_DEFAULT))
      {
        v79 = j[2];
        LODWORD(__src) = 67109376;
        HIDWORD(__src) = v85;
        LOWORD(v94) = 1024;
        *(&v94 + 2) = v79;
        v75 = "#I CMAS Message with Message ID: %u has been processed before on 3GPP2 at %u";
        v76 = v78;
        v77 = 14;
LABEL_78:
        _os_log_impl(&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, v75, &__src, v77);
      }

LABEL_79:
      v80 = 0;
      goto LABEL_83;
    }
  }

  v49 = Registry::getServiceMap(*(a1 + 88));
  v50 = v49;
  if (v12 < 0)
  {
    v51 = (v12 & 0x7FFFFFFFFFFFFFFFLL);
    v52 = 5381;
    do
    {
      v12 = v52;
      v53 = *v51++;
      v52 = (33 * v52) ^ v53;
    }

    while (v53);
  }

  std::mutex::lock(v49);
  __src = v12;
  v54 = sub_100009510(&v50[1].__m_.__sig, &__src);
  if (!v54)
  {
    v56 = 0;
    goto LABEL_59;
  }

  v56 = v54[3];
  v55 = v54[4];
  if (!v55)
  {
LABEL_59:
    std::mutex::unlock(v50);
    v55 = 0;
    v57 = 1;
    goto LABEL_60;
  }

  atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v50);
  atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_100004A34(v55);
  v57 = 0;
LABEL_60:
  v58 = (*(*v56 + 88))(v56);
  if ((v57 & 1) == 0)
  {
    sub_100004A34(v55);
  }

  v59 = *v84;
  if (os_log_type_enabled(*v84, OS_LOG_TYPE_DEFAULT))
  {
    v60 = sms::asString();
    LODWORD(__src) = 67109634;
    HIDWORD(__src) = a4;
    LOWORD(v94) = 1024;
    *(&v94 + 2) = v85;
    HIWORD(v94) = 2080;
    v95 = v60;
    _os_log_impl(&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I Storing WEA (for inter-tech duplicate detection): [category %u uniqueId: %u type %s]", &__src, 0x18u);
  }

  __src = &v88;
  v61 = sub_101476DE4(a1 + 40, v88);
  v62 = v61;
  v63 = v61[6];
  v64 = v61[7];
  if (v63 >= v64)
  {
    v66 = v61[5];
    v67 = v63 - v66;
    v68 = (v63 - v66) >> 4;
    v69 = v68 + 1;
    if ((v68 + 1) >> 60)
    {
      sub_1000CE3D4();
    }

    v70 = v64 - v66;
    if (v70 >> 3 > v69)
    {
      v69 = v70 >> 3;
    }

    if (v70 >= 0x7FFFFFFFFFFFFFF0)
    {
      v71 = 0xFFFFFFFFFFFFFFFLL;
    }

    else
    {
      v71 = v69;
    }

    if (v71)
    {
      sub_100F7E530(v71);
    }

    v81 = (16 * v68);
    *v81 = a4;
    v81[1] = v85;
    v81[2] = v58;
    v81[3] = v87;
    v65 = 16 * v68 + 16;
    memcpy(0, v66, v67);
    v82 = v62[5];
    v62[5] = 0;
    v62[6] = v65;
    v62[7] = 0;
    if (v82)
    {
      operator delete(v82);
    }
  }

  else
  {
    *v63 = a4;
    *(v63 + 1) = v85;
    v65 = (v63 + 16);
    *(v63 + 2) = v58;
    *(v63 + 3) = v87;
  }

  v62[6] = v65;
  v80 = 1;
LABEL_83:
  std::mutex::unlock((a1 + 104));
  return v80;
}

void sub_1015FE9CC(uint64_t a1, uint64_t a2)
{
  v7 = a2;
  std::mutex::lock((a1 + 104));
  v4 = *(*(**(a1 + 16) + 16))(*(a1 + 16), a2);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Invalidating all the stored message IDs", buf, 2u);
  }

  *buf = &v7;
  v5 = sub_101476DE4(a1 + 40, a2);
  v5[6] = v5[5];
  *buf = &v7;
  v6 = sub_1015FF210(a1 + 64, v7);
  v6[6] = v6[5];
  std::mutex::unlock((a1 + 104));
}

uint64_t sub_1015FEAD0(uint64_t a1, uint64_t a2, int a3, int a4)
{
  v8 = (*(**(a1 + 16) + 16))(*(a1 + 16));
  v9 = v8;
  v10 = (a3 - a4);
  if (v10 >> 7 < 0x2A3)
  {
    theDict = 0;
    ServiceMap = Registry::getServiceMap(*(a1 + 88));
    v14 = ServiceMap;
    if (v15 < 0)
    {
      v16 = (v15 & 0x7FFFFFFFFFFFFFFFLL);
      v17 = 5381;
      do
      {
        v15 = v17;
        v18 = *v16++;
        v17 = (33 * v17) ^ v18;
      }

      while (v18);
    }

    std::mutex::lock(ServiceMap);
    *buf = v15;
    v19 = sub_100009510(&v14[1].__m_.__sig, buf);
    if (v19)
    {
      v21 = v19[3];
      v20 = v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v20);
        v22 = 0;
        goto LABEL_12;
      }
    }

    else
    {
      v21 = 0;
    }

    std::mutex::unlock(v14);
    v20 = 0;
    v22 = 1;
LABEL_12:
    (*(*v21 + 96))(&v33, v21, a2, 2, @"CellBroadcast", 0, 0);
    sub_100010180(&theDict, &v33);
    sub_10000A1EC(&v33);
    if ((v22 & 1) == 0)
    {
      sub_100004A34(v20);
    }

    if (!theDict)
    {
      v29 = *v9;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *buf = 0;
        _os_log_error_impl(&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Failed to fetch CellBroadcast dict", buf, 2u);
      }

      v12 = 1;
      goto LABEL_30;
    }

    v33 = 0;
    *buf = CFDictionaryGetValue(theDict, @"MessageValidityPeriod");
    sub_100010180(&v33, buf);
    if (!v33)
    {
      goto LABEL_28;
    }

    Value = CFDictionaryGetValue(v33, @"TimeLimit");
    v24 = Value;
    if (Value && (v25 = CFGetTypeID(Value), v25 == CFNumberGetTypeID()))
    {
      valuePtr = 0;
      if (CFNumberGetValue(v24, kCFNumberLongType, &valuePtr))
      {
        v26 = valuePtr;
        if (60 * valuePtr < v10)
        {
          v27 = *v9;
          v28 = os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
          v12 = 0;
          if (v28)
          {
            *buf = 134217984;
            *&buf[4] = v26;
            _os_log_impl(&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Message is older than %ld minutes, not valid anymore", buf, 0xCu);
            v12 = 0;
          }

          goto LABEL_29;
        }

LABEL_28:
        v12 = 1;
LABEL_29:
        sub_10001021C(&v33);
LABEL_30:
        sub_10001021C(&theDict);
        return v12;
      }
    }

    else
    {
      valuePtr = 0;
    }

    v30 = *v9;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I No Time limit found in validity period dictionary, marking valid", buf, 2u);
    }

    goto LABEL_28;
  }

  v11 = *v8;
  v12 = 0;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 134217984;
    *&buf[4] = 24;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Message is older than %ld hours, not valid anymore", buf, 0xCu);
    return 0;
  }

  return v12;
}

void sub_1015FEE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  sub_10001021C(va);
  sub_10001021C(va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1015FEEB4(uint64_t a1)
{
  *a1 = off_101F56400;
  std::mutex::~mutex((a1 + 104));
  v2 = *(a1 + 96);
  if (v2)
  {
    sub_100004A34(v2);
  }

  sub_1015FF02C(*(a1 + 72));
  sub_1015FF02C(*(a1 + 48));
  CellBroadcastMessageStoreInterface::~CellBroadcastMessageStoreInterface(a1);
  v3 = *(a1 + 32);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  v4 = *(a1 + 16);
  *(a1 + 16) = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 8));
  return a1;
}

void sub_1015FEF60(uint64_t a1)
{
  *a1 = off_101F56400;
  std::mutex::~mutex((a1 + 104));
  v2 = *(a1 + 96);
  if (v2)
  {
    sub_100004A34(v2);
  }

  sub_1015FF02C(*(a1 + 72));
  sub_1015FF02C(*(a1 + 48));
  CellBroadcastMessageStoreInterface::~CellBroadcastMessageStoreInterface(a1);
  v3 = *(a1 + 32);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  v4 = *(a1 + 16);
  *(a1 + 16) = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 8));

  operator delete();
}

void sub_1015FF02C(void *a1)
{
  if (a1)
  {
    sub_1015FF02C(*a1);
    sub_1015FF02C(a1[1]);
    v2 = a1[5];
    if (v2)
    {
      a1[6] = v2;
      operator delete(v2);
    }

    operator delete(a1);
  }
}

void sub_1015FF108(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    (*(*v1 + 48))(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_1015FF144(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1015FF17C(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 48))();
  }

  return result;
}

uint64_t sub_1015FF1AC(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_1015FF210(uint64_t a1, int a2)
{
  v2 = *(a1 + 8);
  if (!v2)
  {
LABEL_8:
    operator new();
  }

  while (1)
  {
    while (1)
    {
      v3 = v2;
      v4 = *(v2 + 32);
      if (v4 <= a2)
      {
        break;
      }

      v2 = *v3;
      if (!*v3)
      {
        goto LABEL_8;
      }
    }

    if (v4 >= a2)
    {
      return v3;
    }

    v2 = v3[1];
    if (!v2)
    {
      goto LABEL_8;
    }
  }
}

uint64_t sub_1015FF2F8()
{
  v1 = @"CellBroadcast";
  v2 = @"DuplicateDetectionParameters";
  v3 = @"DuplicationWindowInMinutes";
  qword_101FCAE30 = 0;
  unk_101FCAE38 = 0;
  qword_101FCAE28 = 0;
  sub_10005B328(&qword_101FCAE28, &v1, &v4, 3uLL);
  __cxa_atexit(sub_10041F938, &qword_101FCAE28, &_mh_execute_header);
  v1 = @"CellBroadcast";
  v2 = @"DuplicateDetectionParameters";
  v3 = @"PerformIntraSimDuplicateDetection";
  qword_101FCAE48 = 0;
  unk_101FCAE50 = 0;
  qword_101FCAE40 = 0;
  sub_10005B328(&qword_101FCAE40, &v1, &v4, 3uLL);
  __cxa_atexit(sub_10041F938, &qword_101FCAE40, &_mh_execute_header);
  v1 = @"CellBroadcast";
  v2 = @"DuplicateDetectionParameters";
  v3 = @"PerformInterSimDuplicateDetection";
  qword_101FCAE58 = 0;
  qword_101FCAE60 = 0;
  unk_101FCAE68 = 0;
  sub_10005B328(&qword_101FCAE58, &v1, &v4, 3uLL);
  return __cxa_atexit(sub_10041F938, &qword_101FCAE58, &_mh_execute_header);
}

uint64_t sub_1015FF4C0@<X0>(void *a1@<X8>)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = a1 + 1;
  result = subscriber::makeSimSlotRange();
  v2 = v3;
  if (v3 != v4)
  {
    do
    {
      result = v5(*v2);
      if (result)
      {
        break;
      }

      ++v2;
    }

    while (v2 != v4);
    if (v2 != v4)
    {
      sub_1015FF44C();
    }
  }

  return result;
}

void sub_1015FF760(TimeHandlerFactoryInterface *this)
{
  *this = off_101F56588;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  TimeHandlerFactoryInterface::~TimeHandlerFactoryInterface(this);
}

void sub_1015FF7BC(TimeHandlerFactoryInterface *this)
{
  *this = off_101F56588;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  TimeHandlerFactoryInterface::~TimeHandlerFactoryInterface(this);

  operator delete();
}

void sub_1015FF90C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    (*(*a10 + 8))(a10);
  }

  if (v10)
  {
    operator delete();
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1015FF954(uint64_t a1, void *a2, uint64_t *a3)
{
  v6 = (a1 + 8);
  ctu::OsLogContext::OsLogContext(&v18, kCtLoggingSystemName, "cb.server");
  v7 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  v8 = dispatch_queue_create("CarrierBundleServer", v7);
  *v6 = 0;
  v6[1] = 0;
  *(a1 + 24) = v8;
  if (v8)
  {
    v9 = v8;
    dispatch_retain(v8);
    *(a1 + 32) = 0;
    dispatch_release(v9);
  }

  else
  {
    *(a1 + 32) = 0;
  }

  ctu::OsLogLogger::OsLogLogger(v16, &v18);
  ctu::OsLogLogger::OsLogLogger((a1 + 40), v16);
  ctu::OsLogLogger::~OsLogLogger(v16);
  ctu::OsLogContext::~OsLogContext(&v18);
  v17[0] = off_101E2B528;
  v17[1] = sub_1000A85E8;
  v17[3] = v17;
  *(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v10) & 1) == 0)
  {
    operator new();
  }

  if (!*(a1 + 48))
  {
    operator new();
  }

  sub_1000A8744(v17);
  *a1 = off_101F565D0;
  *(a1 + 56) = *a2;
  v11 = a2[1];
  *(a1 + 64) = v11;
  if (v11)
  {
    atomic_fetch_add_explicit((v11 + 8), 1uLL, memory_order_relaxed);
  }

  v12 = *a3;
  *a3 = 0;
  *(a1 + 72) = v12;
  v13 = *(a1 + 24);
  object = v13;
  if (v13)
  {
    dispatch_retain(v13);
  }

  (*(*v12 + 32))(v12, &object);
  if (object)
  {
    dispatch_release(object);
  }

  *(a1 + 128) = 0u;
  *(a1 + 144) = 0u;
  *(a1 + 96) = 0u;
  *(a1 + 112) = 0u;
  return a1;
}

void sub_1015FFD74(void *a1)
{
  *a1 = off_101F565D0;
  v2 = a1[19];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = a1[17];
  if (v3)
  {
    sub_100004A34(v3);
  }

  v4 = a1[15];
  if (v4)
  {
    sub_100004A34(v4);
  }

  v5 = a1[13];
  if (v5)
  {
    sub_100004A34(v5);
  }

  v6 = a1[11];
  if (v6)
  {
    sub_100004A34(v6);
  }

  v7 = a1[9];
  a1[9] = 0;
  if (v7)
  {
    (*(*v7 + 8))(v7);
  }

  v8 = a1[8];
  if (v8)
  {
    sub_100004A34(v8);
  }

  v9 = a1[6];
  a1[6] = 0;
  if (v9)
  {
    (*(*v9 + 8))(v9);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 5));
  sub_1000C0544(a1 + 1);

  CarrierBundleServerInterface::~CarrierBundleServerInterface(a1);
}

void sub_1015FFE80(void *a1)
{
  sub_1015FFD74(a1);

  operator delete();
}

void sub_1015FFEB8(char *a1@<X0>, void **a2@<X1>, char *a3@<X8>)
{
  __s1 = 0;
  v57 = 0;
  v58 = 0;
  v52 = a2;
  v53 = off_101FB1708;
  sub_100006354(&v52, &object);
  __p = 0uLL;
  v60 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v60) < 0)
  {
    operator delete(__p);
  }

  xpc_release(object);
  v6 = *(a1 + 5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    p_s1 = &__s1;
    if (v58 < 0)
    {
      p_s1 = __s1;
    }

    LODWORD(__p) = 136446210;
    *(&__p + 4) = p_s1;
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Received command at the server: %{public}s", &__p, 0xCu);
  }

  *a3 = 0;
  *a3 = xpc_null_create();
  v8 = strlen(off_101FB1710);
  v9 = v8;
  v10 = SHIBYTE(v58);
  if ((SHIBYTE(v58) & 0x8000000000000000) != 0)
  {
    if (v8 != v57)
    {
      goto LABEL_14;
    }

    if (v8 == -1)
    {
      sub_10013C334();
    }

    v11 = __s1;
  }

  else
  {
    if (v8 != SHIBYTE(v58))
    {
      goto LABEL_14;
    }

    v11 = &__s1;
  }

  if (!memcmp(v11, off_101FB1710, v9))
  {
    v24 = a1 + 8;
    v52 = a1;
    v53 = a3;
    *&__p = _NSConcreteStackBlock;
    *(&__p + 1) = 0x40000000;
    v25 = sub_101601CE0;
    v26 = &unk_101F56760;
    goto LABEL_104;
  }

LABEL_14:
  v12 = strlen(off_101FB1718);
  v13 = v12;
  if ((v10 & 0x80000000) != 0)
  {
    if (v12 != v57)
    {
      goto LABEL_21;
    }

    if (v12 == -1)
    {
      sub_10013C334();
    }

    v14 = __s1;
  }

  else
  {
    if (v12 != v10)
    {
      goto LABEL_21;
    }

    v14 = &__s1;
  }

  if (!memcmp(v14, off_101FB1718, v13))
  {
    v24 = a1 + 8;
    v52 = a1;
    v53 = a3;
    *&__p = _NSConcreteStackBlock;
    *(&__p + 1) = 0x40000000;
    v25 = sub_101602944;
    v26 = &unk_101F56780;
    goto LABEL_104;
  }

LABEL_21:
  v15 = strlen(off_101FB1720);
  v16 = v15;
  if ((v10 & 0x80000000) != 0)
  {
    if (v15 != v57)
    {
      goto LABEL_28;
    }

    if (v15 == -1)
    {
      sub_10013C334();
    }

    v17 = __s1;
  }

  else
  {
    if (v15 != v10)
    {
      goto LABEL_28;
    }

    v17 = &__s1;
  }

  if (!memcmp(v17, off_101FB1720, v16))
  {
    v24 = a1 + 8;
    v52 = a2;
    v53 = a1;
    v54 = a3;
    *&__p = _NSConcreteStackBlock;
    *(&__p + 1) = 0x40000000;
    v25 = sub_101602CD4;
    v26 = &unk_101F567A0;
    goto LABEL_104;
  }

LABEL_28:
  v18 = strlen(off_101FB1728);
  v19 = v18;
  if ((v10 & 0x80000000) != 0)
  {
    if (v18 != v57)
    {
      goto LABEL_35;
    }

    if (v18 == -1)
    {
      sub_10013C334();
    }

    v20 = __s1;
  }

  else
  {
    if (v18 != v10)
    {
      goto LABEL_35;
    }

    v20 = &__s1;
  }

  if (!memcmp(v20, off_101FB1728, v19))
  {
    v24 = a1 + 8;
    v52 = a2;
    v53 = a1;
    v54 = a3;
    *&__p = _NSConcreteStackBlock;
    *(&__p + 1) = 0x40000000;
    v25 = sub_101603A84;
    v26 = &unk_101F567E0;
    goto LABEL_104;
  }

LABEL_35:
  v21 = strlen(off_101FB1730);
  v22 = v21;
  if ((v10 & 0x80000000) != 0)
  {
    if (v21 != v57)
    {
      goto LABEL_43;
    }

    if (v21 == -1)
    {
      sub_10013C334();
    }

    v23 = __s1;
  }

  else
  {
    if (v21 != v10)
    {
      goto LABEL_43;
    }

    v23 = &__s1;
  }

  if (!memcmp(v23, off_101FB1730, v22))
  {
    v39 = *a2;
    if (v39)
    {
      xpc_retain(v39);
    }

    else
    {
      xpc_null_create();
    }

    v47 = *(a1 + 2);
    if (v47 && std::__shared_weak_count::lock(v47))
    {
      operator new();
    }

    sub_100013CC4();
  }

LABEL_43:
  v27 = strlen(off_101FB1738);
  v28 = v27;
  if ((v10 & 0x80000000) != 0)
  {
    if (v27 != v57)
    {
      goto LABEL_51;
    }

    if (v27 == -1)
    {
      sub_10013C334();
    }

    v29 = __s1;
  }

  else
  {
    if (v27 != v10)
    {
      goto LABEL_51;
    }

    v29 = &__s1;
  }

  if (!memcmp(v29, off_101FB1738, v28))
  {
    v24 = a1 + 8;
    v52 = a1;
    *&__p = _NSConcreteStackBlock;
    *(&__p + 1) = 0x40000000;
    v25 = sub_101604034;
    v26 = &unk_101F56800;
    goto LABEL_104;
  }

LABEL_51:
  v30 = strlen(off_101FB1740);
  v31 = v30;
  if ((v10 & 0x80000000) != 0)
  {
    if (v30 != v57)
    {
      goto LABEL_59;
    }

    if (v30 == -1)
    {
      sub_10013C334();
    }

    v32 = __s1;
  }

  else
  {
    if (v30 != v10)
    {
      goto LABEL_59;
    }

    v32 = &__s1;
  }

  if (!memcmp(v32, off_101FB1740, v31))
  {
    v46 = *a2;
    if (v46)
    {
      xpc_retain(v46);
    }

    else
    {
      xpc_null_create();
    }

    v49 = *(a1 + 2);
    if (v49 && std::__shared_weak_count::lock(v49))
    {
      operator new();
    }

    sub_100013CC4();
  }

LABEL_59:
  v33 = strlen(off_101FB1790);
  v34 = v33;
  if ((v10 & 0x80000000) != 0)
  {
    if (v33 != v57)
    {
      goto LABEL_67;
    }

    if (v33 == -1)
    {
      sub_10013C334();
    }

    v35 = __s1;
  }

  else
  {
    if (v33 != v10)
    {
      goto LABEL_67;
    }

    v35 = &__s1;
  }

  if (!memcmp(v35, off_101FB1790, v34))
  {
    v24 = a1 + 8;
    v52 = a1;
    *&__p = _NSConcreteStackBlock;
    *(&__p + 1) = 0x40000000;
    v25 = sub_1016069C8;
    v26 = &unk_101F56940;
    goto LABEL_104;
  }

LABEL_67:
  v36 = strlen(off_101FB1760);
  v37 = v36;
  if ((v10 & 0x80000000) != 0)
  {
    if (v36 != v57)
    {
      goto LABEL_76;
    }

    if (v36 == -1)
    {
      sub_10013C334();
    }

    v38 = __s1;
  }

  else
  {
    if (v36 != v10)
    {
      goto LABEL_76;
    }

    v38 = &__s1;
  }

  if (!memcmp(v38, off_101FB1760, v37))
  {
    v24 = a1 + 8;
    v52 = a1;
    v53 = a3;
    *&__p = _NSConcreteStackBlock;
    *(&__p + 1) = 0x40000000;
    v25 = sub_101606AA0;
    v26 = &unk_101F56960;
    goto LABEL_104;
  }

LABEL_76:
  v40 = strlen(off_101FB1778);
  v41 = v40;
  if ((v10 & 0x80000000) != 0)
  {
    if (v40 != v57)
    {
      goto LABEL_84;
    }

    if (v40 == -1)
    {
      sub_10013C334();
    }

    v42 = __s1;
  }

  else
  {
    if (v40 != v10)
    {
      goto LABEL_84;
    }

    v42 = &__s1;
  }

  if (!memcmp(v42, off_101FB1778, v41))
  {
    v24 = a1 + 8;
    v52 = a2;
    v53 = a1;
    v54 = a3;
    *&__p = _NSConcreteStackBlock;
    *(&__p + 1) = 0x40000000;
    v25 = sub_101606C40;
    v26 = &unk_101F56980;
LABEL_104:
    v60 = v25;
    v61 = v26;
    v62 = v24;
    v63 = &v52;
    v48 = *(a1 + 3);
    if (*(a1 + 4))
    {
      dispatch_async_and_wait(v48, &__p);
    }

    else
    {
      dispatch_sync(v48, &__p);
    }

    goto LABEL_107;
  }

LABEL_84:
  v43 = strlen(off_101FB1780);
  v44 = v43;
  if ((v10 & 0x80000000) != 0)
  {
    if (v43 != v57)
    {
      goto LABEL_93;
    }

    if (v43 == -1)
    {
      sub_10013C334();
    }

    v45 = __s1;
  }

  else
  {
    if (v43 != v10)
    {
      goto LABEL_93;
    }

    v45 = &__s1;
  }

  if (!memcmp(v45, off_101FB1780, v44))
  {
    *&__p = a2;
    *(&__p + 1) = a1;
    v60 = a3;
    sub_101600994((a1 + 8), &__p);
    goto LABEL_107;
  }

LABEL_93:
  if (sub_100318068(&__s1, off_101FB1788))
  {
    *&__p = a1;
    sub_101600A10((a1 + 8), &__p);
  }

  else if (sub_100318068(&__s1, off_101FB1768))
  {
    *&__p = a1;
    *(&__p + 1) = a3;
    sub_101600A8C((a1 + 8), &__p);
  }

  else
  {
    if (sub_100318068(&__s1, off_101FB1770))
    {
      *&__p = a1;
      sub_101600B08((a1 + 8));
    }

    v50 = *(a1 + 5);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      v51 = &__s1;
      if (v58 < 0)
      {
        v51 = __s1;
      }

      LODWORD(__p) = 136446210;
      *(&__p + 4) = v51;
      _os_log_impl(&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#N Unknown command: %{public}s", &__p, 0xCu);
    }
  }

LABEL_107:
  if (SHIBYTE(v58) < 0)
  {
    operator delete(__s1);
  }
}

void sub_1016008FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

void sub_101600994(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_101607100;
  v4[3] = &unk_101F569A0;
  v4[4] = a1;
  v4[5] = a2;
  v3 = a1 + 16;
  v2 = *(a1 + 16);
  if (*(v3 + 8))
  {
    dispatch_async_and_wait(v2, v4);
  }

  else
  {
    dispatch_sync(v2, v4);
  }
}

void sub_101600A10(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10160764C;
  v4[3] = &unk_101F569C0;
  v4[4] = a1;
  v4[5] = a2;
  v3 = a1 + 16;
  v2 = *(a1 + 16);
  if (*(v3 + 8))
  {
    dispatch_async_and_wait(v2, v4);
  }

  else
  {
    dispatch_sync(v2, v4);
  }
}

void sub_101600A8C(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10160767C;
  v4[3] = &unk_101F569E0;
  v4[4] = a1;
  v4[5] = a2;
  v3 = a1 + 16;
  v2 = *(a1 + 16);
  if (*(v3 + 8))
  {
    dispatch_async_and_wait(v2, v4);
  }

  else
  {
    dispatch_sync(v2, v4);
  }
}

void sub_101600B08(uint64_t a1)
{
  v1 = *(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_101600BF8(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_101600CDC(uint64_t a1, int a2)
{
  if (a2)
  {
    memset(v18, 0, sizeof(v18));
    v3 = *(a1 + 40);
    v4 = os_signpost_id_generate(v3);
    if ((v4 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v5 = *(a1 + 40);
      if (os_signpost_enabled(v5))
      {
        *buf = 0;
        _os_signpost_emit_with_name_impl(&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v4, "CarrierBundleUpdate", "", buf, 2u);
      }
    }

    *buf = off_101F56A10;
    v20 = buf;
    v16 = v4;
    v17 = os_retain(v3);
    sub_1000148FC(v18, buf);
    sub_10001499C(buf);
    sub_10000501C(&__p, "CarrierBundleServer");
    v14[0] = v16;
    v14[1] = v17;
    sub_1000148FC(&v15, v18);
    v16 = 0;
    v17 = 0;
    sub_100014A28(v18);
    Registry::createXpcJetsamAssertion();
    v6 = *buf;
    memset(buf, 0, sizeof(buf));
    v7 = *(a1 + 136);
    *(a1 + 128) = v6;
    if (v7)
    {
      sub_100004A34(v7);
      if (*&buf[8])
      {
        sub_100004A34(*&buf[8]);
      }
    }

    sub_100014DA8(v14);
    if (v13 < 0)
    {
      operator delete(__p);
    }

    sub_100014DA8(&v16);
  }

  else
  {
    v8 = *(a1 + 136);
    *(a1 + 128) = 0;
    *(a1 + 136) = 0;
    if (v8)
    {
      sub_100004A34(v8);
    }

    v9 = *(a1 + 104);
    *(a1 + 96) = 0;
    *(a1 + 104) = 0;
    if (v9)
    {
      sub_100004A34(v9);
    }

    v10 = *(a1 + 120);
    *(a1 + 112) = 0;
    *(a1 + 120) = 0;
    if (v10)
    {
      sub_100004A34(v10);
    }

    v11 = *(a1 + 152);
    *(a1 + 144) = 0;
    *(a1 + 152) = 0;
    if (v11)
    {

      sub_100004A34(v11);
    }
  }
}

void sub_101600F04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22)
{
  sub_100014DA8(&a16);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  sub_100014DA8(&a22);
  _Unwind_Resume(a1);
}

void sub_101600F48(void *a1, void **a2, uint64_t a3)
{
  __s1 = 0;
  v37 = 0;
  v38 = 0;
  v35[0] = a2;
  v35[1] = off_101FB1708;
  sub_100006354(v35, &object);
  __p[0] = 0;
  __p[1] = 0;
  v41 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v41) < 0)
  {
    operator delete(__p[0]);
  }

  xpc_release(object);
  v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    p_s1 = &__s1;
    if (v38 < 0)
    {
      p_s1 = __s1;
    }

    LODWORD(__p[0]) = 136446210;
    *(__p + 4) = p_s1;
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Received command at the server: %{public}s", __p, 0xCu);
  }

  v8 = xpc_dictionary_create(0, 0, 0);
  if (v8 || (v8 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v8) == &_xpc_type_dictionary)
    {
      xpc_retain(v8);
      v9 = v8;
    }

    else
    {
      v9 = xpc_null_create();
    }
  }

  else
  {
    v9 = xpc_null_create();
    v8 = 0;
  }

  xpc_release(v8);
  v10 = strlen(off_101FB1748);
  v11 = v10;
  v12 = SHIBYTE(v38);
  if ((SHIBYTE(v38) & 0x8000000000000000) != 0)
  {
    if (v10 != v37)
    {
      goto LABEL_20;
    }

    if (v10 == -1)
    {
      sub_10013C334();
    }

    v13 = __s1;
  }

  else
  {
    if (v10 != SHIBYTE(v38))
    {
      goto LABEL_20;
    }

    v13 = &__s1;
  }

  if (!memcmp(v13, off_101FB1748, v11))
  {
    v24 = *a2;
    __p[0] = a1;
    __p[1] = v24;
    if (v24)
    {
      xpc_retain(v24);
    }

    else
    {
      __p[1] = xpc_null_create();
    }

    v41 = v9;
    if (v9)
    {
      xpc_retain(v9);
    }

    else
    {
      v41 = xpc_null_create();
    }

    sub_100669460(v42, a3);
    v30 = a1[2];
    if (v30 && std::__shared_weak_count::lock(v30))
    {
      operator new();
    }

    sub_100013CC4();
  }

LABEL_20:
  v14 = strlen(off_101FB1758);
  v15 = v14;
  if ((v12 & 0x80000000) != 0)
  {
    if (v14 != v37)
    {
      goto LABEL_27;
    }

    if (v14 == -1)
    {
      sub_10013C334();
    }

    v16 = __s1;
  }

  else
  {
    if (v14 != v12)
    {
      goto LABEL_27;
    }

    v16 = &__s1;
  }

  if (!memcmp(v16, off_101FB1758, v15))
  {
    v26 = *a2;
    __p[0] = a1;
    __p[1] = v26;
    if (v26)
    {
      xpc_retain(v26);
    }

    else
    {
      __p[1] = xpc_null_create();
    }

    v41 = v9;
    if (v9)
    {
      xpc_retain(v9);
    }

    else
    {
      v41 = xpc_null_create();
    }

    sub_100669460(v42, a3);
    v31 = a1[2];
    if (v31 && std::__shared_weak_count::lock(v31))
    {
      operator new();
    }

    sub_100013CC4();
  }

LABEL_27:
  v17 = strlen(off_101FB1880);
  v18 = v17;
  if ((v12 & 0x80000000) != 0)
  {
    if (v17 != v37)
    {
      goto LABEL_34;
    }

    if (v17 == -1)
    {
      sub_10013C334();
    }

    v19 = __s1;
  }

  else
  {
    if (v17 != v12)
    {
      goto LABEL_34;
    }

    v19 = &__s1;
  }

  if (!memcmp(v19, off_101FB1880, v18))
  {
    v27 = *a2;
    __p[0] = a1;
    __p[1] = v27;
    if (v27)
    {
      xpc_retain(v27);
    }

    else
    {
      __p[1] = xpc_null_create();
    }

    v41 = v9;
    if (v9)
    {
      xpc_retain(v9);
    }

    else
    {
      v41 = xpc_null_create();
    }

    sub_100669460(v42, a3);
    v32 = a1[2];
    if (v32 && std::__shared_weak_count::lock(v32))
    {
      operator new();
    }

    sub_100013CC4();
  }

LABEL_34:
  v20 = strlen(off_101FB1750);
  v21 = v20;
  if ((v12 & 0x80000000) != 0)
  {
    if (v20 != v37)
    {
      v23 = a1[5];
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        goto LABEL_55;
      }

      goto LABEL_53;
    }

    if (v20 == -1)
    {
      sub_10013C334();
    }

    v22 = __s1;
  }

  else
  {
    if (v20 != v12)
    {
      v23 = a1[5];
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        goto LABEL_55;
      }

      goto LABEL_47;
    }

    v22 = &__s1;
  }

  if (!memcmp(v22, off_101FB1750, v21))
  {
    v29 = *a2;
    __p[0] = a1;
    __p[1] = v29;
    if (v29)
    {
      xpc_retain(v29);
    }

    else
    {
      __p[1] = xpc_null_create();
    }

    v41 = v9;
    if (v9)
    {
      xpc_retain(v9);
    }

    else
    {
      v41 = xpc_null_create();
    }

    sub_100669460(v42, a3);
    v33 = a1[2];
    if (v33 && std::__shared_weak_count::lock(v33))
    {
      operator new();
    }

    sub_100013CC4();
  }

  v23 = a1[5];
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    if ((v12 & 0x80000000) != 0)
    {
LABEL_53:
      v25 = __s1;
      goto LABEL_54;
    }

LABEL_47:
    v25 = &__s1;
LABEL_54:
    LODWORD(__p[0]) = 136446210;
    *(__p + 4) = v25;
    _os_log_impl(&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#N Unknown command: %{public}s", __p, 0xCu);
  }

LABEL_55:
  v34 = v9;
  if (v9)
  {
    xpc_retain(v9);
  }

  else
  {
    v34 = xpc_null_create();
  }

  v28 = *(a3 + 24);
  if (!v28)
  {
    sub_100022DB4();
  }

  (*(*v28 + 48))(v28, &v34);
  xpc_release(v34);
  v34 = 0;
  xpc_release(v9);
  if (SHIBYTE(v38) < 0)
  {
    operator delete(__s1);
  }
}

void sub_101601820(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, xpc_object_t a19, void *a20, xpc_object_t a21, xpc_object_t object)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

void sub_1016019D4(uint64_t a1@<X0>, void *a2@<X8>)
{
  v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10160AD6C;
  v5[3] = &unk_101F56D00;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  v6 = v5;
  v3 = a1 + 24;
  v2 = *(a1 + 24);
  if (*(v3 + 8))
  {
    *a2 = 0;
    a2[1] = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_10160ADF8;
    v10 = &unk_101F56D40;
    v11 = a2;
    v12 = &v6;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    *a2 = 0;
    a2[1] = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_10160AD90;
    v10 = &unk_101F56D20;
    v11 = a2;
    v12 = &v6;
    dispatch_sync(v2, &block);
  }
}

void sub_101601BBC(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, sub_101601C90);
  __cxa_rethrow();
}

void sub_101601BFC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101601C50(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101601C90(uint64_t result)
{
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t sub_101601CE0(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v40 = 0;
  memset(v39, 0, sizeof(v39));
  sub_100BE9B38(v39, v2 + 56);
  v38 = 0;
  memset(v37, 0, sizeof(v37));
  sub_100BE9B38(v37, v2 + 56);
  v36 = 0;
  memset(v35, 0, sizeof(v35));
  sub_100BE9B38(v35, v2 + 56);
  v34 = 0;
  memset(v33, 0, sizeof(v33));
  sub_100BE9B38(v33, v2 + 56);
  v32 = 0;
  memset(v31, 0, sizeof(v31));
  sub_100BE9B38(v31, v2 + 56);
  v30 = 0;
  memset(v29, 0, sizeof(v29));
  sub_100BE9B38(v29, v2 + 56);
  v3 = *(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Initializing the bundles", buf, 2u);
  }

  (*(**(v2 + 80) + 16))(buf);
  sub_100BE9D28(v39, buf);
  sub_100BE9D28(v37, v24);
  sub_100BE9D28(v35, v25);
  sub_100BE9D28(v33, v26);
  sub_100BE9D28(v31, v27);
  sub_100BE9D28(v29, v28);
  sub_100BE9E54(v28);
  sub_100BE9E54(v27);
  sub_100BE9E54(v26);
  sub_100BE9E54(v25);
  sub_100BE9E54(v24);
  sub_100BE9E54(buf);
  v4 = xpc_dictionary_create(0, 0, 0);
  if (v4 || (v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == &_xpc_type_dictionary)
    {
      xpc_retain(v4);
      v5 = v4;
    }

    else
    {
      v5 = xpc_null_create();
    }
  }

  else
  {
    v5 = xpc_null_create();
    v4 = 0;
  }

  xpc_release(v4);
  v6 = v1[1];
  v7 = xpc_null_create();
  v8 = *v6;
  *v6 = v5;
  xpc_release(v8);
  xpc_release(v7);
  sub_1016022BC(&v20, v39, 1);
  *buf = v1[1];
  v23 = off_101FB17D0;
  sub_100DAE90C(buf, &v20, &object);
  xpc_release(object);
  object = 0;
  xpc_release(v20);
  v20 = 0;
  sub_1016022BC(&v18, v37, 1);
  *buf = v1[1];
  v23 = off_101FB17D8;
  sub_100DAE90C(buf, &v18, &v19);
  xpc_release(v19);
  v19 = 0;
  xpc_release(v18);
  v18 = 0;
  sub_1016022BC(&v16, v35, 1);
  *buf = v1[1];
  v23 = off_101FB17E0;
  sub_100DAE90C(buf, &v16, &v17);
  xpc_release(v17);
  v17 = 0;
  xpc_release(v16);
  v16 = 0;
  sub_1016022BC(&v14, v33, 1);
  *buf = v1[1];
  v23 = off_101FB17F8;
  sub_100DAE90C(buf, &v14, &v15);
  xpc_release(v15);
  v15 = 0;
  xpc_release(v14);
  v14 = 0;
  sub_1016022BC(&v12, v31, 1);
  *buf = v1[1];
  v23 = off_101FB17E8;
  sub_100DAE90C(buf, &v12, &v13);
  xpc_release(v13);
  v13 = 0;
  xpc_release(v12);
  v12 = 0;
  sub_1016022BC(&v10, v29, 1);
  *buf = v1[1];
  v23 = off_101FB17F0;
  sub_100DAE90C(buf, &v10, &v11);
  xpc_release(v11);
  v11 = 0;
  xpc_release(v10);
  v10 = 0;
  sub_100BE9E54(v29);
  sub_100BE9E54(v31);
  sub_100BE9E54(v33);
  sub_100BE9E54(v35);
  sub_100BE9E54(v37);
  return sub_100BE9E54(v39);
}

void sub_101602240(_Unwind_Exception *a1)
{
  sub_100BE9E54(&STACK[0x4B0]);
  sub_100BE9E54(&STACK[0x570]);
  sub_100BE9E54(&STACK[0x630]);
  sub_100BE9E54(&STACK[0x6F0]);
  sub_100BE9E54(&STACK[0x7B0]);
  sub_100BE9E54(v1 - 240);
  _Unwind_Resume(a1);
}

void sub_1016022BC(void *a1, char *a2, int a3)
{
  *a1 = 0;
  v6 = xpc_dictionary_create(0, 0, 0);
  v7 = v6;
  if (v6)
  {
    *a1 = v6;
  }

  else
  {
    v7 = xpc_null_create();
    *a1 = v7;
    if (!v7)
    {
      v8 = xpc_null_create();
      v7 = 0;
      goto LABEL_8;
    }
  }

  if (xpc_get_type(v7) == &_xpc_type_dictionary)
  {
    xpc_retain(v7);
    goto LABEL_9;
  }

  v8 = xpc_null_create();
LABEL_8:
  *a1 = v8;
LABEL_9:
  xpc_release(v7);
  sub_100BEB0C0(a2, &v39);
  if (v40 >= 0)
  {
    v9 = &v39;
  }

  else
  {
    v9 = v39;
  }

  v37 = xpc_string_create(v9);
  if (!v37)
  {
    v37 = xpc_null_create();
  }

  __p[0] = a1;
  __p[1] = off_101FB1820;
  sub_10000F688(__p, &v37, &v38);
  xpc_release(v38);
  v38 = 0;
  xpc_release(v37);
  v37 = 0;
  if (SHIBYTE(v40) < 0)
  {
    operator delete(v39);
  }

  sub_100BEB29C(a2, &v32);
  v39 = 0uLL;
  v40 = 0;
  ctu::cf::assign();
  *__p = v39;
  v34 = v40;
  if (v40 >= 0)
  {
    v10 = __p;
  }

  else
  {
    v10 = __p[0];
  }

  v35 = xpc_string_create(v10);
  if (!v35)
  {
    v35 = xpc_null_create();
  }

  *&v39 = a1;
  *(&v39 + 1) = off_101FB1828;
  sub_10000F688(&v39, &v35, &v36);
  xpc_release(v36);
  v36 = 0;
  xpc_release(v35);
  v35 = 0;
  if (SHIBYTE(v34) < 0)
  {
    operator delete(__p[0]);
  }

  sub_100005978(&v32);
  sub_100463AE0(a2, &v39);
  if (v40 >= 0)
  {
    v11 = &v39;
  }

  else
  {
    v11 = v39;
  }

  v30 = xpc_string_create(v11);
  if (!v30)
  {
    v30 = xpc_null_create();
  }

  __p[0] = a1;
  __p[1] = off_101FB1830;
  sub_10000F688(__p, &v30, &object);
  xpc_release(object);
  object = 0;
  xpc_release(v30);
  v30 = 0;
  if (SHIBYTE(v40) < 0)
  {
    operator delete(v39);
  }

  sub_10042C4B8(a2, &v39);
  if (v40 >= 0)
  {
    v12 = &v39;
  }

  else
  {
    v12 = v39;
  }

  v28 = xpc_string_create(v12);
  if (!v28)
  {
    v28 = xpc_null_create();
  }

  __p[0] = a1;
  __p[1] = off_101FB1838;
  sub_10000F688(__p, &v28, &v29);
  xpc_release(v29);
  v29 = 0;
  xpc_release(v28);
  v28 = 0;
  if (SHIBYTE(v40) < 0)
  {
    operator delete(v39);
  }

  sub_100BEB15C(a2, &v32);
  v39 = 0uLL;
  v40 = 0;
  ctu::cf::assign();
  *__p = v39;
  v34 = v40;
  if (v40 >= 0)
  {
    v13 = __p;
  }

  else
  {
    v13 = __p[0];
  }

  v26 = xpc_string_create(v13);
  if (!v26)
  {
    v26 = xpc_null_create();
  }

  *&v39 = a1;
  *(&v39 + 1) = off_101FB1840;
  sub_10000F688(&v39, &v26, &v27);
  xpc_release(v27);
  v27 = 0;
  xpc_release(v26);
  v26 = 0;
  if (SHIBYTE(v34) < 0)
  {
    operator delete(__p[0]);
  }

  sub_100005978(&v32);
  if (a3)
  {
    sub_100BEB038(a2, &v39);
    if (v40 >= 0)
    {
      v14 = &v39;
    }

    else
    {
      v14 = v39;
    }

    v24 = xpc_string_create(v14);
    if (!v24)
    {
      v24 = xpc_null_create();
    }

    __p[0] = a1;
    __p[1] = off_101FB1848;
    sub_10000F688(__p, &v24, &v25);
    xpc_release(v25);
    v25 = 0;
    xpc_release(v24);
    v24 = 0;
    if (SHIBYTE(v40) < 0)
    {
      operator delete(v39);
    }

    sub_100BEB060(a2, &v39);
    if (v40 >= 0)
    {
      v15 = &v39;
    }

    else
    {
      v15 = v39;
    }

    v22 = xpc_string_create(v15);
    if (!v22)
    {
      v22 = xpc_null_create();
    }

    __p[0] = a1;
    __p[1] = off_101FB1850;
    sub_10000F688(__p, &v22, &v23);
    xpc_release(v23);
    v23 = 0;
    xpc_release(v22);
    v22 = 0;
    if (SHIBYTE(v40) < 0)
    {
      operator delete(v39);
    }

    sub_100BEB088(a2, &v39);
    if (v40 >= 0)
    {
      v16 = &v39;
    }

    else
    {
      v16 = v39;
    }

    v20 = xpc_string_create(v16);
    if (!v20)
    {
      v20 = xpc_null_create();
    }

    __p[0] = a1;
    __p[1] = off_101FB1858;
    sub_10000F688(__p, &v20, &v21);
    xpc_release(v21);
    v21 = 0;
    xpc_release(v20);
    v20 = 0;
    if (SHIBYTE(v40) < 0)
    {
      operator delete(v39);
    }
  }

  v17 = sub_100BEB0B8(a2);
  v18 = xpc_int64_create(v17);
  if (!v18)
  {
    v18 = xpc_null_create();
  }

  *&v39 = a1;
  *(&v39 + 1) = off_101FB1860;
  sub_10000F688(&v39, &v18, &v19);
  xpc_release(v19);
  v19 = 0;
  xpc_release(v18);
}

uint64_t sub_1016028E8(uint64_t a1)
{
  sub_100BE9E54(a1 + 920);
  sub_100BE9E54(a1 + 736);
  sub_100BE9E54(a1 + 552);
  sub_100BE9E54(a1 + 368);
  sub_100BE9E54(a1 + 184);

  return sub_100BE9E54(a1);
}

void sub_101602944(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v3 = *(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Initializing the country bundles", buf, 2u);
  }

  *buf = 0;
  v26 = 0;
  v27 = 0;
  (*(**(v2 + 80) + 104))(buf);
  v4 = xpc_dictionary_create(0, 0, 0);
  if (v4 || (v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == &_xpc_type_dictionary)
    {
      xpc_retain(v4);
      v5 = v4;
    }

    else
    {
      v5 = xpc_null_create();
    }
  }

  else
  {
    v5 = xpc_null_create();
    v4 = 0;
  }

  xpc_release(v4);
  v6 = v1[1];
  v7 = xpc_null_create();
  v8 = *v6;
  *v6 = v5;
  xpc_release(v8);
  xpc_release(v7);
  sub_10000501C(__p, off_101FB1800);
  v9 = sub_1000E20F0(buf, __p);
  sub_1016022BC(&v23, v9, 1);
  v19 = v1[1];
  v20 = off_101FB1800;
  sub_100DAE90C(&v19, &v23, &v24);
  xpc_release(v24);
  v24 = 0;
  xpc_release(v23);
  v23 = 0;
  if (v22 < 0)
  {
    operator delete(__p[0]);
  }

  sub_10000501C(__p, off_101FB1810);
  v10 = sub_1000E20F0(buf, __p);
  sub_1016022BC(&v17, v10, 1);
  v19 = v1[1];
  v20 = off_101FB1810;
  sub_100DAE90C(&v19, &v17, &object);
  xpc_release(object);
  object = 0;
  xpc_release(v17);
  v17 = 0;
  if (v22 < 0)
  {
    operator delete(__p[0]);
  }

  sub_10000501C(__p, off_101FB1808);
  v11 = sub_1000E20F0(buf, __p);
  sub_1016022BC(&v15, v11, 1);
  v19 = v1[1];
  v20 = off_101FB1808;
  sub_100DAE90C(&v19, &v15, &v16);
  xpc_release(v16);
  v16 = 0;
  xpc_release(v15);
  v15 = 0;
  if (v22 < 0)
  {
    operator delete(__p[0]);
  }

  sub_10000501C(__p, off_101FB1818);
  v12 = sub_1000E20F0(buf, __p);
  sub_1016022BC(&v13, v12, 1);
  v19 = v1[1];
  v20 = off_101FB1818;
  sub_100DAE90C(&v19, &v13, &v14);
  xpc_release(v14);
  v14 = 0;
  xpc_release(v13);
  v13 = 0;
  if (v22 < 0)
  {
    operator delete(__p[0]);
  }

  sub_10109AE14(buf, v26);
}

void sub_101602CD4(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = v1[1];
  *buf = *v1;
  v23[0] = off_101FB17C8;
  sub_100006354(buf, object);
  v4 = xpc::dyn_cast_or_default(object, 0, v3);
  xpc_release(*&object[0]);
  if (v4)
  {
    v28 = 0;
    *buf = *v1;
    v23[0] = off_101FB1798;
    sub_100048A24(buf, &v28);
    *buf = *v1;
    v23[0] = off_101FB17A8;
    sub_100006354(buf, object);
    v6 = xpc::dyn_cast_or_default(object, 0, v5);
    xpc_release(*&object[0]);
    v7 = (v2 + 40);
    if (v4 <= 6u && ((1 << v4) & 0x66) != 0 && (v6 - 1) < 2)
    {
      v7 = (*(**(v2 + 48) + 16))(*(v2 + 48), v6);
    }

    v8 = v28;
    v27 = v28;
    if (v28)
    {
      xpc_retain(v28);
    }

    else
    {
      v8 = xpc_null_create();
      v27 = v8;
    }

    sub_1016031E0(v7, v4, "Matching request", &v27);
    xpc_release(v8);
    v26 = 0;
    v27 = 0;
    *&object[0] = v28;
    if (v28)
    {
      xpc_retain(v28);
    }

    else
    {
      *&object[0] = xpc_null_create();
    }

    xpc::bridge(buf, object, v10);
    sub_100010180(&v26, buf);
    sub_10000A1EC(buf);
    xpc_release(*&object[0]);
    *buf = *v1;
    v23[0] = off_101FB17A0;
    sub_100006354(buf, object);
    v12 = xpc::dyn_cast_or_default(object, 0, v11);
    xpc_release(*&object[0]);
    v25 = 0;
    memset(object, 0, sizeof(object));
    sub_100BE9B38(object, v2 + 56);
    v13 = *(v2 + 80);
    v21 = v26;
    if (v26)
    {
      CFRetain(v26);
    }

    LODWORD(v20) = v12;
    (*(*v13 + 24))(buf, v13, v4, &v21, &v20, v6);
    v14 = buf[0];
    sub_100BE9D28(object, v23);
    sub_100BE9E54(v23);
    sub_10001021C(&v21);
    sub_1016022BC(buf, object, 1);
    v15 = v1[2];
    v16 = *buf;
    *buf = xpc_null_create();
    v17 = *v15;
    *v15 = v16;
    xpc_release(v17);
    xpc_release(*buf);
    v19 = xpc_int64_create(v14);
    if (!v19)
    {
      v19 = xpc_null_create();
    }

    *buf = v1[2];
    v23[0] = off_101FB1868;
    sub_10000F688(buf, &v19, &v20);
    xpc_release(v20);
    v20 = 0;
    xpc_release(v19);
    v19 = 0;
    v18 = *v1[2];
    *buf = v18;
    if (v18)
    {
      xpc_retain(v18);
    }

    else
    {
      v18 = xpc_null_create();
      *buf = v18;
    }

    sub_1016031E0(v7, v4, "Matching response", buf);
    xpc_release(v18);
    *buf = 0;
    sub_100BE9E54(object);
    sub_10001021C(&v26);
    xpc_release(v28);
  }

  else
  {
    v9 = *(v2 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Unknown bundle type in the match bundle request", buf, 2u);
    }
  }
}

BOOL sub_1016031E0(os_log_t *a1, uint64_t a2, uint64_t a3, void **a4)
{
  v7 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 136446466;
    v12 = a3;
    v13 = 2080;
    v14 = asString();
    _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %{public}s %s bundle", buf, 0x16u);
  }

  v8 = *a4;
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = sub_101603300;
  applier[3] = &unk_101F567C0;
  applier[4] = a1;
  return xpc_dictionary_apply(v8, applier);
}

uint64_t sub_101603300(uint64_t a1, char *string, void *a3)
{
  cf = 0;
  *object = xpc_string_create(string);
  if (!*object)
  {
    *object = xpc_null_create();
  }

  xpc::bridge(&__p, object, v6);
  sub_100060DE8(&cf, &__p);
  sub_10000A1EC(&__p);
  xpc_release(*object);
  v18 = cf;
  if (cf)
  {
    CFRetain(cf);
  }

  sub_1016037B4();
  v8 = v7;
  sub_100005978(&v18);
  type = xpc_get_type(a3);
  v10 = **(a1 + 32);
  v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  if (type == &_xpc_type_string)
  {
    if (v8)
    {
      if (!v11)
      {
        goto LABEL_50;
      }

      v17 = a3;
      if (a3)
      {
        xpc_retain(a3);
      }

      else
      {
        v17 = xpc_null_create();
      }

      __p = 0;
      v21 = 0;
      v22 = 0;
      xpc::dyn_cast_or_default();
      if (SHIBYTE(v22) < 0)
      {
        operator delete(__p);
      }

      v14 = object;
      if (v26 < 0)
      {
        v14 = *object;
      }

      *v27 = 136446466;
      *&v27[4] = string;
      v28 = 2082;
      v29 = v14;
      _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I   %{public}s = %{public}s", v27, 0x16u);
      if (v26 < 0)
      {
        operator delete(*object);
      }
    }

    else
    {
      if (!v11)
      {
        goto LABEL_50;
      }

      v17 = a3;
      if (a3)
      {
        xpc_retain(a3);
      }

      else
      {
        v17 = xpc_null_create();
      }

      __p = 0;
      v21 = 0;
      v22 = 0;
      xpc::dyn_cast_or_default();
      if (SHIBYTE(v22) < 0)
      {
        operator delete(__p);
      }

      v15 = object;
      if (v26 < 0)
      {
        v15 = *object;
      }

      *v27 = 136446466;
      *&v27[4] = string;
      v28 = 2080;
      v29 = v15;
      _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I   %{public}s = %s", v27, 0x16u);
      if (v26 < 0)
      {
        operator delete(*object);
      }
    }

    xpc_release(v17);
    goto LABEL_50;
  }

  if (v8)
  {
    if (v11)
    {
      *v27 = a3;
      if (a3)
      {
        xpc_retain(a3);
      }

      else
      {
        *v27 = xpc_null_create();
      }

      xpc::object::to_string(&__p, v27);
      if (v22 >= 0)
      {
        p_p = &__p;
      }

      else
      {
        p_p = __p;
      }

      *object = 136446466;
      *&object[4] = string;
      v24 = 2082;
      v25 = p_p;
      _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I   %{public}s = %{public}s", object, 0x16u);
      if (SHIBYTE(v22) < 0)
      {
        operator delete(__p);
      }

LABEL_26:
      xpc_release(*v27);
    }
  }

  else if (v11)
  {
    *v27 = a3;
    if (a3)
    {
      xpc_retain(a3);
    }

    else
    {
      *v27 = xpc_null_create();
    }

    xpc::object::to_string(&__p, v27);
    if (v22 >= 0)
    {
      v13 = &__p;
    }

    else
    {
      v13 = __p;
    }

    *object = 136446466;
    *&object[4] = string;
    v24 = 2080;
    v25 = v13;
    _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I   %{public}s = %s", object, 0x16u);
    if (SHIBYTE(v22) < 0)
    {
      operator delete(__p);
    }

    goto LABEL_26;
  }

LABEL_50:
  sub_100005978(&cf);
  return 1;
}

void sub_1016036BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, char a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, xpc_object_t a21, uint64_t a22, uint64_t a23, uint64_t a24, xpc_object_t a25)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

void sub_1016037B4()
{
  v1[2] = qword_101FCB6E8;
  v1[3] = @"GID1";
  v1[4] = @"GID2";
  v1[5] = @"MCC";
  v1[6] = @"MNC";
  v1[7] = qword_101FCB6F0;
  v1[8] = qword_101FCB6F8;
  v1[9] = @"kNameOfBundle";
  v1[10] = @"kMatchedPath";
  v1[11] = @"kCarrierFilePathName";
  v1[0] = 0;
  v1[1] = 0;
  v0 = v1;
  operator new();
}

void sub_101603A60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, void *a12)
{
  sub_100005978(&a10);
  sub_100034450(a12);
  _Unwind_Resume(a1);
}

void sub_101603A84(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = v1[1];
  *buf = *v1;
  v15[0] = off_101FB17C8;
  sub_100006354(buf, object);
  v4 = xpc::dyn_cast_or_default(object, 0, v3);
  xpc_release(*&object[0]);
  if (v4)
  {
    v20 = 0;
    *buf = *v1;
    v15[0] = off_101FB1798;
    sub_100048A24(buf, &v20);
    v5 = v20;
    v19 = v20;
    if (v20)
    {
      xpc_retain(v20);
    }

    else
    {
      v5 = xpc_null_create();
      v19 = v5;
    }

    sub_1016031E0((v2 + 40), v4, "Lookup request", &v19);
    xpc_release(v5);
    v18 = 0;
    v19 = 0;
    *&object[0] = v20;
    if (v20)
    {
      xpc_retain(v20);
    }

    else
    {
      *&object[0] = xpc_null_create();
    }

    xpc::bridge(buf, object, v7);
    sub_100010180(&v18, buf);
    sub_10000A1EC(buf);
    xpc_release(*&object[0]);
    v17 = 0;
    memset(object, 0, sizeof(object));
    sub_100BE9B38(object, v2 + 56);
    v8 = *(v2 + 80);
    v13 = v18;
    if (v18)
    {
      CFRetain(v18);
    }

    (*(*v8 + 32))(buf, v8, v4, &v13);
    sub_100BE9D28(object, v15);
    sub_100BE9E54(v15);
    sub_10001021C(&v13);
    sub_1016022BC(buf, object, 0);
    v9 = v1[2];
    v10 = *buf;
    *buf = xpc_null_create();
    v11 = *v9;
    *v9 = v10;
    xpc_release(v11);
    xpc_release(*buf);
    v12 = *v1[2];
    *buf = v12;
    if (v12)
    {
      xpc_retain(v12);
    }

    else
    {
      v12 = xpc_null_create();
      *buf = v12;
    }

    sub_1016031E0((v2 + 40), v4, "Lookup response", buf);
    xpc_release(v12);
    *buf = 0;
    sub_100BE9E54(object);
    sub_10001021C(&v18);
    xpc_release(v20);
  }

  else
  {
    v6 = *(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Unknown bundle type in the lookup bundle request", buf, 2u);
    }
  }
}

void sub_101603D28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, xpc_object_t object)
{
  xpc_release(v35);
  sub_100BE9E54(&object);
  sub_10001021C((v36 - 72));
  xpc_release(*(v36 - 56));
  _Unwind_Resume(a1);
}

uint64_t *sub_101603E04(void **a1)
{
  v1 = *a1;
  v9 = a1;
  v10 = v1;
  v2 = *v1;
  *buf = v1 + 1;
  v12 = off_101FB1870;
  sub_100006354(buf, &v13);
  v4 = xpc::dyn_cast_or_default(&v13, 0, v3);
  xpc_release(v13);
  if (v4)
  {
    v5 = *(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Deleting bundle links", buf, 2u);
    }

    (*(**(v2 + 80) + 56))(*(v2 + 80));
  }

  v6 = *(v2 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Rescanning the carrier bundles in the file system", buf, 2u);
  }

  (*(**(v2 + 80) + 48))(*(v2 + 80));
  v7 = *(v2 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Rescanning the country bundles in the file system", buf, 2u);
  }

  (*(**(v2 + 80) + 120))(*(v2 + 80));
  sub_101603FDC(&v10);
  return sub_1000049E0(&v9);
}

void sub_101603FAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  xpc_release(*(v10 - 24));
  sub_101603FDC(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101603FDC(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    xpc_release(*(v1 + 8));
    *(v1 + 8) = 0;
    operator delete();
  }

  return result;
}

uint64_t sub_101604034(uint64_t a1)
{
  v1 = **(a1 + 40);
  (*(**(v1 + 80) + 40))(*(v1 + 80));
  v2 = *(**(v1 + 80) + 112);

  return v2();
}

uint64_t *sub_1016040B4(uint64_t **a1)
{
  v1 = *a1;
  v15 = a1;
  v16 = v1;
  v2 = *v1;
  if (!*(*v1 + 128))
  {
    sub_101600CDC(*v1, 1);
    object = 0;
    v4 = v1 + 1;
    *buf = v1 + 1;
    *&buf[8] = off_101FB1798;
    sub_100048A24(buf, &object);
    v26 = object;
    if (object)
    {
      xpc_retain(object);
    }

    else
    {
      v26 = xpc_null_create();
    }

    sub_101604660((v2 + 40), &v26);
    xpc_release(v26);
    v25 = 0;
    v26 = 0;
    v28[0] = object;
    if (object)
    {
      xpc_retain(object);
    }

    else
    {
      v28[0] = xpc_null_create();
    }

    xpc::bridge(buf, v28, v5);
    sub_100010180(&v25, buf);
    sub_10000A1EC(buf);
    xpc_release(v28[0]);
    *buf = v1 + 1;
    *&buf[8] = off_101FB1878;
    sub_100006354(buf, v28);
    v7 = xpc::dyn_cast_or_default(v28, 0, v6);
    xpc_release(v28[0]);
    *buf = v4;
    *&buf[8] = off_101FB18B8;
    sub_100006354(buf, v28);
    v9 = xpc::dyn_cast_or_default(v28, 0, v8);
    xpc_release(v28[0]);
    cf = 0;
    sub_1010AF2C4((v2 + 56), &cf);
    if (cf)
    {
      (*(**(v2 + 72) + 96))(buf);
      v10 = *buf;
      memset(buf, 0, sizeof(buf));
      v11 = *(v2 + 120);
      *(v2 + 112) = v10;
      if (v11)
      {
        sub_100004A34(v11);
        if (*&buf[8])
        {
          sub_100004A34(*&buf[8]);
        }

        if (*(v2 + 112))
        {
LABEL_15:
          v23 = 0;
          sub_1010AF494(&v23);
          v22 = cf;
          if (cf)
          {
            CFRetain(cf);
          }

          v21 = v23;
          if (v23)
          {
            CFRetain(v23);
          }

          *buf = v2;
          *&buf[8] = v25;
          if (v25)
          {
            CFRetain(v25);
          }

          v18 = v7;
          v19 = cf;
          if (cf)
          {
            CFRetain(cf);
          }

          v20 = v9;
          v28[3] = 0;
          operator new();
        }
      }

      else if (v10)
      {
        goto LABEL_15;
      }

      v12 = *(v2 + 40);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
LABEL_28:
        sub_101600CDC(v2, 0);
        sub_100005978(&cf);
        sub_10001021C(&v25);
        xpc_release(object);
        goto LABEL_29;
      }

      *buf = 0;
      v13 = "Failed to create downloader";
    }

    else
    {
      v12 = *(v2 + 40);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        goto LABEL_28;
      }

      *buf = 0;
      v13 = "Not a valid version.xml url";
    }

    _os_log_error_impl(&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v13, buf, 2u);
    goto LABEL_28;
  }

  v3 = *(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Carrier bundle update is already in progress, ignoring this request", buf, 2u);
  }

LABEL_29:
  sub_101604608(&v16);
  return sub_1000049E0(&v15);
}

void sub_1016044D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, int a21, __int16 a22, char a23, char a24, int a25, __int16 a26, char a27, char a28, int a29, __int16 a30, char a31, char a32, int a33, __int16 a34, char a35, char a36, xpc_object_t a37, xpc_object_t object)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

uint64_t *sub_101604608(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    xpc_release(*(v1 + 8));
    *(v1 + 8) = 0;
    operator delete();
  }

  return result;
}

void sub_101604660(os_log_t *a1, uint64_t a2)
{
  object[0] = 0;
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *__p = 0u;
  v20 = 0;
  *v27 = a2;
  *&v27[8] = __p;
  sub_100006354(v27, object);
  if (SHIBYTE(v20) < 0)
  {
    operator delete(__p[0]);
  }

  if (xpc_get_type(object[0]) != &_xpc_type_null)
  {
    v4 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      v6 = xpc::dyn_cast_or_default(object, 0, v5);
      v7 = CSIBOOLAsString(v6);
      *buf = 136315138;
      *&buf[4] = v7;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Supports voice call: %s", buf, 0xCu);
    }
  }

  xpc_release(object[0]);
  object[0] = 0;
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *__p = *buf;
  v20 = *&buf[16];
  v8 = *buf;
  if ((buf[23] & 0x80u) == 0)
  {
    v8 = __p;
  }

  *v27 = a2;
  *&v27[8] = v8;
  sub_100006354(v27, object);
  if (SHIBYTE(v20) < 0)
  {
    operator delete(__p[0]);
  }

  if (xpc_get_type(object[0]) != &_xpc_type_null)
  {
    v9 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      memset(buf, 0, sizeof(buf));
      xpc::dyn_cast_or_default();
      if (buf[23] < 0)
      {
        operator delete(*buf);
      }

      v10 = __p;
      if (v20 < 0)
      {
        v10 = __p[0];
      }

      *v27 = 136446210;
      *&v27[4] = v10;
      _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Device name: %{public}s", v27, 0xCu);
      if (SHIBYTE(v20) < 0)
      {
        operator delete(__p[0]);
      }
    }
  }

  xpc_release(object[0]);
  v18 = 0;
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *__p = *buf;
  v20 = *&buf[16];
  v11 = *buf;
  if ((buf[23] & 0x80u) == 0)
  {
    v11 = __p;
  }

  *v27 = a2;
  *&v27[8] = v11;
  sub_100015504(v27, &v18);
  if (SHIBYTE(v20) < 0)
  {
    operator delete(__p[0]);
  }

  if (xpc_get_type(v18) == &_xpc_type_array)
  {
    v13 = v18;
    if (v18)
    {
      xpc_retain(v18);
    }

    else
    {
      v13 = xpc_null_create();
    }

    v14 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      if (xpc_get_type(v13) == &_xpc_type_array)
      {
        count = xpc_array_get_count(v13);
      }

      else
      {
        count = 0;
      }

      *buf = 136446466;
      *&buf[4] = "";
      *&buf[12] = 2048;
      *&buf[14] = count;
      _os_log_impl(&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %{public}sCriteria count: %zu", buf, 0x16u);
    }

    *buf = v13;
    if (v13)
    {
      xpc_retain(v13);
    }

    else
    {
      *buf = xpc_null_create();
    }

    sub_100008EA4(__p, buf, 0);
    xpc_release(*buf);
    *buf = v13;
    if (v13)
    {
      xpc_retain(v13);
    }

    else
    {
      *buf = xpc_null_create();
    }

    if (xpc_get_type(v13) == &_xpc_type_array)
    {
      v16 = xpc_array_get_count(v13);
    }

    else
    {
      v16 = 0;
    }

    sub_100008EA4(v27, buf, v16);
    xpc_release(*buf);
    for (i = __p[1]; __PAIR128__(i, __p[0]) != *v27; i = ++__p[1])
    {
      object[1] = i;
      xdict = 0;
      object[0] = __p;
      sub_10003EAD4(object, &xdict);
      if (xpc_get_type(xdict) == &_xpc_type_dictionary)
      {
        *buf = _NSConcreteStackBlock;
        *&buf[8] = 0x40000000;
        *&buf[16] = sub_101604CC0;
        v24 = &unk_101F56820;
        v25 = a1;
        v26 = "";
        xpc_dictionary_apply(xdict, buf);
      }

      xpc_release(xdict);
    }

    xpc_release(*v27);
    xpc_release(__p[0]);
    xpc_release(v13);
  }

  else
  {
    v12 = *a1;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Update check criteria isn't an array!", buf, 2u);
    }
  }

  xpc_release(v18);
}

void sub_101604B88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17, uint64_t a18, xpc_object_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, xpc_object_t a29)
{
  xpc_release(v29);
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_101604CC0(uint64_t a1, char *string, void *a3)
{
  cf = 0;
  object = xpc_string_create(string);
  if (!object)
  {
    object = xpc_null_create();
  }

  xpc::bridge(cf1, &object, v6);
  sub_100060DE8(&cf, cf1);
  sub_10000A1EC(cf1);
  xpc_release(object);
  v30 = cf;
  if (cf)
  {
    CFRetain(cf);
  }

  sub_1016037B4();
  v8 = v7;
  sub_100005978(&v30);
  object = xpc_string_create(string);
  if (!object)
  {
    object = xpc_null_create();
  }

  xpc::bridge(cf1, &object, v9);
  v10 = CFEqual(*cf1, @"kUpdateBundleType");
  sub_10000A1EC(cf1);
  xpc_release(object);
  if (!v10)
  {
    type = xpc_get_type(a3);
    v15 = **(a1 + 32);
    v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    if (type == &_xpc_type_string)
    {
      if (v8)
      {
        if (!v16)
        {
          goto LABEL_22;
        }

        v18 = *(a1 + 40);
        v27 = a3;
        if (a3)
        {
          xpc_retain(a3);
        }

        else
        {
          v27 = xpc_null_create();
        }

        object = 0;
        v33 = 0;
        v34 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v34) < 0)
        {
          operator delete(object);
        }

        v25 = __p;
        if (v29 < 0)
        {
          v25 = __p[0];
        }

        *cf1 = 136446722;
        *&cf1[4] = v18;
        v36 = 2082;
        v37 = string;
        v38 = 2082;
        v39 = v25;
        _os_log_impl(&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %{public}s%{public}s = %{public}s", cf1, 0x20u);
        if (v29 < 0)
        {
          operator delete(__p[0]);
        }
      }

      else
      {
        if (!v16)
        {
          goto LABEL_22;
        }

        v22 = *(a1 + 40);
        v27 = a3;
        if (a3)
        {
          xpc_retain(a3);
        }

        else
        {
          v27 = xpc_null_create();
        }

        object = 0;
        v33 = 0;
        v34 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v34) < 0)
        {
          operator delete(object);
        }

        v26 = __p;
        if (v29 < 0)
        {
          v26 = __p[0];
        }

        *cf1 = 136446722;
        *&cf1[4] = v22;
        v36 = 2082;
        v37 = string;
        v38 = 2080;
        v39 = v26;
        _os_log_impl(&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %{public}s%{public}s = %s", cf1, 0x20u);
        if (v29 < 0)
        {
          operator delete(__p[0]);
        }
      }

      xpc_release(v27);
      goto LABEL_22;
    }

    if (v8)
    {
      if (!v16)
      {
        goto LABEL_22;
      }

      v17 = *(a1 + 40);
      __p[0] = a3;
      if (a3)
      {
        xpc_retain(a3);
      }

      else
      {
        __p[0] = xpc_null_create();
      }

      xpc::object::to_string(&object, __p);
      if (v34 >= 0)
      {
        p_object = &object;
      }

      else
      {
        p_object = object;
      }

      *cf1 = 136446722;
      *&cf1[4] = v17;
      v36 = 2082;
      v37 = string;
      v38 = 2082;
      v39 = p_object;
      _os_log_impl(&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %{public}s%{public}s = %{public}s", cf1, 0x20u);
      if (SHIBYTE(v34) < 0)
      {
        operator delete(object);
      }
    }

    else
    {
      if (!v16)
      {
        goto LABEL_22;
      }

      v21 = *(a1 + 40);
      __p[0] = a3;
      if (a3)
      {
        xpc_retain(a3);
      }

      else
      {
        __p[0] = xpc_null_create();
      }

      xpc::object::to_string(&object, __p);
      if (v34 >= 0)
      {
        v24 = &object;
      }

      else
      {
        v24 = object;
      }

      *cf1 = 136446722;
      *&cf1[4] = v21;
      v36 = 2082;
      v37 = string;
      v38 = 2080;
      v39 = v24;
      _os_log_impl(&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %{public}s%{public}s = %s", cf1, 0x20u);
      if (SHIBYTE(v34) < 0)
      {
        operator delete(object);
      }
    }

    xpc_release(__p[0]);
    goto LABEL_22;
  }

  v11 = **(a1 + 32);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = *(a1 + 40);
    object = a3;
    if (a3)
    {
      xpc_retain(a3);
    }

    else
    {
      object = xpc_null_create();
    }

    xpc::dyn_cast_or_default(&object, 0, v13);
    v19 = asString();
    *cf1 = 136446466;
    *&cf1[4] = v12;
    v36 = 2080;
    v37 = v19;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %{public}sBundle type: %s", cf1, 0x16u);
    xpc_release(object);
  }

LABEL_22:
  sub_100005978(&cf);
  return 1;
}

void sub_1016051A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11, uint64_t a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, char a25)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

uint64_t sub_1016052E8(uint64_t a1)
{
  *a1 = off_101F56850;
  v2 = (a1 + 16);
  sub_100005978((a1 + 32));
  sub_10001021C(v2);
  return a1;
}

void sub_10160533C(uint64_t a1)
{
  *a1 = off_101F56850;
  v1 = (a1 + 16);
  sub_100005978((a1 + 32));
  sub_10001021C(v1);

  operator delete();
}

const void **sub_10160543C(uint64_t a1, uint64_t a2)
{
  v4 = *(a1 + 8);
  *a2 = off_101F56850;
  *(a2 + 8) = v4;
  sub_100010024((a2 + 16), (a1 + 16));
  *(a2 + 24) = *(a1 + 24);
  result = sub_10005C7A4((a2 + 32), (a1 + 32));
  *(a2 + 40) = *(a1 + 40);
  *(a2 + 41) = 0;
  *(a2 + 44) = 0;
  return result;
}

const void **sub_1016054B0(uint64_t a1)
{
  sub_100005978((a1 + 32));

  return sub_10001021C((a1 + 16));
}

void sub_1016054EC(const void **a1)
{
  sub_100005978(a1 + 4);
  sub_10001021C(a1 + 2);

  operator delete(a1);
}

void sub_101605530(uint64_t a1, CFTypeRef *a2)
{
  cf = *a2;
  *a2 = 0;
  operator new();
}

void sub_1016057B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(v4 - 56) = v3;
  sub_100C116F0((v4 - 56));
  sub_100004A34(v2);
  sub_10001021C(va);
  _Unwind_Resume(a1);
}

uint64_t sub_1016057F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_101605844(uint64_t *a1)
{
  v2 = sub_100C11954(&event::carrierbundle::bundle_update_results[1]);
  memset(v28, 0, sizeof(v28));
  sub_100C115E0(v28, *a1, a1[1], (a1[1] - *a1) >> 4);
  v33 = 0uLL;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v3 = sub_10004A4A8(v2 + 3);
  sub_100048D3C(&v39, v3);
  v4 = v2[1];
  if (v4)
  {
    if (atomic_load_explicit((v4 + 8), memory_order_acquire) == 1)
    {
      sub_100C11F8C(v2, &v39, 0, 1);
    }

    v5 = *v2;
    v6 = v2[1];
    if (v6)
    {
      atomic_fetch_add_explicit((v6 + 8), 1u, memory_order_relaxed);
    }
  }

  else
  {
    v6 = 0;
    v5 = *v2;
  }

  v7 = v33;
  *&v33 = v5;
  *(&v33 + 1) = v6;
  v34 = v7;
  sub_10004A724(&v34 + 1);
  sub_10004A704(*(&v50 + 1));
  sub_10004A6B0(&v39);
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v39 = 0u;
  v54 = 0;
  v55 = 10;
  v56 = &v39 + 8;
  v57 = 0;
  v59 = 0;
  v60 = 0;
  v58 = v28;
  v8 = sub_100C11C24(&v33);
  v9 = sub_100C12F10(v8);
  v32[0] = &v39;
  v32[1] = v2;
  v32[2] = v9;
  v10 = sub_100C11C24(&v33);
  sub_10004AA88((v10 + 16));
  v11 = sub_100C11C24(&v33);
  v12 = *(sub_100C12F10(v11) + 8);
  v13 = sub_100C11C24(&v33);
  v14 = sub_100C12F10(v13);
  *&v30 = v12;
  *(&v30 + 1) = v14;
  *&v31 = &v39;
  *(&v31 + 1) = v14;
  sub_101605C70(&v30);
  v15 = sub_100C11C24(&v33);
  v16 = sub_100C12F10(v15);
  v17 = sub_100C11C24(&v33);
  v18 = sub_100C12F10(v17);
  v29[0] = v16;
  v29[1] = v18;
  v29[2] = &v39;
  v29[3] = v18;
  sub_101605C70(v29);
  v34 = v30;
  v35 = v31;
  v19 = v29[0];
  v20 = v30;
  if (v30 != v29[0])
  {
    v21 = v35;
    v22 = *v35;
    do
    {
      if ((v22 & 1) == 0)
      {
        v23 = sub_100C11C68((v20 + 16));
        v24 = sub_100C126C0((v23 + 32));
        v25 = *(v21 + 272);
        v26 = *v25;
        v27 = v25[1];
        v36 = 0uLL;
        v37 = 0;
        sub_100C115E0(&v36, v26, v27, (v27 - v26) >> 4);
        sub_100C13784((v24 + 24), &v36);
        v38 = &v36;
        sub_100C116F0(&v38);
        if ((*v21 & 1) == 0)
        {
          *v21 = 1;
        }
      }

      if ((*v35 & 1) == 0)
      {
        __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
      }

      *&v34 = *(v34 + 8);
      sub_101605C70(&v34);
      v21 = v35;
      if (*v35 == 1)
      {
        *v35 = 0;
      }

      v22 = 0;
      v20 = v34;
    }

    while (v34 != v19);
  }

  sub_101605FE0(v32);
  sub_1016061A8(&v39);
  sub_10004A724(&v33 + 1);
  *&v39 = v28;
  sub_100C116F0(&v39);
}

void sub_101605BFC(void *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  JUMPOUT(0x101605C68);
}

void sub_101605C34(_Unwind_Exception *a1)
{
  sub_101605FE0(&v3);
  sub_1016061A8(v5);
  sub_10004A724(&v4);
  v5[0] = &v2;
  sub_100C116F0(v5);
  _Unwind_Resume(a1);
}

void sub_101605C70(uint64_t *a1)
{
  v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1])
    {
      goto LABEL_23;
    }

    while (1)
    {
      sub_10004AB6C((a1[2] + 8), *(a1[2] + 264));
      v28 = 0u;
      v29 = 0u;
      v26 = 0u;
      v27 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      v18 = 0u;
      v19 = 0u;
      v3 = *(*a1 + 16);
      sub_101605FA0(v3);
      sub_10004ABC4(&v18, v3);
      v4 = sub_100C11C68((*a1 + 16));
      v5 = (v4 + 32);
      if (*(v4 + 32))
      {
        v6 = v4;
        v7 = a1[2];
        for (i = *sub_100C126C0((v4 + 32)); i != *(sub_100C126C0(v5) + 8); i += 6)
        {
          memset(v30, 0, sizeof(v30));
          sub_10004ACE8(i, v30);
          if (sub_100048EA8(i))
          {
            if (*(v6 + 24) == 1)
            {
              *(v6 + 24) = 0;
              sub_10004B3DC(v6, &v18);
            }

            sub_10004B040(v30);
            break;
          }

          sub_10004AFC8((v7 + 8), v30);
          sub_10004B040(v30);
        }
      }

      v9 = sub_100C11C68((*a1 + 16));
      v10 = a1[2];
      if (*(v9 + 24) == 1)
      {
        ++*(v10 + 280);
      }

      else
      {
        ++*(v10 + 284);
      }

      v11 = sub_100C11C68((*a1 + 16));
      if (*(v11 + 24) != 1 || (v12 = *(v11 + 16)) != 0 && atomic_load_explicit((v12 + 8), memory_order_acquire))
      {
        v13 = 1;
      }

      else
      {
        sub_10004B0FC(a1, &v18, *a1);
        v13 = 0;
      }

      (*(**(&v29 + 1) + 32))(*(&v29 + 1));
      sub_10004A6B0(&v18);
      v1 = *a1;
      v14 = a1[1];
      if (!v13)
      {
        break;
      }

      v15 = *(v1 + 8);
      *a1 = v15;
      if (v15 == v14)
      {
        v1 = v14;
        goto LABEL_23;
      }
    }

    if (v1 == v14)
    {
LABEL_23:
      v16 = a1[3];
      if (v16 != v1)
      {
        v28 = 0u;
        v29 = 0u;
        v26 = 0u;
        v27 = 0u;
        v24 = 0u;
        v25 = 0u;
        v22 = 0u;
        v23 = 0u;
        v20 = 0u;
        v21 = 0u;
        v18 = 0u;
        v19 = 0u;
        v17 = *(v16 + 16);
        sub_101605FA0(v17);
        sub_10004ABC4(&v18, v17);
        sub_10004B0FC(a1, &v18, a1[1]);
        (*(**(&v29 + 1) + 32))(*(&v29 + 1));
        sub_10004A6B0(&v18);
      }
    }
  }
}

void sub_101605F48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_101605FA0(uint64_t result)
{
  if (!result)
  {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }

  return result;
}

void *sub_101605FE0(void *a1)
{
  if (*(*a1 + 284) > *(*a1 + 280))
  {
    v2 = a1[1];
    v3 = a1[2];
    v11 = 0u;
    memset(v10, 0, sizeof(v10));
    v4 = sub_10004A4A8(v2 + 3);
    sub_100048D3C(v10, v4);
    v5 = sub_100C11C24(v2);
    if (sub_100C12F10(v5) == v3)
    {
      v6 = v2[1];
      if (!v6 || atomic_load_explicit((v6 + 8), memory_order_acquire) != 1)
      {
        operator new();
      }

      v7 = sub_100C11C24(v2);
      v9 = *(sub_100C12F10(v7) + 8);
      sub_100C11E74(v2, v10, 0, &v9, 0);
    }

    sub_10004A704(*(&v11 + 1));
    sub_10004A6B0(v10);
  }

  return a1;
}

void sub_10160614C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2)
  {
    operator delete();
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016061A8(uint64_t a1)
{
  v2 = *(a1 + 288);
  if (v2)
  {
    v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10004ABC4(v4, v2);
    sub_10004B3DC(*(a1 + 288), v4);
    (*(**(&v5 + 1) + 32))(*(&v5 + 1));
    sub_10004A6B0(v4);
  }

  sub_10004B4D0((a1 + 8));
  if (*a1 == 1)
  {
    *a1 = 0;
  }

  return a1;
}

void sub_101606280(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_1016062A0(const void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  v3 = dispatch_group_create();
  v4 = *(v2 + 9);
  sub_100010024(&v11, v1 + 1);
  v5 = *(v1 + 16);
  sub_10005C7A4(&v10, v1 + 3);
  (*(*v4 + 40))(&v12, v4, &v11, v5, &v10, *(v1 + 32));
  v6 = v12;
  v12 = 0uLL;
  v7 = *(v2 + 13);
  *(v2 + 6) = v6;
  if (v7)
  {
    sub_100004A34(v7);
    if (*(&v12 + 1))
    {
      sub_100004A34(*(&v12 + 1));
    }
  }

  sub_100005978(&v10);
  sub_10001021C(&v11);
  sub_100010024(&v9, v1 + 5);
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }

  v8 = v1[7];
  if (v8)
  {
    atomic_fetch_add_explicit(v8 + 1, 1uLL, memory_order_relaxed);
  }

  v13 = 0;
  operator new();
}

void sub_1016064F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, char a17, int a18, __int16 a19, char a20, char a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, char a27)
{
  if (v28)
  {
    sub_100004A34(v28);
  }

  if (v27)
  {
    dispatch_release(v27);
  }

  sub_101606560(&a11);
  sub_1000049E0(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_101606560(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    v2 = *(v1 + 56);
    if (v2)
    {
      sub_100004A34(v2);
    }

    sub_10001021C((v1 + 40));
    sub_100005978((v1 + 24));
    sub_10001021C((v1 + 8));
    operator delete();
  }

  return result;
}

void *sub_1016065CC(void *a1)
{
  *a1 = off_101F568C0;
  v2 = a1[3];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = a1[1];
  if (v3)
  {
    dispatch_group_leave(v3);
    v4 = a1[1];
    if (v4)
    {
      dispatch_release(v4);
    }
  }

  return a1;
}

void sub_101606630(void *a1)
{
  *a1 = off_101F568C0;
  v2 = a1[3];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = a1[1];
  if (v3)
  {
    dispatch_group_leave(v3);
    v4 = a1[1];
    if (v4)
    {
      dispatch_release(v4);
    }
  }

  operator delete();
}

void sub_101606740(void *a1, void *a2)
{
  v4 = a1[1];
  *a2 = off_101F568C0;
  a2[1] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    v5 = a2[1];
    if (v5)
    {
      dispatch_group_enter(v5);
    }
  }

  v6 = a1[3];
  a2[2] = a1[2];
  a2[3] = v6;
  if (v6)
  {
    atomic_fetch_add_explicit((v6 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_1016067B0(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(a1 + 8);
  if (v3)
  {
    dispatch_group_leave(v3);
    v4 = *(a1 + 8);
    if (v4)
    {

      dispatch_release(v4);
    }
  }
}

void sub_10160680C(void *__p)
{
  v2 = __p[3];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = __p[1];
  if (v3)
  {
    dispatch_group_leave(v3);
    v4 = __p[1];
    if (v4)
    {
      dispatch_release(v4);
    }
  }

  operator delete(__p);
}

void sub_101606864(uint64_t a1, uint64_t a2)
{
  v4 = *a2;
  v2 = v4;
  v5 = *(a2 + 8);
  v3 = v5;
  *(a2 + 8) = 0;
  *(a2 + 16) = 0;
  *a2 = 0;
  sub_1014B1094(*(a1 + 16), *(*(a1 + 16) + 8), v2, v3, (v3 - v2) >> 4);
  v6 = &v4;
  sub_100C116F0(&v6);
}

void sub_1016068C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = &a9;
  sub_100C116F0(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1016068E4(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F56920))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_101606930(uint64_t a1)
{
  v3 = a1;
  memset(v4, 0, sizeof(v4));
  v1 = *a1;
  sub_100C115E0(v4, **(a1 + 8), *(*(a1 + 8) + 8), (*(*(a1 + 8) + 8) - **(a1 + 8)) >> 4);
  sub_101605844(v4);
  v5 = v4;
  sub_100C116F0(&v5);
  sub_101600CDC(v1, 0);
  return sub_10032EAB4(&v3);
}

void sub_1016069A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(v3 - 24) = v2;
  sub_100C116F0((v3 - 24));
  sub_10032EAB4(va);
  _Unwind_Resume(a1);
}

void sub_1016069C8(uint64_t a1)
{
  v1 = **(a1 + 40);
  (*(**(v1 + 80) + 64))(*(v1 + 80));
  v2 = *(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = CSIBOOLAsString(*(v1 + 128) != 0);
    v4 = 136315138;
    v5 = v3;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Update in progress: %s", &v4, 0xCu);
  }
}

void sub_101606AA0(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v3 = (*(**(*v1 + 80) + 80))(*(*v1 + 80));
  v4 = (*(**(v2 + 80) + 128))(*(v2 + 80));
  v5 = xpc_dictionary_create(0, 0, 0);
  if (v5 || (v5 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v5) == &_xpc_type_dictionary)
    {
      xpc_retain(v5);
      v6 = v5;
    }

    else
    {
      v6 = xpc_null_create();
    }
  }

  else
  {
    v6 = xpc_null_create();
    v5 = 0;
  }

  xpc_release(v5);
  v7 = v1[1];
  v8 = xpc_null_create();
  v9 = *v7;
  *v7 = v6;
  xpc_release(v9);
  xpc_release(v8);
  v11 = xpc_BOOL_create((v3 | v4) & 1);
  if (!v11)
  {
    v11 = xpc_null_create();
  }

  v10[0] = v1[1];
  v10[1] = off_101FB17C0;
  sub_10000F688(v10, &v11, &object);
  xpc_release(object);
  object = 0;
  xpc_release(v11);
}

void sub_101606C40(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = v1[1];
  *&v18[0] = *v1;
  *(&v18[0] + 1) = off_101FB17C8;
  sub_100006354(v18, &v23);
  v4 = xpc::dyn_cast_or_default(&v23, 0, v3);
  xpc_release(v23);
  v22 = 0;
  *&v18[0] = *v1;
  *(&v18[0] + 1) = off_101FB1798;
  sub_100048A24(v18, &v22);
  v5 = v22;
  v21 = v22;
  if (v22)
  {
    xpc_retain(v22);
  }

  else
  {
    v5 = xpc_null_create();
    v21 = v5;
  }

  sub_1016031E0((v2 + 40), v4, "OverlayBundle request", &v21);
  xpc_release(v5);
  v20 = 0;
  v21 = 0;
  v23 = v22;
  if (v22)
  {
    xpc_retain(v22);
  }

  else
  {
    v23 = xpc_null_create();
  }

  xpc::bridge(v18, &v23, v6);
  sub_100010180(&v20, v18);
  sub_10000A1EC(v18);
  xpc_release(v23);
  v19 = 0;
  memset(v18, 0, sizeof(v18));
  sub_100BE9B38(v18, v2 + 56);
  v14 = *v1;
  v15 = off_101FB1830;
  sub_100006354(&v14, &object);
  v23 = 0;
  v24 = 0;
  v25 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v25) < 0)
  {
    operator delete(v23);
  }

  sub_100BEA064(v18, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  xpc_release(object);
  v14 = *v1;
  v15 = off_101FB1858;
  sub_100006354(&v14, &object);
  v23 = 0;
  v24 = 0;
  v25 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v25) < 0)
  {
    operator delete(v23);
  }

  sub_100BEA10C(v18, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  xpc_release(object);
  v23 = *v1;
  v24 = off_101FB1860;
  sub_100006354(&v23, &__p);
  v8 = xpc::dyn_cast_or_default(&__p, 0, v7);
  sub_100BEB144(v18, v8);
  xpc_release(__p.__r_.__value_.__l.__data_);
  v9 = *(v2 + 80);
  v23 = v20;
  if (v20)
  {
    CFRetain(v20);
  }

  (*(*v9 + 88))(v9, v4, &v23, v18);
  sub_10001021C(&v23);
  sub_1016022BC(&__p, v18, 1);
  v10 = v1[2];
  v11 = __p.__r_.__value_.__r.__words[0];
  __p.__r_.__value_.__r.__words[0] = xpc_null_create();
  v12 = *v10;
  *v10 = v11;
  xpc_release(v12);
  xpc_release(__p.__r_.__value_.__l.__data_);
  v13 = *v1[2];
  __p.__r_.__value_.__r.__words[0] = v13;
  if (v13)
  {
    xpc_retain(v13);
  }

  else
  {
    v13 = xpc_null_create();
    __p.__r_.__value_.__r.__words[0] = v13;
  }

  sub_1016031E0((v2 + 40), v4, "OverlayBundle response", &__p.__r_.__value_.__l.__data_);
  xpc_release(v13);
  __p.__r_.__value_.__r.__words[0] = 0;
  sub_100BE9E54(v18);
  sub_10001021C(&v20);
  xpc_release(v22);
}

void sub_101606F98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  xpc_release(v18);
  sub_100BE9E54(&a18);
  sub_10001021C((v19 - 96));
  xpc_release(*(v19 - 80));
  _Unwind_Resume(a1);
}

void sub_101607088(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A1EC(va);
  xpc_release(*(v6 - 72));
  JUMPOUT(0x10160706CLL);
}

void sub_1016070B4()
{
  xpc_release(v0);
  *(v1 - 88) = 0;
  JUMPOUT(0x10160706CLL);
}

void sub_101607100(uint64_t a1)
{
  v1 = *(a1 + 40);
  v34 = 0;
  v2 = *(v1 + 8);
  __p[0] = *v1;
  __p[1] = off_101FB1798;
  sub_100048A24(__p, &v34);
  v3 = v34;
  v33 = v34;
  if (v34)
  {
    xpc_retain(v34);
  }

  else
  {
    v3 = xpc_null_create();
    v33 = v3;
  }

  sub_1016031E0((v2 + 40), 1, "Lookup GSMA configuration request", &v33);
  xpc_release(v3);
  v32 = 0;
  v33 = 0;
  v30[0] = v34;
  if (v34)
  {
    xpc_retain(v34);
  }

  else
  {
    v30[0] = xpc_null_create();
  }

  xpc::bridge(__p, v30, v4);
  sub_100010180(&v32, __p);
  sub_10000A1EC(__p);
  xpc_release(v30[0]);
  v30[0] = 0;
  v30[1] = 0;
  v31 = 0;
  v28 = 0;
  v29 = 0;
  v5 = *(v2 + 80);
  v23 = v32;
  if (v32)
  {
    CFRetain(v32);
  }

  (*(*v5 + 96))(__p, v5, &v23);
  v21[0] = v30;
  v21[1] = &v29;
  v22 = &v28;
  sub_10042E1F8(v21, __p);
  sub_100005978(&v27);
  sub_100005978(&v26);
  if (SHIBYTE(v25) < 0)
  {
    operator delete(__p[0]);
  }

  sub_10001021C(&v23);
  v6 = xpc_dictionary_create(0, 0, 0);
  if (v6 || (v6 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v6) == &_xpc_type_dictionary)
    {
      xpc_retain(v6);
      v7 = v6;
    }

    else
    {
      v7 = xpc_null_create();
    }
  }

  else
  {
    v7 = xpc_null_create();
    v6 = 0;
  }

  xpc_release(v6);
  v8 = *(v1 + 16);
  v9 = xpc_null_create();
  v10 = *v8;
  *v8 = v7;
  xpc_release(v10);
  xpc_release(v9);
  if (v31 >= 0)
  {
    v11 = v30;
  }

  else
  {
    v11 = v30[0];
  }

  v19 = xpc_string_create(v11);
  if (!v19)
  {
    v19 = xpc_null_create();
  }

  __p[0] = *(v1 + 16);
  __p[1] = off_101FB18A0;
  sub_10000F688(__p, &v19, &object);
  xpc_release(object);
  object = 0;
  xpc_release(v19);
  v19 = 0;
  __p[0] = 0;
  __p[1] = 0;
  v25 = 0;
  ctu::cf::assign();
  *v21 = *__p;
  v22 = v25;
  if (SHIBYTE(v25) >= 0)
  {
    v12 = v21;
  }

  else
  {
    v12 = __p[0];
  }

  v17 = xpc_string_create(v12);
  if (!v17)
  {
    v17 = xpc_null_create();
  }

  __p[0] = *(v1 + 16);
  __p[1] = off_101FB18A8;
  sub_10000F688(__p, &v17, &v18);
  xpc_release(v18);
  v18 = 0;
  xpc_release(v17);
  v17 = 0;
  if (SHIBYTE(v22) < 0)
  {
    operator delete(v21[0]);
  }

  __p[0] = 0;
  __p[1] = 0;
  v25 = 0;
  ctu::cf::assign();
  *v21 = *__p;
  v22 = v25;
  if (SHIBYTE(v25) >= 0)
  {
    v13 = v21;
  }

  else
  {
    v13 = __p[0];
  }

  v15 = xpc_string_create(v13);
  if (!v15)
  {
    v15 = xpc_null_create();
  }

  __p[0] = *(v1 + 16);
  __p[1] = off_101FB18B0;
  sub_10000F688(__p, &v15, &v16);
  xpc_release(v16);
  v16 = 0;
  xpc_release(v15);
  v15 = 0;
  if (SHIBYTE(v22) < 0)
  {
    operator delete(v21[0]);
  }

  v14 = **(v1 + 16);
  __p[0] = v14;
  if (v14)
  {
    xpc_retain(v14);
  }

  else
  {
    v14 = xpc_null_create();
    __p[0] = v14;
  }

  sub_1016031E0((v2 + 40), 1, "Lookup GSMA configuration response", __p);
  xpc_release(v14);
  __p[0] = 0;
  sub_100005978(&v28);
  sub_100005978(&v29);
  if (SHIBYTE(v31) < 0)
  {
    operator delete(v30[0]);
  }

  sub_10001021C(&v32);
  xpc_release(v34);
}

void sub_10160753C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  v27 = v25;
  xpc_release(v27);
  sub_100005978((v26 - 112));
  sub_100005978((v26 - 104));
  if (*(v26 - 73) < 0)
  {
    operator delete(*(v26 - 96));
  }

  sub_10001021C((v26 - 72));
  xpc_release(*(v26 - 56));
  _Unwind_Resume(a1);
}

void sub_10160767C(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = (*(**(*v1 + 80) + 144))(*(*v1 + 80));
  v3 = xpc_dictionary_create(0, 0, 0);
  if (v3 || (v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == &_xpc_type_dictionary)
    {
      xpc_retain(v3);
      v4 = v3;
    }

    else
    {
      v4 = xpc_null_create();
    }
  }

  else
  {
    v4 = xpc_null_create();
    v3 = 0;
  }

  xpc_release(v3);
  v5 = v1[1];
  v6 = xpc_null_create();
  v7 = *v5;
  *v5 = v4;
  xpc_release(v7);
  xpc_release(v6);
  v9 = xpc_BOOL_create(v2);
  if (!v9)
  {
    v9 = xpc_null_create();
  }

  v8[0] = v1[1];
  v8[1] = off_101FB17C0;
  sub_10000F688(v8, &v9, &object);
  xpc_release(object);
  object = 0;
  xpc_release(v9);
}

void sub_1016077EC(uint64_t **a1)
{
  v1 = **a1;
  v2 = 0;
  v3 = 0;
  (*(**(v1 + 72) + 112))(&v2);
  if (v2)
  {
    (*(*v2 + 16))(v2);
  }

  if (v3)
  {
    sub_100004A34(v3);
  }

  operator delete();
}

void sub_1016078B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    sub_100004A34(a12);
  }

  operator delete();
}

void sub_1016078E4(uint64_t **a1)
{
  v1 = a1;
  sub_101600CDC(**a1, *(*a1 + 8));
  operator delete();
}

void sub_1016079F0(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *v5 = 0;
      _os_signpost_emit_with_name_impl(&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "CarrierBundleUpdate", "", v5, 2u);
    }
  }
}

uint64_t sub_101607A68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_101607AB4(uint64_t **a1)
{
  v1 = *a1;
  v21 = a1;
  v22[0] = v1;
  v2 = *v1;
  if (!*(*v1 + 128))
  {
    sub_101600CDC(*v1, 1);
    object = 0;
    *buf = v1 + 1;
    *&buf[8] = off_101FB1798;
    sub_100048A24(buf, &object);
    v6 = (v2 + 40);
    v5 = *(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      xpc::object::to_string(buf, &object);
      v7 = v29 >= 0 ? buf : *buf;
      *v33 = 136315138;
      *&v33[4] = v7;
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Checking for update with criteria: %s", v33, 0xCu);
      if (v29 < 0)
      {
        operator delete(*buf);
      }
    }

    v25 = 0;
    *v33 = object;
    if (object)
    {
      xpc_retain(object);
    }

    else
    {
      *v33 = xpc_null_create();
    }

    xpc::bridge(buf, v33, v8);
    sub_100010180(&v25, buf);
    sub_10000A1EC(buf);
    xpc_release(*v33);
    *buf = v1 + 1;
    *&buf[8] = off_101FB1878;
    sub_100006354(buf, v33);
    v11 = xpc::dyn_cast_or_default(v33, 0, v10);
    xpc_release(*v33);
    cf = 0;
    sub_1010AF2C4((v2 + 56), &cf);
    if (cf)
    {
      (*(**(v2 + 72) + 96))(buf);
      v12 = *buf;
      memset(buf, 0, sizeof(buf));
      v13 = *(v2 + 120);
      *(v2 + 112) = v12;
      if (v13)
      {
        sub_100004A34(v13);
        if (*&buf[8])
        {
          sub_100004A34(*&buf[8]);
        }

        if (*(v2 + 112))
        {
LABEL_23:
          v23 = 0;
          sub_1010AF494(&v23);
          v22[2] = cf;
          if (cf)
          {
            CFRetain(cf);
          }

          v22[1] = v23;
          if (v23)
          {
            CFRetain(v23);
          }

          *buf = v2;
          *&buf[8] = v25;
          if (v25)
          {
            CFRetain(v25);
          }

          v28 = v11;
          v30 = cf;
          if (cf)
          {
            CFRetain(cf);
          }

          sub_100669460(&v31, (v1 + 3));
          v14 = v1[2];
          v32 = v14;
          if (v14)
          {
            xpc_retain(v14);
          }

          else
          {
            v32 = xpc_null_create();
          }

          v34 = 0;
          operator new();
        }
      }

      else if (v12)
      {
        goto LABEL_23;
      }

      v17 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        *buf = 0;
        _os_log_error_impl(&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "downloader missing.", buf, 2u);
      }

      sub_101600CDC(v2, 0);
      v18 = v1[2];
      *buf = v18;
      if (v18)
      {
        xpc_retain(v18);
      }

      else
      {
        *buf = xpc_null_create();
      }

      v19 = v1[6];
      if (!v19)
      {
        sub_100022DB4();
      }
    }

    else
    {
      v15 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        *buf = 0;
        _os_log_error_impl(&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Not a valid version.xml url", buf, 2u);
      }

      sub_101600CDC(v2, 0);
      v16 = v1[2];
      *buf = v16;
      if (v16)
      {
        xpc_retain(v16);
      }

      else
      {
        *buf = xpc_null_create();
      }

      v19 = v1[6];
      if (!v19)
      {
        sub_100022DB4();
      }
    }

    (*(*v19 + 48))(v19, buf);
    xpc_release(*buf);
    *buf = 0;
    sub_100005978(&cf);
    sub_10001021C(&v25);
    xpc_release(object);
    goto LABEL_50;
  }

  v3 = *(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Carrier bundle update is already in progress, ignoring this request", buf, 2u);
  }

  v4 = v1[2];
  *buf = v4;
  if (v4)
  {
    xpc_retain(v4);
  }

  else
  {
    *buf = xpc_null_create();
  }

  v9 = v1[6];
  if (!v9)
  {
    sub_100022DB4();
  }

  (*(*v9 + 48))(v9, buf);
  xpc_release(*buf);
LABEL_50:
  sub_1016081F0(v22);
  return sub_1000049E0(&v21);
}

void sub_101608078(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20, char a21, char a22, int a23, __int16 a24, char a25, char a26, int a27, __int16 a28, char a29, char a30, xpc_object_t object, xpc_object_t a32)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

uint64_t *sub_1016081F0(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_1006646F0(v1 + 24);
    xpc_release(*(v1 + 16));
    *(v1 + 16) = 0;
    xpc_release(*(v1 + 8));
    *(v1 + 8) = 0;
    operator delete();
  }

  return result;
}

uint64_t sub_101608260(uint64_t a1)
{
  xpc_release(*(a1 + 64));
  *(a1 + 64) = 0;
  sub_1006646F0(a1 + 32);
  sub_100005978((a1 + 24));
  sub_10001021C((a1 + 8));
  return a1;
}

uint64_t sub_1016082AC(uint64_t a1)
{
  *a1 = off_101F56A90;
  xpc_release(*(a1 + 72));
  *(a1 + 72) = 0;
  sub_1006646F0(a1 + 40);
  sub_100005978((a1 + 32));
  sub_10001021C((a1 + 16));
  return a1;
}

void sub_101608314(uint64_t a1)
{
  *a1 = off_101F56A90;
  xpc_release(*(a1 + 72));
  *(a1 + 72) = 0;
  sub_1006646F0(a1 + 40);
  sub_100005978((a1 + 32));
  sub_10001021C((a1 + 16));

  operator delete();
}

void sub_101608444(_Unwind_Exception *a1)
{
  sub_100005978(v1 + 4);
  sub_10001021C(v1 + 2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

xpc_object_t sub_101608468(uint64_t a1, uint64_t a2)
{
  v4 = *(a1 + 8);
  *a2 = off_101F56A90;
  *(a2 + 8) = v4;
  sub_100010024((a2 + 16), (a1 + 16));
  *(a2 + 24) = *(a1 + 24);
  sub_10005C7A4((a2 + 32), (a1 + 32));
  sub_100669460(a2 + 40, a1 + 40);
  v5 = *(a1 + 72);
  *(a2 + 72) = v5;
  if (v5)
  {
    return xpc_retain(v5);
  }

  result = xpc_null_create();
  *(a2 + 72) = result;
  return result;
}

void sub_1016084F8(_Unwind_Exception *a1)
{
  sub_100005978((v1 + 32));
  sub_10001021C((v1 + 16));
  _Unwind_Resume(a1);
}

const void **sub_101608514(uint64_t a1)
{
  xpc_release(*(a1 + 72));
  *(a1 + 72) = 0;
  sub_1006646F0(a1 + 40);
  sub_100005978((a1 + 32));

  return sub_10001021C((a1 + 16));
}

void sub_101608568(uint64_t a1)
{
  xpc_release(*(a1 + 72));
  *(a1 + 72) = 0;
  sub_1006646F0(a1 + 40);
  sub_100005978((a1 + 32));
  sub_10001021C((a1 + 16));

  operator delete(a1);
}

const void **sub_1016085C4(uint64_t a1, CFTypeRef *a2)
{
  cf[0] = *a2;
  v3 = cf[0];
  *a2 = 0;
  v4 = *(a1 + 8);
  if (!v3)
  {
    v10 = *(v4 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Failed to load version.xml from the server", buf, 2u);
    }

    sub_101600BF8(v4);
  }

  v5 = *(v4 + 72);
  sub_100010024(&v14, (a1 + 16));
  v6 = *(a1 + 24);
  sub_10005C7A4(&v13, (a1 + 32));
  (*(*v5 + 56))(buf, v5, &v14, v6, 1, &v13, 0);
  v7 = *buf;
  memset(buf, 0, sizeof(buf));
  v8 = *(v4 + 152);
  *(v4 + 144) = v7;
  if (v8)
  {
    sub_100004A34(v8);
    if (*&buf[8])
    {
      sub_100004A34(*&buf[8]);
    }
  }

  sub_100005978(&v13);
  sub_10001021C(&v14);
  if (*(v4 + 144))
  {
    cf[1] = cf[0];
    if (cf[0])
    {
      CFRetain(cf[0]);
    }

    *buf = v4;
    sub_100669460(&buf[8], a1 + 40);
    v9 = *(a1 + 72);
    object = v9;
    if (v9)
    {
      xpc_retain(v9);
    }

    else
    {
      object = xpc_null_create();
    }

    v17 = 0;
    operator new();
  }

  return sub_10001021C(cf);
}

void sub_10160886C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, xpc_object_t object)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

uint64_t sub_1016088F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101608944(uint64_t a1)
{
  xpc_release(*(a1 + 40));
  *(a1 + 40) = 0;
  sub_1006646F0(a1 + 8);
  return a1;
}

uint64_t sub_101608980(uint64_t a1)
{
  *a1 = off_101F56B00;
  xpc_release(*(a1 + 48));
  *(a1 + 48) = 0;
  sub_1006646F0(a1 + 16);
  return a1;
}

void sub_1016089D8(uint64_t a1)
{
  *a1 = off_101F56B00;
  xpc_release(*(a1 + 48));
  *(a1 + 48) = 0;
  sub_1006646F0(a1 + 16);

  operator delete();
}

xpc_object_t sub_101608AEC(uint64_t a1, void *a2)
{
  v4 = *(a1 + 8);
  *a2 = off_101F56B00;
  a2[1] = v4;
  sub_100669460((a2 + 2), a1 + 16);
  v5 = *(a1 + 48);
  a2[6] = v5;
  if (v5)
  {
    return xpc_retain(v5);
  }

  result = xpc_null_create();
  a2[6] = result;
  return result;
}

uint64_t sub_101608B5C(uint64_t a1)
{
  xpc_release(*(a1 + 48));
  *(a1 + 48) = 0;

  return sub_1006646F0(a1 + 16);
}

void sub_101608BA0(xpc_object_t *a1)
{
  xpc_release(a1[6]);
  a1[6] = 0;
  sub_1006646F0((a1 + 2));

  operator delete(a1);
}

void sub_101608BEC(void *a1, __int128 *a2)
{
  v8 = *a2;
  v3 = v8;
  v9 = *(a2 + 2);
  *(a2 + 1) = 0;
  *(a2 + 2) = 0;
  *a2 = 0;
  v4 = a1[1];
  v5 = v3;
  if (v3 != *(&v3 + 1))
  {
    while (*(v5 + 8) != 4)
    {
      v5 += 16;
      if (v5 == *(&v3 + 1))
      {
        goto LABEL_9;
      }
    }
  }

  if (v5 != *(&v3 + 1))
  {
    v12 = xpc_BOOL_create(1);
    if (!v12)
    {
      v12 = xpc_null_create();
    }

    v11[0] = a1 + 6;
    v11[1] = off_101FB17B8;
    sub_10000F688(v11, &v12, &v13);
    xpc_release(v13);
    v13 = 0;
    xpc_release(v12);
    v12 = 0;
  }

LABEL_9:
  v6 = a1[6];
  object = v6;
  if (v6)
  {
    xpc_retain(v6);
  }

  else
  {
    object = xpc_null_create();
  }

  v7 = a1[5];
  if (v7)
  {
    (*(*v7 + 48))(v7, &object);
    xpc_release(object);
    object = 0;
    sub_101600BF8(v4);
  }

  sub_100022DB4();
}

void sub_101608D48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, uint64_t *a13)
{
  xpc_release(object);
  a13 = &a9;
  sub_100C116F0(&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_101608D70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_101608DBC(void **a1)
{
  v1 = *a1;
  v11 = a1;
  v12 = v1;
  v2 = *v1;
  object = 0;
  __p = v1 + 1;
  v14 = off_101FB17B0;
  sub_100048A24(&__p, &object);
  v3 = *(v2 + 80);
  *buf = object;
  if (object)
  {
    xpc_retain(object);
  }

  else
  {
    *buf = xpc_null_create();
  }

  xpc::bridge(&__p, buf, v4);
  sub_101462380(&v18, &__p);
  v5 = (*(*v3 + 72))(v3, &v18);
  sub_1002030AC(&v18);
  sub_10000A1EC(&__p);
  xpc_release(*buf);
  v16 = xpc_BOOL_create(v5);
  if (!v16)
  {
    v16 = xpc_null_create();
  }

  __p = v1 + 2;
  v14 = off_101FB17B8;
  sub_10000F688(&__p, &v16, &v17);
  xpc_release(v17);
  v17 = 0;
  xpc_release(v16);
  v16 = 0;
  v6 = *(v2 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string(&__p, (v1 + 2));
    v7 = v15 >= 0 ? &__p : __p;
    *buf = 136446210;
    *&buf[4] = v7;
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Reply dictionary after carrier bundle installation: %{public}s", buf, 0xCu);
    if (v15 < 0)
    {
      operator delete(__p);
    }
  }

  v8 = v1[2];
  __p = v8;
  if (v8)
  {
    xpc_retain(v8);
  }

  else
  {
    __p = xpc_null_create();
  }

  v9 = v1[6];
  if (!v9)
  {
    sub_100022DB4();
  }

  (*(*v9 + 48))(v9, &__p);
  xpc_release(__p);
  __p = 0;
  xpc_release(object);
  sub_1016090B8(&v12);
  return sub_1000049E0(&v11);
}

void sub_101609008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, xpc_object_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, xpc_object_t object)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

uint64_t *sub_1016090B8(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_1006646F0(v1 + 24);
    xpc_release(*(v1 + 16));
    *(v1 + 16) = 0;
    xpc_release(*(v1 + 8));
    *(v1 + 8) = 0;
    operator delete();
  }

  return result;
}

void sub_101609128(uint64_t **a1)
{
  v1 = *a1;
  v2 = **a1;
  cf = 0;
  *&v10[0] = v1 + 1;
  *(&v10[0] + 1) = off_101FB1888;
  sub_100006354(v10, &object);
  xpc::bridge(v12, &object, v3);
  sub_10006DD00(&cf, v12);
  sub_10000A1EC(v12);
  xpc_release(object);
  *&v10[0] = v1 + 1;
  *(&v10[0] + 1) = off_101FB1890;
  sub_100006354(v10, v12);
  xpc::dyn_cast_or_default(v12, 0, v4);
  xpc_release(v12[0]);
  (*(**(v2 + 72) + 48))(v10);
  v5 = v10[0];
  v10[0] = 0uLL;
  v6 = *(v2 + 104);
  *(v2 + 96) = v5;
  if (v6)
  {
    sub_100004A34(v6);
    if (*(&v10[0] + 1))
    {
      sub_100004A34(*(&v10[0] + 1));
    }
  }

  object = cf;
  if (cf)
  {
    CFRetain(cf);
  }

  sub_100669460(v10, (v1 + 3));
  v7 = v1[2];
  v11 = v7;
  if (v7)
  {
    xpc_retain(v7);
  }

  else
  {
    v11 = xpc_null_create();
  }

  v12[3] = 0;
  operator new();
}

void sub_101609360(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, xpc_object_t a11, char a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, xpc_object_t object)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

uint64_t *sub_101609420(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_1006646F0(v1 + 24);
    xpc_release(*(v1 + 16));
    *(v1 + 16) = 0;
    xpc_release(*(v1 + 8));
    *(v1 + 8) = 0;
    operator delete();
  }

  return result;
}

uint64_t sub_101609490(uint64_t a1)
{
  xpc_release(*(a1 + 32));
  *(a1 + 32) = 0;

  return sub_1006646F0(a1);
}

uint64_t sub_1016094D4(uint64_t a1)
{
  *a1 = off_101F56B90;
  xpc_release(*(a1 + 40));
  *(a1 + 40) = 0;
  sub_1006646F0(a1 + 8);
  return a1;
}

void sub_10160952C(uint64_t a1)
{
  *a1 = off_101F56B90;
  xpc_release(*(a1 + 40));
  *(a1 + 40) = 0;
  sub_1006646F0(a1 + 8);

  operator delete();
}

xpc_object_t sub_10160963C(uint64_t a1, void *a2)
{
  *a2 = off_101F56B90;
  sub_100669460((a2 + 1), a1 + 8);
  v4 = *(a1 + 40);
  a2[5] = v4;
  if (v4)
  {
    return xpc_retain(v4);
  }

  result = xpc_null_create();
  a2[5] = result;
  return result;
}

uint64_t sub_1016096A8(uint64_t a1)
{
  xpc_release(*(a1 + 40));
  *(a1 + 40) = 0;

  return sub_1006646F0(a1 + 8);
}

void sub_1016096EC(xpc_object_t *a1)
{
  xpc_release(a1[5]);
  a1[5] = 0;
  sub_1006646F0((a1 + 1));

  operator delete(a1);
}

void sub_101609738(uint64_t a1, uint64_t *a2)
{
  v9 = *a2;
  v3 = v9;
  v10 = *(a2 + 1);
  v4 = v10;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  v5 = v4;
  v6 = v3;
  if (v3 != v4)
  {
    v6 = v3;
    while (*(v6 + 8) != 4)
    {
      v6 += 16;
      if (v6 == v4)
      {
        v6 = v4;
        break;
      }
    }
  }

  v16 = xpc_BOOL_create(v6 != v4);
  if (!v16)
  {
    v16 = xpc_null_create();
  }

  v14 = (a1 + 40);
  v15 = off_101FB17B8;
  sub_10000F688(&v14, &v16, &v17);
  xpc_release(v17);
  v17 = 0;
  xpc_release(v16);
  v16 = 0;
  if (v3 != v5)
  {
    while ((*(v3 + 8) & 0xFD) != 5)
    {
      v3 += 16;
      if (v3 == v5)
      {
        v3 = v5;
        break;
      }
    }
  }

  v12 = xpc_BOOL_create(v3 != v5);
  if (!v12)
  {
    v12 = xpc_null_create();
  }

  v14 = (a1 + 40);
  v15 = off_101FB1898;
  sub_10000F688(&v14, &v12, &object);
  xpc_release(object);
  object = 0;
  xpc_release(v12);
  v7 = *(a1 + 40);
  v11 = v7;
  v12 = 0;
  if (v7)
  {
    xpc_retain(v7);
  }

  else
  {
    v11 = xpc_null_create();
  }

  v8 = *(a1 + 32);
  if (!v8)
  {
    sub_100022DB4();
  }

  (*(*v8 + 48))(v8, &v11);
  xpc_release(v11);
  v14 = &v9;
  sub_100C116F0(&v14);
}

void sub_101609914(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, uint64_t a13, uint64_t a14, uint64_t *a15)
{
  xpc_release(object);
  a15 = &a9;
  sub_100C116F0(&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_10160993C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_101609988(uint64_t **a1)
{
  v1 = *a1;
  v22 = a1;
  v23[0] = v1;
  v2 = *v1;
  if (!*(*v1 + 128))
  {
    sub_101600CDC(*v1, 1);
    object = 0;
    *buf = v1 + 1;
    *&buf[8] = off_101FB1798;
    sub_100048A24(buf, &object);
    v27 = object;
    if (object)
    {
      xpc_retain(object);
    }

    else
    {
      v27 = xpc_null_create();
    }

    sub_101604660((v2 + 40), &v27);
    xpc_release(v27);
    v26 = 0;
    v27 = 0;
    v35[0] = object;
    if (object)
    {
      xpc_retain(object);
    }

    else
    {
      v35[0] = xpc_null_create();
    }

    xpc::bridge(buf, v35, v6);
    sub_100010180(&v26, buf);
    sub_10000A1EC(buf);
    xpc_release(v35[0]);
    *buf = v1 + 1;
    *&buf[8] = off_101FB1878;
    sub_100006354(buf, v35);
    v8 = xpc::dyn_cast_or_default(v35, 0, v7);
    xpc_release(v35[0]);
    *buf = v1 + 1;
    *&buf[8] = off_101FB18B8;
    sub_100006354(buf, v35);
    v10 = xpc::dyn_cast_or_default(v35, 0, v9);
    xpc_release(v35[0]);
    if (v26)
    {
      cf = 0;
      sub_1010AF2C4((v2 + 56), &cf);
      if (cf)
      {
        (*(**(v2 + 72) + 96))(buf);
        v11 = *buf;
        memset(buf, 0, sizeof(buf));
        v12 = *(v2 + 120);
        *(v2 + 112) = v11;
        if (v12)
        {
          sub_100004A34(v12);
          if (*&buf[8])
          {
            sub_100004A34(*&buf[8]);
          }

          if (*(v2 + 112))
          {
LABEL_21:
            v24 = 0;
            sub_1010AF494(&v24);
            v23[2] = cf;
            if (cf)
            {
              CFRetain(cf);
            }

            v23[1] = v24;
            if (v24)
            {
              CFRetain(v24);
            }

            *buf = v2;
            *&buf[8] = v26;
            if (v26)
            {
              CFRetain(v26);
            }

            v30 = v8;
            v31 = cf;
            if (cf)
            {
              CFRetain(cf);
            }

            v32 = v10;
            v13 = v1[2];
            v33 = v13;
            if (v13)
            {
              xpc_retain(v13);
            }

            else
            {
              v33 = xpc_null_create();
            }

            sub_100669460(&v34, (v1 + 3));
            v35[3] = 0;
            operator new();
          }
        }

        else if (v11)
        {
          goto LABEL_21;
        }

        v18 = *(v2 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *buf = 0;
          _os_log_error_impl(&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to create downloader", buf, 2u);
        }

        sub_101600BF8(v2);
      }

      v16 = *(v2 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *buf = 0;
        _os_log_error_impl(&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Not a valid version.xml url", buf, 2u);
      }

      sub_101600CDC(v2, 0);
      v17 = v1[2];
      *buf = v17;
      if (v17)
      {
        xpc_retain(v17);
      }

      else
      {
        *buf = xpc_null_create();
      }

      v20 = v1[6];
      if (!v20)
      {
        sub_100022DB4();
      }

      (*(*v20 + 48))(v20, buf);
      xpc_release(*buf);
      *buf = 0;
      sub_100005978(&cf);
    }

    else
    {
      v14 = *(v2 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *buf = 0;
        _os_log_error_impl(&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "No matching criteria found", buf, 2u);
      }

      sub_101600CDC(v2, 0);
      v15 = v1[2];
      *buf = v15;
      if (v15)
      {
        xpc_retain(v15);
      }

      else
      {
        *buf = xpc_null_create();
      }

      v19 = v1[6];
      if (!v19)
      {
        sub_100022DB4();
      }

      (*(*v19 + 48))(v19, buf);
      xpc_release(*buf);
      *buf = 0;
    }

    sub_10001021C(&v26);
    xpc_release(object);
    goto LABEL_52;
  }

  v3 = *(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Carrier bundle update is already in progress, ignoring this request", buf, 2u);
  }

  v4 = v1[2];
  *buf = v4;
  if (v4)
  {
    xpc_retain(v4);
  }

  else
  {
    *buf = xpc_null_create();
  }

  v5 = v1[6];
  if (!v5)
  {
    sub_100022DB4();
  }

  (*(*v5 + 48))(v5, buf);
  xpc_release(*buf);
LABEL_52:
  sub_10160A1D4(v23);
  return sub_1000049E0(&v22);
}

void sub_101609FF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20, char a21, char a22, int a23, __int16 a24, char a25, char a26, int a27, __int16 a28, char a29, char a30, int a31, __int16 a32, char a33, char a34, xpc_object_t a35, xpc_object_t object, xpc_object_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, xpc_object_t a42)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

uint64_t *sub_10160A1D4(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_1006646F0(v1 + 24);
    xpc_release(*(v1 + 16));
    *(v1 + 16) = 0;
    xpc_release(*(v1 + 8));
    *(v1 + 8) = 0;
    operator delete();
  }

  return result;
}

uint64_t sub_10160A244(uint64_t a1)
{
  sub_1006646F0(a1 + 48);
  xpc_release(*(a1 + 40));
  *(a1 + 40) = 0;
  sub_100005978((a1 + 24));
  sub_10001021C((a1 + 8));
  return a1;
}

uint64_t sub_10160A290(uint64_t a1)
{
  *a1 = off_101F56C10;
  sub_1006646F0(a1 + 56);
  xpc_release(*(a1 + 48));
  *(a1 + 48) = 0;
  sub_100005978((a1 + 32));
  sub_10001021C((a1 + 16));
  return a1;
}

void sub_10160A2F4(uint64_t a1)
{
  *a1 = off_101F56C10;
  sub_1006646F0(a1 + 56);
  xpc_release(*(a1 + 48));
  *(a1 + 48) = 0;
  sub_100005978((a1 + 32));
  sub_10001021C((a1 + 16));

  operator delete();
}

const void **sub_10160A41C(uint64_t a1)
{
  sub_1006646F0(a1 + 56);
  xpc_release(*(a1 + 48));
  *(a1 + 48) = 0;
  sub_100005978((a1 + 32));

  return sub_10001021C((a1 + 16));
}

void sub_10160A470(uint64_t a1)
{
  sub_1006646F0(a1 + 56);
  xpc_release(*(a1 + 48));
  *(a1 + 48) = 0;
  sub_100005978((a1 + 32));
  sub_10001021C((a1 + 16));

  operator delete(a1);
}

void sub_10160A4CC(uint64_t a1, CFTypeRef *a2)
{
  cf = *a2;
  v3 = *a2;
  *a2 = 0;
  v4 = *(a1 + 8);
  if (v3)
  {
    v5 = *(v4 + 72);
    sub_100010024(&v13, (a1 + 16));
    v6 = *(a1 + 24);
    sub_10005C7A4(&v12, (a1 + 32));
    (*(*v5 + 40))(buf, v5, &v13, v6, &v12, *(a1 + 40));
    v7 = *buf;
    memset(buf, 0, sizeof(buf));
    v8 = *(v4 + 104);
    *(v4 + 96) = v7;
    if (v8)
    {
      sub_100004A34(v8);
      if (*&buf[8])
      {
        sub_100004A34(*&buf[8]);
      }
    }

    sub_100005978(&v12);
    sub_10001021C(&v13);
    if (cf)
    {
      CFRetain(cf);
    }

    sub_100669460(buf, a1 + 56);
    v9 = *(a1 + 48);
    object = v9;
    if (v9)
    {
      xpc_retain(v9);
    }

    else
    {
      object = xpc_null_create();
    }

    v16 = v4;
    v17 = 0;
    operator new();
  }

  v10 = *(v4 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Failed to load version.xml from the server", buf, 2u);
  }

  sub_101600BF8(v4);
}

void sub_10160A76C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, xpc_object_t object)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

uint64_t sub_10160A7F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10160A844(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  sub_100010024((a1 + 8), (a2 + 8));
  *(a1 + 16) = *(a2 + 16);
  sub_10005C7A4((a1 + 24), (a2 + 24));
  v4 = *(a2 + 32);
  v5 = *(a2 + 40);
  *(a1 + 40) = v5;
  *(a1 + 32) = v4;
  if (v5)
  {
    xpc_retain(v5);
  }

  else
  {
    *(a1 + 40) = xpc_null_create();
  }

  sub_100669460(a1 + 48, a2 + 48);
  return a1;
}

void sub_10160A8C8(_Unwind_Exception *a1)
{
  sub_100DC3ED0(v2);
  sub_100005978((v1 + 24));
  sub_10001021C((v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_10160A8F0(uint64_t a1)
{
  xpc_release(*(a1 + 32));
  *(a1 + 32) = 0;

  return sub_1006646F0(a1);
}

uint64_t sub_10160A934(uint64_t a1)
{
  *a1 = off_101F56C80;
  xpc_release(*(a1 + 40));
  *(a1 + 40) = 0;
  sub_1006646F0(a1 + 8);
  return a1;
}

void sub_10160A98C(uint64_t a1)
{
  *a1 = off_101F56C80;
  xpc_release(*(a1 + 40));
  *(a1 + 40) = 0;
  sub_1006646F0(a1 + 8);

  operator delete();
}

xpc_object_t sub_10160AAA4(uint64_t a1, void *a2)
{
  *a2 = off_101F56C80;
  sub_100669460((a2 + 1), a1 + 8);
  v4 = *(a1 + 40);
  a2[5] = v4;
  if (v4)
  {
    result = xpc_retain(v4);
  }

  else
  {
    result = xpc_null_create();
    a2[5] = result;
  }

  a2[6] = *(a1 + 48);
  return result;
}

uint64_t sub_10160AB18(uint64_t a1)
{
  xpc_release(*(a1 + 40));
  *(a1 + 40) = 0;

  return sub_1006646F0(a1 + 8);
}

void sub_10160AB5C(xpc_object_t *a1)
{
  xpc_release(a1[5]);
  a1[5] = 0;
  sub_1006646F0((a1 + 1));

  operator delete(a1);
}

void sub_10160ABA8(uint64_t a1, uint64_t *a2)
{
  v7 = *a2;
  v2 = v7;
  v8 = *(a2 + 1);
  v3 = v8;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  v4 = *(a1 + 48);
  if (v2 != v3)
  {
    v5 = v2 + 16;
    do
    {
      v6 = *(v5 - 8) == 4 || v5 == v3;
      v5 += 16;
    }

    while (!v6);
  }

  sub_101600BF8(v4);
}

void sub_10160ACF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, uint64_t *a13)
{
  xpc_release(object);
  a13 = &a9;
  sub_100C116F0(&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_10160AD20(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10160AD6C@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  v2 = **(result + 40);
  v4 = *(v2 + 128);
  v3 = *(v2 + 136);
  *a2 = v4;
  a2[1] = v3;
  if (v3)
  {
    atomic_fetch_add_explicit((v3 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_10160AD90(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v5);
  v2 = *(a1 + 32);
  v3 = v5;
  v5 = 0uLL;
  v4 = *(v2 + 8);
  *v2 = v3;
  if (v4)
  {
    sub_100004A34(v4);
  }

  if (*(&v5 + 1))
  {
    sub_100004A34(*(&v5 + 1));
  }
}

void sub_10160ADF8(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v5);
  v2 = *(a1 + 32);
  v3 = v5;
  v5 = 0uLL;
  v4 = *(v2 + 8);
  *v2 = v3;
  if (v4)
  {
    sub_100004A34(v4);
  }

  if (*(&v5 + 1))
  {
    sub_100004A34(*(&v5 + 1));
  }
}

uint64_t sub_10160AE8C(uint64_t a1, int a2, void *a3)
{
  ctu::OsLogContext::OsLogContext(&v8, kCtLoggingSystemName, "wea");
  ctu::OsLogLogger::OsLogLogger(v9, &v8);
  ctu::OsLogLogger::OsLogLogger(a1, v9);
  ctu::OsLogLogger::~OsLogLogger(v9);
  ctu::OsLogContext::~OsLogContext(&v8);
  *(a1 + 8) = 0xB00000000;
  *(a1 + 16) = 0;
  *(a1 + 24) = 0;
  v6 = a3[1];
  *(a1 + 32) = *a3;
  *(a1 + 40) = v6;
  if (v6)
  {
    atomic_fetch_add_explicit((v6 + 8), 1uLL, memory_order_relaxed);
  }

  ctu::TextConverter::TextConverter((a1 + 48));
  *(a1 + 88) = 0u;
  *(a1 + 76) = 0;
  *(a1 + 68) = 0;
  *(a1 + 104) = 0u;
  *(a1 + 120) = 0u;
  *(a1 + 136) = -1;
  *(a1 + 140) = 0;
  *(a1 + 144) = 0;
  *(a1 + 152) = 0;
  *(a1 + 156) = a2;
  *(a1 + 160) = 0;
  *(a1 + 168) = 0;
  ctu::TextConverter::pushConversion();
  return a1;
}

void sub_10160AF88(_Unwind_Exception *a1)
{
  v4 = *(v1 + 168);
  if (v4)
  {
    sub_100004A34(v4);
  }

  if (*(v1 + 135) < 0)
  {
    operator delete(*(v1 + 112));
  }

  if (*(v1 + 111) < 0)
  {
    operator delete(*v2);
  }

  ctu::TextConverter::~TextConverter((v1 + 48));
  v5 = *(v1 + 40);
  if (v5)
  {
    sub_100004A34(v5);
  }

  v6 = *(v1 + 24);
  if (v6)
  {
    sub_100004A34(v6);
  }

  ctu::OsLogLogger::~OsLogLogger(v1);
  _Unwind_Resume(a1);
}

BOOL sub_10160B010(uint64_t a1, char *__s, _BYTE *a3, int a4)
{
  if (a4 != 5)
  {
    if (a4 == 4)
    {
      LODWORD(v143.__r_.__value_.__l.__data_) = 0;
      LOBYTE(v141) = 0;
      v7 = strlen(__s);
      ctu::TextConverter::setSource((a1 + 48), __s, v7);
      *(a1 + 68) = ctu::TextConverter::nextCode((a1 + 48)) << 8;
      *(a1 + 68) |= ctu::TextConverter::nextCode((a1 + 48));
      *(a1 + 72) = ctu::TextConverter::nextCode((a1 + 48)) << 8;
      *(a1 + 72) |= ctu::TextConverter::nextCode((a1 + 48));
      *(a1 + 76) = ctu::TextConverter::nextCode((a1 + 48));
      ctu::TextConverter::decodeCbsDataCodingScheme();
      Code = ctu::TextConverter::nextCode((a1 + 48));
      v9 = Code;
      *(a1 + 80) = Code;
      if ((Code & 0xF) != 0 && (Code & 0xF0) != 0)
      {
        if (Code >> 4 > (Code & 0xFu))
        {
          goto LABEL_21;
        }
      }

      else
      {
        v9 = 17;
        *(a1 + 80) = 17;
      }

      v26 = *(a1 + 72);
      if (v26 == 4400)
      {
        memset(buf, 0, 24);
        sub_10000501C(buf, __s);
        SourceCount = ctu::TextConverter::getSourceCount((a1 + 48));
        v28 = buf[23];
        if (buf[23] < 0)
        {
          v28 = *&buf[8];
        }

        if (SourceCount <= v28)
        {
          v44 = ctu::TextConverter::getSourceCount((a1 + 48));
          std::string::erase(buf, 0, v44);
          sub_10160DB58();
        }

        v20 = *a1;
        if (!os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
        {
          goto LABEL_28;
        }

        LOWORD(__str.__r_.__value_.__l.__data_) = 0;
LABEL_290:
        _os_log_error_impl(&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to parse Wham. Invalid characters.", &__str, 2u);
LABEL_28:
        v22 = 0;
        if ((buf[23] & 0x80000000) != 0)
        {
          operator delete(*buf);
        }

        goto LABEL_248;
      }

      v29 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        v30 = *(a1 + 68);
        v31 = *(a1 + 76);
        *buf = 67109888;
        *&buf[4] = v26;
        *&buf[8] = 1024;
        *&buf[10] = v30;
        *&buf[14] = 1024;
        *&buf[16] = v31;
        *&buf[20] = 1024;
        *&buf[22] = v9;
        _os_log_impl(&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I GSM Message ID: %u, Serial Number: %u, DCS: %u, Page parameter: %u", buf, 0x1Au);
      }

      if (LODWORD(v143.__r_.__value_.__l.__data_) != 3)
      {
        if (LODWORD(v143.__r_.__value_.__l.__data_) == 2)
        {
          v46 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
          {
            *buf = 134217984;
            *&buf[4] = v7;
            _os_log_impl(&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I The message is in UCS2, the first 2 bytes may contain the language alphabet, PDU length: %zd", buf, 0xCu);
          }

          if (v141 == 1)
          {
            v47 = strlen(__s);
            if (v47 < 0x11)
            {
              v98 = *a1;
              if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
              {
                *buf = 0;
                _os_log_error_impl(&_mh_execute_header, v98, OS_LOG_TYPE_ERROR, "There are not enough bytes to proceed. Failed to parse the message", buf, 2u);
              }

              goto LABEL_219;
            }

            v48 = v47;
            memset(buf, 0, 24);
            sub_10000501C(&__str, __s);
            std::string::basic_string(buf, &__str, 0xCuLL, 4uLL, &v145);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(__str.__r_.__value_.__l.__data_);
            }

            memset(&__str, 0, sizeof(__str));
            sub_10160CF00(&__str, buf);
            v49 = sub_10160D4C0(&__str);
            v50 = *a1;
            if (v49)
            {
              if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
              {
                p_str = &__str;
                if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                {
                  p_str = __str.__r_.__value_.__r.__words[0];
                }

                LODWORD(v145.__r_.__value_.__l.__data_) = 136315138;
                *(v145.__r_.__value_.__r.__words + 4) = p_str;
                _os_log_impl(&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I Language encoding is valid, set to: %s", &v145, 0xCu);
              }

              std::string::operator=((a1 + 112), &__str);
              if (buf[23] >= 0)
              {
                v52 = buf;
              }

              else
              {
                v52 = *buf;
              }

              sub_10160D534(a1, v52, 1);
            }

            else
            {
              if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
              {
                LOWORD(v145.__r_.__value_.__l.__data_) = 0;
                _os_log_error_impl(&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "Language encoding invalid, detecting language from message body", &v145, 2u);
              }

              sub_10000501C(&v144, __s);
              std::string::basic_string(&v145, &v144, 4uLL, v48 - 4, v138);
              sub_10160D974(a1, &v145, 0x10uLL);
              if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(v145.__r_.__value_.__l.__data_);
              }

              if (SHIBYTE(v144.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(v144.__r_.__value_.__l.__data_);
              }
            }

            v99 = *a1;
            if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
            {
              sub_10000501C(&v145, __s + 16);
              v100 = (v145.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &v145 : v145.__r_.__value_.__r.__words[0];
              LODWORD(v144.__r_.__value_.__l.__data_) = 134218242;
              *(v144.__r_.__value_.__r.__words + 4) = 16;
              WORD2(v144.__r_.__value_.__r.__words[1]) = 2080;
              *(&v144.__r_.__value_.__r.__words[1] + 6) = v100;
              _os_log_impl(&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, "#I Advancing the message start byte by %lu bytes, Message %s", &v144, 0x16u);
              if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(v145.__r_.__value_.__l.__data_);
              }
            }

            ctu::TextConverter::setSource((a1 + 48), __s + 16, v48 - 16);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
          }

          else
          {
            v90 = *a1;
            if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
            {
              *buf = 0;
              _os_log_impl(&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "#I The decoding scheme is UCS2. But does not have language header", buf, 2u);
            }

            memset(buf, 0, 32);
            sub_10160DCD4(buf, *(a1 + 76));
            if (buf[24] == 1)
            {
              std::string::operator=((a1 + 112), buf);
              sub_10160D534(a1, "Dcs", 1);
            }

            else
            {
              sub_10000501C(&__str, __s);
              sub_10160D974(a1, &__str, 0x10uLL);
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(__str.__r_.__value_.__l.__data_);
              }
            }

            if (buf[24] != 1)
            {
              goto LABEL_219;
            }
          }

          if ((buf[23] & 0x80000000) != 0)
          {
            operator delete(*buf);
          }
        }

        else
        {
          if (LODWORD(v143.__r_.__value_.__l.__data_))
          {
            goto LABEL_220;
          }

          ctu::TextConverter::pushConversion();
        }

LABEL_219:
        ctu::TextConverter::pushConversion();
        ctu::TextConverter::pushConversion();
LABEL_220:
        ctu::TextConverter::readChars(buf, (a1 + 48), 0x7FFFFFFFuLL);
        v101 = (a1 + 88);
        if (*(a1 + 111) < 0)
        {
          operator delete(*v101);
        }

        *v101 = *buf;
        *(a1 + 104) = *&buf[16];
        v102 = *(a1 + 111);
        if ((v102 & 0x8000000000000000) != 0)
        {
          v106 = *(a1 + 88);
          v107 = *(a1 + 96);
          v103 = &v106[v107];
          v108 = memchr(v106, 0, v107);
          if (v108)
          {
            v105 = v108;
          }

          else
          {
            v105 = v103;
          }
        }

        else
        {
          v103 = v101 + v102;
          v104 = memchr((a1 + 88), 0, v102);
          if (v104)
          {
            v105 = v104;
          }

          else
          {
            v105 = v103;
          }

          v106 = (a1 + 88);
        }

        std::string::erase((a1 + 88), v105 - v106, v103 - v105);
        if (!LODWORD(v143.__r_.__value_.__l.__data_))
        {
          memset(buf, 0, 32);
          sub_10160DCD4(buf, *(a1 + 76));
          if (v141 == 1)
          {
            sub_10160E16C(&__str, a1 + 88);
            if (*(a1 + 135) < 0)
            {
              operator delete(*(a1 + 112));
            }

            *(a1 + 112) = __str;
          }

          else if (buf[24] == 1)
          {
            std::string::operator=((a1 + 112), buf);
            sub_10160D534(a1, "Dcs", 1);
          }

          if (buf[24] == 1 && (buf[23] & 0x80000000) != 0)
          {
            operator delete(*buf);
          }
        }

        sub_10160CCD8(a1);
        v109 = *a1;
        if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
        {
          if (*(a1 + 111) < 0)
          {
            v101 = *v101;
          }

          v110 = (a1 + 112);
          if (*(a1 + 135) < 0)
          {
            v110 = *v110;
          }

          *buf = 136446466;
          *&buf[4] = v101;
          *&buf[12] = 2082;
          *&buf[14] = v110;
          v97 = v109;
          goto LABEL_246;
        }

        goto LABEL_247;
      }

LABEL_21:
      v22 = 0;
      goto LABEL_248;
    }

    v21 = *a1;
    v22 = 0;
    if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_248;
    }

    *buf = 67109120;
    *&buf[4] = a4;
    v23 = "#I Unknown message type %u";
    v24 = v21;
LABEL_20:
    _os_log_impl(&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v23, buf, 8u);
    goto LABEL_21;
  }

  v141 = 0;
  v140 = 0;
  v10 = strlen(__s);
  ctu::TextConverter::setSource((a1 + 48), __s, v10);
  v11 = ctu::TextConverter::nextCode((a1 + 48));
  if (v11 != 1)
  {
    v25 = *a1;
    if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_21;
    }

    *buf = 67109120;
    *&buf[4] = v11;
    v23 = "#I Received a ETWS secondary message of type non-CBS: %d, discarding";
    v24 = v25;
    goto LABEL_20;
  }

  *(a1 + 72) = ctu::TextConverter::nextCode((a1 + 48)) << 8;
  *(a1 + 72) |= ctu::TextConverter::nextCode((a1 + 48));
  *(a1 + 68) = ctu::TextConverter::nextCode((a1 + 48)) << 8;
  *(a1 + 68) |= ctu::TextConverter::nextCode((a1 + 48));
  *(a1 + 76) = ctu::TextConverter::nextCode((a1 + 48));
  ctu::TextConverter::decodeCbsDataCodingScheme();
  *(a1 + 80) = 17;
  v12 = ctu::TextConverter::nextCode((a1 + 48));
  v13 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    v14 = *(a1 + 68);
    v15 = *(a1 + 72);
    v17 = *(a1 + 76);
    v16 = *(a1 + 80);
    *buf = 67110402;
    *&buf[4] = v15;
    *&buf[8] = 1024;
    *&buf[10] = v14;
    *&buf[14] = 1024;
    *&buf[16] = v17;
    *&buf[20] = 1024;
    *&buf[22] = v16;
    *&buf[26] = 2080;
    *&buf[28] = CSIBOOLAsString(v140);
    v147 = 1024;
    v148 = v12;
    _os_log_impl(&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I UMTS Message ID: %u, Serial Number: %u, DCS: %u, Page parameter: %u. Lang prefix present: %s Number of pages: %d", buf, 0x2Au);
  }

  if (*(a1 + 72) == 4400)
  {
    memset(buf, 0, 24);
    sub_10000501C(buf, __s);
    v18 = ctu::TextConverter::getSourceCount((a1 + 48));
    v19 = buf[23];
    if (buf[23] < 0)
    {
      v19 = *&buf[8];
    }

    if (v18 <= v19)
    {
      v45 = ctu::TextConverter::getSourceCount((a1 + 48));
      std::string::erase(buf, 0, v45);
      sub_10160DB58();
    }

    v20 = *a1;
    if (!os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_28;
    }

    LOWORD(__str.__r_.__value_.__l.__data_) = 0;
    goto LABEL_290;
  }

  ServiceMap = Registry::getServiceMap(*(a1 + 32));
  v33 = ServiceMap;
  if (v34 < 0)
  {
    v35 = (v34 & 0x7FFFFFFFFFFFFFFFLL);
    v36 = 5381;
    do
    {
      v34 = v36;
      v37 = *v35++;
      v36 = (33 * v36) ^ v37;
    }

    while (v37);
  }

  std::mutex::lock(ServiceMap);
  *buf = v34;
  v38 = sub_100009510(&v33[1].__m_.__sig, buf);
  if (!v38)
  {
    v40 = 0;
LABEL_64:
    std::mutex::unlock(v33);
    v39 = 0;
    v41 = 1;
    if (!v40)
    {
      goto LABEL_41;
    }

LABEL_65:
    v43 = (*(*v40 + 152))(v40, *(a1 + 156));
    v53 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      v54 = CSIBOOLAsString(v43);
      *buf = 136315138;
      *&buf[4] = v54;
      _os_log_impl(&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I Carrier Requirement to ignore invalid page :- %s", buf, 0xCu);
    }

    goto LABEL_67;
  }

  v40 = v38[3];
  v39 = v38[4];
  if (!v39)
  {
    goto LABEL_64;
  }

  atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v33);
  atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_100004A34(v39);
  v41 = 0;
  if (v40)
  {
    goto LABEL_65;
  }

LABEL_41:
  v42 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
  {
    *buf = 0;
    _os_log_error_impl(&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Invalid CellBroadcast Interface", buf, 2u);
  }

  LOBYTE(v43) = 0;
LABEL_67:
  v135 = v43;
  if ((v41 & 1) == 0)
  {
    sub_100004A34(v39);
  }

  if (v12 < 1)
  {
    goto LABEL_191;
  }

  v55 = 0;
  v136 = 166 * v12;
  v56 = 89;
  while (1)
  {
    v57 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 67109120;
      *&buf[4] = v56 - 82;
      _os_log_impl(&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I Processing message starting at position %d", buf, 8u);
      v57 = *a1;
    }

    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 67109120;
      *&buf[4] = v56;
      _os_log_impl(&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I Valid bytes is at position %d", buf, 8u);
    }

    v58 = strlen(__s);
    if (v58 < (v55 + 180))
    {
      v91 = v58;
      v92 = *a1;
      if (!os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
      {
        goto LABEL_190;
      }

      *buf = 134218240;
      *&buf[4] = v91;
      *&buf[12] = 2048;
      *&buf[14] = (v55 + 180);
      goto LABEL_292;
    }

    ctu::TextConverter::setSource((a1 + 48), &__s[(v55 + 178)], 2uLL);
    v59 = ctu::TextConverter::nextCode((a1 + 48));
    v60 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 67109120;
      *&buf[4] = v59;
      _os_log_impl(&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I Valid bytes in this page are: %d", buf, 8u);
    }

    v61 = 2 * v59;
    v62 = v55 + v61 + 14;
    v63 = strlen(__s);
    if (v63 < v62)
    {
      break;
    }

    memset(&__str, 0, sizeof(__str));
    if (v59 < 0)
    {
      sub_1000A2378();
    }

    if (v61 >= 0x17)
    {
      operator new();
    }

    *(&__str.__r_.__value_.__s + 23) = 2 * v59;
    if (v59)
    {
      memcpy(&__str, &__s[(v55 + 14)], v61);
    }

    __str.__r_.__value_.__s.__data_[2 * v59] = 0;
    v64 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      v65 = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        v65 = __str.__r_.__value_.__r.__words[0];
      }

      *buf = 136315138;
      *&buf[4] = v65;
      _os_log_impl(&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I Decoding hex string: %s", buf, 0xCu);
    }

    v138[0] = 0;
    v138[1] = 0;
    ctu::TextConverter::TextConverter(v138);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v66 = &__str;
    }

    else
    {
      v66 = __str.__r_.__value_.__r.__words[0];
    }

    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = __str.__r_.__value_.__l.__size_;
    }

    ctu::TextConverter::setSource(v138, v66, size);
    ctu::TextConverter::pushConversion();
    if (v141)
    {
      if (v141 == 2)
      {
        v69 = *a1;
        if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 134217984;
          *&buf[4] = v10;
          _os_log_impl(&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "#I The message is in UCS2, the first 2 bytes may contain the language alphabet, PDU length: %zd", buf, 0xCu);
        }

        v70 = v55 + 18;
        if (v140)
        {
          if (v10 > v70)
          {
            memset(buf, 0, 24);
            sub_10000501C(&v145, __s);
            std::string::basic_string(buf, &v145, v70 - 4, 4uLL, &v144);
            if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v145.__r_.__value_.__l.__data_);
            }

            memset(&v145, 0, sizeof(v145));
            sub_10160CF00(&v145, buf);
            v71 = sub_10160D4C0(&v145);
            v72 = *a1;
            if (v71)
            {
              if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
              {
                if ((v145.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                {
                  v73 = &v145;
                }

                else
                {
                  v73 = v145.__r_.__value_.__r.__words[0];
                }

                LODWORD(v144.__r_.__value_.__l.__data_) = 136315138;
                *(v144.__r_.__value_.__r.__words + 4) = v73;
                _os_log_impl(&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I Language encoding is valid, set to: %s", &v144, 0xCu);
              }

              std::string::operator=((a1 + 112), &v145);
              if (buf[23] >= 0)
              {
                v74 = buf;
              }

              else
              {
                v74 = *buf;
              }

              sub_10160D534(a1, v74, 1);
            }

            else
            {
              if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
              {
                LOWORD(v144.__r_.__value_.__l.__data_) = 0;
                _os_log_error_impl(&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "Language encoding invalid, detecting language from message body", &v144, 2u);
              }

              sub_10000501C(&v143, __s);
              std::string::basic_string(&v144, &v143, 4uLL, v10 - 4, &v142);
              sub_10160D974(a1, &v144, v55 + 18);
              if (SHIBYTE(v144.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(v144.__r_.__value_.__l.__data_);
              }

              if (SHIBYTE(v143.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(v143.__r_.__value_.__l.__data_);
              }
            }

            v77 = *a1;
            if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
            {
              sub_10000501C(&v144, &__s[v70]);
              v78 = &v144;
              if ((v144.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              {
                v78 = v144.__r_.__value_.__r.__words[0];
              }

              LODWORD(v143.__r_.__value_.__l.__data_) = 134218242;
              *(v143.__r_.__value_.__r.__words + 4) = v55 + 18;
              WORD2(v143.__r_.__value_.__r.__words[1]) = 2080;
              *(&v143.__r_.__value_.__r.__words[1] + 6) = v78;
              _os_log_impl(&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "#I Advancing the message start byte by %lu bytes, Message %s", &v143, 0x16u);
              if (SHIBYTE(v144.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(v144.__r_.__value_.__l.__data_);
              }
            }

            ctu::TextConverter::setSource(v138, &__s[v70], 0xA0uLL);
            if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v145.__r_.__value_.__l.__data_);
            }

            goto LABEL_139;
          }

          v76 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
          {
            *buf = 0;
            _os_log_impl(&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I There are not enough bytes to proceed. Failed to parse the message", buf, 2u);
          }
        }

        else
        {
          v75 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
          {
            *buf = 0;
            _os_log_impl(&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I The decoding scheme is UCS2. But does not have language header", buf, 2u);
          }

          memset(buf, 0, 32);
          sub_10160DCD4(buf, *(a1 + 76));
          if (buf[24] == 1)
          {
            std::string::operator=((a1 + 112), buf);
            sub_10160D534(a1, "Dcs", 1);
          }

          else
          {
            sub_10000501C(&v145, __s);
            sub_10160D974(a1, &v145, v55 + 18);
            if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v145.__r_.__value_.__l.__data_);
            }
          }

          if (buf[24] == 1)
          {
LABEL_139:
            if ((buf[23] & 0x80000000) != 0)
            {
              operator delete(*buf);
            }
          }
        }

        ctu::TextConverter::pushConversion();
        ctu::TextConverter::pushConversion();
        goto LABEL_142;
      }

      if (v141 == 3)
      {
        v68 = 0;
        goto LABEL_178;
      }
    }

    else
    {
      ctu::TextConverter::pushConversion();
      ctu::TextConverter::pushConversion();
      ctu::TextConverter::pushConversion();
    }

LABEL_142:
    memset(&v145, 0, sizeof(v145));
    ctu::TextConverter::readChars(&v145, v138, 0x7FFFFFFFuLL);
    if ((v145.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v79 = &v145;
    }

    else
    {
      v79 = v145.__r_.__value_.__r.__words[0];
    }

    if ((v145.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v80 = HIBYTE(v145.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v80 = v145.__r_.__value_.__l.__size_;
    }

    v81 = v79 + v80;
    if ((v145.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v82 = &v145 + HIBYTE(v145.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v82 = (v145.__r_.__value_.__r.__words[0] + v145.__r_.__value_.__l.__size_);
    }

    v83 = memchr(v79, 0, v80);
    if (v83)
    {
      v84 = v83;
    }

    else
    {
      v84 = v81;
    }

    std::string::erase(&v145, v84 - v79, v82 - v84);
    v85 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      v86 = HIBYTE(v145.__r_.__value_.__r.__words[2]);
      if ((v145.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v87 = &v145;
      }

      else
      {
        v86 = v145.__r_.__value_.__l.__size_;
        v87 = v145.__r_.__value_.__r.__words[0];
      }

      *buf = 134218242;
      *&buf[4] = v86;
      *&buf[12] = 2080;
      *&buf[14] = v87;
      _os_log_impl(&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I Decoded characters length after remaining valid bytes: %lu, body: %s", buf, 0x16u);
    }

    if (!v141)
    {
      memset(buf, 0, 32);
      sub_10160DCD4(buf, *(a1 + 76));
      if (v140)
      {
        sub_10160E16C(&v144, &v145);
        if (*(a1 + 135) < 0)
        {
          operator delete(*(a1 + 112));
        }

        *(a1 + 112) = v144;
      }

      else if (buf[24] == 1)
      {
        std::string::operator=((a1 + 112), buf);
        sub_10160D534(a1, "Dcs", 1);
      }

      if (buf[24] == 1 && (buf[23] & 0x80000000) != 0)
      {
        operator delete(*buf);
      }
    }

    if ((v145.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v88 = &v145;
    }

    else
    {
      v88 = v145.__r_.__value_.__r.__words[0];
    }

    if ((v145.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v89 = HIBYTE(v145.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v89 = v145.__r_.__value_.__l.__size_;
    }

    std::string::append((a1 + 88), v88, v89);
    if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v145.__r_.__value_.__l.__data_);
    }

    v68 = 1;
LABEL_178:
    ctu::TextConverter::~TextConverter(v138);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__str.__r_.__value_.__l.__data_);
    }

    if ((v68 & 1) == 0)
    {
      goto LABEL_21;
    }

    v55 += 166;
    v56 += 83;
    if (v136 == v55)
    {
      goto LABEL_191;
    }
  }

  v93 = v63;
  v92 = *a1;
  if (!os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
  {
    goto LABEL_190;
  }

  *buf = 134218240;
  *&buf[4] = v93;
  *&buf[12] = 2048;
  *&buf[14] = v62;
LABEL_292:
  _os_log_error_impl(&_mh_execute_header, v92, OS_LOG_TYPE_ERROR, "PDU length: %lu is lesser than expected: %lu", buf, 0x16u);
LABEL_190:
  if ((v135 & 1) == 0)
  {
    goto LABEL_21;
  }

LABEL_191:
  sub_10160CCD8(a1);
  v94 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    v95 = (a1 + 88);
    if (*(a1 + 111) < 0)
    {
      v95 = *v95;
    }

    v96 = (a1 + 112);
    if (*(a1 + 135) < 0)
    {
      v96 = *v96;
    }

    *buf = 136446466;
    *&buf[4] = v95;
    *&buf[12] = 2082;
    *&buf[14] = v96;
    v97 = v94;
LABEL_246:
    _os_log_impl(&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "#I Decoded Body: [%{public}s] Detected Lang: [%{public}s]", buf, 0x16u);
  }

LABEL_247:
  v22 = 1;
LABEL_248:
  if (*(a1 + 72) == 4400)
  {
    v111 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I Wham detected", buf, 2u);
    }

    if (!*(a1 + 160))
    {
      v112 = *a1;
      result = os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT);
      if (result)
      {
        *buf = 0;
        v114 = "#I Failed to decode Wham";
        goto LABEL_274;
      }

      return result;
    }

    return 1;
  }

  if (v22)
  {
    v115 = *(a1 + 68);
    if ((v115 >> 14) - 1 >= 2)
    {
      v116 = 0;
    }

    else
    {
      v116 = v115 >> 14;
    }

    *(a1 + 136) = v116;
    v117 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      v118 = asString();
      *buf = 136315138;
      *&buf[4] = v118;
      _os_log_impl(&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "#I Geographical scope: %s", buf, 0xCu);
      v115 = *(a1 + 68);
      v117 = *a1;
    }

    *(a1 + 140) = (v115 & 0xC000) == 0;
    if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 67109120;
      *&buf[4] = (v115 & 0xC000) == 0;
      _os_log_impl(&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "#I Is urgent: %d", buf, 8u);
      v115 = *(a1 + 68);
      v117 = *a1;
    }

    *(a1 + 144) = (v115 >> 4) & 0x3FF;
    if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 67109120;
      *&buf[4] = (v115 >> 4) & 0x3FF;
      _os_log_impl(&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "#I Message code: %d", buf, 8u);
      v115 = *(a1 + 68);
      v117 = *a1;
    }

    v119 = v115 & 0xF;
    *(a1 + 148) = v119;
    if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 67109120;
      *&buf[4] = v119;
      _os_log_impl(&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "#I Update number: %d", buf, 8u);
    }

    v120 = Registry::getServiceMap(*(a1 + 32));
    v121 = v120;
    if (v122 < 0)
    {
      v123 = (v122 & 0x7FFFFFFFFFFFFFFFLL);
      v124 = 5381;
      do
      {
        v122 = v124;
        v125 = *v123++;
        v124 = (33 * v124) ^ v125;
      }

      while (v125);
    }

    std::mutex::lock(v120);
    *buf = v122;
    v126 = sub_100009510(&v121[1].__m_.__sig, buf);
    if (v126)
    {
      v128 = v126[3];
      v127 = v126[4];
      if (v127)
      {
        atomic_fetch_add_explicit(&v127->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v121);
        atomic_fetch_add_explicit(&v127->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v127);
        v129 = 0;
LABEL_277:
        v130 = (*(*v128 + 128))(v128, *(a1 + 156), *(a1 + 72));
        if ((v129 & 1) == 0)
        {
          sub_100004A34(v127);
        }

        if (v130)
        {
          v131 = (*(a1 + 144) >> 9) & 1;
          *(a1 + 152) = (*(a1 + 144) & 0x200) != 0;
          v132 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
          {
            *buf = 67109120;
            *&buf[4] = v131;
            _os_log_impl(&_mh_execute_header, v132, OS_LOG_TYPE_DEFAULT, "#I Is this message a Emergency alert: %d", buf, 8u);
          }
        }

        if (a3 && *a3)
        {
          *(a1 + 8) = 1;
          operator new();
        }

        v133 = *a1;
        if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
        {
          v134 = CSIBOOLAsString(1);
          *buf = 136315138;
          *&buf[4] = v134;
          _os_log_impl(&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "#I Wea decode success: %s", buf, 0xCu);
        }

        return 1;
      }
    }

    else
    {
      v128 = 0;
    }

    std::mutex::unlock(v121);
    v127 = 0;
    v129 = 1;
    goto LABEL_277;
  }

  v112 = *a1;
  result = os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT);
  if (result)
  {
    *buf = 0;
    v114 = "#I PDU parsing has failed, discarding the message";
LABEL_274:
    _os_log_impl(&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, v114, buf, 2u);
    return 0;
  }

  return result;
}

void sub_10160CAC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, uint64_t a34, uint64_t a35, void *a36, uint64_t a37, int a38, __int16 a39, char a40, char a41, uint64_t a42, void *a43, uint64_t a44, int a45, __int16 a46, char a47, char a48)
{
  if (a32 < 0)
  {
    operator delete(__p);
  }

  if (*(v48 - 137) < 0)
  {
    operator delete(*(v48 - 160));
  }

  _Unwind_Resume(exception_object);
}

void sub_10160CCD8(uint64_t a1)
{
  if ((*(a1 + 80) & 0xE) != 0)
  {
    v2 = *a1;
    if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }

    LOWORD(v17) = 0;
    v3 = "#I Skipping trimming of extra chars on non-concatenated message";
    goto LABEL_4;
  }

  v6 = a1 + 88;
  v7 = *(a1 + 111);
  if (v7 < 0)
  {
    v8 = *(a1 + 88);
    v7 = *(a1 + 96);
  }

  else
  {
    v8 = a1 + 88;
  }

  v9 = v8 - 1;
  while (v7)
  {
    if (!memchr(" \n\r\t\f\v", *(v9 + v7--), 6uLL))
    {
      goto LABEL_15;
    }
  }

  v7 = -1;
LABEL_15:
  v11 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    v17 = 134217984;
    v18 = v7;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Last non cr is at position: %lu", &v17, 0xCu);
  }

  if (v7 == -1)
  {
    if (*(a1 + 111) < 0)
    {
      **(a1 + 88) = 0;
      *(a1 + 96) = 0;
    }

    else
    {
      *(a1 + 88) = 0;
      *(a1 + 111) = 0;
    }

    v2 = *a1;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      v3 = "#I There are no non-cr chars...";
LABEL_4:
      v4 = v2;
      v5 = 2;
LABEL_5:
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v3, &v17, v5);
    }
  }

  else
  {
    v12 = v7 + 1;
    v13 = *(a1 + 111);
    if ((v13 & 0x8000000000000000) != 0)
    {
      if (v12 >= *(a1 + 96))
      {
        return;
      }

      v14 = *(a1 + 88);
      *(a1 + 96) = v12;
    }

    else
    {
      if (v12 >= v13)
      {
        return;
      }

      *(a1 + 111) = v12;
      v14 = a1 + 88;
    }

    *(v14 + v12) = 0;
    v15 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(a1 + 111);
      if (v16 < 0)
      {
        v6 = *(a1 + 88);
        v16 = *(a1 + 96);
      }

      v17 = 134218242;
      v18 = v16;
      v19 = 2080;
      v20 = v6;
      v3 = "#I Decoded characters with cr removed length: %lu, body: %s";
      v4 = v15;
      v5 = 22;
      goto LABEL_5;
    }
  }
}

void sub_10160CF00(std::string *a1, uint64_t *a2)
{
  memset(&__str, 0, sizeof(__str));
  sub_10000501C(&__str, "");
  v4 = *(a2 + 23);
  v5 = a2[1];
  if ((v4 & 0x80000000) == 0)
  {
    v5 = *(a2 + 23);
  }

  if (v5)
  {
    v6 = 0;
    v7 = v4 >> 63;
    v8 = 1;
    do
    {
      if (v7)
      {
        v9 = *a2;
      }

      else
      {
        v9 = a2;
      }

      v10 = __toupper(*(v9 + v6)) - 48;
      v11 = "";
      if (v10 <= 0x16)
      {
        v11 = off_101F56E00[v10];
      }

      sub_10000501C(&v42, v11);
      if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v12 = &v42;
      }

      else
      {
        v12 = v42.__r_.__value_.__r.__words[0];
      }

      if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        size = HIBYTE(v42.__r_.__value_.__r.__words[2]);
      }

      else
      {
        size = v42.__r_.__value_.__l.__size_;
      }

      std::string::append(&__str, v12, size);
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v42.__r_.__value_.__l.__data_);
      }

      v6 = v8;
      v14 = *(a2 + 23);
      v7 = v14 >> 63;
      if ((v14 & 0x80000000) != 0)
      {
        v14 = a2[1];
      }
    }

    while (v14 > v8++);
  }

  memset(&v42, 0, sizeof(v42));
  std::string::basic_string(&v42, &__str, 0, 8uLL, &v41);
  memset(&v41, 0, sizeof(v41));
  std::string::basic_string(&v41, &__str, 8uLL, 8uLL, &v40);
  v16 = &v42;
  if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    v16 = v42.__r_.__value_.__r.__words[0];
  }

  std::string::push_back(&v41, v16->__r_.__value_.__s.__data_[0]);
  std::string::basic_string(&v40, &v42, 1uLL, 7uLL, &v39);
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v42.__r_.__value_.__l.__data_);
  }

  v42 = v40;
  std::string::basic_string(&v40, &v41, 2uLL, 7uLL, &v39);
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v41.__r_.__value_.__l.__data_);
  }

  v41 = v40;
  std::operator+<char>();
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v42.__r_.__value_.__l.__data_);
  }

  v42 = v40;
  std::operator+<char>();
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v41.__r_.__value_.__l.__data_);
  }

  v41 = v40;
  memset(&v40, 0, sizeof(v40));
  sub_10000501C(&v40, "");
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  sub_10000501C(a1, "");
  v17 = HIBYTE(v42.__r_.__value_.__r.__words[2]);
  if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    v17 = v42.__r_.__value_.__l.__size_;
  }

  if (v17)
  {
    for (i = 0; i < v23; i += 4)
    {
      memset(&v39, 0, sizeof(v39));
      std::string::basic_string(&v39, &v42, i, 4uLL, &__p);
      v19 = std::stoul(&v39, 0, 2);
      __p = 0;
      v37 = 0;
      v38 = 0;
      ctu::hex(&__p, v19, v20);
      if (v38 >= 0)
      {
        p_p = &__p;
      }

      else
      {
        p_p = __p;
      }

      if (v38 >= 0)
      {
        v22 = HIBYTE(v38);
      }

      else
      {
        v22 = v37;
      }

      std::string::append(&v40, p_p, v22);
      if (SHIBYTE(v38) < 0)
      {
        operator delete(__p);
      }

      if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v39.__r_.__value_.__l.__data_);
      }

      v23 = HIBYTE(v42.__r_.__value_.__r.__words[2]);
      if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        v23 = v42.__r_.__value_.__l.__size_;
      }
    }
  }

  sub_10160E5CC(&v39, &v40);
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v24 = &v39;
  }

  else
  {
    v24 = v39.__r_.__value_.__r.__words[0];
  }

  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v25 = HIBYTE(v39.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v25 = v39.__r_.__value_.__l.__size_;
  }

  std::string::append(a1, v24, v25);
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v39.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
  {
    v40.__r_.__value_.__l.__size_ = 0;
    v26 = v40.__r_.__value_.__r.__words[0];
  }

  else
  {
    *(&v40.__r_.__value_.__s + 23) = 0;
    v26 = &v40;
  }

  v26->__r_.__value_.__s.__data_[0] = 0;
  v27 = HIBYTE(v41.__r_.__value_.__r.__words[2]);
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    v27 = v41.__r_.__value_.__l.__size_;
  }

  if (v27)
  {
    for (j = 0; j < v33; j += 4)
    {
      memset(&v39, 0, sizeof(v39));
      std::string::basic_string(&v39, &v41, j, 4uLL, &__p);
      v29 = std::stoul(&v39, 0, 2);
      __p = 0;
      v37 = 0;
      v38 = 0;
      ctu::hex(&__p, v29, v30);
      if (v38 >= 0)
      {
        v31 = &__p;
      }

      else
      {
        v31 = __p;
      }

      if (v38 >= 0)
      {
        v32 = HIBYTE(v38);
      }

      else
      {
        v32 = v37;
      }

      std::string::append(&v40, v31, v32);
      if (SHIBYTE(v38) < 0)
      {
        operator delete(__p);
      }

      if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v39.__r_.__value_.__l.__data_);
      }

      v33 = HIBYTE(v41.__r_.__value_.__r.__words[2]);
      if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        v33 = v41.__r_.__value_.__l.__size_;
      }
    }
  }

  sub_10160E5CC(&v39, &v40);
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v34 = &v39;
  }

  else
  {
    v34 = v39.__r_.__value_.__r.__words[0];
  }

  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v35 = HIBYTE(v39.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v35 = v39.__r_.__value_.__l.__size_;
  }

  std::string::append(a1, v34, v35);
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v39.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v40.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v41.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v42.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_10160D3D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  if (*(v33 + 23) < 0)
  {
    operator delete(*v33);
  }

  if (a27 < 0)
  {
    operator delete(a22);
  }

  if (a33 < 0)
  {
    operator delete(a28);
  }

  if (*(v34 - 73) < 0)
  {
    operator delete(*(v34 - 96));
  }

  if (*(v34 - 49) < 0)
  {
    operator delete(*(v34 - 72));
  }

  _Unwind_Resume(exception_object);
}

BOOL sub_10160D4C0(unsigned __int8 *a1)
{
  v1 = a1[23];
  v2 = v1;
  if ((v1 & 0x80u) != 0)
  {
    v1 = *(a1 + 1);
  }

  if (!v1)
  {
    return 1;
  }

  if (v2 >= 0)
  {
    v3 = a1;
  }

  else
  {
    v3 = *a1;
  }

  if (*v3 - 123 < 0xFFFFFFE6)
  {
    return 0;
  }

  v5 = 1;
  do
  {
    v6 = v5;
    if (v1 == v5)
    {
      break;
    }

    ++v5;
  }

  while (v3[v6] - 123 > 0xFFFFFFE5);
  return v6 >= v1;
}

void sub_10160D534(uint64_t a1, const char *a2, _BOOL4 a3)
{
  ServiceMap = Registry::getServiceMap(*(a1 + 32));
  v7 = ServiceMap;
  if (v8 < 0)
  {
    v9 = (v8 & 0x7FFFFFFFFFFFFFFFLL);
    v10 = 5381;
    do
    {
      v8 = v10;
      v11 = *v9++;
      v10 = (33 * v10) ^ v11;
    }

    while (v11);
  }

  std::mutex::lock(ServiceMap);
  *buf = v8;
  v12 = sub_100009510(&v7[1].__m_.__sig, buf);
  if (v12)
  {
    v14 = v12[3];
    v13 = v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v13);
      v15 = 0;
      if (!v14)
      {
        goto LABEL_7;
      }

      goto LABEL_11;
    }
  }

  else
  {
    v14 = 0;
  }

  std::mutex::unlock(v7);
  v13 = 0;
  v15 = 1;
  if (!v14)
  {
LABEL_7:
    v16 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "AnalyticsInterface not found.", buf, 2u);
    }

    goto LABEL_41;
  }

LABEL_11:
  v33 = 0;
  v17 = xpc_dictionary_create(0, 0, 0);
  v18 = v17;
  if (v17)
  {
    v33 = v17;
  }

  else
  {
    v18 = xpc_null_create();
    v33 = v18;
    if (!v18)
    {
      v19 = xpc_null_create();
      v18 = 0;
      goto LABEL_18;
    }
  }

  if (xpc_get_type(v18) != &_xpc_type_dictionary)
  {
    v19 = xpc_null_create();
LABEL_18:
    v33 = v19;
    goto LABEL_19;
  }

  xpc_retain(v18);
LABEL_19:
  xpc_release(v18);
  v31 = xpc_string_create(a2);
  if (!v31)
  {
    v31 = xpc_null_create();
  }

  *buf = &v33;
  *&buf[8] = "LanguageBytes";
  sub_10000F688(buf, &v31, &v32);
  xpc_release(v32);
  v32 = 0;
  xpc_release(v31);
  v31 = 0;
  if (a3)
  {
    if (*(a1 + 135) < 0)
    {
      sub_100005F2C(buf, *(a1 + 112), *(a1 + 120));
    }

    else
    {
      *buf = *(a1 + 112);
      v28 = *(a1 + 128);
    }
  }

  else
  {
    sub_10000501C(buf, "Invalid");
  }

  if (v28 >= 0)
  {
    v20 = buf;
  }

  else
  {
    v20 = *buf;
  }

  v29 = xpc_string_create(v20);
  if (!v29)
  {
    v29 = xpc_null_create();
  }

  v26[0] = &v33;
  v26[1] = "DetectedLanguage";
  sub_10000F688(v26, &v29, &object);
  xpc_release(object);
  object = 0;
  xpc_release(v29);
  v29 = 0;
  if (SHIBYTE(v28) < 0)
  {
    operator delete(*buf);
  }

  v24 = xpc_BOOL_create(a3);
  if (!v24)
  {
    v24 = xpc_null_create();
  }

  *buf = &v33;
  *&buf[8] = "isSuccess";
  sub_10000F688(buf, &v24, &v25);
  xpc_release(v25);
  v25 = 0;
  xpc_release(v24);
  v24 = 0;
  v22 = xpc_int64_create(*(a1 + 76));
  if (!v22)
  {
    v22 = xpc_null_create();
  }

  *buf = &v33;
  *&buf[8] = "DcsValue";
  sub_10000F688(buf, &v22, &v23);
  xpc_release(v23);
  v23 = 0;
  xpc_release(v22);
  v21 = v33;
  v22 = 0;
  if (v33)
  {
    xpc_retain(v33);
  }

  else
  {
    v21 = xpc_null_create();
  }

  (*(*v14 + 16))(v14, "commCenterCbPduLanguageDetection", &v21);
  xpc_release(v21);
  v21 = 0;
  xpc_release(v33);
LABEL_41:
  if ((v15 & 1) == 0)
  {
    sub_100004A34(v13);
  }
}

void sub_10160D8EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(*(v12 - 72));
  if ((v11 & 1) == 0)
  {
    sub_100004A34(v10);
  }

  _Unwind_Resume(a1);
}

void sub_10160D974(uint64_t a1, std::string *__str, std::string::size_type a3)
{
  size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) != 0)
  {
    size = __str->__r_.__value_.__l.__size_;
  }

  if (size <= a3)
  {
    v17 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "There are not enough bytes to proceed. Failed to parse the message", &__p, 2u);
    }
  }

  else
  {
    v5 = a3 - 4;
    v6 = size - 4;
    if (a3 - 4 >= size - 4)
    {
      goto LABEL_26;
    }

    v8 = 0;
    do
    {
      memset(&__p, 0, sizeof(__p));
      std::string::basic_string(&__p, __str, v5, 4uLL, &v19);
      v9 = std::stoul(&__p, 0, 16);
      v10 = qword_101FCAE80;
      if (qword_101FCAE80 != &qword_101FCAE88)
      {
        v11 = v9;
        do
        {
          if (v11 > *(v10 + 32) && v11 < *(v10 + 34))
          {
            std::string::operator=((a1 + 112), (v10 + 40));
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              p_p = &__p;
            }

            else
            {
              p_p = __p.__r_.__value_.__r.__words[0];
            }

            v8 = 1;
            sub_10160D534(a1, p_p, 1);
          }

          v14 = *(v10 + 8);
          if (v14)
          {
            do
            {
              v15 = v14;
              v14 = *v14;
            }

            while (v14);
          }

          else
          {
            do
            {
              v15 = *(v10 + 16);
              v16 = *v15 == v10;
              v10 = v15;
            }

            while (!v16);
          }

          v10 = v15;
        }

        while (v15 != &qword_101FCAE88);
      }

      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      v5 += 4;
    }

    while (v5 < v6);
    if ((v8 & 1) == 0)
    {
LABEL_26:
      sub_10160D534(a1, "Invalid", 0);
    }
  }
}

void sub_10160DB38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_10160DCD4(void *__dst, unsigned int a2)
{
  if ((atomic_load_explicit(&qword_101FCAE78, memory_order_acquire) & 1) == 0)
  {
    v9 = a2;
    v10 = __cxa_guard_acquire(&qword_101FCAE78);
    a2 = v9;
    if (v10)
    {
      v12[0] = 0;
      sub_10000501C(v13, "de");
      v14 = 1;
      sub_10000501C(v15, "en");
      v16 = 2;
      sub_10000501C(v17, "it");
      v18 = 3;
      sub_10000501C(v19, "fr");
      v20 = 4;
      sub_10000501C(v21, "es");
      v22 = 5;
      sub_10000501C(v23, "nl");
      v24 = 6;
      sub_10000501C(v25, "sv");
      v26 = 7;
      sub_10000501C(v27, "da");
      v28 = 8;
      sub_10000501C(v29, "pt");
      v30 = 9;
      sub_10000501C(v31, "fi");
      v32 = 10;
      sub_10000501C(v33, "no");
      v34 = 11;
      sub_10000501C(v35, "el");
      v36 = 12;
      sub_10000501C(v37, "tr");
      v38 = 13;
      sub_10000501C(v39, "hu");
      v40 = 14;
      sub_10000501C(v41, "pl");
      v42 = 32;
      sub_10000501C(v43, "cs");
      v44 = 33;
      sub_10000501C(v45, "he");
      v46 = 34;
      sub_10000501C(v47, "ar");
      v48 = 35;
      sub_10000501C(v49, "ru");
      v50 = 36;
      sub_10000501C(v51, "is");
      sub_10160E6FC(v12, 20);
      v11 = 160;
      do
      {
        if (SHIBYTE(v12[v11 - 1]) < 0)
        {
          operator delete(*&v12[v11 - 6]);
        }

        v11 -= 8;
      }

      while (v11 * 4);
      __cxa_atexit(sub_10160E6D0, &qword_101FCAE98, &_mh_execute_header);
      __cxa_guard_release(&qword_101FCAE78);
      a2 = v9;
    }
  }

  v3 = qword_101FCAEA0;
  if (!qword_101FCAEA0)
  {
LABEL_8:
    v6 = 0;
    *__dst = 0;
    goto LABEL_18;
  }

  v4 = qword_101FCAEA0;
  while (1)
  {
    v5 = *(v4 + 32);
    if (v5 <= a2)
    {
      break;
    }

LABEL_7:
    v4 = *v4;
    if (!v4)
    {
      goto LABEL_8;
    }
  }

  if (v5 < a2)
  {
    v4 += 8;
    goto LABEL_7;
  }

  while (1)
  {
    while (1)
    {
      v7 = *(v3 + 32);
      if (v7 <= a2)
      {
        break;
      }

      v3 = *v3;
      if (!v3)
      {
LABEL_19:
        sub_1000A58E4("map::at:  key not found");
      }
    }

    if (v7 >= a2)
    {
      break;
    }

    v3 = *(v3 + 8);
    if (!v3)
    {
      goto LABEL_19;
    }
  }

  if (*(v3 + 63) < 0)
  {
    sub_100005F2C(__dst, *(v3 + 40), *(v3 + 48));
  }

  else
  {
    v8 = *(v3 + 40);
    __dst[2] = *(v3 + 56);
    *__dst = v8;
  }

  v6 = 1;
LABEL_18:
  *(__dst + 24) = v6;
}

void sub_10160E0B0(_Unwind_Exception *a1)
{
  v3 = v1 + 616;
  v4 = -640;
  while (1)
  {
    if (*(v3 + 23) < 0)
    {
      operator delete(*v3);
    }

    v3 -= 32;
    v4 += 32;
    if (!v4)
    {
      __cxa_guard_abort(&qword_101FCAE78);
      _Unwind_Resume(a1);
    }
  }
}

std::string *sub_10160E16C(uint64_t a1, uint64_t a2)
{
  *a1 = 0;
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  result = sub_10000501C(a1, "");
  v5 = *(a2 + 23);
  if ((v5 & 0x80u) != 0)
  {
    v5 = *(a2 + 8);
  }

  if (v5 >= 4)
  {
    std::string::basic_string(&v6, a2, 0, 2uLL, &v7);
    if (*(a1 + 23) < 0)
    {
      operator delete(*a1);
    }

    *a1 = v6;
    return std::string::erase(a2, 0, 3uLL);
  }

  return result;
}

void sub_10160E210(_Unwind_Exception *exception_object)
{
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10160E230@<X0>(void *a1@<X8>)
{
  v32 = 0;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  *__p = 0u;
  v21 = 0u;
  v18 = 0u;
  *__src = 0u;
  v16 = 0u;
  v17 = 0u;
  v15 = 0u;
  sub_10000C320(&v15);
  v2 = sub_10000C030(&v16);
  v3 = v2;
  v4 = *v2;
  v5 = v2 + *(*v2 - 24);
  if (*(v5 + 36) == -1)
  {
    std::ios_base::getloc((v2 + *(*v2 - 24)));
    v6 = std::locale::use_facet(&v33, &std::ctype<char>::id);
    v7 = (v6->__vftable[2].~facet_0)(v6, 32);
    std::locale::~locale(&v33);
    *(v5 + 36) = v7;
    v4 = *v3;
  }

  *(v5 + 36) = 48;
  *(v3 + *(v4 - 24) + 24) = 4;
  v8 = std::ostream::operator<<();
  sub_10000C030(v8);
  v9 = std::ostream::operator<<();
  sub_10000C030(v9);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if ((BYTE8(v22) & 0x10) != 0)
  {
    v11 = v22;
    if (v22 < __src[1])
    {
      *&v22 = __src[1];
      v11 = __src[1];
    }

    v12 = __src[0];
  }

  else
  {
    if ((BYTE8(v22) & 8) == 0)
    {
      v10 = 0;
      goto LABEL_16;
    }

    v12 = *(&v17 + 1);
    v11 = *(&v18 + 1);
  }

  v10 = v11 - v12;
  if ((v11 - v12) >= 0x7FFFFFFFFFFFFFF8)
  {
    sub_1000A2378();
  }

  if (v10 >= 0x17)
  {
    operator new();
  }

  *(a1 + 23) = v10;
  if (v10)
  {
    memmove(a1, v12, v10);
  }

LABEL_16:
  *(a1 + v10) = 0;
  *&v16 = v13;
  if (SHIBYTE(v21) < 0)
  {
    operator delete(__p[1]);
  }

  std::locale::~locale(&v17);
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10160E58C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::ios::~ios();
  _Unwind_Resume(a1);
}

void sub_10160E5CC(std::string *a1, uint64_t a2)
{
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  sub_10000501C(a1, "");
  v4 = *(a2 + 23);
  if ((v4 & 0x80u) != 0)
  {
    v4 = *(a2 + 8);
  }

  if (v4)
  {
    for (i = 0; i < v7; i += 2)
    {
      memset(&__p, 0, sizeof(__p));
      std::string::basic_string(&__p, a2, i, 2uLL, &v9);
      v6 = std::stoul(&__p, 0, 16);
      std::string::push_back(a1, v6);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      v7 = *(a2 + 23);
      if ((v7 & 0x80u) != 0)
      {
        v7 = *(a2 + 8);
      }
    }
  }
}

void sub_10160E69C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (*(v14 + 23) < 0)
  {
    operator delete(*v14);
  }

  _Unwind_Resume(exception_object);
}

void sub_10160E6FC(uint64_t a1, uint64_t a2)
{
  qword_101FCAEA8 = 0;
  qword_101FCAEA0 = 0;
  qword_101FCAE98 = &qword_101FCAEA0;
  if (a2)
  {
    operator new();
  }
}

void sub_10160E880(_Unwind_Exception *a1)
{
  operator delete(v2);
  sub_100077CD4(v1, *(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_10160E8C8(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F56D70;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10160E91C(uint64_t a1)
{
  v3 = (a1 + 72);
  sub_1000212F4(&v3);
  v3 = (a1 + 48);
  sub_1000212F4(&v3);
  v2 = *(a1 + 40);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 24));
}

void sub_10160E99C(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F56DC0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10160E9F0(uint64_t a1)
{
  v2 = (a1 + 32);
  sub_1000212F4(&v2);
  ctu::OsLogLogger::~OsLogLogger((a1 + 24));
}

void sub_10160EA34()
{
  sub_10000501C(v12, "hi");
  v14 = 159320320;
  if (SHIBYTE(v13) < 0)
  {
    sub_100005F2C(&v15, v12[0], v12[1]);
  }

  else
  {
    v15 = *v12;
    v16 = v13;
  }

  sub_10000501C(v10, "bn");
  v17 = 167709056;
  if (SHIBYTE(v11) < 0)
  {
    sub_100005F2C(&v18, v10[0], v10[1]);
  }

  else
  {
    v18 = *v10;
    v19 = v11;
  }

  sub_10000501C(v8, "kn");
  v20 = 218041472;
  if (SHIBYTE(v9) < 0)
  {
    sub_100005F2C(&v21, v8[0], v8[1]);
  }

  else
  {
    v21 = *v8;
    v22 = v9;
  }

  sub_10000501C(v6, "ta");
  v23 = 201264000;
  if (SHIBYTE(v7) < 0)
  {
    sub_100005F2C(&v24, v6[0], v6[1]);
  }

  else
  {
    v24 = *v6;
    v25 = v7;
  }

  sub_10000501C(v4, "te");
  v26 = 209652736;
  if (SHIBYTE(v5) < 0)
  {
    sub_100005F2C(&v27, v4[0], v4[1]);
  }

  else
  {
    v27 = *v4;
    v28 = v5;
  }

  sub_10000501C(v2, "en");
  v29 = 5898305;
  if (SHIBYTE(v3) < 0)
  {
    sub_100005F2C(&v30, v2[0], v2[1]);
  }

  else
  {
    v30 = *v2;
    v31 = v3;
  }

  sub_10000501C(__p, "en");
  v32 = 7995489;
  if (SHIBYTE(v1) < 0)
  {
    sub_100005F2C(&v33, __p[0], __p[1]);
  }

  else
  {
    v33 = *__p;
    v34 = v1;
  }

  qword_101FCAE90 = 0;
  qword_101FCAE88 = 0;
  qword_101FCAE80 = &qword_101FCAE88;
  operator new();
}

void sub_10160EF24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, void *a34, uint64_t a35, int a36, __int16 a37, char a38, char a39, void *a40, uint64_t a41, int a42, __int16 a43, char a44, char a45, void *a46, uint64_t a47, int a48, __int16 a49, char a50, char a51, char a52, uint64_t a53, uint64_t a54, uint64_t a55, uint64_t a56, uint64_t a57, uint64_t a58, uint64_t a59, uint64_t a60, uint64_t a61, uint64_t a62, uint64_t a63)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  v73 = &a72;
  if (a21 < 0)
  {
    operator delete(a16);
  }

  if (a27 < 0)
  {
    operator delete(a22);
  }

  if (a33 < 0)
  {
    operator delete(a28);
  }

  if (a39 < 0)
  {
    operator delete(a34);
  }

  if (a45 < 0)
  {
    operator delete(a40);
  }

  if (a51 < 0)
  {
    operator delete(a46);
  }

  if (&a52 != &a72)
  {
    do
    {
      if (*(v73 - 1) < 0)
      {
        operator delete(*(v73 - 3));
      }

      v73 -= 32;
    }

    while (v73 != &a52);
  }

  _Unwind_Resume(exception_object);
}

void sub_10160F0A4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, NSObject **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  ctu::OsLogContext::OsLogContext(&v14, kCtLoggingSystemName, "5wi.lzl.ct");
  a1[2] = 0;
  a1[3] = 0;
  v11 = *a5;
  a1[4] = *a5;
  if (v11)
  {
    dispatch_retain(v11);
  }

  a1[5] = 0;
  ctu::OsLogLogger::OsLogLogger(v13, &v14);
  ctu::OsLogLogger::OsLogLogger((a1 + 6), v13);
  ctu::OsLogLogger::~OsLogLogger(v13);
  ctu::OsLogContext::~OsLogContext(&v14);
  v12 = *(a8 + 8);
  if (v12)
  {
    atomic_fetch_add_explicit((v12 + 16), 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((v12 + 16), 1uLL, memory_order_relaxed);
  }

  operator new();
}

void sub_10160F3DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, sd::IMSConnectivityHelperEventDelegate *a10, char a11, int a12, __int16 a13, char a14, char a15)
{
  v17 = v15[20];
  if (v17)
  {
    sub_100004A34(v17);
  }

  v18 = v15[18];
  if (v18)
  {
    sub_100004A34(v18);
  }

  v19 = v15[16];
  if (v19)
  {
    sub_100004A34(v19);
  }

  v20 = v15[14];
  if (v20)
  {
    sub_100004A34(v20);
  }

  v21 = v15[12];
  v15[12] = 0;
  if (v21)
  {
    (*(*v21 + 8))(v21);
  }

  v22 = v15[11];
  if (v22)
  {
    sub_100004A34(v22);
  }

  v23 = v15[9];
  if (v23)
  {
    sub_100004A34(v23);
  }

  v24 = v15[7];
  v15[7] = 0;
  if (v24)
  {
    (*(*v24 + 8))(v24);
  }

  ctu::OsLogLogger::~OsLogLogger((v15 + 6));
  sub_1000C0544(v15 + 2);
  sd::IMSConnectivityHelperEventDelegate::~IMSConnectivityHelperEventDelegate(a10);
  sd::IMSConnectivityHelperInterface::~IMSConnectivityHelperInterface(v15);
  _Unwind_Resume(a1);
}

void sub_10160F530(uint64_t a1)
{
  *a1 = off_101F56EC8;
  v2 = (a1 + 8);
  *(a1 + 8) = off_101F57008;
  v3 = *(a1 + 416);
  if (v3)
  {
    sub_100004A34(v3);
  }

  v4 = *(a1 + 400);
  *(a1 + 400) = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  if (*(a1 + 399) < 0)
  {
    operator delete(*(a1 + 376));
  }

  v14 = (a1 + 352);
  sub_10003CA58(&v14);
  v14 = (a1 + 328);
  sub_10003CA58(&v14);
  v14 = (a1 + 304);
  sub_10003CA58(&v14);
  v14 = (a1 + 280);
  sub_10003CA58(&v14);
  sub_100DE3E98(*(a1 + 264));
  v14 = (a1 + 232);
  sub_1000087B4(&v14);
  v5 = *(a1 + 224);
  if (v5)
  {
    sub_100004A34(v5);
  }

  if (*(a1 + 199) < 0)
  {
    operator delete(*(a1 + 176));
  }

  v6 = *(a1 + 160);
  if (v6)
  {
    sub_100004A34(v6);
  }

  v7 = *(a1 + 144);
  if (v7)
  {
    sub_100004A34(v7);
  }

  v8 = *(a1 + 128);
  if (v8)
  {
    sub_100004A34(v8);
  }

  v9 = *(a1 + 112);
  if (v9)
  {
    sub_100004A34(v9);
  }

  v10 = *(a1 + 96);
  *(a1 + 96) = 0;
  if (v10)
  {
    (*(*v10 + 8))(v10);
  }

  v11 = *(a1 + 88);
  if (v11)
  {
    sub_100004A34(v11);
  }

  v12 = *(a1 + 72);
  if (v12)
  {
    sub_100004A34(v12);
  }

  v13 = *(a1 + 56);
  *(a1 + 56) = 0;
  if (v13)
  {
    (*(*v13 + 8))(v13);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 48));
  sub_1000C0544((a1 + 16));
  sd::IMSConnectivityHelperEventDelegate::~IMSConnectivityHelperEventDelegate(v2);
  sd::IMSConnectivityHelperInterface::~IMSConnectivityHelperInterface(a1);
}

void sub_10160F728(uint64_t a1)
{
  sub_10160F530(a1);

  operator delete();
}

void sub_10160F760(uint64_t a1)
{
  sub_10160F530(a1 - 8);

  operator delete();
}

void sub_10160F79C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10160F8C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    (*(*a10 + 8))(a10);
  }

  if (v10)
  {
    operator delete();
  }

  _Unwind_Resume(exception_object);
}

void sub_10160F908(uint64_t a1, uint64_t *a2)
{
  v5 = *a2;
  v4 = a2[1];
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 8), 1uLL, memory_order_relaxed);
  }

  v6 = *(a1 + 144);
  *(a1 + 136) = v5;
  *(a1 + 144) = v4;
  if (v6)
  {
    sub_100004A34(v6);
  }

  (*(**(a1 + 104) + 200))(buf);
  v7 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(*buf + 52));
  if (v18)
  {
    sub_100004A34(v18);
  }

  v8 = *v7;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I start using IMSConnectivityHelperLazuli", buf, 2u);
  }

  v9 = *a2;
  (*(**(a1 + 104) + 200))(buf);
  v10 = *(a1 + 24);
  if (v10)
  {
    v11 = *buf;
    v12 = *(a1 + 16);
    v13 = std::__shared_weak_count::lock(v10);
    if (v13)
    {
      v14 = v12 + 8;
      if (!v12)
      {
        v14 = 0;
      }

      v15 = v14;
      v16 = v13;
      (*(*v9 + 40))(v9, v11 + 24, &v15);
      if (v16)
      {
        sub_100004A34(v16);
      }

      if (v18)
      {
        sub_100004A34(v18);
      }

      sub_10160FBD8(a1);
    }
  }

  sub_100013CC4();
}

void sub_10160FBA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  if (a12)
  {
    sub_100004A34(a12);
  }

  _Unwind_Resume(exception_object);
}

void sub_10160FBD8(uint64_t a1)
{
  (*(**(a1 + 104) + 200))(&v8);
  v2 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(v8 + 52));
  if (v9)
  {
    sub_100004A34(v9);
  }

  v3 = *v2;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8) = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I resend IMS Pref and proxy", &v8, 2u);
  }

  *(a1 + 204) = 0;
  v4 = *(a1 + 416);
  *(a1 + 408) = 0;
  *(a1 + 416) = 0;
  if (v4)
  {
    sub_100004A34(v4);
  }

  v5 = *(a1 + 24);
  if (v5)
  {
    v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v6);
      v7 = *(a1 + 24);
      if (v7)
      {
        if (std::__shared_weak_count::lock(v7))
        {
          operator new();
        }
      }

      sub_100013CC4();
    }
  }

  sub_100013CC4();
}

void sub_10160FDB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_10160FDD0(void **a1, uint64_t *a2)
{
  (*(*a1[13] + 200))(&v9);
  v4 = (*(*a1[7] + 16))(a1[7], *(v9 + 52));
  if (v10)
  {
    sub_100004A34(v10);
  }

  v5 = *v4;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I stop using IMSConnectivityHelperLazuli", &v9, 2u);
  }

  v6 = *a2;
  (*(*a1[13] + 200))(&v9);
  v7 = v9;
  v8 = ((*a1)[2])(a1);
  (*(*v6 + 48))(v6, v7 + 24, v8);
  if (v10)
  {
    sub_100004A34(v10);
  }

  sub_101610078(a1);
}

void sub_101610058(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_101610078(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v3);
      v4 = *(a1 + 24);
      if (v4)
      {
        if (std::__shared_weak_count::lock(v4))
        {
          operator new();
        }
      }

      sub_100013CC4();
    }
  }

  sub_100013CC4();
}

void sub_101610190(uint64_t a1)
{
  *(a1 + 212) = 2;
  v2 = *(a1 + 224);
  *(a1 + 216) = 0;
  *(a1 + 224) = 0;
  if (v2)
  {
    sub_100004A34(v2);
  }

  *(a1 + 209) = 0;
}

void sub_1016101CC(uint64_t a1)
{
  (*(**(a1 + 104) + 200))(buf);
  v2 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(*buf + 52));
  if (*v19)
  {
    sub_100004A34(*v19);
  }

  v3 = (*(**(a1 + 120) + 480))(*(a1 + 120), *(a1 + 204));
  v4 = *v2;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = asString();
    v6 = *(a1 + 204);
    *buf = 67109634;
    *&buf[4] = v3;
    *v19 = 2080;
    *&v19[2] = v5;
    v20 = 1024;
    v21 = v6;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I PdnBringUp: Attempting pdn bring up after %u seconds. Attempt [%s] # %u", buf, 0x18u);
  }

  Registry::getTimerService(buf, *(a1 + 64));
  v7 = *buf;
  sub_10000501C(__p, "PDP Retry timer");
  v8 = *(a1 + 32);
  object = v8;
  if (v8)
  {
    dispatch_retain(v8);
  }

  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_1016104EC;
  aBlock[3] = &unk_101F57098;
  aBlock[4] = a1;
  v13 = _Block_copy(aBlock);
  sub_100D23364(v7, __p, 1, 1000000 * v3, &object, &v13);
  v9 = v17;
  v17 = 0;
  v10 = *(a1 + 400);
  *(a1 + 400) = v9;
  if (v10)
  {
    (*(*v10 + 8))(v10);
    v11 = v17;
    v17 = 0;
    if (v11)
    {
      (*(*v11 + 8))(v11);
    }
  }

  if (v13)
  {
    _Block_release(v13);
  }

  if (object)
  {
    dispatch_release(object);
  }

  if (v16 < 0)
  {
    operator delete(__p[0]);
  }

  if (*v19)
  {
    sub_100004A34(*v19);
  }
}

void sub_101610480(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *aBlock, dispatch_object_t object, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016104EC(uint64_t a1)
{
  v1 = *(a1 + 32);
  sub_101610A04(v1);
  if (!(*(**(v1 + 104) + 104))(*(v1 + 104)))
  {
    *(v1 + 204) = 0;
    return;
  }

  (*(**(v1 + 104) + 200))(buf);
  v2 = (*(**(v1 + 56) + 16))(*(v1 + 56), *(*buf + 52));
  if (*&buf[8])
  {
    sub_100004A34(*&buf[8]);
  }

  if (validContextType())
  {
    v3 = *(v1 + 172);
  }

  else
  {
    v3 = *(v1 + 168);
    *(v1 + 172) = v3;
  }

  ++*(v1 + 204);
  if (!v3)
  {
    *(v1 + 212) = 0;
    if (!*(v1 + 216))
    {
      sub_1006CB7F4(buf);
    }

    ServiceMap = Registry::getServiceMap(*(v1 + 64));
    v5 = ServiceMap;
    if (v6 < 0)
    {
      v7 = (v6 & 0x7FFFFFFFFFFFFFFFLL);
      v8 = 5381;
      do
      {
        v6 = v8;
        v9 = *v7++;
        v8 = (33 * v8) ^ v9;
      }

      while (v9);
    }

    std::mutex::lock(ServiceMap);
    *buf = v6;
    v10 = sub_100009510(&v5[1].__m_.__sig, buf);
    if (!v10)
    {
      std::mutex::unlock(v5);
      return;
    }

    v12 = v10[3];
    v11 = v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v11);
      if (!v12)
      {
        goto LABEL_41;
      }
    }

    else
    {
      std::mutex::unlock(v5);
      if (!v12)
      {
        return;
      }
    }

    v26 = (*(*v12 + 808))(v12);
    v19 = *(v1 + 136);
    if (v19 && (*(*v19 + 408))(v19, &v26))
    {
      v20 = *v2;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        v21 = subscriber::asString();
        *buf = 136315138;
        *&buf[4] = v21;
        _os_log_impl(&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I PdnBringUp: Cellular Internet connection is already up on %s", buf, 0xCu);
      }

      *(v1 + 200) = 1;
      v22 = v26;
      (*(**(v1 + 104) + 200))(buf);
      v23 = *(*buf + 52);
      if (*&buf[8])
      {
        sub_100004A34(*&buf[8]);
      }

      sub_101610EAC(v1, v22 != v23, *(v1 + 212));
    }

    else
    {
      v24 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 0;
        _os_log_impl(&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I PdnBringUp: Attempting to activate Cellular Internet.", buf, 2u);
      }

      v25 = v26;
      sub_10000501C(buf, "Activating internet for SIP/TLS");
      (*(*v12 + 88))(v12, v25, 1, 1, buf, 0, 0);
      if (v28 < 0)
      {
        operator delete(*buf);
      }
    }

    if (!v11)
    {
      return;
    }

LABEL_41:
    sub_100004A34(v11);
    return;
  }

  if (v3 == 1)
  {
    if (*(v1 + 168) == 1)
    {
      *(v1 + 212) = 1;
      sub_101610EAC(v1, 1, 1);
      return;
    }

    v18 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      v15 = "#I PdnBringUp: Current transport preference is WiFi, but WiFi is not available, cannot activate.";
      v16 = v18;
      v17 = 2;
      goto LABEL_25;
    }
  }

  else
  {
    v13 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      v14 = asString();
      *buf = 136315138;
      *&buf[4] = v14;
      v15 = "#I PdnBringUp: Current transport preference is %s, cannot activate.";
      v16 = v13;
      v17 = 12;
LABEL_25:
      _os_log_impl(&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
    }
  }
}

void sub_1016109A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (v16)
  {
    sub_100004A34(v16);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_101610A04(uint64_t a1)
{
  result = *(a1 + 400);
  if (result)
  {
    (*(*result + 16))(result);
    result = *(a1 + 400);
    *(a1 + 400) = 0;
    if (result)
    {
      v3 = *(*result + 8);

      return v3();
    }
  }

  return result;
}

void sub_101610A98(uint64_t a1)
{
  (*(**(a1 + 104) + 200))(&v4);
  v2 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(v4 + 52));
  if (v5)
  {
    sub_100004A34(v5);
  }

  v3 = *v2;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4) = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Throttling PDN bringup", &v4, 2u);
  }

  ++*(a1 + 204);
}

void sub_101610B74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_101610B8C(uint64_t a1)
{
  (*(**(a1 + 104) + 200))(&v4);
  v2 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(v4 + 52));
  if (v5)
  {
    sub_100004A34(v5);
  }

  v3 = *v2;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4) = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Reset PDN bringup throttling", &v4, 2u);
  }

  *(a1 + 204) = 0;
}

void sub_101610C60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_101610C78(uint64_t a1)
{
  (*(**(a1 + 104) + 200))(&v10);
  v2 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(v10 + 52));
  if (*(&v10 + 1))
  {
    sub_100004A34(*(&v10 + 1));
  }

  if (validContextType())
  {
    v3 = *v2;
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }

    v4 = asString();
    LODWORD(v10) = 136315138;
    *(&v10 + 4) = v4;
    v5 = "#I PdnBringUp: Data is in activating or already up on %s";
    v6 = v3;
    v7 = 12;
    goto LABEL_13;
  }

  if (((*(*a1 + 152))(a1, 0) & 1) == 0)
  {
    v8 = *v2;
    if (!os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }

    LOWORD(v10) = 0;
    v5 = "#N PdnBringUp: No connectivity to activate PDN right now.";
    goto LABEL_12;
  }

  if (*(a1 + 400))
  {
    v8 = *v2;
    if (!os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }

    LOWORD(v10) = 0;
    v5 = "#I PdnBringUp: There is already Pdn bring up request on the queue. Do nothing";
LABEL_12:
    v6 = v8;
    v7 = 2;
LABEL_13:
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, &v10, v7);
    return;
  }

  if (*(a1 + 232) == *(a1 + 240))
  {
    v9 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v10) = 0;
      _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "P-CSCF is empty", &v10, 2u);
    }
  }

  else
  {
    sub_1016101CC(a1);
  }
}

void sub_101610E8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_101610EAC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(**(a1 + 104) + 200))(v13);
  v6 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(*v13 + 52));
  if (*&v13[8])
  {
    sub_100004A34(*&v13[8]);
  }

  if (*(a1 + 212) == a3)
  {
    *(a1 + 208) = a2;
    v7 = *v6;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = asString();
      v9 = "";
      if (*(a1 + 208) == 1 && !*(a1 + 212))
      {
        v9 = "[over cell]";
      }

      *v13 = 136315394;
      *&v13[4] = v8;
      *&v13[12] = 2080;
      *&v13[14] = v9;
      _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Data Connection %s%s is Up", v13, 0x16u);
    }

    sub_101611D18(a1, 0);
    (*(**(a1 + 104) + 48))(*(a1 + 104), a2, a3);
  }

  else
  {
    v10 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      v11 = asString();
      v12 = asString();
      *v13 = 136315394;
      *&v13[4] = v11;
      *&v13[12] = 2080;
      *&v13[14] = v12;
      _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Data Connection %s is Up, but expecting %s", v13, 0x16u);
    }
  }
}

void sub_1016110B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016110E0(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  if (*(a1 + 168) == 1)
  {
    std::string::operator=(a2, (a1 + 176));
    goto LABEL_23;
  }

  if (!*(a1 + 212))
  {
    ServiceMap = Registry::getServiceMap(*(a1 + 64));
    v5 = ServiceMap;
    if (v6 < 0)
    {
      v7 = (v6 & 0x7FFFFFFFFFFFFFFFLL);
      v8 = 5381;
      do
      {
        v6 = v8;
        v9 = *v7++;
        v8 = (33 * v8) ^ v9;
      }

      while (v9);
    }

    std::mutex::lock(ServiceMap);
    *buf = v6;
    v10 = sub_100009510(&v5[1].__m_.__sig, buf);
    if (v10)
    {
      v12 = v10[3];
      v11 = v10[4];
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v5);
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v11);
        v14 = 0;
        if (!v12)
        {
LABEL_21:
          if ((v14 & 1) == 0)
          {
            sub_100004A34(v11);
          }

          goto LABEL_23;
        }

LABEL_13:
        if (capabilities::ct::supportsGemini(v13))
        {
          v15 = (*(*v12 + 808))(v12);
          (*(*v12 + 128))(buf, v12, v15, 0);
          if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(a2->__r_.__value_.__l.__data_);
          }

          *&a2->__r_.__value_.__l.__data_ = *buf;
          a2->__r_.__value_.__r.__words[2] = v22;
        }

        else
        {
          (*(**(a1 + 104) + 200))(&v19);
          (*(*v12 + 128))(buf, v12, *(v19 + 52), 0);
          if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(a2->__r_.__value_.__l.__data_);
          }

          *&a2->__r_.__value_.__l.__data_ = *buf;
          a2->__r_.__value_.__r.__words[2] = v22;
          HIBYTE(v22) = 0;
          buf[0] = 0;
          if (v20)
          {
            sub_100004A34(v20);
          }
        }

        goto LABEL_21;
      }
    }

    else
    {
      v12 = 0;
    }

    std::mutex::unlock(v5);
    v11 = 0;
    v14 = 1;
    if (!v12)
    {
      goto LABEL_21;
    }

    goto LABEL_13;
  }

LABEL_23:
  (*(**(a1 + 104) + 200))(buf);
  v16 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(*buf + 52));
  if (*&buf[8])
  {
    sub_100004A34(*&buf[8]);
  }

  v17 = *v16;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v18 = a2;
    }

    else
    {
      v18 = a2->__r_.__value_.__r.__words[0];
    }

    *buf = 136315138;
    *&buf[4] = v18;
    _os_log_impl(&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I IMSNetworkInterface: %s", buf, 0xCu);
  }
}

void sub_101611414(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  if ((v14 & 1) == 0)
  {
    sub_100004A34(v13);
  }

  if (*(v12 + 23) < 0)
  {
    operator delete(*v12);
  }

  _Unwind_Resume(exception_object);
}

void sub_101611488(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void sub_101611494(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

BOOL sub_1016114A0(uint64_t a1, int a2)
{
  if (*(a1 + 168))
  {
    v3 = 1;
    if (!a2)
    {
      return v3;
    }
  }

  else
  {
    v3 = (*(a1 + 172) == 0) & *(a1 + 169);
    if (!a2)
    {
      return v3;
    }
  }

  (*(**(a1 + 104) + 200))(v11);
  v4 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(*v11 + 52));
  if (*&v11[8])
  {
    sub_100004A34(*&v11[8]);
  }

  v5 = *v4;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = asStringBool(v3);
    v7 = asStringBool(*(a1 + 168));
    v8 = asStringBool(*(a1 + 169));
    v9 = asString();
    *v11 = 136315906;
    *&v11[4] = v6;
    *&v11[12] = 2080;
    *&v11[14] = v7;
    v12 = 2080;
    v13 = v8;
    v14 = 2080;
    v15 = v9;
    _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Connectivity(%s): [WiFiAvailable(%s), CellInternetAvailable(%s), CurrentIMSIRatTransportType(%s)]", v11, 0x2Au);
  }

  return v3;
}

void sub_101611630(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_101611658(_DWORD *a1, BOOL a2, _BOOL4 a3, int a4)
{
  (*(**(a1 + 13) + 200))(v21);
  v8 = (*(**(a1 + 7) + 16))(*(a1 + 7), *(*v21 + 52));
  if (*&v21[8])
  {
    sub_100004A34(*&v21[8]);
  }

  v9 = *v8;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    v10 = asStringBool(*(a1 + 168));
    v11 = asStringBool(a2);
    v12 = asStringBool(*(a1 + 169));
    v13 = asStringBool(a3);
    v14 = asString();
    v15 = asString();
    *v21 = 136316418;
    *&v21[4] = v10;
    *&v21[12] = 2080;
    *&v21[14] = v11;
    v22 = 2080;
    v23 = v12;
    v24 = 2080;
    v25 = v13;
    v26 = 2080;
    v27 = v14;
    v28 = 2080;
    v29 = v15;
    _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Change Connectivity: WiFi: %s -> %s, cellInternetAvailable: %s -> %s, PreferredTransportType: %s -> %s", v21, 0x3Eu);
  }

  v16 = (*(*a1 + 152))(a1, 0);
  v17 = v16;
  if (a4)
  {
    v18 = 0;
  }

  else
  {
    v18 = a3;
  }

  v19 = a2 || v18;
  *(a1 + 168) = a2;
  *(a1 + 169) = a3;
  result = capabilities::ct::supportsCellRadio(v16);
  if (result)
  {
    if (a1[43] != a4)
    {
      sub_101610B8C(a1);
      if (*(a1 + 50))
      {
        sub_101610A04(a1);
        sub_1016101CC(a1);
      }

      result = (*(*a1 + 120))(a1);
    }

    a1[43] = a4;
  }

  if (v17 != v19)
  {
    return sub_1016118D8(a1);
  }

  return result;
}

void sub_1016118B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016118D8(void **a1)
{
  v2 = ((*a1)[19])(a1, 0);
  v3 = *a1[13];
  if (v2)
  {
    (*(v3 + 16))();
    v4 = *(*a1[13] + 32);

    return v4();
  }

  else
  {
    v6 = *(v3 + 24);

    return v6();
  }
}

void sub_1016119CC(uint64_t a1)
{
  (*(**(a1 + 104) + 200))(&v5);
  v2 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(v5 + 52));
  if (v6)
  {
    sub_100004A34(v6);
  }

  v3 = *v2;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5) = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Reset proxies", &v5, 2u);
  }

  sub_100DE3E98(*(a1 + 264));
  *(a1 + 264) = 0;
  *(a1 + 272) = 0;
  *(a1 + 256) = a1 + 264;
  sub_10003CAAC((a1 + 304));
  sub_10003CAAC((a1 + 280));
  sub_10003CAAC((a1 + 352));
  sub_10003CAAC((a1 + 328));
  if (*(a1 + 399) < 0)
  {
    **(a1 + 376) = 0;
    *(a1 + 384) = 0;
  }

  else
  {
    *(a1 + 376) = 0;
    *(a1 + 399) = 0;
  }

  v4 = *(a1 + 416);
  *(a1 + 408) = 0;
  *(a1 + 416) = 0;
  if (v4)
  {
    sub_100004A34(v4);
  }
}

void sub_101611B00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_101611B18(uint64_t a1)
{
  (*(**(a1 + 104) + 200))(&v8);
  v2 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(v8 + 52));
  if (v9)
  {
    sub_100004A34(v9);
  }

  v3 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8) = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Switch current transport and prefer different type if available", &v8, 2u);
  }

  v4 = *(a1 + 212);
  if (*(a1 + 208) != 1 || v4 != 0)
  {
    if (v4 == 1)
    {
      if (*(a1 + 169))
      {
        sub_101611658(a1, 0, 1, 0);
      }

      else
      {
        v7 = *v2;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v8) = 0;
          _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Cellular connection is not available at the moment. Set pending cell transport switch.", &v8, 2u);
        }

        *(a1 + 210) = 1;
      }

      return;
    }

    v6 = *v2;
    goto LABEL_17;
  }

  v6 = *v2;
  if (*(a1 + 168))
  {
LABEL_17:
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I There is no other transport to fallback. Ignore transport switch.", &v8, 2u);
    }

    return;
  }

  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8) = 0;
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Other transport is not available at the moment. Set pending transport sub switch.", &v8, 2u);
  }

  *(a1 + 209) = 1;
}

void sub_101611D00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_101611D18(uint64_t a1, int a2)
{
  Registry::getTimerService(&buf, *(a1 + 64));
  *(a1 + 424) = (**buf.__r_.__value_.__l.__data_)(buf.__r_.__value_.__r.__words[0]);
  if (buf.__r_.__value_.__l.__size_)
  {
    sub_100004A34(buf.__r_.__value_.__l.__size_);
  }

  (*(**(a1 + 104) + 200))(&buf);
  v4 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(buf.__r_.__value_.__r.__words[0] + 52));
  if (buf.__r_.__value_.__l.__size_)
  {
    sub_100004A34(buf.__r_.__value_.__l.__size_);
  }

  if (*(a1 + 232) == *(a1 + 240))
  {
    v6 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "P-CSCF is empty", &buf, 2u);
    }
  }

  else if (*(a1 + 272))
  {
    v5 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I P-CSCF address resolution is already in progress", &buf, 2u);
    }
  }

  else if (*(a1 + 304) == *(a1 + 312) && *(a1 + 280) == *(a1 + 288) && *(a1 + 328) == *(a1 + 336) && *(a1 + 352) == *(a1 + 360))
  {
    v7 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = a2;
      _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Starting P-CSCF resolution, attempt=%u", &buf, 8u);
    }

    if (!*(a1 + 408))
    {
      memset(&buf, 0, 16);
      ServiceMap = Registry::getServiceMap(*(a1 + 64));
      sub_101617F0C(&buf, ServiceMap);
      if (buf.__r_.__value_.__r.__words[0])
      {
        (*(*buf.__r_.__value_.__l.__data_ + 8))(__dst);
        v9 = *__dst;
        __dst[0] = 0;
        __dst[1] = 0;
        v10 = *(a1 + 416);
        *(a1 + 408) = v9;
        if (v10)
        {
          sub_100004A34(v10);
          if (__dst[1])
          {
            sub_100004A34(__dst[1]);
          }
        }
      }

      if (buf.__r_.__value_.__l.__size_)
      {
        sub_100004A34(buf.__r_.__value_.__l.__size_);
      }
    }

    __dst[0] = 0;
    __dst[1] = 0;
    v43 = 0;
    sub_1016146D4(__dst, a1);
    v11 = *(a1 + 232);
    for (i = *(a1 + 240); v11 != i; v11 = (v11 + 24))
    {
      memset(&__str, 0, sizeof(__str));
      if (*(v11 + 23) < 0)
      {
        sub_100005F2C(&__str, *v11, *(v11 + 1));
      }

      else
      {
        v13 = *v11;
        __str.__r_.__value_.__r.__words[2] = *(v11 + 2);
        *&__str.__r_.__value_.__l.__data_ = v13;
      }

      v14 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          p_str = &__str;
        }

        else
        {
          p_str = __str.__r_.__value_.__r.__words[0];
        }

        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(buf.__r_.__value_.__r.__words + 4) = p_str;
        _os_log_impl(&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I P-CSCF: %{public}s", &buf, 0xCu);
      }

      v40 = 0;
      memset(v39, 0, sizeof(v39));
      sub_101614AB8(v39, a1, &__str, &v40 + 1, &v40);
      size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        size = __str.__r_.__value_.__l.__size_;
      }

      if (size)
      {
        std::string::operator=((a1 + 376), &__str);
        if (!CSIPacketAddress::isZeroIP(v39))
        {
          goto LABEL_49;
        }

        v17 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          v17 = __str.__r_.__value_.__l.__size_;
        }

        if (v17)
        {
          v44 = 0uLL;
          v18 = *(a1 + 96);
          v19 = *(a1 + 32);
          object = v19;
          if (v19)
          {
            dispatch_retain(v19);
          }

          (*(*v18 + 80))(&v44, v18, &object);
          if (object)
          {
            dispatch_release(object);
          }

          v20 = v44;
          if (v44)
          {
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
            {
              sub_100005F2C(&buf, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
              v20 = v44;
            }

            else
            {
              buf = __str;
            }

            v48 = v20;
            v49 = *(&v44 + 1);
            if (*(&v44 + 1))
            {
              atomic_fetch_add_explicit((*(&v44 + 1) + 8), 1uLL, memory_order_relaxed);
            }

            sub_101617FD0(a1 + 256, &buf.__r_.__value_.__l.__data_);
            if (v49)
            {
              sub_100004A34(v49);
            }

            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(buf.__r_.__value_.__l.__data_);
            }

            v30 = *(a1 + 24);
            if (v30)
            {
              v31 = std::__shared_weak_count::lock(v30);
              if (v31)
              {
                atomic_fetch_add_explicit(&v31->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                sub_100004A34(v31);
                if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
                {
                  sub_100005F2C(&__p, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
                }

                else
                {
                  __p = __str;
                }

                v35 = HIDWORD(v40);
                v36 = v40;
                v37 = a2;
                v46 = 0;
                operator new();
              }
            }

            sub_100013CC4();
          }

          v27 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              v28 = &__str;
            }

            else
            {
              v28 = __str.__r_.__value_.__r.__words[0];
            }

            LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
            *(buf.__r_.__value_.__r.__words + 4) = v28;
            _os_log_impl(&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#N Failed to resolve P-CSCF %s", &buf, 0xCu);
          }

          if (*(&v44 + 1))
          {
            sub_100004A34(*(&v44 + 1));
          }
        }

        else
        {
LABEL_49:
          memset(&buf, 0, sizeof(buf));
          CSIPacketAddress::operator std::string();
          v21 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            p_buf = &buf;
            if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            {
              p_buf = buf.__r_.__value_.__r.__words[0];
            }

            LODWORD(v44) = 136446210;
            *(&v44 + 4) = p_buf;
            _os_log_impl(&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Adding raw address: %{public}s", &v44, 0xCu);
          }

          v44 = 0uLL;
          v45 = 0;
          CSIPacketAddress::CSIPacketAddress();
          if ((CSIPacketAddress::isZeroIP(&v44) & 1) == 0)
          {
            if (CSIPacketAddress::isIPv4(&v44))
            {
              v23 = *(a1 + 360);
              if (v23 >= *(a1 + 368))
              {
                v29 = sub_1016170A8(a1 + 352, &buf, &v40 + 1, &v40);
              }

              else
              {
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                {
                  sub_100005F2C(*(a1 + 360), buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
                }

                else
                {
                  v24 = *&buf.__r_.__value_.__l.__data_;
                  *(v23 + 16) = *(&buf.__r_.__value_.__l + 2);
                  *v23 = v24;
                }

                v32 = v40;
                *(v23 + 24) = HIDWORD(v40);
                *(v23 + 28) = v32;
                v29 = v23 + 32;
                *(a1 + 360) = v23 + 32;
              }

              *(a1 + 360) = v29;
            }

            else if (CSIPacketAddress::isIPv6(&v44))
            {
              v25 = *(a1 + 336);
              if (v25 >= *(a1 + 344))
              {
                v26 = sub_1016170A8(a1 + 328, &buf, &v40 + 1, &v40);
              }

              else
              {
                sub_101617028((a1 + 328), &buf, &v40 + 1, &v40);
                v26 = v25 + 32;
              }

              *(a1 + 336) = v26;
            }
          }

          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
        }
      }

      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
    }

    if (!*(a1 + 272))
    {
      v33 = *(a1 + 416);
      *(a1 + 408) = 0;
      *(a1 + 416) = 0;
      if (v33)
      {
        sub_100004A34(v33);
      }

      sub_1016127C8(a1);
    }

    if (SHIBYTE(v43) < 0)
    {
      operator delete(__dst[0]);
    }
  }

  else
  {
    sub_1016127C8(a1);
  }
}

void sub_101612528(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, dispatch_object_t object, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, void *__p, uint64_t a35, int a36, __int16 a37, char a38, char a39, uint64_t a40, uint64_t a41, uint64_t a42)
{
  v44 = *(v42 - 136);
  if (v44)
  {
    sub_100004A34(v44);
  }

  _Unwind_Resume(exception_object);
}

_DWORD *sub_10161261C(_DWORD *result, int a2)
{
  if (result[53] == a2)
  {
    v2 = result;
    (*(*result + 120))(result);
    sub_1016127C8(v2);
    (*(**(v2 + 104) + 200))(&v7);
    v3 = (*(**(v2 + 56) + 16))(*(v2 + 56), *(v7 + 52));
    if (*(&v7 + 1))
    {
      sub_100004A34(*(&v7 + 1));
    }

    v4 = *v3;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = asString();
      LODWORD(v7) = 136315138;
      *(&v7 + 4) = v5;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Data Connection %s is Down", &v7, 0xCu);
    }

    *(v2 + 208) = 0;
    *(v2 + 212) = 2;
    v6 = *(v2 + 224);
    *(v2 + 216) = 0;
    *(v2 + 224) = 0;
    if (v6)
    {
      sub_100004A34(v6);
    }

    return (*(**(v2 + 104) + 56))(*(v2 + 104));
  }

  return result;
}

void sub_1016127A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016127C8(uint64_t a1)
{
  v172 = 0;
  v173 = 0;
  v174 = 0;
  if (*(a1 + 168) == 1 && *(a1 + 172) == 1)
  {
    v2 = *(a1 + 304);
    for (i = *(a1 + 312); v2 != i; v2 += 2)
    {
      *buf = 0u;
      v171 = 0u;
      sub_1016173F0(buf, v2);
      __p[0] = 0;
      __p[1] = 0;
      v169 = 0;
      if (HIDWORD(v171))
      {
        if ((SBYTE7(v171) & 0x80u) == 0)
        {
          v3 = BYTE7(v171);
        }

        else
        {
          v3 = *&buf[8];
        }

        memset(&v167, 0, sizeof(v167));
        sub_1000677C4(&v167, v3 + 1);
        if ((v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v4 = &v167;
        }

        else
        {
          v4 = v167.__r_.__value_.__r.__words[0];
        }

        if (v3)
        {
          if ((SBYTE7(v171) & 0x80u) == 0)
          {
            v5 = buf;
          }

          else
          {
            v5 = *buf;
          }

          memmove(v4, v5, v3);
        }

        *(&v4->__r_.__value_.__l.__data_ + v3) = 58;
        std::to_string(&v166, HIDWORD(v171));
        if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v6 = &v166;
        }

        else
        {
          v6 = v166.__r_.__value_.__r.__words[0];
        }

        if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          size = HIBYTE(v166.__r_.__value_.__r.__words[2]);
        }

        else
        {
          size = v166.__r_.__value_.__l.__size_;
        }

        v8 = std::string::append(&v167, v6, size);
        v9 = *&v8->__r_.__value_.__l.__data_;
        v169 = v8->__r_.__value_.__r.__words[2];
        *__p = v9;
        v8->__r_.__value_.__l.__size_ = 0;
        v8->__r_.__value_.__r.__words[2] = 0;
        v8->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v166.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v166.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v167.__r_.__value_.__l.__data_);
        }
      }

      else if (SBYTE7(v171) < 0)
      {
        sub_100005F2C(__p, *buf, *&buf[8]);
      }

      else
      {
        *__p = *buf;
        v169 = v171;
      }

      v11 = v172;
      v10 = v173;
      if (v172 != v173)
      {
        if (v169 >= 0)
        {
          v12 = HIBYTE(v169);
        }

        else
        {
          v12 = __p[1];
        }

        if (v169 >= 0)
        {
          v13 = __p;
        }

        else
        {
          v13 = __p[0];
        }

        while (1)
        {
          v14 = *(v11 + 23);
          v15 = v14;
          if ((v14 & 0x80u) != 0)
          {
            v14 = *(v11 + 8);
          }

          if (v14 == v12)
          {
            v16 = v15 >= 0 ? v11 : *v11;
            if (!memcmp(v16, v13, v12))
            {
              break;
            }
          }

          v11 += 24;
          if (v11 == v10)
          {
            goto LABEL_46;
          }
        }
      }

      if (v11 == v10)
      {
LABEL_46:
        if (v10 >= v174)
        {
          v18 = sub_10016B30C(&v172, __p);
        }

        else
        {
          if (SHIBYTE(v169) < 0)
          {
            sub_100005F2C(v10, __p[0], __p[1]);
          }

          else
          {
            v17 = *__p;
            *(v10 + 16) = v169;
            *v10 = v17;
          }

          v18 = v10 + 24;
        }

        v173 = v18;
      }

      if (SHIBYTE(v169) < 0)
      {
        operator delete(__p[0]);
      }

      if (SBYTE7(v171) < 0)
      {
        operator delete(*buf);
      }
    }

    v20 = *(a1 + 352);
    for (j = *(a1 + 360); v20 != j; v20 += 2)
    {
      *buf = 0u;
      v171 = 0u;
      sub_1016173F0(buf, v20);
      __p[0] = 0;
      __p[1] = 0;
      v169 = 0;
      if (HIDWORD(v171))
      {
        if ((SBYTE7(v171) & 0x80u) == 0)
        {
          v21 = BYTE7(v171);
        }

        else
        {
          v21 = *&buf[8];
        }

        memset(&v167, 0, sizeof(v167));
        sub_1000677C4(&v167, v21 + 1);
        if ((v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v22 = &v167;
        }

        else
        {
          v22 = v167.__r_.__value_.__r.__words[0];
        }

        if (v21)
        {
          if ((SBYTE7(v171) & 0x80u) == 0)
          {
            v23 = buf;
          }

          else
          {
            v23 = *buf;
          }

          memmove(v22, v23, v21);
        }

        *(&v22->__r_.__value_.__l.__data_ + v21) = 58;
        std::to_string(&v166, HIDWORD(v171));
        if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v24 = &v166;
        }

        else
        {
          v24 = v166.__r_.__value_.__r.__words[0];
        }

        if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v25 = HIBYTE(v166.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v25 = v166.__r_.__value_.__l.__size_;
        }

        v26 = std::string::append(&v167, v24, v25);
        v27 = *&v26->__r_.__value_.__l.__data_;
        v169 = v26->__r_.__value_.__r.__words[2];
        *__p = v27;
        v26->__r_.__value_.__l.__size_ = 0;
        v26->__r_.__value_.__r.__words[2] = 0;
        v26->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v166.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v166.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v167.__r_.__value_.__l.__data_);
        }
      }

      else if (SBYTE7(v171) < 0)
      {
        sub_100005F2C(__p, *buf, *&buf[8]);
      }

      else
      {
        *__p = *buf;
        v169 = v171;
      }

      v29 = v172;
      v28 = v173;
      if (v172 != v173)
      {
        if (v169 >= 0)
        {
          v30 = HIBYTE(v169);
        }

        else
        {
          v30 = __p[1];
        }

        if (v169 >= 0)
        {
          v31 = __p;
        }

        else
        {
          v31 = __p[0];
        }

        while (1)
        {
          v32 = *(v29 + 23);
          v33 = v32;
          if ((v32 & 0x80u) != 0)
          {
            v32 = *(v29 + 8);
          }

          if (v32 == v30)
          {
            v34 = v33 >= 0 ? v29 : *v29;
            if (!memcmp(v34, v31, v30))
            {
              break;
            }
          }

          v29 += 24;
          if (v29 == v28)
          {
            goto LABEL_101;
          }
        }
      }

      if (v29 == v28)
      {
LABEL_101:
        if (v28 >= v174)
        {
          v36 = sub_10016B30C(&v172, __p);
        }

        else
        {
          if (SHIBYTE(v169) < 0)
          {
            sub_100005F2C(v28, __p[0], __p[1]);
          }

          else
          {
            v35 = *__p;
            *(v28 + 16) = v169;
            *v28 = v35;
          }

          v36 = v28 + 24;
        }

        v173 = v36;
      }

      if (SHIBYTE(v169) < 0)
      {
        operator delete(__p[0]);
      }

      if (SBYTE7(v171) < 0)
      {
        operator delete(*buf);
      }
    }

    v37 = *(a1 + 280);
    for (k = *(a1 + 288); v37 != k; v37 += 2)
    {
      *buf = 0u;
      v171 = 0u;
      sub_1016173F0(buf, v37);
      __p[0] = 0;
      __p[1] = 0;
      v169 = 0;
      if (HIDWORD(v171))
      {
        sub_10000501C(&v165, "[");
        if ((SBYTE7(v171) & 0x80u) == 0)
        {
          v39 = buf;
        }

        else
        {
          v39 = *buf;
        }

        if ((SBYTE7(v171) & 0x80u) == 0)
        {
          v40 = BYTE7(v171);
        }

        else
        {
          v40 = *&buf[8];
        }

        v41 = std::string::append(&v165, v39, v40);
        v42 = *&v41->__r_.__value_.__l.__data_;
        v166.__r_.__value_.__r.__words[2] = v41->__r_.__value_.__r.__words[2];
        *&v166.__r_.__value_.__l.__data_ = v42;
        v41->__r_.__value_.__l.__size_ = 0;
        v41->__r_.__value_.__r.__words[2] = 0;
        v41->__r_.__value_.__r.__words[0] = 0;
        v43 = std::string::append(&v166, "]:", 2uLL);
        v44 = *&v43->__r_.__value_.__l.__data_;
        v167.__r_.__value_.__r.__words[2] = v43->__r_.__value_.__r.__words[2];
        *&v167.__r_.__value_.__l.__data_ = v44;
        v43->__r_.__value_.__l.__size_ = 0;
        v43->__r_.__value_.__r.__words[2] = 0;
        v43->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v164, HIDWORD(v171));
        if ((v164.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v45 = &v164;
        }

        else
        {
          v45 = v164.__r_.__value_.__r.__words[0];
        }

        if ((v164.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v46 = HIBYTE(v164.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v46 = v164.__r_.__value_.__l.__size_;
        }

        v47 = std::string::append(&v167, v45, v46);
        v48 = *&v47->__r_.__value_.__l.__data_;
        v169 = v47->__r_.__value_.__r.__words[2];
        *__p = v48;
        v47->__r_.__value_.__l.__size_ = 0;
        v47->__r_.__value_.__r.__words[2] = 0;
        v47->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v164.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v167.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v166.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v166.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v165.__r_.__value_.__l.__data_);
        }
      }

      else if (SBYTE7(v171) < 0)
      {
        sub_100005F2C(__p, *buf, *&buf[8]);
      }

      else
      {
        *__p = *buf;
        v169 = v171;
      }

      v50 = v172;
      v49 = v173;
      if (v172 != v173)
      {
        if (v169 >= 0)
        {
          v51 = HIBYTE(v169);
        }

        else
        {
          v51 = __p[1];
        }

        if (v169 >= 0)
        {
          v52 = __p;
        }

        else
        {
          v52 = __p[0];
        }

        while (1)
        {
          v53 = *(v50 + 23);
          v54 = v53;
          if ((v53 & 0x80u) != 0)
          {
            v53 = *(v50 + 8);
          }

          if (v53 == v51)
          {
            v55 = v54 >= 0 ? v50 : *v50;
            if (!memcmp(v55, v52, v51))
            {
              break;
            }
          }

          v50 += 24;
          if (v50 == v49)
          {
            goto LABEL_155;
          }
        }
      }

      if (v50 == v49)
      {
LABEL_155:
        if (v49 >= v174)
        {
          v57 = sub_10016B30C(&v172, __p);
        }

        else
        {
          if (SHIBYTE(v169) < 0)
          {
            sub_100005F2C(v49, __p[0], __p[1]);
          }

          else
          {
            v56 = *__p;
            *(v49 + 16) = v169;
            *v49 = v56;
          }

          v57 = v49 + 24;
        }

        v173 = v57;
      }

      if (SHIBYTE(v169) < 0)
      {
        operator delete(__p[0]);
      }

      if (SBYTE7(v171) < 0)
      {
        operator delete(*buf);
      }
    }

    v58 = *(a1 + 328);
    for (m = *(a1 + 336); v58 != m; v58 += 2)
    {
      *buf = 0u;
      v171 = 0u;
      sub_1016173F0(buf, v58);
      __p[0] = 0;
      __p[1] = 0;
      v169 = 0;
      if (HIDWORD(v171))
      {
        sub_10000501C(&v165, "[");
        if ((SBYTE7(v171) & 0x80u) == 0)
        {
          v60 = buf;
        }

        else
        {
          v60 = *buf;
        }

        if ((SBYTE7(v171) & 0x80u) == 0)
        {
          v61 = BYTE7(v171);
        }

        else
        {
          v61 = *&buf[8];
        }

        v62 = std::string::append(&v165, v60, v61);
        v63 = *&v62->__r_.__value_.__l.__data_;
        v166.__r_.__value_.__r.__words[2] = v62->__r_.__value_.__r.__words[2];
        *&v166.__r_.__value_.__l.__data_ = v63;
        v62->__r_.__value_.__l.__size_ = 0;
        v62->__r_.__value_.__r.__words[2] = 0;
        v62->__r_.__value_.__r.__words[0] = 0;
        v64 = std::string::append(&v166, "]:", 2uLL);
        v65 = *&v64->__r_.__value_.__l.__data_;
        v167.__r_.__value_.__r.__words[2] = v64->__r_.__value_.__r.__words[2];
        *&v167.__r_.__value_.__l.__data_ = v65;
        v64->__r_.__value_.__l.__size_ = 0;
        v64->__r_.__value_.__r.__words[2] = 0;
        v64->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v164, HIDWORD(v171));
        if ((v164.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v66 = &v164;
        }

        else
        {
          v66 = v164.__r_.__value_.__r.__words[0];
        }

        if ((v164.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v67 = HIBYTE(v164.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v67 = v164.__r_.__value_.__l.__size_;
        }

        v68 = std::string::append(&v167, v66, v67);
        v69 = *&v68->__r_.__value_.__l.__data_;
        v169 = v68->__r_.__value_.__r.__words[2];
        *__p = v69;
        v68->__r_.__value_.__l.__size_ = 0;
        v68->__r_.__value_.__r.__words[2] = 0;
        v68->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v164.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v167.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v166.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v166.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v165.__r_.__value_.__l.__data_);
        }
      }

      else if (SBYTE7(v171) < 0)
      {
        sub_100005F2C(__p, *buf, *&buf[8]);
      }

      else
      {
        *__p = *buf;
        v169 = v171;
      }

      v71 = v172;
      v70 = v173;
      if (v172 != v173)
      {
        if (v169 >= 0)
        {
          v72 = HIBYTE(v169);
        }

        else
        {
          v72 = __p[1];
        }

        if (v169 >= 0)
        {
          v73 = __p;
        }

        else
        {
          v73 = __p[0];
        }

        while (1)
        {
          v74 = *(v71 + 23);
          v75 = v74;
          if ((v74 & 0x80u) != 0)
          {
            v74 = *(v71 + 8);
          }

          if (v74 == v72)
          {
            v76 = v75 >= 0 ? v71 : *v71;
            if (!memcmp(v76, v73, v72))
            {
              break;
            }
          }

          v71 += 24;
          if (v71 == v70)
          {
            goto LABEL_209;
          }
        }
      }

      if (v71 == v70)
      {
LABEL_209:
        if (v70 >= v174)
        {
          v78 = sub_10016B30C(&v172, __p);
        }

        else
        {
          if (SHIBYTE(v169) < 0)
          {
            sub_100005F2C(v70, __p[0], __p[1]);
          }

          else
          {
            v77 = *__p;
            *(v70 + 16) = v169;
            *v70 = v77;
          }

          v78 = v70 + 24;
        }

        v173 = v78;
      }

      if (SHIBYTE(v169) < 0)
      {
        operator delete(__p[0]);
      }

      if (SBYTE7(v171) < 0)
      {
        operator delete(*buf);
      }
    }
  }

  else
  {
    v79 = *(a1 + 280);
    for (n = *(a1 + 288); v79 != n; v79 += 2)
    {
      *buf = 0u;
      v171 = 0u;
      sub_1016173F0(buf, v79);
      __p[0] = 0;
      __p[1] = 0;
      v169 = 0;
      if (DWORD2(v171))
      {
        sub_10000501C(&v165, "[");
        if ((SBYTE7(v171) & 0x80u) == 0)
        {
          v81 = buf;
        }

        else
        {
          v81 = *buf;
        }

        if ((SBYTE7(v171) & 0x80u) == 0)
        {
          v82 = BYTE7(v171);
        }

        else
        {
          v82 = *&buf[8];
        }

        v83 = std::string::append(&v165, v81, v82);
        v84 = *&v83->__r_.__value_.__l.__data_;
        v166.__r_.__value_.__r.__words[2] = v83->__r_.__value_.__r.__words[2];
        *&v166.__r_.__value_.__l.__data_ = v84;
        v83->__r_.__value_.__l.__size_ = 0;
        v83->__r_.__value_.__r.__words[2] = 0;
        v83->__r_.__value_.__r.__words[0] = 0;
        v85 = std::string::append(&v166, "]:", 2uLL);
        v86 = *&v85->__r_.__value_.__l.__data_;
        v167.__r_.__value_.__r.__words[2] = v85->__r_.__value_.__r.__words[2];
        *&v167.__r_.__value_.__l.__data_ = v86;
        v85->__r_.__value_.__l.__size_ = 0;
        v85->__r_.__value_.__r.__words[2] = 0;
        v85->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v164, DWORD2(v171));
        if ((v164.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v87 = &v164;
        }

        else
        {
          v87 = v164.__r_.__value_.__r.__words[0];
        }

        if ((v164.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v88 = HIBYTE(v164.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v88 = v164.__r_.__value_.__l.__size_;
        }

        v89 = std::string::append(&v167, v87, v88);
        v90 = *&v89->__r_.__value_.__l.__data_;
        v169 = v89->__r_.__value_.__r.__words[2];
        *__p = v90;
        v89->__r_.__value_.__l.__size_ = 0;
        v89->__r_.__value_.__r.__words[2] = 0;
        v89->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v164.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v167.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v166.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v166.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v165.__r_.__value_.__l.__data_);
        }
      }

      else if (SBYTE7(v171) < 0)
      {
        sub_100005F2C(__p, *buf, *&buf[8]);
      }

      else
      {
        *__p = *buf;
        v169 = v171;
      }

      v92 = v172;
      v91 = v173;
      if (v172 != v173)
      {
        if (v169 >= 0)
        {
          v93 = HIBYTE(v169);
        }

        else
        {
          v93 = __p[1];
        }

        if (v169 >= 0)
        {
          v94 = __p;
        }

        else
        {
          v94 = __p[0];
        }

        while (1)
        {
          v95 = *(v92 + 23);
          v96 = v95;
          if ((v95 & 0x80u) != 0)
          {
            v95 = *(v92 + 8);
          }

          if (v95 == v93)
          {
            v97 = v96 >= 0 ? v92 : *v92;
            if (!memcmp(v97, v94, v93))
            {
              break;
            }
          }

          v92 += 24;
          if (v92 == v91)
          {
            goto LABEL_264;
          }
        }
      }

      if (v92 == v91)
      {
LABEL_264:
        if (v91 >= v174)
        {
          v99 = sub_10016B30C(&v172, __p);
        }

        else
        {
          if (SHIBYTE(v169) < 0)
          {
            sub_100005F2C(v91, __p[0], __p[1]);
          }

          else
          {
            v98 = *__p;
            *(v91 + 16) = v169;
            *v91 = v98;
          }

          v99 = v91 + 24;
        }

        v173 = v99;
      }

      if (SHIBYTE(v169) < 0)
      {
        operator delete(__p[0]);
      }

      if (SBYTE7(v171) < 0)
      {
        operator delete(*buf);
      }
    }

    v100 = *(a1 + 328);
    for (ii = *(a1 + 336); v100 != ii; v100 += 2)
    {
      *buf = 0u;
      v171 = 0u;
      sub_1016173F0(buf, v100);
      __p[0] = 0;
      __p[1] = 0;
      v169 = 0;
      if (DWORD2(v171))
      {
        sub_10000501C(&v165, "[");
        if ((SBYTE7(v171) & 0x80u) == 0)
        {
          v102 = buf;
        }

        else
        {
          v102 = *buf;
        }

        if ((SBYTE7(v171) & 0x80u) == 0)
        {
          v103 = BYTE7(v171);
        }

        else
        {
          v103 = *&buf[8];
        }

        v104 = std::string::append(&v165, v102, v103);
        v105 = *&v104->__r_.__value_.__l.__data_;
        v166.__r_.__value_.__r.__words[2] = v104->__r_.__value_.__r.__words[2];
        *&v166.__r_.__value_.__l.__data_ = v105;
        v104->__r_.__value_.__l.__size_ = 0;
        v104->__r_.__value_.__r.__words[2] = 0;
        v104->__r_.__value_.__r.__words[0] = 0;
        v106 = std::string::append(&v166, "]:", 2uLL);
        v107 = *&v106->__r_.__value_.__l.__data_;
        v167.__r_.__value_.__r.__words[2] = v106->__r_.__value_.__r.__words[2];
        *&v167.__r_.__value_.__l.__data_ = v107;
        v106->__r_.__value_.__l.__size_ = 0;
        v106->__r_.__value_.__r.__words[2] = 0;
        v106->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v164, DWORD2(v171));
        if ((v164.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v108 = &v164;
        }

        else
        {
          v108 = v164.__r_.__value_.__r.__words[0];
        }

        if ((v164.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v109 = HIBYTE(v164.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v109 = v164.__r_.__value_.__l.__size_;
        }

        v110 = std::string::append(&v167, v108, v109);
        v111 = *&v110->__r_.__value_.__l.__data_;
        v169 = v110->__r_.__value_.__r.__words[2];
        *__p = v111;
        v110->__r_.__value_.__l.__size_ = 0;
        v110->__r_.__value_.__r.__words[2] = 0;
        v110->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v164.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v167.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v166.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v166.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v165.__r_.__value_.__l.__data_);
        }
      }

      else if (SBYTE7(v171) < 0)
      {
        sub_100005F2C(__p, *buf, *&buf[8]);
      }

      else
      {
        *__p = *buf;
        v169 = v171;
      }

      v113 = v172;
      v112 = v173;
      if (v172 != v173)
      {
        if (v169 >= 0)
        {
          v114 = HIBYTE(v169);
        }

        else
        {
          v114 = __p[1];
        }

        if (v169 >= 0)
        {
          v115 = __p;
        }

        else
        {
          v115 = __p[0];
        }

        while (1)
        {
          v116 = *(v113 + 23);
          v117 = v116;
          if ((v116 & 0x80u) != 0)
          {
            v116 = *(v113 + 8);
          }

          if (v116 == v114)
          {
            v118 = v117 >= 0 ? v113 : *v113;
            if (!memcmp(v118, v115, v114))
            {
              break;
            }
          }

          v113 += 24;
          if (v113 == v112)
          {
            goto LABEL_318;
          }
        }
      }

      if (v113 == v112)
      {
LABEL_318:
        if (v112 >= v174)
        {
          v120 = sub_10016B30C(&v172, __p);
        }

        else
        {
          if (SHIBYTE(v169) < 0)
          {
            sub_100005F2C(v112, __p[0], __p[1]);
          }

          else
          {
            v119 = *__p;
            *(v112 + 16) = v169;
            *v112 = v119;
          }

          v120 = v112 + 24;
        }

        v173 = v120;
      }

      if (SHIBYTE(v169) < 0)
      {
        operator delete(__p[0]);
      }

      if (SBYTE7(v171) < 0)
      {
        operator delete(*buf);
      }
    }

    v122 = *(a1 + 304);
    for (jj = *(a1 + 312); v122 != jj; v122 += 2)
    {
      *buf = 0u;
      v171 = 0u;
      sub_1016173F0(buf, v122);
      __p[0] = 0;
      __p[1] = 0;
      v169 = 0;
      if (DWORD2(v171))
      {
        if ((SBYTE7(v171) & 0x80u) == 0)
        {
          v123 = BYTE7(v171);
        }

        else
        {
          v123 = *&buf[8];
        }

        memset(&v167, 0, sizeof(v167));
        sub_1000677C4(&v167, v123 + 1);
        if ((v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v124 = &v167;
        }

        else
        {
          v124 = v167.__r_.__value_.__r.__words[0];
        }

        if (v123)
        {
          if ((SBYTE7(v171) & 0x80u) == 0)
          {
            v125 = buf;
          }

          else
          {
            v125 = *buf;
          }

          memmove(v124, v125, v123);
        }

        *(&v124->__r_.__value_.__l.__data_ + v123) = 58;
        std::to_string(&v166, DWORD2(v171));
        if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v126 = &v166;
        }

        else
        {
          v126 = v166.__r_.__value_.__r.__words[0];
        }

        if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v127 = HIBYTE(v166.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v127 = v166.__r_.__value_.__l.__size_;
        }

        v128 = std::string::append(&v167, v126, v127);
        v129 = *&v128->__r_.__value_.__l.__data_;
        v169 = v128->__r_.__value_.__r.__words[2];
        *__p = v129;
        v128->__r_.__value_.__l.__size_ = 0;
        v128->__r_.__value_.__r.__words[2] = 0;
        v128->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v166.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v166.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v167.__r_.__value_.__l.__data_);
        }
      }

      else if (SBYTE7(v171) < 0)
      {
        sub_100005F2C(__p, *buf, *&buf[8]);
      }

      else
      {
        *__p = *buf;
        v169 = v171;
      }

      v131 = v172;
      v130 = v173;
      if (v172 != v173)
      {
        if (v169 >= 0)
        {
          v132 = HIBYTE(v169);
        }

        else
        {
          v132 = __p[1];
        }

        if (v169 >= 0)
        {
          v133 = __p;
        }

        else
        {
          v133 = __p[0];
        }

        while (1)
        {
          v134 = *(v131 + 23);
          v135 = v134;
          if ((v134 & 0x80u) != 0)
          {
            v134 = *(v131 + 8);
          }

          if (v134 == v132)
          {
            v136 = v135 >= 0 ? v131 : *v131;
            if (!memcmp(v136, v133, v132))
            {
              break;
            }
          }

          v131 += 24;
          if (v131 == v130)
          {
            goto LABEL_373;
          }
        }
      }

      if (v131 == v130)
      {
LABEL_373:
        if (v130 >= v174)
        {
          v138 = sub_10016B30C(&v172, __p);
        }

        else
        {
          if (SHIBYTE(v169) < 0)
          {
            sub_100005F2C(v130, __p[0], __p[1]);
          }

          else
          {
            v137 = *__p;
            *(v130 + 16) = v169;
            *v130 = v137;
          }

          v138 = v130 + 24;
        }

        v173 = v138;
      }

      if (SHIBYTE(v169) < 0)
      {
        operator delete(__p[0]);
      }

      if (SBYTE7(v171) < 0)
      {
        operator delete(*buf);
      }
    }

    v140 = *(a1 + 352);
    for (kk = *(a1 + 360); v140 != kk; v140 += 2)
    {
      *buf = 0u;
      v171 = 0u;
      sub_1016173F0(buf, v140);
      __p[0] = 0;
      __p[1] = 0;
      v169 = 0;
      if (DWORD2(v171))
      {
        if ((SBYTE7(v171) & 0x80u) == 0)
        {
          v141 = BYTE7(v171);
        }

        else
        {
          v141 = *&buf[8];
        }

        memset(&v167, 0, sizeof(v167));
        sub_1000677C4(&v167, v141 + 1);
        if ((v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v142 = &v167;
        }

        else
        {
          v142 = v167.__r_.__value_.__r.__words[0];
        }

        if (v141)
        {
          if ((SBYTE7(v171) & 0x80u) == 0)
          {
            v143 = buf;
          }

          else
          {
            v143 = *buf;
          }

          memmove(v142, v143, v141);
        }

        *(&v142->__r_.__value_.__l.__data_ + v141) = 58;
        std::to_string(&v166, DWORD2(v171));
        if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v144 = &v166;
        }

        else
        {
          v144 = v166.__r_.__value_.__r.__words[0];
        }

        if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v145 = HIBYTE(v166.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v145 = v166.__r_.__value_.__l.__size_;
        }

        v146 = std::string::append(&v167, v144, v145);
        v147 = *&v146->__r_.__value_.__l.__data_;
        v169 = v146->__r_.__value_.__r.__words[2];
        *__p = v147;
        v146->__r_.__value_.__l.__size_ = 0;
        v146->__r_.__value_.__r.__words[2] = 0;
        v146->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v166.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v166.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v167.__r_.__value_.__l.__data_);
        }
      }

      else if (SBYTE7(v171) < 0)
      {
        sub_100005F2C(__p, *buf, *&buf[8]);
      }

      else
      {
        *__p = *buf;
        v169 = v171;
      }

      v149 = v172;
      v148 = v173;
      if (v172 != v173)
      {
        if (v169 >= 0)
        {
          v150 = HIBYTE(v169);
        }

        else
        {
          v150 = __p[1];
        }

        if (v169 >= 0)
        {
          v151 = __p;
        }

        else
        {
          v151 = __p[0];
        }

        while (1)
        {
          v152 = *(v149 + 23);
          v153 = v152;
          if ((v152 & 0x80u) != 0)
          {
            v152 = *(v149 + 8);
          }

          if (v152 == v150)
          {
            v154 = v153 >= 0 ? v149 : *v149;
            if (!memcmp(v154, v151, v150))
            {
              break;
            }
          }

          v149 += 24;
          if (v149 == v148)
          {
            goto LABEL_428;
          }
        }
      }

      if (v149 == v148)
      {
LABEL_428:
        if (v148 >= v174)
        {
          v156 = sub_10016B30C(&v172, __p);
        }

        else
        {
          if (SHIBYTE(v169) < 0)
          {
            sub_100005F2C(v148, __p[0], __p[1]);
          }

          else
          {
            v155 = *__p;
            *(v148 + 16) = v169;
            *v148 = v155;
          }

          v156 = v148 + 24;
        }

        v173 = v156;
      }

      if (SHIBYTE(v169) < 0)
      {
        operator delete(__p[0]);
      }

      if (SBYTE7(v171) < 0)
      {
        operator delete(*buf);
      }
    }
  }

  (*(**(a1 + 104) + 200))(buf);
  v157 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(*buf + 52));
  if (*&buf[8])
  {
    sub_100004A34(*&buf[8]);
  }

  v158 = v172;
  v159 = v173;
  v160 = *v157;
  v161 = os_log_type_enabled(v160, OS_LOG_TYPE_DEFAULT);
  if (v158 == v159)
  {
    if (v161)
    {
      *buf = 0;
      v162 = "#I Sending empty proxy list to controller";
      goto LABEL_447;
    }
  }

  else if (v161)
  {
    *buf = 0;
    v162 = "#I All P-CSCF Addresses are resolved. Sending proxy update to controller";
LABEL_447:
    _os_log_impl(&_mh_execute_header, v160, OS_LOG_TYPE_DEFAULT, v162, buf, 2u);
  }

  (*(**(a1 + 104) + 96))(*(a1 + 104), &v172, *(a1 + 212), a1 + 376);
  *buf = &v172;
  sub_1000087B4(buf);
}

void sub_101613B34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, void *__p, uint64_t a38, int a39, __int16 a40, char a41, char a42)
{
  *(v43 - 104) = v42;
  if (a42 < 0)
  {
    operator delete(__p);
  }

  if (*(v43 - 121) < 0)
  {
    operator delete(*(v43 - 144));
  }

  *(v43 - 144) = v43 - 112;
  sub_1000087B4((v43 - 144));
  _Unwind_Resume(a1);
}

void sub_101613D10(uint64_t a1, int a2, uint64_t a3)
{
  memset(&__str, 0, sizeof(__str));
  if (a2 && *a3 != *(a3 + 8))
  {
    std::string::operator=(&__str, *a3);
    (*(**(a1 + 104) + 200))(buf);
    v5 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(*buf + 52));
    if (*&buf[8])
    {
      sub_100004A34(*&buf[8]);
    }

    v6 = *v5;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = (a1 + 176);
      if (*(a1 + 199) < 0)
      {
        v7 = *v7;
      }

      p_str = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        p_str = __str.__r_.__value_.__r.__words[0];
      }

      *buf = 136315394;
      *&buf[4] = v7;
      *&buf[12] = 2080;
      *&buf[14] = p_str;
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I fWifiInterfaceName changes from %s to %s", buf, 0x16u);
    }

    std::string::operator=((a1 + 176), &__str);
  }

  v9 = *(a1 + 168);
  sub_101611658(a1, a2, *(a1 + 169), a2);
  (*(**(a1 + 104) + 200))(buf);
  v10 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(*buf + 52));
  if (*&buf[8])
  {
    sub_100004A34(*&buf[8]);
  }

  if (v9 != a2)
  {
    v11 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I WiFi transport change started", buf, 2u);
    }

    (*(**(a1 + 104) + 88))(*(a1 + 104), 1);
    if (a2)
    {
      if (*(a1 + 209) == 1 && *(a1 + 172) == 1)
      {
        v12 = *v10;
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 0;
          _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Reset pending transport sub switch", buf, 2u);
        }

        v13 = 0;
        *(a1 + 209) = 0;
      }

      else
      {
        v13 = 0;
      }

      goto LABEL_27;
    }

LABEL_25:
    v13 = 1;
LABEL_27:
    sub_10161261C(a1, v13);
    goto LABEL_28;
  }

  if ((a2 & 1) == 0)
  {
    goto LABEL_25;
  }

LABEL_28:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_101614004(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_101614054(uint64_t a1, int a2)
{
  v4 = *(a1 + 172);
  v5 = *(a1 + 48);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = "NOT available.";
    if (a2)
    {
      v6 = "available.";
    }

    LODWORD(v12) = 136315138;
    *(&v12 + 4) = v6;
    _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Cellular Internet is %s", &v12, 0xCu);
  }

  if (a2)
  {
    if (*(a1 + 209) == 1 && *(a1 + 172) == 1 && (*(a1 + 168) & 1) == 0)
    {
      (*(**(a1 + 104) + 200))(&v12);
      v9 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(v12 + 52));
      if (*(&v12 + 1))
      {
        sub_100004A34(*(&v12 + 1));
      }

      v10 = *v9;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v12) = 0;
        _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Reset pending transport sub switch", &v12, 2u);
      }

      v4 = 0;
      *(a1 + 209) = 0;
    }

    else if (*(a1 + 210) == 1 && *(a1 + 172) == 1 && (*(a1 + 169) & 1) == 0)
    {
      (*(**(a1 + 104) + 200))(&v12);
      v7 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(v12 + 52));
      if (*(&v12 + 1))
      {
        sub_100004A34(*(&v12 + 1));
      }

      v8 = *v7;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v12) = 0;
        _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Reset pending cell transport switch", &v12, 2u);
      }

      v4 = 0;
      *(a1 + 210) = 0;
    }
  }

  return sub_101611658(a1, *(a1 + 168), a2 != 0, v4);
}

void sub_1016142D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_101614304(uint64_t a1, int a2)
{
  v2 = a2 != 0;
  if (*(a1 + 200) != v2)
  {
    (*(**(a1 + 104) + 200))(v10);
    v5 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(*v10 + 52));
    if (*&v10[8])
    {
      sub_100004A34(*&v10[8]);
    }

    v6 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      v7 = "Inactive";
      if (*(a1 + 200))
      {
        v8 = "Active";
      }

      else
      {
        v8 = "Inactive";
      }

      if (a2)
      {
        v7 = "Active";
      }

      *v10 = 136315394;
      *&v10[4] = v8;
      *&v10[12] = 2080;
      *&v10[14] = v7;
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Cellular Internet %s->%s", v10, 0x16u);
    }

    *(a1 + 200) = v2;
    if (*(a1 + 212))
    {
      if (a2)
      {
LABEL_13:
        (*(**(a1 + 104) + 200))(v10);
        sub_101610EAC(a1, *(*v10 + 52) != a2, 0);
        if (*&v10[8])
        {
          sub_100004A34(*&v10[8]);
        }

        return;
      }
    }

    else
    {
      v9 = *v5;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *v10 = 0;
        _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Cellular transport change started", v10, 2u);
      }

      (*(**(a1 + 104) + 88))(*(a1 + 104), 1);
      if (*(a1 + 200))
      {
        goto LABEL_13;
      }
    }

    sub_10161261C(a1, 0);
  }
}

void sub_101614548(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

_DWORD *sub_101614574(_DWORD *result, uint64_t a2)
{
  if (*(a2 + 8))
  {
    v2 = result;
    if (!result[53])
    {
      (*(**(result + 13) + 200))(&v6);
      v3 = (*(**(v2 + 7) + 16))(*(v2 + 7), *(v6 + 52));
      if (*(&v6 + 1))
      {
        sub_100004A34(*(&v6 + 1));
      }

      v4 = *v3;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v5 = CSIErrorString();
        LODWORD(v6) = 136315138;
        *(&v6 + 4) = v5;
        _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Activate error for internet Pdn = %s", &v6, 0xCu);
      }

      return sub_10161261C(v2, 0);
    }
  }

  return result;
}

void sub_1016146AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016146D4(void *__dst, uint64_t a2)
{
  if (__PAIR64__(*(a2 + 172), *(a2 + 168)) == 0x100000001)
  {
    if (*(a2 + 199) < 0)
    {
      v16 = *(a2 + 176);
      v17 = *(a2 + 184);

      sub_100005F2C(__dst, v16, v17);
    }

    else
    {
      *__dst = *(a2 + 176);
      __dst[2] = *(a2 + 192);
    }

    return;
  }

  ServiceMap = Registry::getServiceMap(*(a2 + 64));
  v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    v7 = (v6 & 0x7FFFFFFFFFFFFFFFLL);
    v8 = 5381;
    do
    {
      v6 = v8;
      v9 = *v7++;
      v8 = (33 * v8) ^ v9;
    }

    while (v9);
  }

  std::mutex::lock(ServiceMap);
  v18 = v6;
  v10 = sub_100009510(&v5[1].__m_.__sig, &v18);
  if (v10)
  {
    v12 = v10[3];
    v11 = v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v11);
      v14 = 0;
      if (!v12)
      {
        goto LABEL_17;
      }

LABEL_13:
      if (capabilities::ct::supportsGemini(v13))
      {
        v15 = (*(*v12 + 808))(v12);
        (*(*v12 + 128))(v12, v15, 0);
      }

      else
      {
        (*(**(a2 + 104) + 200))(&v18);
        (*(*v12 + 128))(v12, *(v18 + 52), 0);
        if (v19)
        {
          sub_100004A34(v19);
        }
      }

      goto LABEL_17;
    }
  }

  else
  {
    v12 = 0;
  }

  std::mutex::unlock(v5);
  v11 = 0;
  v14 = 1;
  if (v12)
  {
    goto LABEL_13;
  }

LABEL_17:
  if ((v14 & 1) == 0)
  {
    sub_100004A34(v11);
  }

  if (!v12)
  {
    *__dst = 0;
    __dst[1] = 0;
    __dst[2] = 0;
  }
}

void sub_101614918(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  if ((v11 & 1) == 0)
  {
    sub_100004A34(v10);
  }

  _Unwind_Resume(exception_object);
}

void sub_10161494C(uint64_t a1, std::string **a2)
{
  (*(**(a1 + 104) + 200))(&v7);
  v4 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(v7 + 52));
  if (v8)
  {
    sub_100004A34(v8);
  }

  v5 = *v4;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7) = 0;
    _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I P-CSCF list update", &v7, 2u);
  }

  if ((a1 + 232) != a2)
  {
    sub_100008234((a1 + 232), *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  }

  sub_10003CAAC((a1 + 304));
  sub_10003CAAC((a1 + 280));
  sub_10003CAAC((a1 + 352));
  sub_10003CAAC((a1 + 328));
  if (*(a1 + 399) < 0)
  {
    **(a1 + 376) = 0;
    *(a1 + 384) = 0;
  }

  else
  {
    *(a1 + 376) = 0;
    *(a1 + 399) = 0;
  }

  v6 = *(a1 + 416);
  *(a1 + 408) = 0;
  *(a1 + 416) = 0;
  if (v6)
  {
    sub_100004A34(v6);
  }
}

void sub_101614AA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_101614AB8(CSIPacketAddress *a1, uint64_t a2, std::string::size_type a3, int *a4, int *a5)
{
  (*(**(a2 + 104) + 200))(&__s);
  v10 = (*(**(a2 + 56) + 16))(*(a2 + 56), *(__s.__r_.__value_.__r.__words[0] + 52));
  if (__s.__r_.__value_.__l.__size_)
  {
    sub_100004A34(__s.__r_.__value_.__l.__size_);
  }

  v11 = *(a3 + 23);
  if ((v11 & 0x8000000000000000) == 0)
  {
    if (!*(a3 + 23) || *a3 != 91)
    {
      goto LABEL_47;
    }

    v12 = a3;
    v13 = *(a3 + 23);
LABEL_9:
    if (v13 >= 2)
    {
      v14 = &v12[v13];
      v15 = v12;
      while (1)
      {
        v16 = memchr(v15, 93, v13 - 1);
        if (!v16)
        {
          goto LABEL_46;
        }

        if (*v16 == 14941)
        {
          break;
        }

        v15 = v16 + 1;
        v13 = v14 - v15;
        if (v14 - v15 < 2)
        {
          goto LABEL_46;
        }
      }

      if (v16 == v14)
      {
        goto LABEL_46;
      }

      v17 = (v16 - v12);
      if (v16 - v12 == -1)
      {
        goto LABEL_46;
      }

      memset(&__s, 0, sizeof(__s));
      std::string::basic_string(&__s, a3, (v17 + 2), 0xFFFFFFFFFFFFFFFFLL, &__p);
      v18 = SHIBYTE(__s.__r_.__value_.__r.__words[2]);
      if ((SHIBYTE(__s.__r_.__value_.__r.__words[2]) & 0x8000000000000000) != 0)
      {
        size = __s.__r_.__value_.__l.__size_;
        if (!__s.__r_.__value_.__l.__size_)
        {
LABEL_38:
          if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__s.__r_.__value_.__l.__data_);
          }

          goto LABEL_40;
        }

        p_s = __s.__r_.__value_.__r.__words[0];
      }

      else
      {
        if (!*(&__s.__r_.__value_.__s + 23))
        {
LABEL_40:
          std::string::basic_string(&__s, a3, 1uLL, (v17 - 1), &__p);
          if (*(a3 + 23) < 0)
          {
            operator delete(*a3);
          }

          *a3 = __s;
          v27 = *v10;
          v28 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
          LODWORD(v11) = *(a3 + 23);
          if (v28)
          {
            v29 = *a3;
            if (v11 >= 0)
            {
              v29 = a3;
            }

            v30 = *a4;
            v31 = *a5;
            LODWORD(__s.__r_.__value_.__l.__data_) = 136446722;
            *(__s.__r_.__value_.__r.__words + 4) = v29;
            WORD2(__s.__r_.__value_.__r.__words[1]) = 1024;
            *(&__s.__r_.__value_.__r.__words[1] + 6) = v30;
            WORD1(__s.__r_.__value_.__r.__words[2]) = 1024;
            HIDWORD(__s.__r_.__value_.__r.__words[2]) = v31;
            _os_log_impl(&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I P-CSCF addr: %{public}s, Cell port: %u, WiFi port: %u", &__s, 0x18u);
            LOBYTE(v11) = *(a3 + 23);
          }

          goto LABEL_46;
        }

        p_s = &__s;
        size = SHIBYTE(__s.__r_.__value_.__r.__words[2]);
      }

      v21 = memchr(p_s, 58, size);
      if (!v21 || (v22 = v21 - p_s, v22 == -1))
      {
        if (v18 >= 0)
        {
          v25 = &__s;
        }

        else
        {
          v25 = __s.__r_.__value_.__r.__words[0];
        }

        v26 = strtoul(v25, 0, 0);
        *a5 = v26;
        *a4 = v26;
      }

      else
      {
        std::string::basic_string(&__p, &__s, 0, v22, &v48);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          p_p = &__p;
        }

        else
        {
          p_p = __p.__r_.__value_.__r.__words[0];
        }

        *a4 = strtoul(p_p, 0, 0);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
        }

        std::string::basic_string(&__p, &__s, v22 + 1, 0xFFFFFFFFFFFFFFFFLL, &v48);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v24 = &__p;
        }

        else
        {
          v24 = __p.__r_.__value_.__r.__words[0];
        }

        *a5 = strtoul(v24, 0, 0);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }

      goto LABEL_38;
    }

LABEL_46:
    if ((v11 & 0x80) != 0)
    {
      if (*(a3 + 8))
      {
        goto LABEL_48;
      }

      goto LABEL_54;
    }

LABEL_47:
    if (v11)
    {
      goto LABEL_48;
    }

LABEL_54:
    CSIPacketAddress::CSIPacketAddress(a1);
    return;
  }

  v13 = *(a3 + 8);
  if (!v13)
  {
    goto LABEL_54;
  }

  v12 = *a3;
  if (**a3 == 91)
  {
    goto LABEL_9;
  }

LABEL_48:
  *a1 = 0;
  *(a1 + 1) = 0;
  *(a1 + 2) = 0;
  CSIPacketAddress::CSIPacketAddress();
  if (!CSIPacketAddress::isZeroIP(a1))
  {
    return;
  }

  v32 = std::string::find(a3, 58, 0);
  if (v32 == -1)
  {
    return;
  }

  v33 = v32;
  memset(&__s, 0, sizeof(__s));
  std::string::basic_string(&__s, a3, v32 + 1, 0xFFFFFFFFFFFFFFFFLL, &__p);
  v34 = SHIBYTE(__s.__r_.__value_.__r.__words[2]);
  if ((SHIBYTE(__s.__r_.__value_.__r.__words[2]) & 0x8000000000000000) != 0)
  {
    v36 = __s.__r_.__value_.__l.__size_;
    if (!__s.__r_.__value_.__l.__size_)
    {
LABEL_73:
      if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__s.__r_.__value_.__l.__data_);
      }

      goto LABEL_75;
    }

    v35 = __s.__r_.__value_.__r.__words[0];
LABEL_57:
    v37 = memchr(v35, 58, v36);
    if (!v37 || (v38 = v37 - v35, v38 == -1))
    {
      if (v34 >= 0)
      {
        v41 = &__s;
      }

      else
      {
        v41 = __s.__r_.__value_.__r.__words[0];
      }

      v42 = strtoul(v41, 0, 0);
      *a5 = v42;
      *a4 = v42;
    }

    else
    {
      std::string::basic_string(&__p, &__s, 0, v38, &v48);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v39 = &__p;
      }

      else
      {
        v39 = __p.__r_.__value_.__r.__words[0];
      }

      *a4 = strtoul(v39, 0, 0);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      std::string::basic_string(&__p, &__s, v38 + 1, 0xFFFFFFFFFFFFFFFFLL, &v48);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v40 = &__p;
      }

      else
      {
        v40 = __p.__r_.__value_.__r.__words[0];
      }

      *a5 = strtoul(v40, 0, 0);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    goto LABEL_73;
  }

  if (*(&__s.__r_.__value_.__s + 23))
  {
    v35 = &__s;
    v36 = SHIBYTE(__s.__r_.__value_.__r.__words[2]);
    goto LABEL_57;
  }

LABEL_75:
  std::string::basic_string(&__s, a3, 0, v33, &__p);
  if (*(a3 + 23) < 0)
  {
    operator delete(*a3);
  }

  *a3 = __s;
  v43 = *v10;
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    if (*(a3 + 23) >= 0)
    {
      v44 = a3;
    }

    else
    {
      v44 = *a3;
    }

    v45 = *a4;
    v46 = *a5;
    LODWORD(__s.__r_.__value_.__l.__data_) = 136446722;
    *(__s.__r_.__value_.__r.__words + 4) = v44;
    WORD2(__s.__r_.__value_.__r.__words[1]) = 1024;
    *(&__s.__r_.__value_.__r.__words[1] + 6) = v45;
    WORD1(__s.__r_.__value_.__r.__words[2]) = 1024;
    HIDWORD(__s.__r_.__value_.__r.__words[2]) = v46;
    _os_log_impl(&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I P-CSCF addr: %{public}s, Cell port: %u, WiFi port: %u", &__s, 0x18u);
  }

  CSIPacketAddress::CSIPacketAddress();
  CSIPacketAddress::operator=();
}

void sub_10161506C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016150B0(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, char a5, int a6)
{
  (*(**(a1 + 104) + 200))(&buf);
  v12 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(buf.__r_.__value_.__r.__words[0] + 52));
  if (buf.__r_.__value_.__l.__size_)
  {
    sub_100004A34(buf.__r_.__value_.__l.__size_);
  }

  v13 = *(a2 + 23);
  v14 = v13;
  if ((v13 & 0x80u) != 0)
  {
    v13 = *(a2 + 8);
  }

  v15 = *v12;
  if (v13)
  {
    if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *a2;
      if (v14 >= 0)
      {
        v16 = a2;
      }

      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(buf.__r_.__value_.__r.__words + 4) = v16;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(&buf.__r_.__value_.__r.__words[1] + 6) = a6;
      _os_log_impl(&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I IP addr resolution for [%s], attempt=%u", &buf, 0x12u);
    }

    v50 = 0;
    v51 = 0;
    v17 = *(a1 + 96);
    v18 = *(a1 + 32);
    object = v18;
    if (v18)
    {
      dispatch_retain(v18);
    }

    (*(*v17 + 80))(&v50, v17, &object);
    if (object)
    {
      dispatch_release(object);
    }

    if (v50)
    {
      *(v48 + 3) = 0;
      v48[0] = 0;
      if (*(a2 + 23) >= 0)
      {
        v19 = *(a2 + 23);
      }

      else
      {
        v19 = *(a2 + 8);
      }

      memset(&v56, 0, sizeof(v56));
      v20 = &v56;
      sub_1000677C4(&v56, v19 + 1);
      if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        v20 = v56.__r_.__value_.__r.__words[0];
      }

      if (v19)
      {
        if (*(a2 + 23) >= 0)
        {
          v21 = a2;
        }

        else
        {
          v21 = *a2;
        }

        memmove(v20, v21, v19);
      }

      *(&v20->__r_.__value_.__l.__data_ + v19) = 58;
      std::to_string(&v46, a3);
      if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v22 = &v46;
      }

      else
      {
        v22 = v46.__r_.__value_.__r.__words[0];
      }

      if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        size = HIBYTE(v46.__r_.__value_.__r.__words[2]);
      }

      else
      {
        size = v46.__r_.__value_.__l.__size_;
      }

      v24 = std::string::append(&v56, v22, size);
      v25 = *&v24->__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
      *&v47.__r_.__value_.__l.__data_ = v25;
      v24->__r_.__value_.__l.__size_ = 0;
      v24->__r_.__value_.__r.__words[2] = 0;
      v24->__r_.__value_.__r.__words[0] = 0;
      v26 = std::string::append(&v47, ":", 1uLL);
      v27 = *&v26->__r_.__value_.__l.__data_;
      buf.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
      *&buf.__r_.__value_.__l.__data_ = v27;
      v26->__r_.__value_.__l.__size_ = 0;
      v26->__r_.__value_.__r.__words[2] = 0;
      v26->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v45, a4);
      if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v28 = &v45;
      }

      else
      {
        v28 = v45.__r_.__value_.__r.__words[0];
      }

      if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v29 = HIBYTE(v45.__r_.__value_.__r.__words[2]);
      }

      else
      {
        v29 = v45.__r_.__value_.__l.__size_;
      }

      v30 = std::string::append(&buf, v28, v29);
      v31 = v30->__r_.__value_.__l.__size_;
      __src = v30->__r_.__value_.__r.__words[0];
      v48[0] = v30->__r_.__value_.__r.__words[2];
      *(v48 + 3) = *(&v30->__r_.__value_.__r.__words[2] + 3);
      v32 = SHIBYTE(v30->__r_.__value_.__r.__words[2]);
      v30->__r_.__value_.__l.__size_ = 0;
      v30->__r_.__value_.__r.__words[2] = 0;
      v30->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v45.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(buf.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v47.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v46.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v56.__r_.__value_.__l.__data_);
        if ((v32 & 0x80000000) == 0)
        {
          goto LABEL_47;
        }
      }

      else if ((v32 & 0x80000000) == 0)
      {
LABEL_47:
        buf.__r_.__value_.__r.__words[0] = __src;
        buf.__r_.__value_.__l.__size_ = v31;
        LODWORD(buf.__r_.__value_.__r.__words[2]) = v48[0];
        *(&buf.__r_.__value_.__r.__words[2] + 3) = *(v48 + 3);
        *(&buf.__r_.__value_.__s + 23) = v32;
        goto LABEL_57;
      }

      sub_100005F2C(&buf, __src, v31);
LABEL_57:
      v54 = v50;
      v55 = v51;
      if (v51)
      {
        atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      sub_101617FD0(a1 + 256, &buf.__r_.__value_.__l.__data_);
      if (v55)
      {
        sub_100004A34(v55);
      }

      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(buf.__r_.__value_.__l.__data_);
      }

      memset(&buf, 0, sizeof(buf));
      sub_1016146D4(&buf, a1);
      memset(&v47, 0, sizeof(v47));
      (*(**(a1 + 152) + 24))(&v47);
      if (((*(**(a1 + 152) + 32))(*(a1 + 152), &v47) & 3) - 1 <= 1)
      {
        v35 = *v12;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          v36 = asString();
          LODWORD(v56.__r_.__value_.__l.__data_) = 136315138;
          *(v56.__r_.__value_.__r.__words + 4) = v36;
          _os_log_impl(&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Only one IP family %s is configured - limit DNS resolution to it", &v56, 0xCu);
        }
      }

      v37 = *(a1 + 24);
      if (v37)
      {
        v38 = std::__shared_weak_count::lock(v37);
        if (v38)
        {
          atomic_fetch_add_explicit(&v38->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_100004A34(v38);
          if (*(a2 + 23) < 0)
          {
            sub_100005F2C(__p, *a2, *(a2 + 8));
          }

          else
          {
            *__p = *a2;
            __p[2] = *(a2 + 16);
          }

          v41 = a3;
          v42 = a4;
          v43 = a6;
          v44 = a5;
          v52 = 0;
          operator new();
        }
      }

      sub_100013CC4();
    }

    v33 = *v12;
    if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
    {
      if (*(a2 + 23) >= 0)
      {
        v34 = a2;
      }

      else
      {
        v34 = *a2;
      }

      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(buf.__r_.__value_.__r.__words + 4) = v34;
      _os_log_impl(&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#N Failed to create address resolver for P-CSCF %s", &buf, 0xCu);
    }

    if (v51)
    {
      sub_100004A34(v51);
    }
  }

  else if (os_log_type_enabled(*v12, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Domain name is empty", &buf, 2u);
  }
}

void sub_101615790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, char a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, void *a31, uint64_t a32, int a33, __int16 a34, char a35, char a36, uint64_t a37, uint64_t a38, dispatch_object_t object, uint64_t a40, std::__shared_weak_count *a41, char a42)
{
  *(v43 - 128) = &a31;
  sub_1000087B4((v43 - 128));
  if (*(v43 - 153) < 0)
  {
    operator delete(*(v43 - 176));
  }

  if (v42 < 0)
  {
    operator delete(__p);
  }

  if (a41)
  {
    sub_100004A34(a41);
  }

  _Unwind_Resume(a1);
}

void sub_1016158DC(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  ServiceMap = Registry::getServiceMap(*(a1 + 64));
  v5 = ServiceMap;
  if (v6 < 0)
  {
    v7 = (v6 & 0x7FFFFFFFFFFFFFFFLL);
    v8 = 5381;
    do
    {
      v6 = v8;
      v9 = *v7++;
      v8 = (33 * v8) ^ v9;
    }

    while (v9);
  }

  std::mutex::lock(ServiceMap);
  *buf = v6;
  v10 = sub_100009510(&v5[1].__m_.__sig, buf);
  if (v10)
  {
    v12 = v10[3];
    v11 = v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v11);
      v13 = 0;
      if (!v12)
      {
        goto LABEL_7;
      }

      goto LABEL_11;
    }
  }

  else
  {
    v12 = 0;
  }

  std::mutex::unlock(v5);
  v11 = 0;
  v13 = 1;
  if (!v12)
  {
LABEL_7:
    v14 = *(a1 + 48);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "TelephonyAnalytics service not found!", buf, 2u);
    }

    goto LABEL_39;
  }

LABEL_11:
  v34 = 0;
  v15 = xpc_dictionary_create(0, 0, 0);
  v16 = v15;
  if (v15)
  {
    v34 = v15;
  }

  else
  {
    v16 = xpc_null_create();
    v34 = v16;
    if (!v16)
    {
      v17 = xpc_null_create();
      v16 = 0;
      goto LABEL_18;
    }
  }

  if (xpc_get_type(v16) != &_xpc_type_dictionary)
  {
    v17 = xpc_null_create();
LABEL_18:
    v34 = v17;
    goto LABEL_19;
  }

  xpc_retain(v16);
LABEL_19:
  xpc_release(v16);
  v32 = xpc_BOOL_create(a2 == 0);
  if (!v32)
  {
    v32 = xpc_null_create();
  }

  *buf = &v34;
  *&buf[8] = "isSuccessful";
  sub_10000F688(buf, &v32, &object);
  xpc_release(object);
  object = 0;
  xpc_release(v32);
  v32 = 0;
  v30 = xpc_int64_create(a2);
  if (!v30)
  {
    v30 = xpc_null_create();
  }

  *buf = &v34;
  *&buf[8] = "reason";
  sub_10000F688(buf, &v30, &v31);
  xpc_release(v31);
  v31 = 0;
  xpc_release(v30);
  v30 = 0;
  v28 = xpc_int64_create(2);
  if (!v28)
  {
    v28 = xpc_null_create();
  }

  *buf = &v34;
  *&buf[8] = "service";
  sub_10000F688(buf, &v28, &v29);
  xpc_release(v29);
  v29 = 0;
  xpc_release(v28);
  v28 = 0;
  Registry::getTimerService(buf, *(a1 + 64));
  v18 = ((***buf)(*buf) - *(a1 + 424)) / 1000000;
  if (*&buf[8])
  {
    sub_100004A34(*&buf[8]);
  }

  v26 = xpc_int64_create(v18);
  if (!v26)
  {
    v26 = xpc_null_create();
  }

  *buf = &v34;
  *&buf[8] = "duration";
  sub_10000F688(buf, &v26, &v27);
  xpc_release(v27);
  v27 = 0;
  xpc_release(v26);
  v26 = 0;
  v19 = (*(**(a1 + 104) + 208))(*(a1 + 104));
  v24 = xpc_BOOL_create(v19);
  if (!v24)
  {
    v24 = xpc_null_create();
  }

  *buf = &v34;
  *&buf[8] = "IsPR";
  sub_10000F688(buf, &v24, &v25);
  xpc_release(v25);
  v25 = 0;
  xpc_release(v24);
  v24 = 0;
  (*(**(a1 + 104) + 200))(buf);
  v20 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(*buf + 52));
  if (*&buf[8])
  {
    sub_100004A34(*&buf[8]);
  }

  v21 = *v20;
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    v22 = asString();
    *buf = 136315394;
    *&buf[4] = v22;
    *&buf[12] = 2048;
    *&buf[14] = v18;
    _os_log_impl(&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Submitting DNSResolutionEvent metric with errorCode: %s, duration: %llu", buf, 0x16u);
  }

  v23 = v34;
  if (v34)
  {
    xpc_retain(v34);
  }

  else
  {
    v23 = xpc_null_create();
  }

  (*(*v12 + 16))(v12, "DNSResolution", &v23);
  xpc_release(v23);
  v23 = 0;
  xpc_release(v34);
LABEL_39:
  if ((v13 & 1) == 0)
  {
    sub_100004A34(v11);
  }
}

void sub_101615DF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t object, uint64_t a21, uint64_t a22)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

void sub_101615ED8(uint64_t a1)
{
  v1 = *(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_101615FDC(uint64_t a1)
{
  v1 = *(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_1016160E0(uint64_t a1)
{
  (*(**(a1 + 104) + 200))(buf);
  v2 = (*(**(a1 + 56) + 16))(*(a1 + 56), *(buf[0].__locale_ + 13));
  if (buf[1].__locale_)
  {
    sub_100004A34(buf[1].__locale_);
  }

  v3 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf[0].__locale_) = 136315394;
    *(&buf[0].__locale_ + 4) = "IMSConnectivityHelperLazuli";
    WORD2(buf[1].__locale_) = 2080;
    *(&buf[1].__locale_ + 6) = "IMSConnectivityHelperLazuli";
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: ----------------- %s %s ==>> -------------------", buf, 0x16u);
  }

  v111 = 0;
  v109 = 0u;
  v110 = 0u;
  v107 = 0u;
  v108 = 0u;
  v105 = 0u;
  v106 = 0u;
  v103 = 0u;
  v104 = 0u;
  v101 = 0u;
  v102 = 0u;
  *__p = 0u;
  v100 = 0u;
  v97 = 0u;
  *__src = 0u;
  memset(buf, 0, sizeof(buf));
  sub_10000D518(buf);
  v4 = sub_10000C030(buf);
  v5 = sub_10000C030(v4);
  (*(**(a1 + 104) + 200))(__dst);
  v6 = *&__dst[0] + 24;
  v7 = *(*&__dst[0] + 47);
  v8 = v7;
  if ((v7 & 0x80u) != 0)
  {
    v7 = *(*&__dst[0] + 32);
  }

  if (v8 < 0)
  {
    v6 = *(*&__dst[0] + 24);
  }

  if (v7)
  {
    v9 = v6;
  }

  else
  {
    v9 = "<invalid>";
  }

  strlen(v9);
  v10 = sub_10000C030(v5);
  v11 = sub_10000C030(v10);
  v12 = sub_10000C030(v11);
  v13 = sub_10000C030(v12);
  v14 = asStringBool(*(a1 + 168));
  strlen(v14);
  v15 = sub_10000C030(v13);
  v16 = sub_10000C030(v15);
  v17 = sub_10000C030(v16);
  v18 = sub_10000C030(v17);
  v19 = asStringBool(*(a1 + 169));
  strlen(v19);
  v20 = sub_10000C030(v18);
  v21 = sub_10000C030(v20);
  v22 = sub_10000C030(v21);
  v23 = sub_10000C030(v22);
  v24 = asString();
  strlen(v24);
  v25 = sub_10000C030(v23);
  v26 = sub_10000C030(v25);
  v27 = sub_10000C030(v26);
  v28 = sub_10000C030(v27);
  v29 = sub_10000C030(v28);
  v30 = sub_10000C030(v29);
  v31 = sub_10000C030(v30);
  sub_10000C030(v31);
  v32 = std::ostream::operator<<();
  v33 = sub_10000C030(v32);
  v34 = sub_10000C030(v33);
  v35 = sub_10000C030(v34);
  v36 = asString();
  strlen(v36);
  v37 = sub_10000C030(v35);
  v38 = sub_10000C030(v37);
  v39 = sub_10000C030(v38);
  v40 = sub_10000C030(v39);
  v41 = asStringBool(*(a1 + 208));
  strlen(v41);
  v42 = sub_10000C030(v40);
  v43 = sub_10000C030(v42);
  v44 = sub_10000C030(v43);
  v45 = sub_10000C030(v44);
  v46 = asStringBool(*(a1 + 209));
  strlen(v46);
  v47 = sub_10000C030(v45);
  v48 = sub_10000C030(v47);
  v49 = sub_10000C030(v48);
  v50 = sub_10000C030(v49);
  v51 = asStringBool(*(a1 + 210));
  strlen(v51);
  v52 = sub_10000C030(v50);
  v53 = sub_10000C030(v52);
  std::ios_base::getloc((v53 + *(*v53 - 24)));
  v54 = std::locale::use_facet(v90, &std::ctype<char>::id);
  (v54->__vftable[2].~facet_0)(v54, 10);
  std::locale::~locale(v90);
  std::ostream::put();
  std::ostream::flush();
  if (*(&__dst[0] + 1))
  {
    sub_100004A34(*(&__dst[0] + 1));
  }

  v55 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    if ((BYTE8(v101) & 0x10) != 0)
    {
      v57 = v101;
      if (v101 < __src[1])
      {
        *&v101 = __src[1];
        v57 = __src[1];
      }

      locale = __src[0];
    }

    else
    {
      if ((BYTE8(v101) & 8) == 0)
      {
        v56 = 0;
        BYTE7(__dst[1]) = 0;
LABEL_28:
        *(__dst + v56) = 0;
        v59 = __dst;
        if (SBYTE7(__dst[1]) < 0)
        {
          v59 = *&__dst[0];
        }

        *v90 = 136315138;
        *&v90[4] = v59;
        _os_log_impl(&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: %s", v90, 0xCu);
        if (SBYTE7(__dst[1]) < 0)
        {
          operator delete(*&__dst[0]);
        }

        v55 = *v2;
        goto LABEL_33;
      }

      locale = buf[3].__locale_;
      v57 = *(&v97 + 1);
    }

    v56 = v57 - locale;
    if ((v57 - locale) >= 0x7FFFFFFFFFFFFFF8)
    {
      sub_1000A2378();
    }

    if (v56 >= 0x17)
    {
      operator new();
    }

    BYTE7(__dst[1]) = v57 - locale;
    if (v56)
    {
      memmove(__dst, locale, v56);
    }

    goto LABEL_28;
  }

LABEL_33:
  if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__dst[0]) = 0;
    _os_log_impl(&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \tfPcscfResolverMap {\n", __dst, 2u);
  }

  v60 = *(a1 + 256);
  if (v60 != (a1 + 264))
  {
    do
    {
      v61 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        v62 = v60 + 4;
        if (*(v60 + 55) < 0)
        {
          v62 = *v62;
        }

        v63 = v60[7];
        LODWORD(__dst[0]) = 136315394;
        *(__dst + 4) = v62;
        WORD6(__dst[0]) = 2048;
        *(__dst + 14) = v63;
        _os_log_impl(&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \t\t%s - %p\n", __dst, 0x16u);
      }

      v64 = v60[1];
      if (v64)
      {
        do
        {
          v65 = v64;
          v64 = *v64;
        }

        while (v64);
      }

      else
      {
        do
        {
          v65 = v60[2];
          v66 = *v65 == v60;
          v60 = v65;
        }

        while (!v66);
      }

      v60 = v65;
    }

    while (v65 != (a1 + 264));
  }

  v67 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__dst[0]) = 0;
    _os_log_impl(&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \t}\n", __dst, 2u);
    v67 = *v2;
  }

  if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__dst[0]) = 0;
    _os_log_impl(&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \tfPcscfIPv4LegacyList {\n", __dst, 2u);
  }

  v68 = *(a1 + 304);
  for (i = *(a1 + 312); v68 != i; v68 += 2)
  {
    memset(__dst, 0, sizeof(__dst));
    sub_1016173F0(__dst, v68);
    v70 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      if ((SBYTE7(__dst[1]) & 0x80u) == 0)
      {
        v71 = __dst;
      }

      else
      {
        v71 = *&__dst[0];
      }

      *v90 = 136315650;
      *&v90[4] = v71;
      v91 = 1024;
      v92 = DWORD2(__dst[1]);
      v93 = 1024;
      v94 = HIDWORD(__dst[1]);
      _os_log_impl(&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \t\t%s:%u:%u\n", v90, 0x18u);
    }

    if (SBYTE7(__dst[1]) < 0)
    {
      operator delete(*&__dst[0]);
    }
  }

  v72 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__dst[0]) = 0;
    _os_log_impl(&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \t}\n", __dst, 2u);
    v72 = *v2;
  }

  if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__dst[0]) = 0;
    _os_log_impl(&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \tfPcscfIPv6LegacyList {\n", __dst, 2u);
  }

  v73 = *(a1 + 280);
  for (j = *(a1 + 288); v73 != j; v73 += 2)
  {
    memset(__dst, 0, sizeof(__dst));
    sub_1016173F0(__dst, v73);
    v75 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      if ((SBYTE7(__dst[1]) & 0x80u) == 0)
      {
        v76 = __dst;
      }

      else
      {
        v76 = *&__dst[0];
      }

      *v90 = 136315650;
      *&v90[4] = v76;
      v91 = 1024;
      v92 = DWORD2(__dst[1]);
      v93 = 1024;
      v94 = HIDWORD(__dst[1]);
      _os_log_impl(&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \t\t%s:%u:%u\n", v90, 0x18u);
    }

    if (SBYTE7(__dst[1]) < 0)
    {
      operator delete(*&__dst[0]);
    }
  }

  v77 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__dst[0]) = 0;
    _os_log_impl(&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \t}\n", __dst, 2u);
    v77 = *v2;
  }

  if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__dst[0]) = 0;
    _os_log_impl(&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \tfPcscfIPv4ServiceList {\n", __dst, 2u);
  }

  v78 = *(a1 + 352);
  for (k = *(a1 + 360); v78 != k; v78 += 2)
  {
    memset(__dst, 0, sizeof(__dst));
    sub_1016173F0(__dst, v78);
    v80 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      if ((SBYTE7(__dst[1]) & 0x80u) == 0)
      {
        v81 = __dst;
      }

      else
      {
        v81 = *&__dst[0];
      }

      *v90 = 136315650;
      *&v90[4] = v81;
      v91 = 1024;
      v92 = DWORD2(__dst[1]);
      v93 = 1024;
      v94 = HIDWORD(__dst[1]);
      _os_log_impl(&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \t\t%s:%u:%u\n", v90, 0x18u);
    }

    if (SBYTE7(__dst[1]) < 0)
    {
      operator delete(*&__dst[0]);
    }
  }

  v82 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__dst[0]) = 0;
    _os_log_impl(&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \t}\n", __dst, 2u);
    v82 = *v2;
  }

  if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__dst[0]) = 0;
    _os_log_impl(&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \tfPcscfIPv6ServiceList {\n", __dst, 2u);
  }

  v83 = *(a1 + 328);
  for (m = *(a1 + 336); v83 != m; v83 += 2)
  {
    memset(__dst, 0, sizeof(__dst));
    sub_1016173F0(__dst, v83);
    v85 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      if ((SBYTE7(__dst[1]) & 0x80u) == 0)
      {
        v86 = __dst;
      }

      else
      {
        v86 = *&__dst[0];
      }

      *v90 = 136315650;
      *&v90[4] = v86;
      v91 = 1024;
      v92 = DWORD2(__dst[1]);
      v93 = 1024;
      v94 = HIDWORD(__dst[1]);
      _os_log_impl(&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \t\t%s:%u:%u\n", v90, 0x18u);
    }

    if (SBYTE7(__dst[1]) < 0)
    {
      operator delete(*&__dst[0]);
    }
  }

  v87 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__dst[0]) = 0;
    _os_log_impl(&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: \t}\n", __dst, 2u);
    v87 = *v2;
  }

  if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
  {
    v88 = (a1 + 376);
    if (*(a1 + 399) < 0)
    {
      v88 = *v88;
    }

    LODWORD(__dst[0]) = 136315138;
    *(__dst + 4) = v88;
    _os_log_impl(&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: %s", __dst, 0xCu);
    v87 = *v2;
  }

  if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__dst[0]) = 136315394;
    *(__dst + 4) = "IMSConnectivityHelperLazuli";
    WORD6(__dst[0]) = 2080;
    *(__dst + 14) = "IMSConnectivityHelperLazuli";
    _os_log_impl(&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "#I 5wi.lazuli:: ------------ <<== %s %s ------------------------", __dst, 0x16u);
  }

  if (SHIBYTE(v100) < 0)
  {
    operator delete(__p[1]);
  }

  std::locale::~locale(&buf[2]);
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_101616F38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::locale a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20)
{
  std::ios::~ios();
  _Unwind_Resume(a1);
}

void *sub_101617028(void *result, __int128 *a2, _DWORD *a3, _DWORD *a4)
{
  v6 = result;
  v7 = result[1];
  if (*(a2 + 23) < 0)
  {
    result = sub_100005F2C(result[1], *a2, *(a2 + 1));
  }

  else
  {
    v8 = *a2;
    *(v7 + 16) = *(a2 + 2);
    *v7 = v8;
  }

  *(v7 + 24) = *a3;
  *(v7 + 28) = *a4;
  v6[1] = v7 + 32;
  return result;
}

uint64_t sub_1016170A8(uint64_t a1, __int128 *a2, _DWORD *a3, _DWORD *a4)
{
  v4 = (*(a1 + 8) - *a1) >> 5;
  v5 = v4 + 1;
  if ((v4 + 1) >> 59)
  {
    sub_1000CE3D4();
  }

  v9 = *(a1 + 16) - *a1;
  if (v9 >> 4 > v5)
  {
    v5 = v9 >> 4;
  }

  if (v9 >= 0x7FFFFFFFFFFFFFE0)
  {
    v10 = 0x7FFFFFFFFFFFFFFLL;
  }

  else
  {
    v10 = v5;
  }

  v26 = a1;
  if (v10)
  {
    sub_1016171E8(v10);
  }

  v11 = 32 * v4;
  v22 = 0;
  v23 = v11;
  v12 = 0;
  v24 = v11;
  v25 = 0;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(v11, *a2, *(a2 + 1));
    v14 = v23;
    v15 = v24;
    v12 = v25;
  }

  else
  {
    v13 = *a2;
    *(v11 + 16) = *(a2 + 2);
    *v11 = v13;
    v14 = v11;
    v15 = v11;
  }

  *(v11 + 24) = *a3;
  *(v11 + 28) = *a4;
  v16 = v15 + 32;
  v17 = *(a1 + 8) - *a1;
  v18 = v14 - v17;
  memcpy((v14 - v17), *a1, v17);
  v19 = *a1;
  *a1 = v18;
  *(a1 + 8) = v16;
  v20 = *(a1 + 16);
  *(a1 + 16) = v12;
  v24 = v19;
  v25 = v20;
  v22 = v19;
  v23 = v19;
  sub_10003D0D4(&v22);
  return v16;
}

void sub_1016171D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003D0D4(va);
  _Unwind_Resume(a1);
}

void sub_1016171E8(unint64_t a1)
{
  if (!(a1 >> 59))
  {
    operator new();
  }

  sub_100013D10();
}

void *sub_101617230(void *result, __int128 *a2, _DWORD *a3, _DWORD *a4)
{
  v6 = result;
  v7 = result[1];
  if (*(a2 + 23) < 0)
  {
    result = sub_100005F2C(result[1], *a2, *(a2 + 1));
  }

  else
  {
    v8 = *a2;
    *(v7 + 16) = *(a2 + 2);
    *v7 = v8;
  }

  *(v7 + 24) = *a3;
  *(v7 + 28) = *a4;
  v6[1] = v7 + 32;
  return result;
}

uint64_t sub_1016172B0(uint64_t a1, __int128 *a2, _DWORD *a3, _DWORD *a4)
{
  v4 = (*(a1 + 8) - *a1) >> 5;
  v5 = v4 + 1;
  if ((v4 + 1) >> 59)
  {
    sub_1000CE3D4();
  }

  v9 = *(a1 + 16) - *a1;
  if (v9 >> 4 > v5)
  {
    v5 = v9 >> 4;
  }

  if (v9 >= 0x7FFFFFFFFFFFFFE0)
  {
    v10 = 0x7FFFFFFFFFFFFFFLL;
  }

  else
  {
    v10 = v5;
  }

  v26 = a1;
  if (v10)
  {
    sub_1016171E8(v10);
  }

  v11 = 32 * v4;
  v22 = 0;
  v23 = v11;
  v12 = 0;
  v24 = v11;
  v25 = 0;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(v11, *a2, *(a2 + 1));
    v14 = v23;
    v15 = v24;
    v12 = v25;
  }

  else
  {
    v13 = *a2;
    *(v11 + 16) = *(a2 + 2);
    *v11 = v13;
    v14 = v11;
    v15 = v11;
  }

  *(v11 + 24) = *a3;
  *(v11 + 28) = *a4;
  v16 = v15 + 32;
  v17 = *(a1 + 8) - *a1;
  v18 = v14 - v17;
  memcpy((v14 - v17), *a1, v17);
  v19 = *a1;
  *a1 = v18;
  *(a1 + 8) = v16;
  v20 = *(a1 + 16);
  *(a1 + 16) = v12;
  v24 = v19;
  v25 = v20;
  v22 = v19;
  v23 = v19;
  sub_10003D0D4(&v22);
  return v16;
}

void sub_1016173DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003D0D4(va);
  _Unwind_Resume(a1);
}

void *sub_1016173F0(void *__dst, __int128 *a2)
{
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__dst, *a2, *(a2 + 1));
  }

  else
  {
    v4 = *a2;
    __dst[2] = *(a2 + 2);
    *__dst = v4;
  }

  *(__dst + 6) = *(a2 + 6);
  *(__dst + 7) = *(a2 + 7);
  return __dst;
}

void *sub_101617450(void *a1)
{
  *a1 = off_101F571A0;
  v2 = a1[2];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return a1;
}

void sub_10161749C(void *a1)
{
  *a1 = off_101F571A0;
  v1 = a1[2];
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

uint64_t sub_101617574(uint64_t result, void *a2)
{
  v3 = *(result + 8);
  v2 = *(result + 16);
  *a2 = off_101F571A0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 16), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_1016175AC(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1016175BC(void *__p)
{
  v2 = __p[2];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

const char *sub_1016175FC(uint64_t a1, int *a2)
{
  v3 = *(a1 + 16);
  if (v3)
  {
    v4 = *a2;
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = *(a1 + 8);
      if (v6)
      {
        v7 = *(v6 + 1);
        if (v7 < 0)
        {
          v9 = "5wi.lzl.ct.x.X";
          goto LABEL_16;
        }

        v8 = *v6;
        if ((v8 - 2) < 2)
        {
          v9 = "5wi.lzl.ct.M";
          goto LABEL_16;
        }

        if (v8 == 1)
        {
          goto LABEL_15;
        }

        if (!v8)
        {
          if (v4 == 2)
          {
            v9 = off_101F57280[v7 & 0xF];
            goto LABEL_16;
          }

          if (v4 == 1)
          {
            v9 = off_101F57200[v7 & 0xF];
LABEL_16:
            sub_100004A34(v5);
            return v9;
          }

LABEL_15:
          v9 = "5wi.lzl.ct.T";
          goto LABEL_16;
        }
      }

      v9 = "5wi.lzl.ct.?";
      goto LABEL_16;
    }
  }

  return "5wi.lzl.ct.?";
}

uint64_t sub_1016176D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_1016177EC(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[4], v1, sub_1016178C0);
  __cxa_rethrow();
}

void sub_10161782C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101617880(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1016178C0(uint64_t result)
{
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t *sub_1016178EC(void **a1)
{
  v1 = *a1;
  v31 = a1;
  v32 = v1;
  v2 = v1[2];
  if (v2)
  {
    v3 = *v1;
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (!v1[1])
      {
LABEL_30:
        sub_100004A34(v5);
        goto LABEL_31;
      }

      ServiceMap = Registry::getServiceMap(*(v3 + 64));
      v7 = ServiceMap;
      if (v8 < 0)
      {
        v9 = (v8 & 0x7FFFFFFFFFFFFFFFLL);
        v10 = 5381;
        do
        {
          v8 = v10;
          v11 = *v9++;
          v10 = (33 * v10) ^ v11;
        }

        while (v11);
      }

      std::mutex::lock(ServiceMap);
      v38[0] = v8;
      v12 = sub_100009510(&v7[1].__m_.__sig, v38);
      if (v12)
      {
        v14 = v12[3];
        v13 = v12[4];
        if (v13)
        {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v7);
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_100004A34(v13);
          v15 = 0;
          if (!v14)
          {
            goto LABEL_27;
          }

          goto LABEL_13;
        }
      }

      else
      {
        v14 = 0;
      }

      std::mutex::unlock(v7);
      v13 = 0;
      v15 = 1;
      if (!v14)
      {
LABEL_27:
        if ((v15 & 1) == 0)
        {
          sub_100004A34(v13);
        }

        v28 = *(v3 + 168);
        *(v3 + 172) = v28;
        v29 = (*(**(v3 + 136) + 464))(*(v3 + 136));
        sub_101611658(v3, v28, v29, *(v3 + 172));
        goto LABEL_30;
      }

LABEL_13:
      v35 = 0;
      v36 = 0;
      v37 = 0;
      if ((*(*v14 + 16))(v14))
      {
        (*(*v14 + 24))(__p, v14);
        v16 = v36;
        if (v36 >= v37)
        {
          v18 = 0xAAAAAAAAAAAAAAABLL * ((v36 - v35) >> 3);
          v19 = v18 + 1;
          if (v18 + 1 > 0xAAAAAAAAAAAAAAALL)
          {
            sub_1000CE3D4();
          }

          if (0x5555555555555556 * ((v37 - v35) >> 3) > v19)
          {
            v19 = 0x5555555555555556 * ((v37 - v35) >> 3);
          }

          if (0xAAAAAAAAAAAAAAABLL * ((v37 - v35) >> 3) >= 0x555555555555555)
          {
            v20 = 0xAAAAAAAAAAAAAAALL;
          }

          else
          {
            v20 = v19;
          }

          v38[4] = &v35;
          if (v20)
          {
            sub_100005348(&v35, v20);
          }

          v21 = 8 * ((v36 - v35) >> 3);
          v22 = *__p;
          *(v21 + 16) = v34;
          *v21 = v22;
          __p[1] = 0;
          v34 = 0;
          __p[0] = 0;
          v23 = 24 * v18 + 24;
          v24 = (24 * v18 - (v36 - v35));
          memcpy((v21 - (v36 - v35)), v35, v36 - v35);
          v25 = v35;
          v26 = v37;
          v35 = v24;
          v36 = v23;
          v37 = 0;
          v38[0] = v25;
          v38[2] = v25;
          v38[3] = v26;
          v38[1] = v25;
          sub_1000054E0(v38);
          v36 = v23;
          if (SHIBYTE(v34) < 0)
          {
            operator delete(__p[0]);
          }
        }

        else
        {
          v17 = *__p;
          *(v36 + 2) = v34;
          *v16 = v17;
          v36 = v16 + 24;
        }
      }

      v27 = (*(*v14 + 16))(v14);
      (*(*v3 + 264))(v3, v27, &v35);
      v38[0] = &v35;
      sub_1000087B4(v38);
      goto LABEL_27;
    }
  }

LABEL_31:
  sub_10007060C(&v32);
  return sub_1000049E0(&v31);
}

void sub_101617C40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a17 < 0)
  {
    operator delete(__p);
  }

  __p = &a18;
  sub_1000087B4(&__p);
  if ((v20 & 1) == 0)
  {
    sub_100004A34(v19);
  }

  sub_100004A34(v18);
  sub_10007060C(&a11);
  sub_1000049E0(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_101617CAC(void **a1)
{
  v1 = *a1;
  v8 = a1;
  v9 = v1;
  v2 = v1[2];
  if (v2)
  {
    v3 = *v1;
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (v1[1])
      {
        v6 = *(v3 + 104);
        v10 = 2;
        v11 = 0;
        (*(*v6 + 72))(v6, &v10);
      }

      sub_100004A34(v5);
    }
  }

  sub_10007060C(&v9);
  return sub_1000049E0(&v8);
}

void sub_101617D54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100004A34(v10);
  sub_10007060C(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101617D78(void **a1)
{
  v1 = *a1;
  v8 = a1;
  v9 = v1;
  v2 = v1[2];
  if (v2)
  {
    v3 = *v1;
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (v1[1])
      {
        v6 = *(v3 + 212);
        if ((*(v3 + 200) & 1) != 0 || v6 == 1)
        {
          sub_10161261C(v3, v6);
        }
      }

      sub_100004A34(v5);
    }
  }

  sub_10007060C(&v9);
  return sub_1000049E0(&v8);
}

void sub_101617E00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100004A34(v10);
  sub_10007060C(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101617E24(uint64_t *a1)
{
  v1 = *a1;
  v9 = a1;
  v10 = v1;
  v2 = *(v1 + 24);
  if (v2)
  {
    v3 = *v1;
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (*(v1 + 16))
      {
        v6 = *(v3 + 104);
        v7 = *(v1 + 8);
        v11[0] = *(v3 + 168);
        v11[1] = v7;
        v11[2] = v7;
        (*(*v6 + 72))(v6, v11);
        if (!*(v3 + 272))
        {
          sub_1016127C8(v3);
        }

        sub_1016118D8(v3);
      }

      sub_100004A34(v5);
    }
  }

  sub_1015165CC(&v10);
  return sub_1000049E0(&v9);
}

void sub_101617EE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100004A34(v10);
  sub_1015165CC(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_101617F0C(void *a1, std::mutex *this)
{
  if ((v4 & 0x8000000000000000) != 0)
  {
    v5 = (v4 & 0x7FFFFFFFFFFFFFFFLL);
    v6 = 5381;
    do
    {
      v4 = v6;
      v7 = *v5++;
      v6 = (33 * v6) ^ v7;
    }

    while (v7);
  }

  std::mutex::lock(this);
  v11 = v4;
  v8 = sub_100009510(&this[1].__m_.__sig, &v11);
  if (v8)
  {
    v10 = v8[3];
    v9 = v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }

  else
  {
    v10 = 0;
    v9 = 0;
  }

  std::mutex::unlock(this);
  *a1 = v10;
  a1[1] = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_100004A34(v9);
  }
}

uint64_t sub_101617FD0(uint64_t a1, void **a2)
{
  v3 = (a1 + 8);
  v2 = *(a1 + 8);
  if (!v2)
  {
    goto LABEL_7;
  }

  while (1)
  {
    while (1)
    {
      v5 = v2;
      if ((sub_1000068BC(a2, (v2 + 32)) & 0x80) == 0)
      {
        break;
      }

      v2 = *v5;
      v3 = v5;
      if (!*v5)
      {
        goto LABEL_7;
      }
    }

    result = sub_1000068BC(v5 + 4, a2);
    if ((result & 0x80) == 0)
    {
      break;
    }

    v3 = v5 + 1;
    v2 = v5[1];
    if (!v2)
    {
      goto LABEL_7;
    }
  }

  if (!*v3)
  {
LABEL_7:
    operator new();
  }

  return result;
}

uint64_t sub_1016180E0(uint64_t a1)
{
  *a1 = off_101F57380;
  if (*(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  v2 = *(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return a1;
}

void sub_10161813C(uint64_t a1)
{
  *a1 = off_101F57380;
  if (*(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  v2 = *(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void sub_101618264(_Unwind_Exception *a1)
{
  v3 = v1[2];
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_101618284(char *result, uint64_t a2)
{
  v3 = result;
  v5 = *(result + 1);
  v4 = *(result + 2);
  *a2 = off_101F57380;
  *(a2 + 8) = v5;
  *(a2 + 16) = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 16), 1uLL, memory_order_relaxed);
  }

  if (result[47] < 0)
  {
    result = sub_100005F2C((a2 + 24), *(result + 3), *(result + 4));
  }

  else
  {
    v6 = *(result + 24);
    *(a2 + 40) = *(result + 5);
    *(a2 + 24) = v6;
  }

  v7 = *(v3 + 14);
  *(a2 + 48) = *(v3 + 6);
  *(a2 + 56) = v7;
  return result;
}

void sub_101618314(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_101618334(void *a1)
{
  sub_101618E78(a1 + 8);

  operator delete(a1);
}

void sub_101618370(uint64_t a1, __int128 **a2)
{
  v3 = *(a1 + 16);
  if (!v3)
  {
    return;
  }

  v4 = std::__shared_weak_count::lock(v3);
  if (!v4)
  {
    return;
  }

  v5 = v4;
  v6 = *(a1 + 8);
  if (!v6)
  {
    goto LABEL_105;
  }

  v48 = *(a1 + 48);
  v51 = *(a1 + 56);
  (*(**(v6 + 104) + 200))(buf);
  v7 = (*(**(v6 + 56) + 16))(*(v6 + 56), *(*buf + 52));
  if (*&buf[8])
  {
    sub_100004A34(*&buf[8]);
  }

  v8 = sub_100007A6C(v6 + 256, (a1 + 24));
  if ((v6 + 264) == v8)
  {
    v12 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "got service resolver callback without triggering DNS resolve?", buf, 2u);
    }

    if (!*(v6 + 272))
    {
      v13 = *(v6 + 416);
      *(v6 + 408) = 0;
      *(v6 + 416) = 0;
      if (v13)
      {
        sub_100004A34(v13);
      }
    }

    goto LABEL_105;
  }

  v9 = v8;
  sub_100D7A2B0((v6 + 256), v8);
  sub_1000D57F4((v9 + 4));
  operator delete(v9);
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v47 = v5;
  v10 = (*(**(v6 + 104) + 120))(*(v6 + 104));
  v11 = v71;
  if (v10)
  {
    if (v71 >= v72)
    {
      v14 = 0xAAAAAAAAAAAAAAABLL * ((v71 - v70) >> 3);
      if (v14 + 1 > 0xAAAAAAAAAAAAAAALL)
      {
        goto LABEL_111;
      }

      v15 = 0x5555555555555556 * ((v72 - v70) >> 3);
      if (v15 <= v14 + 1)
      {
        v15 = v14 + 1;
      }

      if (0xAAAAAAAAAAAAAAABLL * ((v72 - v70) >> 3) >= 0x555555555555555)
      {
        v16 = 0xAAAAAAAAAAAAAAALL;
      }

      else
      {
        v16 = v15;
      }

      *&v54 = &v70;
      if (v16)
      {
        sub_100005348(&v70, v16);
      }

      *buf = 0;
      *&buf[8] = 8 * ((v71 - v70) >> 3);
      __p[0] = *&buf[8];
      __p[1] = 0;
      sub_10000501C(*&buf[8], "SIPS+D2T.");
      v11 = __p[0] + 24;
      v17 = (*&buf[8] - (v71 - v70));
      memcpy(v17, v70, v71 - v70);
      v18 = v70;
      v19 = v72;
      v70 = v17;
      v71 = v11;
      v72 = __p[1];
      __p[0] = v18;
      __p[1] = v19;
      *buf = v18;
      *&buf[8] = v18;
      sub_1000054E0(buf);
    }

    else
    {
      sub_10000501C(v71, "SIPS+D2T.");
      v11 += 24;
    }

    v71 = v11;
  }

  if (v11 >= v72)
  {
    v21 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v70) >> 3);
    if (v21 + 1 <= 0xAAAAAAAAAAAAAAALL)
    {
      v22 = 0x5555555555555556 * ((v72 - v70) >> 3);
      if (v22 <= v21 + 1)
      {
        v22 = v21 + 1;
      }

      if (0xAAAAAAAAAAAAAAABLL * ((v72 - v70) >> 3) >= 0x555555555555555)
      {
        v23 = 0xAAAAAAAAAAAAAAALL;
      }

      else
      {
        v23 = v22;
      }

      *&v54 = &v70;
      if (v23)
      {
        sub_100005348(&v70, v23);
      }

      *buf = 0;
      *&buf[8] = 8 * ((v11 - v70) >> 3);
      __p[0] = *&buf[8];
      __p[1] = 0;
      sub_10000501C(*&buf[8], "SIP+D2T.");
      v20 = __p[0] + 24;
      v24 = (*&buf[8] - (v71 - v70));
      memcpy(v24, v70, v71 - v70);
      v25 = v70;
      v26 = v72;
      v70 = v24;
      v71 = v20;
      v72 = __p[1];
      __p[0] = v25;
      __p[1] = v26;
      *buf = v25;
      *&buf[8] = v25;
      sub_1000054E0(buf);
      goto LABEL_37;
    }

LABEL_111:
    sub_1000CE3D4();
  }

  sub_10000501C(v11, "SIP+D2T.");
  v20 = v11 + 24;
LABEL_37:
  v71 = v20;
  v27 = v70;
  if (v70 == v20)
  {
LABEL_96:
    v43 = *(v6 + 24);
    if (v43)
    {
      v44 = *(v6 + 16);
      v45 = std::__shared_weak_count::lock(v43);
      if (v45)
      {
        *buf = v44;
        *&buf[8] = v45;
        atomic_fetch_add_explicit(&v45->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v45);
        if (*(a1 + 47) < 0)
        {
          sub_100005F2C(__p, *(a1 + 24), *(a1 + 32));
        }

        else
        {
          *__p = *(a1 + 24);
          *&v54 = *(a1 + 40);
        }

        *(&v54 + 1) = v48;
        v55 = v51;
        v46 = *(v6 + 24);
        if (v46)
        {
          if (std::__shared_weak_count::lock(v46))
          {
            operator new();
          }
        }

        sub_100013CC4();
      }
    }

    sub_100013CC4();
  }

  v49 = v20;
  while (1)
  {
    v69 = 0;
    __dst = 0uLL;
    if (v27[23] < 0)
    {
      sub_100005F2C(&__dst, *v27, *(v27 + 1));
    }

    else
    {
      v28 = *v27;
      v69 = *(v27 + 2);
      __dst = v28;
    }

    v29 = *a2;
    v30 = a2[1];
    if (*a2 != v30)
    {
      v31 = 0;
      while (1)
      {
        *__p = 0u;
        v54 = 0u;
        *buf = 0u;
        sub_100041088(buf, v29);
        v32 = HIBYTE(v54);
        if (v54 >= 0)
        {
          v33 = HIBYTE(v54);
        }

        else
        {
          v33 = v54;
        }

        v34 = HIBYTE(v69);
        if (v69 < 0)
        {
          v34 = *(&__dst + 1);
        }

        if (v33 == v34)
        {
          v35 = v54 >= 0 ? &__p[1] : __p[1];
          v36 = v69 >= 0 ? &__dst : __dst;
          if (!memcmp(v35, v36, v33))
          {
            break;
          }
        }

        if (v32 < 0)
        {
          goto LABEL_58;
        }

LABEL_59:
        if (SHIBYTE(__p[0]) < 0)
        {
          operator delete(*buf);
        }

        v29 += 3;
        if (v29 == v30)
        {
          goto LABEL_90;
        }
      }

      v66[0] = 0;
      v66[1] = 0;
      v67 = 0;
      sub_1016146D4(v66, v6);
      v64 = 0;
      v65 = 0;
      v37 = *(v6 + 96);
      v38 = *(v6 + 32);
      object = v38;
      if (v38)
      {
        dispatch_retain(v38);
      }

      (*(*v37 + 80))(&v64, v37, &object);
      if (object)
      {
        dispatch_release(object);
      }

      v39 = v64;
      if (v64)
      {
        if (SHIBYTE(__p[0]) < 0)
        {
          sub_100005F2C(v59, *buf, *&buf[8]);
          v39 = v64;
        }

        else
        {
          *v59 = *buf;
          v60 = __p[0];
        }

        v61 = v39;
        v62 = v65;
        if (v65)
        {
          atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        sub_101617FD0(v6 + 256, v59);
        if (v62)
        {
          sub_100004A34(v62);
        }

        if (SHIBYTE(v60) < 0)
        {
          operator delete(v59[0]);
        }

        v40 = *(v6 + 24);
        if (v40)
        {
          v41 = *(v6 + 16);
          v42 = std::__shared_weak_count::lock(v40);
          if (v42)
          {
            v56[0] = v41;
            v56[1] = v42;
            atomic_fetch_add_explicit(&v42->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_100004A34(v42);
            if (SHIBYTE(__p[0]) < 0)
            {
              sub_100005F2C(v57, *buf, *&buf[8]);
            }

            else
            {
              *v57 = *buf;
              v57[2] = __p[0];
            }

            v58 = v51;
            v73 = 0;
            operator new();
          }
        }

        sub_100013CC4();
      }

      if (v65)
      {
        sub_100004A34(v65);
      }

      if (SHIBYTE(v67) < 0)
      {
        operator delete(v66[0]);
      }

      v31 = 1;
      if ((HIBYTE(v54) & 0x80) == 0)
      {
        goto LABEL_59;
      }

LABEL_58:
      operator delete(__p[1]);
      goto LABEL_59;
    }

    v31 = 0;
LABEL_90:
    if (SHIBYTE(v69) < 0)
    {
      operator delete(__dst);
    }

    if (v31)
    {
      break;
    }

    v27 += 24;
    if (v27 == v49)
    {
      goto LABEL_96;
    }
  }

  if (v48)
  {
    goto LABEL_96;
  }

  *buf = &v70;
  sub_1000087B4(buf);
  v5 = v47;
LABEL_105:

  sub_100004A34(v5);
}

void sub_101618CE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, std::__shared_weak_count *a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, dispatch_object_t object)
{
  sub_1000054E0(&a17);
  a31 = v37 - 152;
  sub_1000087B4(&a31);
  sub_100004A34(a10);
  _Unwind_Resume(a1);
}

uint64_t sub_101618E2C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_101618E78(uint64_t a1)
{
  if (*(a1 + 39) < 0)
  {
    operator delete(*(a1 + 16));
  }

  v2 = *(a1 + 8);
  if (v2)
  {

    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t sub_101618ECC(uint64_t a1)
{
  *a1 = off_101F57410;
  if (*(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  v2 = *(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return a1;
}

void sub_101618F28(uint64_t a1)
{
  *a1 = off_101F57410;
  if (*(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  v2 = *(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void sub_101619048(_Unwind_Exception *a1)
{
  v3 = v1[2];
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_101619068(char *result, uint64_t a2)
{
  v3 = result;
  v5 = *(result + 1);
  v4 = *(result + 2);
  *a2 = off_101F57410;
  *(a2 + 8) = v5;
  *(a2 + 16) = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 16), 1uLL, memory_order_relaxed);
  }

  if (result[47] < 0)
  {
    result = sub_100005F2C((a2 + 24), *(result + 3), *(result + 4));
  }

  else
  {
    v6 = *(result + 24);
    *(a2 + 40) = *(result + 5);
    *(a2 + 24) = v6;
  }

  *(a2 + 48) = *(v3 + 12);
  return result;
}

void sub_1016190F0(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_101619110(void *a1)
{
  sub_101618E78(a1 + 8);

  operator delete(a1);
}

void sub_10161914C(uint64_t a1, __int128 **a2, int *a3)
{
  v4 = *(a1 + 16);
  if (v4)
  {
    v6 = *a3;
    v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      v8 = v7;
      v9 = *(a1 + 8);
      if (v9)
      {
        v10 = *(a1 + 48);
        (*(**(v9 + 104) + 200))(__p);
        v11 = (*(**(v9 + 56) + 16))(*(v9 + 56), *(__p[0] + 13));
        if (__p[1])
        {
          sub_100004A34(__p[1]);
        }

        v12 = sub_100007A6C(v9 + 256, (a1 + 24));
        if ((v9 + 264) == v12)
        {
          v26 = *v11;
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p[0]) = 0;
            _os_log_error_impl(&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "got service resolver callback without triggering DNS resolve?", __p, 2u);
          }

          if (!*(v9 + 272))
          {
            v27 = *(v9 + 416);
            *(v9 + 408) = 0;
            *(v9 + 416) = 0;
            if (v27)
            {
              sub_100004A34(v27);
            }
          }
        }

        else
        {
          v13 = v12;
          sub_100D7A2B0((v9 + 256), v12);
          sub_1000D57F4((v13 + 4));
          operator delete(v13);
          v15 = *a2;
          v14 = a2[1];
          while (v15 != v14)
          {
            *__p = 0u;
            *v33 = 0u;
            if (*(v15 + 23) < 0)
            {
              sub_100005F2C(__p, *v15, *(v15 + 1));
            }

            else
            {
              v16 = *v15;
              v33[0] = *(v15 + 2);
              *__p = v16;
            }

            LODWORD(v33[1]) = *(v15 + 6);
            sub_1016150B0(v9, __p, v33[1], v33[1], 0, v10);
            if (SHIBYTE(v33[0]) < 0)
            {
              operator delete(__p[0]);
            }

            v15 += 2;
          }

          if (!*(v9 + 272))
          {
            v17 = *(v9 + 416);
            *(v9 + 408) = 0;
            *(v9 + 416) = 0;
            if (v17)
            {
              sub_100004A34(v17);
            }

            sub_1016158DC(v9, v6);
            if (*(v9 + 304) == *(v9 + 312) && *(v9 + 280) == *(v9 + 288) && *(v9 + 328) == *(v9 + 336) && *(v9 + 352) == *(v9 + 360))
            {
              v28 = v10 + 1;
              if (v28 <= 4)
              {
                v29 = *v11;
                if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(__p[0]) = 0;
                  _os_log_error_impl(&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "got empty DNS results. Retrying...", __p, 2u);
                }

                v30 = *(v9 + 16);
                __p[0] = v9;
                sub_100E13114(&__p[1], v30, *(v9 + 24));
                LODWORD(v33[1]) = v28;
                sub_101615ED8(v9 + 16);
              }
            }

            else
            {
              v18 = *(v9 + 399);
              if (v18 < 0)
              {
                v18 = *(v9 + 384);
              }

              if (!v18)
              {
                v19 = *(v9 + 232);
                for (i = *(v9 + 240); v19 != i; v19 = (v19 + 24))
                {
                  __p[1] = 0;
                  v33[0] = 0;
                  __p[0] = 0;
                  if (*(v19 + 23) < 0)
                  {
                    sub_100005F2C(__p, *v19, *(v19 + 1));
                  }

                  else
                  {
                    v21 = *v19;
                    v33[0] = *(v19 + 2);
                    *__p = v21;
                  }

                  v22 = *v11;
                  if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
                  {
                    if (SHIBYTE(v33[0]) >= 0)
                    {
                      v23 = __p;
                    }

                    else
                    {
                      v23 = __p[0];
                    }

                    *buf = 136446210;
                    v35 = v23;
                    _os_log_impl(&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I P-CSCF: %{public}s", buf, 0xCu);
                  }

                  v31 = 0;
                  sub_101614AB8(buf, v9, __p, &v31 + 1, &v31);
                  v24 = HIBYTE(v33[0]);
                  v25 = HIBYTE(v33[0]);
                  if (SHIBYTE(v33[0]) < 0)
                  {
                    v24 = __p[1];
                  }

                  if (v24)
                  {
                    std::string::operator=((v9 + 376), __p);
                    v25 = HIBYTE(v33[0]);
                  }

                  if (v25 < 0)
                  {
                    operator delete(__p[0]);
                  }
                }
              }

              sub_1016127C8(v9);
            }
          }
        }
      }

      sub_100004A34(v8);
    }
  }
}

uint64_t sub_1016195F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_10161963C(uint64_t *a1)
{
  v1 = *a1;
  v6 = a1;
  v7 = v1;
  v2 = *(v1 + 8);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      if (*v1)
      {
        sub_1016150B0(*v1, v1 + 16, *(v1 + 40), *(v1 + 44), 1, *(v1 + 48));
      }

      sub_100004A34(v4);
    }
  }

  sub_1016196D4(&v7);
  return sub_1000049E0(&v6);
}

void sub_1016196B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100004A34(v10);
  sub_1016196D4(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1016196D4(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    if (*(v1 + 39) < 0)
    {
      operator delete(*(v1 + 16));
    }

    v2 = *(v1 + 8);
    if (v2)
    {
      std::__shared_weak_count::__release_weak(v2);
    }

    operator delete();
  }

  return result;
}

uint64_t *sub_101619738(uint64_t *a1)
{
  v1 = *a1;
  v7 = a1;
  v8 = v1;
  v2 = *(v1 + 16);
  if (v2)
  {
    v3 = *v1;
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (*(v1 + 8))
      {
        sub_101611D18(v3, *(v1 + 24));
      }

      sub_100004A34(v5);
    }
  }

  sub_100403C5C(&v8);
  return sub_1000049E0(&v7);
}

void sub_1016197B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100004A34(v10);
  sub_100403C5C(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1016197D4(uint64_t a1)
{
  *a1 = off_101F574A0;
  if (*(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  v2 = *(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return a1;
}

void sub_101619830(uint64_t a1)
{
  *a1 = off_101F574A0;
  if (*(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  v2 = *(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void sub_101619960(_Unwind_Exception *a1)
{
  v3 = v1[2];
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_101619980(char *result, uint64_t a2)
{
  v3 = result;
  v5 = *(result + 1);
  v4 = *(result + 2);
  *a2 = off_101F574A0;
  *(a2 + 8) = v5;
  *(a2 + 16) = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 16), 1uLL, memory_order_relaxed);
  }

  if (result[47] < 0)
  {
    result = sub_100005F2C((a2 + 24), *(result + 3), *(result + 4));
  }

  else
  {
    v6 = *(result + 24);
    *(a2 + 40) = *(result + 5);
    *(a2 + 24) = v6;
  }

  v7 = *(v3 + 6);
  *(a2 + 53) = *(v3 + 53);
  *(a2 + 48) = v7;
  *(a2 + 61) = 0;
  *(a2 + 63) = 0;
  return result;
}

void sub_101619A18(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_101619A38(void *a1)
{
  sub_101618E78(a1 + 8);

  operator delete(a1);
}

void sub_101619A74(uint64_t a1, uint64_t *a2, int *a3)
{
  v4 = *(a1 + 16);
  if (v4)
  {
    v6 = *a3;
    v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      v8 = v7;
      v9 = *(a1 + 8);
      if (v9)
      {
        v23 = 0;
        v24 = 0;
        v25 = 0;
        sub_10004EFD0(&v23, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 1174405120;
        v15[2] = sub_101619D38;
        v15[3] = &unk_101F57500;
        v15[4] = v9;
        v16 = v8;
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        if (*(a1 + 47) < 0)
        {
          sub_100005F2C(&__p, *(a1 + 24), *(a1 + 32));
        }

        else
        {
          __p = *(a1 + 24);
          v18 = *(a1 + 40);
        }

        memset(v19, 0, 24);
        sub_10004EFD0(v19, v23, v24, 0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 3));
        v19[3] = *(a1 + 48);
        v22 = *(a1 + 60);
        v20 = *(a1 + 56);
        v21 = v6;
        v10 = v9[3];
        if (!v10 || (v11 = v9[2], (v12 = std::__shared_weak_count::lock(v10)) == 0))
        {
          sub_100013CC4();
        }

        v13 = v12;
        v14 = v9[4];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_10161A5AC;
        block[3] = &unk_101F57538;
        block[5] = v11;
        v27 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v15;
        dispatch_async(v14, block);
        if (v27)
        {
          sub_100004A34(v27);
        }

        sub_100004A34(v13);
        block[0] = v19;
        sub_1000087B4(block);
        if (SHIBYTE(v18) < 0)
        {
          operator delete(__p);
        }

        if (v16)
        {
          sub_100004A34(v16);
        }

        block[0] = &v23;
        sub_1000087B4(block);
      }

      sub_100004A34(v8);
    }
  }
}

void sub_101619C98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28)
{
  if (a15)
  {
    sub_100004A34(a15);
  }

  *(v29 - 120) = &a28;
  sub_1000087B4((v29 - 120));
  sub_100004A34(v28);
  _Unwind_Resume(a1);
}

uint64_t sub_101619CEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_101619D38(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(a1 + 96);
  v4 = *(a1 + 100);
  v5 = *(a1 + 112);
  v7 = *(a1 + 104);
  v6 = *(a1 + 108);
  v53 = v4;
  v54 = v3;
  (*(**(v2 + 104) + 200))(&__str);
  v8 = (*(**(v2 + 56) + 16))(*(v2 + 56), *(__str.__r_.__value_.__r.__words[0] + 52));
  if (__str.__r_.__value_.__l.__size_)
  {
    sub_100004A34(__str.__r_.__value_.__l.__size_);
  }

  __p[0] = 0;
  __p[1] = 0;
  v52 = 0;
  if (*(a1 + 71) >= 0)
  {
    v9 = *(a1 + 71);
  }

  else
  {
    v9 = *(a1 + 56);
  }

  memset(&v50, 0, sizeof(v50));
  v10 = &v50;
  sub_1000677C4(&v50, v9 + 1);
  if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    v10 = v50.__r_.__value_.__r.__words[0];
  }

  if (v9)
  {
    if (*(a1 + 71) >= 0)
    {
      v11 = (a1 + 48);
    }

    else
    {
      v11 = *(a1 + 48);
    }

    memmove(v10, v11, v9);
  }

  *(&v10->__r_.__value_.__l.__data_ + v9) = 58;
  std::to_string(&v49, v3);
  if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v12 = &v49;
  }

  else
  {
    v12 = v49.__r_.__value_.__r.__words[0];
  }

  if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(v49.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = v49.__r_.__value_.__l.__size_;
  }

  v14 = std::string::append(&v50, v12, size);
  v15 = *&v14->__r_.__value_.__l.__data_;
  v55.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *&v55.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  v16 = std::string::append(&v55, ":", 1uLL);
  v17 = *&v16->__r_.__value_.__l.__data_;
  __str.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *&__str.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v48, v4);
  if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v18 = &v48;
  }

  else
  {
    v18 = v48.__r_.__value_.__r.__words[0];
  }

  if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v19 = HIBYTE(v48.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v19 = v48.__r_.__value_.__l.__size_;
  }

  v20 = std::string::append(&__str, v18, v19);
  v21 = *&v20->__r_.__value_.__l.__data_;
  v52 = v20->__r_.__value_.__r.__words[2];
  *__p = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v48.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v55.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v49.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v50.__r_.__value_.__l.__data_);
  }

  v22 = sub_100007A6C(v2 + 256, __p);
  if ((v2 + 264) == v22)
  {
    v35 = *v8;
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__str.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "got callback without triggering DNS resolve?", &__str, 2u);
    }

    if (!*(v2 + 272))
    {
      v36 = *(v2 + 416);
      *(v2 + 408) = 0;
      *(v2 + 416) = 0;
      if (v36)
      {
        sub_100004A34(v36);
      }
    }
  }

  else
  {
    v23 = v22;
    sub_100D7A2B0((v2 + 256), v22);
    sub_1000D57F4((v23 + 4));
    operator delete(v23);
    v25 = *(a1 + 72);
    v24 = *(a1 + 80);
    v55.__r_.__value_.__r.__words[0] = v2;
    v55.__r_.__value_.__l.__size_ = __PAIR64__(v4, v3);
    for (v55.__r_.__value_.__s.__data_[16] = v5; v25 != v24; v25 = (v25 + 24))
    {
      memset(&__str, 0, sizeof(__str));
      CSIPacketAddress::CSIPacketAddress();
      if ((CSIPacketAddress::isZeroIP(&__str) & 1) == 0)
      {
        if (CSIPacketAddress::isIPv4(&__str))
        {
          if (v5)
          {
            v26 = *(v2 + 312);
            if (v26 >= *(v2 + 320))
            {
              v27 = sub_1016172B0(v2 + 304, v25, &v55.__r_.__value_.__r.__words[1], &v55.__r_.__value_.__r.__words[1] + 1);
            }

            else
            {
              sub_101617230((v2 + 304), v25, &v55.__r_.__value_.__r.__words[1], &v55.__r_.__value_.__r.__words[1] + 1);
              v27 = v26 + 32;
            }

            *(v2 + 312) = v27;
          }

          else
          {
            v30 = *(v2 + 360);
            if (v30 >= *(v2 + 368))
            {
              v31 = sub_1016172B0(v2 + 352, v25, &v55.__r_.__value_.__r.__words[1], &v55.__r_.__value_.__r.__words[1] + 1);
            }

            else
            {
              sub_101617230((v2 + 352), v25, &v55.__r_.__value_.__r.__words[1], &v55.__r_.__value_.__r.__words[1] + 1);
              v31 = v30 + 32;
            }

            *(v2 + 360) = v31;
          }
        }

        else if (CSIPacketAddress::isIPv6(&__str))
        {
          if (v5)
          {
            v28 = *(v2 + 288);
            if (v28 >= *(v2 + 296))
            {
              v29 = sub_1016172B0(v2 + 280, v25, &v55.__r_.__value_.__r.__words[1], &v55.__r_.__value_.__r.__words[1] + 1);
            }

            else
            {
              sub_101617230((v2 + 280), v25, &v55.__r_.__value_.__r.__words[1], &v55.__r_.__value_.__r.__words[1] + 1);
              v29 = v28 + 32;
            }

            *(v2 + 288) = v29;
          }

          else
          {
            v32 = *(v2 + 336);
            if (v32 >= *(v2 + 344))
            {
              v33 = sub_1016172B0(v2 + 328, v25, &v55.__r_.__value_.__r.__words[1], &v55.__r_.__value_.__r.__words[1] + 1);
            }

            else
            {
              sub_101617230((v2 + 328), v25, &v55.__r_.__value_.__r.__words[1], &v55.__r_.__value_.__r.__words[1] + 1);
              v33 = v32 + 32;
            }

            *(v2 + 336) = v33;
          }
        }
      }
    }

    if (!*(v2 + 272))
    {
      v34 = *(v2 + 416);
      *(v2 + 408) = 0;
      *(v2 + 416) = 0;
      if (v34)
      {
        sub_100004A34(v34);
      }

      sub_1016158DC(v2, v6);
      if (*(v2 + 304) != *(v2 + 312) || *(v2 + 280) != *(v2 + 288) || *(v2 + 328) != *(v2 + 336) || *(v2 + 352) != *(v2 + 360))
      {
        if ((*(v2 + 399) & 0x8000000000000000) != 0)
        {
          if (!*(v2 + 384))
          {
            goto LABEL_76;
          }
        }

        else if (!*(v2 + 399))
        {
LABEL_76:
          v37 = *(v2 + 232);
          for (i = *(v2 + 240); v37 != i; v37 = (v37 + 24))
          {
            memset(&__str, 0, sizeof(__str));
            if (*(v37 + 23) < 0)
            {
              sub_100005F2C(&__str, *v37, *(v37 + 1));
            }

            else
            {
              v39 = *v37;
              __str.__r_.__value_.__r.__words[2] = *(v37 + 2);
              *&__str.__r_.__value_.__l.__data_ = v39;
            }

            v40 = *v8;
            if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
            {
              if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              {
                p_str = &__str;
              }

              else
              {
                p_str = __str.__r_.__value_.__r.__words[0];
              }

              LODWORD(v55.__r_.__value_.__l.__data_) = 136446210;
              *(v55.__r_.__value_.__r.__words + 4) = p_str;
              _os_log_impl(&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I P-CSCF: %{public}s", &v55, 0xCu);
            }

            sub_101614AB8(&v55, v2, &__str, &v54, &v53);
            v42 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            v43 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            {
              v42 = __str.__r_.__value_.__l.__size_;
            }

            if (v42)
            {
              std::string::operator=((v2 + 376), &__str);
              v43 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            }

            if (v43 < 0)
            {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
          }
        }

        sub_1016127C8(v2);
        goto LABEL_93;
      }

      if ((v7 + 1) <= 4)
      {
        v44 = *v8;
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__str.__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl(&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "got empty DNS results. Retrying...", &__str, 2u);
        }

        v45 = *(v2 + 16);
        __str.__r_.__value_.__r.__words[0] = v2;
        sub_100E13114(&__str.__r_.__value_.__l.__size_, v45, *(v2 + 24));
        v47 = v7 + 1;
        sub_101615FDC(v2 + 16);
      }
    }
  }

LABEL_93:
  if (SHIBYTE(v52) < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_10161A3C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, uint64_t a32, int a33, __int16 a34, char a35, char a36, void *__p, uint64_t a38, int a39, __int16 a40, char a41, char a42)
{
  if (a42 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10161A49C(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 40);
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 8), 1uLL, memory_order_relaxed);
  }

  if (*(a2 + 71) < 0)
  {
    sub_100005F2C((a1 + 48), *(a2 + 48), *(a2 + 56));
  }

  else
  {
    v5 = *(a2 + 48);
    *(a1 + 64) = *(a2 + 64);
    *(a1 + 48) = v5;
  }

  *(a1 + 72) = 0;
  *(a1 + 80) = 0;
  *(a1 + 88) = 0;
  return sub_10004EFD0(a1 + 72, *(a2 + 72), *(a2 + 80), 0xAAAAAAAAAAAAAAABLL * ((*(a2 + 80) - *(a2 + 72)) >> 3));
}

void sub_10161A528(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 40);
  if (v3)
  {
    sub_100004A34(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_10161A558(uint64_t a1)
{
  v3 = (a1 + 72);
  sub_1000087B4(&v3);
  if (*(a1 + 71) < 0)
  {
    operator delete(*(a1 + 48));
  }

  v2 = *(a1 + 40);
  if (v2)
  {
    sub_100004A34(v2);
  }
}

uint64_t sub_10161A5BC(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 48);
  *(result + 40) = *(a2 + 40);
  *(result + 48) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_10161A5D8(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (v1)
  {
    sub_100004A34(v1);
  }
}

uint64_t *sub_10161A5E8(uint64_t *a1)
{
  v1 = *a1;
  v7 = a1;
  v8 = v1;
  v2 = *(v1 + 16);
  if (v2)
  {
    v3 = *v1;
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (*(v1 + 8))
      {
        sub_101611D18(v3, *(v1 + 24));
      }

      sub_100004A34(v5);
    }
  }

  sub_100403C5C(&v8);
  return sub_1000049E0(&v7);
}

void sub_10161A660(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100004A34(v10);
  sub_100403C5C(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_10161A750(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_release(v1);
  }

  if (v2)
  {
    operator delete();
  }

  _Unwind_Resume(exception_object);
}

const void **sub_10161A778(uint64_t a1)
{
  v2 = CFCalendarCreateWithIdentifier(kCFAllocatorDefault, kCFGregorianCalendar);
  v3 = *(a1 + 64);
  *(a1 + 64) = v2;
  v7 = v3;
  sub_100952474(&v7);
  v7 = CFTimeZoneCreateWithTimeIntervalFromGMT(kCFAllocatorSystemDefault, 0.0);
  CFCalendarSetTimeZone(*(a1 + 64), v7);
  if (!*(a1 + 64))
  {
    v4 = *(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *v6 = 0;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Could not create gregorian calendar", v6, 2u);
    }
  }

  return sub_1006680EC(&v7);
}

void sub_10161A840(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1006680EC(va);
  _Unwind_Resume(a1);
}

void *sub_10161A854(void *a1, uint64_t a2, NSObject **a3)
{
  v6 = a1 + 1;
  ctu::OsLogContext::OsLogContext(&v11, kCtLoggingSystemName, "reg.not");
  *v6 = 0;
  v6[1] = 0;
  v7 = *a3;
  a1[3] = *a3;
  if (v7)
  {
    dispatch_retain(v7);
  }

  a1[4] = 0;
  ctu::OsLogLogger::OsLogLogger(v12, &v11);
  ctu::OsLogLogger::OsLogLogger((a1 + 5), v12);
  ctu::OsLogLogger::~OsLogLogger(v12);
  ctu::OsLogContext::~OsLogContext(&v11);
  *a1 = off_101F57588;
  v8 = *a2;
  a1[6] = *a2;
  v9 = *(a2 + 8);
  a1[7] = v9;
  if (v9)
  {
    atomic_fetch_add_explicit((v9 + 8), 1uLL, memory_order_relaxed);
    v8 = a1[6];
  }

  a1[8] = 0;
  Registry::getNotificationSenderFactory(&v11, v8);
  (*(*v11.var0 + 48))(v11.var0);
  if (v11.var1.fRef)
  {
    sub_100004A34(v11.var1.fRef);
  }

  return a1;
}

void sub_10161A994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11)
  {
    sub_100004A34(a11);
  }

  sub_100952474(v13);
  v15 = v11[7];
  if (v15)
  {
    sub_100004A34(v15);
  }

  ctu::OsLogLogger::~OsLogLogger((v11 + 5));
  sub_1000C0544(v12);
  RegistrationNotificationInterface::~RegistrationNotificationInterface(v11);
  _Unwind_Resume(a1);
}

void sub_10161AA10(uint64_t a1)
{
  *a1 = off_101F57588;
  v2 = *(a1 + 80);
  if (v2)
  {
    sub_100004A34(v2);
  }

  sub_100952474((a1 + 64));
  v3 = *(a1 + 56);
  if (v3)
  {
    sub_100004A34(v3);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 40));
  sub_1000C0544((a1 + 8));

  RegistrationNotificationInterface::~RegistrationNotificationInterface(a1);
}

void sub_10161AA94(uint64_t a1)
{
  sub_10161AA10(a1);

  operator delete();
}

void sub_10161AACC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    if (*(a3 + 23) < 0)
    {
      sub_100005F2C(__p, *a3, *(a3 + 8));
    }

    else
    {
      *__p = *a3;
      v8 = *(a3 + 16);
    }

    v9 = 0;
    operator new();
  }

  v4 = *(a1 + 72);
  if (*(a3 + 23) < 0)
  {
    sub_100005F2C(v5, *a3, *(a3 + 8));
  }

  else
  {
    *v5 = *a3;
    v6 = *(a3 + 16);
  }

  (*(*v4 + 16))(v4, a2, v5);
  if (SHIBYTE(v6) < 0)
  {
    operator delete(v5[0]);
  }
}

void sub_10161AC48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, int a8, __int16 a9, char a10, char a11, ...)
{
  va_start(va, a11);
  sub_10161C5BC(va);
  if (a11 < 0)
  {
    operator delete(a6);
  }

  _Unwind_Resume(a1);
}

void sub_10161AC94(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = *(a3 + 24);
  if (v4)
  {
    if (v4 == a3)
    {
      v7 = v6;
      (*(*v4 + 24))(v4, v6);
    }

    else
    {
      v7 = (*(*v4 + 16))(v4);
    }
  }

  else
  {
    v7 = 0;
  }

  v5 = *(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_10161AE8C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_10161AEA8(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_10161AF98(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_10161B0A8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (a2 == 1)
  {
    v6 = *a3;
    v7 = *(a3 + 2);
    v9[0] = off_101F57838;
    v9[1] = v6;
    v10 = v7;
    v11 = v9;
    sub_10161B1A8(a1, 9u, v9);
    sub_10161C5BC(v9);
  }

  return (*(**(a1 + 72) + 32))(*(a1 + 72), a2, a3);
}

void sub_10161B18C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10161C5BC(va);
  _Unwind_Resume(a1);
}

void sub_10161B1A8(uint64_t a1, unsigned int a2, uint64_t a3)
{
  v6[0] = a1 + 40;
  v6[1] = a2;
  v3 = *(a1 + 56);
  v6[2] = *(a1 + 48);
  v7 = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v8 = 0;
  v4 = *(a3 + 24);
  if (!v4)
  {
    sub_100022DB4();
  }

  (*(*v4 + 48))(v4, v6);
  sub_10119E504(v6, v5);
  sub_1000296E0(&v8);
  if (v7)
  {
    sub_100004A34(v7);
  }
}

void sub_10161B24C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10161C15C(va);
  _Unwind_Resume(a1);
}

uint64_t sub_10161B260(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    v4 = off_101F578B8;
    v5 = a3;
    v6 = &v4;
    sub_10161AC94(a1, 81, &v4);
  }

  return (*(**(a1 + 72) + 104))(*(a1 + 72), a2, a3);
}

void sub_10161B33C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10161C5BC(va);
  _Unwind_Resume(a1);
}

void sub_10161B358(uint64_t a1)
{
  v1[0] = off_101F57938;
  v1[3] = v1;
  sub_10161AC94(a1, 34, v1);
}

void sub_10161B3E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10161C5BC(va);
  _Unwind_Resume(a1);
}

void sub_10161B3F4(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  if (a2 == 1)
  {
    v8 = xpc_array_create(0, 0);
    if (v8 || (v8 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v8) == &_xpc_type_array)
      {
        xpc_retain(v8);
        v9 = v8;
      }

      else
      {
        v9 = xpc_null_create();
      }
    }

    else
    {
      v9 = xpc_null_create();
      v8 = 0;
    }

    v27 = a3;
    xpc_release(v8);
    v11 = *a4;
    v10 = a4[1];
    v28 = v9;
    if (v11 == v10)
    {
LABEL_57:
      if (v9)
      {
        xpc_retain(v9);
        v25 = v9;
      }

      else
      {
        v25 = xpc_null_create();
      }

      v45 = v25;
      v46 = 0;
      v43 = off_101F579B8;
      v44 = v27;
      xpc_null_create();
      v46 = &v43;
      sub_10161AC94(a1, 42, &v43);
    }

    while (1)
    {
      v12 = *(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        NetworkListOperator::getCompositeName(v41, v11);
        if (v42 >= 0)
        {
          v13 = v41;
        }

        else
        {
          v13 = v41[0];
        }

        NetworkListOperator::getRAT(v11);
        v14 = asString();
        NetworkListOperator::getKey(__p, v11);
        if (v40 >= 0)
        {
          v15 = __p;
        }

        else
        {
          v15 = __p[0];
        }

        *buf = 136315650;
        *&buf[4] = v13;
        *&buf[12] = 2080;
        *&buf[14] = v14;
        *&buf[22] = 2080;
        v48 = v15;
        _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Adding operator %s (%s) with code %s", buf, 0x20u);
        if (SHIBYTE(v40) < 0)
        {
          operator delete(__p[0]);
        }

        v9 = v28;
        if (SHIBYTE(v42) < 0)
        {
          operator delete(v41[0]);
        }
      }

      value = 0;
      v16 = xpc_dictionary_create(0, 0, 0);
      v17 = v16;
      if (v16)
      {
        value = v16;
      }

      else
      {
        v17 = xpc_null_create();
        value = v17;
        if (!v17)
        {
          v18 = xpc_null_create();
          v17 = 0;
          goto LABEL_27;
        }
      }

      if (xpc_get_type(v17) != &_xpc_type_dictionary)
      {
        v18 = xpc_null_create();
LABEL_27:
        value = v18;
        goto LABEL_28;
      }

      xpc_retain(v17);
LABEL_28:
      xpc_release(v17);
      NetworkListOperator::getLocalizedCompositeName();
      if (v42 >= 0)
      {
        v19 = v41;
      }

      else
      {
        v19 = v41[0];
      }

      v36 = xpc_string_create(v19);
      if (!v36)
      {
        v36 = xpc_null_create();
      }

      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      *__p = *buf;
      v40 = *&buf[16];
      v20 = *buf;
      if ((buf[23] & 0x80u) == 0)
      {
        v20 = __p;
      }

      p_value = &value;
      v35 = v20;
      sub_10000F688(&p_value, &v36, &object);
      xpc_release(object);
      object = 0;
      if (SHIBYTE(v40) < 0)
      {
        operator delete(__p[0]);
      }

      xpc_release(v36);
      v36 = 0;
      if (SHIBYTE(v42) < 0)
      {
        operator delete(v41[0]);
      }

      NetworkListOperator::getKey(v41, v11);
      if (v42 >= 0)
      {
        v21 = v41;
      }

      else
      {
        v21 = v41[0];
      }

      v32 = xpc_string_create(v21);
      if (!v32)
      {
        v32 = xpc_null_create();
      }

      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      *__p = *buf;
      v40 = *&buf[16];
      v22 = *buf;
      if ((buf[23] & 0x80u) == 0)
      {
        v22 = __p;
      }

      p_value = &value;
      v35 = v22;
      sub_10000F688(&p_value, &v32, &v33);
      xpc_release(v33);
      v33 = 0;
      if (SHIBYTE(v40) < 0)
      {
        operator delete(__p[0]);
      }

      xpc_release(v32);
      v32 = 0;
      if (SHIBYTE(v42) < 0)
      {
        operator delete(v41[0]);
      }

      RAT = NetworkListOperator::getRAT(v11);
      v30 = xpc_int64_create(RAT);
      if (!v30)
      {
        v30 = xpc_null_create();
      }

      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      *v41 = *buf;
      v42 = *&buf[16];
      v24 = *buf;
      if ((buf[23] & 0x80u) == 0)
      {
        v24 = v41;
      }

      __p[0] = &value;
      __p[1] = v24;
      sub_10000F688(__p, &v30, &v31);
      xpc_release(v31);
      v31 = 0;
      if (SHIBYTE(v42) < 0)
      {
        operator delete(v41[0]);
      }

      xpc_release(v30);
      v30 = 0;
      xpc_array_append_value(v9, value);
      xpc_release(value);
      v11 = (v11 + 136);
      if (v11 == v10)
      {
        goto LABEL_57;
      }
    }
  }

  v26 = *(a1 + 72);
  memset(v29, 0, sizeof(v29));
  sub_100F4B410(v29, *a4, a4[1], 0xF0F0F0F0F0F0F0F1 * ((a4[1] - *a4) >> 3));
  (*(*v26 + 96))(v26, a1 + 48, a2, v29, a3 != 0);
  *buf = v29;
  sub_100F4B580(buf);
}

void sub_10161B98C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20, uint64_t a21, xpc_object_t a22, uint64_t a23, uint64_t a24, uint64_t a25, xpc_object_t a26, uint64_t a27, xpc_object_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, void *__p, uint64_t a34, int a35, __int16 a36, char a37, char a38)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

void sub_10161BB10(uint64_t a1)
{
  v1[0] = off_101F57A38;
  v1[3] = v1;
  sub_10161AC94(a1, 43, v1);
}

void sub_10161BB98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10161C5BC(va);
  _Unwind_Resume(a1);
}

void sub_10161BBAC(uint64_t a1, char a2)
{
  v2 = off_101F57AB8;
  v3 = a2;
  v4 = &v2;
  sub_10161AC94(a1, 93, &v2);
}

void sub_10161BC38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10161C5BC(va);
  _Unwind_Resume(a1);
}

void sub_10161BD10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10161C5BC(va);
  _Unwind_Resume(a1);
}

void sub_10161BD24(uint64_t a1, uint64_t a2, char a3)
{
  v3[0] = off_101F57BB8;
  v3[1] = a2;
  v4 = a3;
  v5 = 0;
  v6 = 0;
  v7 = v3;
  sub_10161AC94(a1, 40, v3);
}

void sub_10161BDB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10161C5BC(va);
  _Unwind_Resume(a1);
}

uint64_t sub_10161BDCC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = a3;
  if ((a3 & 0x1000000000000) != 0)
  {
    LODWORD(v4) = 4;
  }

  return (*(**(a1 + 72) + 24))(*(a1 + 72), a2, &v4);
}

uint64_t sub_10161BE24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    v4 = off_101F57C38;
    v5 = a3;
    v6 = &v4;
    sub_10161AC94(a1, 41, &v4);
  }

  return (*(**(a1 + 72) + 40))(*(a1 + 72), a2, a3);
}

void sub_10161BF00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10161C5BC(va);
  _Unwind_Resume(a1);
}

void sub_10161BFF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_10161C5BC(va);
  _Unwind_Resume(a1);
}

void sub_10161C004(uint64_t a1, unsigned int a2, int a3)
{
  v3 = &_mh_execute_header;
  v4[0] = off_101F57D38;
  v4[1] = a1;
  if (!a3)
  {
    v3 = 0;
  }

  v5 = v3 | a2;
  v6 = v4;
  *(&v5 + 5) = 0;
  HIBYTE(v5) = 0;
  sub_10161AC94(a1, 14, v4);
}

void sub_10161C0A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10161C5BC(va);
  _Unwind_Resume(a1);
}

uint64_t sub_10161C0BC(uint64_t a1, char a2)
{
  v3 = off_101F57DB8;
  v4 = a2;
  v5 = &v3;
  sub_10161B1A8(a1, 0xFu, &v3);
  return sub_10161C5BC(&v3);
}

void sub_10161C148(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10161C5BC(va);
  _Unwind_Resume(a1);
}

uint64_t sub_10161C15C(uint64_t a1)
{
  sub_1000296E0((a1 + 32));
  v2 = *(a1 + 24);
  if (v2)
  {
    sub_100004A34(v2);
  }

  return a1;
}

void sub_10161C260(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, sub_10161C334);
  __cxa_rethrow();
}

void sub_10161C2A0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10161C2F4(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10161C334(uint64_t result)
{
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t sub_10161C360(uint64_t a1)
{
  *a1 = off_101F57728;
  if (*(a1 + 31) < 0)
  {
    operator delete(*(a1 + 8));
  }

  return a1;
}

void sub_10161C3B0(uint64_t a1)
{
  *a1 = off_101F57728;
  if (*(a1 + 31) < 0)
  {
    operator delete(*(a1 + 8));
  }

  operator delete();
}

char *sub_10161C4B4(char *result, void *a2)
{
  *a2 = off_101F57728;
  v2 = a2 + 1;
  if (result[31] < 0)
  {
    return sub_100005F2C(v2, *(result + 1), *(result + 2));
  }

  v3 = *(result + 8);
  v2[2] = *(result + 3);
  *v2 = v3;
  return result;
}

void sub_10161C4FC(uint64_t a1)
{
  if (*(a1 + 31) < 0)
  {
    operator delete(*(a1 + 8));
  }
}

void sub_10161C510(void **__p)
{
  if (*(__p + 31) < 0)
  {
    operator delete(__p[1]);
  }

  operator delete(__p);
}

uint64_t sub_10161C570(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10161C5BC(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void sub_10161C63C(unsigned int **a1)
{
  v14 = a1;
  v1 = *(*a1 + 1);
  v2 = **a1;
  ServiceMap = Registry::getServiceMap(*(v1 + 48));
  v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    v6 = (v5 & 0x7FFFFFFFFFFFFFFFLL);
    v7 = 5381;
    do
    {
      v5 = v7;
      v8 = *v6++;
      v7 = (33 * v7) ^ v8;
    }

    while (v8);
  }

  std::mutex::lock(ServiceMap);
  v17[0] = v5;
  v9 = sub_100009510(&v4[1].__m_.__sig, v17);
  if (v9)
  {
    v11 = v9[3];
    v10 = v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v10);
      v12 = 0;
      if (!v11)
      {
LABEL_13:
        if ((v12 & 1) == 0)
        {
          sub_100004A34(v10);
        }

        operator delete();
      }

LABEL_10:
      v15 = 0;
      v13 = *(v1 + 24);
      if (v13)
      {
        dispatch_retain(*(v1 + 24));
      }

      object = v13;
      v17[0] = off_101F577B8;
      v17[1] = v1;
      v17[2] = v2;
      v17[3] = v17;
      sub_100E47D30();
    }
  }

  else
  {
    v11 = 0;
  }

  std::mutex::unlock(v4);
  v10 = 0;
  v12 = 1;
  if (!v11)
  {
    goto LABEL_13;
  }

  goto LABEL_10;
}

void sub_10161C85C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t *a10, dispatch_object_t object, uint64_t *a12)
{
  sub_100E47E78(&a12, 0);
  sub_100E47E78(&a10, 0);
  if ((v13 & 1) == 0)
  {
    sub_100004A34(v12);
  }

  operator delete();
}

__n128 sub_10161C954(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F577B8;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10161C984(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 8);
  v4 = *a2;
  v5 = v2;
  return sub_10161B0A8(*(a1 + 8), *(a1 + 16), &v4);
}

uint64_t sub_10161C9C4(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F57818))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10161CA10(uint64_t **a1)
{
  v1 = a1;
  sub_10161B0A8(**a1, *(*a1 + 2), (*a1 + 12));
  operator delete();
}

uint64_t sub_10161CB10(uint64_t result, uint64_t a2)
{
  *a2 = off_101F57838;
  v2 = *(result + 8);
  *(a2 + 16) = *(result + 16);
  *(a2 + 8) = v2;
  return result;
}

const void **sub_10161CB48(int *a1, uint64_t a2)
{
  sub_10119E42C(a2, kCTIndicatorsRawSignalStrength, 0);
  sub_10119E42C(a2, kCTIndicatorsSignalStrength, 100);
  sub_10119E42C(a2, kCTIndicatorsGradedSignalStrength, a1[2]);
  sub_10119E42C(a2, kCTIndicatorsSignalStrengthDisplayValue, a1[3]);
  v4 = kCTIndicatorsSignalStrengthMaxDisplayValue;
  v5 = a1[4];

  return sub_10119E42C(a2, v4, v5);
}

uint64_t sub_10161CBF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10161CCB0(uint64_t result, uint64_t a2)
{
  *a2 = off_101F578B8;
  *(a2 + 8) = *(result + 8);
  return result;
}

void sub_10161CCE0(uint64_t a1, NSObject ***a2)
{
  if (*(a1 + 8))
  {
    v2 = &kCFBooleanTrue;
  }

  else
  {
    v2 = &kCFBooleanFalse;
  }

  sub_10119DFC0(a2, kCTRegistrationNetworkSelectionMenu, *v2);
}

uint64_t sub_10161CD18(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10161CDF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10161CE3C(uint64_t a1)
{
  *a1 = off_101F579B8;
  xpc_release(*(a1 + 16));
  *(a1 + 16) = 0;
  return a1;
}

void sub_10161CE8C(uint64_t a1)
{
  *a1 = off_101F579B8;
  xpc_release(*(a1 + 16));
  *(a1 + 16) = 0;

  operator delete();
}

xpc_object_t sub_10161CF80(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F579B8;
  *(a2 + 8) = *(a1 + 8);
  v2 = *(a1 + 16);
  *(a2 + 16) = v2;
  if (v2)
  {
    return xpc_retain(v2);
  }

  result = xpc_null_create();
  *(a2 + 16) = result;
  return result;
}

void sub_10161CFEC(void *a1)
{
  sub_10161D198(a1 + 8);

  operator delete(a1);
}

const void **sub_10161D028(uint64_t a1, NSObject ***a2)
{
  v4 = &kCFBooleanTrue;
  if (*(a1 + 8) == 1)
  {
    v4 = &kCFBooleanFalse;
  }

  sub_10119DFC0(a2, kCTRegistrationNetworkListComplete, *v4);
  v11 = 0;
  sub_10119DF48(a2, &v11);
  v10 = 0;
  v5 = *(a1 + 16);
  object = v5;
  if (v5)
  {
    xpc_retain(v5);
  }

  else
  {
    object = xpc_null_create();
  }

  xpc::bridge(&v9, &object, v6);
  sub_10006DD00(&v10, &v9);
  sub_10000A1EC(&v9);
  xpc_release(object);
  CFDictionarySetValue(v11, kCTRegistrationNetworkList, v10);
  sub_100010250(&v10);
  return sub_1000296E0(&v11);
}

void sub_10161D104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, char a10, int a11, const void *a12, const void *a13)
{
  sub_100010250(&a12);
  sub_1000296E0(&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_10161D14C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10161D254(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10161D314(uint64_t result, uint64_t a2)
{
  *a2 = off_101F57AB8;
  *(a2 + 8) = *(result + 8);
  return result;
}

void sub_10161D344(uint64_t a1, NSObject ***a2)
{
  if (*(a1 + 8))
  {
    v2 = &kCFBooleanTrue;
  }

  else
  {
    v2 = &kCFBooleanFalse;
  }

  sub_10119DFC0(a2, kCTEmergencyCallBackMode, *v2);
}

uint64_t sub_10161D37C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10161D44C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F57B38;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  *(a2 + 25) = 0;
  *(a2 + 28) = 0;
  return result;
}

void sub_10161D48C(uint64_t a1, NSObject ***a2)
{
  v3 = *(a1 + 8);
  sub_10161D618(a2, *(a1 + 16), *(a1 + 21), *(a1 + 20), *(a1 + 24));
  v4 = *(a1 + 16);
  ServiceMap = Registry::getServiceMap(*(v3 + 48));
  v6 = ServiceMap;
  v7 = "N3awd7metrics14MetricCountersE";
  if (("N3awd7metrics14MetricCountersE" & 0x8000000000000000) != 0)
  {
    v8 = ("N3awd7metrics14MetricCountersE" & 0x7FFFFFFFFFFFFFFFLL);
    v9 = 5381;
    do
    {
      v7 = v9;
      v10 = *v8++;
      v9 = (33 * v9) ^ v10;
    }

    while (v10);
  }

  std::mutex::lock(ServiceMap);
  v16 = v7;
  v11 = sub_100009510(&v6[1].__m_.__sig, &v16);
  if (!v11)
  {
    v13 = 0;
LABEL_9:
    std::mutex::unlock(v6);
    v12 = 0;
    v14 = 1;
    if (!v13)
    {
      goto LABEL_11;
    }

    goto LABEL_10;
  }

  v13 = v11[3];
  v12 = v11[4];
  if (!v12)
  {
    goto LABEL_9;
  }

  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_100004A34(v12);
  v14 = 0;
  if (v13)
  {
LABEL_10:
    v15 = sub_100AFFDB8(v13);
    sub_100B00C74(v15, (v4 - 7) < 0xFFFFFFFD);
  }

LABEL_11:
  if ((v14 & 1) == 0)
  {
    sub_100004A34(v12);
  }
}

void sub_10161D5B0(_Unwind_Exception *exception_object)
{
  v3 = v1;
  if ((v3 & 1) == 0)
  {
    sub_100004A34(v2);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10161D5CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10161D618(NSObject ***a1, int a2, int a3, int a4, int a5)
{
  v9 = kCTRegistrationStatus;
  v10 = sub_10002BE80(a2);
  sub_10119DFC0(a1, v9, v10);
  if (a4)
  {
    v11 = kCFBooleanTrue;
  }

  else
  {
    v11 = kCFBooleanFalse;
  }

  sub_10119DFC0(a1, kCTRegistrationInHomeCountry, v11);
  if (a3)
  {
    v12 = kCFBooleanTrue;
  }

  else
  {
    v12 = kCFBooleanFalse;
  }

  sub_10119DFC0(a1, kCTRegistrationChangedDueToSimRemoval, v12);
  v13 = kCTCampOnly;
  if (a5 == 6)
  {
    v14 = kCFBooleanTrue;
  }

  else
  {
    v14 = kCFBooleanFalse;
  }

  sub_10119DFC0(a1, v13, v14);
}

uint64_t sub_10161D770(uint64_t result, uint64_t a2)
{
  *a2 = off_101F57BB8;
  v2 = *(result + 8);
  *(a2 + 16) = *(result + 16);
  *(a2 + 8) = v2;
  *(a2 + 17) = 0;
  *(a2 + 19) = 0;
  return result;
}

void sub_10161D7B0(uint64_t a1, NSObject ***a2)
{
  sub_10161D618(a2, *(a1 + 8), *(a1 + 13), *(a1 + 12), *(a1 + 16));
  if (*(a1 + 14))
  {
    v4 = 4;
  }

  else
  {
    v4 = *(a1 + 8);
  }

  v5 = kCTRegistrationDisplayStatus;
  v6 = sub_10002BE80(v4);
  sub_10119DFC0(a2, v5, v6);
  v7 = kCTRegistrationIsForcedRegisteredHome;
  if (*(a1 + 14))
  {
    v8 = &kCFBooleanTrue;
  }

  else
  {
    v8 = &kCFBooleanFalse;
  }

  v9 = *v8;

  sub_10119DFC0(a2, v7, v9);
}

uint64_t sub_10161D868(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10161D928(uint64_t result, uint64_t a2)
{
  *a2 = off_101F57C38;
  *(a2 + 8) = *(result + 8);
  return result;
}

uint64_t sub_10161D974(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10161DA4C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F57CB8;
  result = *(a1 + 8);
  v3 = *(a1 + 24);
  v4 = *(a1 + 40);
  *(a2 + 56) = *(a1 + 56);
  *(a2 + 40) = v4;
  *(a2 + 24) = v3;
  *(a2 + 8) = result;
  return result;
}

void sub_10161DA94(uint64_t a1, NSObject ***a2)
{
  v3 = *(a1 + 8);
  v4 = *(v3 + 64);
  if (v4)
  {
    v6 = *(a1 + 24);
    at = 0.0;
    if (CFCalendarComposeAbsoluteTime(v4, &at, "yMdHms", *(a1 + 36), *(a1 + 32), *(a1 + 28), *(a1 + 16), *(a1 + 20), *&v6))
    {
      v13 = 0;
      valuePtr[0] = *&at;
      v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, valuePtr);
      if (v7)
      {
        v13 = v7;
        valuePtr[0] = 0;
        sub_100029A48(valuePtr);
        v8 = v13;
      }

      else
      {
        v8 = 0;
      }

      v11 = v8;
      v13 = 0;
      sub_100029A48(&v13);
      valuePtr[0] = v8;
      if (v8)
      {
        CFRetain(v8);
      }

      sub_10119E10C(a2, kCTIndicatorsTimeUpdateAbsoluteTime, valuePtr);
      sub_10000A1EC(valuePtr);
      sub_10119E42C(a2, kCTIndicatorsTimeUpdateTimeZoneOffset, *(a1 + 40));
      sub_10161C0BC(v3, *(a1 + 64) != 0);
      sub_100029A48(&v11);
    }

    else
    {
      v10 = *(v3 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(valuePtr[0]) = 0;
        _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Could not compose absolute gregorian time", valuePtr, 2u);
      }
    }
  }

  else
  {
    v9 = *(v3 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(valuePtr[0]) = 0;
      _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid CFCalendar", valuePtr, 2u);
    }
  }
}

void sub_10161DC50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_10000A1EC((v8 - 48));
  sub_100029A48(va);
  _Unwind_Resume(a1);
}

uint64_t sub_10161DC80(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10161DD48(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F57D38;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  *(a2 + 23) = 0;
  *(a2 + 21) = 0;
  return result;
}

uint64_t sub_10161DD80(uint64_t a1, uint64_t a2)
{
  v3 = *(a1 + 8);
  sub_10119E42C(a2, kCTIndicatorsTimeUpdateTimeZoneOffset, *(a1 + 16));
  v4 = *(a1 + 20);

  return sub_10161C0BC(v3, v4);
}

uint64_t sub_10161DDD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10161DE98(uint64_t result, uint64_t a2)
{
  *a2 = off_101F57DB8;
  *(a2 + 8) = *(result + 8);
  return result;
}

void sub_10161DEC8(uint64_t a1, NSObject ***a2)
{
  if (*(a1 + 8))
  {
    v2 = &kCFBooleanTrue;
  }

  else
  {
    v2 = &kCFBooleanFalse;
  }

  sub_10119DFC0(a2, kCTIndicatorsDstUpdateDstIsInEffect, *v2);
}

uint64_t sub_10161DF00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_10161DF4C(uint64_t *a1)
{
  v1 = *a1;
  v3 = a1;
  v4 = v1;
  sub_10161B1A8(*v1, *(v1 + 8), v1 + 16);
  sub_10161DFB4(&v4);
  return sub_1000049E0(&v3);
}

void sub_10161DF98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10161DFB4(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10161DFB4(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_10161C5BC(v1 + 16);
    operator delete();
  }

  return result;
}

void sub_10161E004(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2)
  {
    dispatch_retain(*a2);
  }

  sub_101132998();
}

void sub_10161E074(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_release(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_10161E08C(uint64_t a1, void *a2)
{
  *a2 = 0;
  v2 = *(a1 + 16);
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  sub_1012FB62C();
}

void sub_10161E114(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    sub_100004A34(v2);
  }

  if (v1)
  {
    dispatch_release(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_10161E138(SubscriberFactoryInterface *this)
{
  *this = off_101F57E38;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  SubscriberFactoryInterface::~SubscriberFactoryInterface(this);
}

void sub_10161E194(SubscriberFactoryInterface *this)
{
  *this = off_101F57E38;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  SubscriberFactoryInterface::~SubscriberFactoryInterface(this);

  operator delete();
}

const char *sub_10161E204(int a1)
{
  if (a1 > 112)
  {
    if (a1 > 211)
    {
      if (a1 <= 302)
      {
        switch(a1)
        {
          case 212:
            return "kAWDInstrumentEVDOEnd";
          case 221:
            return "kAWDInstrument1xEVDOTxPower";
          case 302:
            return "kAWDInstrumentLTERRCMessageMsgType";
        }
      }

      else if (a1 > 305)
      {
        if (a1 == 306)
        {
          return "kAWDInstrumentLTETxPower";
        }

        if (a1 == 307)
        {
          return "kAWDInstrumentLTEFallback";
        }
      }

      else
      {
        if (a1 == 303)
        {
          return "kAWDInstrumentLTERRCMessageDir";
        }

        if (a1 == 305)
        {
          return "kAWDInstrumentLTERRCState";
        }
      }

      return "Unknown Instrument ID?";
    }

    if (a1 > 115)
    {
      if (a1 > 201)
      {
        if (a1 == 202)
        {
          return "kAWDInstrument1xEVDOPSCallEnd";
        }

        if (a1 == 211)
        {
          return "kAWDInstrumentEVDOStart";
        }
      }

      else
      {
        if (a1 == 116)
        {
          return "kAWDInstrumentWDCMABearerRateRbCount";
        }

        if (a1 == 201)
        {
          return "kAWDInstrument1xEVDOPSCallStart";
        }
      }

      return "Unknown Instrument ID?";
    }

    if (a1 == 113)
    {
      return "kAWDInstrumentWDCMABearerRateRbId";
    }

    else if (a1 == 114)
    {
      return "kAWDInstrumentWDCMABearerRateDLRate";
    }

    else
    {
      return "kAWDInstrumentWDCMABearerRateULRate";
    }
  }

  else
  {
    if (a1 <= 100)
    {
      if (a1 <= 2)
      {
        switch(a1)
        {
          case 0:
            return "kAWDInstrumentUnknown";
          case 1:
            return "kAWDInstrumentNetworkCondition";
          case 2:
            return "kAWDInstrumentIpThroughPutUp";
        }
      }

      else
      {
        if (a1 <= 4)
        {
          if (a1 == 3)
          {
            return "kAWDInstrumentIpThroughPutDown";
          }

          else
          {
            return "kAWDInstrumentsCellularServiceStatus";
          }
        }

        if (a1 == 5)
        {
          return "kAWDInstrumentIpv6ThroughPutUp";
        }

        if (a1 == 6)
        {
          return "kAWDInstrumentIpv6ThroughPutDown";
        }
      }

      return "Unknown Instrument ID?";
    }

    if (a1 <= 108)
    {
      switch(a1)
      {
        case 'e':
          return "kAWDInstrumentWCDMARRCMessage";
        case 'i':
          return "kAWDInstrumentWCDMACellState";
        case 'j':
          return "kAWDInstrumentWCDMATxPower";
      }

      return "Unknown Instrument ID?";
    }

    if (a1 > 110)
    {
      if (a1 == 111)
      {
        return "kAWDInstrumentsMultiRabPSData";
      }

      else
      {
        return "kAWDInstrumentWDCMABearerRateRabId";
      }
    }

    else if (a1 == 109)
    {
      return "kAWDInstrumentsMultiRabCSVoice";
    }

    else
    {
      return "kAWDInstrumentsMultiRabCSData";
    }
  }
}

void AWDModel::create(capabilities::abs *a1@<X0>, void *a2@<X8>)
{
  v3 = capabilities::abs::supportsWirelessTelemetryUsingMultiClientModel(a1);
  if (v3)
  {
    sub_100020B54();
    v4 = qword_101FCAEB8;
    if (os_log_type_enabled(qword_101FCAEB8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      v5 = "#I AWDModel disabled; multiclient model will be used instead";
LABEL_8:
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, &__p, 2u);
    }
  }

  else
  {
    if (capabilities::ct::getAWDBasebandComponent(v3))
    {
      *a2 = 0;
      a2[1] = 0;
      operator new();
    }

    sub_100020B54();
    v4 = qword_101FCAEB8;
    if (os_log_type_enabled(qword_101FCAEB8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      v5 = "#I AWDModel disabled; no valid AWD baseband component";
      goto LABEL_8;
    }
  }

  *a2 = 0;
  a2[1] = 0;
}

void sub_10161E878(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, sub_101620940);
  __cxa_rethrow();
}

void sub_10161E8A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11, uint64_t a12, dispatch_object_t a13, dispatch_object_t a14, dispatch_object_t a15, dispatch_object_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  __cxa_end_catch();
  if (v23)
  {
    dispatch_release(v23);
    if (!v22)
    {
      goto LABEL_3;
    }
  }

  else if (!v22)
  {
    goto LABEL_3;
  }

  dispatch_release(v22);
LABEL_3:
  _Unwind_Resume(a1);
}

wis::WISServerConnection **sub_10161EA3C(wis::WISServerConnection **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    wis::WISServerConnection::~WISServerConnection(v2);
    operator delete();
  }

  return a1;
}

void AWDModel::bootstrap(AWDModel *this, group_session a2)
{
  v4 = *(this + 4);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Bootstrap AWDModel", &buf, 2u);
  }

  if (*(this + 24))
  {
    v5 = *(this + 28);
    v6 = *a2.var0.fObj;
    group = v6;
    if (v6)
    {
      dispatch_retain(v6);
      dispatch_group_enter(group);
    }

    (**v5)(v5, &group);
    if (group)
    {
      dispatch_group_leave(group);
      if (group)
      {
        dispatch_release(group);
      }
    }

    v7 = *(this + 1);
    if (!v7 || (v8 = *this, (v9 = std::__shared_weak_count::lock(v7)) == 0))
    {
      sub_100013CC4();
    }

    v10 = v9;
    p_shared_weak_owners = &v9->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_100004A34(v9);
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 1174405120;
    aBlock[2] = sub_10009D880;
    aBlock[3] = &unk_101F57E70;
    aBlock[4] = this;
    aBlock[5] = v8;
    v33 = v10;
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    v34 = _Block_copy(aBlock);
    awd::AppContext::setHandler();
    if (v34)
    {
      _Block_release(v34);
    }

    v29[0] = _NSConcreteStackBlock;
    v29[1] = 1174405120;
    v29[2] = sub_10161F6A8;
    v29[3] = &unk_101F57EA0;
    v29[4] = this;
    v29[5] = v8;
    v30 = v10;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v31 = _Block_copy(v29);
    awd::AppContext::setHandler();
    if (v31)
    {
      _Block_release(v31);
    }

    v26[0] = _NSConcreteStackBlock;
    v26[1] = 1174405120;
    v26[2] = sub_1000C4820;
    v26[3] = &unk_101F57ED0;
    v26[4] = this;
    v26[5] = v8;
    v27 = v10;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v28 = _Block_copy(v26);
    awd::AppContext::setHandler();
    if (v28)
    {
      _Block_release(v28);
    }

    v23[0] = _NSConcreteStackBlock;
    v23[1] = 1174405120;
    v23[2] = sub_10005D604;
    v23[3] = &unk_101F57F00;
    v23[4] = this;
    v23[5] = v8;
    v24 = v10;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v25 = _Block_copy(v23);
    awd::AppContext::setHandler();
    if (v25)
    {
      _Block_release(v25);
    }

    v20[0] = _NSConcreteStackBlock;
    v20[1] = 1174405120;
    v20[2] = sub_10005D6AC;
    v20[3] = &unk_101F57F30;
    v20[4] = this;
    v20[5] = v8;
    v21 = v10;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v22 = _Block_copy(v20);
    awd::AppContext::setHandler();
    if (v22)
    {
      _Block_release(v22);
    }

    v17[0] = _NSConcreteStackBlock;
    v17[1] = 1174405120;
    v17[2] = sub_10005F844;
    v17[3] = &unk_101F57F60;
    v17[4] = this;
    v17[5] = v8;
    v18 = v10;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v19 = _Block_copy(v17);
    awd::AppContext::setHandler();
    if (v19)
    {
      _Block_release(v19);
    }

    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    wis::WISServerConnection::registerCallBackForTrigger();
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    wis::WISServerConnection::registerCallBackForComponentConfiguration();
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    wis::WISServerConnection::registerCallBackForPIIOrLocationChange();
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    wis::WISServerConnection::registerCallBackForClearProfiles();
    v12 = *(this + 27);
    v16 = v12;
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    awd::AwdCommandDriver::checkIn();
    if (v16)
    {
      sub_100004A34(v16);
    }

    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
    if (v18)
    {
      std::__shared_weak_count::__release_weak(v18);
    }

    if (v21)
    {
      std::__shared_weak_count::__release_weak(v21);
    }

    if (v24)
    {
      std::__shared_weak_count::__release_weak(v24);
    }

    if (v27)
    {
      std::__shared_weak_count::__release_weak(v27);
    }

    if (v30)
    {
      std::__shared_weak_count::__release_weak(v30);
    }

    if (v33)
    {
      std::__shared_weak_count::__release_weak(v33);
    }

    std::__shared_weak_count::__release_weak(v10);
  }

  v37 = 0;
  __p[0] = _NSConcreteStackBlock;
  __p[1] = 0x40000000;
  __p[2] = sub_10009C240;
  __p[3] = &unk_101F58190;
  __p[4] = this;
  __p[5] = sub_10009C268;
  __p[6] = 0;
  v37 = _Block_copy(__p);
  v13 = *(this + 1);
  if (v13)
  {
    v14 = std::__shared_weak_count::lock(v13);
    if (v14)
    {
      v15 = v14;
      sub_10070F24C(v38, &v37, *(this + 2));
      sub_10070F294(&buf, v38);
      atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_10161F3DC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10161F67C(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 48);
  *(result + 40) = *(a2 + 40);
  *(result + 48) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 16), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_10161F698(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10161F6A8(void *a1, uint64_t a2, int a3)
{
  v4 = a1[6];
  if (v4)
  {
    v6 = a1[4];
    v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      if (a3 && a1[5])
      {
        *(v6 + 129) = 0;
      }

      sub_100004A34(v7);
    }
  }
}

void sub_10161F718(void *a1)
{
  v2 = a1[6];
  if (v2)
  {
    v3 = a1[4];
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[5])
      {
        AWDModel::sendQueriableMetric(v3);
      }

      sub_100004A34(v4);
    }
  }
}

void AWDModel::sendQueriableMetric(AWDModel *this)
{
  v1 = *(this + 1);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_10161F8B4(void *a1, uint64_t a2, uint64_t a3)
{
  v4 = a1[6];
  if (v4)
  {
    v7 = a1[4];
    v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      if (a1[5])
      {
        __p[0] = 0;
        __p[1] = 0;
        v11 = 0;
        sub_1000DCF88(__p, a2, a2 + a3, a3);
        __p[1] = 0;
        v11 = 0;
        __p[0] = 0;
        v9 = *(v7 + 8);
        if (v9)
        {
          if (std::__shared_weak_count::lock(v9))
          {
            operator new();
          }
        }

        sub_100013CC4();
      }

      sub_100004A34(v8);
    }
  }
}

void AWDModel::enableMetricSubmissionInd(AWDModel *this)
{
  v1 = *(this + 1);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_10161FB28(void *a1, int a2, int a3)
{
  v4 = a1[6];
  if (v4)
  {
    v7 = a1[4];
    v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      if (a1[5])
      {
        v9 = *(v7 + 32);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 67109376;
          *&buf[4] = a3;
          v12 = 1024;
          v13 = a2;
          _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I ServerConn: received PII update: %d,%d", buf, 0xEu);
        }

        v10 = *(v7 + 8);
        if (v10)
        {
          if (std::__shared_weak_count::lock(v10))
          {
            operator new();
          }
        }

        sub_100013CC4();
      }

      sub_100004A34(v8);
    }
  }
}

void sub_10161FCC8(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_10161FCD8(void *a1)
{
  v2 = a1[6];
  if (v2)
  {
    v3 = a1[4];
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[5])
      {
        v5 = *(v3 + 8);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5))
          {
            operator new();
          }
        }

        sub_100013CC4();
      }

      sub_100004A34(v4);
    }
  }
}

void sub_10161FE18(uint64_t a1, void *a2)
{
  if (a2[2] == *(a1 + 120))
  {
    v4 = *a2;
    v2 = a2 + 1;
    v3 = v4;
    if (v4 == v2)
    {
      return;
    }

    v5 = *(a1 + 104);
    while (1)
    {
      v6 = *(v3 + 7) == *(v5 + 7) && *(v3 + 32) == *(v5 + 32);
      if (!v6)
      {
        break;
      }

      v7 = v3[1];
      v8 = v3;
      if (v7)
      {
        do
        {
          v3 = v7;
          v7 = *v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          v3 = v8[2];
          v6 = *v3 == v8;
          v8 = v3;
        }

        while (!v6);
      }

      v9 = v5[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          v10 = v5[2];
          v6 = *v10 == v5;
          v5 = v10;
        }

        while (!v6);
      }

      v5 = v10;
      if (v3 == v2)
      {
        return;
      }
    }
  }

  v11 = *(a1 + 112);
  if (v11)
  {
    v12 = a1 + 112;
    do
    {
      if (*(v11 + 28) >= 1)
      {
        v12 = v11;
      }

      v11 = *(v11 + 8 * (*(v11 + 28) < 1));
    }

    while (v11);
    if (v12 != a1 + 112 && *(v12 + 28) <= 1 && *(v12 + 32) == 1)
    {
      sub_101620550(a1, *(a1 + 128));
    }
  }
}

uint64_t AWDModel::shutdown(AWDModel *this, group_session a2)
{
  v4 = *(this + 4);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Shutdown AWDModel", buf, 2u);
  }

  v5 = *(this + 27);
  group[1] = *(this + 26);
  v11 = v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  awd::AwdCommandDriver::checkOut();
  if (v11)
  {
    sub_100004A34(v11);
  }

  v6 = *(this + 28);
  v7 = *a2.var0.fObj;
  group[0] = v7;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(v7);
  }

  (*(*v6 + 16))(v6, group);
  if (group[0])
  {
    dispatch_group_leave(group[0]);
    if (group[0])
    {
      dispatch_release(group[0]);
    }
  }

  for (i = *(this + 31); i != (this + 240); i = i[1])
  {
    sub_1001039A0(i + 2);
  }

  sub_1000FEFCC(this + 30);
  return ctu::RestModule::disconnect((this + 56));
}

void sub_10162004C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group, uint64_t a11, uint64_t a12)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }

  _Unwind_Resume(exception_object);
}

uint64_t AWDModel::start(AWDModel *this)
{
  v2 = *(this + 4);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *v4 = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Start AWDModel", v4, 2u);
  }

  return (*(**(this + 28) + 8))(*(this + 28));
}

void sub_101620110(uint64_t a1)
{
  v2 = *(a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(a1 + 200);
    *buf = 67109120;
    v12 = v3;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Sending configuration for mode %d", buf, 8u);
  }

  *(a1 + 129) = 1;
  v4 = *(a1 + 216);
  v5 = *(a1 + 224);
  v9 = *(a1 + 208);
  v10 = v4;
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v6 = *(a1 + 72);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_1016202C4;
  v7[3] = &unk_101F58050;
  v7[4] = a1;
  aBlock = _Block_copy(v7);
  (*(*v5 + 32))(v5, &v9, 1, v6, &aBlock);
  if (aBlock)
  {
    _Block_release(aBlock);
  }

  if (v10)
  {
    sub_100004A34(v10);
  }
}

void sub_101620284(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock, uint64_t a15, uint64_t a16)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

void sub_1016202C4(uint64_t a1, int a2)
{
  v3 = *(a1 + 32);
  v4 = *(v3 + 32);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      v6 = *(v3 + 200);
      v8 = 67109120;
      v9 = v6;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sending configuration for mode %d :: success", &v8, 8u);
    }

    *(v3 + 129) = 0;
  }

  else if (v5)
  {
    v7 = *(v3 + 200);
    v8 = 67109120;
    v9 = v7;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E Sending configuration for mode %d :: failed", &v8, 8u);
  }
}

void sub_1016203B8(uint64_t a1)
{
  *(a1 + 129) = 1;
  v1 = *(a1 + 216);
  v2 = *(a1 + 224);
  v4 = *(a1 + 208);
  v5 = v1;
  if (v1)
  {
    atomic_fetch_add_explicit(&v1->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  aBlock = _Block_copy(&stru_101F58090);
  (*(*v2 + 40))(v2, &v4, &aBlock);
  if (aBlock)
  {
    _Block_release(aBlock);
  }

  if (v5)
  {
    sub_100004A34(v5);
  }
}

void sub_10162045C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock, uint64_t a11, std::__shared_weak_count *a12)
{
  if (aBlock)
  {
    _Block_release(aBlock);
  }

  if (a12)
  {
    sub_100004A34(a12);
  }

  _Unwind_Resume(exception_object);
}

void sub_101620488(void *a1)
{
  v1 = a1[27];
  v2 = a1[28];
  v4 = a1[26];
  v5 = v1;
  if (v1)
  {
    atomic_fetch_add_explicit(&v1->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  aBlock = _Block_copy(&stru_101F580D0);
  (*(*v2 + 48))(v2, &v4, &aBlock);
  if (aBlock)
  {
    _Block_release(aBlock);
  }

  if (v5)
  {
    sub_100004A34(v5);
  }
}

void sub_101620524(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock, uint64_t a11, std::__shared_weak_count *a12)
{
  if (aBlock)
  {
    _Block_release(aBlock);
  }

  if (a12)
  {
    sub_100004A34(a12);
  }

  _Unwind_Resume(exception_object);
}

void sub_101620550(void *a1, uint64_t a2)
{
  v3 = a1[27];
  v4 = a1[28];
  v6 = a1[26];
  v7 = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  aBlock = _Block_copy(&stru_101F58110);
  (*(*v4 + 24))(v4, &v6, a2, &aBlock);
  if (aBlock)
  {
    _Block_release(aBlock);
  }

  if (v7)
  {
    sub_100004A34(v7);
  }
}

void sub_1016205F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock, uint64_t a11, std::__shared_weak_count *a12)
{
  if (aBlock)
  {
    _Block_release(aBlock);
  }

  if (a12)
  {
    sub_100004A34(a12);
  }

  _Unwind_Resume(exception_object);
}

void AWDModel::handleSignalBars(AWDModel *this)
{
  v1 = *(this + 1);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_10162071C(NSObject *a1, int a2, uint64_t a3, unint64_t a4)
{
  if (os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 67110146;
    v8[1] = a2;
    v9 = 2080;
    v10 = sub_10161E204(a2);
    v11 = 1024;
    v12 = a4 / 0x3E8;
    v13 = 1024;
    v14 = 1000 * (a4 % 0x3E8);
    v15 = 1024;
    v16 = qword_101FCAEB0;
    _os_log_impl(&_mh_execute_header, a1, OS_LOG_TYPE_DEFAULT, "#I Sending instrument id %d (%s), with timestamp %d.%06d, with Instrument serial number %d", v8, 0x24u);
  }

  LODWORD(qword_101FCAEB0) = qword_101FCAEB0 + 1;
  return kdebug_trace();
}

void sub_1016208AC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101620900(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101620940(uint64_t result)
{
  if (result)
  {
    v1 = result;
    sub_1000FEFCC((result + 240));
    v2 = *(v1 + 232);
    if (v2)
    {
      sub_100004A34(v2);
    }

    v3 = *(v1 + 216);
    if (v3)
    {
      sub_100004A34(v3);
    }

    sub_10161EA3C((v1 + 192));
    sub_10005F7C8((v1 + 152));
    sub_10006DCAC(v1 + 104, *(v1 + 112));
    v4 = *(v1 + 80);
    if (v4)
    {
      *(v1 + 88) = v4;
      operator delete(v4);
    }

    v5 = *(v1 + 64);
    if (v5)
    {
      sub_100004A34(v5);
    }

    v6 = *(v1 + 48);
    if (v6)
    {
      sub_100004A34(v6);
    }

    ctu::OsLogLogger::~OsLogLogger((v1 + 32));
    sub_1000C0544(v1);

    operator delete();
  }

  return result;
}

void *sub_1016209FC(void *a1)
{
  *a1 = off_101F581C0;
  v2 = a1[2];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return a1;
}

void sub_101620A48(void *a1)
{
  *a1 = off_101F581C0;
  v1 = a1[2];
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_101620B20(void *a1)
{
  *a1 = off_101F58210;
  v2 = a1[2];
  if (v2)
  {
    sub_100004A34(v2);
  }

  return a1;
}

__n128 sub_101620BE8(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F58250;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_101620C20(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v4 = v3 + 1;
  v5 = v3[1];
  v9 = *v3;
  v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *v3 = v4;
    *v4 = 0;
    v3[2] = 0;
  }

  else
  {
    v9 = &v10;
  }

  sub_10011E228(v3, a2);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  v6(v8, &v9);
  sub_10006DCAC(&v9, v10);
}

uint64_t sub_101620CD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_101620D24(uint64_t *a1)
{
  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v2 = *v1;
  sub_100015184(*v1 + 80, (v1 + 8));
  if (*(v2 + 200) != 1)
  {
    sub_101620110(v2);
  }

  sub_10140335C(&v5);
  return sub_1000049E0(&v4);
}

void sub_101620D80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10140335C(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_101620D9C(uint64_t **a1)
{
  v2 = a1;
  v1 = **a1;
  *(v1 + 88) = *(v1 + 80);
  if (*(v1 + 200) != 1)
  {
    sub_1016203B8(v1);
  }

  operator delete();
}

void sub_101620E30(uint64_t **a1)
{
  v4 = a1;
  v1 = *a1;
  v2 = **a1;
  v3 = *(v1 + 8);
  *(v2 + 128) = v3;
  sub_101620550(v2, v3);
  operator delete();
}

void sub_101620EB8(unsigned int **a1)
{
  v1 = *a1;
  v2 = *(*a1 + 2);
  v3 = *(v2 + 208);
  v6 = v2 + 216;
  v4 = *(v2 + 216);
  v5 = *(v6 + 8);
  v11 = v3;
  v12 = v4;
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v7 = *v1;
  v8 = v1[1];
  v9 = v1[2];
  aBlock = _Block_copy(&stru_101F582E0);
  (*(*v5 + 56))(v5, &v11, v7, v8, v9, &aBlock);
  if (aBlock)
  {
    _Block_release(aBlock);
  }

  if (v12)
  {
    sub_100004A34(v12);
  }

  operator delete();
}

void sub_101620FA4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock, uint64_t a11, std::__shared_weak_count *a12)
{
  if (aBlock)
  {
    _Block_release(aBlock);
  }

  if (a12)
  {
    sub_100004A34(a12);
  }

  operator delete();
}

void sub_101620FF4(void ***a1)
{
  v6 = a1;
  v1 = *a1;
  v2 = **a1;
  v3 = v2[4];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(v1 + 8);
    v5 = *(v1 + 9);
    *buf = 67109376;
    v8 = v4;
    v9 = 0;
    v10 = 4;
    v11 = v5;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Setting pii=%d and location=%d.", buf, 0xEu);
  }

  *buf = *(v1 + 4);
  awd::AppContext::setAppSettings_model();
  sub_101620488(v2);
  operator delete();
}

void sub_101621118(uint64_t **a1)
{
  v5 = a1;
  v1 = *a1;
  v2 = **a1;
  v3 = *(v2 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(v1 + 2);
    *buf = 67109120;
    LODWORD(v7) = v4;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Got Signal bars %d.", buf, 8u);
    v3 = *(v2 + 32);
  }

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 136315394;
    v7 = "kAWDInstrumentNetworkCondition";
    v8 = 1024;
    v9 = qword_101FCAEB0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Sending instrument id %s, with Instrument serial number %d", buf, 0x12u);
  }

  sub_1007A3C94();
  LODWORD(qword_101FCAEB0) = qword_101FCAEB0 + 1;
  kdebug_trace();
  operator delete();
}

void sub_1016212CC(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void *sub_101621364(void *a1, void *a2, int a3)
{
  v4 = sub_10130C5D4(a1, a2, a3, "Roaming Info 3GPP");
  *v4 = off_101F58310;
  MCC::MCC((v4 + 9));
  MNC::MNC((a1 + 13));
  a1[17] = 0;
  a1[18] = 0;
  a1[19] = 0;
  a1[20] = 0xFFFFFFFF00000000;
  return a1;
}

void sub_1016213C8(_Unwind_Exception *a1)
{
  if (*(v1 + 103) < 0)
  {
    operator delete(*(v1 + 80));
  }

  sub_10130C6E0(v1);
  _Unwind_Resume(a1);
}

void sub_1016213F4(uint64_t a1)
{
  v24[0] = 0;
  v24[1] = 0;
  v25 = 0;
  v22[0] = 0;
  v22[1] = 0;
  v23 = 0;
  memset(&__str, 0, sizeof(__str));
  v20 = 0;
  v19 = -1;
  sub_10165733C(*(a1 + 48), &v18);
  v2 = sub_100DF0D24((a1 + 8), &v18, v24);
  sub_100005978(&v18);
  if (v2 && (sub_101657528(*(a1 + 48), &v17), v3 = sub_100DF0D24((a1 + 8), &v17, v22), sub_100005978(&v17), v3) && (sub_101657714(*(a1 + 48), &v16), v4 = sub_100DF0D24((a1 + 8), &v16, &__str), sub_100005978(&v16), v4) && (sub_101657900(*(a1 + 48), &v15), v5 = sub_1016216DC((a1 + 8), &v15, &v20), sub_100005978(&v15), v5) && (sub_101657AEC(*(a1 + 48), &v14), v6 = sub_101621994((a1 + 8), &v14, &v19), sub_100005978(&v14), v6))
  {
    v7 = *(a1 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *v11 = 0;
      _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Successfully retrieved cached 3GPP operator data", v11, 2u);
    }

    MCC::MCC();
    MCC::operator=();
    if (v13 < 0)
    {
      operator delete(__p);
    }

    MNC::MNC();
    MCC::operator=();
    if (v13 < 0)
    {
      operator delete(__p);
    }

    std::string::operator=((a1 + 136), &__str);
    if (v20)
    {
      v8 = 4;
    }

    else
    {
      v8 = 5;
    }

    v9 = v19;
    *(a1 + 160) = v8;
    *(a1 + 164) = v9;
  }

  else
  {
    v10 = *(a1 + 8);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *v11 = 0;
      _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Not all fields in 3GPP operator data are present", v11, 2u);
    }
  }

  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v23) < 0)
  {
    operator delete(v22[0]);
  }

  if (SHIBYTE(v25) < 0)
  {
    operator delete(v24[0]);
  }
}

void sub_10162163C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, char a17, int a18, __int16 a19, char a20, char a21, int a22, __int16 a23, char a24, char a25, int a26, __int16 a27, char a28, char a29, int a30, __int16 a31, char a32, char a33, uint64_t a34, void *a35, uint64_t a36, int a37, __int16 a38, char a39, char a40)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  if (a40 < 0)
  {
    operator delete(a35);
  }

  if (*(v40 - 41) < 0)
  {
    operator delete(*(v40 - 64));
  }

  if (*(v40 - 17) < 0)
  {
    operator delete(*(v40 - 40));
  }

  _Unwind_Resume(exception_object);
}

BOOL sub_1016216DC(NSObject **a1, CFStringRef *a2, _BYTE *a3)
{
  v18 = 0;
  v19.__r_.__value_.__r.__words[0] = CFPreferencesCopyValue(*a2, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_10017A3BC(&v18, &v19.__r_.__value_.__l.__data_);
  v6 = v18;
  if (v18)
  {
    v19.__r_.__value_.__s.__data_[0] = 0;
    ctu::cf::assign(&v19, v18, v5);
    v7 = v19.__r_.__value_.__s.__data_[0];
    *a3 = v19.__r_.__value_.__s.__data_[0];
    v8 = *a1;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_18;
    }

    memset(&v17, 0, sizeof(v17));
    v19.__r_.__value_.__r.__words[0] = 0;
    v19.__r_.__value_.__l.__size_ = v19.__r_.__value_.__r.__words + 2;
    if (v7)
    {
      v9 = 49;
    }

    else
    {
      v9 = 48;
    }

    v19.__r_.__value_.__s.__data_[2] = v9;
    v19.__r_.__value_.__r.__words[2] = v19.__r_.__value_.__r.__words + 3;
    sub_1000D192C(&v17, &v19.__r_.__value_.__s.__data_[2], &v19.__r_.__value_.__s.__data_[3], 1uLL);
    v10 = SHIBYTE(v17.__r_.__value_.__r.__words[2]);
    v11 = v17.__r_.__value_.__r.__words[0];
    memset(&v19, 0, sizeof(v19));
    ctu::cf::assign();
    v12 = &v17;
    if (v10 < 0)
    {
      v12 = v11;
    }

    __p = v19;
    p_p = &__p;
    if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    {
      p_p = v19.__r_.__value_.__r.__words[0];
    }

    *buf = 136315394;
    v22 = v12;
    v23 = 2080;
    v24 = p_p;
    _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Retrieved value: %s for key %s", buf, 0x16u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  else
  {
    v14 = *a1;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_18;
    }

    memset(&v19, 0, sizeof(v19));
    ctu::cf::assign();
    v17 = v19;
    v15 = &v17;
    if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    {
      v15 = v19.__r_.__value_.__r.__words[0];
    }

    LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
    *(__p.__r_.__value_.__r.__words + 4) = v15;
    _os_log_impl(&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N Failed to retrieve value for key %s", &__p, 0xCu);
  }

  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v17.__r_.__value_.__l.__data_);
  }

LABEL_18:
  sub_100045C8C(&v18);
  return v6 != 0;
}

void sub_101621934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a22 < 0)
  {
    operator delete(__p);
  }

  sub_100045C8C(&a16);
  _Unwind_Resume(a1);
}

BOOL sub_101621994(NSObject **a1, CFStringRef *a2, _DWORD *a3)
{
  v20 = 0;
  *&v28 = CFPreferencesCopyValue(*a2, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_100209D88(&v20, &v28);
  v6 = v20;
  if (v20)
  {
    LODWORD(v28) = 0;
    ctu::cf::assign(&v28, v20, v5);
    v7 = v28;
    *a3 = v28;
    v8 = *a1;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      memset(&v23, 0, sizeof(v23));
      v28 = 0uLL;
      v29 = 0;
      v30 = &v28 + 2;
      v31 = &v29 + 7;
      if (v7 >= 0)
      {
        v9 = v7;
      }

      else
      {
        v9 = -v7;
      }

      LODWORD(__p[0]) = v9;
      __p[1] = &v29 + 7;
      LOBYTE(v22) = 48;
      HIDWORD(v22) = 48;
      v10 = sub_10075B978(__p);
      v11 = v10;
      if (v7 < 0)
      {
        *(v10 - 1) = 45;
        v11 = (v10 - 1);
      }

      v30 = v11;
      v31 = &v29 + 7;
      sub_1000D192C(&v23, v11, &v29 + 7, &v29 + 7 - v11);
      v12 = SHIBYTE(v23.__r_.__value_.__r.__words[2]);
      v13 = v23.__r_.__value_.__r.__words[0];
      v28 = 0uLL;
      v29 = 0;
      ctu::cf::assign();
      v14 = &v23;
      if (v12 < 0)
      {
        v14 = v13;
      }

      *__p = v28;
      v22 = v29;
      v15 = __p;
      if (v29 < 0)
      {
        v15 = __p[0];
      }

      *buf = 136315394;
      v25 = v14;
      v26 = 2080;
      v27 = v15;
      _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Retrieved value: %s for key %s", buf, 0x16u);
      if (SHIBYTE(v22) < 0)
      {
        operator delete(__p[0]);
      }

      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
      {
        v16 = v23.__r_.__value_.__r.__words[0];
LABEL_21:
        operator delete(v16);
      }
    }
  }

  else
  {
    v17 = *a1;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v28 = 0uLL;
      v29 = 0;
      ctu::cf::assign();
      *__p = v28;
      v22 = v29;
      v18 = __p;
      if (v29 < 0)
      {
        v18 = __p[0];
      }

      LODWORD(v23.__r_.__value_.__l.__data_) = 136315138;
      *(v23.__r_.__value_.__r.__words + 4) = v18;
      _os_log_impl(&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#N Failed to retrieve value for key %s", &v23, 0xCu);
      if (SHIBYTE(v22) < 0)
      {
        v16 = __p[0];
        goto LABEL_21;
      }
    }
  }

  sub_100029A48(&v20);
  return v6 != 0;
}

void sub_101621C2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(v2 - 73) < 0)
  {
    operator delete(*(v2 - 96));
  }

  sub_100029A48(va);
  _Unwind_Resume(a1);
}

void sub_101621C8C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_101621D5C(uint64_t a1)
{
  memset(&__str, 0, sizeof(__str));
  v20 = -1;
  v21 = -1;
  v19 = 0;
  v18 = -1;
  sub_101657CD8(*(a1 + 48), &v17);
  v2 = sub_100DF0D24((a1 + 8), &v17, &__str);
  sub_100005978(&v17);
  if (v2 && (sub_101657EC4(*(a1 + 48), &v16), v3 = sub_101621994((a1 + 8), &v16, &v21), sub_100005978(&v16), v3) && (sub_1016580B0(*(a1 + 48), &v15), v4 = sub_101621994((a1 + 8), &v15, &v20), sub_100005978(&v15), v4) && (sub_10165829C(*(a1 + 48), &v14), v5 = sub_1016216DC((a1 + 8), &v14, &v19), sub_100005978(&v14), v5) && (sub_101658488(*(a1 + 48), &v13), v6 = sub_101621994((a1 + 8), &v13, &v18), sub_100005978(&v13), v6))
  {
    v7 = *(a1 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *v12 = 0;
      _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Successfully retrieved cached 3GPP2 operator data", v12, 2u);
    }

    std::string::operator=((a1 + 72), &__str);
    v8 = v20;
    *(a1 + 96) = v21;
    *(a1 + 100) = v8;
    if (v19)
    {
      v9 = 4;
    }

    else
    {
      v9 = 5;
    }

    v10 = v18;
    *(a1 + 104) = v9;
    *(a1 + 108) = v10;
  }

  else
  {
    v11 = *(a1 + 8);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *v12 = 0;
      _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Not all fields in 3GPP2 operator data are present", v12, 2u);
    }
  }

  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_101621F30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100005978(va);
  if (*(v3 - 17) < 0)
  {
    operator delete(*(v3 - 40));
  }

  _Unwind_Resume(a1);
}

void sub_101621F8C(uint64_t a1, uint64_t a2)
{
  v90 = 0;
  *v88 = 0u;
  v89 = 0u;
  *v86 = 0u;
  v87 = 0u;
  v4 = *a2;
  if (*a2 <= 2)
  {
    if (v4 == -1)
    {
      goto LABEL_4;
    }

    if (v4)
    {
      if (v4 != 2)
      {
        goto LABEL_42;
      }

      if ((*(a2 + 208) & 1) == 0)
      {
        buf[0].__r_.__value_.__s.__data_[0] = 0;
        LOBYTE(v94[0]) = 0;
        goto LABEL_37;
      }

      sub_10162457C(&v98, (a2 + 120), (a2 + 152));
      sub_101624260(buf, &v98);
      LOBYTE(v94[0]) = 1;
      if (v101 < 0)
      {
        operator delete(v100);
      }

      if ((v99 & 0x80000000) == 0)
      {
        goto LABEL_37;
      }
    }

    else
    {
      if ((*(a2 + 104) & 1) == 0)
      {
        buf[0].__r_.__value_.__s.__data_[0] = 0;
        LOBYTE(v94[0]) = 0;
        goto LABEL_37;
      }

      sub_10162457C(&v98, (a2 + 24), (a2 + 56));
      sub_101624260(buf, &v98);
      LOBYTE(v94[0]) = 1;
      if (v101 < 0)
      {
        operator delete(v100);
      }

      if ((v99 & 0x80000000) == 0)
      {
        goto LABEL_37;
      }
    }

LABEL_29:
    operator delete(v98.__r_.__value_.__l.__size_);
    goto LABEL_37;
  }

  if (v4 > 0xB)
  {
    goto LABEL_42;
  }

  if (((1 << v4) & 0xC38) != 0)
  {
LABEL_4:
    sub_10130C748(a1);
    goto LABEL_199;
  }

  if (((1 << v4) & 0x180) == 0)
  {
    if (v4 != 9)
    {
      goto LABEL_42;
    }

    if ((*(a2 + 312) & 1) == 0)
    {
      buf[0].__r_.__value_.__s.__data_[0] = 0;
      LOBYTE(v94[0]) = 0;
      goto LABEL_37;
    }

    sub_10162457C(&v98, (a2 + 224), (a2 + 256));
    sub_101624260(buf, &v98);
    LOBYTE(v94[0]) = 1;
    if (v101 < 0)
    {
      operator delete(v100);
    }

    if ((v99 & 0x80000000) == 0)
    {
      goto LABEL_37;
    }

    goto LABEL_29;
  }

  if (*(a2 + 448))
  {
    sub_10162457C(&v98, (a2 + 328), (a2 + 360));
    sub_101624260(buf, &v98);
    LOBYTE(v94[0]) = 1;
    if (v101 < 0)
    {
      operator delete(v100);
    }

    if ((v99 & 0x80000000) == 0)
    {
      goto LABEL_37;
    }

    goto LABEL_29;
  }

  buf[0].__r_.__value_.__s.__data_[0] = 0;
  LOBYTE(v94[0]) = 0;
LABEL_37:
  sub_1016241B8(v86, buf);
  if (LOBYTE(v94[0]) == 1)
  {
    if (SHIBYTE(v93[1]) < 0)
    {
      operator delete(buf[1].__r_.__value_.__r.__words[2]);
    }

    if (buf[1].__r_.__value_.__s.__data_[7] < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__size_);
    }
  }

LABEL_42:
  if (v90)
  {
    v5 = MCC::operator!=();
    if (v5)
    {
      v6 = *(a1 + 8);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        IntValue = MCC::getIntValue((a1 + 72));
        v8 = MCC::getIntValue(v86);
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 67109376;
        HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = IntValue;
        LOWORD(buf[0].__r_.__value_.__r.__words[1]) = 1024;
        *(&buf[0].__r_.__value_.__r.__words[1] + 2) = v8;
        _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Network mcc is changing from %03d to %03d", buf, 0xEu);
      }

      MCC::operator=();
      sub_10165733C(*(a1 + 48), &v85);
      MCC::getStringValue(buf, (a1 + 72));
      sub_100DF1690((a1 + 8), &v85, buf);
      if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(buf[0].__r_.__value_.__l.__data_);
      }

      sub_100005978(&v85);
    }

    if (MCC::operator!=())
    {
      v9 = *(a1 + 8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        IntegerWidth = MNC::getIntegerWidth((a1 + 104));
        v11 = MCC::getIntValue((a1 + 104));
        v12 = MNC::getIntegerWidth(v88);
        v13 = MCC::getIntValue(v88);
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 67109888;
        HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = IntegerWidth;
        LOWORD(buf[0].__r_.__value_.__r.__words[1]) = 1024;
        *(&buf[0].__r_.__value_.__r.__words[1] + 2) = v11;
        HIWORD(buf[0].__r_.__value_.__r.__words[1]) = 1024;
        LODWORD(buf[0].__r_.__value_.__r.__words[2]) = v12;
        WORD2(buf[0].__r_.__value_.__r.__words[2]) = 1024;
        *(&buf[0].__r_.__value_.__r.__words[2] + 6) = v13;
        _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Network mnc is changing from %0.*d to %0.*d", buf, 0x1Au);
      }

      MCC::operator=();
      sub_101657528(*(a1 + 48), &v84);
      MCC::getStringValue(buf, (a1 + 104));
      sub_100DF1690((a1 + 8), &v84, buf);
      if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(buf[0].__r_.__value_.__l.__data_);
      }

      sub_100005978(&v84);
      v5 = 1;
    }

    v14 = *a2;
    if (*(a1 + 164) != *a2)
    {
      v15 = *(a1 + 8);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v16 = asString();
        v17 = asString();
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315394;
        *(buf[0].__r_.__value_.__r.__words + 4) = v16;
        WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
        *(&buf[0].__r_.__value_.__r.__words[1] + 6) = v17;
        _os_log_impl(&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Network rat is changing from %s to %s", buf, 0x16u);
        v14 = *a2;
      }

      *(a1 + 164) = v14;
      sub_101657AEC(*(a1 + 48), &v83);
      LODWORD(buf[0].__r_.__value_.__l.__data_) = *(a1 + 164);
      sub_101622FA4((a1 + 8), &v83, buf);
      sub_100005978(&v83);
      v5 = 1;
    }

    formPLMN((a1 + 72), (a1 + 104));
    memset(v82, 0, sizeof(v82));
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      v19 = v82[0];
      v82[0] = Mutable;
      buf[0].__r_.__value_.__r.__words[0] = v19;
      sub_1000296E0(&buf[0].__r_.__value_.__l.__data_);
    }

    v20 = v82[0];
    if (SHIBYTE(v82[3]) < 0)
    {
      sub_100005F2C(&__dst, v82[1], v82[2]);
    }

    else
    {
      __dst = *&v82[1];
    }

    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      sub_100005F2C(&v98, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }

    else
    {
      v98 = __dst;
    }

    v91.__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
    {
      sub_100005F2C(buf, v98.__r_.__value_.__l.__data_, v98.__r_.__value_.__l.__size_);
    }

    else
    {
      buf[0] = v98;
    }

    v77.__r_.__value_.__r.__words[0] = 0;
    if (ctu::cf::convert_copy())
    {
      v22 = v91.__r_.__value_.__r.__words[0];
      v91.__r_.__value_.__r.__words[0] = v77.__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = v22;
      sub_100005978(&__str.__r_.__value_.__l.__data_);
    }

    v23 = qword_101FCB6F0;
    if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }

    value = v91.__r_.__value_.__r.__words[0];
    v91.__r_.__value_.__r.__words[0] = 0;
    sub_100005978(&v91.__r_.__value_.__l.__data_);
    if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v98.__r_.__value_.__l.__data_);
    }

    CFDictionarySetValue(v20, v23, value);
    sub_100005978(&value);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }

    *v96 = 0u;
    v97 = 0u;
    *v94 = 0u;
    v95 = 0u;
    *v93 = 0u;
    memset(buf, 0, sizeof(buf));
    ServiceMap = Registry::getServiceMap(*(a1 + 32));
    v25 = ServiceMap;
    v27 = v26;
    if ((v26 & 0x8000000000000000) != 0)
    {
      v28 = (v26 & 0x7FFFFFFFFFFFFFFFLL);
      v29 = 5381;
      do
      {
        v27 = v29;
        v30 = *v28++;
        v29 = (33 * v29) ^ v30;
      }

      while (v30);
    }

    std::mutex::lock(ServiceMap);
    v98.__r_.__value_.__r.__words[0] = v27;
    v31 = sub_100009510(&v25[1].__m_.__sig, &v98);
    if (v31)
    {
      v33 = v31[3];
      v32 = v31[4];
      if (v32)
      {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v25);
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v32);
        v34 = 0;
        goto LABEL_88;
      }
    }

    else
    {
      v33 = 0;
    }

    std::mutex::unlock(v25);
    v32 = 0;
    v34 = 1;
LABEL_88:
    sub_100010180(&v79, v82);
    (*(*v33 + 24))(buf, v33, &v79);
    sub_10001021C(&v79);
    if ((v34 & 1) == 0)
    {
      sub_100004A34(v32);
    }

    memset(&__str, 0, sizeof(__str));
    if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0)
    {
      sub_100005F2C(&__str, buf[1].__r_.__value_.__l.__data_, buf[1].__r_.__value_.__l.__size_);
    }

    else
    {
      __str = buf[1];
    }

    memset(&v98, 0, sizeof(v98));
    ctu::cf::assign();
    v77 = v98;
    v35 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    v36 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    size = __str.__r_.__value_.__l.__size_;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v38 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v38 = __str.__r_.__value_.__l.__size_;
    }

    v39 = HIBYTE(v98.__r_.__value_.__r.__words[2]);
    if ((v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    {
      v39 = v77.__r_.__value_.__l.__size_;
    }

    if (v38 == v39)
    {
      v40 = (__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &__str : __str.__r_.__value_.__r.__words[0];
      v41 = (v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &v77 : v77.__r_.__value_.__r.__words[0];
      if (!memcmp(v40, v41, v38))
      {
        memset(&v98, 0, sizeof(v98));
        v42 = &v98;
        sub_1000677C4(&v98, v38 + 1);
        if ((v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          v42 = v98.__r_.__value_.__r.__words[0];
        }

        if (v38)
        {
          memmove(v42, v41, v38);
        }

        *(&v42->__r_.__value_.__l.__data_ + v38) = 45;
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__str.__r_.__value_.__l.__data_);
        }

        __str = v98;
        MCC::getStringValue(&v91, (a1 + 72));
        v43 = std::string::append(&v91, "-", 1uLL);
        v44 = *&v43->__r_.__value_.__l.__data_;
        v98.__r_.__value_.__r.__words[2] = v43->__r_.__value_.__r.__words[2];
        *&v98.__r_.__value_.__l.__data_ = v44;
        v43->__r_.__value_.__l.__size_ = 0;
        v43->__r_.__value_.__r.__words[2] = 0;
        v43->__r_.__value_.__r.__words[0] = 0;
        if ((v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v45 = &v98;
        }

        else
        {
          v45 = v98.__r_.__value_.__r.__words[0];
        }

        if ((v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v46 = HIBYTE(v98.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v46 = v98.__r_.__value_.__l.__size_;
        }

        std::string::append(&__str, v45, v46);
        if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v98.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v91.__r_.__value_.__l.__data_);
        }

        MCC::getStringValue(&v98, (a1 + 104));
        if ((v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v47 = &v98;
        }

        else
        {
          v47 = v98.__r_.__value_.__r.__words[0];
        }

        if ((v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v48 = HIBYTE(v98.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v48 = v98.__r_.__value_.__l.__size_;
        }

        std::string::append(&__str, v47, v48);
        if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v98.__r_.__value_.__l.__data_);
        }

        v35 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        size = __str.__r_.__value_.__l.__size_;
        v36 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      }
    }

    v49 = (a1 + 136);
    v50 = *(a1 + 159);
    if (v50 >= 0)
    {
      v51 = *(a1 + 159);
    }

    else
    {
      v51 = *(a1 + 144);
    }

    if (v36 >= 0)
    {
      v52 = v35;
    }

    else
    {
      v52 = size;
    }

    if (v51 != v52 || (v50 >= 0 ? (v53 = (a1 + 136)) : (v53 = *v49), v36 >= 0 ? (v54 = &__str) : (v54 = __str.__r_.__value_.__r.__words[0]), memcmp(v53, v54, v51)))
    {
      v55 = *(a1 + 8);
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        v56 = a1 + 136;
        if (v50 < 0)
        {
          v56 = *v49;
        }

        p_str = __str.__r_.__value_.__r.__words[0];
        if (v36 >= 0)
        {
          p_str = &__str;
        }

        LODWORD(v98.__r_.__value_.__l.__data_) = 136315394;
        *(v98.__r_.__value_.__r.__words + 4) = v56;
        WORD2(v98.__r_.__value_.__r.__words[1]) = 2080;
        *(&v98.__r_.__value_.__r.__words[1] + 6) = p_str;
        _os_log_impl(&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Operator bundle is changing from %s to %s", &v98, 0x16u);
      }

      std::string::operator=((a1 + 136), &__str);
      sub_101657714(*(a1 + 48), &v76);
      sub_100DF1690((a1 + 8), &v76, a1 + 136);
      sub_100005978(&v76);
      v5 = 1;
    }

    memset(&v98, 0, sizeof(v98));
    v58 = Registry::getServiceMap(*(a1 + 32));
    v59 = v58;
    if ((v26 & 0x8000000000000000) != 0)
    {
      v60 = (v26 & 0x7FFFFFFFFFFFFFFFLL);
      v61 = 5381;
      do
      {
        v26 = v61;
        v62 = *v60++;
        v61 = (33 * v61) ^ v62;
      }

      while (v62);
    }

    std::mutex::lock(v58);
    v91.__r_.__value_.__r.__words[0] = v26;
    v63 = sub_100009510(&v59[1].__m_.__sig, &v91);
    if (v63)
    {
      v65 = v63[3];
      v64 = v63[4];
      if (v64)
      {
        atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v59);
        atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v64);
        v66 = 0;
LABEL_160:
        (*(*v65 + 56))(&v98, v65, 1, *(a1 + 48));
        if ((v66 & 1) == 0)
        {
          sub_100004A34(v64);
        }

        if ((v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v67 = HIBYTE(v98.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v67 = v98.__r_.__value_.__l.__size_;
        }

        v68 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          v68 = __str.__r_.__value_.__l.__size_;
        }

        v69 = 4;
        if (v67 == v68)
        {
          if ((v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            v70 = &v98;
          }

          else
          {
            v70 = v98.__r_.__value_.__r.__words[0];
          }

          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            v71 = &__str;
          }

          else
          {
            v71 = __str.__r_.__value_.__r.__words[0];
          }

          if (!memcmp(v70, v71, v67))
          {
            v69 = 5;
          }

          else
          {
            v69 = 4;
          }
        }

        if (*(a1 + 160) != v69)
        {
          v72 = *(a1 + 8);
          if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
          {
            v73 = asString();
            v74 = asString();
            LODWORD(v91.__r_.__value_.__l.__data_) = 136315394;
            *(v91.__r_.__value_.__r.__words + 4) = v73;
            WORD2(v91.__r_.__value_.__r.__words[1]) = 2080;
            *(&v91.__r_.__value_.__r.__words[1] + 6) = v74;
            _os_log_impl(&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I Network roaming is changing from %s to %s", &v91, 0x16u);
          }

          *(a1 + 160) = v69;
          sub_101657900(*(a1 + 48), &v75);
          v91.__r_.__value_.__s.__data_[0] = mapRoamingResultToTriBOOL() == 1;
          sub_101623394((a1 + 8), &v75, &v91);
          sub_100005978(&v75);
          v5 = 1;
        }

        sub_10130C890(a1, v5);
        if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v98.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v77.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__str.__r_.__value_.__l.__data_);
        }

        if (SBYTE7(v97) < 0)
        {
          operator delete(v96[0]);
        }

        if (SHIBYTE(v95) < 0)
        {
          operator delete(v94[1]);
        }

        if (SHIBYTE(v94[0]) < 0)
        {
          operator delete(v93[0]);
        }

        if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(buf[1].__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(buf[0].__r_.__value_.__l.__data_);
        }

        sub_1000296E0(v82);
        if (SHIBYTE(v82[3]) < 0)
        {
          operator delete(v82[1]);
        }

        goto LABEL_199;
      }
    }

    else
    {
      v65 = 0;
    }

    std::mutex::unlock(v59);
    v64 = 0;
    v66 = 1;
    goto LABEL_160;
  }

  v21 = *(a1 + 8);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I No valid 3GPP cell info", buf, 2u);
  }

LABEL_199:
  if (v90 == 1)
  {
    if (SHIBYTE(v89) < 0)
    {
      operator delete(v88[1]);
    }

    if (SHIBYTE(v87) < 0)
    {
      operator delete(v86[1]);
    }
  }
}

void sub_101622D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, __int16 a31)
{
  sub_1002FECBC(v31 - 176);
  sub_100EBBF84(&a31);
  _Unwind_Resume(a1);
}

const void **sub_101622FA4(NSObject **a1, CFStringRef *a2, int *a3)
{
  v28 = 0;
  __p.__r_.__value_.__r.__words[0] = 0;
  LODWORD(valuePtr.__r_.__value_.__l.__data_) = *a3;
  v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v6)
  {
    v7 = __p.__r_.__value_.__r.__words[0];
    __p.__r_.__value_.__r.__words[0] = v6;
    valuePtr.__r_.__value_.__r.__words[0] = v7;
    sub_100029A48(&valuePtr.__r_.__value_.__l.__data_);
  }

  v28 = __p.__r_.__value_.__r.__words[0];
  __p.__r_.__value_.__r.__words[0] = 0;
  sub_100029A48(&__p.__r_.__value_.__l.__data_);
  v8 = v28;
  v9 = *a1;
  v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v28)
  {
    if (v10)
    {
      memset(&v27, 0, sizeof(v27));
      memset(&valuePtr, 0, sizeof(valuePtr));
      v36 = &valuePtr.__r_.__value_.__s.__data_[2];
      v37 = &valuePtr.__r_.__value_.__r.__words[2] + 7;
      v11 = *a3;
      if (v11 >= 0)
      {
        v12 = v11;
      }

      else
      {
        v12 = -v11;
      }

      LODWORD(__p.__r_.__value_.__l.__data_) = v12;
      __p.__r_.__value_.__l.__size_ = &valuePtr.__r_.__value_.__r.__words[2] + 7;
      __p.__r_.__value_.__s.__data_[16] = 48;
      HIDWORD(__p.__r_.__value_.__r.__words[2]) = 48;
      v13 = sub_10075B978(&__p);
      v14 = v13;
      if (v11 < 0)
      {
        *(v13 - 1) = 45;
        v14 = (v13 - 1);
      }

      v36 = v14;
      v37 = &valuePtr.__r_.__value_.__r.__words[2] + 7;
      sub_1000D192C(&v27, v14, &valuePtr.__r_.__value_.__r.__words[2] + 7, &valuePtr.__r_.__value_.__r.__words[2] + 7 - v14);
      v15 = SHIBYTE(v27.__r_.__value_.__r.__words[2]);
      v16 = v27.__r_.__value_.__r.__words[0];
      memset(&valuePtr, 0, sizeof(valuePtr));
      ctu::cf::assign();
      v17 = &v27;
      if (v15 < 0)
      {
        v17 = v16;
      }

      __p = valuePtr;
      p_p = &__p;
      if ((valuePtr.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        p_p = __p.__r_.__value_.__r.__words[0];
      }

      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(buf.__r_.__value_.__r.__words + 4) = v17;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(&buf.__r_.__value_.__r.__words[1] + 6) = p_p;
      _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Saving value %s for key %s", &buf, 0x16u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v27.__r_.__value_.__l.__data_);
      }

      v8 = v28;
    }

    v19 = kCommCenterPreferencesNoBackupAppID;
    CFPreferencesSetValue(*a2, v8, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    CFPreferencesSynchronize(v19, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  }

  else if (v10)
  {
    memset(&valuePtr, 0, sizeof(valuePtr));
    ctu::cf::assign();
    v27 = valuePtr;
    v20 = *a3;
    if ((valuePtr.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v21 = &v27;
    }

    else
    {
      v21 = v27.__r_.__value_.__r.__words[0];
    }

    memset(&buf, 0, sizeof(buf));
    memset(&valuePtr, 0, sizeof(valuePtr));
    v36 = &valuePtr.__r_.__value_.__s.__data_[2];
    v37 = &valuePtr.__r_.__value_.__r.__words[2] + 7;
    if (v20 >= 0)
    {
      v22 = v20;
    }

    else
    {
      v22 = -v20;
    }

    LODWORD(__p.__r_.__value_.__l.__data_) = v22;
    __p.__r_.__value_.__l.__size_ = &valuePtr.__r_.__value_.__r.__words[2] + 7;
    __p.__r_.__value_.__s.__data_[16] = 48;
    HIDWORD(__p.__r_.__value_.__r.__words[2]) = 48;
    v23 = sub_10075B978(&__p);
    v24 = v23;
    if (v20 < 0)
    {
      *(v23 - 1) = 45;
      v24 = (v23 - 1);
    }

    v36 = v24;
    v37 = &valuePtr.__r_.__value_.__r.__words[2] + 7;
    sub_1000D192C(&buf, v24, &valuePtr.__r_.__value_.__r.__words[2] + 7, &valuePtr.__r_.__value_.__r.__words[2] + 7 - v24);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      p_buf = &buf;
    }

    else
    {
      p_buf = buf.__r_.__value_.__r.__words[0];
    }

    *v31 = 136315394;
    v32 = v21;
    v33 = 2080;
    v34 = p_buf;
    _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Failed to created CF object for key %s with value: %s", v31, 0x16u);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
    }

    if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v27.__r_.__value_.__l.__data_);
    }
  }

  return sub_100029A48(&v28);
}

void sub_101623310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  if (*(v27 - 89) < 0)
  {
    operator delete(*(v27 - 112));
  }

  sub_100029A48(&a15);
  _Unwind_Resume(a1);
}

const void **sub_101623394(NSObject **a1, CFStringRef *a2, char *a3)
{
  if (*a3)
  {
    v6 = &kCFBooleanTrue;
  }

  else
  {
    v6 = &kCFBooleanFalse;
  }

  v7 = *v6;
  v26.__r_.__value_.__r.__words[0] = 0;
  sub_100045C8C(&v26.__r_.__value_.__l.__data_);
  v25 = v7;
  v26.__r_.__value_.__r.__words[0] = 0;
  sub_100045C8C(&v26.__r_.__value_.__l.__data_);
  v8 = *a1;
  v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    if (v9)
    {
      memset(&v24, 0, sizeof(v24));
      v26.__r_.__value_.__r.__words[0] = 0;
      v26.__r_.__value_.__l.__size_ = v26.__r_.__value_.__r.__words + 2;
      if (*a3)
      {
        v10 = 49;
      }

      else
      {
        v10 = 48;
      }

      v26.__r_.__value_.__s.__data_[2] = v10;
      v26.__r_.__value_.__r.__words[2] = v26.__r_.__value_.__r.__words + 3;
      sub_1000D192C(&v24, &v26.__r_.__value_.__s.__data_[2], &v26.__r_.__value_.__s.__data_[3], 1uLL);
      v11 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
      v12 = v24.__r_.__value_.__r.__words[0];
      memset(&v26, 0, sizeof(v26));
      ctu::cf::assign();
      v13 = &v24;
      if (v11 < 0)
      {
        v13 = v12;
      }

      __p = v26;
      p_p = &__p;
      if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        p_p = v26.__r_.__value_.__r.__words[0];
      }

      *buf = 136315394;
      v28 = v13;
      v29 = 2080;
      v30 = p_p;
      _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Saving value %s for key %s", buf, 0x16u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v24.__r_.__value_.__l.__data_);
      }

      v7 = v25;
    }

    v15 = kCommCenterPreferencesNoBackupAppID;
    CFPreferencesSetValue(*a2, v7, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    CFPreferencesSynchronize(v15, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  }

  else if (v9)
  {
    memset(&v26, 0, sizeof(v26));
    ctu::cf::assign();
    v24 = v26;
    v16 = *a3;
    v17 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
    v18 = v26.__r_.__value_.__r.__words[0];
    memset(&__p, 0, sizeof(__p));
    v26.__r_.__value_.__r.__words[0] = 0;
    v26.__r_.__value_.__l.__size_ = v26.__r_.__value_.__r.__words + 2;
    if (v16)
    {
      v19 = 49;
    }

    else
    {
      v19 = 48;
    }

    v26.__r_.__value_.__s.__data_[2] = v19;
    v26.__r_.__value_.__r.__words[2] = v26.__r_.__value_.__r.__words + 3;
    sub_1000D192C(&__p, &v26.__r_.__value_.__s.__data_[2], &v26.__r_.__value_.__s.__data_[3], 1uLL);
    v20 = &v24;
    if (v17 < 0)
    {
      v20 = v18;
    }

    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v21 = &__p;
    }

    else
    {
      v21 = __p.__r_.__value_.__r.__words[0];
    }

    *buf = 136315394;
    v28 = v20;
    v29 = 2080;
    v30 = v21;
    _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Failed to created CF object for key %s with value: %s", buf, 0x16u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v24.__r_.__value_.__l.__data_);
    }
  }

  return sub_100045C8C(&v25);
}

void sub_101623678(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, const void *a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  if (v30 < 0)
  {
    operator delete(v29);
  }

  sub_100045C8C(&a23);
  _Unwind_Resume(a1);
}

void sub_1016236F0(uint64_t a1, int *a2)
{
  v4 = *a2 + 1;
  if (v4 > 0xC)
  {
    goto LABEL_8;
  }

  v5 = 1 << v4;
  if ((v5 & 0x1D2B) != 0)
  {

    sub_10130C748(a1);
    return;
  }

  if (v5 & 0x250) == 0 || (a2[178])
  {
LABEL_8:
    memset(&buf, 0, sizeof(buf));
    ServiceMap = Registry::getServiceMap(*(a1 + 32));
    v7 = ServiceMap;
    if (v8 < 0)
    {
      v9 = (v8 & 0x7FFFFFFFFFFFFFFFLL);
      v10 = 5381;
      do
      {
        v8 = v10;
        v11 = *v9++;
        v10 = (33 * v10) ^ v11;
      }

      while (v11);
    }

    std::mutex::lock(ServiceMap);
    *__p = v8;
    v12 = sub_100009510(&v7[1].__m_.__sig, __p);
    if (v12)
    {
      v14 = v12[3];
      v13 = v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v13);
        v15 = 0;
LABEL_18:
        MCC::getStringValue(__p, (a2 + 154));
        (*(*v14 + 24))(&buf, v14, __p);
        if (v50 < 0)
        {
          operator delete(*__p);
        }

        if ((v15 & 1) == 0)
        {
          sub_100004A34(v13);
        }

        v17 = (a1 + 72);
        v18 = *(a1 + 95);
        if (v18 >= 0)
        {
          v19 = *(a1 + 95);
        }

        else
        {
          v19 = *(a1 + 80);
        }

        size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        v21 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          size = buf.__r_.__value_.__l.__size_;
        }

        if (v19 == size && (v18 >= 0 ? (v22 = (a1 + 72)) : (v22 = *v17), (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? (v23 = &buf) : (v23 = buf.__r_.__value_.__r.__words[0]), !memcmp(v22, v23, v19)))
        {
          v27 = 0;
        }

        else
        {
          v24 = *(a1 + 8);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            v25 = (a1 + 72);
            if (v18 < 0)
            {
              v25 = *v17;
            }

            p_buf = buf.__r_.__value_.__r.__words[0];
            if (v21 >= 0)
            {
              p_buf = &buf;
            }

            *__p = 136315394;
            *&__p[4] = v25;
            *&__p[12] = 2080;
            v49 = p_buf;
            _os_log_impl(&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I 1x Network iso is changing from %s to %s", __p, 0x16u);
          }

          std::string::operator=((a1 + 72), &buf);
          sub_101657CD8(*(a1 + 48), &v46);
          sub_100DF1690((a1 + 8), &v46, a1 + 72);
          sub_100005978(&v46);
          v27 = 1;
        }

        v28 = *(a1 + 96);
        v29 = *(a2 + 342);
        if (v28 != v29)
        {
          v30 = *(a1 + 8);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            *__p = 67109376;
            *&__p[4] = v28;
            *&__p[8] = 1024;
            *&__p[10] = v29;
            _os_log_impl(&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I 1x Network sid is changing from %d to %d", __p, 0xEu);
            v29 = *(a2 + 342);
          }

          *(a1 + 96) = v29;
          sub_101657EC4(*(a1 + 48), &v45);
          *__p = *(a1 + 96);
          sub_101622FA4((a1 + 8), &v45, __p);
          sub_100005978(&v45);
          v27 = 1;
        }

        v31 = *(a1 + 100);
        v32 = *(a2 + 343);
        if (v31 != v32)
        {
          v33 = *(a1 + 8);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            *__p = 67109376;
            *&__p[4] = v31;
            *&__p[8] = 1024;
            *&__p[10] = v32;
            _os_log_impl(&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I 1x Network nid is changing from %d to %d", __p, 0xEu);
            v32 = *(a2 + 343);
          }

          *(a1 + 100) = v32;
          sub_1016580B0(*(a1 + 48), &v44);
          *__p = *(a1 + 100);
          sub_101622FA4((a1 + 8), &v44, __p);
          sub_100005978(&v44);
          v27 = 1;
        }

        v34 = *a2;
        if (*(a1 + 108) != *a2)
        {
          v35 = *(a1 + 8);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            v36 = asString();
            v37 = asString();
            *__p = 136315394;
            *&__p[4] = v36;
            *&__p[12] = 2080;
            v49 = v37;
            _os_log_impl(&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I 1x Network rat is changing from %s to %s", __p, 0x16u);
            v34 = *a2;
          }

          *(a1 + 108) = v34;
          sub_101658488(*(a1 + 48), &v43);
          *__p = *(a1 + 108);
          sub_101622FA4((a1 + 8), &v43, __p);
          sub_100005978(&v43);
          v27 = 1;
        }

        if ((*(a2 + 803) & 1) == 0)
        {
          sub_1000D1644();
        }

        if (*(a2 + 802))
        {
          v38 = 5;
        }

        else
        {
          v38 = 4;
        }

        if (*(a1 + 104) != v38)
        {
          v39 = *(a1 + 8);
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            v40 = asString();
            v41 = asString();
            *__p = 136315394;
            *&__p[4] = v40;
            *&__p[12] = 2080;
            v49 = v41;
            _os_log_impl(&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I 1x Network roaming is changing from %s to %s", __p, 0x16u);
          }

          *(a1 + 104) = v38;
          sub_10165829C(*(a1 + 48), &v42);
          __p[0] = mapRoamingResultToTriBOOL() == 1;
          sub_101623394((a1 + 8), &v42, __p);
          sub_100005978(&v42);
          v27 = 1;
        }

        sub_10130C890(a1, v27);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(buf.__r_.__value_.__l.__data_);
        }

        return;
      }
    }

    else
    {
      v14 = 0;
    }

    std::mutex::unlock(v7);
    v13 = 0;
    v15 = 1;
    goto LABEL_18;
  }

  v16 = *(a1 + 8);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I No valid 1x cell info", &buf, 2u);
  }
}

void sub_101623D04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20, char a21, char a22, int a23, __int16 a24, char a25, char a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, void *a34, uint64_t a35, int a36, __int16 a37, char a38, char a39)
{
  if (a32 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_101623DA8(uint64_t a1)
{
  v2 = *(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    IntValue = MCC::getIntValue((a1 + 72));
    IntegerWidth = MNC::getIntegerWidth((a1 + 104));
    v5 = MCC::getIntValue((a1 + 104));
    v6 = (a1 + 136);
    if (*(a1 + 159) < 0)
    {
      v6 = *v6;
    }

    v7[0] = 67110402;
    v7[1] = IntValue;
    v8 = 1024;
    v9 = IntegerWidth;
    v10 = 1024;
    v11 = v5;
    v12 = 2080;
    v13 = v6;
    v14 = 2080;
    v15 = asString();
    v16 = 2080;
    v17 = asString();
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I 3GPP Operator Roaming: Network MCC: %03d, Network MNC: %0.*d, Current operator bundle ID: %s, Roaming: %s, RAT: %s", v7, 0x32u);
  }
}

void sub_101623ED4(uint64_t a1)
{
  v2 = *(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = (a1 + 72);
    if (*(a1 + 95) < 0)
    {
      v3 = *v3;
    }

    v4 = *(a1 + 96);
    v5 = *(a1 + 100);
    v6 = 136316162;
    v7 = v3;
    v8 = 1024;
    v9 = v4;
    v10 = 1024;
    v11 = v5;
    v12 = 2080;
    v13 = asString();
    v14 = 2080;
    v15 = asString();
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I 3GPP2 Operator Roaming: Network ISO: %s, SID: %d, NID: %d, Roaming: %s, RAT: %s", &v6, 0x2Cu);
  }
}

void *sub_101623FD0(uint64_t a1)
{
  *a1 = off_101F58310;
  if (*(a1 + 159) < 0)
  {
    operator delete(*(a1 + 136));
  }

  if (*(a1 + 135) < 0)
  {
    operator delete(*(a1 + 112));
  }

  if (*(a1 + 103) < 0)
  {
    operator delete(*(a1 + 80));
  }

  return sub_10130C6E0(a1);
}

void sub_101624050(uint64_t a1)
{
  *a1 = off_101F58310;
  if (*(a1 + 159) < 0)
  {
    operator delete(*(a1 + 136));
  }

  if (*(a1 + 135) < 0)
  {
    operator delete(*(a1 + 112));
  }

  if (*(a1 + 103) < 0)
  {
    operator delete(*(a1 + 80));
  }

  sub_10130C6E0(a1);

  operator delete();
}

void *sub_1016240E4(uint64_t a1)
{
  *a1 = off_101F58338;
  if (*(a1 + 95) < 0)
  {
    operator delete(*(a1 + 72));
  }

  return sub_10130C6E0(a1);
}

void sub_101624144(uint64_t a1)
{
  *a1 = off_101F58338;
  if (*(a1 + 95) < 0)
  {
    operator delete(*(a1 + 72));
  }

  sub_10130C6E0(a1);

  operator delete();
}

void sub_1016241B8(uint64_t a1, uint64_t a2)
{
  if (*(a1 + 64) == *(a2 + 64))
  {
    if (*(a1 + 64))
    {
      MCC::operator=();

      MCC::operator=();
    }
  }

  else if (*(a1 + 64))
  {
    if (*(a1 + 63) < 0)
    {
      operator delete(*(a1 + 40));
    }

    if (*(a1 + 31) < 0)
    {
      operator delete(*(a1 + 8));
    }

    *(a1 + 64) = 0;
  }

  else
  {
    sub_101624260(a1, a2);
    *(a1 + 64) = 1;
  }
}

MCC *sub_101624260(MCC *a1, uint64_t a2)
{
  MCC::MCC(a1, a2);
  MCC::MCC((v4 + 32), (a2 + 32));
  return a1;
}

void sub_101624298(_Unwind_Exception *exception_object)
{
  if (*(v1 + 31) < 0)
  {
    operator delete(*(v1 + 8));
  }

  _Unwind_Resume(exception_object);
}

void sub_101624334(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    (*(*v1 + 8))(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_101624370(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1016243A8(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t sub_1016243D8(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

void sub_101624498(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    (*(*v1 + 8))(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016244D4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10162450C(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t sub_10162453C(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

MCC *sub_10162457C(MCC *a1, const MCC *a2, const MCC *a3)
{
  MCC::MCC(a1, a2);
  MCC::MCC((v5 + 32), a3);
  return a1;
}

void sub_1016245B4(_Unwind_Exception *exception_object)
{
  if (*(v1 + 31) < 0)
  {
    operator delete(*(v1 + 8));
  }

  _Unwind_Resume(exception_object);
}

void sub_10162488C(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0)
  {
    sub_100004A34(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101624C00(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0)
  {
    sub_100004A34(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101624F84(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0)
  {
    sub_100004A34(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101625304(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0)
  {
    sub_100004A34(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101625688(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0)
  {
    sub_100004A34(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10162573C(uint64_t a1)
{

  operator delete();
}

id sub_1016257F0(uint64_t a1, void *a2)
{
  *a2 = off_101F58480;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_101625840(id *a1)
{

  operator delete(a1);
}

void sub_10162587C(uint64_t a1, uint64_t *a2)
{
  v3 = *a2;
  if (HIDWORD(*a2))
  {
    v4 = v3 == 0;
  }

  else
  {
    v4 = 1;
  }

  if (v4)
  {
    goto LABEL_8;
  }

  if (v3 == 2)
  {
    v5 = [NSError alloc];
    v6 = &NSMachErrorDomain;
    goto LABEL_10;
  }

  if (v3 != 1)
  {
LABEL_8:
    v7 = 0;
    goto LABEL_11;
  }

  v5 = [NSError alloc];
  v6 = &NSPOSIXErrorDomain;
LABEL_10:
  v7 = [v5 initWithDomain:*v6 code:v3 >> 32 userInfo:0];
LABEL_11:
  v8 = v7;
  (*(*(a1 + 8) + 16))();
}

uint64_t sub_101625958(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F584E0))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_1016259D0(uint64_t a1)
{

  operator delete();
}

id sub_101625A84(uint64_t a1, void *a2)
{
  *a2 = off_101F58500;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_101625AD4(id *a1)
{

  operator delete(a1);
}

const void **sub_101625B10(uint64_t a1, const void **a2)
{
  v6 = *a2;
  v3 = v6;
  *a2 = 0;
  v4 = objc_opt_new();
  [v4 setLegacyInfo:v3];
  (*(*(a1 + 8) + 16))();

  return sub_100010250(&v6);
}

void sub_101625B88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100010250(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101625BA8(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F58560))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_101625C20(uint64_t a1)
{

  operator delete();
}

id sub_101625CD4(uint64_t a1, void *a2)
{
  *a2 = off_101F58580;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_101625D24(id *a1)
{

  operator delete(a1);
}

void sub_101625D60(uint64_t a1, void *a2)
{
  v3 = [NSNumber numberWithUnsignedLongLong:*a2];
  (*(*(a1 + 8) + 16))();
}

uint64_t sub_101625DE0(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F585F0))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_101625E58(uint64_t a1)
{

  operator delete();
}

id sub_101625F0C(uint64_t a1, void *a2)
{
  *a2 = off_101F58610;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_101625F5C(id *a1)
{

  operator delete(a1);
}

void sub_101625F98(uint64_t a1, void *a2, unsigned int *a3)
{
  v4 = [CTCellIdInfo cellIdInfoFromCellId:*a2 baseId:*a3];
  (*(*(a1 + 8) + 16))();
}

uint64_t sub_101626020(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F58680))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_101626098(uint64_t a1)
{

  operator delete();
}

id sub_10162614C(uint64_t a1, void *a2)
{
  *a2 = off_101F586A0;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10162619C(id *a1)
{

  operator delete(a1);
}

void sub_1016261D8(uint64_t a1, void *a2)
{
  v3 = [NSNumber numberWithUnsignedLongLong:*a2];
  (*(*(a1 + 8) + 16))();
}

uint64_t sub_101626258(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F58700))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

CellularUsageStoreInterface *sub_1016262A4(CellularUsageStoreInterface *this)
{
  *this = &off_101F58720;
  if (*(this + 8))
  {
    CPRecordStoreDestroy();
  }

  v2 = *(this + 11);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(this + 7);
  if (v3)
  {
    sub_100004A34(v3);
  }

  CellularUsageStoreInterface::~CellularUsageStoreInterface(this);
  ctu::OsLogLogger::~OsLogLogger((this + 40));
  sub_1000C0544(this + 1);
  return this;
}

void sub_101626328(CellularUsageStoreInterface *a1)
{
  sub_1016262A4(a1);

  operator delete();
}

uint64_t sub_101626360()
{
  CPRecordStoreCreateTablesForClass();
  CPRecordStoreCreateTablesForClass();
  CPRecordStoreCreateTablesForClass();
  CPSqliteConnectionSetIntegerForProperty();
  for (i = 0; i != 32; i += 8)
  {
    result = CPSqliteConnectionStatementForSQL();
    if (result)
    {
      CPSqliteStatementPerform();
      result = CPSqliteStatementReset();
    }
  }

  return result;
}

uint64_t sub_10162641C(uint64_t a1)
{
  sub_100020BEC();
  v2 = qword_101FCAED8;
  if (os_log_type_enabled(qword_101FCAED8, OS_LOG_TYPE_DEFAULT))
  {
    *v5 = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Database corruption detected", v5, 2u);
  }

  if (a1)
  {
    v3 = *(a1 + 8);
    if (v3)
    {
      if (*(v3 + 8))
      {
        CPSqliteDatabaseDelete();
      }
    }
  }

  return 1;
}

BOOL sub_1016264A4(uint64_t a1, uint64_t a2, int a3)
{
  v4 = a3;
  sub_100020BEC();
  v5 = qword_101FCAED8;
  if (os_log_type_enabled(qword_101FCAED8, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67110144;
    v7[1] = v4;
    v8 = 1024;
    v9 = a3;
    v10 = 1024;
    v11 = 7;
    v12 = 1024;
    v13 = 327687;
    v14 = 1024;
    v15 = v4 < 7;
    _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Old database version: %d (%d), current database version: %d (%d), needs migration: %d", v7, 0x20u);
  }

  return v4 < 7;
}

uint64_t sub_101626594(uint64_t a1, uint64_t a2, unsigned __int16 a3)
{
  v3 = a3;
  sub_100020BEC();
  v4 = qword_101FCAED8;
  if (os_log_type_enabled(qword_101FCAED8, OS_LOG_TYPE_DEFAULT))
  {
    *v6 = 0;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Doing migration", v6, 2u);
  }

  if (v3 == 1)
  {
    if (CPSqliteConnectionStatementForSQL())
    {
      CPSqliteStatementPerform();
      CPSqliteStatementReset();
    }

    goto LABEL_7;
  }

  if (v3 - 1 <= 1)
  {
LABEL_7:
    if (CPSqliteConnectionStatementForSQL())
    {
      CPSqliteStatementPerform();
      CPSqliteStatementReset();
    }

    if (CPSqliteConnectionStatementForSQL())
    {
      CPSqliteStatementPerform();
      CPSqliteStatementReset();
    }

    if (CPSqliteConnectionStatementForSQL())
    {
      CPSqliteStatementPerform();
      CPSqliteStatementReset();
    }

    goto LABEL_14;
  }

  if (v3 == 3)
  {
LABEL_14:
    if (CPSqliteConnectionStatementForSQL())
    {
      CPSqliteStatementPerform();
      CPSqliteStatementReset();
    }

    goto LABEL_16;
  }

  if (v3 <= 4)
  {
LABEL_16:
    if (CPSqliteConnectionStatementForSQL())
    {
      CPSqliteStatementPerform();
      CPSqliteStatementReset();
    }

    goto LABEL_18;
  }

  if (v3 != 5)
  {
    if (v3 > 6)
    {
      return 0;
    }

    goto LABEL_22;
  }

LABEL_18:
  if (CPSqliteConnectionStatementForSQL())
  {
    CPSqliteStatementPerform();
    CPSqliteStatementReset();
  }

  if (CPSqliteConnectionStatementForSQL())
  {
    CPSqliteStatementPerform();
    CPSqliteStatementReset();
  }

LABEL_22:
  if (CPSqliteConnectionStatementForSQL())
  {
    CPSqliteStatementPerform();
    CPSqliteStatementReset();
  }

  return 0;
}

void sub_101626790(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_101626C08(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  v23 = *(v22 - 80);
  if (v23)
  {
    dispatch_release(v23);
  }

  v24 = *(v22 - 72);
  if (v24)
  {
    dispatch_release(v24);
  }

  if (a21 < 0)
  {
    operator delete(__p);
  }

  v25 = v21[7];
  if (v25)
  {
    sub_100004A34(v25);
  }

  CellularUsageStoreInterface::~CellularUsageStoreInterface(v21);
  ctu::OsLogLogger::~OsLogLogger((v21 + 5));
  sub_1000C0544(v21 + 1);
  operator delete();
}

void sub_101626CA8(uint64_t a1)
{
  v1 = *(a1 + 32);
  memset(&v23, 0, sizeof(v23));
  WirelessUserDirectory = _GetWirelessUserDirectory();
  v3 = &v23;
  sub_10000501C(&v23, WirelessUserDirectory);
  std::string::append(&v23, "/Library/Databases/", 0x13uLL);
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    v3 = v23.__r_.__value_.__r.__words[0];
  }

  v4 = sub_100357BF4();
  v5 = sub_100357C2C();
  sub_100357C64(v3, v4, v5, 0x1EDu);
  std::string::append(&v23, "CellularUsage.db", 0x10uLL);
  v22 = 0;
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
  {
    sub_100005F2C(&v21, v23.__r_.__value_.__l.__data_, v23.__r_.__value_.__l.__size_);
  }

  else
  {
    v21 = v23;
  }

  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
  {
    sub_100005F2C(&__dst, v21.__r_.__value_.__l.__data_, v21.__r_.__value_.__l.__size_);
  }

  else
  {
    __dst = v21;
  }

  v24 = 0;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    sub_100005F2C(&__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }

  else
  {
    __p = __dst;
  }

  v27 = 0;
  if (ctu::cf::convert_copy())
  {
    v6 = v24;
    v24 = v27;
    v28 = v6;
    sub_100005978(&v28);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v22 = v24;
  v24 = 0;
  sub_100005978(&v24);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v21.__r_.__value_.__l.__data_);
  }

  SchemaVersionAtPath = CPSqliteUtilitiesGetSchemaVersionAtPath();
  if ((SchemaVersionAtPath & 0x80000000) == 0)
  {
    *(v1 + 72) = SchemaVersionAtPath;
  }

  v8 = CPRecordStoreCreateWithPath();
  *(v1 + 64) = v8;
  if (v8)
  {
    CPRecordStoreSetSetupHandler();
    v9 = 0;
    v10 = 1;
    do
    {
      v11 = v10;
      v12 = CPRecordIndexOfPropertyNamed();
      v10 = 0;
      dword_101FCAEC8[v9] = v12;
      v9 = 1;
    }

    while ((v11 & 1) != 0);
    v13 = 0;
    v14 = 1;
    do
    {
      v15 = v14;
      v16 = CPRecordIndexOfPropertyNamed();
      v14 = 0;
      dword_101FCAEC8[v13 + 2] = v16;
      v13 = 1;
    }

    while ((v15 & 1) != 0);
    v17 = 0;
    v18 = &off_101F588C8;
    do
    {
      dword_101FCAEC8[v17 + 8] = CPRecordIndexOfPropertyNamed();
      ++v17;
      v18 += 5;
    }

    while (v17 != 13);
    if (CPRecordStoreGetDatabase())
    {
      CPSqliteDatabaseSetVersion();
      CPSqliteDatabaseSetDatabaseInitializer();
      CPSqliteDatabaseSetCorruptionHandler();
      CPSqliteDatabaseSetMigrationHandlers();
      CPSqliteDatabaseConnectionForWriting();
      v19 = *(v1 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Sucessfully created cellular usage database", &__p, 2u);
      }
    }

    else
    {
      v20 = *(v1 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl(&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Cellular Usage database was not set up correctly", &__p, 2u);
      }
    }
  }

  sub_100005978(&v22);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
}

void sub_101627064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, const void *a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35)
{
  sub_100005978(&a22);
  if (a28 < 0)
  {
    operator delete(__p);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  if (a21 < 0)
  {
    operator delete(a16);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1016270F4(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 40);
  *(result + 32) = *(a2 + 32);
  *(result + 40) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_101627110(uint64_t a1)
{
  v1 = *(a1 + 40);
  if (v1)
  {
    sub_100004A34(v1);
  }
}

void sub_101627120(uint64_t a1@<X0>, void *a2@<X8>)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_101627284;
  v4[3] = &unk_101F58B00;
  v4[4] = a1;
  v5 = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_10162C7D0;
  v6[3] = &unk_101F59060;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  v7 = v6;
  v3 = a1 + 24;
  v2 = *(a1 + 24);
  if (*(v3 + 8))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    v9 = 0x40000000;
    v10 = sub_10162C854;
    v11 = &unk_101F590A0;
    v12 = a2;
    v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    v9 = 0x40000000;
    v10 = sub_10162C7E4;
    v11 = &unk_101F59080;
    v12 = a2;
    v13 = &v7;
    dispatch_sync(v2, &block);
  }
}

uint64_t sub_101627284@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  result = *(*(a1 + 32) + 64);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (result)
  {
    v4[0] = off_101F59570;
    v4[3] = v4;
    v3[0] = off_101F59600;
    v3[1] = a2;
    v3[3] = v3;
    sub_10162A964(result, &off_101F58CB8, @"SELECT * from bundle_info WHERE (flags & ? == 0) ORDER BY bundle_id DESC;", 1, v4, v3);
    sub_10036ED9C(v3);
    return sub_10162E97C(v4);
  }

  return result;
}

void sub_101627364(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  sub_10036ED9C(&a10);
  sub_10162E97C(&a14);
  sub_1000087B4(&a9);
  _Unwind_Resume(a1);
}

void sub_10162738C(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_101627450;
  v3[3] = &unk_101F58B20;
  v3[4] = a1;
  v4 = v3;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10162C8C4;
  block[3] = &unk_101F590C0;
  block[4] = a1 + 8;
  block[5] = &v4;
  v2 = a1 + 24;
  v1 = *(a1 + 24);
  if (*(v2 + 8))
  {
    dispatch_async_and_wait(v1, block);
  }

  else
  {
    dispatch_sync(v1, block);
  }
}

uint64_t sub_101627458(uint64_t a1)
{
  result = *(a1 + 64);
  if (result)
  {
    err = 0;
    CPRecordStoreSave();
    return CPRecordStoreInvalidateCaches();
  }

  return result;
}

void sub_1016275A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (v21 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016275E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10162775C;
  v7[3] = &unk_101F58B40;
  v7[4] = a1;
  v7[5] = a2;
  v7[6] = a3;
  v7[7] = a4;
  v8 = v7;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_10162C8D8;
  v9[3] = &unk_101F590E0;
  v9[4] = a1 + 8;
  v9[5] = &v8;
  v10 = v9;
  v5 = a1 + 24;
  v4 = *(a1 + 24);
  if (*(v5 + 8))
  {
    v17 = 0;
    block = _NSConcreteStackBlock;
    v12 = 0x40000000;
    v13 = sub_10006A7C4;
    v14 = &unk_101F59120;
    v15 = &v17;
    v16 = &v10;
    dispatch_async_and_wait(v4, &block);
  }

  else
  {
    v17 = 0;
    block = _NSConcreteStackBlock;
    v12 = 0x40000000;
    v13 = sub_100059868;
    v14 = &unk_101F59100;
    v15 = &v17;
    v16 = &v10;
    dispatch_sync(v4, &block);
  }

  return v17 & 1;
}

BOOL sub_10162776C(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  *a4 = 0;
  v4 = *(a1 + 40);
  if (*(a1 + 64))
  {
    if (os_log_type_enabled(*(a1 + 40), OS_LOG_TYPE_DEFAULT))
    {
      if (*(a2 + 23) >= 0)
      {
        v9 = a2;
      }

      else
      {
        v9 = *a2;
      }

      if (*(a3 + 23) >= 0)
      {
        v10 = a3;
      }

      else
      {
        v10 = *a3;
      }

      v12 = 136315394;
      v13 = v9;
      v14 = 2080;
      v15 = v10;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Get subscriber tag for subscriber %s and mdn %s", &v12, 0x16u);
    }

    if (!sub_10162AEAC(a1, a2, a3, a4))
    {
      sub_10162B198(a1, a2, a3, a4, 0);
    }

    return 1;
  }

  else
  {
    result = os_log_type_enabled(*(a1 + 40), OS_LOG_TYPE_ERROR);
    if (result)
    {
      LOWORD(v12) = 0;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "The store does not exist!", &v12, 2u);
      return 0;
    }
  }

  return result;
}

void sub_1016278D4(uint64_t a1, uint64_t a2, int a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_1016279A0;
  v5[3] = &unk_101F58B60;
  v5[4] = a1;
  v5[5] = a2;
  v6 = a3;
  v7 = v5;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10162C8C4;
  block[3] = &unk_101F590C0;
  block[4] = a1 + 8;
  block[5] = &v7;
  v4 = a1 + 24;
  v3 = *(a1 + 24);
  if (*(v4 + 8))
  {
    dispatch_async_and_wait(v3, block);
  }

  else
  {
    dispatch_sync(v3, block);
  }
}

void sub_1016279B0(uint64_t a1, uint64_t a2, int a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_101627A7C;
  v5[3] = &unk_101F58B80;
  v5[4] = a1;
  v5[5] = a2;
  v6 = a3;
  v7 = v5;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10162C8C4;
  block[3] = &unk_101F590C0;
  block[4] = a1 + 8;
  block[5] = &v7;
  v4 = a1 + 24;
  v3 = *(a1 + 24);
  if (*(v4 + 8))
  {
    dispatch_async_and_wait(v3, block);
  }

  else
  {
    dispatch_sync(v3, block);
  }
}

void sub_101627A8C(uint64_t a1@<X0>, void *a2@<X8>)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_101627BF4;
  v5[3] = &unk_101F58BA0;
  v5[4] = a1;
  v6 = v5;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10162C8EC;
  v7[3] = &unk_101F59140;
  v7[4] = a1 + 8;
  v7[5] = &v6;
  v8 = v7;
  v3 = a1 + 24;
  v2 = *(a1 + 24);
  v4 = a2 + 1;
  if (*(v3 + 8))
  {
    *v4 = 0;
    a2[2] = 0;
    *a2 = v4;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_10162C9A4;
    v12 = &unk_101F59180;
    v13 = a2;
    v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    *v4 = 0;
    a2[2] = 0;
    *a2 = v4;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_10162C900;
    v12 = &unk_101F59160;
    v13 = a2;
    v14 = &v8;
    dispatch_sync(v2, &block);
  }
}

uint64_t sub_101627BF4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v3 = *(a1 + 32);
  a2[2] = 0;
  a2[1] = 0;
  *a2 = a2 + 1;
  result = *(v3 + 64);
  if (result)
  {
    v6[0] = off_101F59880;
    v6[3] = v6;
    v5[0] = off_101F59900;
    v5[1] = v3;
    v5[2] = a2;
    v5[3] = v5;
    sub_10162A964(result, &off_101F58CB8, @"SELECT * from bundle_info ORDER BY bundle_id DESC;", 1, v6, v5);
    sub_10036ED9C(v5);
    return sub_10162E97C(v6);
  }

  return result;
}

void sub_101627CDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, void);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  sub_10036ED9C(va);
  sub_10162E97C(va1);
  sub_100009970(v2, *(v2 + 8));
  _Unwind_Resume(a1);
}

void sub_101627D04(uint64_t a1@<X0>, void *a2@<X8>)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_101627E6C;
  v5[3] = &unk_101F58BC0;
  v5[4] = a1;
  v6 = v5;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10162C8EC;
  v7[3] = &unk_101F59140;
  v7[4] = a1 + 8;
  v7[5] = &v6;
  v8 = v7;
  v3 = a1 + 24;
  v2 = *(a1 + 24);
  v4 = a2 + 1;
  if (*(v3 + 8))
  {
    *v4 = 0;
    a2[2] = 0;
    *a2 = v4;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_10162C9A4;
    v12 = &unk_101F59180;
    v13 = a2;
    v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    *v4 = 0;
    a2[2] = 0;
    *a2 = v4;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_10162C900;
    v12 = &unk_101F59160;
    v13 = a2;
    v14 = &v8;
    dispatch_sync(v2, &block);
  }
}

uint64_t sub_101627E6C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v3 = *(a1 + 32);
  a2[2] = 0;
  a2[1] = 0;
  *a2 = a2 + 1;
  result = *(v3 + 64);
  if (result)
  {
    v6[0] = off_101F59980;
    v6[3] = v6;
    v5[0] = off_101F59A00;
    v5[1] = v3;
    v5[2] = a2;
    v5[3] = v5;
    sub_10162A964(result, &off_101F58CB8, @"SELECT * from bundle_info ORDER BY bundle_id DESC;", 1, v6, v5);
    sub_10036ED9C(v5);
    return sub_10162E97C(v6);
  }

  return result;
}

void sub_101627F54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, void);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  sub_10036ED9C(va);
  sub_10162E97C(va1);
  sub_100009970(v2, *(v2 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_101627F7C(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  *a4 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_1016280F0;
  v7[3] = &unk_101F58BE0;
  v7[4] = a1;
  v7[5] = a2;
  v7[6] = a3;
  v7[7] = a4;
  v8 = v7;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_10162CA48;
  v9[3] = &unk_101F591A0;
  v9[4] = a1 + 8;
  v9[5] = &v8;
  v10 = v9;
  v5 = a1 + 24;
  v4 = *(a1 + 24);
  if (*(v5 + 8))
  {
    v17 = 0;
    block = _NSConcreteStackBlock;
    v12 = 0x40000000;
    v13 = sub_10162CA98;
    v14 = &unk_101F591E0;
    v15 = &v17;
    v16 = &v10;
    dispatch_async_and_wait(v4, &block);
  }

  else
  {
    v17 = 0;
    block = _NSConcreteStackBlock;
    v12 = 0x40000000;
    v13 = sub_10162CA5C;
    v14 = &unk_101F591C0;
    v15 = &v17;
    v16 = &v10;
    dispatch_sync(v4, &block);
  }

  return v17;
}

uint64_t sub_101628100(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v11 = 0;
  if (*(a1 + 64))
  {
    v6 = sub_10162AEAC(a1, a2, a3, &v11);
    if (*(a2 + 23) < 0)
    {
      sub_100005F2C(__p, *a2, *(a2 + 8));
    }

    else
    {
      *__p = *a2;
      v17 = *(a2 + 16);
    }

    v7 = SlotIdFromPersonalityId();
    if (SHIBYTE(v17) < 0)
    {
      operator delete(__p[0]);
      if (v6)
      {
        goto LABEL_10;
      }
    }

    else if (v6)
    {
LABEL_10:
      sub_101627458(a1);
      v13 = 0;
      v14 = v7;
      if (v7)
      {
        v8 = v7 == 3;
      }

      else
      {
        v8 = 1;
      }

      v9 = 3;
      if (v8)
      {
        v9 = 0;
      }

      v12 = v9;
      __p[0] = off_101F59B80;
      __p[1] = &v14;
      v18 = __p;
      v15 = 0;
      operator new();
    }

    sub_10162B198(a1, a2, a3, &v11, 1);
  }

  return v11;
}

void sub_10162850C(uint64_t a1, uint64_t a2)
{
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_1016286A0;
  v7[3] = &unk_101F58C08;
  v7[5] = &v8;
  v7[6] = a1;
  v7[4] = &v12;
  v16 = v7;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10162C8C4;
  block[3] = &unk_101F590C0;
  block[4] = a1 + 8;
  block[5] = &v16;
  v4 = a1 + 24;
  v3 = *(a1 + 24);
  if (*(v4 + 8))
  {
    dispatch_async_and_wait(v3, block);
  }

  else
  {
    dispatch_sync(v3, block);
  }

  v5 = *(v9 + 6);
  if (*(v13 + 6) < v5)
  {
    v6 = *(a2 + 24);
    LODWORD(block[0]) = *(v13 + 6);
    LODWORD(v16) = v5;
    if (!v6)
    {
      sub_100022DB4();
    }

    (*(*v6 + 48))(v6, block, &v16);
  }

  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
}

void sub_10162867C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, void);
  v11 = va_arg(va1, void);
  v12 = va_arg(va1, void);
  v13 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1016286A0(void *a1)
{
  v1 = a1[6];
  v2 = *(a1[4] + 8);
  v3 = *(a1[5] + 8);
  *(v2 + 24) = *(v1 + 74);
  *(v3 + 24) = 5;
  if (*(v2 + 24) > 4)
  {
    v10 = *(v1 + 40);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }

    v11 = 67109120;
    v12 = 5;
    v7 = "#I DataUsage schema is current, not triggering migration: %d";
    v8 = v10;
    v9 = 8;
  }

  else
  {
    *(v1 + 72) = 327687;
    v4 = *(v1 + 40);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }

    v5 = *(v2 + 24);
    v6 = *(v3 + 24);
    v11 = 67109376;
    v12 = v5;
    v13 = 1024;
    v14 = v6;
    v7 = "#I Need to migrate data usage store, old version: %d, new version: %d";
    v8 = v4;
    v9 = 14;
  }

  _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, &v11, v9);
}

const void **sub_1016287D8(uint64_t a1, const void **a2)
{
  v3 = a1 + 8;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  v6[2] = sub_1016288C8;
  v6[3] = &unk_101F58C28;
  v6[4] = a1;
  sub_10005C7A4(&v7, a2);
  v8 = v6;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10162C8C4;
  block[3] = &unk_101F590C0;
  block[4] = v3;
  block[5] = &v8;
  v4 = *(a1 + 24);
  if (*(a1 + 32))
  {
    dispatch_async_and_wait(v4, block);
  }

  else
  {
    dispatch_sync(v4, block);
  }

  return sub_100005978(&v7);
}

void sub_1016288DC(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_1016289A4;
  v4[3] = &unk_101F58C58;
  v4[4] = a1;
  v4[5] = a2;
  v5 = v4;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10162C8C4;
  block[3] = &unk_101F590C0;
  block[4] = a1 + 8;
  block[5] = &v5;
  v3 = a1 + 24;
  v2 = *(a1 + 24);
  if (*(v3 + 8))
  {
    dispatch_async_and_wait(v2, block);
  }

  else
  {
    dispatch_sync(v2, block);
  }
}

const void **sub_1016289A4(uint64_t a1)
{
  v2 = *(a1 + 32);
  v1 = *(a1 + 40);
  if (*(v1 + 23) < 0)
  {
    sub_100005F2C(v7, *v1, *(v1 + 1));
  }

  else
  {
    v3 = *v1;
    v8 = *(v1 + 2);
    *v7 = v3;
  }

  if (SHIBYTE(v8) < 0)
  {
    sub_100005F2C(__p, v7[0], v7[1]);
  }

  else
  {
    *__p = *v7;
    v12 = v8;
  }

  v10 = 0;
  if (SHIBYTE(v12) < 0)
  {
    sub_100005F2C(&__dst, __p[0], __p[1]);
  }

  else
  {
    __dst = *__p;
    v14 = v12;
  }

  v15 = 0;
  if (ctu::cf::convert_copy())
  {
    v4 = v10;
    v10 = v15;
    v16 = v4;
    sub_100005978(&v16);
  }

  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst);
  }

  v5 = v10;
  v9 = v10;
  v10 = 0;
  sub_100005978(&v10);
  if (SHIBYTE(v12) < 0)
  {
    operator delete(__p[0]);
  }

  if (SHIBYTE(v8) < 0)
  {
    operator delete(v7[0]);
  }

  sub_101628B48(*(v2 + 64), v5, @"kCUOSVersion");
  return sub_100005978(&v9);
}

void sub_101628AE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  sub_100005978(&a18);
  if (a24 < 0)
  {
    operator delete(__p);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_101628B48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = off_101F59C80;
  v4[1] = a2;
  v4[2] = a3;
  v4[3] = v4;
  sub_10162BA58(a1, v4);
  return sub_1016308D0(v4);
}

void sub_101628BCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1016308D0(va);
  _Unwind_Resume(a1);
}

void sub_101628BE0(uint64_t a1@<X0>, void *a2@<X8>)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_101628D44;
  v4[3] = &unk_101F58C78;
  v4[4] = a1;
  v5 = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_10162CAD4;
  v6[3] = &unk_101F59200;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  v7 = v6;
  v3 = a1 + 24;
  v2 = *(a1 + 24);
  if (*(v3 + 8))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    v9 = 0x40000000;
    v10 = sub_10162CAE8;
    v11 = &unk_101F59240;
    v12 = a2;
    v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    v9 = 0x40000000;
    v10 = sub_100040FC0;
    v11 = &unk_101F59220;
    v12 = a2;
    v13 = &v7;
    dispatch_sync(v2, &block);
  }
}

const void **sub_101628D44@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v3 = *(*(a1 + 32) + 64);
  v5 = 0;
  sub_101628DD8(&v5, v3);
  v6 = 0uLL;
  v7 = 0;
  ctu::cf::assign();
  *a2 = v6;
  *(a2 + 16) = v7;
  return sub_100005978(&v5);
}

void sub_101628DB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  sub_100005978(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_101628DD8(uint64_t *a1, uint64_t a2)
{
  if (a2)
  {
    result = CPRecordStoreGetDatabase();
    if (result)
    {
      result = CPSqliteDatabaseCopyValueForProperty();
    }
  }

  else
  {
    result = 0;
  }

  *a1 = result;
  return result;
}

uint64_t sub_101628E20(uint64_t a1)
{
  v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10162CB4C;
  v5[3] = &unk_101F59260;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  v6 = v5;
  v2 = a1 + 24;
  v1 = *(a1 + 24);
  if (*(v2 + 8))
  {
    v13 = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_10162CBA0;
    v10 = &unk_101F592A0;
    v11 = &v13;
    v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }

  else
  {
    v13 = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_10162CB64;
    v10 = &unk_101F59280;
    v11 = &v13;
    v12 = &v6;
    dispatch_sync(v1, &block);
  }

  return v13;
}

uint64_t sub_101628F48(uint64_t a1)
{
  if (a1)
  {
    if (CPRecordStoreGetDatabase() && CPSqliteDatabaseConnectionForWriting())
    {
      CPSqliteConnectionBegin();
      v1 = CPSqliteConnectionIntegerForPropertyWithDefaultValue();
      CPSqliteDatabaseReleaseSqliteConnection();
      v2 = v1 != 0;
      if (v1 == -1)
      {
        v2 = 0;
      }

      v3 = v1 != -1;
    }

    else
    {
      v2 = 0;
      v3 = 0;
    }
  }

  else
  {
    v2 = 0;
    v3 = 0;
  }

  return v2 | (v3 << 8);
}

void sub_101628FD8(uint64_t a1, char a2)
{
  v4 = a1;
  v5 = a2;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10162CBDC;
  block[3] = &unk_101F592C0;
  block[4] = a1 + 8;
  block[5] = &v4;
  v3 = a1 + 24;
  v2 = *(a1 + 24);
  if (*(v3 + 8))
  {
    dispatch_async_and_wait(v2, block);
  }

  else
  {
    dispatch_sync(v2, block);
  }
}

uint64_t sub_101629064(uint64_t a1, unsigned int a2, uint64_t a3)
{
  v4[0] = off_101F59D10;
  v4[1] = a2;
  v4[2] = a3;
  v4[3] = v4;
  sub_10162BA58(a1, v4);
  return sub_1016308D0(v4);
}

void sub_1016290EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1016308D0(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101629100(uint64_t a1)
{
  v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10162CBF8;
  v5[3] = &unk_101F592E0;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  v6 = v5;
  v2 = a1 + 24;
  v1 = *(a1 + 24);
  if (*(v2 + 8))
  {
    v13 = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_10162CBA0;
    v10 = &unk_101F592A0;
    v11 = &v13;
    v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }

  else
  {
    v13 = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_10162CB64;
    v10 = &unk_101F59280;
    v11 = &v13;
    v12 = &v6;
    dispatch_sync(v1, &block);
  }

  return v13;
}

void sub_101629228(uint64_t a1, char a2)
{
  v4 = a1;
  v5 = a2;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10162CC10;
  block[3] = &unk_101F59300;
  block[4] = a1 + 8;
  block[5] = &v4;
  v3 = a1 + 24;
  v2 = *(a1 + 24);
  if (*(v3 + 8))
  {
    dispatch_async_and_wait(v2, block);
  }

  else
  {
    dispatch_sync(v2, block);
  }
}

uint64_t sub_1016292B4(uint64_t a1, int a2)
{
  v5 = a1;
  v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10162CC2C;
  v7[3] = &unk_101F59320;
  v7[4] = a1 + 8;
  v7[5] = &v5;
  v8 = v7;
  v3 = a1 + 24;
  v2 = *(a1 + 24);
  if (*(v3 + 8))
  {
    v15 = 0;
    v16 = 0;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_10162CE5C;
    v12 = &unk_101F59360;
    v13 = &v15;
    v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    v15 = 0;
    v16 = 0;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_10162CE20;
    v12 = &unk_101F59340;
    v13 = &v15;
    v14 = &v8;
    dispatch_sync(v2, &block);
  }

  return v15;
}

uint64_t sub_1016293E4(void *a1, uint64_t a2, int a3)
{
  v4 = a3;
  *a1 = 0;
  v6[0] = off_101F59D90;
  v6[1] = &v4;
  v6[3] = v6;
  v5[0] = off_101F59E10;
  v5[1] = a1;
  v5[3] = v5;
  sub_10162A964(a2, &off_101F58D50, @"SELECT * from subscriber_info WHERE (tag == ?) ORDER BY last_update_time DESC;", 0, v6, v5);
  sub_10036ED9C(v5);
  return sub_10162E97C(v6);
}

void sub_1016294C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, void);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  sub_10036ED9C(va);
  sub_10162E97C(va1);
  sub_10000A1EC(v2);
  _Unwind_Resume(a1);
}

void sub_1016294E8(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

const void **sub_1016295EC(uint64_t a1, uint64_t a2, const void *a3)
{
  v7 = 0;
  valuePtr = a3;
  v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v3)
  {
    v7 = v3;
    valuePtr = 0;
    sub_100029A48(&valuePtr);
    v4 = v7;
  }

  else
  {
    v4 = 0;
  }

  v6 = v4;
  v7 = 0;
  sub_100029A48(&v7);
  CPRecordSetProperty();
  return sub_100029A48(&v6);
}

void sub_10162968C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100029A48(va);
  _Unwind_Resume(a1);
}

uint64_t sub_1016296AC(uint64_t a1, int a2)
{
  v5 = a1;
  v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10162D000;
  v7[3] = &unk_101F59380;
  v7[4] = a1 + 8;
  v7[5] = &v5;
  v8 = v7;
  v3 = a1 + 24;
  v2 = *(a1 + 24);
  if (*(v3 + 8))
  {
    v15 = 0;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_10162D1D0;
    v12 = &unk_101F593C0;
    v13 = &v15;
    v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    v15 = 0;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_10162D194;
    v12 = &unk_101F593A0;
    v13 = &v15;
    v14 = &v8;
    dispatch_sync(v2, &block);
  }

  return v15;
}

void sub_1016297DC(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

const void **sub_1016298D0(uint64_t a1, uint64_t a2, int a3)
{
  v7 = 0;
  LODWORD(valuePtr) = a3;
  v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v3)
  {
    v7 = v3;
    valuePtr = 0;
    sub_100029A48(&valuePtr);
    v4 = v7;
  }

  else
  {
    v4 = 0;
  }

  v6 = v4;
  v7 = 0;
  sub_100029A48(&v7);
  CPRecordSetProperty();
  return sub_100029A48(&v6);
}

void sub_101629970(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100029A48(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101629990(uint64_t a1, uint64_t a2)
{
  v3 = a1 + 8;
  v7 = a1;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    v9 = *(a2 + 16);
  }

  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_10162D358;
  v10[3] = &unk_101F593E0;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = v10;
  v4 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 0x40000000;
    v14 = sub_10162CBA0;
    v15 = &unk_101F592A0;
    v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }

  else
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 0x40000000;
    v14 = sub_10162CB64;
    v15 = &unk_101F59280;
    v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }

  v5 = v18;
  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }

  return v5;
}

void sub_101629B0C(uint64_t a1, uint64_t a2, __int16 a3)
{
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    __p[2] = *(a2 + 16);
  }

  v7 = a3;
  v5 = *(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_101629C70(uint64_t a1, uint64_t a2)
{
  v3 = a1 + 8;
  v7 = a1;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    v9 = *(a2 + 16);
  }

  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_10162D6B8;
  v10[3] = &unk_101F59400;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = v10;
  v4 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 0x40000000;
    v14 = sub_10162CBA0;
    v15 = &unk_101F592A0;
    v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }

  else
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 0x40000000;
    v14 = sub_10162CB64;
    v15 = &unk_101F59280;
    v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }

  v5 = v18;
  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }

  return v5;
}

void sub_101629DEC(uint64_t a1, uint64_t a2, __int16 a3)
{
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    __p[2] = *(a2 + 16);
  }

  v7 = a3;
  v5 = *(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_101629F50(uint64_t a1, uint64_t a2)
{
  v3 = a1 + 8;
  v7 = a1;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    v9 = *(a2 + 16);
  }

  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_10162DA24;
  v10[3] = &unk_101F59420;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = v10;
  v4 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 0x40000000;
    v14 = sub_10162CBA0;
    v15 = &unk_101F592A0;
    v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }

  else
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 0x40000000;
    v14 = sub_10162CB64;
    v15 = &unk_101F59280;
    v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }

  v5 = v18;
  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }

  return v5;
}

void sub_10162A0CC(uint64_t a1, uint64_t a2, __int16 a3)
{
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    __p[2] = *(a2 + 16);
  }

  v7 = a3;
  v5 = *(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_10162A230(uint64_t a1, uint64_t a2)
{
  v3 = a1 + 8;
  v7 = a1;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    v9 = *(a2 + 16);
  }

  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_10162DD90;
  v10[3] = &unk_101F59440;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = v10;
  v4 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 0x40000000;
    v14 = sub_10162CBA0;
    v15 = &unk_101F592A0;
    v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }

  else
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 0x40000000;
    v14 = sub_10162CB64;
    v15 = &unk_101F59280;
    v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }

  v5 = v18;
  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }

  return v5;
}

void sub_10162A3AC(uint64_t a1, uint64_t a2, __int16 a3)
{
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    __p[2] = *(a2 + 16);
  }

  v7 = a3;
  v5 = *(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_10162A510(uint64_t a1, uint64_t a2)
{
  v3 = a1 + 8;
  v7 = a1;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    v9 = *(a2 + 16);
  }

  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_10162E0FC;
  v10[3] = &unk_101F59460;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = v10;
  v4 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 0x40000000;
    v14 = sub_10162CBA0;
    v15 = &unk_101F592A0;
    v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }

  else
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 0x40000000;
    v14 = sub_10162CB64;
    v15 = &unk_101F59280;
    v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }

  v5 = v18;
  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }

  return v5;
}

void sub_10162A68C(uint64_t a1, uint64_t a2, char a3)
{
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    __p[2] = *(a2 + 16);
  }

  v7 = a3;
  v5 = *(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_10162A7F0(uint64_t a1@<X0>, void *a2@<X8>)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10162A94C;
  v4[3] = &unk_101F58C98;
  v4[4] = a1;
  v5 = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_10162E808;
  v6[3] = &unk_101F59500;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  v7 = v6;
  v3 = a1 + 24;
  v2 = *(a1 + 24);
  if (*(v3 + 8))
  {
    *a2 = 0;
    block = _NSConcreteStackBlock;
    v9 = 0x40000000;
    v10 = sub_10162E81C;
    v11 = &unk_101F59540;
    v12 = a2;
    v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    *a2 = 0;
    block = _NSConcreteStackBlock;
    v9 = 0x40000000;
    v10 = sub_1000645F0;
    v11 = &unk_101F59520;
    v12 = a2;
    v13 = &v7;
    dispatch_sync(v2, &block);
  }
}

uint64_t sub_10162A964(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  result = CPRecordStoreGetDatabase();
  if (result)
  {
    result = a4 ? CPSqliteDatabaseStatementForReading() : CPSqliteDatabaseStatementForWriting();
    v10 = result;
    if (result)
    {
      if (*(result + 8))
      {
        v11 = *(a5 + 24);
        v13 = v10;
        if (!v11)
        {
          sub_100022DB4();
        }

        (*(*v11 + 48))(v11, &v13);
        v12 = CPRecordStoreProcessStatement();
        v13 = v12;
        if (v12)
        {
          sub_100372C3C(a6, v12);
        }

        CPSqliteStatementReset();
        sub_100010250(&v13);
      }

      return CPSqliteDatabaseReleaseSqliteStatement();
    }
  }

  return result;
}

void sub_10162AA58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100010250(va);
  _Unwind_Resume(a1);
}

uint64_t sub_10162AA6C(uint64_t result, uint64_t a2, int a3)
{
  if (*(result + 64))
  {
    v6 = 0;
    if (a3 == 2)
    {
      v3 = 4;
    }

    else
    {
      if (a3)
      {
        goto LABEL_7;
      }

      v3 = 16;
    }

    v6 = v3;
LABEL_7:
    v5 = 20;
    v4 = 1;
    v8[0] = off_101F59680;
    v8[1] = a2;
    v8[3] = v8;
    v7 = 0;
    operator new();
  }

  return result;
}

void sub_10162AC60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, void);
  v9 = va_arg(va1, void);
  v10 = va_arg(va1, void);
  v11 = va_arg(va1, void);
  sub_10036ED9C(va);
  sub_10162E97C(va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10162AC8C(uint64_t result, uint64_t a2, int a3)
{
  if (*(result + 64))
  {
    v6 = 0;
    if (a3 == 2)
    {
      v3 = 8;
    }

    else
    {
      if (a3)
      {
        goto LABEL_7;
      }

      v3 = 32;
    }

    v6 = v3;
LABEL_7:
    v5 = 40;
    v4 = 1;
    v8[0] = off_101F59780;
    v8[1] = a2;
    v8[3] = v8;
    v7 = 0;
    operator new();
  }

  return result;
}

void sub_10162AE80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, void);
  v9 = va_arg(va1, void);
  v10 = va_arg(va1, void);
  v11 = va_arg(va1, void);
  sub_10036ED9C(va);
  sub_10162E97C(va1);
  _Unwind_Resume(a1);
}

BOOL sub_10162AEAC(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  v19 = 0;
  sub_10162B040(&v19, a1, a2, a3);
  v8 = v19;
  if (v19)
  {
    Property = CPRecordGetProperty();
    v11 = Property;
    if (Property)
    {
      v12 = CFGetTypeID(Property);
      v13 = v12 == CFNumberGetTypeID() ? v11 : 0;
    }

    else
    {
      v13 = 0;
    }

    *buf = 0;
    ctu::cf::assign(buf, v13, v10);
    v14 = *buf;
    *a4 = *buf;
    v15 = *(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      if (*(a2 + 23) >= 0)
      {
        v16 = a2;
      }

      else
      {
        v16 = *a2;
      }

      if (*(a3 + 23) >= 0)
      {
        v17 = a3;
      }

      else
      {
        v17 = *a3;
      }

      *buf = 136315650;
      v21 = v16;
      v22 = 2080;
      v23 = v17;
      v24 = 1024;
      v25 = v14;
      _os_log_impl(&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Subscriber %s and mdn %s have tag %u", buf, 0x1Cu);
    }
  }

  sub_10000A1EC(&v19);
  return v8 != 0;
}

void *sub_10162B040(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *result = 0;
  v4 = *(a4 + 23);
  if ((v4 & 0x80u) != 0)
  {
    v4 = *(a4 + 8);
  }

  if (v4)
  {
    v6[0] = off_101F59E90;
    v6[1] = a3;
    v6[2] = a4;
    v6[3] = v6;
    v5 = 0;
    operator new();
  }

  return result;
}

void sub_10162B16C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, void);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  sub_10036ED9C(va);
  sub_10162E97C(va1);
  sub_10000A1EC(v2);
  _Unwind_Resume(a1);
}

void sub_10162B198(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  v12 = a5;
  v11 = 0;
  v10 = 0;
  v7 = *(a3 + 23);
  if ((v7 & 0x80u) != 0)
  {
    v7 = *(a3 + 8);
  }

  if (!v7)
  {
    v8 = *(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *v9 = 0;
      _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Subscriber mdn is empty", v9, 2u);
    }
  }

  v14[0] = off_101F59A80;
  v14[1] = a2;
  v14[2] = a3;
  v14[3] = v14;
  v13 = 0;
  operator new();
}

const void **sub_10162B384(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(a3 + 23) < 0)
  {
    sub_100005F2C(v5, *a3, *(a3 + 8));
  }

  else
  {
    *v5 = *a3;
    v6 = *(a3 + 16);
  }

  if (SHIBYTE(v6) < 0)
  {
    sub_100005F2C(__dst, v5[0], v5[1]);
  }

  else
  {
    *__dst = *v5;
    v10 = v6;
  }

  v8 = 0;
  if (SHIBYTE(v10) < 0)
  {
    sub_100005F2C(__p, __dst[0], __dst[1]);
  }

  else
  {
    *__p = *__dst;
    v12 = v10;
  }

  v13 = 0;
  if (ctu::cf::convert_copy())
  {
    v3 = v8;
    v8 = v13;
    v14 = v3;
    sub_100005978(&v14);
  }

  if (SHIBYTE(v12) < 0)
  {
    operator delete(__p[0]);
  }

  v7 = v8;
  v8 = 0;
  sub_100005978(&v8);
  if (SHIBYTE(v10) < 0)
  {
    operator delete(__dst[0]);
  }

  if (SHIBYTE(v6) < 0)
  {
    operator delete(v5[0]);
  }

  CPRecordSetProperty();
  return sub_100005978(&v7);
}

void sub_10162B4D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, void *a26, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
  sub_100005978(&a18);
  if (a24 < 0)
  {
    operator delete(__p);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

const void **sub_10162B53C(double a1)
{
  v5 = 0;
  valuePtr = *&a1;
  v1 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
  if (v1)
  {
    v5 = v1;
    valuePtr = 0;
    sub_100029A48(&valuePtr);
    v2 = v5;
  }

  else
  {
    v2 = 0;
  }

  v4 = v2;
  v5 = 0;
  sub_100029A48(&v5);
  CPRecordSetProperty();
  return sub_100029A48(&v4);
}

void sub_10162B5C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100029A48(va);
  _Unwind_Resume(a1);
}

void sub_10162B5E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __p[0] = 0;
  __p[1] = 0;
  v22 = 0;
  if (*(a3 + 23) < 0)
  {
    sub_100005F2C(__p, *a3, *(a3 + 8));
  }

  else
  {
    *__p = *a3;
    v22 = *(a3 + 16);
  }

  v19 = 0;
  v20 = 0;
  ServiceMap = Registry::getServiceMap(*(a2 + 48));
  v7 = ServiceMap;
  if (v8 < 0)
  {
    v9 = (v8 & 0x7FFFFFFFFFFFFFFFLL);
    v10 = 5381;
    do
    {
      v8 = v10;
      v11 = *v9++;
      v10 = (33 * v10) ^ v11;
    }

    while (v11);
  }

  std::mutex::lock(ServiceMap);
  *buf = v8;
  v12 = sub_100009510(&v7[1].__m_.__sig, buf);
  if (v12)
  {
    v14 = v12[3];
    v13 = v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v13);
      v15 = 0;
      goto LABEL_12;
    }
  }

  else
  {
    v14 = 0;
  }

  std::mutex::unlock(v7);
  v13 = 0;
  v15 = 1;
LABEL_12:
  (**v14)(&v19, v14, __p);
  if ((v15 & 1) == 0)
  {
    sub_100004A34(v13);
  }

  if (v19)
  {
    if (*(v19 + 95) < 0)
    {
      sub_100005F2C(a1, *(v19 + 72), *(v19 + 80));
    }

    else
    {
      v16 = *(v19 + 72);
      *(a1 + 16) = *(v19 + 88);
      *a1 = v16;
    }
  }

  else
  {
    v17 = *(a2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      if (*(a3 + 23) >= 0)
      {
        v18 = a3;
      }

      else
      {
        v18 = *a3;
      }

      *buf = 136315138;
      *&buf[4] = v18;
      _os_log_error_impl(&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "No personality info for %s", buf, 0xCu);
    }

    *a1 = 0;
    *(a1 + 8) = 0;
    *(a1 + 16) = 0;
  }

  if (v20)
  {
    sub_100004A34(v20);
  }

  if (SHIBYTE(v22) < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_10162B818(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  if (a16 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10162B870(uint64_t a1, uint64_t a2)
{
  v8 = 0;
  if (!sub_10162B9C0(a1, a2, &v8))
  {
    memset(__p, 0, sizeof(__p));
    sub_10162B5E8(__p, a1, a2);
    v4 = sub_101628100(a1, a2, __p);
    if (SHIBYTE(__p[2]) < 0)
    {
      operator delete(__p[0]);
    }

    v8 = v4;
    v5 = *(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*(a2 + 23) >= 0)
      {
        v6 = a2;
      }

      else
      {
        v6 = *a2;
      }

      LODWORD(__p[0]) = 136315650;
      *(__p + 4) = v6;
      WORD2(__p[1]) = 1024;
      *(&__p[1] + 6) = v4;
      WORD1(__p[2]) = 1024;
      HIDWORD(__p[2]) = 0;
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Could not find tag for %s.  Added a new one (%d) based on subscriber id only at the expense of tag %d", __p, 0x18u);
    }
  }

  return v8;
}

void sub_10162B99C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

BOOL sub_10162B9C0(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  __p[0] = 0;
  __p[1] = 0;
  v9 = 0;
  sub_10162B5E8(__p, a1, a2);
  v6 = sub_10162776C(a1, a2, __p, a3);
  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }

  return v6;
}

void sub_10162BA3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10162BA58(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (*(a2 + 24))
    {
      result = CPRecordStoreGetDatabase();
      if (result)
      {
        result = CPSqliteDatabaseConnectionForWriting();
        if (result)
        {
          v3 = result;
          CPSqliteConnectionBegin();
          v4 = *(a2 + 24);
          v5 = v3;
          if (!v4)
          {
            sub_100022DB4();
          }

          (*(*v4 + 48))(v4, &v5);
          CPSqliteConnectionCommit();

          return CPSqliteDatabaseReleaseSqliteConnection();
        }
      }
    }
  }

  return result;
}

void sub_10162BB08(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  v4[0] = off_101F59F90;
  v4[1] = a3;
  v4[3] = v4;
  v3 = 0;
  operator new();
}

void sub_10162BC0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, void);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  sub_10036ED9C(va);
  sub_10162E97C(va1);
  sub_10000A1EC(v2);
  _Unwind_Resume(a1);
}

const void **sub_10162BC38(uint64_t a1, uint64_t a2)
{
  v4 = *(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(a2 + 23) >= 0)
    {
      v5 = a2;
    }

    else
    {
      v5 = *a2;
    }

    v6 = a2 + 24;
    if (*(a2 + 47) < 0)
    {
      v6 = *(a2 + 24);
    }

    v7 = a2 + 48;
    if (*(a2 + 71) < 0)
    {
      v7 = *(a2 + 48);
    }

    *buf = 136381187;
    *&buf[4] = v5;
    *&buf[12] = 2081;
    *&buf[14] = v6;
    *&buf[22] = 2081;
    v53 = v7;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Plan Transfer from %{private}s to %{private}s with mdn %{private}s", buf, 0x20u);
  }

  v49 = 0;
  sub_10162B040(&v49, a1, a2, a2 + 48);
  if (!v49)
  {
    sub_10162BB08(&__p, a1, a2);
  }

  v48 = 0;
  sub_10162B040(&v48, a1, a2 + 24, a2 + 48);
  v8 = *(a2 + 71);
  v9 = v8;
  if ((v8 & 0x80u) != 0)
  {
    v8 = *(a2 + 56);
  }

  if (v8)
  {
    v10 = v48 == 0;
  }

  else
  {
    v10 = 1;
  }

  v11 = !v10;
  v44 = v11;
  if (v10)
  {
    v20 = -1;
  }

  else
  {
    v12 = *(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      if (*(a2 + 47) >= 0)
      {
        v13 = a2 + 24;
      }

      else
      {
        v13 = *(a2 + 24);
      }

      v14 = *(a2 + 48);
      if (v9 >= 0)
      {
        v14 = a2 + 48;
      }

      *buf = 136380931;
      *&buf[4] = v13;
      *&buf[12] = 2081;
      *&buf[14] = v14;
      _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Exact match for plan transfer with to subscriberId %{private}s and phone number %{private}s exists.  Removing.", buf, 0x16u);
    }

    Property = CPRecordGetProperty();
    v17 = Property;
    if (Property)
    {
      v18 = CFGetTypeID(Property);
      if (v18 == CFNumberGetTypeID())
      {
        v19 = v17;
      }

      else
      {
        v19 = 0;
      }
    }

    else
    {
      v19 = 0;
    }

    *buf = 0;
    ctu::cf::assign(buf, v19, v16);
    v20 = *buf;
    CPRecordStoreRemoveRecord();
  }

  __p = 0;
  v47 = 0uLL;
  v21 = CPRecordGetProperty();
  if (v21)
  {
    CFGetTypeID(v21);
    CFStringGetTypeID();
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    *(&v47 + 7) = *&buf[15];
    v23 = *buf;
    v22 = *&buf[8];
    v24 = buf[23];
    __p = *buf;
    *&v47 = *&buf[8];
    HIBYTE(v47) = buf[23];
  }

  else
  {
    v23 = 0;
    v22 = 0;
    v24 = 0;
  }

  v25 = v24;
  if ((v24 & 0x80u) == 0)
  {
    v26 = v24;
  }

  else
  {
    v26 = v22;
  }

  if (!v26)
  {
    v51 = 0;
    sub_10162BB08(&v51, a1, a2 + 24);
  }

  sub_10162B384(v49, 0, a2 + 24);
  v27 = *(a2 + 71);
  v28 = v27;
  if ((v27 & 0x80u) != 0)
  {
    v27 = *(a2 + 56);
  }

  if (v26 != v27 || (v25 >= 0 ? (p_p = &__p) : (p_p = v23), v28 >= 0 ? (v30 = (a2 + 48)) : (v30 = *(a2 + 48)), memcmp(p_p, v30, v26)))
  {
    sub_10162B384(v49, 1, a2 + 48);
  }

  v31 = *(a1 + 40);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    if (*(a2 + 23) >= 0)
    {
      v32 = a2;
    }

    else
    {
      v32 = *a2;
    }

    v33 = &__p;
    if (v25 < 0)
    {
      v33 = v23;
    }

    if (*(a2 + 47) >= 0)
    {
      v34 = a2 + 24;
    }

    else
    {
      v34 = *(a2 + 24);
    }

    if (*(a2 + 71) >= 0)
    {
      v35 = a2 + 48;
    }

    else
    {
      v35 = *(a2 + 48);
    }

    *buf = 136381443;
    *&buf[4] = v32;
    *&buf[12] = 2081;
    *&buf[14] = v33;
    *&buf[22] = 2081;
    v53 = v34;
    v54 = 2081;
    v55 = v35;
    _os_log_impl(&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Record transferred from %{private}s %{private}s to %{private}s %{private}s", buf, 0x2Au);
  }

  Current = CFAbsoluteTimeGetCurrent();
  sub_10162B53C(Current);
  if (v44)
  {
    v37 = CPRecordGetProperty();
    v39 = v37;
    if (v37)
    {
      v40 = CFGetTypeID(v37);
      if (v40 == CFNumberGetTypeID())
      {
        v41 = v39;
      }

      else
      {
        v41 = 0;
      }
    }

    else
    {
      v41 = 0;
    }

    *buf = 0;
    ctu::cf::assign(buf, v41, v38);
    if (v20 == *buf)
    {
      v42 = *(a1 + 40);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 67109120;
        *&buf[4] = v20;
        _os_log_impl(&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#N Tag to rectify is equal to replacement tag %u", buf, 8u);
      }
    }

    else
    {
      v45[0] = v20;
      v45[1] = *buf;
      v51 = 0;
      sub_100F533BC(v45, &v51);
      sub_10000501C(buf, "/cc/events/rectify_tag");
      object = v51;
      v51 = xpc_null_create();
      ctu::RestModule::sendEvent();
      xpc_release(object);
      object = 0;
      if (buf[23] < 0)
      {
        operator delete(*buf);
      }

      xpc_release(v51);
    }
  }

  sub_101627458(a1);
  if (SHIBYTE(v47) < 0)
  {
    operator delete(__p);
  }

  sub_10000A1EC(&v48);
  return sub_10000A1EC(&v49);
}

void sub_10162C26C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, const void *a18, const void *a19, xpc_object_t object, xpc_object_t a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  sub_10000A1EC(&a21);
  if (a17 < 0)
  {
    operator delete(__p);
  }

  sub_10000A1EC(&a18);
  sub_10000A1EC(&a19);
  _Unwind_Resume(a1);
}

void sub_10162C348(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10162C39C(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10162C3DC(uint64_t result)
{
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t sub_10162C418(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 48);
  *(result + 40) = *(a2 + 40);
  *(result + 48) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_10162C434(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (v1)
  {
    sub_100004A34(v1);
  }
}

void sub_10162C444(ServiceManager::Service *this)
{
  *this = off_101F58FF0;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10162C4A0(ServiceManager::Service *this)
{
  *this = off_101F58FF0;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_10162C520@<X0>(void *a1@<X8>)
{
  v2 = 1;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  return sub_1000FF040(a1, &v2, &vars0, 1);
}

void sub_10162C564(uint64_t a1, dispatch_object_t *a2)
{
  v2 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v2);
    dispatch_group_leave(v2);

    dispatch_release(v2);
  }
}

void sub_10162C5DC(uint64_t a1)
{
  v1 = *(*(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_10162C6BC(uint64_t a1, int a2, ServiceStage *this)
{
  v3 = *(a1 + 8);
  ServiceStage::holdOffStage(&group[1], this);
  v4 = *(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_10162C7E4(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v3);
  v2 = *(a1 + 32);
  sub_100071A6C(v2);
  *v2 = v3;
  *(v2 + 16) = v4;
  v3 = 0uLL;
  v4 = 0;
  v5 = &v3;
  sub_1000087B4(&v5);
}

void sub_10162C854(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v3);
  v2 = *(a1 + 32);
  sub_100071A6C(v2);
  *v2 = v3;
  *(v2 + 16) = v4;
  v3 = 0uLL;
  v4 = 0;
  v5 = &v3;
  sub_1000087B4(&v5);
}

void sub_10162C900(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v7);
  v2 = *(a1 + 32);
  v3 = v2 + 8;
  sub_100009970(v2, *(v2 + 8));
  v4 = v9;
  *v2 = v7;
  v5 = v8;
  *(v2 + 8) = v8;
  *(v2 + 16) = v4;
  if (v4)
  {
    v6 = 0;
    *(v5 + 2) = v3;
    v7 = &v8;
    v8 = 0;
    v9 = 0;
  }

  else
  {
    *v2 = v3;
    v6 = v8;
  }

  sub_100009970(&v7, v6);
}

void sub_10162C9A4(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v7);
  v2 = *(a1 + 32);
  v3 = v2 + 8;
  sub_100009970(v2, *(v2 + 8));
  v4 = v9;
  *v2 = v7;
  v5 = v8;
  *(v2 + 8) = v8;
  *(v2 + 16) = v4;
  if (v4)
  {
    v6 = 0;
    *(v5 + 2) = v3;
    v7 = &v8;
    v8 = 0;
    v9 = 0;
  }

  else
  {
    *v2 = v3;
    v6 = v8;
  }

  sub_100009970(&v7, v6);
}

uint64_t sub_10162CA5C(uint64_t a1)
{
  result = (*(**(a1 + 40) + 16))();
  **(a1 + 32) = result;
  return result;
}

uint64_t sub_10162CA98(uint64_t a1)
{
  result = (*(**(a1 + 40) + 16))();
  **(a1 + 32) = result;
  return result;
}

__n128 sub_10162CAE8(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v4);
  v2 = *(a1 + 32);
  if (*(v2 + 23) < 0)
  {
    operator delete(*v2);
  }

  result = v4;
  *(v2 + 16) = v5;
  *v2 = result;
  return result;
}

uint64_t sub_10162CB64(uint64_t a1)
{
  result = (*(**(a1 + 40) + 16))();
  **(a1 + 32) = result;
  return result;
}

uint64_t sub_10162CBA0(uint64_t a1)
{
  result = (*(**(a1 + 40) + 16))();
  **(a1 + 32) = result;
  return result;
}

uint64_t sub_10162CC2C(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v3 = *(v1 + 2);
  v19 = 0;
  sub_1016293E4(&v19, *(v2 + 64), v3);
  if (v19)
  {
    Property = CPRecordGetProperty();
    v6 = Property;
    if (Property)
    {
      v7 = CFGetTypeID(Property);
      if (v7 == CFNumberGetTypeID())
      {
        v8 = v6;
      }

      else
      {
        v8 = 0;
      }
    }

    else
    {
      v8 = 0;
    }

    *buf = 0;
    ctu::cf::assign(buf, v8, v5);
    v10 = *buf;
    v11 = CPRecordGetProperty();
    v13 = v11;
    if (v11)
    {
      v14 = CFGetTypeID(v11);
      if (v14 == CFNumberGetTypeID())
      {
        v15 = v13;
      }

      else
      {
        v15 = 0;
      }
    }

    else
    {
      v15 = 0;
    }

    *buf = 0;
    ctu::cf::assign(buf, v15, v12);
    v16 = *buf;
    v17 = *(v2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 134218496;
      *&buf[4] = v10;
      v21 = 2048;
      v22 = v16;
      v23 = 1024;
      v24 = v3;
      _os_log_impl(&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I home budget %llu roaming budget %llu for tag: %u", buf, 0x1Cu);
    }
  }

  else
  {
    v9 = *(v2 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *buf = 67109120;
      *&buf[4] = v3;
      _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not find tag %u when getting user entered budget", buf, 8u);
    }

    v10 = 0;
  }

  sub_10000A1EC(&v19);
  return v10;
}

uint64_t sub_10162CE20(uint64_t a1)
{
  result = (*(**(a1 + 40) + 16))();
  v3 = *(a1 + 32);
  *v3 = result;
  v3[1] = v4;
  return result;
}

uint64_t sub_10162CE5C(uint64_t a1)
{
  result = (*(**(a1 + 40) + 16))();
  v3 = *(a1 + 32);
  *v3 = result;
  v3[1] = v4;
  return result;
}

void sub_10162CE98(uint64_t **a1)
{
  v1 = **a1;
  v2 = (*a1)[1];
  v3 = (*a1)[2];
  v4 = *(*a1 + 6);
  v6 = 0;
  sub_1016293E4(&v6, *(v1 + 64), v4);
  if (v6)
  {
    sub_1016295EC(v6, 5, v2);
    sub_1016295EC(v6, 6, v3);
    sub_101627458(v1);
  }

  else
  {
    v5 = *(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *buf = 67109120;
      v8 = v4;
      _os_log_error_impl(&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find tag %u when setting user entered budget", buf, 8u);
    }
  }

  sub_10000A1EC(&v6);
  operator delete();
}

uint64_t sub_10162D000(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v3 = *(v1 + 2);
  v13 = 0;
  sub_1016293E4(&v13, *(v2 + 64), v3);
  if (v13)
  {
    Property = CPRecordGetProperty();
    v6 = Property;
    if (Property)
    {
      v7 = CFGetTypeID(Property);
      if (v7 == CFNumberGetTypeID())
      {
        v8 = v6;
      }

      else
      {
        v8 = 0;
      }
    }

    else
    {
      v8 = 0;
    }

    *buf = 0;
    ctu::cf::assign(buf, v8, v5);
    v10 = *buf;
    v11 = *(v2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 67109376;
      v15 = v10;
      v16 = 1024;
      v17 = v3;
      _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I user entered billing end day of month %d for tag: %u", buf, 0xEu);
    }
  }

  else
  {
    v9 = *(v2 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *buf = 67109120;
      v15 = v3;
      _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not find tag %u when getting user entered billing end day of the month", buf, 8u);
    }

    v10 = 0xFFFFFFFFLL;
  }

  sub_10000A1EC(&v13);
  return v10;
}

uint64_t sub_10162D194(uint64_t a1)
{
  result = (*(**(a1 + 40) + 16))();
  **(a1 + 32) = result;
  return result;
}

uint64_t sub_10162D1D0(uint64_t a1)
{
  result = (*(**(a1 + 40) + 16))();
  **(a1 + 32) = result;
  return result;
}

void sub_10162D20C(uint64_t **a1)
{
  v1 = **a1;
  v3 = *(*a1 + 2);
  v2 = *(*a1 + 3);
  v5 = 0;
  sub_1016293E4(&v5, *(v1 + 64), v2);
  if (v5)
  {
    sub_1016298D0(v5, 7, v3);
    sub_101627458(v1);
  }

  else
  {
    v4 = *(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *buf = 67109120;
      v7 = v2;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find tag %u when setting user entered billing end day of the month", buf, 8u);
    }
  }

  sub_10000A1EC(&v5);
  operator delete();
}

uint64_t sub_10162D358(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v16 = 0;
  if (sub_10162B9C0(v2, (v1 + 1), &v16))
  {
    v3 = v16;
    v17 = 0;
    sub_1016293E4(&v17, *(v2 + 64), v16);
    if (v17)
    {
      Property = CPRecordGetProperty();
      v5 = Property;
      if (Property)
      {
        v6 = CFGetTypeID(Property);
        if (v6 == CFNumberGetTypeID())
        {
          v8 = v5;
        }

        else
        {
          v8 = 0;
        }

        *buf = 0;
        ctu::cf::assign(buf, v8, v7);
        v9 = *buf;
        v10 = *buf != 0;
        v11 = *(v2 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 67109376;
          v19 = v9 != 0;
          v20 = 1024;
          v21 = v3;
          _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Low data mode %d for tag: %u", buf, 0xEu);
        }

        v12 = 1;
        goto LABEL_16;
      }

      v14 = *(v2 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 67109120;
        v19 = v3;
        _os_log_impl(&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Low data mode not stored for tag: %u", buf, 8u);
      }
    }

    else
    {
      v13 = *(v2 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *buf = 67109120;
        v19 = v3;
        _os_log_error_impl(&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when getting low data mode", buf, 8u);
      }
    }

    v12 = 0;
    v10 = 0;
LABEL_16:
    sub_10000A1EC(&v17);
    return v10 | (v12 << 8);
  }

  v12 = 0;
  v10 = 0;
  return v10 | (v12 << 8);
}

void sub_10162D548(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10000A1EC(va);
  _Unwind_Resume(a1);
}

uint64_t *sub_10162D568(uint64_t *a1)
{
  v1 = *a1;
  v7 = a1;
  v8 = v1;
  v2 = *v1;
  v3 = sub_10162B870(*v1, v1 + 8);
  v4 = *(v1 + 32);
  v9 = 0;
  sub_1016293E4(&v9, *(v2 + 64), v3);
  if (v9)
  {
    if ((v4 & 0x100) != 0)
    {
      sub_1016298D0(v9, 8, v4);
    }

    else
    {
      CPRecordSetProperty();
    }

    sub_101627458(v2);
  }

  else
  {
    v5 = *(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *buf = 67109120;
      v11 = v3;
      _os_log_error_impl(&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when setting low power mode", buf, 8u);
    }
  }

  sub_10000A1EC(&v9);
  sub_1008B8BD0(&v8);
  return sub_1000049E0(&v7);
}

void sub_10162D68C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  va_copy(va2, va1);
  v5 = va_arg(va2, void);
  sub_10000A1EC(va2);
  sub_1008B8BD0(va1);
  sub_1000049E0(va);
  _Unwind_Resume(a1);
}

uint64_t sub_10162D6B8(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v16 = 0;
  if (sub_10162B9C0(v2, (v1 + 1), &v16))
  {
    v15 = 0;
    sub_1016293E4(&v15, *(v2 + 64), v16);
    if (v15)
    {
      Property = CPRecordGetProperty();
      v4 = Property;
      if (Property)
      {
        v5 = CFGetTypeID(Property);
        if (v5 == CFNumberGetTypeID())
        {
          v7 = v4;
        }

        else
        {
          v7 = 0;
        }

        *buf = 0;
        ctu::cf::assign(buf, v7, v6);
        v8 = *buf;
        v9 = *buf != 0;
        v10 = *(v2 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 67109376;
          v18 = v8 != 0;
          v19 = 1024;
          v20 = v16;
          _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Smart data mode %d for tag: %u", buf, 0xEu);
        }

        v11 = 1;
        goto LABEL_16;
      }

      v13 = *(v2 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 67109120;
        v18 = v16;
        _os_log_impl(&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Smart data mode not stored for tag: %u", buf, 8u);
      }
    }

    else
    {
      v12 = *(v2 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *buf = 67109120;
        v18 = v16;
        _os_log_error_impl(&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when getting smart data mode", buf, 8u);
      }
    }

    v11 = 0;
    v9 = 0;
LABEL_16:
    sub_10000A1EC(&v15);
    return v9 | (v11 << 8);
  }

  v11 = 0;
  v9 = 0;
  return v9 | (v11 << 8);
}

uint64_t *sub_10162D8D0(uint64_t *a1)
{
  v1 = *a1;
  v6 = a1;
  v7 = v1;
  v2 = *v1;
  v3 = sub_10162B870(*v1, v1 + 8);
  v8 = 0;
  sub_1016293E4(&v8, *(v2 + 64), v3);
  if (v8)
  {
    if (*(v1 + 33) == 1)
    {
      sub_1016298D0(v8, 10, *(v1 + 32));
    }

    else
    {
      CPRecordSetProperty();
    }

    sub_101627458(v2);
  }

  else
  {
    v4 = *(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *buf = 67109120;
      v10 = v3;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when setting smart data mode", buf, 8u);
    }
  }

  sub_10000A1EC(&v8);
  sub_1008B8BD0(&v7);
  return sub_1000049E0(&v6);
}

void sub_10162D9F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  va_copy(va2, va1);
  v5 = va_arg(va2, void);
  sub_10000A1EC(va2);
  sub_1008B8BD0(va1);
  sub_1000049E0(va);
  _Unwind_Resume(a1);
}

uint64_t sub_10162DA24(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v16 = 0;
  if (sub_10162B9C0(v2, (v1 + 1), &v16))
  {
    v15 = 0;
    sub_1016293E4(&v15, *(v2 + 64), v16);
    if (v15)
    {
      Property = CPRecordGetProperty();
      v4 = Property;
      if (Property)
      {
        v5 = CFGetTypeID(Property);
        if (v5 == CFNumberGetTypeID())
        {
          v7 = v4;
        }

        else
        {
          v7 = 0;
        }

        *buf = 0;
        ctu::cf::assign(buf, v7, v6);
        v8 = *buf;
        v9 = *buf != 0;
        v10 = *(v2 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 67109376;
          v18 = v8 != 0;
          v19 = 1024;
          v20 = v16;
          _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Interface cost expensive %d for tag: %u", buf, 0xEu);
        }

        v11 = 1;
        goto LABEL_16;
      }

      v13 = *(v2 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 67109120;
        v18 = v16;
        _os_log_impl(&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Interface cost not stored for tag: %u", buf, 8u);
      }
    }

    else
    {
      v12 = *(v2 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *buf = 67109120;
        v18 = v16;
        _os_log_error_impl(&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when getting interface cost", buf, 8u);
      }
    }

    v11 = 0;
    v9 = 0;
LABEL_16:
    sub_10000A1EC(&v15);
    return v9 | (v11 << 8);
  }

  v11 = 0;
  v9 = 0;
  return v9 | (v11 << 8);
}

uint64_t *sub_10162DC3C(uint64_t *a1)
{
  v1 = *a1;
  v6 = a1;
  v7 = v1;
  v2 = *v1;
  v3 = sub_10162B870(*v1, v1 + 8);
  v8 = 0;
  sub_1016293E4(&v8, *(v2 + 64), v3);
  if (v8)
  {
    if (*(v1 + 33) == 1)
    {
      sub_1016298D0(v8, 11, *(v1 + 32));
    }

    else
    {
      CPRecordSetProperty();
    }

    sub_101627458(v2);
  }

  else
  {
    v4 = *(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *buf = 67109120;
      v10 = v3;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when setting interface cost", buf, 8u);
    }
  }

  sub_10000A1EC(&v8);
  sub_1008B8BD0(&v7);
  return sub_1000049E0(&v6);
}

void sub_10162DD64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  va_copy(va2, va1);
  v5 = va_arg(va2, void);
  sub_10000A1EC(va2);
  sub_1008B8BD0(va1);
  sub_1000049E0(va);
  _Unwind_Resume(a1);
}

uint64_t sub_10162DD90(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v16 = 0;
  if (sub_10162B9C0(v2, (v1 + 1), &v16))
  {
    v15 = 0;
    sub_1016293E4(&v15, *(v2 + 64), v16);
    if (v15)
    {
      Property = CPRecordGetProperty();
      v4 = Property;
      if (Property)
      {
        v5 = CFGetTypeID(Property);
        if (v5 == CFNumberGetTypeID())
        {
          v7 = v4;
        }

        else
        {
          v7 = 0;
        }

        *buf = 0;
        ctu::cf::assign(buf, v7, v6);
        v8 = *buf;
        v9 = *buf != 0;
        v10 = *(v2 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 67109376;
          v18 = v8 != 0;
          v19 = 1024;
          v20 = v16;
          _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Privacy Proxy %d for tag: %u", buf, 0xEu);
        }

        v11 = 1;
        goto LABEL_16;
      }

      v13 = *(v2 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 67109120;
        v18 = v16;
        _os_log_impl(&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Privacy Proxy not stored for tag: %u", buf, 8u);
      }
    }

    else
    {
      v12 = *(v2 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *buf = 67109120;
        v18 = v16;
        _os_log_error_impl(&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when getting privacy proxy", buf, 8u);
      }
    }

    v11 = 0;
    v9 = 0;
LABEL_16:
    sub_10000A1EC(&v15);
    return v9 | (v11 << 8);
  }

  v11 = 0;
  v9 = 0;
  return v9 | (v11 << 8);
}

uint64_t *sub_10162DFA8(uint64_t *a1)
{
  v1 = *a1;
  v6 = a1;
  v7 = v1;
  v2 = *v1;
  v3 = sub_10162B870(*v1, v1 + 8);
  v8 = 0;
  sub_1016293E4(&v8, *(v2 + 64), v3);
  if (v8)
  {
    if (*(v1 + 33) == 1)
    {
      sub_1016298D0(v8, 12, *(v1 + 32));
    }

    else
    {
      CPRecordSetProperty();
    }

    sub_101627458(v2);
  }

  else
  {
    v4 = *(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *buf = 67109120;
      v10 = v3;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when setting privacy proxy", buf, 8u);
    }
  }

  sub_10000A1EC(&v8);
  sub_1008B8BD0(&v7);
  return sub_1000049E0(&v6);
}

void sub_10162E0D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  va_copy(va2, va1);
  v5 = va_arg(va2, void);
  sub_10000A1EC(va2);
  sub_1008B8BD0(va1);
  sub_1000049E0(va);
  _Unwind_Resume(a1);
}

uint64_t sub_10162E0FC(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v16 = 0;
  if (sub_10162B9C0(v2, (v1 + 1), &v16))
  {
    v3 = v16;
    v17 = 0;
    sub_1016293E4(&v17, *(v2 + 64), v16);
    if (v17)
    {
      Property = CPRecordGetProperty();
      v5 = Property;
      if (Property)
      {
        v6 = CFGetTypeID(Property);
        if (v6 == CFNumberGetTypeID())
        {
          v8 = v5;
        }

        else
        {
          v8 = 0;
        }

        *buf = 0;
        ctu::cf::assign(buf, v8, v7);
        v9 = *buf;
        v10 = *buf != 0;
        v11 = *(v2 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 67109376;
          v19 = v9 != 0;
          v20 = 1024;
          v21 = v3;
          _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Reliable network fallback %d for tag: %u", buf, 0xEu);
        }

        v12 = 1;
        goto LABEL_16;
      }

      v14 = *(v2 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 67109120;
        v19 = v3;
        _os_log_impl(&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Reliable network fallback not stored for tag: %u", buf, 8u);
      }
    }

    else
    {
      v13 = *(v2 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *buf = 67109120;
        v19 = v3;
        _os_log_error_impl(&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when getting reliable network fallback", buf, 8u);
      }
    }

    v12 = 0;
    v10 = 0;
LABEL_16:
    sub_10000A1EC(&v17);
    return v10 | (v12 << 8);
  }

  v12 = 0;
  v10 = 0;
  return v10 | (v12 << 8);
}

void sub_10162E2EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10000A1EC(va);
  _Unwind_Resume(a1);
}

uint64_t *sub_10162E30C(uint64_t *a1)
{
  v1 = *a1;
  v7 = a1;
  v8 = v1;
  v2 = *v1;
  v3 = sub_10162B870(*v1, v1 + 8);
  v4 = *(v1 + 32);
  v9 = 0;
  sub_1016293E4(&v9, *(v2 + 64), v3);
  if (v9)
  {
    sub_1016298D0(v9, 9, v4);
    sub_101627458(v2);
  }

  else
  {
    v5 = *(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *buf = 67109120;
      v11 = v3;
      _os_log_error_impl(&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when setting reliable network fallback", buf, 8u);
    }
  }

  sub_10000A1EC(&v9);
  sub_1003023A8(&v8);
  return sub_1000049E0(&v7);
}

void sub_10162E41C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  va_copy(va2, va1);
  v5 = va_arg(va2, void);
  sub_10000A1EC(va2);
  sub_1003023A8(va1);
  sub_1000049E0(va);
  _Unwind_Resume(a1);
}

uint64_t *sub_10162E448(uint64_t *a1)
{
  v1 = *a1;
  v3 = a1;
  v4 = v1;
  ctu::RestModule::disconnect((*v1 + 80));
  sub_1000FF844(&v4);
  return sub_1000049E0(&v3);
}

void sub_10162E490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_10162E4AC(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v1, *(**a1 + 48));
  ctu::RestModule::connect();
  if (v2)
  {
    sub_100004A34(v2);
  }

  sub_10000501C(&__p, "/cc/events/service_transferred");
  operator new();
}

void sub_10162E5D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  sub_1000062D4(&a19);
  if (a18 < 0)
  {
    operator delete(__p);
  }

  operator delete();
}

__n128 sub_10162E6B4(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F59490;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_10162E6EC(void *a1)
{
  v9 = 0;
  v7 = 0u;
  *__p = 0u;
  *v5 = 0u;
  *v6 = 0u;
  rest::read_rest_value();
  v2 = a1[2];
  v3 = a1[3];
  v4 = (a1[1] + (v3 >> 1));
  if (v3)
  {
    v2 = *(*v4 + v2);
  }

  v2(v4, v5);
  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }

  if (SHIBYTE(v7) < 0)
  {
    operator delete(v6[1]);
  }

  if (SHIBYTE(v6[0]) < 0)
  {
    operator delete(v5[0]);
  }
}

uint64_t sub_10162E7BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

const void **sub_10162E81C(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v5);
  v2 = *(a1 + 32);
  if (v2 != &v5)
  {
    v3 = *v2;
    *v2 = 0;
    v6 = v3;
    *v2 = v5;
    v5 = 0;
    sub_100005978(&v6);
  }

  return sub_100005978(&v5);
}

uint64_t sub_10162E930(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10162E97C(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t sub_10162EA6C(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F59600;
  a2[1] = v2;
  return result;
}

void sub_10162EA98(uint64_t a1, CFArrayRef *a2)
{
  v3 = *a2;
  Count = CFArrayGetCount(*a2);
  if (Count >= 1)
  {
    v5 = Count;
    for (i = 0; i != v5; ++i)
    {
      CFArrayGetValueAtIndex(v3, i);
      Property = CPRecordGetProperty();
      if (Property)
      {
        CFGetTypeID(Property);
        CFStringGetTypeID();
      }

      __p[0] = 0;
      __p[1] = 0;
      v9 = 0;
      v10 = 0uLL;
      v11 = 0;
      ctu::cf::assign();
      *__p = v10;
      v9 = v11;
      sub_100005308(*(a1 + 8), __p);
      if (SHIBYTE(v9) < 0)
      {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_10162EB7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10162EBAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

const void **sub_10162EBF8(uint64_t a1, uint64_t a2)
{
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(v4, *a2, *(a2 + 8));
  }

  else
  {
    *v4 = *a2;
    v5 = *(a2 + 16);
  }

  if (SHIBYTE(v5) < 0)
  {
    sub_100005F2C(__p, v4[0], v4[1]);
  }

  else
  {
    *__p = *v4;
    v9 = v5;
  }

  v7 = 0;
  if (SHIBYTE(v9) < 0)
  {
    sub_100005F2C(&__dst, __p[0], __p[1]);
  }

  else
  {
    __dst = *__p;
    v11 = v9;
  }

  v12 = 0;
  if (ctu::cf::convert_copy())
  {
    v2 = v7;
    v7 = v12;
    v13 = v2;
    sub_100005978(&v13);
  }

  if (SHIBYTE(v11) < 0)
  {
    operator delete(__dst);
  }

  v6 = v7;
  v7 = 0;
  sub_100005978(&v7);
  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }

  if (SHIBYTE(v5) < 0)
  {
    operator delete(v4[0]);
  }

  CPRecordSetProperty();
  return sub_100005978(&v6);
}

void sub_10162ED3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  sub_100005978(&a18);
  if (a24 < 0)
  {
    operator delete(__p);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_10162EDA0(uint64_t a1, int a2, unsigned int a3)
{
  Property = CPRecordGetProperty();
  if (Property)
  {
    v7 = Property;
    v8 = CFGetTypeID(Property);
    if (v8 == CFNumberGetTypeID())
    {
      v9 = v7;
    }

    else
    {
      v9 = 0;
    }
  }

  else
  {
    v9 = 0;
  }

  valuePtr = 0;
  ctu::cf::assign(&valuePtr, v9, v6);
  if ((a3 | a2) == a2)
  {
    v14 = 0;
    valuePtr = valuePtr & ~a2 | a3;
    v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
    if (v10)
    {
      v14 = v10;
      valuePtr = 0;
      sub_100029A48(&valuePtr);
      v11 = v14;
    }

    else
    {
      v11 = 0;
    }

    v13 = v11;
    v14 = 0;
    sub_100029A48(&v14);
    CPRecordSetProperty();
    sub_100029A48(&v13);
  }

  else
  {
    sub_100020BEC();
    v12 = qword_101FCAED8;
    if (os_log_type_enabled(qword_101FCAED8, OS_LOG_TYPE_ERROR))
    {
      LODWORD(valuePtr) = 67109376;
      HIDWORD(valuePtr) = a3;
      v16 = 1024;
      v17 = a2;
      _os_log_error_impl(&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Value (0x%08X) has bits set outside of the mask (0x%08X)", &valuePtr, 0xEu);
    }
  }
}

uint64_t sub_10162EFC0(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F59680;
  a2[1] = v2;
  return result;
}

uint64_t sub_10162EFEC(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 8);
  if (v2[23] < 0)
  {
    v2 = *v2;
  }

  return sqlite3_bind_text(*(*a2 + 8), 1, v2, -1, 0);
}

uint64_t sub_10162F014(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10162F0E4(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F59700;
  result = *(a1 + 8);
  v3 = *(a1 + 24);
  *(a2 + 40) = *(a1 + 40);
  *(a2 + 24) = v3;
  *(a2 + 8) = result;
  return result;
}

void sub_10162F124(uint64_t a1, CFArrayRef *a2)
{
  v3 = *a2;
  v4 = *(a1 + 8);
  if (CFArrayGetCount(*a2) >= 1)
  {
    v5 = *(v4 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(a1 + 16);
      if (*(v6 + 23) < 0)
      {
        v6 = *v6;
      }

      v7 = **(a1 + 24);
      v9 = 136446466;
      v10 = v6;
      v11 = 1024;
      v12 = v7;
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Updating bundle entry: %{public}s with notification state set to: 0x%08X", &v9, 0x12u);
    }

    ValueAtIndex = CFArrayGetValueAtIndex(v3, 0);
    sub_10162EDA0(ValueAtIndex, **(a1 + 32), **(a1 + 24));
    **(a1 + 40) = 0;
  }
}

uint64_t sub_10162F228(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10162F2E4(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F59780;
  a2[1] = v2;
  return result;
}

uint64_t sub_10162F310(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 8);
  if (v2[23] < 0)
  {
    v2 = *v2;
  }

  return sqlite3_bind_text(*(*a2 + 8), 1, v2, -1, 0);
}

uint64_t sub_10162F338(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10162F408(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F59800;
  result = *(a1 + 8);
  v3 = *(a1 + 24);
  *(a2 + 40) = *(a1 + 40);
  *(a2 + 24) = v3;
  *(a2 + 8) = result;
  return result;
}

void sub_10162F448(uint64_t a1, CFArrayRef *a2)
{
  v3 = *a2;
  v4 = *(a1 + 8);
  if (CFArrayGetCount(*a2) >= 1)
  {
    v5 = *(v4 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(a1 + 16);
      if (*(v6 + 23) < 0)
      {
        v6 = *v6;
      }

      v7 = **(a1 + 24);
      v9 = 136446466;
      v10 = v6;
      v11 = 1024;
      v12 = v7;
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Updating bundle entry: %{public}s with notification state set to: 0x%08X", &v9, 0x12u);
    }

    ValueAtIndex = CFArrayGetValueAtIndex(v3, 0);
    sub_10162EDA0(ValueAtIndex, **(a1 + 32), **(a1 + 24));
    **(a1 + 40) = 0;
  }
}

uint64_t sub_10162F54C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10162F624(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10162F6E4(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F59900;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

void sub_10162F714(uint64_t a1, CFArrayRef *a2)
{
  v3 = *a2;
  v4 = *(a1 + 8);
  Count = CFArrayGetCount(*a2);
  if (Count >= 1)
  {
    v6 = Count;
    for (i = 0; i != v6; ++i)
    {
      CFArrayGetValueAtIndex(v3, i);
      Property = CPRecordGetProperty();
      if (Property)
      {
        CFGetTypeID(Property);
        CFStringGetTypeID();
      }

      __p[0] = 0;
      __p[1] = 0;
      v23 = 0;
      memset(buf, 0, sizeof(buf));
      v25 = 0;
      ctu::cf::assign();
      *__p = *buf;
      v23 = v25;
      v9 = CPRecordGetProperty();
      v11 = v9;
      if (v9)
      {
        v12 = CFGetTypeID(v9);
        if (v12 == CFNumberGetTypeID())
        {
          v13 = v11;
        }

        else
        {
          v13 = 0;
        }
      }

      else
      {
        v13 = 0;
      }

      *buf = 0;
      ctu::cf::assign(buf, v13, v10);
      v14 = (*buf >> 2) & 5;
      if (v14 > 3)
      {
        if (v14 == 4)
        {
          v18 = *(a1 + 16);
          *buf = __p;
          *(sub_101329334(v18, __p) + 56) = 0;
        }

        else
        {
          v19 = *(v4 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            if (v23 >= 0)
            {
              v20 = __p;
            }

            else
            {
              v20 = __p[0];
            }

            *buf = 136446210;
            *&buf[4] = v20;
            _os_log_impl(&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#N Invalid authorization state for %{public}s", buf, 0xCu);
          }

          v21 = *(a1 + 16);
          *buf = __p;
          *(sub_101329334(v21, __p) + 56) = 0;
          sub_10162AA6C(v4, __p, 0);
        }
      }

      else
      {
        v15 = *(a1 + 16);
        *buf = __p;
        if (v14)
        {
          v16 = sub_101329334(v15, __p);
          v17 = 2;
        }

        else
        {
          v16 = sub_101329334(v15, __p);
          v17 = 1;
        }

        *(v16 + 56) = v17;
      }

      if (SHIBYTE(v23) < 0)
      {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_10162F9A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a23 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10162F9DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10162FAB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10162FB74(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F59A00;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

void sub_10162FBA4(uint64_t a1, CFArrayRef *a2)
{
  v3 = *a2;
  v4 = *(a1 + 8);
  Count = CFArrayGetCount(*a2);
  if (Count >= 1)
  {
    v6 = Count;
    for (i = 0; i != v6; ++i)
    {
      CFArrayGetValueAtIndex(v3, i);
      Property = CPRecordGetProperty();
      if (Property)
      {
        CFGetTypeID(Property);
        CFStringGetTypeID();
      }

      __p[0] = 0;
      __p[1] = 0;
      v23 = 0;
      memset(buf, 0, sizeof(buf));
      v25 = 0;
      ctu::cf::assign();
      *__p = *buf;
      v23 = v25;
      v9 = CPRecordGetProperty();
      v11 = v9;
      if (v9)
      {
        v12 = CFGetTypeID(v9);
        if (v12 == CFNumberGetTypeID())
        {
          v13 = v11;
        }

        else
        {
          v13 = 0;
        }
      }

      else
      {
        v13 = 0;
      }

      *buf = 0;
      ctu::cf::assign(buf, v13, v10);
      v14 = (*buf >> 3) & 5;
      if (v14 > 3)
      {
        if (v14 == 4)
        {
          v18 = *(a1 + 16);
          *buf = __p;
          *(sub_101329334(v18, __p) + 56) = 0;
        }

        else
        {
          v19 = *(v4 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            if (v23 >= 0)
            {
              v20 = __p;
            }

            else
            {
              v20 = __p[0];
            }

            *buf = 136446210;
            *&buf[4] = v20;
            _os_log_impl(&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#N Invalid authorization state for %{public}s", buf, 0xCu);
          }

          v21 = *(a1 + 16);
          *buf = __p;
          *(sub_101329334(v21, __p) + 56) = 0;
          sub_10162AC8C(v4, __p, 0);
        }
      }

      else
      {
        v15 = *(a1 + 16);
        *buf = __p;
        if (v14)
        {
          v16 = sub_101329334(v15, __p);
          v17 = 2;
        }

        else
        {
          v16 = sub_101329334(v15, __p);
          v17 = 1;
        }

        *(v16 + 56) = v17;
      }

      if (SHIBYTE(v23) < 0)
      {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_10162FE30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a23 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10162FE6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10162FF2C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F59A80;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10162FF5C(uint64_t a1, uint64_t *a2)
{
  v3 = *a2;
  v4 = *(a1 + 8);
  if (v4[23] < 0)
  {
    v4 = *v4;
  }

  result = sqlite3_bind_text(*(*a2 + 8), 1, v4, -1, 0);
  v6 = *(a1 + 16);
  if (*(v6 + 23) < 0)
  {
    if (!v6[1])
    {
      return result;
    }

    v6 = *v6;
  }

  else if (!*(v6 + 23))
  {
    return result;
  }

  v7 = *(v3 + 8);

  return sqlite3_bind_text(v7, 2, v6, -1, 0);
}

uint64_t sub_10162FFF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1016300C8(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F59B00;
  result = *(a1 + 8);
  v3 = *(a1 + 24);
  v4 = *(a1 + 40);
  *(a2 + 56) = *(a1 + 56);
  *(a2 + 40) = v4;
  *(a2 + 24) = v3;
  *(a2 + 8) = result;
  return result;
}

void sub_101630110(uint64_t a1, CFArrayRef *a2)
{
  v3 = *a2;
  v4 = *(a1 + 8);
  if (CFArrayGetCount(*a2) < 1)
  {
    return;
  }

  v29 = a1;
  v30 = v4;
  if (CFArrayGetCount(v3) < 2)
  {
    goto LABEL_20;
  }

  Count = CFArrayGetCount(v3);
  if (Count < 1)
  {
    goto LABEL_20;
  }

  v6 = Count;
  v7 = 0;
  v31 = 0;
  v8 = 0;
  v9 = 1;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v3, v8);
    Property = CPRecordGetProperty();
    v12 = CPRecordGetProperty();
    if (!Property)
    {
      goto LABEL_19;
    }

    v13 = v12;
    v14 = CFGetTypeID(Property);
    v15 = v14 == CFStringGetTypeID() ? Property : 0;
    if (!CFStringGetLength(v15))
    {
      goto LABEL_19;
    }

    if (v13)
    {
      v16 = CFGetTypeID(v13);
      v17 = v16 == CFStringGetTypeID() ? v13 : 0;
      if (CFStringGetLength(v17))
      {
        break;
      }
    }

    v31 = ValueAtIndex;
    if (v7)
    {
      goto LABEL_18;
    }

LABEL_19:
    v9 = ++v8 < v6;
    if (v6 == v8)
    {
      goto LABEL_20;
    }
  }

  v7 = ValueAtIndex;
  if (!ValueAtIndex)
  {
    goto LABEL_19;
  }

LABEL_18:
  if (!v31)
  {
    goto LABEL_19;
  }

  CPRecordStoreRemoveRecord();
  if (v9)
  {
    **(v29 + 16) = 1;
    return;
  }

LABEL_20:
  v18 = CFArrayGetValueAtIndex(v3, 0);
  v19 = CPRecordGetProperty();
  if (v19)
  {
    v21 = v19;
    v22 = CFGetTypeID(v19);
    if (v22 == CFNumberGetTypeID())
    {
      v23 = v21;
    }

    else
    {
      v23 = 0;
    }
  }

  else
  {
    v23 = 0;
  }

  *buf = 0;
  ctu::cf::assign(buf, v23, v20);
  **(v29 + 24) = *buf;
  if (**(v29 + 32) == 1)
  {
    sub_10162B384(v18, 0, *(v29 + 40));
    sub_10162B384(v18, 1, *(v29 + 48));
    Current = CFAbsoluteTimeGetCurrent();
    sub_10162B53C(Current);
  }

  **(v29 + 56) = 1;
  v25 = *(v30 + 40);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    v26 = *(v29 + 40);
    if (*(v26 + 23) < 0)
    {
      v26 = *v26;
    }

    v27 = *(v29 + 48);
    if (*(v27 + 23) < 0)
    {
      v27 = *v27;
    }

    v28 = **(v29 + 24);
    *buf = 136315650;
    v33 = v26;
    v34 = 2080;
    v35 = v27;
    v36 = 1024;
    v37 = v28;
    _os_log_impl(&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Found best match for subscriber %s and mdn %s with tag: %u", buf, 0x1Cu);
  }
}

uint64_t sub_1016303D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101630490(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F59B80;
  a2[1] = v2;
  return result;
}

uint64_t sub_1016304D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1016305A0(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F59C00;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_1016305D8(uint64_t a1, const __CFArray **a2)
{
  v3 = *a2;
  v4 = *(a1 + 8);
  v5 = *(v4 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    Count = CFArrayGetCount(v3);
    v7 = **(a1 + 16);
    v8 = **(a1 + 24);
    v16 = 134218496;
    v17 = Count;
    v18 = 2048;
    v19 = v7;
    v20 = 1024;
    v21 = v8;
    _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Found: %ld subscriber records in the database. Maximum allowed are: %lu for slot index: %d", &v16, 0x1Cu);
  }

  if (CFArrayGetCount(v3) > **(a1 + 16))
  {
    CFArrayGetValueAtIndex(v3, 0);
    Property = CPRecordGetProperty();
    if (Property)
    {
      v11 = Property;
      v12 = CFGetTypeID(Property);
      if (v12 == CFNumberGetTypeID())
      {
        v13 = v11;
      }

      else
      {
        v13 = 0;
      }
    }

    else
    {
      v13 = 0;
    }

    v16 = 0;
    ctu::cf::assign(&v16, v13, v10);
    **(a1 + 32) = v16;
    CPRecordStoreRemoveRecord();
    v14 = *(v4 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = **(a1 + 32);
      v16 = 67109120;
      LODWORD(v17) = v15;
      _os_log_impl(&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Removing old subscriber with tag: %u", &v16, 8u);
    }
  }
}

uint64_t sub_101630784(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_101630844(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F59C80;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_101630884(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1016308D0(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

__n128 sub_1016309C4(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F59D10;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_101630A08(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101630AC4(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F59D90;
  a2[1] = v2;
  return result;
}

uint64_t sub_101630B0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101630BC8(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F59E10;
  a2[1] = v2;
  return result;
}

CFIndex sub_101630BF4(uint64_t a1, CFArrayRef *a2)
{
  v3 = *a2;
  result = CFArrayGetCount(*a2);
  if (result >= 1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v3, 0);
    return sub_1000673E0(*(a1 + 8), &ValueAtIndex);
  }

  return result;
}

uint64_t sub_101630C4C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_101630D0C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F59E90;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_101630D3C(uint64_t a1, uint64_t *a2)
{
  v3 = *a2;
  v4 = *(a1 + 8);
  if (v4[23] < 0)
  {
    v4 = *v4;
  }

  sqlite3_bind_text(*(*a2 + 8), 1, v4, -1, 0);
  v5 = *(v3 + 8);
  v6 = *(a1 + 16);
  if (v6[23] < 0)
  {
    v6 = *v6;
  }

  return sqlite3_bind_text(v5, 2, v6, -1, 0);
}

uint64_t sub_101630DB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_101630E7C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F59F10;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_101630EB4(uint64_t a1, CFArrayRef *a2)
{
  v3 = *a2;
  v4 = *(a1 + 16);
  if (CFArrayGetCount(*a2) >= 1)
  {
    *v9 = CFArrayGetValueAtIndex(v3, 0);
    sub_1000673E0(*(a1 + 8), v9);
    Current = CFAbsoluteTimeGetCurrent();
    sub_10162B53C(Current);
    v6 = *(v4 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(a1 + 24);
      if (*(v7 + 23) < 0)
      {
        v7 = *v7;
      }

      v8 = *(a1 + 32);
      if (*(v8 + 23) < 0)
      {
        v8 = *v8;
      }

      *v9 = 136315394;
      *&v9[4] = v7;
      v10 = 2080;
      v11 = v8;
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Found exact match for subscriber %s and mdn %s", v9, 0x16u);
    }
  }
}

uint64_t sub_101630FCC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101631088(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F59F90;
  a2[1] = v2;
  return result;
}

uint64_t sub_1016310B4(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 8);
  if (v2[23] < 0)
  {
    v2 = *v2;
  }

  return sqlite3_bind_text(*(*a2 + 8), 1, v2, -1, 0);
}

uint64_t sub_1016310E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1016311A8(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5A010;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_1016311E0(uint64_t a1, CFArrayRef *a2)
{
  v3 = *a2;
  v4 = *(a1 + 16);
  if (CFArrayGetCount(*a2) >= 1)
  {
    *v8 = CFArrayGetValueAtIndex(v3, 0);
    sub_1000673E0(*(a1 + 8), v8);
    Current = CFAbsoluteTimeGetCurrent();
    sub_10162B53C(Current);
    v6 = *(v4 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(a1 + 24);
      if (*(v7 + 23) < 0)
      {
        v7 = *v7;
      }

      *v8 = 136315138;
      *&v8[4] = v7;
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Found exact match for subscriber %s and no mdn", v8, 0xCu);
    }
  }
}

uint64_t sub_1016312DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_1016313C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  std::__shared_weak_count::~__shared_weak_count(v10);
  operator delete(v12);

  _Unwind_Resume(a1);
}

void sub_1016313F0(DataUsageCacheManagerFactoryInterface *a1)
{
  DataUsageCacheManagerFactoryInterface::~DataUsageCacheManagerFactoryInterface(a1);

  operator delete();
}

void sub_101631448(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F5A0D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

BOOL sub_1016314C4(void **a1)
{
  v1 = *a1;
  if (!*a1)
  {
    return 0;
  }

  v4 = *v1;
  v2 = v1 + 1;
  v3 = v4;
  if (v4 == v2)
  {
    return 0;
  }

  do
  {
    result = *(v3 + 64) == 0;
    if (!*(v3 + 64))
    {
      break;
    }

    v6 = v3[1];
    if (v6)
    {
      do
      {
        v7 = v6;
        v6 = *v6;
      }

      while (v6);
    }

    else
    {
      do
      {
        v7 = v3[2];
        v8 = *v7 == v3;
        v3 = v7;
      }

      while (!v8);
    }

    v3 = v7;
  }

  while (v7 != v2);
  return result;
}

void **sub_10163152C@<X0>(void **result@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  v4 = *result;
  if (!*result)
  {
    goto LABEL_15;
  }

  v7 = *v4;
  v5 = v4 + 1;
  v6 = v7;
  if (v7 != v5)
  {
    while (*(v6 + 8) != a2)
    {
      v8 = v6[1];
      if (v8)
      {
        do
        {
          v9 = v8;
          v8 = *v8;
        }

        while (v8);
      }

      else
      {
        do
        {
          v9 = v6[2];
          v10 = *v9 == v6;
          v6 = v9;
        }

        while (!v10);
      }

      v6 = v9;
      if (v9 == v5)
      {
        goto LABEL_14;
      }
    }
  }

  if (v6 == v5)
  {
LABEL_14:
    LOBYTE(v4) = 0;
LABEL_15:
    *a3 = 0;
    goto LABEL_18;
  }

  if (*(v6 + 63) < 0)
  {
    result = sub_100005F2C(a3, v6[5], v6[6]);
  }

  else
  {
    v11 = *(v6 + 5);
    *(a3 + 16) = v6[7];
    *a3 = v11;
  }

  LOBYTE(v4) = 1;
LABEL_18:
  *(a3 + 24) = v4;
  return result;
}

uint64_t sub_1016315EC(void **a1, void *a2)
{
  v2 = *a1;
  if (!*a1)
  {
    return 0;
  }

  v4 = v2 + 1;
  v3 = *v2;
  if (*v2 != v2 + 1)
  {
    while (!sub_100071DF8(v3 + 5, a2))
    {
      v7 = v3[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          v8 = v3[2];
          v9 = *v8 == v3;
          v3 = v8;
        }

        while (!v9);
      }

      v3 = v8;
      if (v8 == v4)
      {
        v3 = v4;
        break;
      }
    }

    v2 = *a1;
  }

  if (v3 == v2 + 1)
  {
    return 0;
  }

  else
  {
    return *(v3 + 8);
  }
}

const void **sub_1016316A4(uint64_t a1, int a2, const void **a3)
{
  *v14 = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    *v14 = Mutable;
    *buf = 0;
    sub_1000296E0(buf);
  }

  if (a2 == 1)
  {
    v7 = 13;
  }

  else
  {
    v7 = 12;
  }

  *(a1 + 48) = v7;
  v13 = 0;
  sub_101346294(a3, &v13);
  if (v13)
  {
    sub_1002972A4(*v14, @"MessagePayload", v13);
  }

  else
  {
    sub_101631844();
    v8 = qword_101FCAF20;
    if (os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "The message doesn't have a payload", buf, 2u);
    }
  }

  sub_100010180(&v11, v14);
  sub_1016318DC(&v12, v11);
  v9 = (a1 + 56);
  if ((a1 + 56) != &v12)
  {
    *buf = *v9;
    *v9 = v12;
    v12 = 0;
    sub_10002D760(buf);
  }

  sub_10002D760(&v12);
  sub_10001021C(&v11);
  sub_10001021C(&v13);
  return sub_1000296E0(v14);
}

void sub_101631804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  sub_10001021C(va);
  sub_1000296E0(va1);
  _Unwind_Resume(a1);
}

void sub_101631844()
{
  if ((atomic_load_explicit(&qword_101FCAF28, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_101FCAF28))
  {
    ctu::OsLogLogger::OsLogLogger(&qword_101FCAF20, kCtLoggingSystemName, "lasd.ids.msg");

    __cxa_guard_release(&qword_101FCAF28);
  }
}

void sub_1016318DC(void *a1, void *a2)
{
  v3 = a2;
  v12 = 0;
  v4 = [NSKeyedArchiver archivedDataWithRootObject:v3 requiringSecureCoding:1 error:&v12];
  v5 = v12;
  v6 = v5;
  if (v4)
  {
    if (!v5)
    {
      *a1 = v4;
      CFRetain(v4);
      goto LABEL_8;
    }

    sub_101631844();
    v7 = qword_101FCAF20;
    if (os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
    {
      *buf = 138412290;
      v14 = v6;
      v8 = "Error archiving message dictionary : %@";
      v9 = v7;
      v10 = 12;
LABEL_10:
      _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v8, buf, v10);
    }
  }

  else
  {
    sub_101631844();
    v11 = qword_101FCAF20;
    if (os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      v8 = "nil data";
      v9 = v11;
      v10 = 2;
      goto LABEL_10;
    }
  }

  *a1 = 0;
LABEL_8:
}

void sub_101631A38(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

const void **sub_101631A78@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  theDict = 0;
  sub_10002D728(&v11, (a1 + 56));
  sub_101631C34(&theDict, v11);
  sub_10002D760(&v11);
  if (theDict)
  {
    *buf = 0;
    Value = CFDictionaryGetValue(theDict, @"MessagePayload");
    v4 = Value;
    if (Value && (v5 = CFGetTypeID(Value), v5 == CFDictionaryGetTypeID()))
    {
      *buf = v4;
      CFRetain(v4);
      if (v4)
      {
        sub_1013464BC(buf, a2);
LABEL_10:
        sub_10001021C(buf);
        return sub_10001021C(&theDict);
      }
    }

    else
    {
      *buf = 0;
    }

    sub_101631844();
    v6 = qword_101FCAF20;
    if (os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
    {
      *v9 = 0;
      _os_log_error_impl(&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not get version info", v9, 2u);
    }

    a2[2] = 0;
    a2[1] = 0;
    *a2 = a2 + 1;
    goto LABEL_10;
  }

  sub_101631844();
  v7 = qword_101FCAF20;
  if (os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
  {
    *buf = 0;
    _os_log_error_impl(&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to decode the message", buf, 2u);
  }

  a2[2] = 0;
  a2[1] = 0;
  *a2 = a2 + 1;
  return sub_10001021C(&theDict);
}

void sub_101631BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  sub_10001021C(va);
  sub_10001021C(va1);
  _Unwind_Resume(a1);
}

void sub_101631C34(void *a1, void *a2)
{
  v3 = a2;
  if (v3)
  {
    v12 = 0;
    v4 = [[NSKeyedUnarchiver alloc] initForReadingFromData:v3 error:&v12];
    v5 = v12;
    if (v5)
    {
      sub_101631844();
      v6 = qword_101FCAF20;
      if (os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
      {
        *buf = 138412290;
        v14 = v5;
        _os_log_error_impl(&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Error creating the UnArchiver : %@", buf, 0xCu);
      }

      *a1 = 0;
    }

    else
    {
      [v4 setRequiresSecureCoding:1];
      v8 = objc_opt_class();
      v9 = [NSSet setWithObjects:v8, objc_opt_class(), 0];
      v10 = [v4 decodeObjectOfClasses:v9 forKey:NSKeyedArchiveRootObjectKey];

      if (v10)
      {
        *a1 = v10;
        CFRetain(v10);
      }

      else
      {
        sub_101631844();
        v11 = qword_101FCAF20;
        if (os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
        {
          *buf = 0;
          _os_log_error_impl(&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "message dictionary is nil", buf, 2u);
        }

        *a1 = 0;
      }
    }
  }

  else
  {
    sub_101631844();
    v7 = qword_101FCAF20;
    if (os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Message data is NULL", buf, 2u);
    }

    *a1 = 0;
  }
}

const void **sub_101631EC4(uint64_t a1, int a2, const void **a3, const char *a4)
{
  v21 = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v9 = v21;
    v21 = Mutable;
    *buf = v9;
    sub_1000296E0(buf);
  }

  if (a2 == 1)
  {
    v10 = 15;
  }

  else
  {
    v10 = 14;
  }

  *(a1 + 48) = v10;
  v20 = 0;
  sub_101346294(a3, &v20);
  sub_1002972A4(v21, @"MessagePayload", v20);
  if (a4[23] < 0)
  {
    a4 = *a4;
  }

  v11 = CFStringCreateWithCString(kCFAllocatorDefault, a4, 0x8000100u);
  v19 = v11;
  v18 = CFURLCreateWithFileSystemPath(0, v11, kCFURLPOSIXPathStyle, 0);
  if (v18)
  {
    v12 = v11 == 0;
  }

  else
  {
    v12 = 1;
  }

  if (v12)
  {
    sub_101631844();
    v13 = qword_101FCAF20;
    if (os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid db path, cannot send the db file", buf, 2u);
    }
  }

  else
  {
    sub_1005C1224((a1 + 64), &v18);
    sub_100010180(&v16, &v21);
    sub_1016318DC(&v17, v16);
    v14 = (a1 + 56);
    if ((a1 + 56) != &v17)
    {
      *buf = *v14;
      *v14 = v17;
      v17 = 0;
      sub_10002D760(buf);
    }

    sub_10002D760(&v17);
    sub_10001021C(&v16);
  }

  sub_1002030AC(&v18);
  sub_100005978(&v19);
  sub_10001021C(&v20);
  return sub_1000296E0(&v21);
}

void sub_101632090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11, const void *a12, const void *a13, const void *a14)
{
  sub_10001021C(&a9);
  sub_1002030AC(&a11);
  sub_100005978(&a12);
  sub_10001021C(&a13);
  sub_1000296E0(&a14);
  _Unwind_Resume(a1);
}

const void **sub_1016320F0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v27 = 0;
  sub_10002D728(&v26, (a1 + 56));
  sub_101631C34(&v27, v26);
  sub_10002D760(&v26);
  if (v27)
  {
    v25 = 0;
    Value = CFDictionaryGetValue(v27, @"MessagePayload");
    v5 = Value;
    if (Value && (v6 = CFGetTypeID(Value), v6 == CFDictionaryGetTypeID()))
    {
      v25 = v5;
      CFRetain(v5);
      if (v5)
      {
        v22 = 0;
        v23 = 0;
        v24 = 0;
        sub_1013464BC(&v25, &v22);
        if (v24 == 1)
        {
          v12 = *(a1 + 64);
          if (v12)
          {
            v21 = CFURLCopyFileSystemPath(v12, kCFURLPOSIXPathStyle);
            v17[0] = 0;
            v17[1] = 0;
            __p[0] = 0;
            ctu::cf::assign();
            v20[0] = 0;
            *(v20 + 3) = 0;
            a2[1] = 0;
            v13 = v22;
            *a2 = a2 + 1;
            a2[2] = 0;
            if (v13 != &v23)
            {
              do
              {
                *__p = 0u;
                v19 = 0u;
                *v17 = 0u;
                if (*(v13 + 63) < 0)
                {
                  sub_100005F2C(v17, v13[5], v13[6]);
                }

                else
                {
                  *v17 = *(v13 + 5);
                  __p[0] = v13[7];
                }

                __p[1] = 0;
                *&v19 = 0;
                DWORD2(v19) = v20[0];
                *(&v19 + 11) = *(v20 + 3);
                HIBYTE(v19) = 0;
                sub_101264AB4(a2, v13 + 8);
                if (SHIBYTE(v19) < 0)
                {
                  operator delete(__p[1]);
                }

                if (SHIBYTE(__p[0]) < 0)
                {
                  operator delete(v17[0]);
                }

                v14 = v13[1];
                if (v14)
                {
                  do
                  {
                    v15 = v14;
                    v14 = *v14;
                  }

                  while (v14);
                }

                else
                {
                  do
                  {
                    v15 = v13[2];
                    v16 = *v15 == v13;
                    v13 = v15;
                  }

                  while (!v16);
                }

                v13 = v15;
              }

              while (v15 != &v23);
            }

            sub_100005978(&v21);
            goto LABEL_36;
          }

          sub_101631844();
          v7 = qword_101FCAF20;
          if (!os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
          {
LABEL_35:
            a2[2] = 0;
            a2[1] = 0;
            *a2 = a2 + 1;
LABEL_36:
            sub_100077CD4(&v22, v23);
LABEL_13:
            sub_10001021C(&v25);
            return sub_10001021C(&v27);
          }

          LOWORD(v17[0]) = 0;
          v8 = "Invalid resource URL";
        }

        else
        {
          if (!v24)
          {
            goto LABEL_35;
          }

          sub_101631844();
          v7 = qword_101FCAF20;
          if (!os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
          {
            goto LABEL_35;
          }

          LOWORD(v17[0]) = 0;
          v8 = "Only 1 file and metadata are expected at a time";
        }

        _os_log_error_impl(&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v8, v17, 2u);
        goto LABEL_35;
      }
    }

    else
    {
      v25 = 0;
    }

    sub_101631844();
    v9 = qword_101FCAF20;
    if (os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v17[0]) = 0;
      _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not get the bundle info", v17, 2u);
    }

    a2[2] = 0;
    a2[1] = 0;
    *a2 = a2 + 1;
    goto LABEL_13;
  }

  sub_101631844();
  v10 = qword_101FCAF20;
  if (os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v17[0]) = 0;
    _os_log_error_impl(&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to decode the message", v17, 2u);
  }

  a2[2] = 0;
  a2[1] = 0;
  *a2 = a2 + 1;
  return sub_10001021C(&v27);
}

void sub_10163247C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, int a20, __int16 a21, char a22, char a23, char *a24, uint64_t a25, const void *a26)
{
  sub_100077CD4(&a21, a24);
  sub_10001021C(&a26);
  sub_10001021C((v26 - 72));
  _Unwind_Resume(a1);
}

uint64_t sub_101632548(uint64_t a1)
{
  v8 = 0;
  sub_10002D728(&v7, (a1 + 56));
  sub_101631C34(&v8, v7);
  sub_10002D760(&v7);
  if (v8)
  {
    v2 = *(a1 + 48) - 12;
    if (v2 <= 3u)
    {
      v3 = v2 + 1;
    }

    else
    {
      v3 = 0;
    }
  }

  else
  {
    sub_101631844();
    v4 = qword_101FCAF20;
    if (os_log_type_enabled(qword_101FCAF20, OS_LOG_TYPE_ERROR))
    {
      *v6 = 0;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to decode the message", v6, 2u);
    }

    v3 = 0;
  }

  sub_10001021C(&v8);
  return v3;
}

void sub_10163260C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10001021C(va);
  _Unwind_Resume(a1);
}

void sub_10163280C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, xpc_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  ctu::OsLogLogger::~OsLogLogger(&object);
  ctu::OsLogContext::~OsLogContext(&__p);
  ctu::XpcServer::~XpcServer(v18);
  NetworkAccessPolicyServerInterface::~NetworkAccessPolicyServerInterface(v17);
  _Unwind_Resume(a1);
}

void sub_10163291C(uint64_t a1, dispatch_object_t *a2)
{
  v2 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v2);
  }

  operator new();
}

void sub_1016329B8(uint64_t a1, dispatch_object_t *a2)
{
  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }

  v4 = *(a1 + 24);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_101632AB8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  v10 = a1[10];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v18[0]) = 0;
    _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Got a client request to perform first network use flow", v18, 2u);
  }

  if (*(a2 + 4))
  {
    v11 = a1[16];
    if (v11)
    {
      v12 = std::__shared_weak_count::lock(v11);
      if (v12)
      {
        v13 = a1[15];
        if (v13)
        {
          v15 = *a5;
          v14 = a5[1];
          if (v14)
          {
            atomic_fetch_add_explicit((v14 + 8), 1uLL, memory_order_relaxed);
          }

          v18[0] = off_101F5A528;
          v18[1] = v15;
          v18[2] = v14;
          v18[3] = v18;
          (*(*v13 + 8))(v13, a3, a4, 0, v18);
          sub_10000FF50(v18);
LABEL_16:
          sub_100004A34(v12);
          return;
        }
      }
    }

    else
    {
      v12 = 0;
    }

    v17 = a1[10];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18[0]) = 0;
      _os_log_error_impl(&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Policy server is null", v18, 2u);
    }

    if (v12)
    {
      goto LABEL_16;
    }
  }

  else
  {
    v16 = a1[10];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v18[0]) = 0;
      _os_log_impl(&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N Client is not entitled", v18, 2u);
    }
  }
}

void sub_101632C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10000FF50(&a9);
  sub_100004A34(v9);
  _Unwind_Resume(a1);
}

void sub_101632CB0(uint64_t a1, unsigned int *a2, uint64_t *a3)
{
  v4 = *(a1 + 128);
  if (v4)
  {
    v7 = std::__shared_weak_count::lock(v4);
    if (v7 && *(a1 + 120))
    {
      if (*(a2 + 4) == 1)
      {
        v8 = a3[1];
        v29 = *a3;
        v30 = v8;
        if (v8)
        {
          atomic_fetch_add_explicit((v8 + 8), 1uLL, memory_order_relaxed);
        }

        v31 = *a2;
        v32 = *(a2 + 4);
        if (*(a2 + 31) < 0)
        {
          sub_100005F2C(__p, *(a2 + 1), *(a2 + 2));
        }

        else
        {
          *__p = *(a2 + 2);
          __p[2] = *(a2 + 3);
        }

        __p[10] = 0;
        operator new();
      }

      *v26 = 0;
      v27 = 0;
      v28 = 0;
      ServiceMap = Registry::getServiceMap(*(a1 + 136));
      v11 = ServiceMap;
      if (v12 < 0)
      {
        v13 = (v12 & 0x7FFFFFFFFFFFFFFFLL);
        v14 = 5381;
        do
        {
          v12 = v14;
          v15 = *v13++;
          v14 = (33 * v14) ^ v15;
        }

        while (v15);
      }

      std::mutex::lock(ServiceMap);
      *buf = v12;
      v16 = sub_100009510(&v11[1].__m_.__sig, buf);
      if (v16)
      {
        v18 = v16[3];
        v17 = v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_100004A34(v17);
          v19 = 0;
LABEL_25:
          (*(*v18 + 104))(v26, v18, *a2);
          if ((v19 & 1) == 0)
          {
            sub_100004A34(v17);
          }

          v20 = HIBYTE(v28);
          if (v28 < 0)
          {
            v20 = v27;
          }

          if (v20)
          {
            v21 = a3[1];
            if (v21)
            {
              atomic_fetch_add_explicit((v21 + 8), 1uLL, memory_order_relaxed);
            }

            if (*(a2 + 31) < 0)
            {
              sub_100005F2C(v24, *(a2 + 1), *(a2 + 2));
            }

            else
            {
              *v24 = *(a2 + 2);
              v25 = *(a2 + 3);
            }

            __p[6] = 0;
            operator new();
          }

          v22 = *(a1 + 80);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            v23 = *a2;
            *buf = 67109120;
            *&buf[4] = v23;
            _os_log_error_impl(&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Not able to get mapped bundle id for process with pid: %d", buf, 8u);
          }

          if (SHIBYTE(v28) < 0)
          {
            operator delete(*v26);
          }

          goto LABEL_12;
        }
      }

      else
      {
        v18 = 0;
      }

      std::mutex::unlock(v11);
      v17 = 0;
      v19 = 1;
      goto LABEL_25;
    }
  }

  else
  {
    v7 = 0;
  }

  v9 = *(a1 + 80);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *v26 = 0;
    _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Policy server is null", v26, 2u);
  }

LABEL_12:
  if (v7)
  {
    sub_100004A34(v7);
  }
}

void sub_101633154(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28)
{
  v31 = v29[2];
  if (v31)
  {
    sub_100004A34(v31);
  }

  operator delete(v29);
  sub_101633238(&a9);
  if (a20 < 0)
  {
    operator delete(__p);
  }

  sub_100004A34(v28);
  _Unwind_Resume(a1);
}

uint64_t sub_101633238(uint64_t a1)
{
  if (*(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  v2 = *(a1 + 8);
  if (v2)
  {
    sub_100004A34(v2);
  }

  return a1;
}

uint64_t sub_101633278(uint64_t a1)
{
  if (*(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  xpc_release(*(a1 + 8));
  *(a1 + 8) = 0;
  return a1;
}

uint64_t sub_1016332BC(uint64_t a1)
{
  if (*(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  xpc_release(*(a1 + 8));
  *(a1 + 8) = 0;
  return a1;
}

void sub_101633300(uint64_t a1, uint64_t *a2)
{
  memset(v4, 0, sizeof(v4));
  sub_10003CF88(v4, *a2, a2[1], (a2[1] - *a2) >> 5);
  v3 = *(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_101633438(uint64_t a1, xpc::object *a2)
{
  v3 = *(a1 + 80);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    xpc::object::to_string(__p, a2);
    if (v6 >= 0)
    {
      v4 = __p;
    }

    else
    {
      v4 = __p[0];
    }

    *buf = 136315138;
    v8 = v4;
    _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received server error %s", buf, 0xCu);
    if (v6 < 0)
    {
      operator delete(__p[0]);
    }
  }
}

void sub_101633530(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 8);
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 16), 1uLL, memory_order_relaxed);
  }

  v3 = *(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_101633630(uint64_t a1)
{
  *a1 = off_101F5A120;
  v2 = (a1 + 8);
  *(a1 + 8) = off_101F5A178;
  v3 = *(a1 + 144);
  if (v3)
  {
    sub_100004A34(v3);
  }

  v4 = *(a1 + 128);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }

  sub_1016339F4(*(a1 + 104));
  v5 = *(a1 + 88);
  if (v5)
  {
    dispatch_release(v5);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 80));
  ctu::XpcServer::~XpcServer(v2);

  NetworkAccessPolicyServerInterface::~NetworkAccessPolicyServerInterface(a1);
}

void sub_1016336DC(uint64_t a1)
{
  *a1 = off_101F5A120;
  v2 = (a1 + 8);
  *(a1 + 8) = off_101F5A178;
  v3 = *(a1 + 144);
  if (v3)
  {
    sub_100004A34(v3);
  }

  v4 = *(a1 + 128);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }

  sub_1016339F4(*(a1 + 104));
  v5 = *(a1 + 88);
  if (v5)
  {
    dispatch_release(v5);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 80));
  ctu::XpcServer::~XpcServer(v2);
  NetworkAccessPolicyServerInterface::~NetworkAccessPolicyServerInterface(a1);

  operator delete();
}

void sub_10163379C(uint64_t a1)
{
  v2 = (a1 - 8);
  *(a1 - 8) = off_101F5A120;
  *a1 = off_101F5A178;
  v3 = *(a1 + 136);
  if (v3)
  {
    sub_100004A34(v3);
  }

  v4 = *(a1 + 120);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }

  sub_1016339F4(*(a1 + 96));
  v5 = *(a1 + 80);
  if (v5)
  {
    dispatch_release(v5);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 72));
  ctu::XpcServer::~XpcServer(a1);

  NetworkAccessPolicyServerInterface::~NetworkAccessPolicyServerInterface(v2);
}

uint64_t sub_101633850(uint64_t a1)
{
  if (*(a1 + 39) < 0)
  {
    operator delete(*(a1 + 16));
  }

  xpc_release(*a1);
  *a1 = 0;
  return a1;
}

void sub_10163392C(void *a1)
{
  __cxa_begin_catch(a1);
  xpc::auto_reply::deleter(v1, v2);
  __cxa_rethrow();
}

void sub_101633958(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1016339B0(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F5A298))
  {
    return a1 + 32;
  }

  else
  {
    return 0;
  }
}

void sub_1016339F4(void *a1)
{
  if (a1)
  {
    sub_1016339F4(*a1);
    sub_1016339F4(a1[1]);
    sub_101633A48((a1 + 4));

    operator delete(a1);
  }
}

void sub_101633A48(uint64_t a1)
{
  if (*(a1 + 39) < 0)
  {
    operator delete(*(a1 + 16));
  }

  xpc_release(*a1);
  *a1 = 0;
}

void sub_101633B5C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[4], v1, sub_101633C30);
  __cxa_rethrow();
}

void sub_101633B9C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101633BF0(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101633C30(uint64_t result)
{
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t *sub_101633C5C(uint64_t a1)
{
  v2 = a1;
  ctu::XpcServer::startListener_sync((*a1 + 8));
  return sub_1000FF844(&v2);
}

void sub_101633C98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000FF844(va);
  _Unwind_Resume(a1);
}

uint64_t *sub_101633CAC(uint64_t *a1)
{
  v1 = *a1;
  v4 = a1;
  v5 = v1;
  Listener_sync = ctu::XpcServer::getListener_sync((*v1 + 8));
  xpc_connection_cancel(*Listener_sync);
  sub_1000FF844(&v5);
  return sub_1000049E0(&v4);
}

void sub_101633CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_101633D18(uint64_t **a1, unint64_t a2)
{
  v4 = (a1 + 1);
  v3 = a1[1];
  if (v3)
  {
    v5 = v4;
    v6 = v3;
    do
    {
      v7 = v6[4];
      v8 = v7 >= a2;
      v9 = v7 < a2;
      if (v8)
      {
        v5 = v6;
      }

      v6 = v6[v9];
    }

    while (v6);
    if (v5 != v4 && v5[4] <= a2)
    {
      v10 = v5[1];
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = *v10;
        }

        while (v10);
      }

      else
      {
        v12 = v5;
        do
        {
          v11 = v12[2];
          v13 = *v11 == v12;
          v12 = v11;
        }

        while (!v13);
      }

      if (*a1 == v5)
      {
        *a1 = v11;
      }

      a1[2] = (a1[2] - 1);
      sub_100018288(v3, v5);
      sub_101633A48((v5 + 4));

      operator delete(v5);
    }
  }
}

uint64_t sub_101633DF8(uint64_t a1)
{
  *a1 = off_101F5A328;
  if (*(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  v2 = *(a1 + 16);
  if (v2)
  {
    sub_100004A34(v2);
  }

  return a1;
}

void sub_101633E54(uint64_t a1)
{
  *a1 = off_101F5A328;
  if (*(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  v2 = *(a1 + 16);
  if (v2)
  {
    sub_100004A34(v2);
  }

  operator delete();
}

void sub_101633F7C(_Unwind_Exception *a1)
{
  v3 = v1[2];
  if (v3)
  {
    sub_100004A34(v3);
  }

  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_101633F9C(char *result, uint64_t a2)
{
  v3 = *(result + 1);
  v2 = *(result + 2);
  *a2 = off_101F5A328;
  *(a2 + 8) = v3;
  *(a2 + 16) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  v4 = *(result + 6);
  *(a2 + 28) = result[28];
  *(a2 + 24) = v4;
  if (result[55] < 0)
  {
    return sub_100005F2C((a2 + 32), *(result + 4), *(result + 5));
  }

  v5 = *(result + 2);
  *(a2 + 48) = *(result + 6);
  *(a2 + 32) = v5;
  return result;
}

void sub_101634028(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 16);
  if (v3)
  {
    sub_100004A34(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_101634048(void *a1)
{
  sub_1016341C0(a1 + 8);

  operator delete(a1);
}

void sub_101634084(uint64_t a1, uint64_t *a2)
{
  memset(v3, 0, sizeof(v3));
  sub_10003CF88(v3, *a2, a2[1], (a2[1] - *a2) >> 5);
  v7 = 0;
  sub_10003D138(&v7, v3);
  object = v7;
  if (v7)
  {
    xpc_retain(v7);
  }

  else
  {
    object = xpc_null_create();
  }

  v4[0] = *(a1 + 8);
  v4[1] = "kDataUsagePolicies";
  sub_1000609CC(v4, &object, &v6);
  xpc_release(v6);
  v6 = 0;
  xpc_release(object);
  object = 0;
  xpc_release(v7);
  v4[0] = v3;
  sub_10003CA58(v4);
}

void sub_10163415C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10003CA58(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101634174(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_1016341C0(uint64_t a1)
{
  if (*(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  v2 = *(a1 + 8);
  if (v2)
  {

    sub_100004A34(v2);
  }
}

uint64_t sub_101634214(uint64_t a1)
{
  *a1 = off_101F5A3A8;
  if (*(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  v2 = *(a1 + 16);
  if (v2)
  {
    sub_100004A34(v2);
  }

  return a1;
}

void sub_101634270(uint64_t a1)
{
  *a1 = off_101F5A3A8;
  if (*(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  v2 = *(a1 + 16);
  if (v2)
  {
    sub_100004A34(v2);
  }

  operator delete();
}

void sub_101634398(_Unwind_Exception *a1)
{
  v3 = v1[2];
  if (v3)
  {
    sub_100004A34(v3);
  }

  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_1016343B8(char *result, uint64_t a2)
{
  v3 = *(result + 1);
  v2 = *(result + 2);
  *a2 = off_101F5A3A8;
  *(a2 + 8) = v3;
  *(a2 + 16) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  v4 = *(result + 6);
  *(a2 + 28) = result[28];
  *(a2 + 24) = v4;
  if (result[55] < 0)
  {
    return sub_100005F2C((a2 + 32), *(result + 4), *(result + 5));
  }

  v5 = *(result + 2);
  *(a2 + 48) = *(result + 6);
  *(a2 + 32) = v5;
  return result;
}

void sub_101634444(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 16);
  if (v3)
  {
    sub_100004A34(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_101634464(void *a1)
{
  sub_1016341C0(a1 + 8);

  operator delete(a1);
}

void sub_1016344A0(uint64_t a1, uint64_t *a2)
{
  memset(v3, 0, sizeof(v3));
  sub_10003CF88(v3, *a2, a2[1], (a2[1] - *a2) >> 5);
  v7 = 0;
  sub_10003D138(&v7, v3);
  object = v7;
  if (v7)
  {
    xpc_retain(v7);
  }

  else
  {
    object = xpc_null_create();
  }

  v4[0] = *(a1 + 8);
  v4[1] = "kDataUsagePolicies";
  sub_1000609CC(v4, &object, &v6);
  xpc_release(v6);
  v6 = 0;
  xpc_release(object);
  object = 0;
  xpc_release(v7);
  v4[0] = v3;
  sub_10003CA58(v4);
}

void sub_101634578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10003CA58(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101634590(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1016345DC(uint64_t a1)
{
  *a1 = off_101F5A428;
  if (*(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  xpc_release(*(a1 + 16));
  *(a1 + 16) = 0;
  return a1;
}

void sub_10163463C(uint64_t a1)
{
  *a1 = off_101F5A428;
  if (*(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  xpc_release(*(a1 + 16));
  *(a1 + 16) = 0;

  operator delete();
}

void sub_101634778(_Unwind_Exception *a1)
{
  sub_1015575B0(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

xpc_object_t sub_101634798(uint64_t a1, uint64_t a2)
{
  v5 = *(a1 + 8);
  v4 = *(a1 + 16);
  *a2 = off_101F5A428;
  *(a2 + 8) = v5;
  *(a2 + 16) = v4;
  v6 = (a2 + 16);
  if (v4)
  {
    result = xpc_retain(v4);
  }

  else
  {
    result = xpc_null_create();
    *v6 = result;
  }

  v8 = *(a1 + 24);
  *(a2 + 28) = *(a1 + 28);
  *(a2 + 24) = v8;
  if (*(a1 + 55) < 0)
  {
    return sub_100005F2C((a2 + 32), *(a1 + 32), *(a1 + 40));
  }

  v9 = *(a1 + 32);
  *(a2 + 48) = *(a1 + 48);
  *(a2 + 32) = v9;
  return result;
}

void sub_101634850(uint64_t a1)
{
  if (*(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  xpc_release(*(a1 + 16));
  *(a1 + 16) = 0;
}

void sub_101634890(uint64_t a1)
{
  if (*(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  xpc_release(*(a1 + 16));

  operator delete(a1);
}

void sub_1016348E0(uint64_t a1, uint64_t *a2)
{
  memset(v6, 0, sizeof(v6));
  sub_10003CF88(v6, *a2, a2[1], (a2[1] - *a2) >> 5);
  v3 = *(a1 + 8);
  object = 0;
  sub_10003D138(&object, v6);
  v4 = object;
  if (object)
  {
    xpc_retain(object);
  }

  else
  {
    v4 = xpc_null_create();
  }

  v5 = *(a1 + 16);
  v7 = v5;
  if (v5)
  {
    xpc_retain(v5);
  }

  else
  {
    v7 = xpc_null_create();
  }

  sub_10003C80C(v3, v4, &v7, a1 + 24);
}

void sub_1016349D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, uint64_t *a14)
{
  xpc_release(v15);
  a12 = 0;
  xpc_release(v14);
  xpc_release(object);
  a14 = &a9;
  sub_10003CA58(&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_101634A24(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101634A70(uint64_t a1)
{
  *a1 = off_101F5A4A8;
  if (*(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  xpc_release(*(a1 + 16));
  *(a1 + 16) = 0;
  return a1;
}

void sub_101634AD0(uint64_t a1)
{
  *a1 = off_101F5A4A8;
  if (*(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  xpc_release(*(a1 + 16));
  *(a1 + 16) = 0;

  operator delete();
}

xpc_object_t sub_101634B50(uint64_t a1, uint64_t a2)
{
  v5 = *(a1 + 8);
  v4 = *(a1 + 16);
  *a2 = off_101F5A4A8;
  *(a2 + 8) = v5;
  *(a2 + 16) = v4;
  v6 = (a2 + 16);
  if (v4)
  {
    result = xpc_retain(v4);
  }

  else
  {
    result = xpc_null_create();
    *v6 = result;
  }

  v8 = *(a1 + 24);
  *(a2 + 28) = *(a1 + 28);
  *(a2 + 24) = v8;
  if (*(a1 + 55) < 0)
  {
    return sub_100005F2C((a2 + 32), *(a1 + 32), *(a1 + 40));
  }

  v9 = *(a1 + 32);
  *(a2 + 48) = *(a1 + 48);
  *(a2 + 32) = v9;
  return result;
}

void sub_101634C08(uint64_t a1)
{
  if (*(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  xpc_release(*(a1 + 16));
  *(a1 + 16) = 0;
}

uint64_t sub_101634C48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void *sub_101634C94(void *a1)
{
  *a1 = off_101F5A528;
  v2 = a1[2];
  if (v2)
  {
    sub_100004A34(v2);
  }

  return a1;
}

void sub_101634CE0(void *a1)
{
  *a1 = off_101F5A528;
  v1 = a1[2];
  if (v1)
  {
    sub_100004A34(v1);
  }

  operator delete();
}

uint64_t sub_101634DB8(uint64_t result, void *a2)
{
  v3 = *(result + 8);
  v2 = *(result + 16);
  *a2 = off_101F5A528;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_101634DF0(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    sub_100004A34(v1);
  }
}

void sub_101634E00(void *__p)
{
  v2 = __p[2];
  if (v2)
  {
    sub_100004A34(v2);
  }

  operator delete(__p);
}

void sub_101634E40(uint64_t a1, BOOL *a2)
{
  v4 = xpc_BOOL_create(*a2);
  if (!v4)
  {
    v4 = xpc_null_create();
  }

  v3[0] = *(a1 + 8);
  v3[1] = "kCUFirstNetworkUseFlowPeformedResult";
  sub_10000F688(v3, &v4, &object);
  xpc_release(object);
  object = 0;
  xpc_release(v4);
}

uint64_t sub_101634EC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_101634F10(void **a1)
{
  v1 = *a1;
  v30 = a1;
  v31 = v1;
  v2 = *v1;
  v33 = 0;
  v34 = 0;
  v32 = 0;
  sub_10003CF88(&v32, v1[1], v1[2], (v1[2] - v1[1]) >> 5);
  object[0] = 0;
  sub_10003D138(object, &v32);
  v3 = *(v2 + 96);
  if (v3 != (v2 + 104))
  {
    while (*(v3 + 44) == 1)
    {
      v4 = object[0];
      v41 = object[0];
      if (object[0])
      {
        xpc_retain(object[0]);
      }

      else
      {
        v4 = xpc_null_create();
        v41 = v4;
      }

      v15 = v3[4];
      v40 = v15;
      if (v15)
      {
        xpc_retain(v15);
      }

      else
      {
        v15 = xpc_null_create();
        v40 = v15;
      }

      sub_100035EDC(&v41, &v40);
      xpc_release(v15);
      v40 = 0;
      xpc_release(v4);
      v41 = 0;
LABEL_48:
      v26 = v3[1];
      if (v26)
      {
        do
        {
          v27 = v26;
          v26 = *v26;
        }

        while (v26);
      }

      else
      {
        do
        {
          v27 = v3[2];
          v28 = *v27 == v3;
          v3 = v27;
        }

        while (!v28);
      }

      v3 = v27;
      if (v27 == (v2 + 104))
      {
        goto LABEL_54;
      }
    }

    v38[0] = 0;
    v38[1] = 0;
    v39 = 0;
    ServiceMap = Registry::getServiceMap(*(v2 + 136));
    v6 = ServiceMap;
    if (v7 < 0)
    {
      v8 = (v7 & 0x7FFFFFFFFFFFFFFFLL);
      v9 = 5381;
      do
      {
        v7 = v9;
        v10 = *v8++;
        v9 = (33 * v9) ^ v10;
      }

      while (v10);
    }

    std::mutex::lock(ServiceMap);
    v43 = v7;
    v11 = sub_100009510(&v6[1].__m_.__sig, &v43);
    if (v11)
    {
      v13 = v11[3];
      v12 = v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v12);
        v14 = 0;
LABEL_18:
        (*(*v13 + 104))(v38, v13, *(v3 + 10));
        if ((v14 & 1) == 0)
        {
          sub_100004A34(v12);
        }

        v16 = v32;
        v17 = v33;
        if (SHIBYTE(v39) < 0)
        {
          sub_100005F2C(__p, v38[0], v38[1]);
        }

        else
        {
          *__p = *v38;
          v37 = v39;
        }

        v18 = HIBYTE(v37);
        if (v16 != v17)
        {
          if (v37 >= 0)
          {
            v19 = HIBYTE(v37);
          }

          else
          {
            v19 = __p[1];
          }

          if (v37 >= 0)
          {
            v20 = __p;
          }

          else
          {
            v20 = __p[0];
          }

          while (1)
          {
            v21 = *(v16 + 23);
            v22 = v21;
            if ((v21 & 0x80u) != 0)
            {
              v21 = *(v16 + 8);
            }

            if (v19 == v21)
            {
              v23 = v22 >= 0 ? v16 : *v16;
              if (!memcmp(v20, v23, v19))
              {
                break;
              }
            }

            v16 += 32;
            if (v16 == v17)
            {
              v16 = v17;
              break;
            }
          }
        }

        if (v18 < 0)
        {
          operator delete(__p[0]);
        }

        if (v16 != v33)
        {
          v35[3] = 0;
          if (*(v16 + 23) < 0)
          {
            sub_100005F2C(&__dst, *v16, *(v16 + 8));
          }

          else
          {
            v24 = *v16;
            v45 = *(v16 + 16);
            __dst = v24;
          }

          v25 = *(v16 + 24);
          v47 = *(v16 + 28);
          v46 = v25;
          memset(v35, 0, 24);
          object[1] = v35;
          object[2] = 0;
          operator new();
        }

        if (SHIBYTE(v39) < 0)
        {
          operator delete(v38[0]);
        }

        goto LABEL_48;
      }
    }

    else
    {
      v13 = 0;
    }

    std::mutex::unlock(v6);
    v12 = 0;
    v14 = 1;
    goto LABEL_18;
  }

LABEL_54:
  xpc_release(object[0]);
  v43 = &v32;
  sub_10003CA58(&v43);
  sub_101635528(&v31);
  return sub_1000049E0(&v30);
}

void sub_1016353D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, xpc_object_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, void *__p, uint64_t a32, int a33, __int16 a34, char a35, char a36, uint64_t a37, uint64_t a38, xpc_object_t object, char a40, uint64_t a41, uint64_t a42)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  sub_10004F058(exception_object);
}

uint64_t *sub_101635528(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    v2 = (v1 + 8);
    sub_10003CA58(&v2);
    operator delete();
  }

  return result;
}

void sub_101635588(uint64_t **a1)
{
  v7 = a1;
  v1 = *a1;
  v2 = **a1;
  v3 = (*a1)[1];
  v4 = (*a1)[2];
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 16), 1uLL, memory_order_relaxed);
  }

  v5 = *(v2 + 128);
  *(v2 + 120) = v3;
  *(v2 + 128) = v4;
  if (v5)
  {
    std::__shared_weak_count::__release_weak(v5);
  }

  v6 = v1[2];
  if (v6)
  {
    std::__shared_weak_count::__release_weak(v6);
  }

  operator delete();
}

uint64_t NetworkUsageStrategy::NetworkUsageStrategy(uint64_t a1, void *a2, void *a3, dispatch_object_t *a4)
{
  v8 = *a4;
  if (*a4)
  {
    dispatch_retain(*a4);
  }

  ctu::OsLogContext::OsLogContext(&v21, kCtLoggingSystemName, "cu.data.nwusage");
  if (v8)
  {
    dispatch_retain(v8);
    v9 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, 0);
    dispatch_retain(v8);
    dispatch_retain(v8);
    v10 = dispatch_queue_create_with_target_V2("NetworkUsage", v9, v8);
  }

  else
  {
    v11 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, 0);
    v10 = dispatch_queue_create("NetworkUsage", v11);
  }

  v12 = v10;
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  *(a1 + 24) = v10;
  if (v10)
  {
    dispatch_retain(v10);
  }

  *(a1 + 32) = v8;
  if (v8)
  {
    dispatch_retain(v8);
  }

  if (v12)
  {
    dispatch_release(v12);
  }

  if (v8)
  {
    dispatch_release(v8);
    dispatch_release(v8);
    dispatch_release(v8);
  }

  ctu::OsLogLogger::OsLogLogger(v22, &v21);
  ctu::OsLogLogger::OsLogLogger((a1 + 40), v22);
  ctu::OsLogLogger::~OsLogLogger(v22);
  ctu::OsLogContext::~OsLogContext(&v21);
  if (v8)
  {
    dispatch_release(v8);
  }

  *a1 = off_101F5A5A8;
  v13 = a2[1];
  *(a1 + 48) = *a2;
  *(a1 + 56) = v13;
  if (v13)
  {
    atomic_fetch_add_explicit((v13 + 16), 1uLL, memory_order_relaxed);
  }

  v14 = a3[1];
  *(a1 + 64) = *a3;
  *(a1 + 72) = v14;
  if (v14)
  {
    atomic_fetch_add_explicit((v14 + 8), 1uLL, memory_order_relaxed);
  }

  sub_10000501C(&__p, "NetworkUsage");
  v15 = *(a1 + 24);
  v18 = v15;
  if (v15)
  {
    dispatch_retain(v15);
  }

  object = *a4;
  if (*a4)
  {
    dispatch_retain(*a4);
  }

  ctu::RestModule::RestModule();
  if (object)
  {
    dispatch_release(object);
  }

  if (v18)
  {
    dispatch_release(v18);
  }

  if (v20 < 0)
  {
    operator delete(__p);
  }

  *(a1 + 112) = 0;
  *(a1 + 104) = 0;
  *(a1 + 96) = a1 + 104;
  *(a1 + 120) = -1;
  *(a1 + 136) = 0;
  *(a1 + 128) = a1 + 136;
  *(a1 + 168) = 0;
  *(a1 + 160) = 0;
  *(a1 + 144) = 0;
  *(a1 + 152) = a1 + 160;
  return a1;
}

void sub_101635854(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if (object)
  {
    dispatch_release(object);
  }

  if (a10)
  {
    dispatch_release(a10);
  }

  if (a16 < 0)
  {
    operator delete(__p);
  }

  v21 = v19[9];
  if (v21)
  {
    sub_100004A34(v21);
  }

  v22 = v19[7];
  if (v22)
  {
    std::__shared_weak_count::__release_weak(v22);
  }

  ctu::OsLogLogger::~OsLogLogger((v19 + 5));
  sub_1000C0544(v19 + 1);
  _Unwind_Resume(a1);
}

void NetworkUsageStrategy::~NetworkUsageStrategy(char **this)
{
  *this = off_101F5A5A8;
  sub_100009970((this + 19), this[20]);
  sub_10006DCAC((this + 16), this[17]);
  sub_100009970((this + 12), this[13]);
  v2 = this[11];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = this[9];
  if (v3)
  {
    sub_100004A34(v3);
  }

  v4 = this[7];
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }

  ctu::OsLogLogger::~OsLogLogger((this + 5));
  sub_1000C0544(this + 1);
}

void NetworkUsageStrategy::initialize(NetworkUsageStrategy *this)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_100004AA0(v1, this + 1);
  operator new();
}

void NetworkUsageStrategy::shutdown(NetworkUsageStrategy *this, group_session a2)
{
  v3 = *a2.var0.fObj;
  if (*a2.var0.fObj)
  {
    dispatch_retain(*a2.var0.fObj);
    dispatch_group_enter(v3);
  }

  v4[0] = 0;
  v4[1] = 0;
  sub_100004AA0(v4, this + 1);
  operator new();
}

void NetworkUsageStrategy::startCollect(NetworkUsageStrategy *this)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_100004AA0(v1, this + 1);
  operator new();
}

void NetworkUsageStrategy::stopCollect(NetworkUsageStrategy *this)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_100004AA0(v1, this + 1);
  operator new();
}

void NetworkUsageStrategy::getTetheringInfo(NetworkUsageStrategy *this@<X0>, void **a2@<X8>)
{
  v29 = this;
  if (!*(this + 4))
  {
    v27 = 1;
    goto LABEL_29;
  }

  if ((dispatch_workloop_is_current() & 1) == 0)
  {
    v27 = *(this + 4) == 0;
LABEL_29:
    v30[0] = _NSConcreteStackBlock;
    v30[1] = 0x40000000;
    v30[2] = sub_101638048;
    v30[3] = &unk_101F5A7B0;
    v30[4] = this + 8;
    v30[5] = &v29;
    v31 = v30;
    v28 = *(this + 3);
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    if (v27)
    {
      v33 = sub_10163820C;
      v34 = &unk_101F5A7D0;
      v35 = a2;
      v36 = &v31;
      dispatch_sync(v28, block);
    }

    else
    {
      v33 = sub_101638278;
      v34 = &unk_101F5A7F0;
      v35 = a2;
      v36 = &v31;
      dispatch_async_and_wait(v28, block);
    }

    return;
  }

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v4 = *(this + 16);
  v5 = this + 136;
  if (v4 != this + 136)
  {
    v6 = 0;
    do
    {
      InterfaceBytes = getInterfaceBytes(*(v4 + 10));
      v8 = *(v4 + 6);
      v9 = InterfaceBytes >= v8;
      v10 = InterfaceBytes - v8;
      if (v9)
      {
        v11 = v10;
      }

      else
      {
        v11 = 0;
      }

      v12 = a2[2];
      if (v6 >= v12)
      {
        v15 = *a2;
        v16 = v6 - *a2;
        v17 = 0xAAAAAAAAAAAAAAABLL * (v16 >> 3) + 1;
        if (v17 > 0xAAAAAAAAAAAAAAALL)
        {
          sub_1000CE3D4();
        }

        v18 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v15) >> 3);
        if (2 * v18 > v17)
        {
          v17 = 2 * v18;
        }

        if (v18 >= 0x555555555555555)
        {
          v19 = 0xAAAAAAAAAAAAAAALL;
        }

        else
        {
          v19 = v17;
        }

        if (v19)
        {
          sub_101637FF0(v19);
        }

        v20 = 8 * (v16 >> 3);
        v21 = *(v4 + 4);
        v22 = *(v4 + 11);
        *v20 = v11;
        *(v20 + 8) = v22;
        *(v20 + 16) = v21;
        v6 = v20 + 24;
        v23 = v20 - v16;
        memcpy((v20 - v16), v15, v16);
        *a2 = v23;
        a2[1] = v6;
        a2[2] = 0;
        if (v15)
        {
          operator delete(v15);
        }
      }

      else
      {
        v13 = *(v4 + 4);
        v14 = *(v4 + 11);
        *v6 = v11;
        *(v6 + 8) = v14;
        *(v6 + 16) = v13;
        v6 += 24;
      }

      a2[1] = v6;
      v24 = *(v4 + 1);
      if (v24)
      {
        do
        {
          v25 = v24;
          v24 = *v24;
        }

        while (v24);
      }

      else
      {
        do
        {
          v25 = *(v4 + 2);
          v26 = *v25 == v4;
          v4 = v25;
        }

        while (!v26);
      }

      v4 = v25;
    }

    while (v25 != v5);
  }
}

void sub_101635FF0(void *a1)
{
  if (v2)
  {
    *(v1 + 8) = v2;
    operator delete(v2);
  }

  sub_10004F058(a1);
}

void NetworkUsageStrategy::pollAndUpdateSources(NetworkUsageStrategy *this)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_100004AA0(v1, this + 1);
  operator new();
}

void NetworkUsageStrategy::setupThresholdMonitor_sync(Registry **this)
{
  if (!(*(*this + 9))(this))
  {
    return;
  }

  InternetInterfaceIndex = getInternetInterfaceIndex((this + 5), this + 8);
  v3 = *(this + 30);
  if (InternetInterfaceIndex != v3)
  {
    if ((v3 & 0x80000000) == 0)
    {
      v4 = this[5];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 0;
        _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Destroying internet threshold source", buf, 2u);
      }

      (*(*this + 7))(this);
    }

    v5 = this[5];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(this + 30);
      *buf = 67109376;
      *&buf[4] = v6;
      *&buf[8] = 1024;
      *&buf[10] = InternetInterfaceIndex;
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Internet interface index updated, old %d, new %d", buf, 0xEu);
    }

    *(this + 30) = InternetInterfaceIndex;
  }

  v7 = 0;
  *&buf[8] = 0;
  *&buf[16] = 0;
  *buf = &buf[8];
  *v72 = xmmword_1019A3250;
  do
  {
    v8 = *&v72[v7];
    TetheringInterfaceIndex = getTetheringInterfaceIndex(this + 5, this + 8, v8);
    if (TetheringInterfaceIndex < 0)
    {
      goto LABEL_27;
    }

    v10 = *buf;
    if (*buf != &buf[8])
    {
      while (*(v10 + 10) != TetheringInterfaceIndex)
      {
        v11 = *(v10 + 1);
        if (v11)
        {
          do
          {
            v12 = v11;
            v11 = *v11;
          }

          while (v11);
        }

        else
        {
          do
          {
            v12 = *(v10 + 2);
            v21 = *v12 == v10;
            v10 = v12;
          }

          while (!v21);
        }

        v10 = v12;
        if (v12 == &buf[8])
        {
          goto LABEL_20;
        }
      }

LABEL_27:
      v16 = this[5];
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *v73 = 134217984;
        v74 = v8;
        _os_log_impl(&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I No interface for 0x%0llX", v73, 0xCu);
      }

      goto LABEL_29;
    }

LABEL_20:
    getContextIdForType(this + 8, v8);
    v13 = *&buf[8];
    if (!*&buf[8])
    {
LABEL_26:
      operator new();
    }

    while (1)
    {
      while (1)
      {
        v14 = v13;
        v15 = v13[4];
        if (v15 <= v8)
        {
          break;
        }

        v13 = *v14;
        if (!*v14)
        {
          goto LABEL_26;
        }
      }

      if (v15 >= v8)
      {
        break;
      }

      v13 = v14[1];
      if (!v13)
      {
        goto LABEL_26;
      }
    }

LABEL_29:
    v7 += 8;
  }

  while (v7 != 16);
  v17 = (this + 16);
  if (*&buf[16] != this[18])
  {
    v19 = *v17;
    goto LABEL_52;
  }

  v18 = *buf;
  if (*buf == &buf[8])
  {
LABEL_49:
    sub_10006DCAC(buf, *&buf[8]);
    if (InternetInterfaceIndex != v3)
    {
      goto LABEL_111;
    }
  }

  else
  {
    v19 = *v17;
    v20 = *v17;
    while (1)
    {
      v21 = v18[4] == v20[4] && *(v18 + 10) == *(v20 + 10);
      if (!v21)
      {
        break;
      }

      v22 = v18[1];
      v23 = v18;
      if (v22)
      {
        do
        {
          v18 = v22;
          v22 = *v22;
        }

        while (v22);
      }

      else
      {
        do
        {
          v18 = v23[2];
          v21 = *v18 == v23;
          v23 = v18;
        }

        while (!v21);
      }

      v24 = v20[1];
      if (v24)
      {
        do
        {
          v25 = v24;
          v24 = *v24;
        }

        while (v24);
      }

      else
      {
        do
        {
          v25 = v20[2];
          v21 = *v25 == v20;
          v20 = v25;
        }

        while (!v21);
      }

      v20 = v25;
      if (v18 == &buf[8])
      {
        goto LABEL_49;
      }
    }

LABEL_52:
    v26 = (this + 17);
    if (v19 != this + 17)
    {
      do
      {
        v27 = *&buf[8];
        if (!*&buf[8])
        {
          goto LABEL_61;
        }

        v28 = v19[4];
        v29 = &buf[8];
        do
        {
          v30 = *(v27 + 32);
          v31 = v30 >= v28;
          v32 = v30 < v28;
          if (v31)
          {
            v29 = v27;
          }

          v27 = *(v27 + 8 * v32);
        }

        while (v27);
        if (v29 != &buf[8] && (v33 = *(v29 + 4), v28 >= v33))
        {
          if (v28 == v33 && *(v19 + 10) == *(v29 + 10))
          {
            *(v29 + 6) = v19[6];
          }

          else
          {
            v40 = this[5];
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
            {
              *v72 = 0;
              _os_log_error_impl(&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "context does not equal iterator", v72, 2u);
            }
          }
        }

        else
        {
LABEL_61:
          v34 = this[5];
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            v35 = v19[4];
            v36 = *(v19 + 10);
            *v72 = 134218240;
            *&v72[4] = v35;
            *&v72[12] = 1024;
            *&v72[14] = v36;
            _os_log_impl(&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Destroying tethering threshold source for 0x%08llX, current ifindex: %d", v72, 0x12u);
          }

          (*(*this + 8))(this, v19 + 4);
        }

        v37 = v19[1];
        if (v37)
        {
          do
          {
            v38 = v37;
            v37 = *v37;
          }

          while (v37);
        }

        else
        {
          do
          {
            v38 = v19[2];
            v21 = *v38 == v19;
            v19 = v38;
          }

          while (!v21);
        }

        v19 = v38;
      }

      while (v38 != v26);
    }

    if (v17 != buf)
    {
      v41 = *buf;
      if (this[18] && ((v42 = *v17, *v17 = v26, (*v26)[2] = 0, *v26 = 0, this[18] = 0, *(v42 + 8)) ? (v43 = *(v42 + 8)) : (v43 = v42), v43))
      {
        v44 = sub_1000685CC(v43);
        if (v41 == &buf[8])
        {
          v45 = v43;
          v51 = v41;
        }

        else
        {
          do
          {
            v45 = v44;
            v46 = *(v41 + 4);
            *(v43 + 32) = v46;
            *(v43 + 40) = *(v41 + 40);
            v47 = *v26;
            v48 = (this + 17);
            v49 = (this + 17);
            if (*v26)
            {
              do
              {
                while (1)
                {
                  v48 = v47;
                  if (v46 >= v47[4])
                  {
                    break;
                  }

                  v47 = *v47;
                  v49 = v48;
                  if (!*v48)
                  {
                    goto LABEL_91;
                  }
                }

                v47 = v47[1];
              }

              while (v47);
              v49 = v48 + 1;
            }

LABEL_91:
            sub_1000070DC(this + 16, v48, v49, v43);
            if (v44)
            {
              v44 = sub_1000685CC(v44);
            }

            else
            {
              v44 = 0;
            }

            v50 = *(v41 + 1);
            if (v50)
            {
              do
              {
                v51 = v50;
                v50 = *v50;
              }

              while (v50);
            }

            else
            {
              do
              {
                v51 = *(v41 + 2);
                v21 = *v51 == v41;
                v41 = v51;
              }

              while (!v21);
            }

            if (!v45)
            {
              break;
            }

            v43 = v45;
            v41 = v51;
          }

          while (v51 != &buf[8]);
        }

        sub_10006DCAC((this + 16), v45);
        if (v44)
        {
          for (i = v44[2]; i; i = i[2])
          {
            v44 = i;
          }

          sub_10006DCAC((this + 16), v44);
        }
      }

      else
      {
        v51 = v41;
      }

      if (v51 != &buf[8])
      {
        operator new();
      }
    }

    sub_10006DCAC(buf, *&buf[8]);
LABEL_111:
    if ((this[15] & 0x80000000) != 0)
    {
      v71 = this[5];
      if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
      {
        *buf = 0;
        _os_log_error_impl(&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "Unable to determine internet ifindex for threshold monitoring", buf, 2u);
      }
    }

    else
    {
      v53 = this[16];
      v54 = (this + 17);
      if (v53 != (this + 17))
      {
        do
        {
          v55 = *(v53 + 10);
          if (v55 < 0)
          {
            v61 = this[5];
            if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
            {
              v64 = *(v53 + 4);
              *buf = 67109376;
              *&buf[4] = v55;
              *&buf[8] = 2048;
              *&buf[10] = v64;
              _os_log_error_impl(&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "Tethering interface index (%d) is not valid for 0x%08llX", buf, 0x12u);
            }
          }

          else
          {
            InterfaceBytes = getInterfaceBytes(*(v53 + 10));
            *(v53 + 6) = InterfaceBytes;
            v57 = this[5];
            if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
            {
              v58 = *(v53 + 4);
              v59 = *(v53 + 10);
              v60 = *(v53 + 11);
              *buf = 134218752;
              *&buf[4] = v58;
              *&buf[12] = 1024;
              *&buf[14] = v59;
              *&buf[18] = 1024;
              *&buf[20] = v60;
              v76 = 2048;
              v77 = InterfaceBytes;
              _os_log_impl(&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I Tethering bytes for 0x%08llX, index %d and context %d starting at: %llu", buf, 0x22u);
            }
          }

          v62 = *(v53 + 1);
          if (v62)
          {
            do
            {
              v63 = v62;
              v62 = *v62;
            }

            while (v62);
          }

          else
          {
            do
            {
              v63 = *(v53 + 2);
              v21 = *v63 == v53;
              v53 = v63;
            }

            while (!v21);
          }

          v53 = v63;
        }

        while (v63 != v54);
        v53 = this[16];
      }

      if (v53 != v54)
      {
        do
        {
          v65 = this[5];
          if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
          {
            v66 = *(v53 + 4);
            v67 = *(v53 + 10);
            v68 = *(v53 + 11);
            *buf = 134218496;
            *&buf[4] = v66;
            *&buf[12] = 1024;
            *&buf[14] = v67;
            *&buf[18] = 1024;
            *&buf[20] = v68;
            _os_log_impl(&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "#I Threshold source 0x%08llX, Internet ifindex: %d, Tethering ifindex: %d", buf, 0x18u);
          }

          v69 = *(v53 + 1);
          if (v69)
          {
            do
            {
              v70 = v69;
              v69 = *v69;
            }

            while (v69);
          }

          else
          {
            do
            {
              v70 = *(v53 + 2);
              v21 = *v70 == v53;
              v53 = v70;
            }

            while (!v21);
          }

          v53 = v70;
        }

        while (v70 != v54);
      }

      (*(*this + 5))(this);
      (*(*this + 6))(this);
    }
  }
}

void NetworkUsageStrategy::updateTetheringDataUsage_sync(void *a1, uint64_t *a2)
{
  InterfaceBytes = getInterfaceBytes(*(a2 + 2));
  if (InterfaceBytes)
  {
    v5 = InterfaceBytes;
    v6 = a2[2];
    v7 = InterfaceBytes - v6;
    if (InterfaceBytes <= v6)
    {
      v14 = a1[5];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v15 = 134218240;
        v16 = v5;
        v17 = 2048;
        v18 = v6;
        _os_log_error_impl(&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Ignoring tethering bytes (%llu) since there has been no increase (%llu)", &v15, 0x16u);
      }
    }

    else
    {
      v8 = a1[7];
      if (v8)
      {
        v9 = *a2;
        v10 = *(a2 + 3);
        v11 = std::__shared_weak_count::lock(v8);
        if (v11)
        {
          v12 = v11;
          v13 = a1[6];
          if (v13)
          {
            (*(*v13 + 24))(v13, v9, v7, v10);
          }

          sub_100004A34(v12);
        }
      }

      a2[2] = v5;
    }
  }
}

void sub_101636C90(void *a1, void *a2)
{
  v38[0] = 0;
  v38[1] = 0;
  v37 = v38;
  v4 = (a1 + 12);
  v5 = a1[12];
  v6 = a1 + 13;
  v39 = &v37;
  v40 = v38;
  if (v5 == a1 + 13)
  {
    v10 = v38;
  }

  else
  {
    do
    {
      if (*(v5 + 55) < 0)
      {
        sub_100005F2C(__p, v5[4], v5[5]);
      }

      else
      {
        *__p = *(v5 + 2);
        *&__p[16] = v5[6];
      }

      sub_1016373A8(&v39, __p);
      if ((__p[23] & 0x80000000) != 0)
      {
        operator delete(*__p);
      }

      v7 = v5[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          v8 = v5[2];
          v9 = *v8 == v5;
          v5 = v8;
        }

        while (!v9);
      }

      v5 = v8;
    }

    while (v8 != v6);
    v10 = v37;
  }

  v12 = a2 + 1;
  v11 = *a2;
  v39 = &v37;
  v40 = v10;
  if (v11 != a2 + 1)
  {
    do
    {
      if (*(v11 + 55) < 0)
      {
        sub_100005F2C(__p, v11[4], v11[5]);
      }

      else
      {
        *__p = *(v11 + 2);
        *&__p[16] = v11[6];
      }

      sub_1016373A8(&v39, __p);
      if ((__p[23] & 0x80000000) != 0)
      {
        operator delete(*__p);
      }

      v13 = v11[1];
      if (v13)
      {
        do
        {
          v14 = v13;
          v13 = *v13;
        }

        while (v13);
      }

      else
      {
        do
        {
          v14 = v11[2];
          v9 = *v14 == v11;
          v11 = v14;
        }

        while (!v9);
      }

      v11 = v14;
    }

    while (v14 != v12);
    v10 = v37;
  }

  if (v10 == v38)
  {
    goto LABEL_85;
  }

  while (1)
  {
    v15 = sub_100007A6C(v4, v10 + 4);
    v16 = sub_100007A6C(a2, v10 + 4);
    if (v6 == v15)
    {
      break;
    }

    if (v12 == v16)
    {
      if (*(v15 + 64) && !*(v15 + 68))
      {
        v22 = a1[5];
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          v31 = *(v10 + 55);
          v32 = v31 < 0;
          if (v31 < 0)
          {
            v31 = v10[5];
          }

          if (v32)
          {
            v33 = v10[4];
          }

          else
          {
            v33 = (v10 + 4);
          }

          if (v31)
          {
            v27 = v33;
          }

          else
          {
            v27 = "<invalid>";
          }

          v28 = asStringBool(0);
          v29 = asStringBool(1);
LABEL_83:
          *__p = 136315650;
          *&__p[4] = v27;
          *&__p[12] = 2080;
          *&__p[14] = v28;
          *&__p[22] = 2080;
          v42 = v29;
          _os_log_impl(&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I IMS iWLAN over cell registration changed for personality: %s: %s -> %s", __p, 0x20u);
          goto LABEL_84;
        }

        goto LABEL_84;
      }
    }

    else
    {
      if (!*(v15 + 64))
      {
        if (*(v16 + 64) != 1 || *(v16 + 68))
        {
          goto LABEL_45;
        }

        v18 = 0;
        LOBYTE(v19) = 1;
LABEL_73:
        v22 = a1[5];
        if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          goto LABEL_84;
        }

        v34 = *(v10 + 55);
        v35 = v34 < 0;
        if (v34 < 0)
        {
          v34 = v10[5];
        }

        if (v35)
        {
          v36 = v10[4];
        }

        else
        {
          v36 = (v10 + 4);
        }

        if (v34)
        {
          v27 = v36;
        }

        else
        {
          v27 = "<invalid>";
        }

        v28 = asStringBool(v19);
        v29 = asStringBool(v18);
        goto LABEL_83;
      }

      v17 = *(v15 + 68);
      v18 = v17 == 0;
      if ((*(v16 + 64) & 1) == 0)
      {
        if (v17)
        {
          goto LABEL_45;
        }

        LOBYTE(v19) = 0;
        v18 = 1;
        goto LABEL_73;
      }

      v19 = *(v16 + 68) == 0;
      if ((v17 == 0) != v19)
      {
        goto LABEL_73;
      }
    }

LABEL_45:
    v20 = v10[1];
    if (v20)
    {
      do
      {
        v21 = v20;
        v20 = *v20;
      }

      while (v20);
    }

    else
    {
      do
      {
        v21 = v10[2];
        v9 = *v21 == v10;
        v10 = v21;
      }

      while (!v9);
    }

    v10 = v21;
    if (v21 == v38)
    {
      goto LABEL_85;
    }
  }

  if (*(v16 + 64) != 1 || *(v16 + 68))
  {
    goto LABEL_45;
  }

  v22 = a1[5];
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    v24 = *(v10 + 55);
    v25 = v24 < 0;
    if (v24 < 0)
    {
      v24 = v10[5];
    }

    if (v25)
    {
      v26 = v10[4];
    }

    else
    {
      v26 = (v10 + 4);
    }

    if (v24)
    {
      v27 = v26;
    }

    else
    {
      v27 = "<invalid>";
    }

    v28 = asStringBool(1);
    v29 = asStringBool(0);
    goto LABEL_83;
  }

LABEL_84:
  (*(*a1 + 80))(a1, 0);
LABEL_85:
  sub_100009970(&v37, v38[0]);
}

uint64_t sub_101637110(uint64_t a1)
{
  v2 = *(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(a1 + 120);
    *buf = 67109120;
    LODWORD(v21) = v3;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Internet Interface Index: %d", buf, 8u);
  }

  v4 = *(a1 + 128);
  if (v4 != (a1 + 136))
  {
    do
    {
      v5 = *(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        v6 = v4[4];
        v7 = *(v4 + 10);
        v8 = *(v4 + 11);
        v9 = v4[6];
        *buf = 134218752;
        v21 = v6;
        v22 = 1024;
        v23 = v7;
        v24 = 1024;
        v25 = v8;
        v26 = 2048;
        v27 = v9;
        _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Tethering Connection 0x%08llX, TetheringIfIndex: %d, TetheringContextID: %d, LastTetheringBytes: %llu", buf, 0x22u);
      }

      v10 = v4[1];
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = *v10;
        }

        while (v10);
      }

      else
      {
        do
        {
          v11 = v4[2];
          v12 = *v11 == v4;
          v4 = v11;
        }

        while (!v12);
      }

      v4 = v11;
    }

    while (v11 != (a1 + 136));
  }

  v13 = *(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Ignored UUIDs:", buf, 2u);
  }

  v14 = *(a1 + 152);
  if (v14 != (a1 + 160))
  {
    do
    {
      v15 = *(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v16 = v14 + 4;
        if (*(v14 + 55) < 0)
        {
          v16 = *v16;
        }

        *buf = 136315138;
        v21 = v16;
        _os_log_impl(&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
      }

      v17 = v14[1];
      if (v17)
      {
        do
        {
          v18 = v17;
          v17 = *v17;
        }

        while (v17);
      }

      else
      {
        do
        {
          v18 = v14[2];
          v12 = *v18 == v14;
          v14 = v18;
        }

        while (!v12);
      }

      v14 = v18;
    }

    while (v18 != (a1 + 160));
  }

  return (*(*a1 + 88))(a1);
}

uint64_t sub_1016373A8(uint64_t a1, void **a2)
{
  v5 = *a1;
  v4 = *(a1 + 8);
  v11 = 0;
  v12 = 0;
  v6 = *sub_100074A00(v5, v4, &v12, &v11, a2);
  if (!v6)
  {
    sub_1013B7784();
  }

  *(a1 + 8) = v6;
  v7 = v6[1];
  if (v7)
  {
    do
    {
      v8 = v7;
      v7 = *v7;
    }

    while (v7);
  }

  else
  {
    do
    {
      v8 = v6[2];
      v9 = *v8 == v6;
      v6 = v8;
    }

    while (!v9);
  }

  *(a1 + 8) = v8;
  return a1;
}

void sub_1016374B4(_Unwind_Exception *exception_object)
{
  if (byte_101FCAF57 < 0)
  {
    operator delete(qword_101FCAF40);
  }

  _Unwind_Resume(exception_object);
}

_BYTE *sub_1016374D8()
{
  sub_10000501C(byte_101FCAF70, "/Developer/usr/libexec/vpnagent");
  sub_10000501C(&byte_101FCAF70[24], "/usr/libexec/vpnagent");
  return sub_10000501C(byte_101FCAFA0, "/usr/sbin/pppd");
}

void sub_101637540(_Unwind_Exception *exception_object)
{
  while (1)
  {
    v4 = *(v2 - 1);
    v2 -= 3;
    if (v4 < 0)
    {
      operator delete(*v2);
    }

    if (v2 == v1)
    {
      _Unwind_Resume(exception_object);
    }
  }
}

void sub_101637568(Registry ****a1)
{
  v1 = **a1;
  Registry::createRestModuleOneTimeUseConnection(&v2, v1[8]);
  ctu::RestModule::connect();
  if (v3)
  {
    sub_100004A34(v3);
  }

  (*(*v1 + 2))(v1);
  sub_10000501C(&__p, "/cc/props/ims_registration_state");
  operator new();
}

__n128 sub_101637B6C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5A6C0;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_101637BA4(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v4 = v3 + 1;
  v5 = v3[1];
  v9 = *v3;
  v10 = v5;
  if (v3[2])
  {
    *(v5 + 16) = &v10;
    *v3 = v4;
    *v4 = 0;
    v3[2] = 0;
  }

  else
  {
    v9 = &v10;
  }

  sub_1008E2524(v3, a2);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  v6(v8, &v9);
  sub_100009970(&v9, v10);
}

uint64_t sub_101637C7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_101637D44(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5A740;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_101637D7C(void *a1)
{
  v1 = a1[2];
  v2 = a1[3];
  v3 = (a1[1] + (v2 >> 1));
  if (v2)
  {
    return (*(*v3 + v1))();
  }

  else
  {
    return v1(v3);
  }
}

uint64_t sub_101637DC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_101637E10(uint64_t *a1)
{
  v1 = *a1;
  v5 = a1;
  v6 = v1;
  v2 = *v1;
  v3 = *(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }

  ctu::RestModule::disconnect((v2 + 80));
  sub_1000FF844(&v6);
  return sub_1000049E0(&v5);
}

void sub_101637E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_101637EB0(void **a1)
{
  v1 = a1;
  (*(***a1 + 24))(**a1);
  operator delete();
}

void sub_101637F50(void **a1)
{
  v1 = a1;
  (*(***a1 + 32))(**a1);
  operator delete();
}

void sub_101637FF0(unint64_t a1)
{
  if (a1 < 0xAAAAAAAAAAAAAABLL)
  {
    operator new();
  }

  sub_100013D10();
}

void sub_101638048(uint64_t a1@<X0>, void **a2@<X8>)
{
  v3 = **(a1 + 40);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  v4 = *(v3 + 128);
  v5 = (v3 + 136);
  if (v4 != (v3 + 136))
  {
    v6 = 0;
    do
    {
      InterfaceBytes = getInterfaceBytes(*(v4 + 10));
      v8 = v4[6];
      v9 = InterfaceBytes >= v8;
      v10 = InterfaceBytes - v8;
      if (v9)
      {
        v11 = v10;
      }

      else
      {
        v11 = 0;
      }

      v12 = a2[2];
      if (v6 >= v12)
      {
        v15 = *a2;
        v16 = v6 - *a2;
        v17 = 0xAAAAAAAAAAAAAAABLL * (v16 >> 3) + 1;
        if (v17 > 0xAAAAAAAAAAAAAAALL)
        {
          sub_1000CE3D4();
        }

        v18 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v15) >> 3);
        if (2 * v18 > v17)
        {
          v17 = 2 * v18;
        }

        if (v18 >= 0x555555555555555)
        {
          v19 = 0xAAAAAAAAAAAAAAALL;
        }

        else
        {
          v19 = v17;
        }

        if (v19)
        {
          sub_101637FF0(v19);
        }

        v20 = 8 * (v16 >> 3);
        v21 = v4[4];
        v22 = *(v4 + 11);
        *v20 = v11;
        *(v20 + 8) = v22;
        *(v20 + 16) = v21;
        v6 = v20 + 24;
        v23 = v20 - v16;
        memcpy((v20 - v16), v15, v16);
        *a2 = v23;
        a2[1] = v6;
        a2[2] = 0;
        if (v15)
        {
          operator delete(v15);
        }
      }

      else
      {
        v13 = v4[4];
        v14 = *(v4 + 11);
        *v6 = v11;
        *(v6 + 8) = v14;
        *(v6 + 16) = v13;
        v6 += 24;
      }

      a2[1] = v6;
      v24 = v4[1];
      if (v24)
      {
        do
        {
          v25 = v24;
          v24 = *v24;
        }

        while (v24);
      }

      else
      {
        do
        {
          v25 = v4[2];
          v26 = *v25 == v4;
          v4 = v25;
        }

        while (!v26);
      }

      v4 = v25;
    }

    while (v25 != v5);
  }
}

void sub_1016381E4(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    *(v1 + 8) = v2;
    operator delete(v2);
  }

  _Unwind_Resume(exception_object);
}

double sub_10163820C(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v5);
  v2 = *(a1 + 32);
  v3 = *v2;
  if (*v2)
  {
    *(v2 + 8) = v3;
    operator delete(v3);
    *v2 = 0;
    *(v2 + 8) = 0;
    *(v2 + 16) = 0;
  }

  result = *&v5;
  *v2 = v5;
  *(v2 + 16) = v6;
  return result;
}

double sub_101638278(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v5);
  v2 = *(a1 + 32);
  v3 = *v2;
  if (*v2)
  {
    *(v2 + 8) = v3;
    operator delete(v3);
    *v2 = 0;
    *(v2 + 8) = 0;
    *(v2 + 16) = 0;
  }

  result = *&v5;
  *v2 = v5;
  *(v2 + 16) = v6;
  return result;
}

void sub_1016382E4(void **a1)
{
  v1 = a1;
  (*(***a1 + 80))(**a1, 0);
  operator delete();
}

void sub_101638474(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }

  if (v2)
  {
    operator delete();
  }

  _Unwind_Resume(exception_object);
}

unint64_t stewie::ServiceSearch::getOptimalTarget(uint64_t a1, uint64_t a2, double *a3)
{
  v4 = *(a1 + 32);
  if (v4 && (v7 = std::__shared_weak_count::lock(v4)) != 0)
  {
    v8 = v7;
    v9 = *(a1 + 24);
    if (v9)
    {
      v28 = 0;
      v29 = 0;
      (*(*v9 + 16))(&v28, v9);
      if (v28)
      {
        v10 = *(v28 + 16);
        if (v10 == (v28 + 24))
        {
          v22 = 0;
          LOBYTE(v12) = 0;
          v13 = 0;
        }

        else
        {
          v11 = 0;
          LOBYTE(v12) = 0;
          v13 = 0;
          v14 = 0;
          v15 = 0.0;
          v16 = 0;
          v17 = 0.0;
          do
          {
            v18 = v10[5];
            if (*(v18 + 12) != 1 || (v18[1] & 1) == 0)
            {
              v25 = 0;
              v26 = 0.0;
              v27 = 0;
              if ((*(*v9 + 24))(v9, *v18, a2, &v25))
              {
                if (v26 >= v17)
                {
                  v12 = *v18;
                  v11 = *v18 >> 8;
                  v13 = 1;
                  v14 = v25;
                  v16 = v27;
                  v15 = v26;
                  v17 = v26;
                }
              }
            }

            v19 = v10[1];
            if (v19)
            {
              do
              {
                v20 = v19;
                v19 = *v19;
              }

              while (v19);
            }

            else
            {
              do
              {
                v20 = v10[2];
                v21 = *v20 == v10;
                v10 = v20;
              }

              while (!v21);
            }

            v10 = v20;
          }

          while (v20 != (v28 + 24));
          v22 = (*&v11 & 0xFFFFFFLL) << 8;
          if (v13)
          {
            *a3 = v14;
            a3[1] = v15;
            *(a3 + 2) = v16;
          }
        }

        v23 = v12;
        v9 = v13 << 32;
      }

      else
      {
        v9 = 0;
        v23 = 0;
        v22 = 0;
      }

      if (v29)
      {
        sub_100004A34(v29);
      }
    }

    else
    {
      v22 = 0;
      v23 = 0;
    }

    sub_100004A34(v8);
  }

  else
  {
    v22 = 0;
    v23 = 0;
    v9 = 0;
  }

  return v23 | v22 | v9;
}

void stewie::ServiceSearch::getServiceWindow(uint64_t a1@<X0>, unint64_t *a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  if (*a2 > *a3)
  {
    *a4 = 0;
    *(a4 + 8) = 0;
    *(a4 + 16) = 0;
    *(a4 + 24) = 0;
    *(a4 + 32) = 0;
    return;
  }

  v6 = *(a1 + 32);
  if (v6)
  {
    v9 = std::__shared_weak_count::lock(v6);
    v10 = v9;
    if (v9)
    {
      v11 = *(a1 + 24);
      if (v11)
      {
        v30 = a4;
        v29 = a2;
        v12 = *(a1 + 8);
        v41 = 1000000000 * (*a2 / 0x3B9ACA00 - v12 - *a2 / 0x3B9ACA00 % v12);
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        v35 = *a3;
        v38[0] = *a3;
        v38[1] = v12;
        v38[2] = v11;
        v38[3] = v9;
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        v39 = 0;
        v38[4] = a1;
        v40 = 0;
        v31 = v9;
        sub_100004A34(v9);
        sub_101638C24(&buf, v38, &v41);
        v32 = 0;
        *&v33[8] = 0;
        v13 = buf;
        v39 = buf;
        BYTE4(v40) = BYTE12(buf);
        LODWORD(v40) = DWORD2(buf);
        v14 = BYTE12(buf);
        v36 = 0;
        v37 = 0;
        v15 = 1000000000 * v12;
        v34 = -1000000000 * v12;
        *v33 = BYTE12(buf);
        while (1)
        {
          while (1)
          {
            do
            {
              if (v13 >= v35)
              {
LABEL_43:
                stewie::ServiceWindow::ServiceWindow(v30, &v41, a3, v33[0] & 1, &v37, &v36);
                v10 = v31;
                sub_100004A34(v31);
                goto LABEL_46;
              }

              *v43 = v15 + v13;
              sub_101638C24(&buf, v38, v43);
              v13 = buf;
              v39 = buf;
              BYTE4(v40) = BYTE12(buf);
              LODWORD(v40) = DWORD2(buf);
            }

            while (BYTE12(buf) == v14);
            v16 = *a1;
            if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf) = 134217984;
              *(&buf + 4) = v13 / 0x3B9ACA00;
              _os_log_impl(&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I  - advance: detected service change at: %llu", &buf, 0xCu);
            }

            v17 = v13 + v34;
            LOBYTE(v18) = BYTE4(v40);
            v19 = BYTE4(v40);
            v20 = v13;
            if (v13 + v34 <= v13)
            {
              v21 = v13;
              do
              {
                *v43 = 1000000000 * (((v21 / 0x3B9ACA00 - v17 / 0x3B9ACA00) >> 1) + v17 / 0x3B9ACA00);
                sub_101638C24(&buf, v38, v43);
                v19 = BYTE12(buf);
                if (v14 == BYTE12(buf))
                {
                  v17 = *v43 + 1000000000;
                }

                else
                {
                  v21 = *v43 - 1000000000;
                }
              }

              while (v17 <= v21);
              v20 = buf;
            }

            v22 = v14 == v19 ? v20 + 1000000000 : v20;
            v23 = *a1;
            if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf) = 134217984;
              *(&buf + 4) = v22 / 0x3B9ACA00;
              _os_log_impl(&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I  - advance: second accurate change at: %llu", &buf, 0xCu);
            }

            buf = 0uLL;
            *v43 = v22 + v15;
            sub_101638C24(&buf, v38, v43);
            if (BYTE12(buf) == v14)
            {
              break;
            }

            v24 = *a1;
            if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
            {
              goto LABEL_32;
            }

LABEL_31:
            *v43 = 0;
            _os_log_impl(&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I  - advance: second accurate change is valid", v43, 2u);
LABEL_32:
            if (!v22)
            {
              goto LABEL_43;
            }

            if (v22 >= *v29)
            {
              if (v14)
              {
                if (*&v33[4])
                {
                  v28 = 271;
LABEL_50:
                  __assert_rtn("getServiceWindow", "ConnectionAssistantServiceSearch_watch_ios.cpp", v28, "false");
                }

                v27 = &v37;
              }

              else
              {
                if (v32)
                {
                  v28 = 278;
                  goto LABEL_50;
                }

                v27 = &v36;
              }

              *v27 = v22;
              v26 = v37;
              v32 = v36;
            }

            else
            {
              v41 = v22;
              v33[0] = v18;
              v26 = *&v33[4];
            }

            v14 = v18;
            *&v33[4] = v26;
            if (v26)
            {
              v14 = v18;
              if (v32)
              {
                goto LABEL_43;
              }
            }
          }

          v42 = v13 + v15;
          sub_101638C24(v43, v38, &v42);
          v13 = *v43;
          v39 = *v43;
          BYTE4(v40) = v45;
          LODWORD(v40) = v44;
          v18 = v45;
          v24 = *a1;
          v25 = os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT);
          if (v18 != v14)
          {
            if (!v25)
            {
              goto LABEL_32;
            }

            goto LABEL_31;
          }

          if (v25)
          {
            *v43 = 0;
            _os_log_impl(&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I  - advance: skipping short change", v43, 2u);
          }
        }
      }
    }
  }

  else
  {
    v10 = 0;
  }

  *a4 = 0;
  *(a4 + 8) = 0;
  *(a4 + 16) = 0;
  *(a4 + 24) = 0;
  *(a4 + 32) = 0;
  if (v10)
  {
LABEL_46:
    sub_100004A34(v10);
  }
}

void sub_101638BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  sub_100004A34(a13);
  sub_100004A34(a13);
  _Unwind_Resume(a1);
}

void sub_101638C24(void *a1, uint64_t a2, void *a3)
{
  v6 = **(a2 + 32);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *a3 / 0x3B9ACA00uLL;
    LODWORD(buf) = 134217984;
    *(&buf + 4) = v7;
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I  - getStateAt: %llu", &buf, 0xCu);
  }

  buf = 0uLL;
  v24 = 0;
  if (*(a2 + 52) == 1 && (*(**(a2 + 16) + 24))(*(a2 + 16), *(a2 + 48), a3, &buf))
  {
    v8 = **(a2 + 32);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if ((*(a2 + 52) & 1) == 0)
      {
        sub_1000D1644();
      }

      v9 = *(a2 + 48);
      *v21 = 67109120;
      *&v21[4] = v9;
      _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I  - getStateAt: reusing target id: %d", v21, 8u);
    }

    v10 = *(a2 + 48);
    *a1 = *a3;
    a1[1] = v10;
  }

  else
  {
    *v21 = 0;
    v22 = 0;
    (*(**(a2 + 16) + 16))(v21);
    if (!*v21 || (v11 = *(*v21 + 16), v11 == (*v21 + 24)))
    {
LABEL_24:
      v16 = 0;
      *a1 = *a3;
    }

    else
    {
      while (1)
      {
        v12 = v11[5];
        v13 = *(a2 + 52) == 1 && *v12 == *(a2 + 48);
        if (!v13 && (*(v12 + 12) != 1 || (*(v12 + 4) & 1) == 0) && (*(**(a2 + 16) + 24))(*(a2 + 16)))
        {
          break;
        }

        v14 = v11[1];
        if (v14)
        {
          do
          {
            v15 = v14;
            v14 = *v14;
          }

          while (v14);
        }

        else
        {
          do
          {
            v15 = v11[2];
            v13 = *v15 == v11;
            v11 = v15;
          }

          while (!v13);
        }

        v11 = v15;
        if (v15 == (*v21 + 24))
        {
          goto LABEL_24;
        }
      }

      v17 = **(a2 + 32);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        v18 = *v11[5];
        v20[0] = 67109120;
        v20[1] = v18;
        _os_log_impl(&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I  - getStateAt: tracking target id: %d", v20, 8u);
      }

      v19 = *v11[5];
      *a1 = *a3;
      v16 = v19 | &_mh_execute_header;
    }

    a1[1] = v16;
    if (v22)
    {
      sub_100004A34(v22);
    }
  }
}

void stewie::ServiceSearch::getServicePlot(uint64_t a1@<X0>, unint64_t *a2@<X1>, unint64_t *a3@<X2>, void *a4@<X3>, _OWORD *a5@<X8>)
{
  if (*a2 > *a3)
  {
    a5[1] = 0u;
    a5[2] = 0u;
    *a5 = 0u;
    return;
  }

  v7 = *(a1 + 32);
  if (v7)
  {
    v9 = a3;
    v11 = std::__shared_weak_count::lock(v7);
    if (v11)
    {
      v12 = *(a1 + 24);
      if (v12)
      {
        v63 = 0;
        v64 = 0;
        (*(*v12 + 16))(&v63, v12);
        if (v63)
        {
          v13 = *(a1 + 16);
          v14 = 1000000000 * *a2 / 0x3B9ACA00 / v13 * v13;
          __p[0] = 0;
          __p[1] = 0;
          v58 = v14;
          v15 = ((*v9 / 0x3B9ACA00 - v14 / 0x3B9ACA00) / v13);
          v62 = 0;
          v16 = v15 * 1.6;
          v57 = v11;
          if (v16)
          {
            if (v16 <= 0x666666666666666)
            {
              sub_1016397F4(__p, v16);
            }

            sub_1016397DC();
          }

          v17 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 134217984;
            *(&buf + 4) = 0;
            _os_log_impl(&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I getServicePlot: reserved space for %zu readings", &buf, 0xCu);
          }

          v59 = v9;
          if (*a4 && a4[1] && a4[2])
          {
            v18 = a4[3];
            v19 = a4[4];
            v20 = v58;
            if (v18 != v19)
            {
              v20 = v58;
              do
              {
                v21 = *v18;
                if (*v18 >= v20)
                {
                  v22 = __p[1];
                  if (__p[1] >= v62)
                  {
                    v24 = __p[0];
                    v25 = 0xCCCCCCCCCCCCCCCDLL * ((__p[1] - __p[0]) >> 3) + 1;
                    if (v25 > 0x666666666666666)
                    {
                      sub_1016397DC();
                    }

                    if (0x999999999999999ALL * ((v62 - __p[0]) >> 3) > v25)
                    {
                      v25 = 0x999999999999999ALL * ((v62 - __p[0]) >> 3);
                    }

                    if (0xCCCCCCCCCCCCCCCDLL * ((v62 - __p[0]) >> 3) >= 0x333333333333333)
                    {
                      v26 = 0x666666666666666;
                    }

                    else
                    {
                      v26 = v25;
                    }

                    if (v26)
                    {
                      sub_1016397F4(__p, v26);
                    }

                    v27 = 8 * ((__p[1] - __p[0]) >> 3);
                    *v27 = v21;
                    *(v27 + 8) = *(v18 + 2);
                    *(v27 + 16) = *(v18 + 1);
                    *(v27 + 32) = v18[4];
                    if (v24 != v22)
                    {
                      v28 = v24;
                      v29 = v27 + v24 - v22;
                      do
                      {
                        *v29 = *v28;
                        *(v29 + 8) = *(v28 + 2);
                        *(v29 + 16) = *(v28 + 1);
                        *(v29 + 32) = *(v28 + 4);
                        v28 += 40;
                        v29 += 40;
                      }

                      while (v28 != v22);
                    }

                    v23 = (v27 + 40);
                    __p[0] = (v27 + v24 - v22);
                    __p[1] = (v27 + 40);
                    v62 = 0;
                    if (v24)
                    {
                      operator delete(v24);
                    }
                  }

                  else
                  {
                    *__p[1] = v21;
                    *(v22 + 2) = *(v18 + 2);
                    *(v22 + 1) = *(v18 + 1);
                    *(v22 + 4) = v18[4];
                    v23 = v22 + 40;
                  }

                  __p[1] = v23;
                  v20 = *v18;
                }

                v18 += 5;
              }

              while (v18 != v19);
            }

            if (__p[0] != __p[1])
            {
              v30 = *a1;
              if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(buf) = 134217984;
                *(&buf + 4) = 0xCCCCCCCCCCCCCCCDLL * ((__p[1] - __p[0]) >> 3);
                _os_log_impl(&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I getServicePlot: reused %zu readings", &buf, 0xCu);
              }

              v20 += 1000000000 * *(a1 + 16);
            }

            v9 = v59;
          }

          else
          {
            v31 = *a1;
            v20 = v58;
            if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              _os_log_impl(&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I getServicePlot: lastKnownPlot is invalid, skipping", &buf, 2u);
              v20 = v58;
            }
          }

          v32 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl(&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I getServicePlot [", &buf, 2u);
          }

          v56 = a5;
          v60 = v20;
          v33 = *v9;
          if (v20 < *v9)
          {
            v34 = v63;
            do
            {
              v35 = *(v34 + 16);
              if (v35 != (v34 + 24))
              {
                do
                {
                  v36 = v35[5];
                  if (*(v36 + 12) != 1 || (v36[1] & 1) == 0)
                  {
                    buf = 0uLL;
                    v70 = 0;
                    if ((*(*v12 + 24))(v12, *v36, &v60, &buf))
                    {
                      v37 = *a1;
                      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
                      {
                        v38 = *v36;
                        *v65 = 67109376;
                        v66 = v38;
                        v67 = 2048;
                        v68 = *(&buf + 1) * 180.0 / 3.14159265;
                        _os_log_impl(&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I  - getServicePlot: id: %d, service: %.2f", v65, 0x12u);
                      }

                      v39 = *v36;
                      v40 = buf;
                      v41 = v70;
                      v42 = __p[1];
                      if (__p[1] >= v62)
                      {
                        v44 = __p[0];
                        v45 = 0xCCCCCCCCCCCCCCCDLL * ((__p[1] - __p[0]) >> 3) + 1;
                        if (v45 > 0x666666666666666)
                        {
                          sub_1016397DC();
                        }

                        if (0x999999999999999ALL * ((v62 - __p[0]) >> 3) > v45)
                        {
                          v45 = 0x999999999999999ALL * ((v62 - __p[0]) >> 3);
                        }

                        if (0xCCCCCCCCCCCCCCCDLL * ((v62 - __p[0]) >> 3) >= 0x333333333333333)
                        {
                          v46 = 0x666666666666666;
                        }

                        else
                        {
                          v46 = v45;
                        }

                        if (v46)
                        {
                          sub_1016397F4(__p, v46);
                        }

                        v47 = 8 * ((__p[1] - __p[0]) >> 3);
                        *v47 = v60;
                        *(v47 + 8) = v39;
                        *(v47 + 16) = v40;
                        *(v47 + 32) = v41;
                        if (v44 != v42)
                        {
                          v48 = v44;
                          v49 = v47 + v44 - v42;
                          do
                          {
                            *v49 = *v48;
                            *(v49 + 8) = *(v48 + 2);
                            *(v49 + 16) = *(v48 + 1);
                            *(v49 + 32) = *(v48 + 4);
                            v48 += 40;
                            v49 += 40;
                          }

                          while (v48 != v42);
                        }

                        v43 = (v47 + 40);
                        __p[0] = (v47 + v44 - v42);
                        __p[1] = (v47 + 40);
                        v62 = 0;
                        if (v44)
                        {
                          operator delete(v44);
                        }
                      }

                      else
                      {
                        *__p[1] = v60;
                        *(v42 + 2) = v39;
                        *(v42 + 1) = v40;
                        v43 = v42 + 40;
                        *(v42 + 4) = v41;
                      }

                      __p[1] = v43;
                    }
                  }

                  v50 = v35[1];
                  if (v50)
                  {
                    do
                    {
                      v51 = v50;
                      v50 = *v50;
                    }

                    while (v50);
                  }

                  else
                  {
                    do
                    {
                      v51 = v35[2];
                      v52 = *v51 == v35;
                      v35 = v51;
                    }

                    while (!v52);
                  }

                  v34 = v63;
                  v35 = v51;
                }

                while (v51 != (v63 + 24));
                v20 = v60;
                v33 = *v59;
              }

              v20 += 1000000000 * *(a1 + 16);
              v60 = v20;
            }

            while (v20 < v33);
          }

          v53 = *a1;
          v54 = os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT);
          v55 = *__p;
          if (v54)
          {
            LODWORD(buf) = 134217984;
            *(&buf + 4) = 0xCCCCCCCCCCCCCCCDLL * ((__p[1] - __p[0]) >> 3);
            _os_log_impl(&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I getServicePlot ] - %zu readings", &buf, 0xCu);
            v33 = *v59;
            v55 = *__p;
          }

          *v56 = v58;
          *(v56 + 1) = v58;
          *(v56 + 2) = v33;
          *(v56 + 24) = v55;
          *(v56 + 5) = v62;
          v11 = v57;
        }

        else
        {
          a5[1] = 0u;
          a5[2] = 0u;
          *a5 = 0u;
        }

        if (v64)
        {
          sub_100004A34(v64);
        }

        goto LABEL_42;
      }
    }
  }

  else
  {
    v11 = 0;
  }

  a5[1] = 0u;
  a5[2] = 0u;
  *a5 = 0u;
LABEL_42:
  if (v11)
  {
    sub_100004A34(v11);
  }
}

void sub_10163978C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, std::__shared_weak_count *a22)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a22)
  {
    sub_100004A34(a22);
  }

  sub_100004A34(a10);
  _Unwind_Resume(a1);
}

void sub_1016397F4(uint64_t a1, unint64_t a2)
{
  if (a2 < 0x666666666666667)
  {
    operator new();
  }

  sub_100013D10();
}

void sub_1016398BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10)
  {
    sub_101639960(&a10, v10);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016398E0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101639920(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

void sub_101639960(int a1, ctu::OsLogLogger *this)
{
  if (this)
  {
    v3 = *(this + 4);
    if (v3)
    {
      std::__shared_weak_count::__release_weak(v3);
    }

    ctu::OsLogLogger::~OsLogLogger(this);

    operator delete();
  }
}

void sub_1016399BC(void *a1, void *a2)
{
  v5 = @"Roadside";
  memset(__p, 0, sizeof(__p));
  sub_10005B328(__p, &v5, &v6, 1uLL);
  sub_101644F28(a1, a2, "stw.rs.env");
}

void sub_101639AE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
  {
    operator delete(__p);
  }

  sub_101647298(v14);
  _Unwind_Resume(a1);
}

void sub_101639B2C(uint64_t a1, _BYTE *a2)
{
  v4 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Setting up environment", &__p, 2u);
  }

  v5 = sub_101639D04(a1);
  v7 = v6;
  v8 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (v7)
    {
      std::to_string(&__p, v5);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        p_p = &__p;
      }

      else
      {
        p_p = __p.__r_.__value_.__r.__words[0];
      }

      *buf = 136446210;
      v12 = p_p;
      _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Found stored providerId: %{public}s", buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    else
    {
      *buf = 136446210;
      v12 = "<none>";
      _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Found stored providerId: %{public}s", buf, 0xCu);
    }
  }

  sub_10164531C(a1, (a2 + 8), *a2 & v7 & 1);
  if (((*(a1 + 272) == 0) & v7) == 1)
  {
    sub_10079CC68(a1 + 280);
  }
}

const void *sub_101639D04(uint64_t a1)
{
  v4 = 0;
  sub_10007B7D8(a1 + 280);
  sub_10010B240(&v4, &v5);
  sub_10000A1EC(&v5);
  if (v4)
  {
    v5 = 0;
    ctu::cf::assign(&v5, v4, v1);
    v2 = v5;
    sub_100029A48(&v4);
  }

  else
  {
    sub_100029A48(&v4);
    return 0;
  }

  return v2;
}

void sub_101639DAC(uint64_t a1, uint64_t a2)
{
  v3 = [NSNumber numberWithUnsignedLongLong:a2];
  sub_10079CC40(a1 + 280);
}

void sub_101639E3C(uint64_t a1)
{
  sub_101646E5C(a1);
  v2 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(a1 + 273) == 1 && *(a1 + 88))
    {
      v3 = "false";
      if (*(a1 + 152) && *(a1 + 168))
      {
        v3 = "true";
      }
    }

    else
    {
      v3 = "false";
    }

    v8 = 136315138;
    v9 = v3;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Ready: %s", &v8, 0xCu);
  }

  v4 = sub_101639D04(a1);
  if (v5)
  {
    v6 = v4;
    v7 = sub_100032AC8((a1 + 8));
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 134217984;
      v9 = v6;
      _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [d] Provider Id: %llu", &v8, 0xCu);
    }
  }
}

void *sub_101639F94(void *a1)
{
  *a1 = off_101F5A8D8;
  v2 = a1[36];
  a1[36] = 0;
  if (v2)
  {
    (*(*v2 + 32))(v2);
  }

  TMKXPCServer.shutdown()();

  return sub_101647298(a1);
}

void sub_10163A020(void *a1)
{
  sub_101639F94(a1);

  operator delete();
}

uint64_t sub_10163A058(uint64_t a1, uint64_t a2)
{
  (*(*a1 + 80))(a1, 0);
  (*(*a1 + 80))(a1, ++byte_101FCAFB8);
  (*(*a1 + 80))(a1, 0);
  __p = 0;
  v10 = 0;
  v11 = 0;
  CSIPhoneNumber::getBaseNumber(&__p, (a1 + 8));
  v4 = HIBYTE(v11);
  if (v11 < 0)
  {
    v4 = v10;
  }

  (*(*a1 + 80))(a1, (((v4 + 1) >> 1) + 1));
  TypeOfAddress = CSIPhoneNumber::getTypeOfAddress((a1 + 8));
  (*(*a1 + 80))(a1, TypeOfAddress);
  if (v11 >= 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p;
  }

  (*(*a1 + 112))(a1, p_p);
  if (SHIBYTE(v11) < 0)
  {
    operator delete(__p);
  }

  v7 = *(*a1 + 80);

  return v7(a1, a2);
}

void sub_10163A22C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_10163A248(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  sub_10163A058(a1, a3);
  v5 = *(a2 + 23);
  if (v5 < 0)
  {
    LODWORD(v5) = *(a2 + 2);
    a2 = *a2;
  }

  sub_10164066C(a2, v5, __p);
  if ((v9 & 0x80u) == 0)
  {
    v6 = __p;
  }

  else
  {
    v6 = __p[0];
  }

  if ((v9 & 0x80u) == 0)
  {
    v7 = v9;
  }

  else
  {
    v7 = __p[1];
  }

  std::string::append((a1 + 328), v6, v7);
  if (v9 < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_10163A2D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_10163A2F4(uint64_t a1)
{
  v2 = a1 + 328;
  if (*(a1 + 351) < 0)
  {
    *(a1 + 336) = 0;
    v3 = *(a1 + 328);
  }

  else
  {
    *(a1 + 351) = 0;
    v3 = (a1 + 328);
  }

  *v3 = 0;
  (*(*a1 + 88))(a1);
  v12 = 0;
  v10[0] = 0;
  v10[1] = 0;
  v11 = 0;
  (*(*a1 + 48))(v10, a1, &v12);
  if (*(a1 + 351) < 0)
  {
    *(a1 + 336) = 0;
    v4 = *(a1 + 328);
  }

  else
  {
    *(a1 + 351) = 0;
    v4 = v2;
  }

  *v4 = 0;
  sub_10163A058(a1, v12);
  v9 = 0;
  __p[0] = 0;
  __p[1] = 0;
  v8 = 0;
  (*(*a1 + 48))(__p, a1, &v9);
  sub_100168A48(__p, v10, &v5);
  if (*(a1 + 351) < 0)
  {
    operator delete(*v2);
  }

  *v2 = v5;
  *(v2 + 16) = v6;
  if (SHIBYTE(v8) < 0)
  {
    operator delete(__p[0]);
  }

  if (SHIBYTE(v11) < 0)
  {
    operator delete(v10[0]);
  }
}

void sub_10163A45C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  if (*(v18 - 25) < 0)
  {
    operator delete(*(v18 - 48));
  }

  _Unwind_Resume(exception_object);
}

void sub_10163A494(uint64_t a1, unsigned __int8 *a2, int a3)
{
  v6 = (a1 + 328);
  if (*(a1 + 351) < 0)
  {
    *(a1 + 336) = 0;
    v7 = *(a1 + 328);
  }

  else
  {
    *(a1 + 351) = 0;
    v7 = (a1 + 328);
  }

  *v7 = 0;
  (*(*a1 + 80))(a1, 2);
  (*(*a1 + 80))(a1, *a2);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  LOBYTE(v26) = 0;
  sub_1001CD884(&v30, &v26);
  v29 = 0;
  v8 = a2[31];
  if ((v8 & 0x80u) != 0)
  {
    v8 = *(a2 + 2);
  }

  if (v8 || (a3 & 1) != 0)
  {
    if (v8)
    {
      v9 = 7;
    }

    else
    {
      v9 = 3;
    }

    if (!a3)
    {
      v9 = 4;
    }

    v29 = v9;
  }

  sub_1001CD884(&v30, &v29);
  if (a3)
  {
    sub_1001CD884(&v30, a2 + 1);
    sub_1001CD884(&v30, a2 + 2);
  }

  LODWORD(v10) = a2[31];
  if ((v10 & 0x80000000) != 0)
  {
    v10 = *(a2 + 2);
    if (!v10)
    {
      goto LABEL_28;
    }
  }

  else if (!a2[31])
  {
    goto LABEL_28;
  }

  LOBYTE(v26) = v10;
  sub_1001CD884(&v30, &v26);
  v11 = a2[31];
  v12 = *(a2 + 2);
  if ((v11 & 0x80u) == 0)
  {
    v13 = a2 + 8;
  }

  else
  {
    v13 = *(a2 + 1);
  }

  if ((v11 & 0x80u) == 0)
  {
    v14 = v11;
  }

  else
  {
    v14 = v12;
  }

  for (; v14; --v14)
  {
    LOBYTE(v26) = *v13;
    sub_1001CD884(&v30, &v26);
    ++v13;
  }

LABEL_28:
  v26 = 0;
  v27 = 0;
  v28 = 0;
  ctu::hex();
  ctu::hex0(&__p, 0x41, v15);
  if ((v25 & 0x80u) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p;
  }

  if ((v25 & 0x80u) == 0)
  {
    v17 = v25;
  }

  else
  {
    v17 = v24;
  }

  std::string::append(v6, p_p, v17);
  if (v25 < 0)
  {
    operator delete(__p);
  }

  ctu::hex0(&__p, (v31 - v30), v18);
  if ((v25 & 0x80u) == 0)
  {
    v19 = &__p;
  }

  else
  {
    v19 = __p;
  }

  if ((v25 & 0x80u) == 0)
  {
    v20 = v25;
  }

  else
  {
    v20 = v24;
  }

  std::string::append(v6, v19, v20);
  if (v25 < 0)
  {
    operator delete(__p);
  }

  if (v28 >= 0)
  {
    v21 = &v26;
  }

  else
  {
    v21 = v26;
  }

  if (v28 >= 0)
  {
    v22 = HIBYTE(v28);
  }

  else
  {
    v22 = v27;
  }

  std::string::append(v6, v21, v22);
  if (SHIBYTE(v28) < 0)
  {
    operator delete(v26);
  }

  if (v30)
  {
    v31 = v30;
    operator delete(v30);
  }
}

void sub_10163A714(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, void *__p, uint64_t a23)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10163A77C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(a1 + 351) < 0)
  {
    *(a1 + 336) = 0;
    v6 = *(a1 + 328);
  }

  else
  {
    v6 = (a1 + 328);
    *(a1 + 351) = 0;
  }

  *v6 = 0;
  (*(*a1 + 80))(a1, 4);
  (*(*a1 + 80))(a1, a2);
  (*(*a1 + 80))(a1, 2);
  (*(*a1 + 80))(a1, a3);
  v7 = *(*a1 + 80);

  return v7(a1, 0);
}

uint64_t sub_10163A8B4(uint64_t a1)
{
  if (*(a1 + 351) < 0)
  {
    *(a1 + 336) = 0;
    v2 = *(a1 + 328);
  }

  else
  {
    v2 = (a1 + 328);
    *(a1 + 351) = 0;
  }

  *v2 = 0;
  (*(*a1 + 80))(a1, 6);
  ++byte_101FCAFB8;
  v3 = *(*a1 + 80);
  v4 = byte_101FCAFB8;

  return v3(a1, v4);
}

void sub_10163A968(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v15[0] = 0;
  v15[1] = 0;
  ctu::TextConverter::TextConverter(v15);
  v14 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  (*(*a1 + 48))(&v11, a1, &v14);
  if (v13 >= 0)
  {
    v4 = &v11;
  }

  else
  {
    v4 = v11;
  }

  if (v13 >= 0)
  {
    v5 = HIBYTE(v13);
  }

  else
  {
    v5 = v12;
  }

  ctu::TextConverter::setSource(v15, v4, v5);
  ctu::TextConverter::pushConversion();
  __p = 0;
  v9 = 0;
  v10 = 0;
  ctu::TextConverter::readChars(&__p, v15, 0x7FFFFFFFuLL);
  if (v10 >= 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p;
  }

  if (v10 >= 0)
  {
    v7 = HIBYTE(v10);
  }

  else
  {
    v7 = v9;
  }

  sub_10110506C(a2, p_p, &p_p[v7], v7);
  if (SHIBYTE(v10) < 0)
  {
    operator delete(__p);
  }

  if (SHIBYTE(v13) < 0)
  {
    operator delete(v11);
  }

  ctu::TextConverter::~TextConverter(v15);
}

void sub_10163AA90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  if (a21 < 0)
  {
    operator delete(a16);
  }

  ctu::TextConverter::~TextConverter((v22 - 48));
  v24 = *v21;
  if (*v21)
  {
    *(v21 + 8) = v24;
    operator delete(v24);
  }

  _Unwind_Resume(a1);
}

void sub_10163AAEC(SmsPduEncoder *a1)
{
  SmsPduEncoder::~SmsPduEncoder(a1);

  operator delete();
}

void ImsSmsPduDecoder::ImsSmsPduDecoder(ImsSmsPduDecoder *this)
{
  SmsPduDecoder::SmsPduDecoder(this);
  *v2 = &off_101F5AB48;
  *(v2 + 788) = 0;
  *(v2 + 736) = 0u;
  *(v2 + 752) = 0u;
  *(v2 + 768) = 0u;
  CSIPhoneNumber::CSIPhoneNumber((v2 + 792));
  *(this + 952) = 0;
}

void sub_10163AB90(_Unwind_Exception *a1)
{
  v4 = *(v1 + 95);
  if (v4)
  {
    *(v1 + 96) = v4;
    operator delete(v4);
  }

  v5 = *v2;
  if (*v2)
  {
    *(v1 + 93) = v5;
    operator delete(v5);
  }

  SmsPduDecoder::~SmsPduDecoder(v1);
  _Unwind_Resume(a1);
}

void sub_10163ABC4(void **this)
{
  *this = &off_101F5AB48;
  if (*(this + 943) < 0)
  {
    operator delete(this[115]);
  }

  if (*(this + 919) < 0)
  {
    operator delete(this[112]);
  }

  if (*(this + 879) < 0)
  {
    operator delete(this[107]);
  }

  if (*(this + 847) < 0)
  {
    operator delete(this[103]);
  }

  if (*(this + 823) < 0)
  {
    operator delete(this[100]);
  }

  v2 = this[95];
  if (v2)
  {
    this[96] = v2;
    operator delete(v2);
  }

  v3 = this[92];
  if (v3)
  {
    this[93] = v3;
    operator delete(v3);
  }

  SmsPduDecoder::~SmsPduDecoder(this);
}

void sub_10163AC88(void **a1)
{
  sub_10163ABC4(a1);

  operator delete();
}

uint64_t ImsSmsPduDecoder::decodeRpMessage(uint64_t a1, uint64_t a2)
{
  v4 = *a2;
  v3 = *(a2 + 8);
  if (*a2 != v3)
  {
    v6 = (a1 + 736);
    if (a1 + 736 != a2)
    {
      sub_1001122C4((a1 + 736), *a2, v3, v3 - v4);
      v4 = *a2;
      v3 = *(a2 + 8);
    }

    v34 = 0;
    v35 = 0;
    v36 = 0;
    sub_10164066C(v4, v3 - v4, &v34);
    if (v36 >= 0)
    {
      v7 = &v34;
    }

    else
    {
      v7 = v34;
    }

    if (v36 >= 0)
    {
      v8 = HIBYTE(v36);
    }

    else
    {
      v8 = v35;
    }

    ctu::TextConverter::setSource((a1 + 16), v7, v8);
    v33 = 0;
    v9 = SmsPduDecoder::decodeOctet(a1, &v33);
    if ((v9 & 1) == 0)
    {
      v10 = *(a1 + 8);
      v11 = 0;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 0;
        _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Incoming direction is not MT", buf, 2u);
        v11 = 0;
      }

      goto LABEL_53;
    }

    *(a1 + 784) = v9 & 6;
    if ((v9 & 6u) > 3)
    {
      if ((v9 & 6) != 4)
      {
        v20 = *(a1 + 8);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 136315138;
          *&buf[4] = "RP-SMMA";
          _os_log_impl(&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Invalid message type: %s", buf, 0xCu);
        }

        *(a1 + 42) = 1;
        goto LABEL_52;
      }

      *buf = 0;
      *(a1 + 788) = SmsPduDecoder::decodeOctet(a1, buf);
      v15 = SmsPduDecoder::decodeOctet(a1, buf);
      if ((v15 - 3) > 0xFFFFFFFD)
      {
        *(a1 + 952) = SmsPduDecoder::decodeOctet(a1, buf);
      }

      else
      {
        *(a1 + 42) = 1;
        v16 = *(a1 + 8);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v38[0]) = 67109120;
          HIDWORD(v38[0]) = v15;
          v14 = "RP-ERROR decode failed - Invalid Cause Element Length: Expected: [1-2], Actual: %d";
          v17 = v38;
          v18 = v16;
          v19 = 8;
LABEL_51:
          _os_log_impl(&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v14, v17, v19);
        }
      }
    }

    else if ((v9 & 6) != 0)
    {
      *buf = 0;
      *(a1 + 788) = SmsPduDecoder::decodeOctet(a1, buf);
    }

    else
    {
      v37 = 0;
      *(a1 + 788) = SmsPduDecoder::decodeOctet(a1, &v37);
      SmsPduDecoder::decodeSmscInfo(a1);
      if (*(a1 + 42) == 1)
      {
        v13 = *(a1 + 8);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 0;
          v14 = "SMSC info could not be parsed";
LABEL_50:
          v17 = buf;
          v18 = v13;
          v19 = 2;
          goto LABEL_51;
        }
      }

      else
      {
        SmsPduDecoder::getOriginatingServiceCenter(buf, a1);
        *(a1 + 792) = *buf;
        v21 = (a1 + 800);
        if (*(a1 + 823) < 0)
        {
          operator delete(*v21);
        }

        *v21 = *&buf[8];
        *(a1 + 816) = v41;
        HIBYTE(v41) = 0;
        buf[8] = 0;
        v22 = (a1 + 824);
        if (*(a1 + 847) < 0)
        {
          operator delete(*v22);
        }

        *v22 = v42;
        *(a1 + 840) = v43;
        HIBYTE(v43) = 0;
        LOBYTE(v42) = 0;
        *(a1 + 848) = v44;
        *(a1 + 852) = v45;
        v23 = (a1 + 856);
        if (*(a1 + 879) < 0)
        {
          operator delete(*v23);
        }

        *v23 = v46;
        *(a1 + 872) = v47;
        HIBYTE(v47) = 0;
        LOBYTE(v46) = 0;
        *(a1 + 880) = v48;
        *(a1 + 888) = v49;
        v24 = (a1 + 896);
        if (*(a1 + 919) < 0)
        {
          operator delete(*v24);
        }

        *v24 = __p;
        *(a1 + 912) = v51;
        HIBYTE(v51) = 0;
        LOBYTE(__p) = 0;
        v25 = (a1 + 920);
        if (*(a1 + 943) < 0)
        {
          operator delete(*(a1 + 920));
          v26 = SHIBYTE(v51);
          *v25 = v52;
          *(a1 + 936) = v53;
          HIBYTE(v53) = 0;
          LOBYTE(v52) = 0;
          *(a1 + 944) = v54;
          if (v26 < 0)
          {
            operator delete(__p);
          }
        }

        else
        {
          *v25 = v52;
          *(a1 + 936) = v53;
          HIBYTE(v53) = 0;
          LOBYTE(v52) = 0;
          *(a1 + 944) = v54;
        }

        if (SHIBYTE(v47) < 0)
        {
          operator delete(v46);
        }

        if (SHIBYTE(v43) < 0)
        {
          operator delete(v42);
        }

        if (SHIBYTE(v41) < 0)
        {
          operator delete(*&buf[8]);
        }

        if (!SmsPduDecoder::decodeOctet(a1, &v37))
        {
          SmsPduDecoder::decodeOctet(a1, &v37);
          SourceCount = ctu::TextConverter::getSourceCount((a1 + 16));
          v29 = *v6;
          v30 = (SourceCount + (SourceCount >> 31)) >> 1;
          memset(buf, 0, sizeof(buf));
          sub_100A23D78(buf, v29, v29 + SourceCount / 2, v30);
          sub_10000501C(v38, "RP-DATA");
          ImsSmsPduDecoder::logPdu(a1, buf, v38);
          if (v39 < 0)
          {
            operator delete(v38[0]);
          }

          v31 = *(a1 + 736);
          v32 = *(a1 + 744);
          if (&v32[-v31] > v30)
          {
            sub_10080F604((a1 + 760), (v31 + v30), v32, &v32[-v31 - v30]);
            sub_10000501C(v38, "TPDU");
            ImsSmsPduDecoder::logPdu(a1, a1 + 760, v38);
            if (v39 < 0)
            {
              operator delete(v38[0]);
            }
          }

          if (*buf)
          {
            *&buf[8] = *buf;
            operator delete(*buf);
          }

          goto LABEL_52;
        }

        *(a1 + 42) = 1;
        v13 = *(a1 + 8);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 0;
          v14 = "RP-DATA decode failed - Non-Zero RP-Terminating-Address length";
          goto LABEL_50;
        }
      }
    }

LABEL_52:
    v11 = *(a1 + 42) ^ 1;
LABEL_53:
    if (SHIBYTE(v36) < 0)
    {
      operator delete(v34);
    }

    return v11 & 1;
  }

  v12 = *(a1 + 8);
  v11 = 0;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Incoming PDU is empty", buf, 2u);
    v11 = 0;
  }

  return v11 & 1;
}

void sub_10163B27C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, void *a25, uint64_t a26)
{
  if (a23 < 0)
  {
    operator delete(__p);
  }

  if (a25)
  {
    operator delete(a25);
  }

  if (a16 < 0)
  {
    operator delete(a11);
  }

  _Unwind_Resume(exception_object);
}

void ImsSmsPduDecoder::logPdu(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v11[0] = 0;
  v11[1] = 0;
  ctu::TextConverter::TextConverter(v11);
  ctu::TextConverter::pushConversion();
  ctu::TextConverter::setSource(v11, *a2, *(a2 + 8) - *a2);
  __p[0] = 0;
  __p[1] = 0;
  v10 = 0;
  ctu::TextConverter::readChars(__p, v11, 0x7FFFFFFFuLL);
  v6 = *(a1 + 8);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    if (*(a3 + 23) >= 0)
    {
      v7 = a3;
    }

    else
    {
      v7 = *a3;
    }

    v8 = __p;
    if (v10 < 0)
    {
      v8 = __p[0];
    }

    *buf = 136315395;
    v13 = v7;
    v14 = 2085;
    v15 = v8;
    _os_log_debug_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "3GPP MT SMS %s (hex): %{sensitive}s", buf, 0x16u);
  }

  if (SHIBYTE(v10) < 0)
  {
    operator delete(__p[0]);
  }

  ctu::TextConverter::~TextConverter(v11);
}

void sub_10163B424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  ctu::TextConverter::~TextConverter(va);
  _Unwind_Resume(a1);
}

BOOL sub_10163B4CC(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 40);
  if (!v2)
  {
    return 0;
  }

  v3 = *(v2 + 272);
  v4 = *(v2 + 104);
  if (v3)
  {
    v5 = *(a1 + 26);
    if (v5 == (v4 + 1))
    {
      return 0;
    }
  }

  else
  {
    v5 = *(a1 + 26);
  }

  return v5 != v4;
}

BOOL sub_10163B508(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 40);
  if (!v2)
  {
    return 0;
  }

  v3 = *(v2 + 272);
  v4 = *(v2 + 104);
  if (v3)
  {
    v5 = *(a1 + 10);
    if (v5 == (v4 + 1))
    {
      return 0;
    }
  }

  else
  {
    v5 = *(a1 + 10);
  }

  return v5 != v4;
}

uint64_t sub_10163B554(uint64_t a1, os_log_t *a2)
{
  v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
  {
    v5 = sub_1011E88BC(*(a1 + 12));
    v6 = 136315138;
    v7 = v5;
    _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Compression is not supported for this message", &v6, 0xCu);
  }

  return __TUAssertTrigger();
}

void sub_10163B6A0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v6 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    v7 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v7;
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }

  v8 = *(a2 + 40);
  if (!v8)
  {
    v76 = *a2;
    if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
    {
      v79 = sub_1011E88BC(*(a1 + 12));
      *buf = 136315138;
      *&buf[4] = v79;
      v78 = "[%s] Roadside environment doesn't exist";
      goto LABEL_159;
    }

LABEL_157:
    *a3 = 0;
    *(a3 + 24) = 0;
    return;
  }

  if (*(v8 + 273) != 1 || !*(v8 + 88) || !*(v8 + 152) || !*(v8 + 168))
  {
    v76 = *a2;
    if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
    {
      v77 = sub_1011E88BC(*(a1 + 12));
      *buf = 136315138;
      *&buf[4] = v77;
      v78 = "[%s] Roadside environment is not ready";
LABEL_159:
      _os_log_error_impl(&_mh_execute_header, v76, OS_LOG_TYPE_ERROR, v78, buf, 0xCu);
      goto LABEL_157;
    }

    goto LABEL_157;
  }

  memset(__p, 0, 24);
  v9 = sub_101646CD0(v8);
  v10 = sub_101646540(*(a2 + 40));
  v11 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    v12 = sub_1011E88BC(*(a1 + 12));
    v13 = *(a1 + 26);
    if (v9 > 4)
    {
      v14 = "???";
    }

    else
    {
      v14 = off_101F5B908[v9];
    }

    v15 = *(a1 + 88);
    v16 = "no";
    v17 = *(a1 + 56);
    *buf = 136316674;
    if (v15)
    {
      v18 = "yes";
    }

    else
    {
      v18 = "no";
    }

    *&buf[4] = v12;
    if ((v10 & 0x100000000) != 0)
    {
      v19 = v10;
    }

    else
    {
      v19 = 0;
    }

    *&buf[12] = 1024;
    if (v17)
    {
      v16 = "yes";
    }

    *&buf[14] = v13;
    *&buf[18] = 2080;
    *&buf[20] = "kAny";
    *&buf[28] = 2080;
    *&buf[30] = v14;
    v86 = 2080;
    v87 = v18;
    v88 = 1024;
    v89 = v19;
    v90 = 2080;
    v91 = v16;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [%s] ConversationID: %hhu, lineID: %s, battery: %s, has questionnaire answer: %s, preferred codec id: %u, Has phone number: %s", buf, 0x40u);
  }

  memset(buf, 0, 32);
  sub_100E008CC(buf, 0xC8uLL);
  v20 = sub_100E415B0(*(a2 + 40));
  v21 = buf[24];
  if (v20)
  {
    v22 = *(a1 + 24);
    if (*&buf[24])
    {
      v23 = v22 & 3;
      if (*&buf[24] == 1)
      {
        *(*&buf[8] - 1) |= v23 >> 1;
        *&buf[24] += 6;
        v83[0] = v23 << buf[24];
        sub_1001CD884(buf, v83);
      }

      else
      {
        *&buf[24] -= 2;
        *(*&buf[8] - 1) |= v23 << (v21 - 2);
      }
    }

    else
    {
      *&buf[24] = 6;
      v83[0] = v22 << 6;
      sub_1001CD884(buf, v83);
    }

    v26 = buf[24];
    if (*&buf[24])
    {
      if (*&buf[24] >= 6uLL)
      {
        *&buf[24] -= 6;
        *(*&buf[8] - 1) |= 5 << (v26 - 6);
      }

      else
      {
        *(*&buf[8] - 1) |= 5u >> (6 - buf[24]);
        *&buf[24] += 2;
        v83[0] = 5 << buf[24];
        sub_1001CD884(buf, v83);
      }
    }

    else
    {
      *&buf[24] = 2;
      v83[0] = 20;
      sub_1001CD884(buf, v83);
    }

    v30 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      v31 = sub_1011E88BC(*(a1 + 12));
      v32 = *(a1 + 24);
      if (v32 > 4)
      {
        v33 = "???";
      }

      else
      {
        v33 = off_101F5B8E0[v32];
      }

      *v83 = 136315650;
      *&v83[4] = v31;
      *&v83[12] = 2080;
      *&v83[14] = v33;
      *&v83[22] = 2080;
      v84 = "kFakeRoadsideStart";
      v37 = "#I [%s] Mock mode is enabled. Serialized header: Version: %s, MessageType: %s";
      v38 = v30;
      v39 = 32;
LABEL_52:
      _os_log_impl(&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, v83, v39);
    }
  }

  else
  {
    v24 = *(a1 + 24);
    if (*&buf[24])
    {
      v25 = v24 & 3;
      if (*&buf[24] == 1)
      {
        *(*&buf[8] - 1) |= v25 >> 1;
        *&buf[24] += 6;
        v83[0] = v25 << buf[24];
        sub_1001CD884(buf, v83);
      }

      else
      {
        *&buf[24] -= 2;
        *(*&buf[8] - 1) |= v25 << (v21 - 2);
      }
    }

    else
    {
      *&buf[24] = 6;
      v83[0] = v24 << 6;
      sub_1001CD884(buf, v83);
    }

    v27 = *(a1 + 25);
    v28 = buf[24];
    if (*&buf[24])
    {
      v29 = v27 & 0x3F;
      if (*&buf[24] >= 6uLL)
      {
        *&buf[24] -= 6;
        *(*&buf[8] - 1) |= v29 << (v28 - 6);
      }

      else
      {
        *(*&buf[8] - 1) |= v29 >> (6 - buf[24]);
        *&buf[24] += 2;
        v83[0] = v29 << buf[24];
        sub_1001CD884(buf, v83);
      }
    }

    else
    {
      *&buf[24] = 2;
      v83[0] = 4 * v27;
      sub_1001CD884(buf, v83);
    }

    v34 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      v35 = *(a1 + 24);
      if (v35 > 4)
      {
        v36 = "???";
      }

      else
      {
        v36 = off_101F5B8E0[v35];
      }

      v40 = sub_1011E88E0(*(a1 + 25));
      *v83 = 136315394;
      *&v83[4] = v36;
      *&v83[12] = 2080;
      *&v83[14] = v40;
      v37 = "#I Serialized header: Version: %s, MessageType: %s";
      v38 = v34;
      v39 = 22;
      goto LABEL_52;
    }
  }

  v41 = *(a1 + 26);
  v42 = buf[24];
  if (*&buf[24])
  {
    if (*&buf[24] >= 8uLL)
    {
      *&buf[24] -= 8;
      *(*&buf[8] - 1) |= v41 << (v42 - 8);
    }

    else
    {
      *(*&buf[8] - 1) |= v41 >> (8 - buf[24]);
      v83[0] = v41 << buf[24];
      sub_1001CD884(buf, v83);
    }
  }

  else
  {
    v83[0] = *(a1 + 26);
    sub_1001CD884(buf, v83);
  }

  v43 = *(a2 + 40);
  v44 = *(v43 + 88);
  v45 = *(v43 + 96);
  if (v45)
  {
    atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  sub_1015C41A4(v44, a2, buf);
  v46 = buf[24];
  if (*&buf[24])
  {
    v47 = v9 & 3;
    if (*&buf[24] == 1)
    {
      *(*&buf[8] - 1) |= (v9 & 3) >> 1;
      *&buf[24] += 6;
      v83[0] = v47 << buf[24];
      sub_1001CD884(buf, v83);
    }

    else
    {
      *&buf[24] -= 2;
      *(*&buf[8] - 1) |= v47 << (v46 - 2);
    }
  }

  else
  {
    *&buf[24] = 6;
    v83[0] = v9 << 6;
    sub_1001CD884(buf, v83);
  }

  if (*&buf[24] == 1)
  {
    *&buf[24] = 7;
    v83[0] = 0;
    sub_1001CD884(buf, v83);
    goto LABEL_69;
  }

  if (!*&buf[24])
  {
    *&buf[24] = 6;
    v83[0] = 0;
    sub_1001CD884(buf, v83);
LABEL_69:
    v48 = *&buf[24];
    goto LABEL_71;
  }

  v48 = *&buf[24] - 2;
LABEL_71:
  v49 = *(a1 + 56);
  if (v48)
  {
    *&buf[24] = v48 - 1;
    *(*&buf[8] - 1) |= v49 << (v48 - 1);
  }

  else
  {
    *&buf[24] = 7;
    v83[0] = v49 << 7;
    sub_1001CD884(buf, v83);
  }

  if (*(a1 + 56) != 1)
  {
    v52 = buf[24];
    if (*&buf[24] == 1)
    {
      *(*&buf[8] - 1) |= 1u;
      *&buf[24] += 6;
      v83[0] = 3 << buf[24];
      sub_1001CD884(buf, v83);
    }

    else if (*&buf[24])
    {
      *&buf[24] -= 2;
      *(*&buf[8] - 1) |= 3 << (v52 - 2);
    }

    else
    {
      *&buf[24] = 6;
      v83[0] = -64;
      sub_1001CD884(buf, v83);
    }

    if (*&buf[24])
    {
      if (!--*&buf[24])
      {
        goto LABEL_97;
      }

LABEL_94:
      __TUAssertTrigger();
      if (*&buf[24])
      {
        if (*&buf[24] >= 4uLL)
        {
          *&buf[24] -= 4;
          if ((v10 & 0x100000000) != 0)
          {
            goto LABEL_99;
          }

          goto LABEL_101;
        }

        *&buf[24] |= 4uLL;
        v83[0] = 0;
        sub_1001CD884(buf, v83);
LABEL_98:
        if ((v10 & 0x100000000) != 0)
        {
LABEL_99:
          sub_100E66080(buf, v10);
          goto LABEL_105;
        }

LABEL_101:
        if (*&buf[24])
        {
          if (*&buf[24] <= 3uLL)
          {
            *&buf[24] |= 4uLL;
            v83[0] = 0;
            sub_1001CD884(buf, v83);
          }
        }

        else
        {
          *&buf[24] = 4;
          v83[0] = 0;
          sub_1001CD884(buf, v83);
        }

LABEL_105:
        v55 = *(a1 + 30);
        *&buf[24] = 7;
        v83[0] = v55 << 7;
        sub_1001CD884(buf, v83);
        v56 = *(a1 + 28);
        v57 = buf[24];
        if (*&buf[24])
        {
          v58 = (v56 >> 8) & 0x7F;
          if (*&buf[24] >= 7uLL)
          {
            *&buf[24] -= 7;
            *(*&buf[8] - 1) |= v58 << (v57 - 7);
          }

          else
          {
            *(*&buf[8] - 1) |= v58 >> (7 - buf[24]);
            ++*&buf[24];
            v83[0] = v58 << buf[24];
            sub_1001CD884(buf, v83);
          }
        }

        else
        {
          *&buf[24] = 1;
          v83[0] = (v56 >> 7) & 0xFE;
          sub_1001CD884(buf, v83);
        }

        v59 = buf[24];
        if (*&buf[24])
        {
          if (*&buf[24] >= 8uLL)
          {
            *&buf[24] -= 8;
            *(*&buf[8] - 1) |= v56 << (v59 - 8);
          }

          else
          {
            *(*&buf[8] - 1) |= v56 >> (8 - buf[24]);
            v83[0] = v56 << buf[24];
            sub_1001CD884(buf, v83);
          }
        }

        else
        {
          v83[0] = v56;
          sub_1001CD884(buf, v83);
        }

        sub_101639DAC(*(a2 + 40), *(a1 + 28));
        if (*&buf[24])
        {
          __TUAssertTrigger();
        }

        if (*(a1 + 88) == 1)
        {
          sub_1006AD8F0(v83, *(a1 + 64), *(a1 + 72), buf);
        }

        v60 = *__p;
        *__p = *buf;
        *buf = v60;
        v61 = __p[2];
        __p[2] = *&buf[16];
        *&buf[16] = v61;
        if (v45)
        {
          sub_100004A34(v45);
          v62 = *buf;
          if (!*buf)
          {
            goto LABEL_122;
          }
        }

        else
        {
          v62 = v60;
          if (!v60)
          {
LABEL_122:
            v63 = *(a2 + 40);
            v65 = *(v63 + 168);
            v64 = *(v63 + 176);
            if (v64)
            {
              atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
            }

            memset(v83, 0, sizeof(v83));
            buf[0] = *__p[0];
            buf[1] = *(__p[0] + 1);
            *&buf[6] = 0;
            *&buf[2] = 0;
            memset(v83, 0, sizeof(v83));
            sub_1000DCF88(v83, buf, &buf[8], 8);
            v66 = __p[0];
            v67 = __p[1] - __p[0];
            if ((__p[1] - __p[0]) <= 2)
            {
              __TUAssertTrigger();
              v66 = __p[0];
              v67 = __p[1] - __p[0];
            }

            memset(buf, 0, 32);
            sub_101335AF4(a2, v65, v83, v66 + 2, v67 - 2, buf);
            v68 = buf[24];
            if (buf[24])
            {
              v69 = __p[0];
              v70 = __p[1] - __p[0];
              if (__p[1] - __p[0] != *&buf[8] - *buf + 2)
              {
                __TUAssertTrigger();
                v69 = __p[0];
                v70 = __p[1] - __p[0];
              }

              if (v70 > 1)
              {
                if (v70 != 2)
                {
                  __p[1] = v69 + 2;
                }
              }

              else
              {
                sub_10018D3CC(__p, 2 - v70);
              }

              if ((buf[24] & 1) == 0)
              {
                sub_1000D1644();
              }

              v72 = *buf;
              v73 = *&buf[8];
              while (v72 != v73)
              {
                sub_1001CD884(__p, v72++);
              }
            }

            else
            {
              v71 = *a2;
              if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
              {
                v74 = sub_1011E88BC(*(a1 + 12));
                *v81 = 136315138;
                v82 = v74;
                _os_log_error_impl(&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "[%s] Failed to encrypt", v81, 0xCu);
              }

              *a3 = 0;
              *(a3 + 24) = 0;
            }

            if (buf[24] == 1 && *buf)
            {
              *&buf[8] = *buf;
              operator delete(*buf);
            }

            if (*v83)
            {
              *&v83[8] = *v83;
              operator delete(*v83);
            }

            if (v64)
            {
              sub_100004A34(v64);
            }

            v54 = __p[0];
            if (v68)
            {
              *a3 = __p[0];
              *(a3 + 8) = *&__p[1];
              *(a3 + 24) = 1;
              return;
            }

            goto LABEL_143;
          }
        }

        *&buf[8] = v62;
        operator delete(v62);
        goto LABEL_122;
      }

LABEL_97:
      *&buf[24] = 4;
      v83[0] = 0;
      sub_1001CD884(buf, v83);
      goto LABEL_98;
    }

    *&buf[24] = 7;
    v83[0] = 0;
    sub_1001CD884(buf, v83);
LABEL_93:
    if (!*&buf[24])
    {
      goto LABEL_97;
    }

    goto LABEL_94;
  }

  v50 = sub_10172B414((a1 + 32));
  if (v51)
  {
    sub_100F275BC(buf, v50);
    goto LABEL_93;
  }

  v53 = *a2;
  if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
  {
    v75 = sub_1011E88BC(*(a1 + 12));
    *v83 = 136315138;
    *&v83[4] = v75;
    _os_log_error_impl(&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "[%s] Failed to encode phone number", v83, 0xCu);
  }

  *a3 = 0;
  *(a3 + 24) = 0;
  if (v45)
  {
    sub_100004A34(v45);
  }

  if (*buf)
  {
    *&buf[8] = *buf;
    operator delete(*buf);
  }

  v54 = __p[0];
LABEL_143:
  if (v54)
  {
    __p[1] = v54;
    operator delete(v54);
  }
}

void sub_10163C408(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, char a22)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (v22)
  {
    sub_100004A34(v22);
  }

  if (a9)
  {
    operator delete(a9);
  }

  _Unwind_Resume(exception_object);
}

void sub_10163C4CC(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 40);
  if (v3)
  {

    sub_101646044(v3);
  }

  else
  {
    v4 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
    {
      v5 = sub_1011E88BC(*(a1 + 12));
      v6 = 136315138;
      v7 = v5;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "[%s] Roadside environment doesn't exist", &v6, 0xCu);
    }
  }
}

BOOL sub_10163C644(void *a1, uint64_t a2)
{
  if (!*(a2 + 40))
  {
    return 0;
  }

  v3 = *(a2 + 48);
  v6[0] = *(a2 + 40);
  v6[1] = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  if (sub_100F54B40(a2, v6) == 3 && a1[4] != a1[5])
  {
    v4 = a1[8] == 0;
    if (!v3)
    {
      return v4;
    }

    goto LABEL_9;
  }

  v4 = 0;
  if (v3)
  {
LABEL_9:
    sub_100004A34(v3);
  }

  return v4;
}

void sub_10163C6E0(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10163C700(uint64_t a1, uint64_t a2)
{
  if (*(a1 + 32) == *(a1 + 40))
  {
    __TUAssertTrigger();
  }

  v4 = *(a1 + 64);
  if (v4)
  {
    v7 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
    {
      v9 = sub_1011E88BC(*(a1 + 12));
      v10 = "complete";
      if (!*v4)
      {
        v10 = "in progress";
      }

      *buf = 136315394;
      v13 = v9;
      v14 = 2080;
      v15 = v10;
      _os_log_error_impl(&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "[%s] Compression attempt is already %s", buf, 0x16u);
    }

    return __TUAssertTrigger();
  }

  v5 = *(a2 + 40);
  if (!v5)
  {
    v8 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
    {
      v11 = sub_1011E88BC(*(a1 + 12));
      *buf = 136315138;
      v13 = v11;
      _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "[%s] Roadside environment doesn't exist", buf, 0xCu);
    }

    return __TUAssertTrigger();
  }

  if ((sub_101646540(v5) & 0x100000000) != 0)
  {
    operator new();
  }

  return __TUAssertTrigger();
}

BOOL sub_10163CA98(void *a1, uint64_t a2)
{
  v2 = *(a2 + 40);
  if (!v2 || *(v2 + 274) != 1)
  {
    return 0;
  }

  v5 = *(a2 + 48);
  v10[0] = *(a2 + 40);
  v10[1] = v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v6 = sub_100F54B40(a2, v10);
  if (v5)
  {
    sub_100004A34(v5);
  }

  if (v6 >= 2 && (a1[4] == a1[5] || v6 != 3 || (v7 = a1[8]) != 0 && *v7 == 1) && (v8 = *(a2 + 40), *(v8 + 273) == 1) && *(v8 + 88) && *(v8 + 152))
  {
    return *(v8 + 168) != 0;
  }

  else
  {
    return 0;
  }
}

void sub_10163CB78(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_10163CBA8(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v6 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    v7 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v7;
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }

  v8 = *(a2 + 40);
  if (!v8)
  {
    v55 = *a2;
    if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_104;
    }

    v58 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v58;
    v57 = "[%s] Roadside environment doesn't exist";
    goto LABEL_101;
  }

  if (*(v8 + 273) != 1 || !*(v8 + 88) || !*(v8 + 152) || !*(v8 + 168))
  {
    v55 = *a2;
    if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_104;
    }

    v56 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v56;
    v57 = "[%s] Roadside environment is not ready";
LABEL_101:
    v61 = v55;
    v62 = 12;
LABEL_102:
    _os_log_error_impl(&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, v57, buf, v62);
    goto LABEL_104;
  }

  if ((*(v8 + 274) & 1) == 0)
  {
    v55 = *a2;
    if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_104;
    }

    v59 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v59;
    v57 = "[%s] Roadside start message hasn't been acked yet";
    goto LABEL_101;
  }

  v9 = sub_101639D04(v8);
  if ((v10 & 1) == 0)
  {
    v55 = *a2;
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      v60 = sub_1011E88BC(*(a1 + 12));
      *buf = 136315138;
      *&buf[4] = v60;
      v57 = "[%s] ProviderId is missing in environment";
      goto LABEL_101;
    }

LABEL_104:
    *a3 = 0;
    *(a3 + 24) = 0;
    return;
  }

  v11 = v9;
  v12 = *(a1 + 28);
  if (v9 != v12)
  {
    v63 = *a2;
    if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_104;
    }

    v64 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315650;
    *&buf[4] = v64;
    *&buf[12] = 2048;
    *&buf[14] = v11;
    *&buf[22] = 1024;
    *&buf[24] = v12;
    v57 = "[%s] Expected providerId: %llu, but attempted providerId is: %hu";
    v61 = v63;
    v62 = 28;
    goto LABEL_102;
  }

  if (*(a1 + 60) == 1)
  {
    if (!*(a1 + 56))
    {
      __TUAssertTrigger();
    }

    v13 = sub_101646540(*(a2 + 40));
    v14 = v13;
    if ((v13 & 0x100000000) == 0)
    {
      __TUAssertTrigger();
    }

    if (*(a1 + 56) == v14)
    {
      v15 = 1;
    }

    else
    {
      v15 = 2;
    }
  }

  else
  {
    v15 = 0;
  }

  memset(__p, 0, 24);
  memset(buf, 0, 32);
  sub_100E008CC(buf, 0xC8uLL);
  v16 = *(a1 + 24);
  v17 = buf[24];
  if (*&buf[24])
  {
    v18 = v16 & 3;
    if (*&buf[24] == 1)
    {
      *(*&buf[8] - 1) |= v18 >> 1;
      *&buf[24] += 6;
      v68[0] = v18 << buf[24];
      sub_1001CD884(buf, v68);
    }

    else
    {
      *&buf[24] -= 2;
      *(*&buf[8] - 1) |= v18 << (v17 - 2);
    }
  }

  else
  {
    *&buf[24] = 6;
    v68[0] = v16 << 6;
    sub_1001CD884(buf, v68);
  }

  v19 = *(a1 + 25);
  v20 = buf[24];
  if (*&buf[24])
  {
    v21 = v19 & 0x3F;
    if (*&buf[24] >= 6uLL)
    {
      *&buf[24] -= 6;
      *(*&buf[8] - 1) |= v21 << (v20 - 6);
    }

    else
    {
      *(*&buf[8] - 1) |= v21 >> (6 - buf[24]);
      *&buf[24] += 2;
      v68[0] = v21 << buf[24];
      sub_1001CD884(buf, v68);
    }
  }

  else
  {
    *&buf[24] = 2;
    v68[0] = 4 * v19;
    sub_1001CD884(buf, v68);
  }

  v22 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    v23 = *(a1 + 24);
    if (v23 > 4)
    {
      v24 = "???";
    }

    else
    {
      v24 = off_101F5B8E0[v23];
    }

    v25 = sub_1011E88E0(*(a1 + 25));
    *v68 = 136315394;
    *&v68[4] = v24;
    *&v68[12] = 2080;
    *&v68[14] = v25;
    _os_log_impl(&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Serialized header: Version: %s, MessageType: %s", v68, 0x16u);
  }

  v26 = *(a1 + 26);
  v27 = buf[24];
  if (*&buf[24])
  {
    if (*&buf[24] >= 8uLL)
    {
      *&buf[24] -= 8;
      *(*&buf[8] - 1) |= v26 << (v27 - 8);
    }

    else
    {
      *(*&buf[8] - 1) |= v26 >> (8 - buf[24]);
      v68[0] = v26 << buf[24];
      sub_1001CD884(buf, v68);
    }
  }

  else
  {
    v68[0] = *(a1 + 26);
    sub_1001CD884(buf, v68);
  }

  v28 = buf[24];
  if (*&buf[24] == 1)
  {
    *(*&buf[8] - 1) |= (v15 & 0xFE) >> 1;
    *&buf[24] += 6;
    v68[0] = v15 << buf[24];
    sub_1001CD884(buf, v68);
  }

  else if (*&buf[24])
  {
    *&buf[24] -= 2;
    *(*&buf[8] - 1) |= v15 << (v28 - 2);
  }

  else
  {
    *&buf[24] = 6;
    v68[0] = v15 << 6;
    sub_1001CD884(buf, v68);
  }

  if (*&buf[24])
  {
    --*&buf[24];
  }

  else
  {
    *&buf[24] = 7;
    v68[0] = 0;
    sub_1001CD884(buf, v68);
  }

  sub_100E672BC(buf, *(a1 + 30));
  if (v15 == 2)
  {
    sub_100E673E0(buf, *(a1 + 56));
  }

  if (*&buf[24])
  {
    __TUAssertTrigger();
  }

  v29 = __p[0];
  v30 = __p[2];
  *__p = *buf;
  __p[2] = *&buf[16];
  *buf = v29;
  *&buf[16] = v30;
  if (v29)
  {
    *&buf[8] = v29;
    operator delete(v29);
  }

  v31 = *(a1 + 40);
  v32 = *(a1 + 32);
  if (v31 == v32)
  {
    v38 = *a2;
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      v53 = sub_1011E88BC(*(a1 + 12));
      *buf = 136315138;
      *&buf[4] = v53;
      _os_log_error_impl(&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "[%s] No text. Failed to encode", buf, 0xCu);
    }

    *a3 = 0;
    *(a3 + 24) = 0;
    v39 = __p[0];
  }

  else
  {
    sub_1006AD8F0(buf, v32, v31, __p);
    v33 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      v34 = sub_1011E88BC(*(a1 + 12));
      v35 = *(a1 + 26);
      v36 = off_101F5B8C8[v15];
      if (*(a1 + 60) == 1)
      {
        v37 = *(a1 + 56);
      }

      else
      {
        v37 = 0;
      }

      v40 = *(a1 + 30);
      v41 = *(a1 + 40) - *(a1 + 32);
      *buf = 136316418;
      *&buf[4] = v34;
      *&buf[12] = 1024;
      *&buf[14] = v35;
      *&buf[18] = 2080;
      *&buf[20] = v36;
      *&buf[28] = 1024;
      *&buf[30] = v37;
      v70 = 1024;
      v71 = v40;
      v72 = 2048;
      v73 = v41;
      _os_log_impl(&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I [%s] ConversationID: %hhu, Encoding: %s[%u], Outgoing sequence number: %hu, Text size: %zu", buf, 0x32u);
    }

    v42 = *(a2 + 40);
    v44 = *(v42 + 168);
    v43 = *(v42 + 176);
    if (v43)
    {
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    memset(v68, 0, 24);
    buf[0] = *__p[0];
    buf[1] = *(__p[0] + 1);
    *&buf[2] = 0;
    buf[6] = *(__p[0] + 2);
    buf[7] = *(__p[0] + 3);
    memset(v68, 0, 24);
    sub_1000DCF88(v68, buf, &buf[8], 8);
    v45 = __p[0];
    v46 = __p[1] - __p[0];
    if ((__p[1] - __p[0]) <= 4)
    {
      __TUAssertTrigger();
      v45 = __p[0];
      v46 = __p[1] - __p[0];
    }

    memset(buf, 0, 32);
    sub_101335AF4(a2, v44, v68, v45 + 4, v46 - 4, buf);
    v47 = buf[24];
    if (buf[24])
    {
      v48 = __p[0];
      v49 = __p[1] - __p[0];
      if (__p[1] - __p[0] != *&buf[8] - *buf + 4)
      {
        __TUAssertTrigger();
        v48 = __p[0];
        v49 = __p[1] - __p[0];
      }

      if (v49 > 3)
      {
        if (v49 != 4)
        {
          __p[1] = v48 + 4;
        }
      }

      else
      {
        sub_10018D3CC(__p, 4 - v49);
      }

      if ((buf[24] & 1) == 0)
      {
        sub_1000D1644();
      }

      v51 = *buf;
      v52 = *&buf[8];
      while (v51 != v52)
      {
        sub_1001CD884(__p, v51++);
      }
    }

    else
    {
      v50 = *a2;
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        v54 = sub_1011E88BC(*(a1 + 12));
        *v66 = 136315138;
        v67 = v54;
        _os_log_error_impl(&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "[%s] Failed to encrypt", v66, 0xCu);
      }

      *a3 = 0;
      *(a3 + 24) = 0;
    }

    if (buf[24] == 1 && *buf)
    {
      *&buf[8] = *buf;
      operator delete(*buf);
    }

    if (*v68)
    {
      *&v68[8] = *v68;
      operator delete(*v68);
    }

    if (v43)
    {
      sub_100004A34(v43);
    }

    v39 = __p[0];
    if (v47)
    {
      *a3 = __p[0];
      *(a3 + 8) = *&__p[1];
      *(a3 + 24) = 1;
      return;
    }
  }

  if (v39)
  {
    __p[1] = v39;
    operator delete(v39);
  }
}

void sub_10163D510(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, char a22)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (v22)
  {
    sub_100004A34(v22);
  }

  if (a9)
  {
    operator delete(a9);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10163D660(uint64_t a1, os_log_t *a2)
{
  v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
  {
    v5 = sub_1011E88BC(*(a1 + 12));
    v6 = 136315138;
    v7 = v5;
    _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Compression is not supported for this message", &v6, 0xCu);
  }

  return __TUAssertTrigger();
}

void sub_10163D7AC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v6 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    v7 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v7;
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }

  v8 = *(a2 + 40);
  if (!v8)
  {
    v55 = *a2;
    if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_115;
    }

    v58 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v58;
    v57 = "[%s] Roadside environment doesn't exist";
    goto LABEL_114;
  }

  if (*(v8 + 273) != 1 || !*(v8 + 88) || !*(v8 + 152) || !*(v8 + 168))
  {
    v55 = *a2;
    if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_115;
    }

    v56 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v56;
    v57 = "[%s] Roadside environment is not ready";
LABEL_114:
    _os_log_error_impl(&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, v57, buf, 0xCu);
    goto LABEL_115;
  }

  if ((*(v8 + 274) & 1) == 0)
  {
    v55 = *a2;
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      v59 = sub_1011E88BC(*(a1 + 12));
      *buf = 136315138;
      *&buf[4] = v59;
      v57 = "[%s] Roadside start message hasn't been acked yet";
      goto LABEL_114;
    }

LABEL_115:
    *a3 = 0;
    *(a3 + 24) = 0;
    return;
  }

  memset(__p, 0, 24);
  v9 = sub_101646CD0(v8);
  v10 = sub_101646358(*(a2 + 40));
  if (((v10 + 1) & 0x100) != 0)
  {
    v11 = 1;
  }

  else
  {
    v11 = v10 + 1;
  }

  sub_101646438(*(a2 + 40));
  v12 = *(a2 + 40);
  v13 = *(v12 + 104);
  v14 = *(v12 + 276);
  *(v12 + 276) = 0;
  memset(buf, 0, 32);
  sub_100E008CC(buf, 0xC8uLL);
  v15 = *(a1 + 24);
  v16 = buf[24];
  if (*&buf[24])
  {
    v17 = v15 & 3;
    if (*&buf[24] == 1)
    {
      *(*&buf[8] - 1) |= v17 >> 1;
      *&buf[24] += 6;
      v63[0] = v17 << buf[24];
      sub_1001CD884(buf, v63);
    }

    else
    {
      *&buf[24] -= 2;
      *(*&buf[8] - 1) |= v17 << (v16 - 2);
    }
  }

  else
  {
    *&buf[24] = 6;
    v63[0] = v15 << 6;
    sub_1001CD884(buf, v63);
  }

  v18 = *(a1 + 25);
  v19 = buf[24];
  if (*&buf[24])
  {
    v20 = v18 & 0x3F;
    if (*&buf[24] >= 6uLL)
    {
      *&buf[24] -= 6;
      *(*&buf[8] - 1) |= v20 << (v19 - 6);
    }

    else
    {
      *(*&buf[8] - 1) |= v20 >> (6 - buf[24]);
      *&buf[24] += 2;
      v63[0] = v20 << buf[24];
      sub_1001CD884(buf, v63);
    }
  }

  else
  {
    *&buf[24] = 2;
    v63[0] = 4 * v18;
    sub_1001CD884(buf, v63);
  }

  v21 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    v22 = *(a1 + 24);
    if (v22 > 4)
    {
      v23 = "???";
    }

    else
    {
      v23 = off_101F5B8E0[v22];
    }

    v24 = sub_1011E88E0(*(a1 + 25));
    *v63 = 136315394;
    *&v63[4] = v23;
    *&v63[12] = 2080;
    *&v63[14] = v24;
    _os_log_impl(&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Serialized header: Version: %s, MessageType: %s", v63, 0x16u);
  }

  v25 = buf[24];
  if (*&buf[24])
  {
    if (*&buf[24] >= 8uLL)
    {
      *&buf[24] -= 8;
      *(*&buf[8] - 1) |= v13 << (v25 - 8);
    }

    else
    {
      *(*&buf[8] - 1) |= v13 >> (8 - buf[24]);
      v63[0] = v13 << buf[24];
      sub_1001CD884(buf, v63);
    }
  }

  else
  {
    v63[0] = v13;
    sub_1001CD884(buf, v63);
  }

  v26 = v11 & (v10 << 23 >> 31);
  v27 = buf[24];
  if (*&buf[24])
  {
    if (*&buf[24] >= 8uLL)
    {
      *&buf[24] -= 8;
      *(*&buf[8] - 1) |= v26 << (v27 - 8);
    }

    else
    {
      *(*&buf[8] - 1) |= (v11 & (v10 << 23 >> 31)) >> (8 - buf[24]);
      v63[0] = (v11 & (v10 << 23 >> 31)) << buf[24];
      sub_1001CD884(buf, v63);
    }
  }

  else
  {
    v63[0] = v11 & (v10 << 23 >> 31);
    sub_1001CD884(buf, v63);
  }

  v28 = *(a2 + 40);
  v29 = *(v28 + 88);
  v30 = *(v28 + 96);
  if (v30)
  {
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  sub_1015C41A4(v29, a2, buf);
  v31 = buf[24];
  if (*&buf[24])
  {
    v32 = v9 & 3;
    if (*&buf[24] == 1)
    {
      *(*&buf[8] - 1) |= (v9 & 3) >> 1;
      *&buf[24] += 6;
      v63[0] = v32 << buf[24];
      sub_1001CD884(buf, v63);
    }

    else
    {
      *&buf[24] -= 2;
      *(*&buf[8] - 1) |= v32 << (v31 - 2);
    }
  }

  else
  {
    *&buf[24] = 6;
    v63[0] = v9 << 6;
    sub_1001CD884(buf, v63);
  }

  if (*&buf[24])
  {
    v33 = *&buf[24] - 1;
  }

  else
  {
    *&buf[24] = 7;
    v63[0] = 0;
    sub_1001CD884(buf, v63);
    v33 = *&buf[24];
  }

  if (v33 == 1)
  {
    *&buf[24] = 7;
    if (v14)
    {
      v34 = 0x80;
    }

    else
    {
      v34 = 0;
    }

    goto LABEL_52;
  }

  if (!v33)
  {
    *&buf[24] = 6;
    if (v14)
    {
      v34 = 64;
    }

    else
    {
      v34 = 0;
    }

LABEL_52:
    v63[0] = v34;
    sub_1001CD884(buf, v63);
    goto LABEL_57;
  }

  *&buf[24] = v33 - 2;
  *(*&buf[8] - 1) |= v14 << (v33 - 2);
LABEL_57:
  v35 = *&buf[24];
  if (*&buf[24])
  {
    if (*&buf[24] >= 3uLL)
    {
      *&buf[24] -= 3;
      if (v35 == 3)
      {
        goto LABEL_65;
      }

      goto LABEL_64;
    }

    *&buf[24] += 5;
    v63[0] = 0;
    sub_1001CD884(buf, v63);
  }

  else
  {
    *&buf[24] = 5;
    v63[0] = 0;
    sub_1001CD884(buf, v63);
  }

  if (*&buf[24])
  {
LABEL_64:
    __TUAssertTrigger();
  }

LABEL_65:
  v36 = *__p;
  *__p = *buf;
  *buf = v36;
  v37 = __p[2];
  __p[2] = *&buf[16];
  *&buf[16] = v37;
  if (!v30)
  {
    v38 = v36;
    if (!v36)
    {
      goto LABEL_68;
    }

    goto LABEL_67;
  }

  sub_100004A34(v30);
  v38 = *buf;
  if (*buf)
  {
LABEL_67:
    *&buf[8] = v38;
    operator delete(v38);
  }

LABEL_68:
  v39 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    v40 = sub_1011E88BC(*(a1 + 12));
    if (v9 > 4)
    {
      v41 = "???";
    }

    else
    {
      v41 = off_101F5B908[v9];
    }

    *buf = 136316162;
    *&buf[4] = v40;
    *&buf[12] = 1024;
    *&buf[14] = v13;
    if (v14)
    {
      v42 = "Yes";
    }

    else
    {
      v42 = "No";
    }

    *&buf[18] = 1024;
    *&buf[20] = v26;
    *&buf[24] = 2080;
    *&buf[26] = v41;
    v65 = 2080;
    v66 = v42;
    _os_log_impl(&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I [%s] ConversationID: %hhu, location sequence num: %hhu, battery: %s, Is Resume: %s", buf, 0x2Cu);
  }

  v43 = *(a2 + 40);
  v45 = *(v43 + 168);
  v44 = *(v43 + 176);
  if (v44)
  {
    atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  memset(v63, 0, 24);
  buf[0] = *__p[0];
  buf[1] = *(__p[0] + 1);
  buf[6] = 0;
  *&buf[2] = 0;
  buf[7] = *(__p[0] + 2);
  memset(v63, 0, 24);
  sub_1000DCF88(v63, buf, &buf[8], 8);
  v46 = __p[0];
  v47 = __p[1] - __p[0];
  if ((__p[1] - __p[0]) <= 3)
  {
    __TUAssertTrigger();
    v46 = __p[0];
    v47 = __p[1] - __p[0];
  }

  memset(buf, 0, 32);
  sub_101335AF4(a2, v45, v63, v46 + 3, v47 - 3, buf);
  v48 = buf[24];
  if (buf[24])
  {
    v49 = __p[0];
    v50 = __p[1] - __p[0];
    if (__p[1] - __p[0] != *&buf[8] - *buf + 3)
    {
      __TUAssertTrigger();
      v49 = __p[0];
      v50 = __p[1] - __p[0];
    }

    if (v50 > 2)
    {
      if (v50 != 3)
      {
        __p[1] = v49 + 3;
      }
    }

    else
    {
      sub_10018D3CC(__p, 3 - v50);
    }

    if ((buf[24] & 1) == 0)
    {
      sub_1000D1644();
    }

    v52 = *buf;
    v53 = *&buf[8];
    while (v52 != v53)
    {
      sub_1001CD884(__p, v52++);
    }
  }

  else
  {
    v51 = *a2;
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      v54 = sub_1011E88BC(*(a1 + 12));
      *v61 = 136315138;
      v62 = v54;
      _os_log_error_impl(&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "[%s] Failed to encrypt", v61, 0xCu);
    }

    *a3 = 0;
    *(a3 + 24) = 0;
  }

  if (buf[24] == 1 && *buf)
  {
    *&buf[8] = *buf;
    operator delete(*buf);
  }

  if (*v63)
  {
    *&v63[8] = *v63;
    operator delete(*v63);
  }

  if (v44)
  {
    sub_100004A34(v44);
  }

  if (v48)
  {
    *a3 = __p[0];
    *(a3 + 8) = *&__p[1];
    *(a3 + 24) = 1;
  }

  else if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_10163E124(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, char a22)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (v22)
  {
    sub_100004A34(v22);
  }

  if (a9)
  {
    operator delete(a9);
  }

  _Unwind_Resume(exception_object);
}

void sub_10163E268(uint64_t a1, uint64_t a2, NSObject **a3, uint64_t a4)
{
  if (*(a1 + 40) != 1 || *(a1 + 72) || *(a1 + 48) == *(a1 + 56))
  {
    __TUAssertTrigger();
  }

  if (a3[5])
  {
    v7 = a3[6];
    *&buf = a3[5];
    *(&buf + 1) = v7;
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    v8 = sub_100F54B40(a3, &buf);
    if (v7)
    {
      sub_100004A34(v7);
    }

    if (v8 == 3)
    {
      operator new();
    }
  }

  v9 = *a3;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    v10 = sub_1011E88BC(*(a1 + 12));
    LODWORD(buf) = 136315138;
    *(&buf + 4) = v10;
    _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "[%s][Decompression] Failure: Environment is not ready", &buf, 0xCu);
  }

  sub_100E69DF0(&buf, a4);
  operator new();
}

void sub_10163E5A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  v9 = va_arg(va1, void);
  v10 = va_arg(va1, void);
  v11 = va_arg(va1, void);
  v12 = va_arg(va1, void);
  v13 = va_arg(va1, void);
  v14 = va_arg(va1, void);
  v15 = va_arg(va1, void);
  v16 = va_arg(va1, void);
  sub_100E4C090(va1);
  sub_100E686A8(va);
  _Unwind_Resume(a1);
}

BOOL sub_10163E60C(uint64_t a1, uint64_t a2, _BYTE **a3)
{
  v6 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    v7 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v7;
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding", buf, 0xCu);
  }

  v8 = *(a2 + 40);
  if (!v8)
  {
    v56 = *a2;
    result = os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
    if (!result)
    {
      return result;
    }

    v84 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v84;
    v13 = "[%s] Roadside environment doesn't exist";
LABEL_126:
    v14 = v56;
    v15 = 12;
    goto LABEL_127;
  }

  if (*(v8 + 273) != 1 || !*(v8 + 88) || !*(v8 + 152) || !*(v8 + 168))
  {
    v56 = *a2;
    result = os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
    if (!result)
    {
      return result;
    }

    v70 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v70;
    v13 = "[%s] Roadside environment is not ready";
    goto LABEL_126;
  }

  v9 = a3[1] - *a3;
  if (v9 <= 4)
  {
    v10 = *a2;
    result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v12 = sub_1011E88BC(*(a1 + 12));
      *buf = 136315650;
      *&buf[4] = v12;
      *&buf[12] = 2048;
      *&buf[14] = 4;
      *&buf[22] = 2048;
      *&buf[24] = v9;
      v13 = "[%s] Incomplete message: Expected size > %zu, got %zu";
      v14 = v10;
      v15 = 32;
      goto LABEL_127;
    }

    return result;
  }

  *(a1 + 26) = 0;
  v16 = 8;
  while (1)
  {
    v17 = a3[4];
    v18 = a3[5];
    if (!v18)
    {
      a3[4] = ++v17;
      a3[5] = 8;
      v18 = 8;
    }

    v19 = *a3;
    if (v17 >= a3[1] - *a3)
    {
      *(a3 + 24) = 1;
      v56 = *a2;
      result = os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
      if (!result)
      {
        return result;
      }

      v62 = sub_1011E88BC(*(a1 + 12));
      *buf = 136315138;
      *&buf[4] = v62;
      v13 = "[%s] Failed to read conversationID";
      goto LABEL_126;
    }

    v20 = v16 - v18;
    if (v16 <= v18)
    {
      break;
    }

    v21 = v17[v19] & ~(-1 << v18);
    a3[5] = 0;
    *(a1 + 26) |= v21 << v20;
    v16 = v20;
    if (v20 - 9 < 0xFFFFFFFFFFFFFFF8)
    {
      __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
    }
  }

  a3[5] = (v18 - v16);
  if (v16 < 8)
  {
    v22 = ~(-1 << v16);
  }

  else
  {
    v22 = -1;
  }

  v23 = *(a1 + 26) | (v17[v19] >> (v18 - v16)) & v22;
  v24 = v23;
  *(a1 + 26) = v23;
  v25 = *(*(a2 + 40) + 104);
  if (v23 != v25)
  {
    v35 = *a2;
    result = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v36 = sub_1011E88BC(*(a1 + 12));
      *buf = 136315650;
      *&buf[4] = v36;
      *&buf[12] = 1024;
      *&buf[14] = v25;
      *&buf[18] = 1024;
      *&buf[20] = v24;
      v13 = "[%s] Expected conversationID: %hhu, got: %hhu. Rejecting message";
      v14 = v35;
      v15 = 24;
      goto LABEL_127;
    }

    return result;
  }

  v26 = 0;
  v27 = *a3;
  v28 = a3[1] - *a3;
  v29 = a3[4];
  v30 = a3[5];
  v31 = 2;
  if (v30)
  {
    goto LABEL_24;
  }

  while (2)
  {
    a3[4] = ++v29;
    a3[5] = 8;
    v30 = 8;
LABEL_24:
    if (v29 >= v28)
    {
      *(a3 + 24) = 1;
      v56 = *a2;
      result = os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
      if (!result)
      {
        return result;
      }

      v64 = sub_1011E88BC(*(a1 + 12));
      *buf = 136315138;
      *&buf[4] = v64;
      v13 = "[%s] Failed to read text encoding";
      goto LABEL_126;
    }

    v32 = v30 >= v31;
    v33 = v30 - v31;
    if (!v32)
    {
      v34 = v29[v27];
      a3[5] = 0;
      v26 |= 2 * (v34 & 1);
      v31 = 1;
      continue;
    }

    break;
  }

  a3[5] = v33;
  v37 = (v26 | (v29[v27] >> v33) & ~(-1 << v31));
  if (v37 >= 3)
  {
    v38 = 3;
  }

  else
  {
    v38 = v37;
  }

  *(a1 + 30) = v38;
  if (v37 >= 3)
  {
    v39 = *a2;
    result = os_log_type_enabled(v39, OS_LOG_TYPE_ERROR);
    if (!result)
    {
      return result;
    }

    v40 = sub_1011E88BC(*(a1 + 12));
    v41 = off_101F5B930[v38];
    *buf = 136315650;
    *&buf[4] = v40;
    *&buf[12] = 2080;
    *&buf[14] = v41;
    *&buf[22] = 1024;
    *&buf[24] = 3;
    v13 = "[%s] Invalid encoding: %s (Received: %hhu)";
    v14 = v39;
    v15 = 28;
LABEL_127:
    _os_log_error_impl(&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v13, buf, v15);
    return 0;
  }

  if (!v33)
  {
    v33 = 8;
    a3[4] = ++v29;
    a3[5] = 8;
  }

  if (v29 >= v28)
  {
    *(a3 + 24) = 1;
    v56 = *a2;
    result = os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
    if (!result)
    {
      return result;
    }

    v88 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v88;
    v13 = "[%s] Failed to read reservedBit";
    goto LABEL_126;
  }

  a3[5] = (v33 - 1);
  *(a1 + 32) = 0;
  if ((sub_100E69330(a3, (a1 + 32), 0xDuLL) & 1) == 0)
  {
    v56 = *a2;
    result = os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
    if (!result)
    {
      return result;
    }

    v57 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v57;
    v13 = "[%s] Failed to read incoming sequence number";
    goto LABEL_126;
  }

  v42 = sub_101639D04(*(a2 + 40));
  if ((v43 & 1) == 0)
  {
    v56 = *a2;
    result = os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
    if (!result)
    {
      return result;
    }

    v58 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v58;
    v13 = "[%s] ProviderId is missing in environment";
    goto LABEL_126;
  }

  *(a1 + 28) = v42;
  if (*(a3 + 24) == 1)
  {
    __TUAssertTrigger();
    if (a3[3])
    {
      sub_1000D1644();
    }
  }

  v44 = a3[5];
  if (v44)
  {
    v45 = a3[4];
  }

  else
  {
    v45 = (a3[4] + 1);
  }

  if ((v44 | 8) != 8)
  {
    __TUAssertTrigger();
  }

  if (v45 != 4)
  {
    __TUAssertTrigger();
  }

  *__p = 0u;
  v93 = 0u;
  v46 = *(a2 + 40);
  v48 = *(v46 + 152);
  v47 = *(v46 + 160);
  if (v47)
  {
    atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  memset(v98, 0, sizeof(v98));
  v49 = *a3;
  buf[0] = **a3;
  buf[1] = v49[1];
  *&buf[2] = 0;
  buf[6] = v49[2];
  buf[7] = v49[3];
  memset(v98, 0, sizeof(v98));
  sub_1000DCF88(v98, buf, &buf[8], 8);
  sub_101335EFC(a2, v48, v98, *a3 + 4, a3[1] - *a3 - 4, buf);
  sub_1004EDCD0(__p, buf);
  if (buf[24] == 1 && *buf)
  {
    *&buf[8] = *buf;
    operator delete(*buf);
  }

  if (*v98)
  {
    *&v98[8] = *v98;
    operator delete(*v98);
  }

  if (v47)
  {
    sub_100004A34(v47);
  }

  if ((BYTE8(v93) & 1) == 0)
  {
    v59 = *a2;
    if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_86;
    }

    v60 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v60;
    v61 = "[%s] Failed to decrypt incoming text message";
LABEL_75:
    _os_log_error_impl(&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, v61, buf, 0xCu);
    goto LABEL_86;
  }

  if (__p[0] == __p[1])
  {
    v59 = *a2;
    if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_86;
    }

    v63 = sub_1011E88BC(*(a1 + 12));
    *buf = 136315138;
    *&buf[4] = v63;
    v61 = "[%s] Decrypted message contents are empty";
    goto LABEL_75;
  }

  *buf = __p[0];
  *&buf[8] = __p[1];
  v50 = v93;
  __p[1] = 0;
  *&v93 = 0;
  __p[0] = 0;
  *&buf[16] = v50;
  *&buf[24] = 0;
  *&buf[32] = 0;
  *v95 = 8;
  v51 = *(a1 + 30);
  if (v51 == 2)
  {
    v91 = 0;
    if (sub_100E6957C(buf, &v91))
    {
      v65 = v91;
      if (HIDWORD(v91))
      {
        v66 = *a2;
        if (!os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
        {
          goto LABEL_84;
        }

        v67 = sub_1011E88BC(*(a1 + 12));
        *v98 = 136315394;
        *&v98[4] = v67;
        *&v98[12] = 2048;
        *&v98[14] = v65;
        v55 = "[%s] CodecId must fit 32 bits (Received: %llu)";
        v68 = v66;
        v69 = 22;
      }

      else
      {
        if (v91)
        {
          if ((*(a1 + 40) & 1) == 0)
          {
            *(a1 + 40) = 1;
          }

          *(a1 + 36) = v65;
          goto LABEL_95;
        }

        v85 = *a2;
        if (!os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
        {
          goto LABEL_84;
        }

        v86 = sub_1011E88BC(*(a1 + 12));
        *v98 = 136315394;
        *&v98[4] = v86;
        *&v98[12] = 1024;
        *&v98[14] = 0;
        v55 = "[%s] Received invalid codecId(%u) from backend";
        v68 = v85;
        v69 = 18;
      }
    }

    else
    {
      v53 = *a2;
      if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      {
        goto LABEL_84;
      }

      v87 = sub_1011E88BC(*(a1 + 12));
      *v98 = 136315138;
      *&v98[4] = v87;
      v55 = "[%s] Failed to read varint-128 codecId";
LABEL_133:
      v68 = v53;
      v69 = 12;
    }

    _os_log_error_impl(&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, v55, v98, v69);
    goto LABEL_84;
  }

  if (v51 == 1)
  {
    v52 = sub_101646540(*(a2 + 40));
    if ((v52 & 0x100000000) == 0)
    {
      v53 = *a2;
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      {
        v54 = sub_1011E88BC(*(a1 + 12));
        *v98 = 136315138;
        *&v98[4] = v54;
        v55 = "[%s] Don't have a valid preferred codec id";
        goto LABEL_133;
      }

LABEL_84:
      if (*buf)
      {
        *&buf[8] = *buf;
        operator delete(*buf);
      }

LABEL_86:
      if (BYTE8(v93) == 1 && __p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }

      return 0;
    }

    *(a1 + 36) = v52;
    *(a1 + 40) = 1;
  }

LABEL_95:
  if (buf[24] == 1)
  {
    __TUAssertTrigger();
    if (buf[24])
    {
      sub_1000D1644();
    }
  }

  if (*v95)
  {
    v71 = *&buf[32];
  }

  else
  {
    v71 = *&buf[32] + 1;
  }

  if ((*v95 | 8) != 8)
  {
    __TUAssertTrigger();
  }

  v72 = *&buf[8];
  for (i = (v71 + *buf); i != v72; ++i)
  {
    sub_1001CD884(a1 + 48, i);
  }

  v74 = *(a1 + 48);
  v75 = *(a1 + 56);
  if (v74 == v75)
  {
    v89 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
    {
      v90 = sub_1011E88BC(*(a1 + 12));
      *v98 = 136315138;
      *&v98[4] = v90;
      _os_log_error_impl(&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "[%s] Rejecting empty text received from backend", v98, 0xCu);
    }
  }

  if (*buf)
  {
    *&buf[8] = *buf;
    operator delete(*buf);
  }

  if (BYTE8(v93) == 1 && __p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (v74 == v75)
  {
    return 0;
  }

  v76 = *a2;
  if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
  {
    v77 = sub_1011E88BC(*(a1 + 12));
    if (*(a1 + 30) > 3u)
    {
      v78 = "???";
    }

    else
    {
      v78 = off_101F5B930[*(a1 + 30)];
    }

    v79 = *(a1 + 26);
    if (*(a1 + 40) == 1)
    {
      v80 = *(a1 + 36);
    }

    else
    {
      v80 = 0;
    }

    v81 = *(a1 + 32);
    v82 = *(a1 + 56) - *(a1 + 48);
    if (*(a1 + 30))
    {
      v83 = "true";
    }

    else
    {
      v83 = "false";
    }

    *buf = 136316674;
    *&buf[4] = v77;
    *&buf[12] = 1024;
    *&buf[14] = v79;
    *&buf[18] = 2080;
    *&buf[20] = v78;
    *&buf[28] = 1024;
    *&buf[30] = v80;
    *&buf[34] = 1024;
    *&buf[36] = v81;
    *v95 = 2048;
    *&v95[2] = v82;
    v96 = 2080;
    v97 = v83;
    _os_log_impl(&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I [%s] ConversationID: %hhu, Encoding: %s[%u], sequence number: %hu, Received text size: %zu, isCompressed: %s", buf, 0x3Cu);
  }

  return 1;
}

void sub_10163F1C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, char a14, void *__p, uint64_t a16)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a14 == 1)
  {
    if (a11)
    {
      operator delete(a11);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10163F278(uint64_t a1)
{
  *a1 = off_101F5ABD0;
  *(a1 + 16) = &unk_101F5AC80;
  if (*(a1 + 88) == 1)
  {
    v2 = *(a1 + 64);
    if (v2)
    {
      *(a1 + 72) = v2;
      operator delete(v2);
    }
  }

  if (*(a1 + 56) == 1 && *(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  return a1;
}

void sub_10163F310(uint64_t a1)
{
  *a1 = off_101F5ABD0;
  *(a1 + 16) = &unk_101F5AC80;
  if (*(a1 + 88) == 1)
  {
    v2 = *(a1 + 64);
    if (v2)
    {
      *(a1 + 72) = v2;
      operator delete(v2);
    }
  }

  if (*(a1 + 56) == 1 && *(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  operator delete();
}

void sub_10163F3C8(uint64_t a1)
{
  *(a1 - 16) = off_101F5ABD0;
  *a1 = &unk_101F5AC80;
  if (*(a1 + 72) == 1)
  {
    v2 = *(a1 + 48);
    if (v2)
    {
      *(a1 + 56) = v2;
      operator delete(v2);
    }
  }

  if (*(a1 + 40) == 1 && *(a1 + 39) < 0)
  {
    v3 = *(a1 + 16);

    operator delete(v3);
  }
}

void sub_10163F474(uint64_t a1)
{
  *(a1 - 16) = off_101F5ABD0;
  *a1 = &unk_101F5AC80;
  if (*(a1 + 72) == 1)
  {
    v2 = *(a1 + 48);
    if (v2)
    {
      *(a1 + 56) = v2;
      operator delete(v2);
    }
  }

  if (*(a1 + 40) == 1 && *(a1 + 39) < 0)
  {
    operator delete(*(a1 + 16));
  }

  operator delete();
}

void sub_10163F54C(void *a1)
{
  *a1 = off_101F5AF10;
  a1[2] = &unk_101F5AFC0;
  v2 = a1[9];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }

  operator delete();
}

void sub_10163F5E8(void *a1)
{
  *(a1 - 2) = off_101F5AF10;
  *a1 = &unk_101F5AFC0;
  v2 = a1[7];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = a1[2];
  if (v3)
  {
    a1[3] = v3;

    operator delete(v3);
  }
}

void sub_10163F678(void *a1)
{
  *(a1 - 2) = off_101F5AF10;
  *a1 = &unk_101F5AFC0;
  v2 = a1[7];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }

  operator delete();
}

void *sub_10163F788(void *a1)
{
  *a1 = off_101F5B590;
  a1[2] = &unk_101F5B5F8;
  v2 = a1[10];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = a1[6];
  if (v3)
  {
    a1[7] = v3;
    operator delete(v3);
  }

  return a1;
}

void sub_10163F804(void *a1)
{
  *a1 = off_101F5B590;
  a1[2] = &unk_101F5B5F8;
  v2 = a1[10];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = a1[6];
  if (v3)
  {
    a1[7] = v3;
    operator delete(v3);
  }

  operator delete();
}

void sub_10163F8A0(void *a1)
{
  *(a1 - 2) = off_101F5B590;
  *a1 = &unk_101F5B5F8;
  v2 = a1[8];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = a1[4];
  if (v3)
  {
    a1[5] = v3;

    operator delete(v3);
  }
}

void sub_10163F930(void *a1)
{
  *(a1 - 2) = off_101F5B590;
  *a1 = &unk_101F5B5F8;
  v2 = a1[8];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }

  operator delete();
}

void *sub_10163F9CC(void *a1)
{
  *a1 = off_101F5B7D8;
  ctu::OsLogLogger::~OsLogLogger((a1 + 8));
  sub_100E287C8((a1 + 4));
  v2 = a1[3];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return a1;
}

void sub_10163FA24(void *a1)
{
  *a1 = off_101F5B7D8;
  ctu::OsLogLogger::~OsLogLogger((a1 + 8));
  sub_100E287C8((a1 + 4));
  v2 = a1[3];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void sub_10163FB30(_Unwind_Exception *a1)
{
  sub_100E287C8((v1 + 4));
  v3 = v1[3];
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10163FB60(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5B7D8;
  *(a2 + 8) = *(a1 + 8);
  v4 = *(a1 + 24);
  *(a2 + 24) = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 16), 1uLL, memory_order_relaxed);
  }

  sub_100E6A3F4(a2 + 32, a1 + 32);
  return ctu::OsLogLogger::OsLogLogger((a2 + 64), (a1 + 64));
}

void sub_10163FBD8(_Unwind_Exception *a1)
{
  sub_100E287C8(v1 + 32);
  v3 = *(v1 + 24);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10163FC00(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((a1 + 64));
  sub_100E287C8(a1 + 32);
  v2 = *(a1 + 24);
  if (v2)
  {

    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_10163FC54(void *a1)
{
  ctu::OsLogLogger::~OsLogLogger((a1 + 8));
  sub_100E287C8((a1 + 4));
  v2 = a1[3];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(a1);
}

void sub_10163FCA4(void *a1, uint64_t *a2, __n128 *a3)
{
  v4 = a1[3];
  if (v4)
  {
    v6 = *a2;
    v7 = a1[1];
    v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      v9 = v8;
      v10 = a1[2];
      if (v10)
      {
        *v10 = 1;
        if ((v6 & 0x100000000) != 0 && a3->n128_u64[0] != a3->n128_u64[1] && v6)
        {
          v14 = *(v7 + 40) - *(v7 + 32);
          *(v7 + 56) = v6;
          *(v7 + 60) = 1;
          v15 = a3->n128_u64[1] - a3->n128_u64[0];
          if (v14 < v15)
          {
            __TUAssertTrigger();
          }

          v16 = a1[8];
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            v17 = sub_1011E88BC(*(v7 + 12));
            *v21 = 136315650;
            *&v21[4] = v17;
            v22 = 2048;
            v23 = v14;
            v24 = 2048;
            v25 = v15;
            _os_log_impl(&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I [%s][Compression] Reduced size from %zu bytes -> %zu bytes", v21, 0x20u);
          }

          v18 = sub_100015184(v7 + 32, a3);
          v19 = *(v7 + 56);
          *v21 = v14 - v15;
          *&v21[8] = v19;
          BYTE2(v23) = 1;
          v20 = a1[7];
          if (!v20)
          {
            sub_100022DB4();
          }

          (*(*v20 + 48))(v20, v21, v18);
        }

        else
        {
          v11 = a1[8];
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            v12 = sub_1011E88BC(*(v7 + 12));
            *v21 = 136315138;
            *&v21[4] = v12;
            _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [%s][Compression] Going uncompressed", v21, 0xCu);
          }

          v21[0] = 0;
          BYTE2(v23) = 0;
          v13 = a1[7];
          if (!v13)
          {
            sub_100022DB4();
          }

          (*(*v13 + 48))(v13, v21);
        }
      }

      sub_100004A34(v9);
    }
  }
}

uint64_t sub_10163FF04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_10163FF50(uint64_t a1)
{
  v3 = a1;
  v4[0] = 0;
  v4[16] = 0;
  v1 = *(a1 + 24);
  if (!v1)
  {
    sub_100022DB4();
  }

  (*(*v1 + 48))(v1, v4);
  return sub_100E6A4D4(&v3);
}

void *sub_10163FFD4(void *a1)
{
  *a1 = off_101F5B858;
  v2 = a1[8];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  sub_100E287C8((a1 + 2));
  ctu::OsLogLogger::~OsLogLogger((a1 + 1));
  return a1;
}

void sub_101640030(void *a1)
{
  *a1 = off_101F5B858;
  v2 = a1[8];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  sub_100E287C8((a1 + 2));
  ctu::OsLogLogger::~OsLogLogger((a1 + 1));

  operator delete();
}

void sub_101640164(_Unwind_Exception *a1)
{
  ctu::OsLogLogger::~OsLogLogger(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101640188(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5B858;
  v4 = a2 + 16;
  ctu::OsLogLogger::OsLogLogger((a2 + 8), (a1 + 8));
  result = sub_100E6A3F4(v4, a1 + 16);
  *(a2 + 48) = *(a1 + 48);
  v6 = *(a1 + 64);
  *(a2 + 64) = v6;
  if (v6)
  {
    atomic_fetch_add_explicit((v6 + 16), 1uLL, memory_order_relaxed);
  }

  v7 = *(a1 + 72);
  *(a2 + 80) = *(a1 + 80);
  *(a2 + 72) = v7;
  *(a2 + 81) = 0;
  *(a2 + 84) = 0;
  return result;
}

void sub_101640238(uint64_t a1)
{
  v2 = *(a1 + 64);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  sub_100E287C8(a1 + 16);

  ctu::OsLogLogger::~OsLogLogger((a1 + 8));
}

void sub_101640280(void *a1)
{
  v2 = a1[8];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  sub_100E287C8((a1 + 2));
  ctu::OsLogLogger::~OsLogLogger((a1 + 1));

  operator delete(a1);
}

void sub_1016402D0(uint64_t a1, __n128 *a2)
{
  v3 = *(a1 + 64);
  if (v3)
  {
    v5 = *(a1 + 48);
    v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      v7 = v6;
      if (*(a1 + 56))
      {
        if ((*(v5 + 40) & 1) == 0)
        {
          __TUAssertTrigger();
        }

        *(v5 + 56) = *(v5 + 48);
        v8 = a2->n128_u64[1];
        if (a2->n128_u64[0] == v8)
        {
          v25 = *(a1 + 8);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            v26 = sub_1011E88BC(*(v5 + 12));
            v27 = *(v5 + 36);
            v28 = *(v5 + 26);
            v29 = *(v5 + 32);
            *buf = 136315906;
            *&buf[4] = v26;
            v35 = 1024;
            v36 = v27;
            v37 = 1024;
            v38 = v28;
            v39 = 1024;
            v40 = v29;
            _os_log_error_impl(&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "[%s][Decompression] Failed. codecId: %u, conversationID: %hhu, incoming sequence number: %hu", buf, 0x1Eu);
          }

          buf[0] = 0;
          BYTE2(v36) = 0;
          sub_100E6A48C(a1 + 16);
        }

        else
        {
          v9 = v8 - a2->n128_u64[0];
          v10 = *(a1 + 8);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            v11 = sub_1011E88BC(*(v5 + 12));
            v12 = *(v5 + 36);
            v13 = *(v5 + 26);
            v14 = *(v5 + 32);
            v15 = *(a1 + 72);
            *buf = 136316418;
            *&buf[4] = v11;
            v35 = 1024;
            v36 = v12;
            v37 = 1024;
            v38 = v13;
            v39 = 1024;
            v40 = v14;
            v41 = 2048;
            v42 = v15;
            v43 = 2048;
            v44 = v9;
            _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [%s][Decompression] For codecId: %u, conversationID: %hhu, incoming sequence number: %hu, compressed text size: %zu, uncompressed text size: %zu bytes", buf, 0x32u);
          }

          sub_100015184(v5 + 48, a2);
          v16 = *(a1 + 72);
          v17 = v9 - v16;
          if (v9 < v16)
          {
            v18 = *(a1 + 8);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              *buf = 0;
              _os_log_error_impl(&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Backend is compressing in a way that does not yield any benefit. Please create radar.", buf, 2u);
            }

            v17 = 0;
          }

          if (*(a1 + 80) == 1)
          {
            v19 = *(a1 + 8);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              v20 = *(v5 + 12);
              sub_1001E0090(buf, *(v5 + 48), *(v5 + 56), *(v5 + 56) - *(v5 + 48));
              v21 = sub_1011E88BC(v20);
              v22 = v38 >= 0 ? buf : *buf;
              v30 = 136315394;
              v31 = v21;
              v32 = 2080;
              v33 = v22;
              _os_log_impl(&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I [%s] Decompressed text: %s", &v30, 0x16u);
              if (SHIBYTE(v38) < 0)
              {
                operator delete(*buf);
              }
            }
          }

          v23 = *(v5 + 36);
          *buf = v17;
          *&buf[8] = v23;
          BYTE2(v36) = 1;
          v24 = *(a1 + 40);
          if (!v24)
          {
            sub_100022DB4();
          }

          (*(*v24 + 48))(v24, buf);
        }
      }

      sub_100004A34(v7);
    }
  }
}

uint64_t sub_101640620(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10164066C(const char *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  v6[0] = 0;
  v6[1] = 0;
  ctu::TextConverter::TextConverter(v6);
  ctu::TextConverter::pushConversion();
  ctu::TextConverter::setSource(v6, a1, a2);
  ctu::TextConverter::readChars(a3, v6, 0x7FFFFFFFuLL);
  ctu::TextConverter::~TextConverter(v6);
}

void sub_101640704(uint64_t a1)
{
  *a1 = off_101F5B960;
  sub_1016430D0(a1 + 120);
  sub_10048662C((a1 + 112));
  sub_100005978((a1 + 104));
  v2 = *(a1 + 96);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  v3 = *(a1 + 72);
  if (v3)
  {
    sub_100004A34(v3);
  }

  v4 = *(a1 + 56);
  if (v4)
  {
    sub_100004A34(v4);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 40));
  sub_1000C0544((a1 + 8));

  MISServiceInterface::~MISServiceInterface(a1);
}

void sub_1016407A0(uint64_t a1)
{
  sub_101640704(a1);

  operator delete();
}

void sub_1016407D8(capabilities::ct *a1)
{
  if (capabilities::ct::getBasebandBootStrategy(a1) == 1)
  {
    operator new();
  }

  operator new();
}

void sub_101640B38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17)
  {
    (*(a17->isa + 1))(a17);
  }

  if (a12)
  {
    sub_100004A34(a12);
  }

  sub_100004A34(v17);
  _Unwind_Resume(a1);
}

void sub_101640C6C(uint64_t a1, dispatch_object_t *a2)
{
  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_101640D70(uint64_t a1, int a2, ServiceStage *this)
{
  ServiceStage::holdOffStage(&group[1], this);
  v4 = *(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_101640E84(void *a1, char a2, char a3, char a4, uint64_t a5)
{
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_101640FA8;
  v11[3] = &unk_101F5B9B8;
  v12 = a2;
  v13 = a3;
  v14 = a4;
  v11[4] = a1;
  v11[5] = a5;
  v6 = a1[2];
  if (!v6 || (v7 = a1[1], (v8 = std::__shared_weak_count::lock(v6)) == 0))
  {
    sub_100013CC4();
  }

  v9 = v8;
  v10 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_101643FB8;
  block[3] = &unk_101F5BE48;
  block[5] = v7;
  v16 = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v11;
  dispatch_async(v10, block);
  if (v16)
  {
    sub_100004A34(v16);
  }

  sub_100004A34(v9);
}

void sub_101640FA8(uint64_t a1)
{
  v2 = *(a1 + 32);
  if (*(a1 + 48))
  {
    *(v2 + 80) = 0;
LABEL_6:
    *buf = 0;
    v8 = 0;
    sub_1016410C4(buf, v2);
    v4 = *buf;
    sub_101641340(*buf, *(a1 + 48), *(a1 + 49), *(a1 + 50), 0, *(a1 + 40));
    if (capabilities::ct::supportsReportingTetheringStateToBaseband(v5))
    {
      sub_10005C7A4(&v6, (v4 + 88));
      sub_101641D3C(v2, &v6);
      sub_100005978(&v6);
    }

    if (v8)
    {
      sub_100004A34(v8);
    }

    return;
  }

  if (*(v2 + 80) != 1)
  {
    goto LABEL_6;
  }

  v3 = *(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I MIS retries stopped", buf, 2u);
  }
}

void sub_10164109C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  sub_100005978(&a10);
  if (a12)
  {
    sub_100004A34(a12);
  }

  _Unwind_Resume(a1);
}

std::__shared_weak_count *sub_1016410C4(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  v4 = *(a2 + 96);
  if (!v4 || (result = std::__shared_weak_count::lock(v4), (a1[1] = result) == 0) || (v6 = *(a2 + 88), (*a1 = v6) == 0))
  {
    operator new();
  }

  return result;
}

void sub_1016412A4(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, sub_1016431E8);
  __cxa_rethrow();
}

void sub_1016412CC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  if (*(v1 + 8))
  {
    sub_100004A34(*(v1 + 8));
  }

  _Unwind_Resume(a1);
}

void sub_101641340(uint64_t a1, int a2, _BOOL4 a3, char a4, _BOOL4 a5, uint64_t a6)
{
  v12 = *(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    if (a2)
    {
      v13 = "reset & ";
    }

    else
    {
      v13 = "";
    }

    *buf = 136315906;
    *&buf[4] = v13;
    *&buf[12] = 2080;
    *&buf[14] = a6;
    *&buf[22] = 2080;
    *&buf[24] = asStringBool(a3);
    LOWORD(v71) = 2080;
    *(&v71 + 2) = asStringBool(a5);
    _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Calls to %scheck MIS avalibility on %s, onlyForUnknownAuth=%s, pingOnly=%s", buf, 0x2Au);
  }

  v57 = a5;
  v58 = a3;
  v14 = *(a1 + 16);
  if (!v14 || (v15 = *(a1 + 8), (v16 = std::__shared_weak_count::lock(v14)) == 0))
  {
    sub_100013CC4();
  }

  v17 = v16;
  v67[0] = _NSConcreteStackBlock;
  v67[1] = 1174405120;
  v67[2] = sub_1016432B8;
  v67[3] = &unk_101F5BC18;
  v67[4] = a1;
  v67[5] = v15;
  v68 = v16;
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  v18 = sub_10164241C(a1, v67);
  v19 = v68;
  if (v68)
  {
    sub_100004A34(v68);
  }

  if (!v18)
  {
    goto LABEL_88;
  }

  if (!capabilities::ct::supportsReportingTetheringStateToBaseband(v19))
  {
    goto LABEL_22;
  }

  v20 = *(a1 + 64);
  if (!v20 || *(a1 + 88))
  {
    goto LABEL_22;
  }

  v83 = 0u;
  v84 = 0u;
  v81 = 0u;
  v82 = 0u;
  v79 = 0u;
  v80 = 0u;
  v77 = 0u;
  v78 = 0u;
  v75 = 0u;
  v76 = 0u;
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  memset(buf, 0, sizeof(buf));
  if ((_NETRBClientGetDynamicStoreKey(v20, buf) & 1) == 0)
  {
    v22 = *(a1 + 40);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_22;
    }

    *v69 = 0;
    v24 = "_NETRBClientGetDynamicStoreKey failed";
LABEL_90:
    _os_log_error_impl(&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, v24, v69, 2u);
    goto LABEL_22;
  }

  v21 = CFStringCreateWithCString(kCFAllocatorDefault, buf, 0x8000100u);
  v22 = *(a1 + 40);
  if (v21)
  {
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *v69 = 0;
      _os_log_impl(&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I PHS key retreived successfully", v69, 2u);
    }

    v23 = *(a1 + 88);
    *(a1 + 88) = v21;
    *v69 = v23;
    sub_100005978(v69);
    goto LABEL_22;
  }

  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *v69 = 0;
    v24 = "_NETRBClientGetDynamicStoreKey failed to convert to CFStringRef";
    goto LABEL_90;
  }

LABEL_22:
  if (v58)
  {
    *v69 = 0;
    v66 = 0;
    if ((_NETRBClientGetGlobalServiceState(*(a1 + 64), v69, &v66) & 1) == 0)
    {
      v25 = *(a1 + 40);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 136315138;
        *&buf[4] = a6;
        _os_log_impl(&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#E Failed to get MIS state (%s)", buf, 0xCu);
      }
    }

    v26 = *v69;
    if ((*v69 - 1022) <= 0xFFFFFFFD)
    {
      v27 = *(a1 + 40);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 67109378;
        *&buf[4] = v26;
        *&buf[8] = 2080;
        *&buf[10] = a6;
        v28 = "#I MIS state is already known: %d, bailing out (%s)";
        v29 = v27;
        v30 = 18;
LABEL_63:
        _os_log_impl(&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v28, buf, v30);
      }

LABEL_87:
      sub_101642604(a1);
      goto LABEL_88;
    }

    v31 = v66;
    v32 = *(a1 + 40);
    v33 = os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
    if (v26 == 1021 && v31 == 3 && (a2 & 1) == 0)
    {
      if (!v33)
      {
        goto LABEL_87;
      }

      *buf = 67109634;
      *&buf[4] = 1021;
      *&buf[8] = 1024;
      *&buf[10] = 3;
      *&buf[14] = 2080;
      *&buf[16] = a6;
      v28 = "#I NOT retrying when MIS state is: %d, the reason is: %d (%s)";
      v29 = v32;
      goto LABEL_58;
    }

    if (v33)
    {
      *buf = 67109634;
      *&buf[4] = v26;
      *&buf[8] = 1024;
      *&buf[10] = v31;
      *&buf[14] = 2080;
      *&buf[16] = a6;
      _os_log_impl(&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I retrying when MIS state is: %d, the reason is: %d (%s)", buf, 0x18u);
    }
  }

  v34 = *(a1 + 72);
  if (!v34)
  {
    goto LABEL_52;
  }

  v35 = *(a1 + 40);
  v36 = os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT);
  if (a4)
  {
    if (v36)
    {
      *buf = 136315138;
      *&buf[4] = a6;
      _os_log_impl(&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I MIS Authentication interrupted (%s)", buf, 0xCu);
      v34 = *(a1 + 72);
    }

    dispatch_source_cancel(v34);
    dispatch_release(*(a1 + 72));
    *(a1 + 72) = 0;
    v37 = *(a1 + 64);
    if (!v37)
    {
      v39 = *(a1 + 40);
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        goto LABEL_52;
      }

      *buf = 0;
      v41 = "#I MIS Authentication interrupted while fClientRef not present";
      goto LABEL_51;
    }

    v38 = _NETRBClientStopService(v37);
    v39 = *(a1 + 40);
    v40 = os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
    if (v38)
    {
      if (v40)
      {
        *buf = 0;
        _os_log_impl(&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I MIS Stopping", buf, 2u);
      }

      *(a1 + 80) = 1;
      *(a1 + 81) |= a2;
      goto LABEL_88;
    }

    if (v40)
    {
      *buf = 0;
      v41 = "#E MIS failed to stop";
LABEL_51:
      _os_log_impl(&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, v41, buf, 2u);
    }

LABEL_52:
    if (a2)
    {
      sub_1016424F0(a1);
    }

    if (v57)
    {
      *v69 = 0;
      v66 = 0;
      GlobalServiceState = _NETRBClientGetGlobalServiceState(*(a1 + 64), v69, &v66);
      v43 = *(a1 + 40);
      v44 = os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT);
      if ((GlobalServiceState & 1) == 0)
      {
        if (v44)
        {
          *buf = 136315138;
          *&buf[4] = a6;
          v28 = "#E Failed to get MIS state (%s)";
          v29 = v43;
          v30 = 12;
          goto LABEL_63;
        }

        goto LABEL_87;
      }

      if (!v44)
      {
        goto LABEL_87;
      }

      *buf = 67109634;
      *&buf[4] = *v69;
      *&buf[8] = 1024;
      *&buf[10] = v66;
      *&buf[14] = 2080;
      *&buf[16] = a6;
      v28 = "#I MIS state is: %d, the reason is: %d (%s)";
      v29 = v43;
LABEL_58:
      v30 = 24;
      goto LABEL_63;
    }

    *v69 = 0;
    v45 = xpc_dictionary_create(0, 0, 0);
    v46 = v45;
    if (v45)
    {
      *v69 = v45;
    }

    else
    {
      v46 = xpc_null_create();
      *v69 = v46;
      if (!v46)
      {
        v47 = xpc_null_create();
        v46 = 0;
        goto LABEL_69;
      }
    }

    if (xpc_get_type(v46) == &_xpc_type_dictionary)
    {
      xpc_retain(v46);
      goto LABEL_70;
    }

    v47 = xpc_null_create();
LABEL_69:
    *v69 = v47;
LABEL_70:
    xpc_release(v46);
    v64 = xpc_uint64_create(1uLL);
    if (!v64)
    {
      v64 = xpc_null_create();
    }

    *buf = v69;
    *&buf[8] = netrbClientDeviceType[0];
    sub_10000F688(buf, &v64, &object);
    xpc_release(object);
    object = 0;
    xpc_release(v64);
    v64 = 0;
    started = _NETRBClientStartService(*(a1 + 64), 0, 201, 301, *v69);
    v49 = *(a1 + 40);
    v50 = os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT);
    if (started)
    {
      if (v50)
      {
        *buf = 0;
        _os_log_impl(&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I Starting MIS service.", buf, 2u);
      }

      *(a1 + 80) = 0;
      v51 = dispatch_time(0, 60000000000);
      v52 = dispatch_source_create(&_dispatch_source_type_timer, 1uLL, 0, *(a1 + 24));
      *(a1 + 72) = v52;
      v53 = *(a1 + 40);
      v54 = os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT);
      if (v52)
      {
        if (v54)
        {
          *buf = 0;
          _os_log_impl(&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I fCleanTimer created", buf, 2u);
          v52 = *(a1 + 72);
        }

        handler[0] = _NSConcreteStackBlock;
        handler[1] = 1174405120;
        handler[2] = sub_101643518;
        handler[3] = &unk_101F5BC48;
        handler[4] = a1;
        handler[5] = v15;
        v60 = v17;
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        v61 = v58;
        v62 = a4;
        v63 = 0;
        dispatch_source_set_event_handler(v52, handler);
        dispatch_source_set_timer(*(a1 + 72), v51, 0xFFFFFFFFFFFFFFFFLL, 0x12A05F200uLL);
        dispatch_activate(*(a1 + 72));
        if (v60)
        {
          sub_100004A34(v60);
        }

        xpc_release(*v69);
        goto LABEL_88;
      }

      if (v54)
      {
        *buf = 0;
        v55 = "#E Failed to created Clean Timer.";
        v56 = v53;
        goto LABEL_85;
      }
    }

    else if (v50)
    {
      *buf = 0;
      v55 = "#E Failed to start MIS service.";
      v56 = v49;
LABEL_85:
      _os_log_impl(&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, v55, buf, 2u);
    }

    xpc_release(*v69);
    goto LABEL_87;
  }

  if (v36)
  {
    *buf = 136315138;
    *&buf[4] = a6;
    _os_log_impl(&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I MIS Authentication already active (%s)", buf, 0xCu);
  }

LABEL_88:
  sub_100004A34(v17);
}

void sub_101641CB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, xpc_object_t object)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

void sub_101641D3C(uint64_t a1, void **a2)
{
  if (*a2 && !*(a1 + 112))
  {
    values = *a2;
    v4 = *(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      HIDWORD(buf.info) = 0;
      buf.retain = 0;
      ctu::cf::assign();
      *__p = 0u;
      v14 = 0;
      LODWORD(buf.version) = 136315138;
      *(&buf.version + 4) = __p;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Starting PHS DS listener for key: %s", &buf, 0xCu);
      if (SHIBYTE(v14) < 0)
      {
        operator delete(__p[0]);
      }
    }

    buf.version = 0;
    buf.info = a1;
    memset(&buf.retain, 0, 24);
    v5 = SCDynamicStoreCreate(kCFAllocatorDefault, @"com.apple.CommCenter:PHSStateListener", sub_101642D1C, &buf);
    v6 = *(a1 + 112);
    *(a1 + 112) = v5;
    __p[0] = v6;
    sub_10048662C(__p);
    if (*(a1 + 112))
    {
      v12 = CFArrayCreate(0, &values, 1, &kCFTypeArrayCallBacks);
      if (SCDynamicStoreSetNotificationKeys(*(a1 + 112), v12, 0))
      {
        if (SCDynamicStoreSetDispatchQueue(*(a1 + 112), *(a1 + 24)))
        {
          sub_100222570((a1 + 104), a2);
          v7 = *(a1 + 40);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p[0]) = 0;
            _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I fPhsStore created successfully", __p, 2u);
          }

          sub_101642910(a1);
          goto LABEL_18;
        }

        v9 = *(a1 + 40);
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
LABEL_17:
          v11 = *(a1 + 112);
          *(a1 + 112) = 0;
          __p[0] = v11;
          sub_10048662C(__p);
LABEL_18:
          sub_100010250(&v12);
          return;
        }

        LOWORD(__p[0]) = 0;
        v10 = "fPhsStore SCDynamicStoreSetDispatchQueue failed";
      }

      else
      {
        v9 = *(a1 + 40);
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          goto LABEL_17;
        }

        LOWORD(__p[0]) = 0;
        v10 = "fPhsStore SCDynamicStoreSetNotificationKeys failed";
      }

      _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v10, __p, 2u);
      goto LABEL_17;
    }

    v8 = *(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "fPhsStore SCDynamicStore failed", __p, 2u);
    }
  }
}

void sub_101641FF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_101642024(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10164213C;
  v7[3] = &unk_101F5B9D8;
  v7[4] = a1;
  v2 = a1[2];
  if (!v2 || (v3 = a1[1], (v4 = std::__shared_weak_count::lock(v2)) == 0))
  {
    sub_100013CC4();
  }

  v5 = v4;
  v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_101643FB8;
  block[3] = &unk_101F5BE48;
  block[5] = v3;
  v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9)
  {
    sub_100004A34(v9);
  }

  sub_100004A34(v5);
}

void sub_10164213C(uint64_t a1)
{
  v1 = *(a1 + 32);
  v5 = 0;
  v6 = 0;
  sub_1016410C4(&v5, v1);
  v2 = v5;
  sub_101641340(v5, 0, 0, 0, 1, "ping");
  if (capabilities::ct::supportsReportingTetheringStateToBaseband(v3))
  {
    sub_10005C7A4(&v4, (v2 + 88));
    sub_101641D3C(v1, &v4);
    sub_100005978(&v4);
  }

  if (v6)
  {
    sub_100004A34(v6);
  }
}

void sub_1016421CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  sub_100005978(&a10);
  if (a12)
  {
    sub_100004A34(a12);
  }

  _Unwind_Resume(a1);
}

void sub_1016421F4(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_10164230C;
  v8[3] = &unk_101F5B9F8;
  v8[4] = a1;
  v8[5] = a2;
  v3 = a1[2];
  if (!v3 || (v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0))
  {
    sub_100013CC4();
  }

  v6 = v5;
  v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_101643FB8;
  block[3] = &unk_101F5BE48;
  block[5] = v4;
  v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10)
  {
    sub_100004A34(v10);
  }

  sub_100004A34(v6);
}

void sub_10164230C(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(a1 + 40);
    LODWORD(v6) = 136315138;
    *(&v6 + 4) = v4;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Calls to reset MIS avalibility on %s", &v6, 0xCu);
  }

  *(v2 + 80) = 0;
  v6 = 0uLL;
  sub_1016410C4(&v6, v2);
  v5 = v6;
  if (sub_10164241C(v6, 0))
  {
    sub_1016424F0(v5);
    sub_101642604(v5);
  }

  if (*(&v6 + 1))
  {
    sub_100004A34(*(&v6 + 1));
  }
}

BOOL sub_10164241C(uint64_t a1, const void *a2)
{
  if (*(a1 + 64))
  {
    return 1;
  }

  v10 = v2;
  v11 = v3;
  v6 = _NETRBClientCreate(*(a1 + 24), a2, 0);
  *(a1 + 64) = v6;
  v7 = *(a1 + 40);
  if (v6)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *v8 = 0;
      _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I MIS Client attached.", v8, 2u);
    }

    return 1;
  }

  else
  {
    result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to attach to MIS Client.", buf, 2u);
      return 0;
    }
  }

  return result;
}

void sub_1016424F0(uint64_t a1)
{
  v13 = 0;
  v12 = 0;
  if ((_NETRBClientGetGlobalServiceState(*(a1 + 64), &v13, &v12) & 1) == 0)
  {
    v2 = *(a1 + 40);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }

    *buf = 0;
    v3 = "#E Failed to get MIS state.";
    v4 = buf;
    v5 = v2;
    goto LABEL_6;
  }

  if (v13 == 1020)
  {
LABEL_3:
    *(a1 + 81) = 0;
    return;
  }

  v6 = _NETRBClientSetGlobalServiceState(*(a1 + 64), 1020);
  v7 = *(a1 + 40);
  v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v8)
    {
      *v9 = 0;
      _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Called to reset", v9, 2u);
    }

    goto LABEL_3;
  }

  if (v8)
  {
    v10 = 0;
    v3 = "#E Failed to reset MIS state.";
    v4 = &v10;
    v5 = v7;
LABEL_6:
    _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v3, v4, 2u);
  }
}

void sub_101642604(uint64_t a1)
{
  v2 = *(a1 + 64);
  if (v2)
  {
    v3 = _NETRBClientDestroy(v2);
    *(a1 + 64) = 0;
    v4 = *(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I MIS Client detached.", buf, 2u);
    }

    if ((v3 & 1) == 0)
    {
      v5 = *(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *v6 = 0;
        _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E Failed to detach from MIS.", v6, 2u);
      }
    }
  }
}

void sub_1016426C4(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_1016427DC;
  v7[3] = &unk_101F5BA18;
  v7[4] = a1;
  v2 = a1[2];
  if (!v2 || (v3 = a1[1], (v4 = std::__shared_weak_count::lock(v2)) == 0))
  {
    sub_100013CC4();
  }

  v5 = v4;
  v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_101643FB8;
  block[3] = &unk_101F5BE48;
  block[5] = v3;
  v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9)
  {
    sub_100004A34(v9);
  }

  sub_100004A34(v5);
}

void sub_1016427EC(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_101642904;
  v7[3] = &unk_101F5BA38;
  v7[4] = a1;
  v2 = a1[2];
  if (!v2 || (v3 = a1[1], (v4 = std::__shared_weak_count::lock(v2)) == 0))
  {
    sub_100013CC4();
  }

  v5 = v4;
  v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_101643FB8;
  block[3] = &unk_101F5BE48;
  block[5] = v3;
  v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9)
  {
    sub_100004A34(v9);
  }

  sub_100004A34(v5);
}

const void **sub_101642910(uint64_t a1)
{
  valuePtr = 0;
  cf = 0;
  v24 = SCDynamicStoreCopyValue(*(a1 + 112), *(a1 + 104));
  sub_100138C38(&cf, &v24);
  if (!cf)
  {
    v8 = *(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      return sub_10001021C(&cf);
    }

    LOWORD(v24) = 0;
    v9 = "Cannot find PHS dictionary";
LABEL_13:
    _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v9, &v24, 2u);
    return sub_10001021C(&cf);
  }

  v2 = CFGetTypeID(cf);
  if (v2 != CFDictionaryGetTypeID())
  {
    v8 = *(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      return sub_10001021C(&cf);
    }

    LOWORD(v24) = 0;
    v9 = "PHS dictionary of wrong type";
    goto LABEL_13;
  }

  theArray = 0;
  Value = CFDictionaryGetValue(cf, @"InternalInterfaces");
  v4 = Value;
  if (Value && (v5 = CFGetTypeID(Value), v5 == CFArrayGetTypeID()))
  {
    theArray = v4;
    CFRetain(v4);
    if (theArray)
    {
      if (CFArrayGetCount(theArray) > 0)
      {
        v24 = a1;
        v25 = theArray;
        if (theArray)
        {
          CFRetain(theArray);
          v6 = v24;
          v7 = v25;
        }

        else
        {
          v7 = 0;
          v6 = a1;
        }

        if ((sub_101642D88(v6, v7, kSCEntNetIPv4) & 1) == 0 && !sub_101642D88(v24, v25, kSCEntNetIPv6))
        {
          goto LABEL_38;
        }

        v15 = CFDictionaryGetValue(cf, @"Hosts");
        v16 = v15;
        if (v15 && (v17 = CFGetTypeID(v15), v17 == CFDictionaryGetTypeID()) && CFDictionaryGetCount(v16))
        {
          v18 = CFDictionaryGetValue(v16, @"Current");
          v19 = v18;
          if (v18)
          {
            v20 = CFGetTypeID(v18);
            if (v20 == CFNumberGetTypeID())
            {
              CFNumberGetValue(v19, kCFNumberIntType, &valuePtr);
LABEL_38:
              v23 = *(a1 + 40);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
              {
                *buf = 67109120;
                v30 = valuePtr;
                _os_log_impl(&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I PHS: %d connected devices", buf, 8u);
              }

              sub_100010250(&v25);
              v12 = valuePtr;
              goto LABEL_19;
            }
          }

          v21 = *(a1 + 40);
          if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            goto LABEL_38;
          }

          *buf = 0;
          v22 = "#N No devices in PHS dictionary";
        }

        else
        {
          v21 = *(a1 + 40);
          if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            goto LABEL_38;
          }

          *buf = 0;
          v22 = "#N No hosts in PHS dictionary";
        }

        _os_log_impl(&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v22, buf, 2u);
        goto LABEL_38;
      }

      v10 = *(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v24) = 0;
        v11 = "#I external interface in PHS dictionary is empty";
        goto LABEL_17;
      }

      goto LABEL_18;
    }
  }

  else
  {
    theArray = 0;
  }

  v10 = *(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v24) = 0;
    v11 = "#I Cannot find external interface in PHS dictionary";
LABEL_17:
    _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v11, &v24, 2u);
  }

LABEL_18:
  v12 = 0;
LABEL_19:
  if (*(a1 + 152) != v12)
  {
    *(a1 + 152) = v12;
    v13 = *(a1 + 144);
    if (v13)
    {
      (*(*v13 + 48))(v13, a1 + 152);
    }
  }

  sub_100010250(&theArray);
  return sub_10001021C(&cf);
}

void sub_101642CC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v6 = va_arg(va1, const void *);
  sub_100010250((v4 + 8));
  sub_100010250(va);
  sub_10001021C(va1);
  _Unwind_Resume(a1);
}

const void **sub_101642D1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = *(a3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *v6 = 0;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I PHS DS changed", v6, 2u);
  }

  return sub_101642910(a3);
}

uint64_t sub_101642D88(uint64_t a1, CFArrayRef theArray, const __CFString *a3)
{
  ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
  if (ValueAtIndex)
  {
    v6 = ValueAtIndex;
    v7 = CFGetTypeID(ValueAtIndex);
    if (v7 == CFStringGetTypeID())
    {
      v8 = v6;
    }

    else
    {
      v8 = 0;
    }
  }

  else
  {
    v8 = 0;
  }

  v17 = v8;
  NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, v8, a3);
  v16 = NetworkInterfaceEntity;
  if (!NetworkInterfaceEntity)
  {
    v11 = *(a1 + 40);
    v10 = 0;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_15;
    }

    *buf = 0;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N hasStateForNetworkType: no sharedIPKey", buf, 2u);
LABEL_14:
    v10 = 0;
    goto LABEL_15;
  }

  *buf = SCDynamicStoreCopyValue(*(a1 + 112), NetworkInterfaceEntity);
  if (!*buf)
  {
    v12 = *(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v14[0] = 0;
      _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N hasStateForNetworkType: no plistRef", v14, 2u);
    }

    sub_10000A1EC(buf);
    goto LABEL_14;
  }

  sub_10000A1EC(buf);
  v10 = 1;
LABEL_15:
  sub_100005978(&v16);
  sub_100005978(&v17);
  return v10;
}

void sub_101642ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, const void *);
  sub_100005978(va);
  sub_100005978(va1);
  _Unwind_Resume(a1);
}

void sub_101642EFC(uint64_t a1)
{
  v2 = *(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: ========= MISService =========", buf, 2u);
    v2 = *(a1 + 40);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = asStringBool(*(a1 + 80));
    v4 = *(a1 + 104);
    if (v4)
    {
      v10 = 0uLL;
      v11 = 0;
      ctu::cf::assign();
      *__p = 0uLL;
      v9 = 0;
      v5 = __p;
    }

    else
    {
      v5 = "null";
    }

    v6 = asStringBool(*(a1 + 112) != 0);
    v7 = *(a1 + 152);
    *buf = 136315906;
    v13 = v3;
    v14 = 2082;
    v15 = v5;
    v16 = 2080;
    v17 = v6;
    v18 = 1024;
    v19 = v7;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fStopRetries: %s, fPhsKey: %{public}s, fPhsStore: %s, fPhsClientsSource = %d", buf, 0x26u);
    if (v4)
    {
      if (SHIBYTE(v9) < 0)
      {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_101643098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016430D0(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void sub_101643154(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1016431A8(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1016431E8(uint64_t result)
{
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t sub_101643214(uint64_t a1)
{
  *a1 = off_101F5BB70;
  sub_101642604(a1);
  sub_100005978((a1 + 88));
  v2 = *(a1 + 56);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 40));
  sub_1000C0544((a1 + 8));
  return a1;
}

void sub_101643280(uint64_t a1)
{
  sub_101643214(a1);

  operator delete();
}

uint64_t sub_1016432B8(uint64_t a1, int a2, xpc_object_t xdict)
{
  v3 = *(a1 + 32);
  if (a2 == 1001)
  {
    v5 = *(v3 + 72);
    if (v5)
    {
      v6 = *(v3 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v14) = 0;
        _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I MIS Authentication responseHandler. fCleanTimer canceled", &v14, 2u);
        v5 = *(v3 + 72);
      }

      dispatch_source_cancel(v5);
      dispatch_release(*(v3 + 72));
      *(v3 + 72) = 0;
    }

    uint64 = xpc_dictionary_get_uint64(xdict, netrbClientNotificationKey[0]);
    v8 = *(v3 + 40);
    v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if (uint64 == 5002)
    {
      if (v9)
      {
        LOWORD(v14) = 0;
        _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I MIS Authentication Successfull", &v14, 2u);
      }

      v10 = *(v3 + 64);
      if (v10)
      {
        _NETRBClientStopService(v10);
      }
    }

    else
    {
      if (v9)
      {
        v14 = 134217984;
        v15 = uint64;
        _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I MIS Authentication complete with notification: %lld", &v14, 0xCu);
      }

      if (uint64 == 5003 && *(v3 + 80) == 1)
      {
        sub_101643680(v3, *(v3 + 81), 0, 1, 0, "Start failed with NETRB_FAILURE");
      }
    }

    sub_101642604(v3);
  }

  else
  {
    v12 = *(v3 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v14 = 67109120;
      LODWORD(v15) = a2;
      _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I MIS responseHandler response: %d", &v14, 8u);
    }

    if (a2 == 1002 && *(v3 + 80) == 1)
    {
      sub_101643680(v3, *(v3 + 81), 0, 1, 0, "deffered Stop");
    }
  }

  return 0;
}

uint64_t sub_1016434EC(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 48);
  *(result + 40) = *(a2 + 40);
  *(result + 48) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_101643508(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (v1)
  {
    sub_100004A34(v1);
  }
}

void sub_101643518(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Cleaning Time out triggered before misd finished querying.", buf, 2u);
  }

  dispatch_source_cancel(*(v2 + 72));
  dispatch_release(*(v2 + 72));
  *(v2 + 72) = 0;
  v4 = *(v2 + 64);
  if (v4)
  {
    v5 = _NETRBClientStopService(v4);
    v6 = *(v2 + 40);
    v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      if (v7)
      {
        v13 = 0;
        v8 = "#I MIS Stopping";
        v9 = &v13;
LABEL_13:
        _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v8, v9, 2u);
      }
    }

    else if (v7)
    {
      *v12 = 0;
      v8 = "#E MIS failed to stop";
      v9 = v12;
      goto LABEL_13;
    }
  }

  else if (*(v2 + 80) == 1)
  {
    v10 = *(v2 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *v11 = 0;
      _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I trying MIS again", v11, 2u);
    }

    sub_101643680(v2, *(v2 + 81), *(a1 + 56), *(a1 + 57), *(a1 + 58), "timed out");
  }

  sub_101642604(v2);
}

void sub_101643680(void *a1, char a2, char a3, char a4, char a5, uint64_t a6)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_1016437A8;
  v12[3] = &unk_101F5BC78;
  v13 = a2;
  v14 = a3;
  v15 = a4;
  v16 = a5;
  v12[4] = a1;
  v12[5] = a6;
  v7 = a1[2];
  if (!v7 || (v8 = a1[1], (v9 = std::__shared_weak_count::lock(v7)) == 0))
  {
    sub_100013CC4();
  }

  v10 = v9;
  v11 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1016437C4;
  block[3] = &unk_101F5BCA0;
  block[5] = v8;
  v18 = v10;
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v12;
  dispatch_async(v11, block);
  if (v18)
  {
    sub_100004A34(v18);
  }

  sub_100004A34(v10);
}

uint64_t sub_1016437D4(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 48);
  *(result + 40) = *(a2 + 40);
  *(result + 48) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_1016437F0(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (v1)
  {
    sub_100004A34(v1);
  }
}

void sub_101643804(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101643858(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101643898(uint64_t result)
{
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void sub_1016438C4(ServiceManager::Service *this)
{
  *this = off_101F5BD40;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_101643920(ServiceManager::Service *this)
{
  *this = off_101F5BD40;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_1016439A0@<X0>(void *a1@<X8>)
{
  v2 = 2;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  return sub_1000FF040(a1, &v2, &vars0, 1);
}

void sub_1016439E4(uint64_t a1, NSObject **a2)
{
  v2 = *(a1 + 8);
  v3 = *a2;
  group = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }

  (*(*v2 + 64))(v2, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group)
    {
      dispatch_release(group);
    }
  }
}

void sub_101643A6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }

  _Unwind_Resume(exception_object);
}

uint64_t *sub_101643AFC(void *a1)
{
  v1 = *a1;
  v7 = a1;
  v8 = v1;
  v2 = *(v1 + 8);
  Registry::createRestModuleOneTimeUseConnection(&v9, *(v2 + 48));
  ctu::RestModule::connect();
  if (v10)
  {
    sub_100004A34(v10);
  }

  v3 = (v2 + 120);
  v11[0] = off_101F5BDC0;
  v11[1] = v2 + 64;
  v12 = v11;
  if (v11 != (v2 + 120))
  {
    v4 = *(v2 + 144);
    if (v4 == v3)
    {
      v13[1] = v2 + 64;
      v13[2] = 0;
      v12 = 0;
      v13[0] = off_101F5BDC0;
      (*(*v4 + 24))(v4, v11);
      (*(**(v2 + 144) + 32))(*(v2 + 144));
      *(v2 + 144) = 0;
      v12 = v11;
      (*(v13[0] + 24))(v13, v2 + 120);
      (*(v13[0] + 32))(v13);
    }

    else
    {
      *(v2 + 120) = off_101F5BDC0;
      *(v2 + 128) = v2 + 64;
      v12 = v4;
    }

    *(v2 + 144) = v3;
  }

  sub_1016430D0(v11);
  v5 = *(v2 + 144);
  if (v5)
  {
    (*(*v5 + 48))(v5, v2 + 152);
  }

  sub_100714410(&v8);
  return sub_1000049E0(&v7);
}

void sub_101643D0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_101643DBC(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F5BDC0;
  a2[1] = v2;
  return result;
}

void sub_101643DE8(uint64_t a1, int *a2)
{
  v2 = xpc_int64_create(*a2);
  if (!v2)
  {
    v2 = xpc_null_create();
  }

  sub_10000501C(&__p, "/cc/props/phs_clients");
  object = v2;
  if (v2)
  {
    xpc_retain(v2);
  }

  else
  {
    object = xpc_null_create();
  }

  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0)
  {
    operator delete(__p);
  }

  xpc_release(v2);
}

void sub_101643E98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_101643EE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_101643F2C(void **a1)
{
  v7 = a1;
  v1 = *a1;
  v2 = **a1;
  v3 = v2[12];
  v2[11] = 0;
  v2[12] = 0;
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  v4 = v2[14];
  v2[14] = 0;
  v8 = v4;
  sub_10048662C(&v8);
  v5 = v1[1];
  if (v5)
  {
    dispatch_group_leave(v5);
    v6 = v1[1];
    if (v6)
    {
      dispatch_release(v6);
    }
  }

  operator delete();
}

uint64_t sub_101643FC8(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 48);
  *(result + 40) = *(a2 + 40);
  *(result + 48) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_101643FE4(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (v1)
  {
    sub_100004A34(v1);
  }
}

void *sub_101643FFC(void *a1, void *a2)
{
  v5 = 3;
  LODWORD(__p) = 6776178;
  sub_10072A6B4(a1, a2, &__p, "reg", 0);
  *a1 = &off_101F5BF80;
  if (v5 < 0)
  {
    operator delete(__p);
  }

  *a1 = &off_101F5BF10;
  return a1;
}

void sub_101644098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10164413C(uint64_t a1)
{
  ServiceMap = Registry::getServiceMap(*(a1 + 40));
  v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    v4 = (v3 & 0x7FFFFFFFFFFFFFFFLL);
    v5 = 5381;
    do
    {
      v3 = v5;
      v6 = *v4++;
      v5 = (33 * v5) ^ v6;
    }

    while (v6);
  }

  std::mutex::lock(ServiceMap);
  v12 = v3;
  v7 = sub_100009510(&v2[1].__m_.__sig, &v12);
  if (v7)
  {
    v9 = v7[3];
    v8 = v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v8);
      v10 = 0;
      goto LABEL_9;
    }
  }

  else
  {
    v9 = 0;
  }

  std::mutex::unlock(v2);
  v8 = 0;
  v10 = 1;
LABEL_9:
  (*(*v9 + 264))(v9, 1);
  if ((v10 & 1) == 0)
  {
    sub_100004A34(v8);
  }

  return 1;
}

void sub_10164424C(_Unwind_Exception *exception_object)
{
  v3 = v1;
  if ((v3 & 1) == 0)
  {
    sub_100004A34(v2);
  }

  _Unwind_Resume(exception_object);
}

void sub_10164426C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v4 = *(a1 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(a3 + 23) >= 0)
    {
      v5 = a3;
    }

    else
    {
      v5 = *a3;
    }

    v6 = 136315138;
    v7 = v5;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s is releasing its registration notification assertion", &v6, 0xCu);
  }
}

void sub_101644318(uint64_t a1)
{
  ServiceMap = Registry::getServiceMap(*(a1 + 40));
  v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    v4 = (v3 & 0x7FFFFFFFFFFFFFFFLL);
    v5 = 5381;
    do
    {
      v3 = v5;
      v6 = *v4++;
      v5 = (33 * v5) ^ v6;
    }

    while (v6);
  }

  std::mutex::lock(ServiceMap);
  v11 = v3;
  v7 = sub_100009510(&v2[1].__m_.__sig, &v11);
  if (v7)
  {
    v9 = v7[3];
    v8 = v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v8);
      v10 = 0;
      goto LABEL_9;
    }
  }

  else
  {
    v9 = 0;
  }

  std::mutex::unlock(v2);
  v8 = 0;
  v10 = 1;
LABEL_9:
  (*(*v9 + 264))(v9, 0);
  if ((v10 & 1) == 0)
  {
    sub_100004A34(v8);
  }
}

void sub_101644424(_Unwind_Exception *exception_object)
{
  v3 = v1;
  if ((v3 & 1) == 0)
  {
    sub_100004A34(v2);
  }

  _Unwind_Resume(exception_object);
}

void sub_101644448(uint64_t a1)
{
  sub_10072A870(a1);

  operator delete();
}

void sub_101644484(uint64_t a1)
{
  sub_10072A870(a1);

  operator delete();
}

void sub_10164453C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    (*(*v1 + 8))(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_101644578(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1016445B0(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t sub_1016445E0(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

void sub_1016448B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11)
  {
    sub_100004A34(a11);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016449D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t object)
{
  v17 = *(v15 - 32);
  *(v15 - 32) = 0;
  if (v17)
  {
    (*(*v17 + 24))(v17);
  }

  objc_destroyWeak((v14 + 32));
  if (object)
  {
    dispatch_release(object);
  }

  objc_destroyWeak((v15 - 24));
  _Unwind_Resume(a1);
}

void sub_101644A30(uint64_t a1, uint64_t a2)
{
  WeakRetained = objc_loadWeakRetained((a1 + 32));
  v4 = WeakRetained;
  if (WeakRetained)
  {
    v5 = *WeakRetained[10];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 0;
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Handling iCloud change notification", v6, 2u);
    }

    [v4 handleiCloudAccountEventSync:a2];
  }
}

uint64_t sub_101644DB8(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F5C070;
  a2[1] = v2;
  return result;
}

void sub_101644DE4(uint64_t a1, BOOL *a2)
{
  v2 = xpc_BOOL_create(*a2);
  if (!v2)
  {
    v2 = xpc_null_create();
  }

  sub_10000501C(&__p, "/cc/props/edu_mode");
  object = v2;
  if (v2)
  {
    xpc_retain(v2);
  }

  else
  {
    object = xpc_null_create();
  }

  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0)
  {
    operator delete(__p);
  }

  xpc_release(v2);
}

void sub_101644E94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_101644EDC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1016452A0(uint64_t result)
{
  v1 = *(result + 8);
  *(result + 8) = 0;
  if (v1)
  {
    v2 = *(v1 + 8);
    *(v1 + 8) = 0;
    if (v2)
    {
      (*(*v2 + 32))(v2);
    }

    TMKXPCServer.shutdown()();
    operator delete();
  }

  return result;
}

void sub_10164531C(uint64_t a1, uint64_t a2, int a3)
{
  if (*(a1 + 273))
  {
    return;
  }

  if (sub_101645C4C(a1 + 232, 0))
  {
    sub_10007B7D8(a1 + 184);
    v6 = buf.__r_.__value_.__r.__words[0];
    sub_10000A1EC(&buf.__r_.__value_.__l.__data_);
    if (v6)
    {
      v7 = sub_100032AC8((a1 + 8));
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Protocol version has changed. Will ensure we start with a new conversation", &buf, 2u);
      }

      sub_10079CC68(a1 + 184);
    }

    v8 = sub_100032AC8((a1 + 8));
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(buf.__r_.__value_.__r.__words + 4) = "kV0";
      _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Updated current protocol version to: %s", &buf, 0xCu);
    }

    sub_101645D0C(a1 + 232, 0);
  }

  *(a1 + 273) = 1;
  v9 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (a3)
    {
      v10 = "yes";
    }

    else
    {
      v10 = "no";
    }

    if (*(a2 + 8) == 1)
    {
      std::to_string(&buf, *a2);
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        p_buf = &buf;
      }

      else
      {
        p_buf = buf.__r_.__value_.__r.__words[0];
      }

      *v47 = 136315394;
      *&v47[4] = v10;
      *&v47[12] = 2080;
      *&v47[14] = p_buf;
      _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Setting up conversation environment [Attempt Resume = %s][minimumRawConversationID=%s]", v47, 0x16u);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }

    else
    {
      *v47 = 136315394;
      *&v47[4] = v10;
      *&v47[12] = 2080;
      *&v47[14] = "<none>";
      _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Setting up conversation environment [Attempt Resume = %s][minimumRawConversationID=%s]", v47, 0x16u);
    }
  }

  *v47 = 0;
  *&v47[8] = 0;
  sub_10079CA24(v47, a1 + 16, @"ConversationDict", a1 + 64, 4);
  theDict = 0;
  sub_10007B7D8(v47);
  sub_100010180(&theDict, &buf.__r_.__value_.__l.__data_);
  sub_10000A1EC(&buf.__r_.__value_.__l.__data_);
  if (theDict)
  {
    Value = CFDictionaryGetValue(theDict, @"ConversationID");
    v13 = Value;
    if (Value)
    {
      v14 = CFGetTypeID(Value);
      if (v14 == CFNumberGetTypeID())
      {
        v15 = v13;
      }

      else
      {
        v15 = 0;
      }
    }

    else
    {
      v15 = 0;
    }

    v16 = CFDictionaryGetValue(theDict, @"AppIncoming");
    v17 = v16;
    if (v16)
    {
      v18 = CFGetTypeID(v16);
      if (v18 == CFDataGetTypeID())
      {
        v19 = v17;
      }

      else
      {
        v19 = 0;
      }
    }

    else
    {
      v19 = 0;
    }

    v20 = CFDictionaryGetValue(theDict, @"AppOutgoing");
    v21 = v20;
    if (v20 && (v22 = CFGetTypeID(v20), v22 == CFDataGetTypeID()) && v15 && v19)
    {
      if (CFDataGetLength(v19) == 32 && CFDataGetLength(v21) == 32)
      {
        buf.__r_.__value_.__r.__words[0] = 0;
        ctu::cf::assign(&buf, v15, v23);
        v24 = buf.__r_.__value_.__r.__words[0];
        *(a1 + 112) = buf.__r_.__value_.__r.__words[0];
        *(a1 + 120) = 1;
        if (a3 && (*(a2 + 8) != 1 || *a2 <= v24))
        {
          sub_10007B7D8(a1 + 184);
          sub_100432018(&buf, &BytePtr);
          sub_101645DC8(&buf);
          v26 = v25;
          sub_1003EC530(&buf.__r_.__value_.__l.__data_);
          sub_10000A1EC(&BytePtr);
          if (v26)
          {
            BytePtr = CFDataGetBytePtr(v19);
            CFDataGetBytePtr(v19);
            CFDataGetLength(v19);
            sub_101345E08();
          }
        }

        v41 = sub_100032AC8((a1 + 8));
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          if ((*(a1 + 120) & 1) == 0)
          {
            sub_1000D1644();
          }

          v42 = *(a1 + 112);
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v42;
          LOWORD(buf.__r_.__value_.__r.__words[1]) = 2048;
          *(&buf.__r_.__value_.__r.__words[1] + 2) = v42;
          _os_log_impl(&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I ConversationID: %hhu [Raw: %llu] is not eligible for resume", &buf, 0x12u);
        }

        goto LABEL_45;
      }

      v27 = sub_100032AC8((a1 + 8));
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        goto LABEL_44;
      }

      Length = CFDataGetLength(v19);
      v37 = CFDataGetLength(v21);
      LODWORD(buf.__r_.__value_.__l.__data_) = 134218496;
      *(buf.__r_.__value_.__r.__words + 4) = Length;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
      *(&buf.__r_.__value_.__r.__words[1] + 6) = v37;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2048;
      v46 = 32;
      v38 = "Conversation dict has invalid key size (incoming: %ld, outgoing: %ld). Expected size: %zu";
      v39 = v27;
      v40 = 32;
    }

    else
    {
      v27 = sub_100032AC8((a1 + 8));
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
LABEL_44:

        sub_10079CC68(v47);
        goto LABEL_45;
      }

      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      v38 = "Conversation dict has invalid enteries";
      v39 = v27;
      v40 = 2;
    }

    _os_log_error_impl(&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, v38, &buf, v40);
    goto LABEL_44;
  }

LABEL_45:
  sub_10001021C(&theDict);
  sub_10007B7D8(a1 + 184);
  v28 = buf.__r_.__value_.__r.__words[0];
  sub_10000A1EC(&buf.__r_.__value_.__l.__data_);
  if (v28)
  {
    sub_10079CC68(a1 + 184);
  }

  sub_10007B7D8(a1 + 200);
  v29 = buf.__r_.__value_.__r.__words[0];
  sub_10000A1EC(&buf.__r_.__value_.__l.__data_);
  if (v29)
  {
    sub_10079CC68(a1 + 200);
  }

  sub_10007B7D8(a1 + 216);
  v30 = buf.__r_.__value_.__r.__words[0];
  sub_10000A1EC(&buf.__r_.__value_.__l.__data_);
  if (v30)
  {
    sub_10079CC68(a1 + 216);
  }

  if (*(a1 + 120))
  {
    *(a1 + 104) = *(a1 + 112) + 1;
  }

  else
  {
    *(a1 + 104) = 0;
    v31 = sub_100032AC8((a1 + 8));
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I No previous conversation found.", &buf, 2u);
    }
  }

  if (*(a2 + 8) == 1 && *(a1 + 104) < *a2)
  {
    *(a1 + 104) = *a2;
    v32 = sub_100032AC8((a1 + 8));
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Picking conversationID based on minimumRawConversationID requirement", &buf, 2u);
    }
  }

  v33 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    v34 = *(a1 + 104);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v34;
    LOWORD(buf.__r_.__value_.__r.__words[1]) = 2048;
    *(&buf.__r_.__value_.__r.__words[1] + 2) = v34;
    _os_log_impl(&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I [Final] Will use conversation: %hhu [Raw: %llu]", &buf, 0x12u);
  }

  v35 = *&v47[8];
  *&v47[8] = 0;
  if (v35)
  {
    (*(*v35 + 32))(v35);
  }

  TMKXPCServer.shutdown()();
}

void sub_101645B7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_10079CC90(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101645C4C(uint64_t a1, char a2)
{
  if (*(a1 + 18) != 1 || (a2 & 1) != 0)
  {
    *(a1 + 18) = 1;
    v7 = 0;
    sub_10007B7D8(*(a1 + 8));
    sub_10010B240(&v7, &v6);
    sub_10000A1EC(&v6);
    if (v7)
    {
      LODWORD(v6) = 0;
      ctu::cf::assign(&v6, v7, v4);
      v3 = v6;
    }

    else
    {
      v3 = *(a1 + 16);
    }

    *(a1 + 17) = v3;
    sub_100029A48(&v7);
  }

  else
  {
    return *(a1 + 17);
  }

  return v3;
}

void sub_101645CE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100029A48(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101645D0C(uint64_t a1, unsigned int a2)
{
  *(a1 + 18) = 1;
  *(a1 + 17) = a2;
  v2 = *(a1 + 8);
  v8 = 0;
  valuePtr = a2;
  v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v3)
  {
    v8 = v3;
    valuePtr = 0;
    sub_100029A48(&valuePtr);
    v4 = v8;
  }

  else
  {
    v4 = 0;
  }

  v7 = v4;
  v8 = 0;
  sub_100029A48(&v8);
  v5 = sub_10079CC40(v2);
  sub_100029A48(&v7);
  return v5;
}

void sub_101645DA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100029A48(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101645DC8(CFDateRef *a1)
{
  if (!*a1)
  {
    return 0;
  }

  Current = CFAbsoluteTimeGetCurrent();
  v5 = CFDateCreate(kCFAllocatorDefault, Current);
  TimeIntervalSinceDate = CFDateGetTimeIntervalSinceDate(*a1, v5);
  sub_1003EC530(&v5);
  if (TimeIntervalSinceDate <= 0.0)
  {
    return 0;
  }

  else
  {
    return (TimeIntervalSinceDate * 1000.0);
  }
}

void sub_101645E5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1003EC530(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101645E78(uint64_t a1)
{
  if (*(a1 + 274) == 1)
  {
    v2 = sub_100032AC8((a1 + 8));
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v6[0]) = 0;
      _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Most likely a duplicate ack for start", v6, 2u);
    }

LABEL_4:

    return 0;
  }

  if (*(a1 + 273) != 1 || !*(a1 + 88) || !*(a1 + 152) || !*(a1 + 168))
  {
    v2 = sub_100032AC8((a1 + 8));
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v6[0]) = 0;
      _os_log_error_impl(&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Start message was acked but conversation environment is not ready!", v6, 2u);
    }

    goto LABEL_4;
  }

  v4 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(a1 + 104);
    v6[0] = 67109376;
    v6[1] = v5;
    v7 = 2048;
    v8 = v5;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Start message acked for ConversationID: %hhu [Raw: %llu]", v6, 0x12u);
  }

  result = 1;
  *(a1 + 274) = 1;
  return result;
}

void sub_101646044(uint64_t a1)
{
  if ((*(a1 + 277) & 1) == 0)
  {
    if (*(a1 + 273) == 1 && *(a1 + 88) && *(a1 + 152) && *(a1 + 168))
    {
      v2 = sub_100032AC8((a1 + 8));
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        v3 = *(a1 + 104);
        LODWORD(v10) = 67109376;
        HIDWORD(v10) = v3;
        LOWORD(v11[0]) = 2048;
        *(v11 + 2) = v3;
        _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I First attempt for start was made for ConversationID: %hhu [Raw: %llu]. Persisting keys.", &v10, 0x12u);
      }

      v4 = *(a1 + 104);
      *(a1 + 277) = 1;
      *(a1 + 112) = v4;
      *(a1 + 120) = 1;
      v5 = objc_alloc_init(NSMutableDictionary);
      v6 = [NSNumber numberWithUnsignedLongLong:*(a1 + 104)];
      v7 = [NSData dataWithBytes:**(a1 + 152) length:*(*(a1 + 152) + 8) - **(a1 + 152)];
      v8 = [NSData dataWithBytes:**(a1 + 168) length:*(*(a1 + 168) + 8) - **(a1 + 168)];
      [v5 setValue:v6 forKey:@"ConversationID"];
      [v5 setValue:v7 forKey:@"AppIncoming"];
      [v5 setValue:v8 forKey:@"AppOutgoing"];
      v10 = 0;
      v11[0] = 0;
      sub_10079CA24(&v10, a1 + 16, @"ConversationDict", a1 + 64, 4);
      sub_10079CC40(&v10);
      v9 = v11[0];
      v11[0] = 0;
      if (v9)
      {
        (*(*v9 + 32))(v9);
      }

      TMKXPCServer.shutdown()();
    }

    else
    {
      v5 = sub_100032AC8((a1 + 8));
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v10) = 0;
        _os_log_error_impl(&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "First attempt for start was made but conversation environment is not ready!", &v10, 2u);
      }
    }
  }
}

void sub_1016462B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10079CC90(&a9);

  _Unwind_Resume(a1);
}

void sub_101646308(uint64_t a1, __int128 *a2)
{
  v3 = *a2;
  *a2 = 0;
  *(a2 + 1) = 0;
  v4 = *(a1 + 264);
  *(a1 + 256) = v3;
  if (v4)
  {
    sub_100004A34(v4);
  }
}

AutoStartTimer *sub_101646328(uint64_t a1)
{
  result = *(a1 + 256);
  if (result)
  {
    return (AutoStartTimer::isExpired(result) ^ 1);
  }

  return result;
}

uint64_t sub_101646358(uint64_t a1)
{
  v6 = 0;
  sub_10007B7D8(a1 + 200);
  sub_10010B240(&v6, &v5);
  sub_10000A1EC(&v5);
  if (v6)
  {
    LOBYTE(v5) = 0;
    ctu::cf::assign(&v5, v6, v1);
    v2 = v5;
    sub_100029A48(&v6);
    v3 = 1;
  }

  else
  {
    sub_100029A48(&v6);
    v2 = 0;
    v3 = 0;
  }

  return v2 | (v3 << 8);
}

void sub_1016463DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100029A48(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101646400(uint64_t a1)
{
  v1 = sub_101646358(a1);
  if (((v1 + 1) & 0x100) != 0)
  {
    v2 = 1;
  }

  else
  {
    v2 = v1 + 1;
  }

  if ((v1 & 0xFF00) == 0)
  {
    return 0;
  }

  return v2;
}

void sub_101646438(uint64_t a1)
{
  v2 = sub_101646358(a1);
  if (v2 == 0xFF)
  {
    v3 = 1;
  }

  else
  {
    v3 = v2 + 1;
  }

  if ((v2 & 0xFF00) != 0)
  {
    v4 = v3;
  }

  else
  {
    v4 = 0;
  }

  v5 = [NSNumber numberWithUnsignedShort:v4];
  sub_10079CC40(a1 + 200);
}

BOOL sub_1016464CC(uint64_t a1)
{
  v4 = 0;
  sub_10007B7D8(a1 + 216);
  sub_10010B240(&v4, &v3);
  sub_10000A1EC(&v3);
  v1 = v4 != 0;
  sub_100029A48(&v4);
  return v1;
}

unint64_t sub_101646540(uint64_t a1)
{
  v5 = 0;
  sub_10007B7D8(a1 + 216);
  sub_10010B240(&v5, &v4);
  sub_10000A1EC(&v4);
  if (v5 && (LODWORD(v4) = 0, ctu::cf::assign(&v4, v5, v1), v2 = v4, v4))
  {
    sub_100029A48(&v5);
    return v2 | &_mh_execute_header;
  }

  else
  {
    sub_100029A48(&v5);
    return 0;
  }
}

void sub_1016465C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100029A48(va);
  _Unwind_Resume(a1);
}

void sub_1016465E4(uint64_t a1, uint64_t a2)
{
  v3 = [NSNumber numberWithUnsignedInt:a2];
  sub_10079CC40(a1 + 216);
}

const void **sub_101646658(const void **result)
{
  if (*(result + 274) == 1)
  {
    v1 = result;
    v2 = (result + 1);
    v3 = (*(*result + 8))(result);
    Current = CFAbsoluteTimeGetCurrent();
    v6 = CFDateCreate(kCFAllocatorDefault, Current + v3);
    v5 = sub_100032AC8(v2);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 134218240;
      v8 = v3;
      v9 = 2048;
      v10 = v3 / 60;
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Conversation resume eligiblity extended. Eligible until: %lld seconds (about %ld minutes) from now", buf, 0x16u);
    }

    sub_10079CC40((v1 + 23));
    return sub_1003EC530(&v6);
  }

  return result;
}

void sub_10164679C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1003EC530(va);
  _Unwind_Resume(a1);
}

uint64_t sub_1016467BC(uint64_t *a1, const void **a2)
{
  if (*(a1 + 274))
  {
LABEL_2:
    v2 = 0;
    v3 = 1;
    return v2 | v3;
  }

  if (*(a1 + 277) == 1)
  {
    v6 = *a2;
    v7 = a2[1] - *a2;
    v8 = a1[16];
    if (v7 == a1[17] - v8 && !memcmp(v6, v8, v7))
    {
      v15 = sub_100032AC8(a1 + 1);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 0;
        _os_log_impl(&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Newly generated app key is same as old key. No worries", buf, 2u);
      }

      goto LABEL_2;
    }

    v9 = sub_100032AC8(a1 + 1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "We had attempted start message, but app key changed before we could receive ack. Will bump conversationID next time", buf, 2u);
    }

    v3 = 0;
    v2 = 0xA00000000;
  }

  else
  {
    memset(buf, 0, sizeof(buf));
    v20 = 0;
    v10 = *a1;
    __p[0] = 0;
    __p[1] = 0;
    v18 = 0;
    v11 = (*(v10 + 56))(a1);
    if (sub_101335894(a1 + 1, v11, a2, buf, __p))
    {
      v12 = sub_100032AC8(a1 + 1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *v16 = 0;
        _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Derived incoming and outgoing keys", v16, 2u);
      }

      operator new();
    }

    v13 = sub_100032AC8(a1 + 1);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *v16 = 0;
      _os_log_error_impl(&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to derive incoming and outgoing keys", v16, 2u);
    }

    v3 = 0;
    v2 = 0x500000000;
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    if (*buf)
    {
      *&buf[8] = *buf;
      operator delete(*buf);
    }
  }

  return v2 | v3;
}

void sub_101646AE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a15)
  {
    operator delete(a15);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_101646B48(uint64_t a1)
{
  if (*(a1 + 274) != 1)
  {
    return 0;
  }

  sub_10007B7D8(a1 + 184);
  sub_100432018(&v4, &v3);
  v1 = sub_101645DC8(&v4);
  sub_1003EC530(&v4);
  sub_10000A1EC(&v3);
  return v1;
}

void sub_101646BC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_1003EC530(&a10);
  sub_10000A1EC(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_101646BF0@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  v2 = *(result + 160);
  *a2 = *(result + 152);
  a2[1] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

uint64_t sub_101646C0C@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  v2 = *(result + 176);
  *a2 = *(result + 168);
  a2[1] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_101646C28(void *a1, uint64_t *a2)
{
  if (((*(*a1 + 80))(a1, a1 + 11) & 1) == 0)
  {
    v5 = *a2;
    v4 = a2[1];
    if (v4)
    {
      atomic_fetch_add_explicit((v4 + 8), 1uLL, memory_order_relaxed);
    }

    v6 = a1[12];
    a1[11] = v5;
    a1[12] = v4;
    if (v6)
    {

      sub_100004A34(v6);
    }
  }
}

uint64_t sub_101646CB4@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  v2 = *(result + 96);
  *a2 = *(result + 88);
  a2[1] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

uint64_t sub_101646CD0(uint64_t a1)
{
  v2 = IOPSGetPercentRemaining();
  v3 = sub_100032AC8((a1 + 8));
  v4 = v3;
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to get battery info", buf, 2u);
    }
  }

  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 67109634;
    v7 = 0;
    v8 = 2080;
    v9 = "no";
    v10 = 2080;
    v11 = "no";
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Battery is: %d percent, charging: %s, fully charged: %s", buf, 0x1Cu);
  }

  return 0;
}

void sub_101646E5C(uint64_t a1)
{
  sub_100E41830(a1);
  v2 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(a1 + 274))
    {
      v3 = "true";
    }

    else
    {
      v3 = "false";
    }

    v23 = 136315138;
    v24 = v3;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Start acked: %s", &v23, 0xCu);
  }

  v4 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(a1 + 104);
    v23 = 134217984;
    v24 = v5;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [d] Raw ConversationID: %llu", &v23, 0xCu);
  }

  v6 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(a1 + 104);
    v23 = 67109120;
    LODWORD(v24) = v7;
    _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [d] ConversationID: %hhu", &v23, 8u);
  }

  v8 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(a1 + 272))
    {
      v9 = "true";
    }

    else
    {
      v9 = "false";
    }

    v23 = 136315138;
    v24 = v9;
    _os_log_impl(&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [d] Did resume conversation: %s", &v23, 0xCu);
  }

  v10 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    if (*(a1 + 275))
    {
      v11 = "true";
    }

    else
    {
      v11 = "false";
    }

    v23 = 136315138;
    v24 = v11;
    _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [d] Location update due: %s", &v23, 0xCu);
  }

  v12 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = sub_101646358(a1);
    if (v13 == 255)
    {
      v14 = 1;
    }

    else
    {
      v14 = v13 + 1;
    }

    if ((v13 & 0xFF00) == 0)
    {
      v14 = 0;
    }

    v23 = 67109120;
    LODWORD(v24) = v14;
    _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [d] Next loc seq num: %hhu", &v23, 8u);
  }

  v15 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    v16 = off_101F5C2A0[sub_101646CD0(a1)];
    v23 = 136315138;
    v24 = v16;
    _os_log_impl(&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [d] Battery: %s", &v23, 0xCu);
  }

  v17 = sub_100032AC8((a1 + 8));
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    v18 = *(a1 + 256);
    v19 = "false";
    if (v18 && (AutoStartTimer::isExpired(v18) & 1) == 0)
    {
      v19 = "true";
    }

    v23 = 136315138;
    v24 = v19;
    _os_log_impl(&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [d] Location update timer is running: %s", &v23, 0xCu);
  }

  v20 = sub_101646540(a1);
  v21 = v20;
  if (HIDWORD(v20))
  {
    v22 = sub_100032AC8((a1 + 8));
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      v23 = 67109120;
      LODWORD(v24) = v21;
      _os_log_impl(&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I [d] Preferred Codec ID: %u", &v23, 8u);
    }
  }
}

void *sub_101647298(void *a1)
{
  *a1 = off_101F5C0F0;
  v2 = a1[8];
  v3 = a1[9];
  while (v2 != v3)
  {
    CFRelease(*v2++);
  }

  v4 = a1[33];
  if (v4)
  {
    sub_100004A34(v4);
  }

  v5 = a1[30];
  a1[30] = 0;
  if (v5)
  {
    v6 = *(v5 + 8);
    *(v5 + 8) = 0;
    if (v6)
    {
      (*(*v6 + 32))(v6);
    }

    TMKXPCServer.shutdown()();
    operator delete();
  }

  v7 = a1[28];
  a1[28] = 0;
  if (v7)
  {
    (*(*v7 + 32))(v7);
  }

  TMKXPCServer.shutdown()();
  v8 = a1[26];
  a1[26] = 0;
  if (v8)
  {
    (*(*v8 + 32))(v8);
  }

  TMKXPCServer.shutdown()();
  v9 = a1[24];
  a1[24] = 0;
  if (v9)
  {
    (*(*v9 + 32))(v9);
  }

  TMKXPCServer.shutdown()();
  v10 = a1[22];
  if (v10)
  {
    sub_100004A34(v10);
  }

  v11 = a1[20];
  if (v11)
  {
    sub_100004A34(v11);
  }

  v12 = a1[16];
  if (v12)
  {
    a1[17] = v12;
    operator delete(v12);
  }

  v13 = a1[12];
  if (v13)
  {
    sub_100004A34(v13);
  }

  v14 = a1[8];
  if (v14)
  {
    a1[9] = v14;
    operator delete(v14);
  }

  return sub_100E418EC(a1);
}

uint64_t sub_101647468(uint64_t result)
{
  v1 = *(result + 8);
  *(result + 8) = 0;
  if (v1)
  {
    v2 = *(v1 + 8);
    *(v1 + 8) = 0;
    if (v2)
    {
      (*(*v2 + 32))(v2);
    }

    TMKXPCServer.shutdown()();
    operator delete();
  }

  return result;
}

void sub_1016474F8(uint64_t a1)
{
  v1 = *(a1 + 8);
  *(a1 + 8) = 0;
  if (v1)
  {
    v2 = *(v1 + 8);
    *(v1 + 8) = 0;
    if (v2)
    {
      (*(*v2 + 32))(v2);
    }

    TMKXPCServer.shutdown()();
    operator delete();
  }

  operator delete();
}

void PhoneNumberRegistrationManager::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_101647D68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, void);
  v9 = va_arg(va1, void);
  v10 = va_arg(va1, void);
  v11 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger(va);
  sub_1000C0544(v6);
  ctu::OsLogContext::~OsLogContext(va1);
  JUMPOUT(0x101647D50);
}

void sub_101647D98(uint64_t a1)
{
  *a1 = off_101F5C2D0;
  PersonalitiesTracker::~PersonalitiesTracker((a1 + 1912));
  sub_100009970(a1 + 1888, *(a1 + 1896));
  sub_1001A8E08(a1 + 1864, *(a1 + 1872));
  sub_10006DCAC(a1 + 1840, *(a1 + 1848));
  sub_100359978(a1 + 1816, *(a1 + 1824));
  sub_10032D3A4(a1 + 1792, *(a1 + 1800));
  sub_1002B7314(a1 + 1768, *(a1 + 1776));
  sub_10006DCAC(a1 + 1744, *(a1 + 1752));
  sub_10004543C(a1 + 936);
  sub_10004543C(a1 + 128);
  v2 = *(a1 + 120);
  if (v2)
  {
    sub_100004A34(v2);
  }

  sub_100D92208(*(a1 + 96));
  v3 = *(a1 + 80);
  if (v3)
  {
    sub_100004A34(v3);
  }

  v4 = *(a1 + 64);
  if (v4)
  {
    sub_100004A34(v4);
  }

  v5 = *(a1 + 48);
  *(a1 + 48) = 0;
  if (v5)
  {
    (*(*v5 + 8))(v5);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 40));
  sub_1000C0544((a1 + 8));

  PhoneNumberRegistrationInterface::~PhoneNumberRegistrationInterface(a1);
}

void sub_101647EC4(uint64_t a1)
{
  sub_101647D98(a1);

  operator delete();
}

void sub_101647EFC(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_101647FFC(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 1816);
  v3 = (a1 + 1824);
  if (v2 != (a1 + 1824))
  {
    v5 = (a2 + 8);
    while (1)
    {
      v6 = *v5;
      if (!*v5)
      {
        break;
      }

      v7 = *(v2 + 8);
      v8 = v5;
      do
      {
        if (*(v6 + 32) >= v7)
        {
          v8 = v6;
        }

        v6 = *(v6 + 8 * (*(v6 + 32) < v7));
      }

      while (v6);
      if (v8 == v5 || v7 < *(v8 + 8))
      {
        goto LABEL_12;
      }

      if ((BasicSimInfo::operator==() & 1) == 0)
      {
        break;
      }

LABEL_13:
      v9 = v2[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          v10 = v2[2];
          v11 = *v10 == v2;
          v2 = v10;
        }

        while (!v11);
      }

      v2 = v10;
      if (v10 == v3)
      {
        return;
      }
    }

    v7 = *(v2 + 8);
LABEL_12:
    sub_10164BD3C(a1, v7, (v2 + 5));
    goto LABEL_13;
  }
}

void sub_1016480CC(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 1792);
  v3 = (a1 + 1800);
  if (v2 != (a1 + 1800))
  {
    v5 = (a2 + 8);
    while (1)
    {
      v6 = *v5;
      if (!*v5)
      {
        break;
      }

      v7 = *(v2 + 8);
      v8 = v5;
      do
      {
        if (*(v6 + 32) >= v7)
        {
          v8 = v6;
        }

        v6 = *(v6 + 8 * (*(v6 + 32) < v7));
      }

      while (v6);
      if (v8 == v5 || v7 < *(v8 + 8))
      {
        goto LABEL_12;
      }

      if ((rest::operator==() & 1) == 0)
      {
        break;
      }

LABEL_16:
      v12 = v2[1];
      if (v12)
      {
        do
        {
          v13 = v12;
          v12 = *v12;
        }

        while (v12);
      }

      else
      {
        do
        {
          v13 = v2[2];
          v14 = *v13 == v2;
          v2 = v13;
        }

        while (!v14);
      }

      v2 = v13;
      if (v13 == v3)
      {
        return;
      }
    }

    v7 = *(v2 + 8);
LABEL_12:
    v9 = (*(**(a1 + 48) + 16))(*(a1 + 48), v7);
    sub_1016496A4(a1, v7);
    if ((*(v2 + 40) - 1) <= 3u)
    {
      v10 = *v9;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v11 = asString();
        *buf = 136315138;
        v16 = v11;
        _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle updated :%s", buf, 0xCu);
      }

      sub_1016488F8(a1, v7);
    }

    goto LABEL_16;
  }
}

void sub_1016482A4(uint64_t a1, int a2, uint64_t a3)
{
  v5 = a2 & 0xFFFFFFFE;
  v6 = (a2 & 0xFFFFFFFE) == 4;
  v7 = (*(**(a1 + 48) + 16))(*(a1 + 48), a3);
  v8 = *(a1 + 96);
  if (!v8)
  {
    goto LABEL_8;
  }

  v9 = a1 + 96;
  do
  {
    if (*(v8 + 32) >= a3)
    {
      v9 = v8;
    }

    v8 = *(v8 + 8 * (*(v8 + 32) < a3));
  }

  while (v8);
  if (v9 != a1 + 96 && *(v9 + 32) <= a3)
  {
    v11 = *(v9 + 40);
    if (*(v11 + 2) != v6)
    {
      *(v11 + 2) = v6;
      v12 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        v13 = 136315138;
        v14 = CSIBOOLAsString(v5 == 4);
        _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Registration status update :- %s", &v13, 0xCu);
      }

      sub_1016488F8(a1, a3);
    }
  }

  else
  {
LABEL_8:
    v10 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v13) = 0;
      _os_log_error_impl(&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid Slot context while handling Registered Network Info", &v13, 2u);
    }
  }
}

void sub_10164843C(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 1768);
  v3 = (a1 + 1776);
  if (v2 != (a1 + 1776))
  {
    v6 = a2 + 8;
    v37 = (a1 + 96);
    while (v6 != sub_100007A6C(a2, v2 + 4) && (rest::operator==() & 1) != 0)
    {
LABEL_51:
      v35 = v2[1];
      if (v35)
      {
        do
        {
          v36 = v35;
          v35 = *v35;
        }

        while (v35);
      }

      else
      {
        do
        {
          v36 = v2[2];
          v33 = *v36 == v2;
          v2 = v36;
        }

        while (!v33);
      }

      v2 = v36;
      if (v36 == v3)
      {
        return;
      }
    }

    v7 = *(a1 + 2064);
    v8 = *v7;
    v9 = *(v7 + 8);
    if (*v7 != v9)
    {
      v10 = *(v2 + 55);
      if (v10 >= 0)
      {
        v11 = *(v2 + 55);
      }

      else
      {
        v11 = v2[5];
      }

      if (v10 >= 0)
      {
        v12 = v2 + 4;
      }

      else
      {
        v12 = v2[4];
      }

      while (1)
      {
        v13 = *v8;
        v14 = *(*v8 + 47);
        v15 = v14;
        if ((v14 & 0x80u) != 0)
        {
          v14 = *(*v8 + 32);
        }

        if (v14 == v11)
        {
          v18 = *(v13 + 24);
          v16 = v13 + 24;
          v17 = v18;
          v19 = (v15 >= 0 ? v16 : v17);
          if (!memcmp(v19, v12, v11))
          {
            break;
          }
        }

        v8 += 2;
        if (v8 == v9)
        {
          goto LABEL_26;
        }
      }
    }

    if (v8 == v9)
    {
LABEL_26:
      v23 = 0;
      v21 = 0;
      v20 = 0;
    }

    else
    {
      v21 = *v8;
      v20 = v8[1];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      if (v21)
      {
        v22 = *(v21 + 52);
        v23 = 1;
LABEL_28:
        v24 = (*(**(a1 + 48) + 16))(*(a1 + 48), v22);
        if (v23)
        {
          v25 = *v37;
          if (!*v37)
          {
            goto LABEL_36;
          }

          v26 = *(v21 + 52);
          v27 = v37;
          do
          {
            if (*(v25 + 32) >= v26)
            {
              v27 = v25;
            }

            v25 = *(v25 + 8 * (*(v25 + 32) < v26));
          }

          while (v25);
          if (v27 != v37 && v26 >= *(v27 + 8))
          {
            sub_1016488F8(a1, v26);
          }

          else
          {
LABEL_36:
            v28 = *v24;
            if (os_log_type_enabled(*v24, OS_LOG_TYPE_ERROR))
            {
              *buf = 0;
              _os_log_error_impl(&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Invalid slot while handling phone number update", buf, 2u);
            }
          }
        }

        else
        {
          v29 = *v24;
          if (os_log_type_enabled(*v24, OS_LOG_TYPE_DEFAULT))
          {
            v30 = *(v2 + 55);
            v31 = v30 < 0;
            if (v30 < 0)
            {
              v30 = v2[5];
            }

            if (v31)
            {
              v32 = v2[4];
            }

            else
            {
              v32 = (v2 + 4);
            }

            v33 = v30 == 0;
            v34 = "<invalid>";
            if (!v33)
            {
              v34 = v32;
            }

            *buf = 136315138;
            v39 = v34;
            _os_log_impl(&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I handlePhoneNumberAvailable_sync, unknown persona '%s'", buf, 0xCu);
          }
        }

        if (v20)
        {
          sub_100004A34(v20);
        }

        goto LABEL_51;
      }

      v23 = 0;
    }

    v22 = 0;
    goto LABEL_28;
  }
}

void sub_101648728(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_101648748(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 1888);
  v3 = (a1 + 1896);
  if (v2 != (a1 + 1896))
  {
    v26 = a2 + 8;
    do
    {
      v6 = *(a1 + 2064);
      v8 = *v6;
      v7 = *(v6 + 8);
      if (*v6 != v7)
      {
        v9 = *(v2 + 55);
        if (v9 >= 0)
        {
          v10 = *(v2 + 55);
        }

        else
        {
          v10 = v2[5];
        }

        if (v9 >= 0)
        {
          v11 = v2 + 4;
        }

        else
        {
          v11 = v2[4];
        }

        while (1)
        {
          v12 = *v8;
          v13 = *(*v8 + 47);
          v14 = v13;
          if ((v13 & 0x80u) != 0)
          {
            v13 = *(*v8 + 32);
          }

          if (v13 == v10)
          {
            v17 = *(v12 + 24);
            v15 = v12 + 24;
            v16 = v17;
            v18 = (v14 >= 0 ? v15 : v16);
            if (!memcmp(v18, v11, v10))
            {
              break;
            }
          }

          v8 += 2;
          if (v8 == v7)
          {
            goto LABEL_29;
          }
        }
      }

      if (v8 != v7)
      {
        v20 = *v8;
        v19 = v8[1];
        if (v19)
        {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        if (v20)
        {
          if (!*(v20 + 49))
          {
            v21 = sub_1001E8808(v2 + 7, 1u);
            v22 = sub_100007A6C(a2, v2 + 4);
            if (v26 == v22 || v21 != sub_1001E8808((v22 + 56), 1u))
            {
              sub_1016488F8(a1, *(v20 + 52));
            }
          }
        }

        if (v19)
        {
          sub_100004A34(v19);
        }
      }

LABEL_29:
      v23 = v2[1];
      if (v23)
      {
        do
        {
          v24 = v23;
          v23 = *v23;
        }

        while (v23);
      }

      else
      {
        do
        {
          v24 = v2[2];
          v25 = *v24 == v2;
          v2 = v24;
        }

        while (!v25);
      }

      v2 = v24;
    }

    while (v24 != v3);
  }
}

void sub_1016488D8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016488F8(uint64_t a1, uint64_t a2)
{
  v4 = (*(**(a1 + 48) + 16))(*(a1 + 48));
  if (subscriber::isValidSimSlot())
  {
    v5 = (*(**(a1 + 48) + 16))(*(a1 + 48), a2);
    v6 = v5;
    v8 = (a1 + 96);
    v7 = *(a1 + 96);
    if (!v7)
    {
      goto LABEL_9;
    }

    v9 = a1 + 96;
    do
    {
      if (*(v7 + 32) >= a2)
      {
        v9 = v7;
      }

      v7 = *(v7 + 8 * (*(v7 + 32) < a2));
    }

    while (v7);
    if (v9 == v8 || *(v9 + 32) > a2)
    {
LABEL_9:
      v10 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
      {
        *__p = 0;
        _os_log_error_impl(&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid Slot while reading phone number.", __p, 2u);
      }

LABEL_11:
      v11 = 0;
      goto LABEL_12;
    }

    PersonalityIdFromSlotId();
    v16 = sub_100007A6C(a1 + 1768, __p);
    if (v38 < 0)
    {
      operator delete(*__p);
    }

    if (a1 + 1776 == v16 || (*(v16 + 136) & 1) == 0)
    {
      v22 = *v6;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *__p = 0;
        _os_log_impl(&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#N Phone number hasn't been read", __p, 2u);
      }

      goto LABEL_11;
    }

    v17 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *__p = 0;
      _os_log_impl(&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Phone number has been read", __p, 2u);
    }

    v18 = *(a1 + 2064);
    v19 = *v18;
    v20 = *(v18 + 8);
    if (v19 != v20)
    {
      while (*(*v19 + 49) || *(*v19 + 52) != a2)
      {
        v19 += 2;
        if (v19 == v20)
        {
          goto LABEL_49;
        }
      }
    }

    if (v19 == v20)
    {
LABEL_49:
      v24 = 0;
      goto LABEL_50;
    }

    v23 = *v19;
    v24 = v19[1];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    if (v23)
    {
      v25 = sub_100007A6C(a1 + 1888, (v23 + 24));
      if (a1 + 1896 == v25)
      {
        v27 = *v6;
        if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          goto LABEL_50;
        }

        *__p = 0;
        v34 = "#I PNR cannot be performed over Entitlements (not supported)";
        goto LABEL_68;
      }

      v26 = sub_1001E8808((v25 + 56), 1u);
      v27 = *v6;
      v28 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
      if (v26)
      {
        if (v28)
        {
          *__p = 0;
          v29 = "#I PNR can be performed over Entitlements";
LABEL_54:
          _os_log_impl(&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v29, __p, 2u);
          goto LABEL_55;
        }

        goto LABEL_55;
      }

      if (v28)
      {
        *__p = 0;
        v34 = "#I PNR cannot be performed over Entitlements (not reachable)";
LABEL_68:
        _os_log_impl(&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v34, __p, 2u);
      }
    }

LABEL_50:
    v30 = *(v9 + 40);
    v31 = *(v30 + 1);
    if (v31)
    {
      v27 = *v6;
      if (*(v30 + 2) == 1)
      {
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          *__p = 0;
          v29 = "#I PNR is allowed via SMS";
          goto LABEL_54;
        }

LABEL_55:
        v11 = 1;
LABEL_62:
        if (v24)
        {
          sub_100004A34(v24);
        }

LABEL_12:
        v12 = *v8;
        if (!*v8)
        {
          goto LABEL_19;
        }

        v13 = a1 + 96;
        do
        {
          if (*(v12 + 32) >= a2)
          {
            v13 = v12;
          }

          v12 = *(v12 + 8 * (*(v12 + 32) < a2));
        }

        while (v12);
        if (v13 != v8 && *(v13 + 32) <= a2)
        {
          v21 = *(*a1 + 32);

          v21(a1, a2, v11);
        }

        else
        {
LABEL_19:
          v14 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
          {
            *__p = 0;
            v15 = "Invalid Slot while accessing fReadyState..";
LABEL_40:
            _os_log_error_impl(&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v15, __p, 2u);
            return;
          }
        }

        return;
      }
    }

    else
    {
      v27 = *v6;
    }

    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      v32 = CSIBOOLAsString(v31);
      v33 = CSIBOOLAsString(*(*(v9 + 40) + 2));
      *__p = 136315394;
      *&__p[4] = v32;
      v36 = 2080;
      v37 = v33;
      _os_log_impl(&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I PNR is not allowed via SMS. SMS online: %s Registration status:%s", __p, 0x16u);
      v27 = *v6;
    }

    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *__p = 0;
      _os_log_impl(&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#N PNR is not allowed over Entitlements or SMS", __p, 2u);
    }

    v11 = 0;
    goto LABEL_62;
  }

  v14 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
  {
    *__p = 0;
    v15 = "Invalid Slot while evaluating Registration state..";
    goto LABEL_40;
  }
}

void sub_101648E5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (v14)
  {
    sub_100004A34(v14);
  }

  _Unwind_Resume(exception_object);
}

void sub_101648E98(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 1744);
  v3 = (a1 + 1752);
  if (v2 != (a1 + 1752))
  {
    v5 = (a2 + 8);
    while (1)
    {
      v6 = *v5;
      v7 = *(v2 + 7);
      if (!*v5)
      {
        break;
      }

      v8 = v5;
      do
      {
        if (*(v6 + 28) >= v7)
        {
          v8 = v6;
        }

        v6 = *(v6 + 8 * (*(v6 + 28) < v7));
      }

      while (v6);
      if (v8 == v5 || v7 < *(v8 + 7))
      {
        break;
      }

      v17 = *(v8 + 32);
      v9 = *(v2 + 32);
      if (v17 != v9)
      {
        goto LABEL_11;
      }

LABEL_14:
      v14 = v2[1];
      if (v14)
      {
        do
        {
          v15 = v14;
          v14 = *v14;
        }

        while (v14);
      }

      else
      {
        do
        {
          v15 = v2[2];
          v16 = *v15 == v2;
          v2 = v15;
        }

        while (!v16);
      }

      v2 = v15;
      if (v15 == v3)
      {
        return;
      }
    }

    LOBYTE(v9) = *(v2 + 32);
LABEL_11:
    v18 = *(v2 + 7);
    v10 = v9 & 1;
    *buf = &v18;
    v11 = sub_10124D180(a1 + 88, v7);
    *(v11[5] + 1) = v10;
    v12 = *(*(**(a1 + 48) + 16))(*(a1 + 48), v18);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = CSIBOOLAsString(*(v11[5] + 1));
      *buf = 136315138;
      *&buf[4] = v13;
      _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I SMS Online changed :- %s", buf, 0xCu);
    }

    sub_1016488F8(a1, v18);
    goto LABEL_14;
  }
}

void sub_101649074(Registry **a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a2 + 24);
  if (v6 > 3)
  {
    if (v6 == 7)
    {
      goto LABEL_21;
    }

    if (v6 != 4)
    {
      return;
    }
  }

  else if (v6 != 1)
  {
    if (v6 != 2 || (capabilities::ct::supportsGemini(a1) & 1) != 0)
    {
      return;
    }

LABEL_21:
    if (*(*a3 + 49))
    {
      return;
    }

    ServiceMap = Registry::getServiceMap(a1[7]);
    v20 = ServiceMap;
    if ((v21 & 0x8000000000000000) != 0)
    {
      v22 = (v21 & 0x7FFFFFFFFFFFFFFFLL);
      v23 = 5381;
      do
      {
        v21 = v23;
        v24 = *v22++;
        v23 = (33 * v23) ^ v24;
      }

      while (v24);
    }

    std::mutex::lock(ServiceMap);
    v28 = v21;
    v25 = sub_100009510(&v20[1].__m_.__sig, &v28);
    if (v25)
    {
      v26 = v25[3];
      v16 = v25[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v20);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v16);
        v27 = 0;
        if (!v26)
        {
LABEL_38:
          if (v27)
          {
            return;
          }

LABEL_33:
          sub_100004A34(v16);
          return;
        }

LABEL_37:
        (*(*v26 + 56))(v26, a2, 1);
        goto LABEL_38;
      }
    }

    else
    {
      v26 = 0;
    }

    std::mutex::unlock(v20);
    v16 = 0;
    v27 = 1;
    if (!v26)
    {
      goto LABEL_38;
    }

    goto LABEL_37;
  }

  v7 = *(*a3 + 49);
  v8 = v7 == 3 || v7 == 0;
  if (v8 && *(*a3 + 48) == 1)
  {
    v9 = Registry::getServiceMap(a1[7]);
    v10 = v9;
    if ((v11 & 0x8000000000000000) != 0)
    {
      v12 = (v11 & 0x7FFFFFFFFFFFFFFFLL);
      v13 = 5381;
      do
      {
        v11 = v13;
        v14 = *v12++;
        v13 = (33 * v13) ^ v14;
      }

      while (v14);
    }

    std::mutex::lock(v9);
    v28 = v11;
    v15 = sub_100009510(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      v17 = v15[3];
      v16 = v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v16);
        v18 = 0;
        if (!v17)
        {
LABEL_32:
          if (v18)
          {
            return;
          }

          goto LABEL_33;
        }

LABEL_31:
        (*(*v17 + 48))(v17, a3);
        goto LABEL_32;
      }
    }

    else
    {
      v17 = 0;
    }

    std::mutex::unlock(v10);
    v16 = 0;
    v18 = 1;
    if (!v17)
    {
      goto LABEL_32;
    }

    goto LABEL_31;
  }
}

void sub_1016492C8(_Unwind_Exception *exception_object)
{
  v3 = v1;
  if ((v3 & 1) == 0)
  {
    sub_100004A34(v2);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016492F8(uint64_t a1)
{
  ServiceMap = Registry::getServiceMap(*(a1 + 56));
  v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    v5 = (v4 & 0x7FFFFFFFFFFFFFFFLL);
    v6 = 5381;
    do
    {
      v4 = v6;
      v7 = *v5++;
      v6 = (33 * v6) ^ v7;
    }

    while (v7);
  }

  std::mutex::lock(ServiceMap);
  v16 = v4;
  v8 = sub_100009510(&v3[1].__m_.__sig, &v16);
  if (v8)
  {
    v10 = v8[3];
    v9 = v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v9);
      v11 = 0;
      if (!v10)
      {
        goto LABEL_17;
      }

      goto LABEL_10;
    }
  }

  else
  {
    v10 = 0;
  }

  std::mutex::unlock(v3);
  v9 = 0;
  v11 = 1;
  if (!v10)
  {
    goto LABEL_17;
  }

LABEL_10:
  v12 = *(a1 + 2064);
  v13 = *v12;
  v14 = v12[1];
  while (v13 != v14)
  {
    v15 = *v13;
    if (*v13 && !*(v15 + 49) && *(v15 + 48) == 1)
    {
      (*(*v10 + 48))(v10, v13);
    }

    v13 += 2;
  }

LABEL_17:
  if ((v11 & 1) == 0)
  {
    sub_100004A34(v9);
  }
}

void sub_101649440(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_101649458(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_101649550(uint64_t a1, uint64_t *a2)
{
  v4 = *a2;
  if (*(*a2 + 49) == 3)
  {
    v5 = 1;
  }

  else
  {
    v20 = v2;
    v21 = v3;
    v9 = a1;
    v10 = *(v4 + 52);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = sub_10164C560;
    v11[3] = &unk_101F5CA88;
    v11[4] = a1 + 8;
    v11[5] = &v9;
    v12 = v11;
    v7 = a1 + 24;
    v6 = *(a1 + 24);
    if (*(v7 + 8))
    {
      v19 = 0;
      v13 = _NSConcreteStackBlock;
      v14 = 0x40000000;
      v15 = sub_10006A800;
      v16 = &unk_101F5CAC8;
      v17 = &v19;
      v18 = &v12;
      dispatch_async_and_wait(v6, &v13);
    }

    else
    {
      v19 = 0;
      v13 = _NSConcreteStackBlock;
      v14 = 0x40000000;
      v15 = sub_1000598A4;
      v16 = &unk_101F5CAA8;
      v17 = &v19;
      v18 = &v12;
      dispatch_sync(v6, &v13);
    }

    v5 = v19;
  }

  return v5 & 1;
}

void sub_1016496A4(uint64_t a1, uint64_t a2)
{
  ServiceMap = Registry::getServiceMap(*(a1 + 56));
  v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    v7 = (v6 & 0x7FFFFFFFFFFFFFFFLL);
    v8 = 5381;
    do
    {
      v6 = v8;
      v9 = *v7++;
      v8 = (33 * v8) ^ v9;
    }

    while (v9);
  }

  std::mutex::lock(ServiceMap);
  v15 = v6;
  v10 = sub_100009510(&v5[1].__m_.__sig, &v15);
  if (v10)
  {
    v12 = v10[3];
    v11 = v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v11);
      v13 = 0;
      if (!v12)
      {
        goto LABEL_7;
      }

LABEL_11:
      v16[0] = off_101F5CAF8;
      v16[1] = a2;
      v16[2] = a1;
      v16[3] = v16;
      (*(*v12 + 184))(v12, a2, v16);
      sub_100D9F910(v16);
      goto LABEL_12;
    }
  }

  else
  {
    v12 = 0;
  }

  std::mutex::unlock(v5);
  v11 = 0;
  v13 = 1;
  if (v12)
  {
    goto LABEL_11;
  }

LABEL_7:
  v14 = *(*(**(a1 + 48) + 16))(*(a1 + 48), a2);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v15) = 0;
    _os_log_error_impl(&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid Carrier bundle interface", &v15, 2u);
  }

LABEL_12:
  if ((v13 & 1) == 0)
  {
    sub_100004A34(v11);
  }
}

void sub_101649888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if ((v11 & 1) == 0)
  {
    sub_100004A34(v10);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016498C8(uint64_t a1, int a2)
{
  v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10164CDA0;
  v7[3] = &unk_101F5CB68;
  v7[4] = a1 + 8;
  v7[5] = v5;
  v8 = v7;
  v3 = a1 + 24;
  v2 = *(a1 + 24);
  if (*(v3 + 8))
  {
    v15 = 0;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_10006A800;
    v12 = &unk_101F5CAC8;
    v13 = &v15;
    v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    v15 = 0;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_1000598A4;
    v12 = &unk_101F5CAA8;
    v13 = &v15;
    v14 = &v8;
    dispatch_sync(v2, &block);
  }

  return v15 & 1;
}

void sub_101649A00(uint64_t a1)
{
  v2 = *(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Dumping PNR Param :", buf, 2u);
  }

  subscriber::makeSimSlotRange();
  v3 = *buf;
  v4 = v34;
  if (*buf != v34)
  {
    v5 = v35;
    do
    {
      if (v5(*v3))
      {
        break;
      }

      ++v3;
    }

    while (v3 != v4);
    v31 = v34;
    while (v3 != v31)
    {
      v32 = *v3;
      v6 = (*(**(a1 + 48) + 16))(*(a1 + 48));
      *v36 = &v32;
      v7 = sub_10124D180(a1 + 88, v32);
      v8 = v7[5];
      v9 = v7[6];
      if (v9)
      {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      v10 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        v11 = CSIBOOLAsString(*v8);
        *v36 = 136315138;
        *&v36[4] = v11;
        _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Ready state :- %s", v36, 0xCu);
        v10 = *v6;
      }

      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v12 = CSIBOOLAsString(v8[1]);
        *v36 = 136315138;
        *&v36[4] = v12;
        _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I SMS online state :- %s", v36, 0xCu);
        v10 = *v6;
      }

      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v13 = CSIBOOLAsString(v8[2]);
        *v36 = 136315138;
        *&v36[4] = v13;
        _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Registered state :- %s", v36, 0xCu);
      }

      PersonalityIdFromSlotId();
      v14 = sub_100007A6C(a1 + 1768, v36);
      if (v39 < 0)
      {
        operator delete(*v36);
      }

      v15 = *v6;
      v16 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
      if (a1 + 1776 == v14)
      {
        if (!v16)
        {
          goto LABEL_28;
        }

        *v36 = 0;
        v19 = v15;
        v20 = "#I Phone number :- none, sim :- none";
        v21 = 2;
      }

      else
      {
        if (!v16)
        {
          goto LABEL_28;
        }

        v17 = (v14 + 80);
        if (*(v14 + 103) < 0)
        {
          v17 = *v17;
        }

        v18 = (v14 + 56);
        if (*(v14 + 79) < 0)
        {
          v18 = *v18;
        }

        *v36 = 136315394;
        *&v36[4] = v17;
        v37 = 2080;
        v38 = v18;
        v19 = v15;
        v20 = "#I Phone number :- %s, sim :- %s";
        v21 = 22;
      }

      _os_log_impl(&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v20, v36, v21);
LABEL_28:
      v22 = *(a1 + 2064);
      v23 = *v22;
      v24 = *(v22 + 8);
      if (v23 != v24)
      {
        while (*(*v23 + 49) || *(*v23 + 52) != v32)
        {
          v23 += 2;
          if (v23 == v24)
          {
            goto LABEL_39;
          }
        }
      }

      if (v23 == v24)
      {
LABEL_39:
        v26 = 0;
LABEL_40:
        v28 = 0;
        goto LABEL_41;
      }

      v25 = *v23;
      v26 = v23[1];
      if (v26)
      {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      if (!v25)
      {
        goto LABEL_40;
      }

      v27 = sub_100007A6C(a1 + 1888, (v25 + 24));
      if (a1 + 1896 == v27)
      {
        goto LABEL_40;
      }

      v28 = sub_1001E8808((v27 + 56), 1u);
LABEL_41:
      v29 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        v30 = CSIBOOLAsString(v28);
        *v36 = 136315138;
        *&v36[4] = v30;
        _os_log_impl(&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Entitlement reachability :- %s", v36, 0xCu);
      }

      if (v26)
      {
        sub_100004A34(v26);
      }

      if (v9)
      {
        sub_100004A34(v9);
      }

      do
      {
        ++v3;
      }

      while (v3 != v4 && (v5(*v3) & 1) == 0);
    }
  }
}

void sub_101649E44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  if (v28)
  {
    sub_100004A34(v28);
  }

  if (v29)
  {
    sub_100004A34(v29);
  }

  _Unwind_Resume(exception_object);
}

void sub_101649EA4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101649EF8(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101649F38(uint64_t result)
{
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void sub_101649F64(ServiceManager::Service *this)
{
  *this = off_101F5C438;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_101649FC0(ServiceManager::Service *this)
{
  *this = off_101F5C438;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_10164A040@<X0>(void *a1@<X8>)
{
  v2 = 2;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  return sub_1000FF040(a1, &v2, &vars0, 1);
}

void sub_10164A084(uint64_t a1, dispatch_object_t *a2)
{
  v2 = *(a1 + 8);
  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_101647EFC(v2, v3);
  }

  v4 = *(a1 + 8);

  sub_101647EFC(v4, 0);
}

void sub_10164A128(uint64_t a1, int a2, ServiceStage *this)
{
  v3 = *(a1 + 8);
  ServiceStage::holdOffStage(&group[1], this);
  v4 = *(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t *sub_10164A260(uint64_t *a1)
{
  v1 = *a1;
  v5 = a1;
  v6 = v1;
  v2 = *v1;
  v3 = *(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }

  ctu::RestModule::disconnect((v2 + 112));
  sub_1000FF844(&v6);
  return sub_1000049E0(&v5);
}

void sub_10164A2E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_10164A300(uint64_t **a1)
{
  v1 = **a1;
  v2 = *(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }

  subscriber::makeSimSlotRange();
  v3 = *buf;
  v4 = v11;
  if (*buf != v11)
  {
    v5 = v12;
    do
    {
      if (v5(*v3))
      {
        break;
      }

      ++v3;
    }

    while (v3 != v4);
    if (v3 != v11)
    {
      v8 = *v3;
      operator new();
    }
  }

  Registry::createRestModuleOneTimeUseConnection(&v6, *(v1 + 56));
  ctu::RestModule::connect();
  if (v7)
  {
    sub_100004A34(v7);
  }

  sub_10000501C(&__p, "/cc/props/reg_net_info1");
  operator new();
}

void sub_10164AA58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, char a24)
{
  sub_100249B60(&a13);
  sub_100249BE0(&__p);
  sub_100249C60(&a24);
  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_10164AB48(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F5C4F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10164AB9C(uint64_t a1)
{
  if (*(a1 + 79) < 0)
  {
    operator delete(*(a1 + 56));
  }

  if (*(a1 + 55) < 0)
  {
    v2 = *(a1 + 32);

    operator delete(v2);
  }
}

__n128 sub_10164AC74(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5C548;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10164ACAC(uint64_t a1, const xpc::object *a2)
{
  read_rest_value(*(a1 + 8), a2);
  v3 = *(a1 + 24);
  v4 = *(a1 + 32);
  v5 = (*(a1 + 16) + (v4 >> 1));
  if (v4)
  {
    v3 = *(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10164AD28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10164ADF0(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5C5C8;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10164AE28(uint64_t a1, const xpc::object *a2)
{
  read_rest_value(*(a1 + 8), a2);
  v3 = *(a1 + 24);
  v4 = *(a1 + 32);
  v5 = (*(a1 + 16) + (v4 >> 1));
  if (v4)
  {
    v3 = *(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10164AEA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10164AF6C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5C648;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_10164AFA4(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v4 = v3 + 1;
  v5 = v3[1];
  v9 = *v3;
  v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *v3 = v4;
    *v4 = 0;
    v3[2] = 0;
  }

  else
  {
    v9 = &v10;
  }

  sub_10011E228(v3, a2);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  v6(v8, &v9);
  sub_10006DCAC(&v9, v10);
}

uint64_t sub_10164B07C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10164B144(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5C6C8;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_10164B17C(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v4 = v3 + 1;
  v5 = v3[1];
  v9 = *v3;
  v10 = v5;
  if (v3[2])
  {
    *(v5 + 16) = &v10;
    *v3 = v4;
    *v4 = 0;
    v3[2] = 0;
  }

  else
  {
    v9 = &v10;
  }

  sub_1002BB888(v3, a2);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  v6(v8, &v9);
  sub_1002B7314(&v9, v10);
}

uint64_t sub_10164B254(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10164B31C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5C748;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_10164B354(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v4 = v3 + 1;
  v5 = v3[1];
  v9 = *v3;
  v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *v3 = v4;
    *v4 = 0;
    v3[2] = 0;
  }

  else
  {
    v9 = &v10;
  }

  sub_10032CF1C(v3, a2);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  v6(v8, &v9);
  sub_10032D3A4(&v9, v10);
}

uint64_t sub_10164B42C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10164B4F4(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5C7C8;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_10164B52C(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v21 = 0uLL;
  v22 = 0;
  sub_10010A62C(&v21, a2);
  p_size = &v3->__r_.__value_.__l.__size_;
  size = v3->__r_.__value_.__l.__size_;
  v18 = v3->__r_.__value_.__r.__words[0];
  v19 = size;
  v20 = v3->__r_.__value_.__r.__words[2];
  if (v20)
  {
    *(size + 16) = &v19;
    v3->__r_.__value_.__r.__words[0] = p_size;
    *p_size = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
  }

  else
  {
    v18 = &v19;
  }

  v16 = v21;
  v17 = v22;
  v22 = 0;
  v21 = 0uLL;
  sub_100D21B04(v3, &v16);
  v23 = &v16;
  sub_1000B2AF8(&v23);
  if (v20 == v3->__r_.__value_.__r.__words[2])
  {
    v6 = v18;
    if (v18 == &v19)
    {
      goto LABEL_24;
    }

    v7 = v3->__r_.__value_.__r.__words[0];
    while (*(v6 + 8) == *(v7 + 8) && BasicSimInfo::operator==())
    {
      v8 = v6[1];
      v9 = v6;
      if (v8)
      {
        do
        {
          v6 = v8;
          v8 = *v8;
        }

        while (v8);
      }

      else
      {
        do
        {
          v6 = v9[2];
          v10 = *v6 == v9;
          v9 = v6;
        }

        while (!v10);
      }

      v11 = v7[1];
      if (v11)
      {
        do
        {
          v12 = v11;
          v11 = *v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          v12 = v7[2];
          v10 = *v12 == v7;
          v7 = v12;
        }

        while (!v10);
      }

      v7 = v12;
      if (v6 == &v19)
      {
        goto LABEL_24;
      }
    }
  }

  v13 = a1[3];
  v14 = a1[4];
  v15 = (a1[2] + (v14 >> 1));
  if (v14)
  {
    v13 = *(*v15 + v13);
  }

  v13(v15, &v18);
LABEL_24:
  sub_100359978(&v18, v19);
  v18 = &v21;
  sub_1000B2AF8(&v18);
}

void sub_10164B6F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, char *a13, uint64_t a14, char a15)
{
  sub_100359978(&a12, a13);
  a12 = &a15;
  sub_1000B2AF8(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_10164B738(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10164B800(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5C848;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_10164B838(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v4 = v3 + 1;
  v5 = v3[1];
  v9 = *v3;
  v10 = v5;
  if (v3[2])
  {
    *(v5 + 16) = &v10;
    *v3 = v4;
    *v4 = 0;
    v3[2] = 0;
  }

  else
  {
    v9 = &v10;
  }

  sub_1005CAF40(v3, a2);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  v6(v8, &v9);
  sub_100009970(&v9, v10);
}

uint64_t sub_10164B910(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10164B9D8(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5C8C8;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10164BA10(void *a1)
{
  v1 = a1[2];
  v2 = a1[3];
  v3 = (a1[1] + (v2 >> 1));
  if (v2)
  {
    return (*(*v3 + v1))();
  }

  else
  {
    return v1(v3);
  }
}

uint64_t sub_10164BA58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10164BB20(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5C948;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10164BB58(void *a1)
{
  v1 = a1[2];
  v2 = a1[3];
  v3 = (a1[1] + (v2 >> 1));
  if (v2)
  {
    return (*(*v3 + v1))();
  }

  else
  {
    return v1(v3);
  }
}

uint64_t sub_10164BBA0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10164BC68(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5C9C8;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10164BCA0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = a1[2];
  v5 = a1[3];
  v6 = (a1[1] + (v5 >> 1));
  if (v5)
  {
    v4 = *(*v6 + v4);
  }

  return v4(v6, a3, a4);
}

uint64_t sub_10164BCF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10164BD3C(uint64_t a1, int a2, uint64_t a3)
{
  v22 = a2;
  v6 = (*(**(a1 + 48) + 16))(*(a1 + 48));
  if (subscriber::isValidSimSlot())
  {
    *buf = &v22;
    v7 = sub_10124D180(a1 + 88, a2);
    v8 = v7[5];
    v9 = (v8 + 8);
    v10 = *(v8 + 31);
    v11 = v10;
    v12 = *(v8 + 16);
    if ((v10 & 0x80u) == 0)
    {
      v13 = v10;
    }

    else
    {
      v13 = v12;
    }

    v14 = *(a3 + 119);
    v15 = v14;
    if ((v14 & 0x80u) != 0)
    {
      v14 = *(a3 + 104);
    }

    if (v13 != v14 || (v11 >= 0 ? (v16 = v9) : (v16 = v9->__r_.__value_.__r.__words[0]), v15 >= 0 ? (v17 = (a3 + 96)) : (v17 = *(a3 + 96)), memcmp(v16, v17, v13)))
    {
      std::string::operator=(v9, (a3 + 96));
      v18 = *v6;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = v7[5];
        v20 = (v19 + 8);
        if (*(v19 + 31) < 0)
        {
          v20 = *v20;
        }

        *buf = 136315138;
        *&buf[4] = v20;
        _os_log_impl(&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Updating IMSI :- %s", buf, 0xCu);
      }
    }
  }

  else
  {
    v21 = *v6;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid slot while handling sim update", buf, 2u);
    }
  }
}

void sub_10164BF0C(uint64_t **a1)
{
  v1 = **a1;
  v2 = *(*a1 + 12);
  v11 = *(*a1 + 2);
  v3 = (*(**(v1 + 48) + 16))(*(v1 + 48), v11);
  if (subscriber::isValidSimSlot())
  {
    *buf = &v11;
    v4 = sub_10124D180(v1 + 88, v11);
    v5 = v4[5];
    v6 = *v5;
    if (v6 != v2)
    {
      v7 = *v3;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = CSIBOOLAsString(v6);
        v9 = CSIBOOLAsString(v2);
        *buf = 136315394;
        *&buf[4] = v8;
        v13 = 2080;
        v14 = v9;
        _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N PNR state is changing from %s to %s", buf, 0x16u);
        v5 = v4[5];
      }

      *v5 = v2;
      (*(**(v1 + 72) + 320))(*(v1 + 72), v11, v2);
    }
  }

  else
  {
    v10 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid slot context while sending Ready Notification", buf, 2u);
    }
  }

  operator delete();
}

uint64_t *sub_10164C130(uint64_t *a1)
{
  v1 = *a1;
  v22 = a1;
  v23 = v1;
  v2 = *v1;
  v3 = *(v1 + 8);
  sub_10005C7A4(&v24, (v1 + 16));
  v28 = v3;
  v4 = (*(**(v2 + 48) + 16))(*(v2 + 48), v3);
  if ((subscriber::isValidSimSlot() & 1) == 0)
  {
    v19 = *v4;
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_30;
    }

    *buf = 0;
    v20 = "Invalid slot context while reading Carrier Name";
LABEL_32:
    _os_log_error_impl(&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v20, buf, 2u);
    goto LABEL_30;
  }

  if (!v24)
  {
    v19 = *v4;
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_30;
    }

    *buf = 0;
    v20 = "Invalid Carrier bundle name";
    goto LABEL_32;
  }

  memset(&__str, 0, sizeof(__str));
  memset(buf, 0, sizeof(buf));
  v30 = 0;
  ctu::cf::assign();
  *__p = *buf;
  v26 = v30;
  if (v30 >= 0)
  {
    v5 = __p;
  }

  else
  {
    v5 = __p[0];
  }

  sub_10000501C(&__str, v5);
  if (SHIBYTE(v26) < 0)
  {
    operator delete(__p[0]);
  }

  *buf = &v28;
  v6 = sub_10124D180(v2 + 88, v3);
  v7 = v6[5];
  v8 = (v7 + 32);
  v9 = *(v7 + 55);
  v10 = v9;
  v11 = *(v7 + 40);
  if ((v9 & 0x80u) == 0)
  {
    v12 = v9;
  }

  else
  {
    v12 = v11;
  }

  size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    size = __str.__r_.__value_.__l.__size_;
  }

  if (v12 != size || (v10 >= 0 ? (v14 = v8) : (v14 = v8->__r_.__value_.__r.__words[0]), (__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? (p_str = &__str) : (p_str = __str.__r_.__value_.__r.__words[0]), memcmp(v14, p_str, v12)))
  {
    std::string::operator=(v8, &__str);
    v16 = *v4;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = v6[5];
      v18 = (v17 + 32);
      if (*(v17 + 55) < 0)
      {
        v18 = *v18;
      }

      *buf = 136315138;
      *&buf[4] = v18;
      _os_log_impl(&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Carrier Name updated :- %s", buf, 0xCu);
    }
  }

  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
  }

LABEL_30:
  sub_100005978(&v24);
  sub_10164C420(&v23);
  return sub_1000049E0(&v22);
}

void sub_10164C3BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  sub_100005978(&a12);
  sub_10164C420(&a11);
  sub_1000049E0(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_10164C420(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100005978((v1 + 16));
    operator delete();
  }

  return result;
}

void sub_10164C490(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F5CA48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10164C4E4(uint64_t a1)
{
  if (*(a1 + 127) < 0)
  {
    operator delete(*(a1 + 104));
  }

  if (*(a1 + 103) < 0)
  {
    operator delete(*(a1 + 80));
  }

  if (*(a1 + 79) < 0)
  {
    operator delete(*(a1 + 56));
  }

  if (*(a1 + 55) < 0)
  {
    v2 = *(a1 + 32);

    operator delete(v2);
  }
}

uint64_t sub_10164C560(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v3 = v1[2];
  v4 = (*(**(*v1 + 48) + 16))(*(*v1 + 48), v3);
  if (!subscriber::isValidSimSlot())
  {
    goto LABEL_9;
  }

  v5 = *(v2 + 96);
  if (!v5)
  {
    goto LABEL_9;
  }

  v6 = v2 + 96;
  do
  {
    if (*(v5 + 32) >= v3)
    {
      v6 = v5;
    }

    v5 = *(v5 + 8 * (*(v5 + 32) < v3));
  }

  while (v5);
  if (v6 == v2 + 96 || *(v6 + 32) > v3)
  {
LABEL_9:
    v7 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *v45 = 0;
      _os_log_error_impl(&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid Slot while checking phone number credential validity.", v45, 2u);
    }

    return 0;
  }

  v10 = *(v2 + 1824);
  if (!v10)
  {
    goto LABEL_20;
  }

  v11 = v2 + 1824;
  do
  {
    if (*(v10 + 32) >= v3)
    {
      v11 = v10;
    }

    v10 = *(v10 + 8 * (*(v10 + 32) < v3));
  }

  while (v10);
  if (v11 == v2 + 1824 || *(v11 + 32) > v3)
  {
LABEL_20:
    v12 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_21;
    }

    *v45 = 0;
    v39 = "Invalid Slot for sims property";
    v40 = v12;
    v41 = 2;
LABEL_61:
    _os_log_error_impl(&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, v39, v45, v41);
    goto LABEL_21;
  }

  if (*(v11 + 48) != 5)
  {
    v38 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_21;
    }

    *v45 = 136315138;
    *&v45[4] = subscriber::asString();
    v39 = "Invalid Sim state :%s";
    v40 = v38;
    v41 = 12;
    goto LABEL_61;
  }

  for (i = *(v11 + 56); i != *(v11 + 64); ++i)
  {
    if ((*i - 4) >= 0xFFFFFFFD)
    {
      v44 = *v4;
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        *v45 = 136315138;
        *&v45[4] = subscriber::asString();
        _os_log_impl(&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Valid Sim App present :%s", v45, 0xCu);
      }

      v8 = subscriber::isSimUnreadable() ^ 1;
      v14 = 1;
      goto LABEL_24;
    }
  }

LABEL_21:
  v13 = *v4;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *v45 = 0;
    _os_log_error_impl(&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "No valid sim card is present", v45, 2u);
  }

  v14 = 0;
  v8 = 0;
LABEL_24:
  v15 = (*(**(v2 + 48) + 16))(*(v2 + 48), v3);
  ServiceMap = Registry::getServiceMap(*(v2 + 56));
  v17 = ServiceMap;
  if (v18 < 0)
  {
    v19 = (v18 & 0x7FFFFFFFFFFFFFFFLL);
    v20 = 5381;
    do
    {
      v18 = v20;
      v21 = *v19++;
      v20 = (33 * v20) ^ v21;
    }

    while (v21);
  }

  std::mutex::lock(ServiceMap);
  *v45 = v18;
  v22 = sub_100009510(&v17[1].__m_.__sig, v45);
  if (v22)
  {
    v24 = v22[3];
    v23 = v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v23);
      v25 = 0;
      if (!v24)
      {
        goto LABEL_30;
      }

      goto LABEL_34;
    }
  }

  else
  {
    v24 = 0;
  }

  std::mutex::unlock(v17);
  v23 = 0;
  v25 = 1;
  if (!v24)
  {
LABEL_30:
    v26 = *v15;
    v8 = 0;
    if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
    {
      *v45 = 0;
      _os_log_impl(&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Missing ActivationInterface", v45, 2u);
      v8 = 0;
    }

    goto LABEL_48;
  }

LABEL_34:
  if ((*(*v24 + 64))(v24))
  {
    v8 = v14 & v8;
    v27 = *v15;
    if (!os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_48;
    }

    v28 = CSIBOOLAsString(v8);
    *v45 = 136315138;
    *&v45[4] = v28;
    v29 = "#I UIM is required, phone calls allowed = %s";
    v30 = v27;
    v31 = 12;
    goto LABEL_47;
  }

  v32 = *(v2 + 1848);
  if (!v32)
  {
    goto LABEL_44;
  }

  v33 = v2 + 1848;
  do
  {
    if (*(v32 + 28) >= v3)
    {
      v33 = v32;
    }

    v32 = *(v32 + 8 * (*(v32 + 28) < v3));
  }

  while (v32);
  if (v33 == v2 + 1848 || *(v33 + 28) > v3 || *(v33 + 32) != 2)
  {
LABEL_44:
    v8 = v14 & v8;
    v34 = *v15;
    if (!os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_48;
    }

    v35 = CSIBOOLAsString(v8);
    v36 = asString();
    *v45 = 136315394;
    *&v45[4] = v35;
    v46 = 2080;
    v47 = v36;
    v29 = "#I UIM is not required, not service provisioned, phone calls allowed = %s Baseband provisioned state = %s";
    goto LABEL_46;
  }

  v34 = *v15;
  if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
  {
    v42 = CSIBOOLAsString(v8);
    v43 = asString();
    *v45 = 136315394;
    *&v45[4] = v42;
    v46 = 2080;
    v47 = v43;
    v29 = "#I UIM is not required, phone calls allowed = %s Baseband provisioned state = %s";
LABEL_46:
    v30 = v34;
    v31 = 22;
LABEL_47:
    _os_log_impl(&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v29, v45, v31);
  }

LABEL_48:
  if ((v25 & 1) == 0)
  {
    sub_100004A34(v23);
  }

  return v8;
}

void sub_10164CB04(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

__n128 sub_10164CBB4(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5CAF8;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

void sub_10164CBE4(uint64_t a1, const void **a2)
{
  v2 = *a2;
  v6 = v2;
  v7 = v2;
  *a2 = 0;
  v3 = *(a1 + 16);
  v4 = *(a1 + 8);
  if (v2)
  {
    CFRetain(v2);
    v8 = v3;
    v9 = v4;
    v10 = v2;
    CFRetain(v2);
  }

  else
  {
    v8 = *(a1 + 16);
    v9 = v4;
    v10 = 0;
  }

  v5 = *(v3 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_10164CD54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10164CDA0(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v3 = *v1[1];
  v4 = (*(**(*v1 + 6) + 16))(*(*v1 + 6), v3);
  if ((subscriber::isValidSimSlot() & 1) == 0)
  {
    v10 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      v11 = buf;
      goto LABEL_22;
    }

LABEL_19:
    v14 = 0;
    return v14 & 1;
  }

  v7 = *(v2 + 12);
  v6 = v2 + 24;
  v5 = v7;
  if (!v7)
  {
    goto LABEL_9;
  }

  v8 = v6;
  v9 = v5;
  do
  {
    if (v9[8] >= v3)
    {
      v8 = v9;
    }

    v9 = *&v9[2 * (v9[8] < v3)];
  }

  while (v9);
  if (v8 == v6 || v8[8] > v3)
  {
LABEL_9:
    v10 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      v15 = 0;
      v11 = &v15;
LABEL_22:
      _os_log_error_impl(&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid Slot. Unable to get Registration state.", v11, 2u);
      goto LABEL_19;
    }

    goto LABEL_19;
  }

  while (1)
  {
    while (1)
    {
      v12 = *(v5 + 8);
      if (v12 <= v3)
      {
        break;
      }

      v5 = *v5;
      if (!v5)
      {
        goto LABEL_17;
      }
    }

    if (v12 >= v3)
    {
      break;
    }

    v5 = v5[1];
    if (!v5)
    {
LABEL_17:
      sub_1000A58E4("map::at:  key not found");
    }
  }

  v14 = *v5[5];
  return v14 & 1;
}

void stewie::StewieConnectionAssistantFactory::create(uint64_t a1@<X0>, dispatch_object_t *a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  v8 = *a1;
  v9 = *(a1 + 8);
  v30 = v8;
  v31 = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    v8 = *a1;
  }

  Registry::getTimerService(&v28, v8);
  ServiceMap = Registry::getServiceMap(*a1);
  v11 = ServiceMap;
  if (v12 < 0)
  {
    v13 = (v12 & 0x7FFFFFFFFFFFFFFFLL);
    v14 = 5381;
    do
    {
      v12 = v14;
      v15 = *v13++;
      v14 = (33 * v14) ^ v15;
    }

    while (v15);
  }

  std::mutex::lock(ServiceMap);
  v22 = v12;
  v16 = sub_100009510(&v11[1].__m_.__sig, &v22);
  if (v16)
  {
    v18 = v16[3];
    v17 = v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }

  else
  {
    v18 = 0;
    v17 = 0;
  }

  std::mutex::unlock(v11);
  v26 = v18;
  v27 = v17;
  if (v17)
  {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_100004A34(v17);
  }

  Registry::getNotificationSenderFactory(&v22, *a1);
  (*(*v22 + 40))(&v24);
  object = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
  }

  v19 = *(a3 + 8);
  v20 = v19;
  if (v19)
  {
    atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }

  stewie::StewieConnectionAssistant::create(&v28, &v26, a4);
  if (v20)
  {
    std::__shared_weak_count::__release_weak(v20);
  }

  if (object)
  {
    dispatch_release(object);
  }

  if (v25)
  {
    sub_100004A34(v25);
  }

  if (v23)
  {
    sub_100004A34(v23);
  }

  if (v27)
  {
    sub_100004A34(v27);
  }

  if (v29)
  {
    sub_100004A34(v29);
  }

  if (v31)
  {
    sub_100004A34(v31);
  }
}

void sub_10164D0F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, dispatch_object_t object, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a11)
  {
    std::__shared_weak_count::__release_weak(a11);
  }

  if (object)
  {
    dispatch_release(object);
  }

  if (a16)
  {
    sub_100004A34(a16);
  }

  if (a14)
  {
    sub_100004A34(a14);
  }

  if (a18)
  {
    sub_100004A34(a18);
  }

  if (a20)
  {
    sub_100004A34(a20);
  }

  v22 = *(v20 - 72);
  if (v22)
  {
    sub_100004A34(v22);
  }

  _Unwind_Resume(exception_object);
}

BOOL sub_10164D174(uint64_t a1, const __CFString *a2)
{
  v3 = sub_10164D1B0(a2);
  *(a1 + 32) |= v3;
  return v3 != 0;
}

uint64_t sub_10164D1B0(const __CFString *a1)
{
  if (CFStringCompare(a1, @"subscribed", 0) == kCFCompareEqualTo)
  {
    return 1;
  }

  if (CFStringCompare(a1, @"not-subscribed", 0) == kCFCompareEqualTo)
  {
    return 2;
  }

  if (CFStringCompare(a1, @"depleted", 0))
  {
    return 8 * (CFStringCompare(a1, @"throttled", 0) == kCFCompareEqualTo);
  }

  return 4;
}

BOOL sub_10164D24C(uint64_t a1, const __CFString *a2)
{
  v3 = sub_10164D1B0(a2);
  *(a1 + 32) |= v3 << 8;
  return v3 != 0;
}

BOOL sub_10164D288(uint64_t a1, const __CFString *a2)
{
  v3 = sub_10164D1B0(a2);
  *(a1 + 32) |= v3 << 16;
  return v3 != 0;
}

double sub_10164D2DC(uint64_t a1)
{
  *(a1 + 64) = 0;
  result = 0.0;
  *(a1 + 32) = 0u;
  *(a1 + 48) = 0u;
  *a1 = 0u;
  *(a1 + 16) = 0u;
  *(a1 + 80) = 0;
  *(a1 + 72) = a1 + 80;
  *(a1 + 104) = 0;
  *(a1 + 88) = 0;
  *(a1 + 96) = a1 + 104;
  *(a1 + 136) = 0;
  *(a1 + 128) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = a1 + 128;
  *(a1 + 144) = 0;
  return result;
}

uint64_t sub_10164D31C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = sub_10005C7A4(a1, a2);
  sub_10005C7A4(v6 + 1, (a2 + 8));
  sub_10005C7A4((a1 + 16), (a2 + 16));
  sub_10005C7A4((a1 + 24), (a2 + 24));
  v7 = *(a2 + 32);
  v8 = *(a2 + 48);
  *(a1 + 64) = *(a2 + 64);
  *(a1 + 32) = v7;
  *(a1 + 48) = v8;
  sub_1003ED590((a1 + 72), a3);
  sub_1003ED714((a1 + 96), a3 + 24);
  sub_1003ED898((a1 + 120), a3 + 48);
  *(a1 + 144) = *(a3 + 72);
  return a1;
}

void sub_10164D3B4(_Unwind_Exception *a1)
{
  sub_10006DCAC(v1 + 96, *(v1 + 104));
  sub_10006DCAC(v1 + 72, *(v1 + 80));
  sub_1003EDA14(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10164D3F8(uint64_t a1)
{
  if (*(a1 + 144))
  {
    v1 = 1;
  }

  else
  {
    v1 = *(a1 + 64);
  }

  return v1 & 1;
}

void sub_10164D414(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10164D6F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17)
  {
    (*(a17->isa + 1))(a17);
  }

  if (a12)
  {
    sub_100004A34(a12);
  }

  sub_100004A34(v17);
  _Unwind_Resume(a1);
}

MobileStoreDemoInterface *sub_10164D82C(MobileStoreDemoInterface *this)
{
  *this = &off_101F5CBB0;
  v2 = *(this + 10);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(this + 7);
  if (v3)
  {
    sub_100004A34(v3);
  }

  MobileStoreDemoInterface::~MobileStoreDemoInterface(this);
  ctu::OsLogLogger::~OsLogLogger((this + 40));
  sub_1000C0544(this + 1);
  return this;
}

void sub_10164D8A0(MobileStoreDemoInterface *a1)
{
  sub_10164D82C(a1);

  operator delete();
}

void sub_10164D8D8(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_10164D9D8(uint64_t a1)
{
  v2 = *(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 136315138;
    v5 = printers::asString((a1 + 64), v3);
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Demo Device: %s", &v4, 0xCu);
  }
}

void sub_10164DA80(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10164DAD4(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10164DB14(uint64_t result)
{
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void sub_10164DB40(ServiceManager::Service *this)
{
  *this = off_101F5CCE0;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10164DB9C(ServiceManager::Service *this)
{
  *this = off_101F5CCE0;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_10164DC1C@<X0>(void *a1@<X8>)
{
  v2 = 3;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  return sub_1000FF040(a1, &v2, &vars0, 1);
}

void sub_10164DC60(uint64_t a1, dispatch_object_t *a2)
{
  v2 = *(a1 + 8);
  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_10164D8D8(v2, v3);
  }

  v4 = *(a1 + 8);

  sub_10164D8D8(v4, 0);
}

void sub_10164DD04(uint64_t a1, int a2, ServiceStage *this)
{
  v3 = *(a1 + 8);
  ServiceStage::holdOffStage(&group[1], this);
  v4 = *(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t *sub_10164DE18(uint64_t *a1)
{
  v1 = *a1;
  v3 = a1;
  v4 = v1;
  ctu::RestModule::disconnect((*v1 + 72));
  sub_1000FF844(&v4);
  return sub_1000049E0(&v3);
}

void sub_10164DE60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_10164DE7C(void *a1)
{
  v1 = *a1;
  v2 = a1;
  v3 = v1;
  sub_10000501C(&__p, "/cc/events/dump_state");
  operator new();
}

void sub_10164E01C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, std::__shared_weak_count *a18)
{
  if (a18)
  {
    sub_100004A34(a18);
  }

  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

__n128 sub_10164E0F8(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5CD60;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10164E130(void *a1)
{
  v1 = a1[2];
  v2 = a1[3];
  v3 = (a1[1] + (v2 >> 1));
  if (v2)
  {
    return (*(*v3 + v1))();
  }

  else
  {
    return v1(v3);
  }
}

uint64_t sub_10164E178(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10164E240(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5CDE0;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10164E278(void *a1, xpc *this, BOOL a3)
{
  v4 = a1[1];
  v5 = *v4;
  *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  return v6(v8, v5);
}

uint64_t sub_10164E310(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_10164E35C(uint64_t *a1, uint64_t *a2)
{
  v3 = *a2;
  *a1 = *a2;
  v4 = a2[1];
  a1[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    v3 = *a1;
    v4 = a1[1];
  }

  a1[3] = 0;
  a1[2] = (a1 + 3);
  a1[6] = 0;
  a1[4] = 0;
  a1[5] = (a1 + 6);
  v27 = (a1 + 5);
  a1[7] = 0;
  a1[9] = 0;
  a1[8] = (a1 + 9);
  v28 = (a1 + 8);
  a1[10] = 0;
  *(a1 + 22) = 5;
  a1[12] = 160;
  v30 = v3;
  v31 = v4;
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  subscriber::makeSimSlotRange();
  v26 = a1;
  if (v31)
  {
    sub_100004A34(v31);
  }

  v5 = v32;
  v6 = v33;
  if (v32 != v33)
  {
    v7 = v34;
    do
    {
      if (v34(*v5))
      {
        break;
      }

      ++v5;
    }

    while (v5 != v33);
    v8 = v33;
    while (v5 != v8)
    {
      v29 = *v5;
      v35 = &v29;
      *(sub_10030C46C(v28, &v29) + 8) = 0;
      v35 = &v29;
      v9 = sub_10164F798(v27, &v29);
      v10 = v9;
      v11 = v9[6];
      if (v9[7] != v11)
      {
        v12 = v9[9];
        v13 = v12 / 0xAA;
        v14 = *(v11 + 8 * (v12 / 0xAA));
        v15 = v12 % 0xAA;
        v16 = v14 + 24 * (v12 % 0xAA);
        v17 = v9[10] + v12;
        v18 = v17 / 0xAA;
        v19 = *(v11 + 8 * (v17 / 0xAA));
        v20 = v17 % 0xAA;
        v21 = v19 + 24 * v20;
        if (v21 != v16)
        {
          v22 = v20 - v15 + 170 * ((8 * v18 - 8 * v13) >> 3);
          if (v22 >= 1)
          {
            v23 = (v11 + 8 * v13);
            do
            {
              if (*(v16 + 23) < 0)
              {
                operator delete(*v16);
                v14 = *v23;
              }

              v16 += 24;
              if (v16 - v14 == 4080)
              {
                v24 = v23[1];
                ++v23;
                v14 = v24;
                v16 = v24;
              }
            }

            while (v16 != v21);
            v10[10] -= v22;
              ;
            }
          }
        }
      }

      do
      {
        ++v5;
      }

      while (v5 != v6 && (v7(*v5) & 1) == 0);
    }
  }

  return v26;
}

void sub_10164E5CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15)
  {
    sub_100004A34(a15);
  }

  sub_10006DCAC(a12, *(v15 + 72));
  sub_101350034(a11, *(v15 + 48));
  sub_100077CD4(v16, *(v15 + 24));
  v18 = *(v15 + 8);
  if (v18)
  {
    sub_100004A34(v18);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10164E62C(uint64_t a1, int a2)
{
  v4 = *(a1 + 72);
  result = a1 + 72;
  v3 = v4;
  if (v4)
  {
    v5 = result;
    do
    {
      if (*(v3 + 28) >= a2)
      {
        v5 = v3;
      }

      v3 = *(v3 + 8 * (*(v3 + 28) < a2));
    }

    while (v3);
    if (v5 != result && *(v5 + 28) <= a2)
    {
      ++*(v5 + 32);
    }
  }

  return result;
}

uint64_t sub_10164E674(uint64_t a1, int a2)
{
  v7 = a2;
  v2 = a1 + 72;
  v3 = *(a1 + 72);
  if (!v3)
  {
    return 0;
  }

  v4 = a1 + 64;
  v5 = v2;
  do
  {
    if (*(v3 + 28) >= a2)
    {
      v5 = v3;
    }

    v3 = *(v3 + 8 * (*(v3 + 28) < a2));
  }

  while (v3);
  if (v5 != v2 && *(v5 + 28) <= a2)
  {
    return *sub_1000A8C4C(v4, &v7);
  }

  else
  {
    return 0;
  }
}

std::string *sub_10164E6E8(uint64_t a1, unsigned int a2, const std::string *a3)
{
  v6 = a2;
  v7 = &v6;
  v4 = sub_10164FD90(a1 + 16, &v6);
  return std::string::operator=((v4 + 5), a3);
}

uint64_t *sub_10164E744@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  v6 = *(a1 + 24);
  result = (a1 + 24);
  v5 = v6;
  if (!v6)
  {
    goto LABEL_9;
  }

  v7 = (result - 1);
  v8 = result;
  do
  {
    v9 = *(v5 + 32);
    v10 = v9 >= a2;
    v11 = v9 < a2;
    if (v10)
    {
      v8 = v5;
    }

    v5 = *(v5 + 8 * v11);
  }

  while (v5);
  if (v8 != result && *(v8 + 32) <= a2)
  {
    *a3 = 0;
    *(a3 + 8) = 0;
    *(a3 + 16) = 0;
    if (*(v8 + 63) < 0)
    {
      sub_100005F2C(a3, *(v8 + 40), *(v8 + 48));
    }

    else
    {
      v12 = *(v8 + 40);
      *(a3 + 16) = *(v8 + 56);
      *a3 = v12;
    }

    return sub_100A5AE8C(v7, v8);
  }

  else
  {
LABEL_9:
    *a3 = 0;
    *(a3 + 8) = 0;
    *(a3 + 16) = 0;
  }

  return result;
}

void sub_10164E7F0(_Unwind_Exception *exception_object)
{
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10164E80C(uint64_t a1, uint64_t a2, int a3)
{
  v65 = a3;
  v5 = *(a1 + 48);
  v3 = a1 + 48;
  v4 = v5;
  if (v5)
  {
    v7 = v3 - 8;
    v8 = v3;
    do
    {
      if (*(v4 + 32) >= a3)
      {
        v8 = v4;
      }

      v4 = *(v4 + 8 * (*(v4 + 32) < a3));
    }

    while (v4);
    if (v8 != v3 && *(v8 + 32) <= a3)
    {
      *&v66 = &v65;
      v10 = sub_10164F798(v3 - 8, &v65);
      v11 = v10[9];
      v12 = v10[6];
      v13 = (v12 + 8 * (v11 / 0xAA));
      if (v10[7] == v12)
      {
        v14 = 0;
      }

      else
      {
        v14 = *v13 + 24 * (v11 % 0xAA);
      }

LABEL_13:
      v15 = 0;
      while (1)
      {
        *&v66 = &v65;
        v16 = sub_10164F798(v7, &v65);
        v17 = v16[6];
        if (v16[7] == v17)
        {
          v19 = 0;
        }

        else
        {
          v18 = v16[10] + v16[9];
          v19 = *(v17 + 8 * (v18 / 0xAA)) + 24 * (v18 % 0xAA);
        }

        if (v14 + v15 == v19)
        {
          break;
        }

        v20 = *(v14 + v15 + 23);
        if (v20 >= 0)
        {
          v21 = *(v14 + v15 + 23);
        }

        else
        {
          v21 = *(v14 + v15 + 8);
        }

        v22 = *(a2 + 23);
        v23 = v22;
        if ((v22 & 0x80u) != 0)
        {
          v22 = *(a2 + 8);
        }

        if (v21 == v22)
        {
          v24 = v20 >= 0 ? (v14 + v15) : *(v14 + v15);
          v25 = v23 >= 0 ? a2 : *a2;
          if (!memcmp(v24, v25, v21))
          {
            *&v66 = &v65;
            v27 = sub_10164F798(v7, &v65);
            v28 = v27[9];
            v29 = v27[6];
            v30 = v27[7];
            v31 = (v29 + 8 * (v28 / 0xAA));
            if (v30 == v29)
            {
              v32 = 0;
            }

            else
            {
              v32 = *v31 + 24 * (v28 % 0xAA);
            }

            if (v14 - v32 + v15)
            {
              v33 = 170 * (v13 - v31) - 0x5555555555555555 * ((v14 - *v13 + v15) >> 3) + 0x5555555555555555 * ((v32 - *v31) >> 3);
            }

            else
            {
              v33 = 0;
            }

            *&v66 = v29 + 8 * (v28 / 0xAA);
            *(&v66 + 1) = v32;
            sub_10164FCF4(&v66, v33);
            v34 = v66;
            v35 = v27[10];
            v36 = *v66;
            v37 = *(&v66 + 1) - *v66;
            v38 = 0xAAAAAAAAAAAAAAABLL * (v37 >> 3);
            if (v33 <= (v35 - 1) >> 1)
            {
              if (v37 < -23)
              {
                v51 = 168 - v38;
                v44 = (v66 - 8 * (v51 / 0xAA));
                v45 = *v44 + 24 * (170 * (v51 / 0xAA) - v51) + 4056;
              }

              else
              {
                v43 = v38 + 1;
                v44 = (v66 + 8 * (v43 / 0xAA));
                v45 = *v44 + 24 * (v43 % 0xAA);
              }

              if (v66 == v31)
              {
                v52 = v32;
                v53 = *(&v66 + 1);
              }

              else
              {
                v66 = 0uLL;
                v67 = 0;
                sub_10164FE68(&v66, v36, *(&v34 + 1), v44, v45);
                v44 = *(&v66 + 1);
                v45 = v67;
                v54 = (v34 - 8);
                while (v54 != v31)
                {
                  v55 = *v54--;
                  v66 = 0uLL;
                  v67 = 0;
                  sub_10164FE68(&v66, v55, v55 + 4080, v44, v45);
                  v44 = *(&v66 + 1);
                  v45 = v67;
                }

                v53 = *v54 + 4080;
                v52 = v32;
              }

              sub_10164FE68(&v66, v52, v53, v44, v45);
              if (*(v32 + 23) < 0)
              {
                operator delete(*v32);
              }

              *(v27 + 9) = vaddq_s64(*(v27 + 9), xmmword_1017CD970);
              sub_100642C84((v27 + 5), 1);
            }

            else
            {
              if (v37 < -23)
              {
                v46 = 168 - v38;
                v47 = 168 - v38;
                v40 = (v66 - 8 * ((168 - v38) / 0xAA));
                v41 = *v40;
                v42 = (*v40 + 24 * (170 * (v47 / 0xAA) - v46) + 4056);
              }

              else
              {
                v39 = v38 + 1;
                v40 = (v66 + 8 * ((v38 + 1) / 0xAA));
                v41 = *v40;
                v42 = (*v40 + 24 * (v39 % 0xAA));
              }

              v48 = v35 + v28;
              v49 = (v29 + 8 * (v48 / 0xAA));
              if (v30 == v29)
              {
                v50 = 0;
              }

              else
              {
                v50 = *v49 + 24 * (v48 % 0xAA);
              }

              if (v40 == v49)
              {
                v66 = 0uLL;
                v67 = 0;
                v60 = v50;
                v57 = v34 >> 64;
                v56 = v34;
              }

              else
              {
                v66 = 0uLL;
                v67 = 0;
                sub_10164FF44(&v66, v42, v41 + 255, v34, *(&v34 + 1));
                v56 = *(&v66 + 1);
                v57 = v67;
                v58 = v40 + 1;
                while (v58 != v49)
                {
                  v59 = *v58++;
                  v66 = 0uLL;
                  v67 = 0;
                  sub_10164FF44(&v66, v59, v59 + 255, v56, v57);
                  v56 = *(&v66 + 1);
                  v57 = v67;
                }

                v42 = *v58;
                v66 = 0uLL;
                v67 = 0;
                v60 = v50;
              }

              sub_10164FF44(&v66, v42, v60, v56, v57);
              if (*(v67 + 23) < 0)
              {
                operator delete(*v67);
              }

              --v27[10];
              sub_101350420(v27 + 5, 1);
            }

            v61 = v27[9];
            v62 = v27[6];
            v63 = (v62 + 8 * (v61 / 0xAA));
            if (v27[7] == v62)
            {
              v64 = 0;
            }

            else
            {
              v64 = *v63 + 24 * (v61 % 0xAA);
            }

            *&v66 = v63;
            *(&v66 + 1) = v64;
            sub_10164FCF4(&v66, v33);
            return 1;
          }
        }

        v15 += 24;
        if (v14 - *v13 + v15 == 4080)
        {
          v26 = v13[1];
          ++v13;
          v14 = v26;
          goto LABEL_13;
        }
      }
    }
  }

  return 0;
}

void sub_10164EDA0(uint64_t a1@<X0>, Registry **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  ctu::cf::assign();
  v71 = 0uLL;
  v72 = 0;
  ctu::cf::assign();
  v69 = 0uLL;
  v70 = 0;
  ctu::cf::assign();
  v67 = 0uLL;
  v68 = 0;
  v45 = 0uLL;
  *&v46 = 0;
  ctu::cf::assign();
  v65 = 0uLL;
  v66 = 0;
  v12 = *a2;
  v63 = 0uLL;
  v64 = 0;
  ServiceMap = Registry::getServiceMap(v12);
  v14 = ServiceMap;
  if (v15 < 0)
  {
    v16 = (v15 & 0x7FFFFFFFFFFFFFFFLL);
    v17 = 5381;
    do
    {
      v15 = v17;
      v18 = *v16++;
      v17 = (33 * v17) ^ v18;
    }

    while (v18);
  }

  std::mutex::lock(ServiceMap);
  *&v45 = v15;
  v19 = sub_100009510(&v14[1].__m_.__sig, &v45);
  if (v19)
  {
    v21 = v19[3];
    v20 = v19[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v14);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v20);
      v22 = 0;
      goto LABEL_9;
    }
  }

  else
  {
    v21 = 0;
  }

  std::mutex::unlock(v14);
  v20 = 0;
  v22 = 1;
LABEL_9:
  (*(*v21 + 96))(&__dst, v21, a5, 1, @"PhoneNumberRegistrationMessagePrefix", 0, 1);
  v45 = 0uLL;
  *&v46 = 0;
  ctu::cf::assign();
  v63 = v45;
  v64 = v46;
  sub_10000A1EC(&__dst.__r_.__value_.__l.__data_);
  if ((v22 & 1) == 0)
  {
    sub_100004A34(v20);
  }

  memset(&__dst, 0, sizeof(__dst));
  if (*(a4 + 23) < 0)
  {
    v23 = *(a4 + 8);
    if (v23)
    {
      sub_100005F2C(&__dst, *a4, v23);
      goto LABEL_20;
    }
  }

  else if (*(a4 + 23))
  {
    __dst = *a4;
    goto LABEL_20;
  }

  if (*(a3 + 23) >= 0)
  {
    v24 = a3;
  }

  else
  {
    v24 = *a3;
  }

  v25 = *v24;
  LODWORD(v45) = v25 * time(0);
  v26 = rand_r(&v45);
  std::to_string(&__dst, v26);
LABEL_20:
  sub_10164F584(a1, &__dst, a5);
  v61 = 0;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  *__p = 0u;
  v50 = 0u;
  v47 = 0u;
  *__src = 0u;
  v45 = 0u;
  v46 = 0u;
  sub_10000D518(&v45);
  v27 = sub_10000C030(&v45);
  v28 = sub_10000C030(v27);
  v29 = sub_10000C030(v28);
  v30 = sub_10000C030(v29);
  sub_10000C030(v30);
  v31 = std::ostream::operator<<();
  v32 = sub_10000C030(v31);
  v33 = sub_10000C030(v32);
  v34 = sub_10000C030(v33);
  v35 = sub_10000C030(v34);
  v36 = sub_10000C030(v35);
  v37 = sub_10000C030(v36);
  v38 = sub_10000C030(v37);
  sub_10000C030(v38);
  *a6 = 0;
  *(a6 + 8) = 0;
  *(a6 + 16) = 0;
  if ((BYTE8(v51) & 0x10) != 0)
  {
    v40 = v51;
    if (v51 < __src[1])
    {
      *&v51 = __src[1];
      v40 = __src[1];
    }

    v41 = __src[0];
  }

  else
  {
    if ((BYTE8(v51) & 8) == 0)
    {
      v39 = 0;
LABEL_30:
      v42 = a6;
      goto LABEL_33;
    }

    v41 = *(&v46 + 1);
    v40 = *(&v47 + 1);
  }

  v39 = v40 - v41;
  if ((v40 - v41) >= 0x7FFFFFFFFFFFFFF8)
  {
    sub_1000A2378();
  }

  if (v39 >= 0x17)
  {
    operator new();
  }

  *(a6 + 23) = v39;
  v42 = a6;
  if (!v39)
  {
    goto LABEL_30;
  }

  memmove(a6, v41, v39);
LABEL_33:
  *(v42 + v39) = 0;
  v43 = *(a6 + 23);
  if ((v43 & 0x80u) != 0)
  {
    v43 = *(a6 + 8);
  }

  v44 = *(a1 + 96);
  if (v43 > v44)
  {
    std::string::resize(a6, v44, 0);
  }

  if (SHIBYTE(v50) < 0)
  {
    operator delete(__p[1]);
  }

  std::locale::~locale(&v46);
  std::ostream::~ostream();
  std::ios::~ios();
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v64) < 0)
  {
    operator delete(v63);
  }

  if (SHIBYTE(v66) < 0)
  {
    operator delete(v65);
  }

  if (SHIBYTE(v68) < 0)
  {
    operator delete(v67);
  }

  if (SHIBYTE(v70) < 0)
  {
    operator delete(v69);
  }

  if (SHIBYTE(v72) < 0)
  {
    operator delete(v71);
  }
}

void sub_10164F430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, void *__p, uint64_t a47, int a48, __int16 a49, char a50, char a51)
{
  if (*(v51 + 23) < 0)
  {
    operator delete(*v51);
  }

  std::ios::~ios();
  if (a51 < 0)
  {
    operator delete(__p);
  }

  if (*(v52 - 217) < 0)
  {
    operator delete(*(v52 - 240));
  }

  if (*(v52 - 185) < 0)
  {
    operator delete(*(v52 - 208));
  }

  if (*(v52 - 153) < 0)
  {
    operator delete(*(v52 - 176));
  }

  if (*(v52 - 121) < 0)
  {
    operator delete(*(v52 - 144));
  }

  if (*(v52 - 89) < 0)
  {
    operator delete(*(v52 - 112));
  }

  _Unwind_Resume(a1);
}

void *sub_10164F584(uint64_t a1, __int128 *a2, int a3)
{
  v8 = a3;
  v9 = &v8;
  if (sub_10164F798(a1 + 40, &v8)[10] >= 5)
  {
    v9 = &v8;
    v5 = sub_10164F798(a1 + 40, &v8);
    sub_100642BFC(v5 + 5);
  }

  v9 = &v8;
  v6 = sub_10164F798(a1 + 40, &v8);
  return sub_10064295C(v6 + 5, a2);
}

uint64_t sub_10164F640@<X0>(uint64_t result@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  v8 = a2;
  v5 = result + 48;
  v4 = *(result + 48);
  if (!v4)
  {
    goto LABEL_8;
  }

  result += 40;
  v6 = v5;
  do
  {
    if (*(v4 + 32) >= a2)
    {
      v6 = v4;
    }

    v4 = *(v4 + 8 * (*(v4 + 32) < a2));
  }

  while (v4);
  if (v6 != v5 && *(v6 + 32) <= a2)
  {
    v9 = &v8;
    v7 = sub_10164F798(result, &v8);
    return sub_10165001C(a3, v7 + 5);
  }

  else
  {
LABEL_8:
    a3[1] = 0u;
    a3[2] = 0u;
    *a3 = 0u;
  }

  return result;
}

BOOL sub_10164F6E8(uint64_t a1, const void **a2)
{
  std::to_string(&v11, *(a1 + 88));
  v3 = SHIBYTE(v11.__r_.__value_.__r.__words[2]);
  if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(v11.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = v11.__r_.__value_.__l.__size_;
  }

  v5 = *(a2 + 23);
  v6 = v5;
  if (v5 < 0)
  {
    v5 = a2[1];
  }

  if (size == v5)
  {
    if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v7 = &v11;
    }

    else
    {
      v7 = v11.__r_.__value_.__r.__words[0];
    }

    if (v6 >= 0)
    {
      v8 = a2;
    }

    else
    {
      v8 = *a2;
    }

    v9 = memcmp(v7, v8, size) == 0;
    if (v3 < 0)
    {
      goto LABEL_16;
    }
  }

  else
  {
    v9 = 0;
    if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
    {
LABEL_16:
      operator delete(v11.__r_.__value_.__l.__data_);
    }
  }

  return v9;
}

uint64_t *sub_10164F798(uint64_t a1, int *a2)
{
  v2 = *(a1 + 8);
  if (!v2)
  {
LABEL_8:
    operator new();
  }

  v3 = *a2;
  while (1)
  {
    while (1)
    {
      v4 = v2;
      v5 = *(v2 + 32);
      if (v3 >= v5)
      {
        break;
      }

      v2 = *v4;
      if (!*v4)
      {
        goto LABEL_8;
      }
    }

    if (v5 >= v3)
    {
      return v4;
    }

    v2 = v4[1];
    if (!v2)
    {
      goto LABEL_8;
    }
  }
}

uint64_t sub_10164F894(uint64_t a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(a1 + 16) == 1)
    {
      sub_100641DD4(v2 + 5);
    }

    operator delete(v2);
  }

  return a1;
}

void *sub_10164F8E0(void *result, unint64_t a2)
{
  v2 = result;
  v3 = result[2] - result[1];
  if (v3)
  {
    v4 = a2;
  }

  else
  {
    v4 = a2 + 1;
  }

  if (v4 % 0xAA)
  {
    v5 = v4 / 0xAA + 1;
  }

  else
  {
    v5 = v4 / 0xAA;
  }

  v6 = result[4];
  if (v5 >= v6 / 0xAA)
  {
    v7 = v6 / 0xAA;
  }

  else
  {
    v7 = v5;
  }

  if (v5 <= v6 / 0xAA)
  {
    for (result[4] = v6 - 170 * v7; v7; --v7)
    {
      v14 = v2[1];
      __p[0] = *v14;
      v2[1] = v14 + 1;
      result = sub_100129284(v2, __p);
    }
  }

  else
  {
    v8 = v5 - v7;
    v9 = result[3] - *result;
    if (v5 - v7 > (v9 >> 3) - (v3 >> 3))
    {
      v10 = v3 >> 3;
      v11 = v9 >> 2;
      if (v11 <= v8 + v10)
      {
        v12 = v8 + v10;
      }

      else
      {
        v12 = v11;
      }

      v13 = v10 - v7;
      v18 = result;
      if (v12)
      {
        sub_1000FB8B8(result, v12);
      }

      __p[0] = 0;
      __p[1] = (8 * v13);
      v17 = 8 * v13;
      operator new();
    }

    if (v8)
    {
      if (result[3] != result[2])
      {
        operator new();
      }

      operator new();
    }

    for (result[4] = v6 - 170 * v7; v7; --v7)
    {
      v15 = v2[1];
      __p[0] = *v15;
      v2[1] = v15 + 1;
      result = sub_100129284(v2, __p);
    }
  }

  return result;
}

void sub_10164FC80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void *sub_10164FCF4(void *result, uint64_t a2)
{
  if (a2)
  {
    v2 = *result;
    v3 = a2 - 0x5555555555555555 * ((result[1] - **result) >> 3);
    if (v3 < 1)
    {
      v5 = 169 - v3;
      v6 = &v2[-(v5 / 0xAA)];
      *result = v6;
      v4 = *v6 + 24 * (170 * (v5 / 0xAA) - v5) + 4056;
    }

    else
    {
      *result = &v2[v3 / 0xAA];
      v4 = v2[v3 / 0xAA] + 24 * (v3 % 0xAA);
    }

    result[1] = v4;
  }

  return result;
}

uint64_t *sub_10164FD90(uint64_t a1, unsigned int *a2)
{
  v2 = *(a1 + 8);
  if (!v2)
  {
LABEL_8:
    operator new();
  }

  v3 = *a2;
  while (1)
  {
    while (1)
    {
      v4 = v2;
      v5 = *(v2 + 32);
      if (v3 >= v5)
      {
        break;
      }

      v2 = *v4;
      if (!*v4)
      {
        goto LABEL_8;
      }
    }

    if (v5 >= v3)
    {
      return v4;
    }

    v2 = v4[1];
    if (!v2)
    {
      goto LABEL_8;
    }
  }
}

uint64_t sub_10164FE68(uint64_t result, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  v5 = a4;
  v7 = result;
  if (a2 == a3)
  {
    v8 = a2;
  }

  else
  {
    v8 = a3;
    v9 = *a4;
    while (1)
    {
      v10 = 0xAAAAAAAAAAAAAAABLL * ((a5 - v9) >> 3);
      if ((0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 3)) < v10)
      {
        v10 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 3);
      }

      v11 = a3 - 24 * v10;
      result = sub_1001E2E74(&v15, v11, a3, a5);
      if (v11 == a2)
      {
        break;
      }

      v13 = *--v5;
      v9 = v13;
      a5 = v13 + 4080;
      a3 = v11;
    }

    a5 = v12;
    if (*v5 + 4080 == v12)
    {
      v14 = v5[1];
      ++v5;
      a5 = v14;
    }
  }

  *v7 = v8;
  v7[1] = v5;
  v7[2] = a5;
  return result;
}

__int128 *sub_10164FF44(__int128 *result, __int128 *a2, __int128 *a3, uint64_t *a4, uint64_t a5)
{
  v5 = a4;
  v6 = a2;
  v7 = result;
  if (a2 != a3)
  {
    v5 = a4 + 1;
    v9 = *a4;
    while (1)
    {
      v10 = 0xAAAAAAAAAAAAAAABLL * ((v9 - a5 + 4080) >> 3);
      if ((0xAAAAAAAAAAAAAAABLL * ((a3 - v6) >> 3)) < v10)
      {
        v10 = 0xAAAAAAAAAAAAAAABLL * ((a3 - v6) >> 3);
      }

      result = sub_10080520C(&v13, v6, (v6 + 24 * v10), a5);
      v6 = result;
      if (result == a3)
      {
        break;
      }

      v12 = *v5++;
      v9 = v12;
      a5 = v12;
    }

    a5 = v11;
    if (*(v5 - 1) + 4080 == v11)
    {
      a5 = *v5;
    }

    else
    {
      --v5;
    }
  }

  *v7 = v6;
  v7[1] = v5;
  v7[2] = a5;
  return result;
}

uint64_t sub_10165001C(uint64_t a1, void *a2)
{
  *(a1 + 16) = 0u;
  *(a1 + 32) = 0u;
  *a1 = 0u;
  v3 = a2[4];
  v4 = a2[1];
  if (a2[2] == v4)
  {
    v5 = 0;
    v8 = 0;
    v7 = (v4 + 8 * ((a2[5] + v3) / 0xAA));
  }

  else
  {
    v5 = (*(v4 + 8 * (v3 / 0xAA)) + 24 * (v3 % 0xAA));
    v6 = a2[5] + v3;
    v7 = (v4 + 8 * (v6 / 0xAA));
    v8 = (*v7 + 24 * (v6 % 0xAA));
  }

  sub_1016500E4(a1, (v4 + 8 * (v3 / 0xAA)), v5, v7, v8);
  return a1;
}

void *sub_1016500E4(void *a1, void *a2, __int128 *a3, void *a4, __int128 *a5)
{
  if (a5 == a3)
  {
    v5 = 0;
  }

  else
  {
    v5 = 170 * (a4 - a2) - 0x5555555555555555 * ((a5 - *a4) >> 3) + 0x5555555555555555 * ((a3 - *a2) >> 3);
  }

  return sub_101650134(a1, a2, a3, v5);
}

void *sub_101650134(void *a1, void *a2, __int128 *a3, unint64_t a4)
{
  v8 = a1[1];
  v9 = a1[2];
  if (v9 == v8)
  {
    v10 = 0;
  }

  else
  {
    v10 = 170 * ((v9 - v8) >> 3) - 1;
  }

  v11 = a1[5];
  v12 = v11 + a1[4];
  v13 = v10 - v12;
  if (a4 > v13)
  {
    sub_10164F8E0(a1, a4 - v13);
    v11 = a1[5];
    v8 = a1[1];
    v9 = a1[2];
    v12 = a1[4] + v11;
  }

  v14 = (v8 + 8 * (v12 / 0xAA));
  if (v9 == v8)
  {
    v15 = 0;
    v16 = 0;
  }

  else
  {
    v15 = *v14 + 24 * (v12 % 0xAA);
    v16 = v15;
  }

  v26 = v14;
  v27 = v16;
  result = sub_10164FCF4(&v26, a4);
  v18 = v27;
  if (v15 != v27)
  {
    v19 = v26;
    do
    {
      if (v14 == v19)
      {
        v20 = v18;
      }

      else
      {
        v20 = *v14 + 4080;
      }

      if (v15 == v20)
      {
        v20 = v15;
      }

      else
      {
        v21 = 0;
        v22 = v15;
        do
        {
          if (*(a3 + 23) < 0)
          {
            result = sub_100005F2C(v22, *a3, *(a3 + 1));
          }

          else
          {
            v23 = *a3;
            *(v22 + 16) = *(a3 + 2);
            *v22 = v23;
          }

          a3 = (a3 + 24);
          if ((a3 - *a2) == 4080)
          {
            v24 = a2[1];
            ++a2;
            a3 = v24;
          }

          v22 += 24;
          v21 -= 24;
        }

        while (v22 != v20);
        v11 = a1[5];
      }

      v11 -= 0x5555555555555555 * ((v20 - v15) >> 3);
      a1[5] = v11;
      if (v14 == v19)
      {
        break;
      }

      v25 = v14[1];
      ++v14;
      v15 = v25;
    }

    while (v25 != v18);
  }

  return result;
}

void sub_101650374(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2)
  {
    dispatch_retain(*a2);
  }

  sub_10159BCDC();
}

void sub_1016503EC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_release(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_101650404(QMICDMASettingsFactoryInterface *this)
{
  *this = off_101F5CEC8;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  QMICDMASettingsFactoryInterface::~QMICDMASettingsFactoryInterface(this);
}

void sub_101650460(QMICDMASettingsFactoryInterface *this)
{
  *this = off_101F5CEC8;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  QMICDMASettingsFactoryInterface::~QMICDMASettingsFactoryInterface(this);

  operator delete();
}

void _StartCSINotificationThread()
{
  v0 = 0;
  v1 = 0;
  InternetAssertion::create();
}

void sub_1016507F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20, uint64_t a21, std::__shared_weak_count *a22, uint64_t a23, uint64_t a24, uint64_t a25, std::__shared_weak_count *a26, uint64_t a27, uint64_t a28, uint64_t a29, std::__shared_weak_count *a30, uint64_t a31, uint64_t a32)
{
  if (a12)
  {
    sub_100004A34(a12);
  }

  if (a14)
  {
    sub_100004A34(a14);
  }

  if (a18)
  {
    sub_100004A34(a18);
  }

  if (a22)
  {
    sub_100004A34(a22);
  }

  if (a26)
  {
    sub_100004A34(a26);
  }

  if (a30)
  {
    sub_100004A34(a30);
  }

  v34 = *(v32 - 168);
  if (v34)
  {
    sub_100004A34(v34);
  }

  v35 = *(v32 - 136);
  if (v35)
  {
    sub_100004A34(v35);
  }

  v36 = *(v32 - 104);
  if (v36)
  {
    sub_100004A34(v36);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016510C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_1001018AC(va);
  operator delete();
}

uint64_t _StopCSINotificationThread(void)
{
  pthread_mutex_lock(&stru_101FB9DA8);
  if (qword_101FCBD60)
  {
    sub_100DEC69C(qword_101FCBD60);
    while (qword_101FCBD60)
    {
      pthread_cond_wait(&stru_101FB9DE8, &stru_101FB9DA8);
    }
  }

  pthread_mutex_unlock(&stru_101FB9DA8);
  return 1;
}

void sub_101651324(int a1, int **a2)
{
  if (!a1)
  {
    return;
  }

  v4 = *a2;
  v3 = a2[1];
  v5 = v3 - *a2;
  v91 = 0u;
  if (v5 >= 0x10)
  {
    v6 = 16;
  }

  else
  {
    v6 = v5;
  }

  v90 = 0uLL;
  v89 = 0uLL;
  v88 = 0uLL;
  v87 = 0uLL;
  v86 = 0uLL;
  v85 = 0uLL;
  v84 = 0uLL;
  if (v3 != v4)
  {
    v7 = &v84;
    v8 = v4;
    do
    {
      v9 = *v8++;
      *v7 = v9;
      v7 = (v7 + 8);
    }

    while (v8 != &v4[v6]);
  }

  memset(__dst, 0, sizeof(__dst));
  memset(v82, 0, sizeof(v82));
  bzero(v81, 0x400uLL);
  if (a1 > 99)
  {
    if (a1 > 117)
    {
      if (a1 == 118)
      {
        *&buf.var0 = 0;
        buf.var2.__rep_.__l.__data_ = 0;
        sub_10020A8B4(v10, &buf);
        v27 = *&buf.var0;
        if (*&buf.var0)
        {
          v28 = (*(**&buf.var0 + 808))(*&buf.var0);
          sub_10000501C(__p, "Data provisioning context deactivate");
          (*(*v27 + 88))(v27, v28, 64, 0, __p, 0, 0);
          if (v66 < 0)
          {
            operator delete(__p[0]);
          }

          v29 = *&buf.var0;
          v30 = (*(**&buf.var0 + 808))(*&buf.var0);
          sub_10000501C(v63, "Data provisioning secondary context deactivate");
          (*(*v29 + 88))(v29, v30, 0x800000, 0, v63, 0, 0);
          if (v64 < 0)
          {
            operator delete(v63[0]);
          }
        }

        data = buf.var2.__rep_.__l.__data_;
        if (buf.var2.__rep_.__l.__data_)
        {
          goto LABEL_142;
        }

        return;
      }

      if (a1 == 132)
      {
        v24 = 105;
LABEL_120:
        sub_101651F18(v24, v6, &v84, __dst, v82, v81);
        return;
      }

      if (a1 != 151 || v3 == v4)
      {
        return;
      }

      --v6;
      v24 = *(&v84 + v6);
    }

    else
    {
      if (a1 != 100)
      {
        if (a1 == 103)
        {
          ++v6;
          v22 = 3;
        }

        else
        {
          if (a1 != 104)
          {
            return;
          }

          ++v6;
          v22 = 2;
        }

        *(&v84 + 1) = v22;
        v24 = 86;
        goto LABEL_120;
      }

      *&buf.var0 = 0;
      buf.var2.__rep_.__l.__data_ = 0;
      sub_10020A8B4(v10, &buf);
      if (*&buf.var0)
      {
        v6 = (*(**&buf.var0 + 344))(*&buf.var0, 0, &v84);
        v24 = 37;
      }

      else
      {
        v24 = 0;
      }

      if (buf.var2.__rep_.__l.__data_)
      {
        sub_100004A34(buf.var2.__rep_.__l.__data_);
      }
    }

    if (!v24)
    {
      return;
    }

    goto LABEL_120;
  }

  if (a1 > 49)
  {
    if ((a1 - 50) >= 3)
    {
      return;
    }

    *&v84 = 11;
    if (a1 == 51)
    {
      v23 = 48;
    }

    else
    {
      v23 = 49;
    }

    if (a1 == 50)
    {
      v24 = 47;
    }

    else
    {
      v24 = v23;
    }

    if ((sub_100B051A4() & 4) != 0)
    {
      sub_100B051E4(4);
      sub_101651F18(v24, 1, &v84, __dst, v82, v81);
      v6 = 0;
      v24 = 6;
    }

    else
    {
      v6 = 1;
    }

    goto LABEL_120;
  }

  if (a1 != 1)
  {
    if (a1 != 48)
    {
      if (a1 != 49)
      {
        return;
      }

      *&v84 = 11;
      v79 = 0u;
      v80 = 0u;
      v77 = 0u;
      v78 = 0u;
      v75 = 0u;
      v76 = 0u;
      v74 = 0u;
      *v73 = 0u;
      memset(&buf, 0, sizeof(buf));
      CSIPhoneNumber::CSIPhoneNumber(&buf);
      Registry::get(&v67, v11);
      ServiceMap = Registry::getServiceMap(v67);
      v13 = ServiceMap;
      if (v14 < 0)
      {
        v15 = (v14 & 0x7FFFFFFFFFFFFFFFLL);
        v16 = 5381;
        do
        {
          v14 = v16;
          v17 = *v15++;
          v16 = (33 * v16) ^ v17;
        }

        while (v17);
      }

      std::mutex::lock(ServiceMap);
      v70 = v14;
      v18 = sub_100009510(&v13[1].__m_.__sig, &v70);
      if (v18)
      {
        v20 = v18[3];
        v19 = v18[4];
        if (v19)
        {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v13);
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_100004A34(v19);
          v21 = 0;
          goto LABEL_83;
        }
      }

      else
      {
        v20 = 0;
      }

      std::mutex::unlock(v13);
      v19 = 0;
      v21 = 1;
LABEL_83:
      v56 = (*(*v20 + 288))(v20, &buf, 2);
      if ((v21 & 1) == 0)
      {
        sub_100004A34(v19);
      }

      if (v68)
      {
        sub_100004A34(v68);
      }

      if (v56)
      {
        CSIPhoneNumber::getFullNumber(&v67, &buf);
        v57 = v69 >= 0 ? &v67 : v67;
        strlcpy(__dst, v57, 0x100uLL);
        if (v69 < 0)
        {
          operator delete(v67);
        }
      }

      if ((sub_100B051A4() & 4) != 0)
      {
LABEL_109:
        sub_100B051E4(4);
        sub_101651F18(0x2E, 1, &v84, __dst, v82, v81);
        v6 = 0;
        v24 = 6;
        goto LABEL_110;
      }

LABEL_108:
      v24 = 46;
      v6 = 1;
LABEL_110:
      if (SBYTE7(v80) < 0)
      {
        operator delete(v79);
      }

      if (SHIBYTE(v78) < 0)
      {
        operator delete(*(&v77 + 1));
      }

      if (SBYTE7(v76) < 0)
      {
        operator delete(v75);
      }

      if (SBYTE7(v74) < 0)
      {
        operator delete(v73[0]);
      }

      if (*(&buf.var2.__rep_.__l + 23) < 0)
      {
        operator delete(buf.var2.__rep_.__l.__data_);
      }

      goto LABEL_120;
    }

    *&v84 = 11;
    v79 = 0u;
    v80 = 0u;
    v77 = 0u;
    v78 = 0u;
    v75 = 0u;
    v76 = 0u;
    v74 = 0u;
    *v73 = 0u;
    memset(&buf, 0, sizeof(buf));
    CSIPhoneNumber::CSIPhoneNumber(&buf);
    Registry::get(&v67, v32);
    v33 = Registry::getServiceMap(v67);
    v34 = v33;
    if (v35 < 0)
    {
      v36 = (v35 & 0x7FFFFFFFFFFFFFFFLL);
      v37 = 5381;
      do
      {
        v35 = v37;
        v38 = *v36++;
        v37 = (33 * v37) ^ v38;
      }

      while (v38);
    }

    std::mutex::lock(v33);
    v70 = v35;
    v39 = sub_100009510(&v34[1].__m_.__sig, &v70);
    if (v39)
    {
      v41 = v39[3];
      v40 = v39[4];
      if (v40)
      {
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v34);
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v40);
        v42 = 0;
        goto LABEL_97;
      }
    }

    else
    {
      v41 = 0;
    }

    std::mutex::unlock(v34);
    v40 = 0;
    v42 = 1;
LABEL_97:
    v58 = (*(*v41 + 288))(v41, &buf, 1);
    if ((v42 & 1) == 0)
    {
      sub_100004A34(v40);
    }

    if (v68)
    {
      sub_100004A34(v68);
    }

    if (v58)
    {
      CSIPhoneNumber::getFullNumber(&v67, &buf);
      v59 = v69 >= 0 ? &v67 : v67;
      strlcpy(__dst, v59, 0x100uLL);
      if (v69 < 0)
      {
        operator delete(v67);
      }
    }

    if ((sub_100B051A4() & 4) != 0)
    {
      goto LABEL_109;
    }

    goto LABEL_108;
  }

  v67 = 0;
  v68 = 0;
  Registry::get(&v67, v10);
  v25 = v84;
  if (v84 == -1)
  {
    v26 = 0;
  }

  else
  {
    v70 = 0;
    covertIntegersToUuid(&v70, v84, DWORD2(v84), v85, DWORD2(v85));
    sub_100DF07C8(v67, &buf);
    v26 = CallController::hasCallWithUuid(*&buf.var0, &v70);
    if (buf.var2.__rep_.__l.__data_)
    {
      sub_100004A34(buf.var2.__rep_.__l.__data_);
    }

    v25 = sub_1000475BC(&v70);
  }

  v70 = 0;
  v71 = 0;
  sub_10020A8B4(v25, &v70);
  if (!v26)
  {
    v54 = v70;
    if (!v70)
    {
      goto LABEL_139;
    }

    v55 = 34;
    goto LABEL_138;
  }

  if ((atomic_load_explicit(qword_101FCAFC0, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(qword_101FCAFC0))
  {
    __cxa_atexit(sub_1010D9714, &xmmword_101FCAFD0, &_mh_execute_header);
    __cxa_guard_release(qword_101FCAFC0);
  }

  sub_100DF07C8(v67, &buf);
  v43 = CallController::activeOrHeldCalls(*&buf.var0);
  if (buf.var2.__rep_.__l.__data_)
  {
    sub_100004A34(buf.var2.__rep_.__l.__data_);
  }

  if ((v43 & 1) == 0)
  {
    if (xmmword_101FCAFD0)
    {
      v60 = *(&xmmword_101FCAFD0 + 1);
      xmmword_101FCAFD0 = 0uLL;
      if (v60)
      {
        sub_100004A34(v60);
      }
    }

    goto LABEL_136;
  }

  if (!xmmword_101FCAFD0)
  {
    v44 = Registry::getServiceMap(v67);
    v45 = v44;
    if (v46 < 0)
    {
      v47 = (v46 & 0x7FFFFFFFFFFFFFFFLL);
      v48 = 5381;
      do
      {
        v46 = v48;
        v49 = *v47++;
        v48 = (33 * v48) ^ v49;
      }

      while (v49);
    }

    std::mutex::lock(v44);
    *&buf.var0 = v46;
    v50 = sub_100009510(&v45[1].__m_.__sig, &buf);
    if (v50)
    {
      v52 = v50[3];
      v51 = v50[4];
      if (v51)
      {
        atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v45);
        atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v51);
        v53 = 0;
        goto LABEL_127;
      }
    }

    else
    {
      v52 = 0;
    }

    std::mutex::unlock(v45);
    v51 = 0;
    v53 = 1;
LABEL_127:
    if (v52)
    {
      (*(*v52 + 8))(&buf, v52, "com.apple.commcenter", 0);
      v61 = *&buf.var0;
      *&buf.var0 = 0;
      buf.var2.__rep_.__l.__data_ = 0;
      v62 = *(&xmmword_101FCAFD0 + 1);
      xmmword_101FCAFD0 = v61;
      if (v62)
      {
        sub_100004A34(v62);
        if (buf.var2.__rep_.__l.__data_)
        {
          sub_100004A34(buf.var2.__rep_.__l.__data_);
        }
      }
    }

    if ((v53 & 1) == 0)
    {
      sub_100004A34(v51);
    }

    if (!xmmword_101FCAFD0 && os_log_type_enabled(&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      buf.var0 = 136315138;
      *&buf.var1 = "com.apple.commcenter";
      _os_log_error_impl(&_mh_execute_header, &_os_log_default, OS_LOG_TYPE_ERROR, "Could not create power assertion: %s", &buf, 0xCu);
    }
  }

LABEL_136:
  v54 = v70;
  if (!v70)
  {
    goto LABEL_139;
  }

  v55 = 35;
LABEL_138:
  (*(*v54 + 176))(v54, 3, v55, 0);
LABEL_139:
  if (v71)
  {
    sub_100004A34(v71);
  }

  data = v68;
  if (v68)
  {
LABEL_142:
    sub_100004A34(data);
  }
}

void sub_101651DD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *__p, std::__shared_weak_count *a23, int a24, __int16 a25, char a26, char a27, char a28, std::__shared_weak_count *a29, char a30, uint64_t a31)
{
  if ((v32 & 1) == 0)
  {
    sub_100004A34(v31);
  }

  if (a29)
  {
    sub_100004A34(a29);
  }

  if (a23)
  {
    sub_100004A34(a23);
  }

  _Unwind_Resume(exception_object);
}

void sub_101651F18(Registry *a1, uint64_t a2, int64_t *a3, _BYTE *a4, _BYTE *a5, _BYTE *a6)
{
  v23 = 0;
  v24 = 0;
  Registry::get(&v23, a1);
  ServiceMap = Registry::getServiceMap(v23);
  v13 = ServiceMap;
  if ((v14 & 0x8000000000000000) != 0)
  {
    v15 = (v14 & 0x7FFFFFFFFFFFFFFFLL);
    v16 = 5381;
    do
    {
      v14 = v16;
      v17 = *v15++;
      v16 = (33 * v16) ^ v17;
    }

    while (v17);
  }

  std::mutex::lock(ServiceMap);
  v25 = v14;
  v18 = sub_100009510(&v13[1].__m_.__sig, &v25);
  if (!v18)
  {
    v20 = 0;
LABEL_9:
    std::mutex::unlock(v13);
    v19 = 0;
    v21 = 1;
    if (!v20)
    {
      goto LABEL_11;
    }

    goto LABEL_10;
  }

  v20 = v18[3];
  v19 = v18[4];
  if (!v19)
  {
    goto LABEL_9;
  }

  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v13);
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_100004A34(v19);
  v21 = 0;
  if (v20)
  {
LABEL_10:
    BYTE2(v22) = 0;
    LOWORD(v22) = 0;
    (*(*v20 + 32))(v20, a1, a2, a3, 0, 0, a4, a5, a6, v22);
  }

LABEL_11:
  if ((v21 & 1) == 0)
  {
    sub_100004A34(v19);
  }

  sub_1009FC418(a1, a2, a3, 0, 0, a4, a5, a6, 0, 0, 0);
  if (v24)
  {
    sub_100004A34(v24);
  }
}

void sub_1016520B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if ((v13 & 1) == 0)
  {
    sub_100004A34(v14);
  }

  if (a13)
  {
    sub_100004A34(a13);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016520EC(uint64_t a1)
{
  sub_1016526D0((a1 + 24));
  v3 = a1;
  sub_1001018AC(&v3);
  return a1;
}

void sub_101652130(uint64_t a1)
{
  sub_101652478(a1);

  operator delete();
}

uint64_t sub_101652168(uint64_t a1)
{
  v7 = 0u;
  memset(v6, 0, sizeof(v6));
  v2 = sub_10004A4A8((a1 + 48));
  sub_100048D3C(v6, v2);
  if (*(a1 + 32))
  {
    for (i = *sub_100974C7C((a1 + 32)); i != *(sub_100974C7C((a1 + 32)) + 8); i += 6)
    {
      memset(v8, 0, sizeof(v8));
      sub_10004ACE8(i, v8);
      if (sub_100048EA8(i))
      {
        if (*(a1 + 24) == 1)
        {
          *(a1 + 24) = 0;
          sub_100100F00(a1, v6);
        }

        sub_10004B040(v8);
        break;
      }

      sub_10004B040(v8);
    }
  }

  v4 = *(a1 + 24);
  sub_10004A704(*(&v7 + 1));
  sub_10004A6B0(v6);
  return v4;
}

void sub_1016522A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10004B040(v3 - 80);
  sub_1000FFEDC(va);
  _Unwind_Resume(a1);
}

uint64_t sub_1016522E4(uint64_t a1)
{
  v1 = sub_10004ACA4((a1 + 48));

  return sub_100048C68(v1);
}

uint64_t sub_101652310(uint64_t a1)
{
  v1 = sub_10004ACA4((a1 + 48));

  return sub_10004A704(v1);
}

atomic_uint **sub_10165233C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v4 = *(a1 + 40);
  *a2 = *(a1 + 32);
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 8), 1u, memory_order_relaxed);
    v5 = *(a1 + 40);
  }

  else
  {
    v5 = 0;
  }

  v7[1] = v2;
  v7[2] = v3;
  *(a1 + 32) = 0;
  *(a1 + 40) = 0;
  v7[0] = v5;
  return sub_10004A724(v7);
}

uint64_t sub_101652394(uint64_t result)
{
  if (result)
  {
    v1 = result;
    sub_1016526D0((result + 24));
    v2 = v1;
    sub_1001018AC(&v2);
    operator delete();
  }

  return result;
}

uint64_t sub_101652408(uint64_t result)
{
  v1 = *(result + 16);
  if (v1)
  {
    sub_1016526D0((v1 + 24));
    v2 = v1;
    sub_1001018AC(&v2);
    operator delete();
  }

  return result;
}

uint64_t sub_101652478(uint64_t a1)
{
  *a1 = off_101F5CF28;
  v2 = (a1 + 40);
  sub_10004A724((a1 + 56));
  sub_10004A724(v2);
  *a1 = off_101E263F8;
  sub_100083940((a1 + 16));
  return a1;
}

uint64_t sub_101652508(uint64_t a1)
{
  result = *(a1 + 16);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t sub_101652550(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4)
  {
    goto LABEL_2;
  }

  v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(a2 + 8) = 0;
        return result;
      }

      result = *(*a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ("N5boost3_bi6bind_tIvNS_4_mfi3mf1Iv18EventSenderAdapterRKN5event8CSIEventEEENS0_5list2INS0_5valueIPS4_EENS_3argILi1EEEEEEE" & 0x7FFFFFFFFFFFFFFFLL) || (result = strcmp(result, ("N5boost3_bi6bind_tIvNS_4_mfi3mf1Iv18EventSenderAdapterRKN5event8CSIEventEEENS0_5list2INS0_5valueIPS4_EENS_3argILi1EEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *a2 = v4;
      }

      else
      {
        *a2 = 0;
      }
    }
  }

  else
  {
    v5 = *result;
    *(a2 + 16) = *(result + 16);
    *a2 = v5;
  }

  return result;
}

uint64_t sub_1016525F0(uint64_t a1)
{
  v1 = *(a1 + 8);
  v2 = *a1;
  v3 = (*(a1 + 16) + (v1 >> 1));
  if (v1)
  {
    return (*(*v3 + v2))();
  }

  else
  {
    return v2(v3);
  }
}

uint64_t sub_101652618(uint64_t result, uint64_t a2)
{
  if (a2 != result)
  {
    v2 = a2;
    v3 = result;
    v4 = *a2;
    if (*a2)
    {
      *result = v4;
      if (v4)
      {
        v7 = *(a2 + 8);
        *(result + 24) = *(a2 + 24);
        *(result + 8) = v7;
      }

      else
      {
        result = (*v4)(a2 + 8, result + 8, 1);
      }
    }

    else
    {
      v5 = *result;
      if (!*result)
      {
        return result;
      }

      if ((v5 & 1) == 0)
      {
        v6 = *v5;
        if (v6)
        {
          result = v6(result + 8, result + 8, 2);
        }
      }

      v2 = v3;
    }

    *v2 = 0;
  }

  return result;
}

void sub_1016526AC(void *a1)
{
  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_rethrow();
}

void (***sub_1016526D0(void (***a1)(void, void, uint64_t)))(void, void, uint64_t)
{
  v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      v3 = *v2;
      if (v3)
      {
        v3(a1 + 1, a1 + 1, 2);
      }
    }

    *a1 = 0;
  }

  return a1;
}

uint64_t sub_101652720()
{
  {
    return __cxa_atexit(sub_100DBA2A0, &ctu::Singleton<ctu::power::assertion,ctu::power::assertion,ctu::PthreadMutexGuardPolicy<ctu::power::assertion>>::sInstance, &_mh_execute_header);
  }

  return result;
}

void sub_10165284C(KeychainStoreFactoryInterface *this)
{
  *this = off_101F5D060;
  v2 = *(this + 2);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  KeychainStoreFactoryInterface::~KeychainStoreFactoryInterface(this);
}

void sub_1016528A8(KeychainStoreFactoryInterface *this)
{
  *this = off_101F5D060;
  v2 = *(this + 2);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  KeychainStoreFactoryInterface::~KeychainStoreFactoryInterface(this);

  operator delete();
}

void sub_101652938(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F5D0A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1016529B4(KeychainStoreFactoryInterface *this)
{
  *this = off_101F5D060;
  v2 = *(this + 2);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  KeychainStoreFactoryInterface::~KeychainStoreFactoryInterface(this);
}

void sub_101652A10(KeychainStoreFactoryInterface *this)
{
  *this = off_101F5D060;
  v2 = *(this + 2);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  KeychainStoreFactoryInterface::~KeychainStoreFactoryInterface(this);

  operator delete();
}

void sub_101652C94(_Unwind_Exception *a1)
{
  objc_destroyWeak((v1 + 32));
  objc_destroyWeak((v2 - 24));
  _Unwind_Resume(a1);
}

void sub_101652CB0(uint64_t a1, void *a2)
{
  v5 = a2;
  WeakRetained = objc_loadWeakRetained((a1 + 32));
  v4 = WeakRetained;
  if (WeakRetained)
  {
    [WeakRetained registerOfferCategory:v5];
  }
}

void sub_101653130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, void *a18)
{
  if (v18)
  {
    sub_100004A34(v18);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10165320C(void *a1, void *a2)
{
  v3 = a2;
  v4 = [v3 identifier];
  v5 = [v4 isEqualToString:a1[4]];

  if (v5)
  {
    v6 = sub_100032AC8(*(a1[5] + 8));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = a1[4];
      v13 = 138412290;
      v14 = v7;
LABEL_7:
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I '%@' notification category is already registered, removing it", &v13, 0xCu);
    }
  }

  else
  {
    v8 = [v3 identifier];
    v9 = [v8 isEqualToString:a1[6]];

    if (!v9)
    {
      v11 = 1;
      goto LABEL_10;
    }

    v6 = sub_100032AC8(*(a1[5] + 8));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v10 = a1[6];
      v13 = 138412290;
      v14 = v10;
      goto LABEL_7;
    }
  }

  v11 = 0;
LABEL_10:

  return v11;
}

void sub_1016535AC(id a1, NSError *a2)
{
  v2 = a2;
  if (v2 && os_log_type_enabled(&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    v3 = [(NSError *)v2 localizedDescription];
    v4 = 138412290;
    v5 = v3;
    _os_log_error_impl(&_mh_execute_header, &_os_log_default, OS_LOG_TYPE_ERROR, "addNotificationRequest error: %@", &v4, 0xCu);
  }
}

uint64_t sub_1016538FC(uint64_t a1)
{
  *a1 = off_101F5D1A0;

  v2 = *(a1 + 72);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(a1 + 56);
  if (v3)
  {
    sub_100004A34(v3);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 40));
  sub_100320D6C(a1 + 8);
  return a1;
}

void sub_101653970(uint64_t a1)
{
  sub_1016538FC(a1);

  operator delete();
}

void sub_1016539A8(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  v4 = *(a1 + 48);
  switch(a2)
  {
    case 2:
      *buf = 0;
      v7 = kBifrostLocalizationTable;
      (*(*v4 + 40))(&buf[8], v4, kBifrostLocalizationTable, @"BIFROST_MESSAGING_ALERT_CONNECT_OFFER_BODY", 0);
      (*(*v4 + 40))(&v10, v4, v7, @"BIFROST_MESSAGING_ALERT_CONNECT_OFFER_ACCEPT", 0);
      v11 = @"ConnectionAssistant-OTG-Accept-SatelliteConnection";
      CFRetain(@"ConnectionAssistant-OTG-Accept-SatelliteConnection");
      v12 = @"OffGridModeOfferAlert";
      CFRetain(@"OffGridModeOfferAlert");
      v13 = 0;
      operator new();
    case 1:
      *buf = 0;
      v6 = kBifrostLocalizationTable;
      (*(*v4 + 40))(&buf[8], v4, kBifrostLocalizationTable, @"BIFROST_MESSAGING_ALERT_OTG_OFFER_BODY", 0);
      (*(*v4 + 40))(&v10, v4, v6, @"BIFROST_MESSAGING_ALERT_OTG_OFFER_ACCEPT", 0);
      v11 = @"ConnectionAssistant-OTG-Accept";
      CFRetain(@"ConnectionAssistant-OTG-Accept");
      v12 = @"OffGridModeOfferAlert";
      CFRetain(@"OffGridModeOfferAlert");
      v13 = 0;
      operator new();
    case 0:
      v5 = kBifrostLocalizationTable;
      (*(*v4 + 40))(buf, *(a1 + 48), kBifrostLocalizationTable, @"BIFROST_MESSAGING_LOCK_SCREEN_OTG_OFFER_TITLE", 0);
      (*(*v4 + 40))(&buf[8], v4, v5, @"BIFROST_MESSAGING_LOCK_SCREEN_OTG_OFFER_BODY", 0);
      v10 = 0;
      v11 = @"ConnectionAssistant-OTG";
      CFRetain(@"ConnectionAssistant-OTG");
      v12 = @"OffGridModeOffer";
      CFRetain(@"OffGridModeOffer");
      v13 = 257;
      operator new();
  }

  v8 = sub_100032AC8((a1 + 40));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *buf = 0;
    _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to create alert content", buf, 2u);
  }

  *a3 = 0;
  a3[1] = 0;
}

void sub_101654654(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32)
{
  sub_1001DCA14(&a13);
  sub_100004A34(v32);
  _Unwind_Resume(a1);
}

uint64_t sub_1016547C8(uint64_t a1)
{
  sub_10135E90C(a1 + 24);
  v2 = *(a1 + 16);
  *(a1 + 16) = 0;

  v3 = *(a1 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  return a1;
}

void stewie::ConnectionAssistantAlertInterface::create(Registry **a1@<X0>, void *a2@<X8>)
{
  ServiceMap = Registry::getServiceMap(*a1);
  v5 = ServiceMap;
  if (v6 < 0)
  {
    v7 = (v6 & 0x7FFFFFFFFFFFFFFFLL);
    v8 = 5381;
    do
    {
      v6 = v8;
      v9 = *v7++;
      v8 = (33 * v8) ^ v9;
    }

    while (v9);
  }

  std::mutex::lock(ServiceMap);
  v15.var0 = v6;
  v10 = sub_100009510(&v5[1].__m_.__sig, &v15);
  if (!v10)
  {
    std::mutex::unlock(v5);
    goto LABEL_9;
  }

  v12 = v10[3];
  v11 = v10[4];
  if (!v11)
  {
    std::mutex::unlock(v5);
    if (v12)
    {
      goto LABEL_11;
    }

LABEL_9:
    *a2 = 0;
    a2[1] = 0;
    return;
  }

  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_100004A34(v11);
  if (!v12)
  {
    *a2 = 0;
    a2[1] = 0;
LABEL_16:
    sub_100004A34(v11);
    return;
  }

LABEL_11:
  v13 = 0;
  v14 = 0;
  Registry::getTimerService(&v13, *a1);
  if (v13)
  {
    operator new();
  }

  *a2 = 0;
  a2[1] = 0;
  if (v14)
  {
    sub_100004A34(v14);
  }

  if (v11)
  {
    goto LABEL_16;
  }
}

void sub_101654BB0()
{
  v4 = *(v1 + 72);
  if (v4)
  {
    sub_100004A34(v4);
  }

  v5 = *(v1 + 56);
  if (v5)
  {
    sub_100004A34(v5);
  }

  ctu::OsLogLogger::~OsLogLogger((v1 + 40));
  sub_100320D6C(v3);
  if (v2)
  {
    sub_100004A34(v2);
    if (!v0)
    {
      goto LABEL_7;
    }
  }

  else if (!v0)
  {
    goto LABEL_7;
  }

  sub_100004A34(v0);
LABEL_7:
  operator delete();
}

const void **sub_101654CE4(const void **a1)
{
  sub_100005978(a1 + 4);
  sub_100005978(a1 + 3);
  sub_100005978(a1 + 2);
  sub_100005978(a1 + 1);

  return sub_100005978(a1);
}

void sub_101654D58(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F5D2C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

const void **sub_101654DAC(const void **a1)
{
  sub_100005978(a1 + 7);
  sub_100005978(a1 + 6);
  sub_100005978(a1 + 5);
  sub_100005978(a1 + 4);

  return sub_100005978(a1 + 3);
}

void sub_101654E24(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F5D318;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101654EA0(uint64_t a1)
{
  *a1 = off_101F5D368;
  sub_100020C84();
  v2 = sub_100032AC8(&qword_101FCAFE0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *v6 = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Destroying alert handle", v6, 2u);
  }

  v3 = *(a1 + 56);
  if (v3)
  {
    sub_100004A34(v3);
  }

  sub_100005978((a1 + 40));
  sub_1001DCA14((a1 + 32));
  v4 = *(a1 + 16);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }

  return a1;
}

void sub_101654F64(uint64_t a1)
{
  sub_101654EA0(a1);

  operator delete();
}

void sub_101654FA4(uint64_t a1)
{
  if (*(a1 + 32))
  {
    sub_100020C84();
    v2 = sub_100032AC8(&qword_101FCAFE0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Dismissing notification alert", buf, 2u);
    }

    CFUserNotificationCancel(*(a1 + 32));
  }

  else
  {
    v3 = (a1 + 40);
    if (*(a1 + 40))
    {
      v4 = *(a1 + 16);
      if (v4)
      {
        v5 = std::__shared_weak_count::lock(v4);
        if (v5)
        {
          v6 = *(a1 + 8);
          if (v6)
          {
            sub_100020C84();
            v7 = sub_100032AC8(&qword_101FCAFE0);
            if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
            {
              *buf = 0;
              _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Dismissing notification", buf, 2u);
            }

            sub_10005C7A4(&cf, v3);
            *buf = v6;
            v11 = cf;
            if (cf)
            {
              CFRetain(cf);
            }

            v8 = *(v6 + 16);
            if (v8 && std::__shared_weak_count::lock(v8))
            {
              operator new();
            }

            sub_100013CC4();
          }

          sub_100004A34(v5);
        }
      }
    }
  }
}

uint64_t sub_1016551D8(uint64_t a1, uint64_t a2)
{
  v3 = (a2 + 24);
  v4 = *(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(a1 + 24) = a1;
      (*(**v3 + 24))(*v3, a1);
      return a1;
    }

    *(a1 + 24) = v4;
  }

  else
  {
    v3 = (a1 + 24);
  }

  *v3 = 0;
  return a1;
}

uint64_t sub_101655258(uint64_t a1)
{
  *a1 = off_101F5D3B0;
  sub_10135E90C(a1 + 32);
  v2 = *(a1 + 24);
  *(a1 + 24) = 0;

  v3 = *(a1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  return a1;
}

void sub_1016552BC(uint64_t a1)
{
  *a1 = off_101F5D3B0;
  sub_10135E90C(a1 + 32);
  v2 = *(a1 + 24);
  *(a1 + 24) = 0;

  v3 = *(a1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void sub_1016553D8(_Unwind_Exception *a1)
{
  sub_10031F3F4(v2);
  v4 = v1[2];
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101655400(uint64_t a1, void *a2)
{
  v5 = *(a1 + 8);
  v4 = *(a1 + 16);
  *a2 = off_101F5D3B0;
  a2[1] = v5;
  a2[2] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 16), 1uLL, memory_order_relaxed);
  }

  a2[3] = *(a1 + 24);
  return sub_1016556EC((a2 + 4), a1 + 32);
}

void sub_10165547C(_Unwind_Exception *a1)
{
  sub_10031F3F4(v2);
  v4 = *(v1 + 16);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }

  _Unwind_Resume(a1);
}

void sub_10165549C(uint64_t a1)
{
  sub_10135E90C(a1 + 32);
  v2 = *(a1 + 24);
  *(a1 + 24) = 0;

  v3 = *(a1 + 16);
  if (v3)
  {

    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_1016554FC(uint64_t a1)
{
  sub_10135E90C(a1 + 32);
  v2 = *(a1 + 24);
  *(a1 + 24) = 0;

  v3 = *(a1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete(a1);
}

void sub_101655558(uint64_t a1)
{
  v2 = *(a1 + 16);
  v4[0] = *(a1 + 8);
  v4[1] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }

  sub_1016556EC(&v5, a1 + 32);
  v3 = sub_100032AC8((a1 + 24));
  operator new();
}

void sub_10165566C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016556A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1016556EC(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

uint64_t *sub_101655784(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_10135E90C(v1 + 16);
    v2 = *(v1 + 8);
    if (v2)
    {
      std::__shared_weak_count::__release_weak(v2);
    }

    operator delete();
  }

  return result;
}

uint64_t *sub_1016557E0(uint64_t *a1)
{
  v6 = a1;
  v2 = a1[1];
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      if (*a1)
      {
        sub_101655860(a1[5], *a1, 0);
      }

      sub_100004A34(v4);
    }
  }

  return sub_101655784(&v6);
}

void sub_101655844(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100004A34(v2);
  sub_101655784(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101655860(uint64_t a1, uint64_t a2, char a3)
{
  v5 = a2;
  v4 = a3;
  if (!a1)
  {
    sub_100022DB4();
  }

  return (*(*a1 + 48))(a1, &v5, &v4);
}

uint64_t *sub_1016558B8(id **a1)
{
  [**a1 postNotification:{(*a1)[3], a1, *a1}];
  sub_10165591C(&v3);
  return sub_1000049E0(&v2);
}

void sub_101655900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10165591C(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10165591C(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    v2 = *(v1 + 32);
    if (v2)
    {
      sub_100004A34(v2);
    }

    v3 = *(v1 + 16);
    if (v3)
    {
      sub_100004A34(v3);
    }

    operator delete();
  }

  return result;
}

void sub_101655984(id **a1)
{
  v1 = *a1;
  v6 = a1;
  v7 = v1;
  responseFlags = 0;
  v2 = CFUserNotificationReceiveResponse(*(*v1 + 4), 7.0, &responseFlags);
  sub_100020C84();
  v3 = sub_100032AC8(&qword_101FCAFE0);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 67109376;
    HIDWORD(buf) = v2;
    *buf_8 = 2048;
    *&buf_8[2] = responseFlags;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Notification response received: %d, responseFlags = %ld", &buf, 0x12u);
  }

  v4 = v1[1];
  buf = *v1;
  *buf_8 = v4;
  if (v4)
  {
    atomic_fetch_add_explicit(v4 + 1, 1uLL, memory_order_relaxed);
  }

  *&buf_8[8] = responseFlags;
  v11 = v2;
  sub_1016556EC(&v12, (v1 + 3));
  v5 = sub_100032AC8(v1 + 2);
  operator new();
}

void sub_101655B54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t *sub_101655BA0(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_10135E90C(v1 + 24);
    v2 = *(v1 + 16);
    *(v1 + 16) = 0;

    v3 = *(v1 + 8);
    if (v3)
    {
      sub_100004A34(v3);
    }

    operator delete();
  }

  return result;
}

uint64_t *sub_101655C10(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_10135E90C(v1 + 32);
    v2 = *(v1 + 8);
    if (v2)
    {
      sub_100004A34(v2);
    }

    operator delete();
  }

  return result;
}

uint64_t *sub_101655C6C(uint64_t a1)
{
  v3 = a1;
  if (*(a1 + 24))
  {
    v1 = 0;
  }

  else
  {
    v1 = *(a1 + 16) == 0;
  }

  sub_101655860(*(a1 + 56), *a1, v1);
  return sub_101655C10(&v3);
}

void sub_101655CC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_101655C10(va);
  _Unwind_Resume(a1);
}

uint64_t *sub_101655CD8(void *a1)
{
  [*(**a1 + 80) dismissNotification:{*(*a1 + 8), a1, *a1}];
  sub_101655D3C(&v3);
  return sub_1000049E0(&v2);
}

void sub_101655D20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_101655D3C(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101655D3C(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100005978((v1 + 8));
    operator delete();
  }

  return result;
}

void sub_101655D90(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101655DC8(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t sub_101655DF8(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

void *sub_101655E38(void *a1, uint64_t a2, NSObject **a3, uint64_t a4, char *a5)
{
  ctu::OsLogContext::OsLogContext(&v12, kCtLoggingSystemName, a5);
  sub_101655F2C(a1 + 1, a3, &v12);
  ctu::OsLogContext::~OsLogContext(&v12);
  *a1 = &off_101F5D4A8;
  v9 = *a2;
  v10 = *(a2 + 8);
  a1[6] = *a2;
  a1[7] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit((v10 + 8), 1uLL, memory_order_relaxed);
    v9 = a1[6];
  }

  Registry::getMobileHelper(a1 + 8, v9);
  a1[10] = 0;
  a1[11] = a4;
  return a1;
}

void sub_101655EEC(_Unwind_Exception *a1)
{
  v3 = v1[7];
  if (v3)
  {
    sub_100004A34(v3);
  }

  SuppServicesPreferencesInterface::~SuppServicesPreferencesInterface(v1);
  ctu::OsLogLogger::~OsLogLogger((v1 + 5));
  sub_1000C0544(v1 + 1);
  _Unwind_Resume(a1);
}

void *sub_101655F2C(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  v5 = *a2;
  a1[2] = *a2;
  if (v5)
  {
    dispatch_retain(v5);
  }

  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger(v7, a3);
  ctu::OsLogLogger::OsLogLogger((a1 + 4), v7);
  ctu::OsLogLogger::~OsLogLogger(v7);
  return a1;
}

void sub_101655F94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger(va);
  sub_1000C0544(v2);
  _Unwind_Resume(a1);
}

SuppServicesPreferencesInterface *sub_101655FB8(SuppServicesPreferencesInterface *this)
{
  *this = &off_101F5D4A8;
  v2 = *(this + 10);
  *(this + 10) = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  v3 = *(this + 9);
  if (v3)
  {
    sub_100004A34(v3);
  }

  v4 = *(this + 7);
  if (v4)
  {
    sub_100004A34(v4);
  }

  SuppServicesPreferencesInterface::~SuppServicesPreferencesInterface(this);
  ctu::OsLogLogger::~OsLogLogger((this + 40));
  sub_1000C0544(this + 1);
  return this;
}

unint64_t sub_101656064@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if ((a2 - 1) > 1)
  {
    v5 = 0;
  }

  else
  {
    v5 = kSuppServicesCLIRStatusKeys[subscriber::simSlotAsInstance()];
  }

  result = sub_101656118(a1 + 64, v5);
  if (HIDWORD(result))
  {
    operator new();
  }

  *a3 = 0;
  a3[1] = 0;
  return result;
}

unint64_t sub_101656118(uint64_t a1, uint64_t a2)
{
  cf = 0;
  if (!a2)
  {
    LODWORD(v2) = 0;
    v5 = 0;
    v6 = 0;
    cf = 0;
    goto LABEL_9;
  }

  (*(**a1 + 16))(&cf);
  v2 = cf;
  if (!cf)
  {
LABEL_8:
    v5 = 0;
    v6 = 0;
    goto LABEL_9;
  }

  v8 = 0;
  v3 = CFGetTypeID(cf);
  if (v3 != CFNumberGetTypeID() || (ctu::cf::assign(&v8, v2, v4) & 1) == 0)
  {
    LODWORD(v2) = 0;
    goto LABEL_8;
  }

  LODWORD(v2) = v8 & 0xFFFFFF00;
  v5 = v8;
  v6 = &_mh_execute_header;
LABEL_9:
  sub_10000A1EC(&cf);
  return v6 | v5 | v2;
}

void sub_101656200(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10000A1EC(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101656214(uint64_t a1, int a2, unsigned __int8 **a3)
{
  v4 = **a3;
  v5 = (*a3)[1];
  if ((a2 - 1) > 1)
  {
    v6 = 0;
  }

  else
  {
    v6 = kSuppServicesCLIRStatusKeys[subscriber::simSlotAsInstance()];
  }

  return sub_101656288((a1 + 64), v6, v5 | (v4 << 16));
}

uint64_t sub_101656288(void *a1, uint64_t a2, unsigned int a3)
{
  v10 = 0;
  valuePtr = a3;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v5)
  {
    v10 = v5;
    valuePtr = 0;
    sub_100029A48(&valuePtr);
    v6 = v10;
  }

  else
  {
    v6 = 0;
  }

  v9 = v6;
  v10 = 0;
  sub_100029A48(&v10);
  v7 = 0;
  if (a2 && v6)
  {
    v7 = (*(**a1 + 24))(*a1, kCommCenterSharedSettingsBundleId, a2, v6);
  }

  sub_100029A48(&v9);
  return v7;
}

void sub_101656360(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100029A48(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101656380(uint64_t a1, int a2)
{
  if ((a2 - 1) > 1 || !kSuppServicesCLIRStatusKeys[subscriber::simSlotAsInstance()])
  {
    return 0;
  }

  v3 = *(**(a1 + 64) + 24);

  return v3();
}

const void **sub_101656418@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  theDict = 0;
  if ((a2 - 1) <= 1 && kSuppServicesCLIRNetworkStatusKeys[subscriber::simSlotAsInstance()])
  {
    (*(**(a1 + 64) + 16))(&v15);
  }

  else
  {
    v15 = 0;
  }

  sub_100010180(&theDict, &v15);
  sub_10000A1EC(&v15);
  if (theDict)
  {
    Value = CFDictionaryGetValue(theDict, kServiceStatusKey);
    v6 = Value;
    LODWORD(v15) = 0;
    if (Value)
    {
      v7 = CFGetTypeID(Value);
      if (v7 == CFNumberGetTypeID())
      {
        ctu::cf::assign(&v15, v6, v8);
      }
    }

    v9 = CFDictionaryGetValue(theDict, kProvisionStatusKey);
    v10 = v9;
    LODWORD(v15) = 0;
    if (v9)
    {
      v11 = CFGetTypeID(v9);
      if (v11 == CFNumberGetTypeID())
      {
        ctu::cf::assign(&v15, v10, v12);
      }
    }

    *a3 = 0;
    a3[1] = 0;
    operator new();
  }

  *a3 = 0;
  a3[1] = 0;
  return sub_10001021C(&theDict);
}

uint64_t sub_1016566C0(uint64_t a1, int a2, unsigned __int8 **a3)
{
  v7 = *a3;
  v6 = a3[1];
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v29 = Mutable;
  v9 = *v7;
  __p[0] = 0;
  *&valuePtr = v9;
  v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  v11 = kServiceStatusKey;
  if (v10)
  {
    __p[0] = v10;
    *&valuePtr = 0;
    sub_100029A48(&valuePtr);
    v12 = __p[0];
  }

  else
  {
    v12 = 0;
  }

  v36 = v12;
  __p[0] = 0;
  sub_100029A48(__p);
  CFDictionarySetValue(Mutable, v11, v12);
  sub_100029A48(&v36);
  v13 = v7[1];
  __p[0] = 0;
  *&valuePtr = v13;
  v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  v15 = kProvisionStatusKey;
  if (v14)
  {
    __p[0] = v14;
    *&valuePtr = 0;
    sub_100029A48(&valuePtr);
    v16 = __p[0];
  }

  else
  {
    v16 = 0;
  }

  v36 = v16;
  __p[0] = 0;
  sub_100029A48(__p);
  CFDictionarySetValue(Mutable, v15, v16);
  sub_100029A48(&v36);
  if (v6)
  {
    sub_100004A34(v6);
  }

  v17 = v29;
  v18 = *a3;
  if ((*a3)[31] < 0)
  {
    sub_100005F2C(v26, *(v18 + 1), *(v18 + 2));
  }

  else
  {
    v19 = *(v18 + 8);
    v27 = *(v18 + 3);
    *v26 = v19;
  }

  if (SHIBYTE(v27) < 0)
  {
    sub_100005F2C(__p, v26[0], v26[1]);
  }

  else
  {
    *__p = *v26;
    v32 = v27;
  }

  v30 = 0;
  if (SHIBYTE(v32) < 0)
  {
    sub_100005F2C(&valuePtr, __p[0], __p[1]);
  }

  else
  {
    valuePtr = *__p;
    v34 = v32;
  }

  v35 = 0;
  if (ctu::cf::convert_copy())
  {
    v20 = v30;
    v30 = v35;
    v36 = v20;
    sub_100005978(&v36);
  }

  v21 = kOperatorBundleIDKey;
  if (SHIBYTE(v34) < 0)
  {
    operator delete(valuePtr);
  }

  v22 = v30;
  v28 = v30;
  v30 = 0;
  sub_100005978(&v30);
  if (SHIBYTE(v32) < 0)
  {
    operator delete(__p[0]);
  }

  CFDictionarySetValue(v17, v21, v22);
  sub_100005978(&v28);
  if (SHIBYTE(v27) < 0)
  {
    operator delete(v26[0]);
  }

  if ((a2 - 1) <= 1 && (v23 = kSuppServicesCLIRNetworkStatusKeys[subscriber::simSlotAsInstance()]) != 0)
  {
    v24 = (*(**(a1 + 64) + 24))(*(a1 + 64), kCommCenterSharedSettingsBundleId, v23, v29);
  }

  else
  {
    v24 = 0;
  }

  sub_1000296E0(&v29);
  return v24;
}

void sub_1016569DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, const void *a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, void *a26, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
  sub_100005978(&a18);
  if (a24 < 0)
  {
    operator delete(__p);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  sub_1000296E0(&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_101656A94(uint64_t a1, int a2)
{
  if ((a2 - 1) > 1 || !kSuppServicesCLIRNetworkStatusKeys[subscriber::simSlotAsInstance()])
  {
    return 0;
  }

  v3 = *(**(a1 + 64) + 24);

  return v3();
}

uint64_t sub_101656B2C(uint64_t a1, int a2)
{
  if ((a2 - 1) > 1)
  {
    v3 = 0;
  }

  else
  {
    v3 = kSuppServicesCallWaitingStatusKeys[subscriber::simSlotAsInstance()];
  }

  return sub_101656B88(a1 + 64, v3);
}

uint64_t sub_101656B88(uint64_t a1, uint64_t a2)
{
  cf = 0;
  if (!a2)
  {
    LODWORD(v2) = 0;
    v5 = 0;
    cf = 0;
    goto LABEL_10;
  }

  (*(**a1 + 16))(&cf);
  v2 = cf;
  if (!cf)
  {
LABEL_9:
    v5 = 0;
    goto LABEL_10;
  }

  v7 = 0;
  v3 = CFGetTypeID(cf);
  if (v3 != CFBooleanGetTypeID())
  {
    LODWORD(v2) = 0;
    goto LABEL_9;
  }

  LODWORD(v2) = ctu::cf::assign(&v7, v2, v4);
  if (v2)
  {
    v5 = v7;
  }

  else
  {
    v5 = 0;
  }

LABEL_10:
  sub_10000A1EC(&cf);
  return v5 | (v2 << 8);
}

void sub_101656C5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10000A1EC(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101656C70(uint64_t a1, int a2, int a3)
{
  if ((a2 - 1) > 1)
  {
    v5 = 0;
  }

  else
  {
    v5 = kSuppServicesCallWaitingStatusKeys[subscriber::simSlotAsInstance()];
  }

  return sub_101656CD4((a1 + 64), v5, a3);
}

uint64_t sub_101656CD4(void *a1, uint64_t a2, int a3)
{
  v5 = &kCFBooleanTrue;
  if (!a3)
  {
    v5 = &kCFBooleanFalse;
  }

  v6 = *v5;
  v10 = 0;
  sub_100045C8C(&v10);
  v9 = v6;
  v10 = 0;
  sub_100045C8C(&v10);
  v7 = 0;
  if (a2 && v6)
  {
    v7 = (*(**a1 + 24))(*a1, kCommCenterSharedSettingsBundleId, a2, v6);
  }

  sub_100045C8C(&v9);
  return v7;
}

uint64_t sub_101656DA8(uint64_t a1, int a2)
{
  if ((a2 - 1) > 1 || !kSuppServicesCallWaitingStatusKeys[subscriber::simSlotAsInstance()])
  {
    return 0;
  }

  v3 = *(**(a1 + 64) + 24);

  return v3();
}

uint64_t sub_101656E40(uint64_t a1, int a2)
{
  if ((a2 - 1) > 1)
  {
    v3 = 0;
  }

  else
  {
    v3 = kSuppServicesAutoAnswerStatusKeys[subscriber::simSlotAsInstance()];
  }

  return sub_101656B88(a1 + 64, v3);
}

uint64_t sub_101656E9C(uint64_t a1, int a2, int a3)
{
  if ((a2 - 1) > 1)
  {
    v5 = 0;
  }

  else
  {
    v5 = kSuppServicesAutoAnswerStatusKeys[subscriber::simSlotAsInstance()];
  }

  return sub_101656CD4((a1 + 64), v5, a3);
}

uint64_t sub_101656F00(uint64_t a1, int a2)
{
  if ((a2 - 1) > 1 || !kSuppServicesAutoAnswerStatusKeys[subscriber::simSlotAsInstance()])
  {
    return 0;
  }

  v3 = *(**(a1 + 64) + 24);

  return v3();
}

uint64_t sub_101656F98(uint64_t a1)
{
  v2 = subscriber::simSlotAsInstance();
  v3 = kUserDefaultVoiceSlotKey;

  return sub_101656288((a1 + 64), v3, v2);
}

unint64_t sub_101656FE4(uint64_t a1)
{
  v1 = sub_101656118(a1 + 64, kUserDefaultVoiceSlotKey);
  if (HIDWORD(v1))
  {
    return subscriber::instanceAsSimSlot(v1, v2) | &_mh_execute_header;
  }

  else
  {
    return 0;
  }
}

void sub_10165709C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void *sub_1016570B4(void *a1)
{
  *a1 = off_101F5D610;
  v2 = a1[2];
  if (v2)
  {
    sub_100004A34(v2);
  }

  return a1;
}

void sub_101657100(void *a1)
{
  *a1 = off_101F5D610;
  v1 = a1[2];
  if (v1)
  {
    sub_100004A34(v1);
  }

  operator delete();
}

void sub_101657224(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F5D650;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1016572C0(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F5D6A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10165733C(int a1@<W0>, void *a2@<X8>)
{
  v3 = a1 != 1;
  if (a1 == 1)
  {
    v4 = "";
  }

  else
  {
    v4 = "_2";
  }

  *a2 = 0;
  sub_10000501C(&v10, "kOperatorRoamingInfo_3GPP_NetworkMcc");
  v5 = std::string::append(&v10, v4, 2 * v3);
  v7 = v5->__r_.__value_.__r.__words[0];
  size = v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(v11 + 3) = *(&v5->__r_.__value_.__r.__words[2] + 3);
  v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(&v14 + 3) = *(v11 + 3);
    HIBYTE(v14) = v8;
    v12 = 0;
LABEL_7:
    *__p = *__dst;
    v16 = v14;
    goto LABEL_8;
  }

  sub_100005F2C(__dst, v7, size);
  v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  sub_100005F2C(__p, __dst[0], __dst[1]);
LABEL_8:
  v17 = 0;
  if (ctu::cf::convert_copy())
  {
    v9 = v12;
    v12 = v17;
    v18 = v9;
    sub_100005978(&v18);
  }

  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  *a2 = v12;
  v12 = 0;
  sub_100005978(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1016574C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100005978(&a16);
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (v29 < 0)
  {
    operator delete(v28);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_101657528(int a1@<W0>, void *a2@<X8>)
{
  v3 = a1 != 1;
  if (a1 == 1)
  {
    v4 = "";
  }

  else
  {
    v4 = "_2";
  }

  *a2 = 0;
  sub_10000501C(&v10, "kOperatorRoamingInfo_3GPP_NetworkMnc");
  v5 = std::string::append(&v10, v4, 2 * v3);
  v7 = v5->__r_.__value_.__r.__words[0];
  size = v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(v11 + 3) = *(&v5->__r_.__value_.__r.__words[2] + 3);
  v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(&v14 + 3) = *(v11 + 3);
    HIBYTE(v14) = v8;
    v12 = 0;
LABEL_7:
    *__p = *__dst;
    v16 = v14;
    goto LABEL_8;
  }

  sub_100005F2C(__dst, v7, size);
  v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  sub_100005F2C(__p, __dst[0], __dst[1]);
LABEL_8:
  v17 = 0;
  if (ctu::cf::convert_copy())
  {
    v9 = v12;
    v12 = v17;
    v18 = v9;
    sub_100005978(&v18);
  }

  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  *a2 = v12;
  v12 = 0;
  sub_100005978(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1016576AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100005978(&a16);
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (v29 < 0)
  {
    operator delete(v28);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_101657714(int a1@<W0>, void *a2@<X8>)
{
  v3 = a1 != 1;
  if (a1 == 1)
  {
    v4 = "";
  }

  else
  {
    v4 = "_2";
  }

  *a2 = 0;
  sub_10000501C(&v10, "kOperatorRoamingInfo_3GPP_CurrentOperatorBundleId");
  v5 = std::string::append(&v10, v4, 2 * v3);
  v7 = v5->__r_.__value_.__r.__words[0];
  size = v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(v11 + 3) = *(&v5->__r_.__value_.__r.__words[2] + 3);
  v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(&v14 + 3) = *(v11 + 3);
    HIBYTE(v14) = v8;
    v12 = 0;
LABEL_7:
    *__p = *__dst;
    v16 = v14;
    goto LABEL_8;
  }

  sub_100005F2C(__dst, v7, size);
  v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  sub_100005F2C(__p, __dst[0], __dst[1]);
LABEL_8:
  v17 = 0;
  if (ctu::cf::convert_copy())
  {
    v9 = v12;
    v12 = v17;
    v18 = v9;
    sub_100005978(&v18);
  }

  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  *a2 = v12;
  v12 = 0;
  sub_100005978(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_101657898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100005978(&a16);
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (v29 < 0)
  {
    operator delete(v28);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_101657900(int a1@<W0>, void *a2@<X8>)
{
  v3 = a1 != 1;
  if (a1 == 1)
  {
    v4 = "";
  }

  else
  {
    v4 = "_2";
  }

  *a2 = 0;
  sub_10000501C(&v10, "kOperatorRoamingInfo_3GPP_Roaming");
  v5 = std::string::append(&v10, v4, 2 * v3);
  v7 = v5->__r_.__value_.__r.__words[0];
  size = v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(v11 + 3) = *(&v5->__r_.__value_.__r.__words[2] + 3);
  v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(&v14 + 3) = *(v11 + 3);
    HIBYTE(v14) = v8;
    v12 = 0;
LABEL_7:
    *__p = *__dst;
    v16 = v14;
    goto LABEL_8;
  }

  sub_100005F2C(__dst, v7, size);
  v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  sub_100005F2C(__p, __dst[0], __dst[1]);
LABEL_8:
  v17 = 0;
  if (ctu::cf::convert_copy())
  {
    v9 = v12;
    v12 = v17;
    v18 = v9;
    sub_100005978(&v18);
  }

  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  *a2 = v12;
  v12 = 0;
  sub_100005978(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_101657A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100005978(&a16);
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (v29 < 0)
  {
    operator delete(v28);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_101657AEC(int a1@<W0>, void *a2@<X8>)
{
  v3 = a1 != 1;
  if (a1 == 1)
  {
    v4 = "";
  }

  else
  {
    v4 = "_2";
  }

  *a2 = 0;
  sub_10000501C(&v10, "kOperatorRoamingInfo_3GPP_RAT");
  v5 = std::string::append(&v10, v4, 2 * v3);
  v7 = v5->__r_.__value_.__r.__words[0];
  size = v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(v11 + 3) = *(&v5->__r_.__value_.__r.__words[2] + 3);
  v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(&v14 + 3) = *(v11 + 3);
    HIBYTE(v14) = v8;
    v12 = 0;
LABEL_7:
    *__p = *__dst;
    v16 = v14;
    goto LABEL_8;
  }

  sub_100005F2C(__dst, v7, size);
  v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  sub_100005F2C(__p, __dst[0], __dst[1]);
LABEL_8:
  v17 = 0;
  if (ctu::cf::convert_copy())
  {
    v9 = v12;
    v12 = v17;
    v18 = v9;
    sub_100005978(&v18);
  }

  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  *a2 = v12;
  v12 = 0;
  sub_100005978(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_101657C70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100005978(&a16);
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (v29 < 0)
  {
    operator delete(v28);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_101657CD8(int a1@<W0>, void *a2@<X8>)
{
  v3 = a1 != 1;
  if (a1 == 1)
  {
    v4 = "";
  }

  else
  {
    v4 = "_2";
  }

  *a2 = 0;
  sub_10000501C(&v10, "kOperatorRoamingInfo_3GPP_2_NetworkIso");
  v5 = std::string::append(&v10, v4, 2 * v3);
  v7 = v5->__r_.__value_.__r.__words[0];
  size = v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(v11 + 3) = *(&v5->__r_.__value_.__r.__words[2] + 3);
  v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(&v14 + 3) = *(v11 + 3);
    HIBYTE(v14) = v8;
    v12 = 0;
LABEL_7:
    *__p = *__dst;
    v16 = v14;
    goto LABEL_8;
  }

  sub_100005F2C(__dst, v7, size);
  v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  sub_100005F2C(__p, __dst[0], __dst[1]);
LABEL_8:
  v17 = 0;
  if (ctu::cf::convert_copy())
  {
    v9 = v12;
    v12 = v17;
    v18 = v9;
    sub_100005978(&v18);
  }

  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  *a2 = v12;
  v12 = 0;
  sub_100005978(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_101657E5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100005978(&a16);
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (v29 < 0)
  {
    operator delete(v28);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_101657EC4(int a1@<W0>, void *a2@<X8>)
{
  v3 = a1 != 1;
  if (a1 == 1)
  {
    v4 = "";
  }

  else
  {
    v4 = "_2";
  }

  *a2 = 0;
  sub_10000501C(&v10, "kOperatorRoamingInfo_3GPP_2_Sid");
  v5 = std::string::append(&v10, v4, 2 * v3);
  v7 = v5->__r_.__value_.__r.__words[0];
  size = v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(v11 + 3) = *(&v5->__r_.__value_.__r.__words[2] + 3);
  v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(&v14 + 3) = *(v11 + 3);
    HIBYTE(v14) = v8;
    v12 = 0;
LABEL_7:
    *__p = *__dst;
    v16 = v14;
    goto LABEL_8;
  }

  sub_100005F2C(__dst, v7, size);
  v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  sub_100005F2C(__p, __dst[0], __dst[1]);
LABEL_8:
  v17 = 0;
  if (ctu::cf::convert_copy())
  {
    v9 = v12;
    v12 = v17;
    v18 = v9;
    sub_100005978(&v18);
  }

  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  *a2 = v12;
  v12 = 0;
  sub_100005978(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_101658048(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100005978(&a16);
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (v29 < 0)
  {
    operator delete(v28);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_1016580B0(int a1@<W0>, void *a2@<X8>)
{
  v3 = a1 != 1;
  if (a1 == 1)
  {
    v4 = "";
  }

  else
  {
    v4 = "_2";
  }

  *a2 = 0;
  sub_10000501C(&v10, "kOperatorRoamingInfo_3GPP_2_Nid");
  v5 = std::string::append(&v10, v4, 2 * v3);
  v7 = v5->__r_.__value_.__r.__words[0];
  size = v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(v11 + 3) = *(&v5->__r_.__value_.__r.__words[2] + 3);
  v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(&v14 + 3) = *(v11 + 3);
    HIBYTE(v14) = v8;
    v12 = 0;
LABEL_7:
    *__p = *__dst;
    v16 = v14;
    goto LABEL_8;
  }

  sub_100005F2C(__dst, v7, size);
  v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  sub_100005F2C(__p, __dst[0], __dst[1]);
LABEL_8:
  v17 = 0;
  if (ctu::cf::convert_copy())
  {
    v9 = v12;
    v12 = v17;
    v18 = v9;
    sub_100005978(&v18);
  }

  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  *a2 = v12;
  v12 = 0;
  sub_100005978(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_101658234(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100005978(&a16);
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (v29 < 0)
  {
    operator delete(v28);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_10165829C(int a1@<W0>, void *a2@<X8>)
{
  v3 = a1 != 1;
  if (a1 == 1)
  {
    v4 = "";
  }

  else
  {
    v4 = "_2";
  }

  *a2 = 0;
  sub_10000501C(&v10, "kOperatorRoamingInfo_3GPP_2_Roaming");
  v5 = std::string::append(&v10, v4, 2 * v3);
  v7 = v5->__r_.__value_.__r.__words[0];
  size = v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(v11 + 3) = *(&v5->__r_.__value_.__r.__words[2] + 3);
  v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(&v14 + 3) = *(v11 + 3);
    HIBYTE(v14) = v8;
    v12 = 0;
LABEL_7:
    *__p = *__dst;
    v16 = v14;
    goto LABEL_8;
  }

  sub_100005F2C(__dst, v7, size);
  v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  sub_100005F2C(__p, __dst[0], __dst[1]);
LABEL_8:
  v17 = 0;
  if (ctu::cf::convert_copy())
  {
    v9 = v12;
    v12 = v17;
    v18 = v9;
    sub_100005978(&v18);
  }

  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  *a2 = v12;
  v12 = 0;
  sub_100005978(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_101658420(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100005978(&a16);
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (v29 < 0)
  {
    operator delete(v28);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_101658488(int a1@<W0>, void *a2@<X8>)
{
  v3 = a1 != 1;
  if (a1 == 1)
  {
    v4 = "";
  }

  else
  {
    v4 = "_2";
  }

  *a2 = 0;
  sub_10000501C(&v10, "kOperatorRoamingInfo_3GPP_2_RAT");
  v5 = std::string::append(&v10, v4, 2 * v3);
  v7 = v5->__r_.__value_.__r.__words[0];
  size = v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(v11 + 3) = *(&v5->__r_.__value_.__r.__words[2] + 3);
  v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(&v14 + 3) = *(v11 + 3);
    HIBYTE(v14) = v8;
    v12 = 0;
LABEL_7:
    *__p = *__dst;
    v16 = v14;
    goto LABEL_8;
  }

  sub_100005F2C(__dst, v7, size);
  v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  sub_100005F2C(__p, __dst[0], __dst[1]);
LABEL_8:
  v17 = 0;
  if (ctu::cf::convert_copy())
  {
    v9 = v12;
    v12 = v17;
    v18 = v9;
    sub_100005978(&v18);
  }

  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  *a2 = v12;
  v12 = 0;
  sub_100005978(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_10165860C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100005978(&a16);
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (v29 < 0)
  {
    operator delete(v28);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_101658674(int a1@<W0>, void *a2@<X8>)
{
  v3 = a1 != 1;
  if (a1 == 1)
  {
    v4 = "";
  }

  else
  {
    v4 = "_2";
  }

  *a2 = 0;
  sub_10000501C(&v10, "kOperatorRoamingInfo_Subscriber_Mcc");
  v5 = std::string::append(&v10, v4, 2 * v3);
  v7 = v5->__r_.__value_.__r.__words[0];
  size = v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(v11 + 3) = *(&v5->__r_.__value_.__r.__words[2] + 3);
  v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(&v14 + 3) = *(v11 + 3);
    HIBYTE(v14) = v8;
    v12 = 0;
LABEL_7:
    *__p = *__dst;
    v16 = v14;
    goto LABEL_8;
  }

  sub_100005F2C(__dst, v7, size);
  v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  sub_100005F2C(__p, __dst[0], __dst[1]);
LABEL_8:
  v17 = 0;
  if (ctu::cf::convert_copy())
  {
    v9 = v12;
    v12 = v17;
    v18 = v9;
    sub_100005978(&v18);
  }

  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  *a2 = v12;
  v12 = 0;
  sub_100005978(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1016587F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100005978(&a16);
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (v29 < 0)
  {
    operator delete(v28);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_101658860(int a1@<W0>, void *a2@<X8>)
{
  v3 = a1 != 1;
  if (a1 == 1)
  {
    v4 = "";
  }

  else
  {
    v4 = "_2";
  }

  *a2 = 0;
  sub_10000501C(&v10, "kOperatorRoamingInfo_Subscriber_Mnc");
  v5 = std::string::append(&v10, v4, 2 * v3);
  v7 = v5->__r_.__value_.__r.__words[0];
  size = v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(v11 + 3) = *(&v5->__r_.__value_.__r.__words[2] + 3);
  v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(&v14 + 3) = *(v11 + 3);
    HIBYTE(v14) = v8;
    v12 = 0;
LABEL_7:
    *__p = *__dst;
    v16 = v14;
    goto LABEL_8;
  }

  sub_100005F2C(__dst, v7, size);
  v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  sub_100005F2C(__p, __dst[0], __dst[1]);
LABEL_8:
  v17 = 0;
  if (ctu::cf::convert_copy())
  {
    v9 = v12;
    v12 = v17;
    v18 = v9;
    sub_100005978(&v18);
  }

  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  *a2 = v12;
  v12 = 0;
  sub_100005978(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1016589E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100005978(&a16);
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (v29 < 0)
  {
    operator delete(v28);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_101658A4C(int a1@<W0>, void *a2@<X8>)
{
  v3 = a1 != 1;
  if (a1 == 1)
  {
    v4 = "";
  }

  else
  {
    v4 = "_2";
  }

  *a2 = 0;
  sub_10000501C(&v10, "kOperatorRoamingInfo_Subscriber_CarrierBundleID");
  v5 = std::string::append(&v10, v4, 2 * v3);
  v7 = v5->__r_.__value_.__r.__words[0];
  size = v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(v11 + 3) = *(&v5->__r_.__value_.__r.__words[2] + 3);
  v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(&v14 + 3) = *(v11 + 3);
    HIBYTE(v14) = v8;
    v12 = 0;
LABEL_7:
    *__p = *__dst;
    v16 = v14;
    goto LABEL_8;
  }

  sub_100005F2C(__dst, v7, size);
  v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  sub_100005F2C(__p, __dst[0], __dst[1]);
LABEL_8:
  v17 = 0;
  if (ctu::cf::convert_copy())
  {
    v9 = v12;
    v12 = v17;
    v18 = v9;
    sub_100005978(&v18);
  }

  if (SHIBYTE(v16) < 0)
  {
    operator delete(__p[0]);
  }

  *a2 = v12;
  v12 = 0;
  sub_100005978(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_14;
    }
  }

  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }

  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_101658BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100005978(&a16);
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (v29 < 0)
  {
    operator delete(v28);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  _Unwind_Resume(a1);
}

void sub_101658F5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0)
  {
    sub_100004A34(v16);
  }

  _Unwind_Resume(a1);
}

void sub_101659340(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0)
  {
    sub_100004A34(v16);
  }

  _Unwind_Resume(a1);
}

void sub_101659648(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0)
  {
    sub_100004A34(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1016599D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t a11, char a12, uint64_t a13, dispatch_object_t object, char a15, uint64_t a16)
{
  if ((v20 & 1) == 0)
  {
    sub_100004A34(v18);
  }

  _Unwind_Resume(a1);
}

void sub_101659DB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0)
  {
    sub_100004A34(v16);
  }

  _Unwind_Resume(a1);
}

void sub_10165A19C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t a11, char a12, uint64_t a13, dispatch_object_t object, char a15, uint64_t a16)
{
  if ((v20 & 1) == 0)
  {
    sub_100004A34(v18);
  }

  _Unwind_Resume(a1);
}

void sub_10165A578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0)
  {
    sub_100004A34(v16);
  }

  _Unwind_Resume(a1);
}

void sub_10165A964(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t a11, char a12, uint64_t a13, dispatch_object_t object, char a15, uint64_t a16)
{
  if ((v20 & 1) == 0)
  {
    sub_100004A34(v18);
  }

  _Unwind_Resume(a1);
}

void sub_10165AD40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0)
  {
    sub_100004A34(v16);
  }

  _Unwind_Resume(a1);
}

void sub_10165B11C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0)
  {
    sub_100004A34(v16);
  }

  _Unwind_Resume(a1);
}

void sub_10165B500(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0)
  {
    sub_100004A34(v16);
  }

  _Unwind_Resume(a1);
}

void sub_10165BA3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, dispatch_object_t object, char a31, uint64_t a32)
{
  sub_100D1A460(&a31);
  if ((v35 & 1) == 0)
  {
    sub_100004A34(v34);
  }

  _Unwind_Resume(a1);
}

void sub_10165BB60(uint64_t a1)
{

  operator delete();
}

id sub_10165BC14(uint64_t a1, void *a2)
{
  *a2 = off_101F5D6F0;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10165BC64(id *a1)
{

  operator delete(a1);
}

void sub_10165BCA0(uint64_t a1, uint64_t a2)
{
  v4 = *a2;
  v3 = *(a2 + 8);
  *a2 = 0;
  *(a2 + 8) = 0;
  v5 = sub_101735308(*(a2 + 16));
  if (v5)
  {
    v6 = 0;
  }

  else
  {
    v6 = sub_101735378(*v4);
  }

  (*(*(a1 + 8) + 16))();

  if (v3)
  {

    sub_100004A34(v3);
  }
}

void sub_10165BD48(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10165BD70(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F5D750))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10165BDE8(uint64_t a1)
{

  operator delete();
}

id sub_10165BE9C(uint64_t a1, void *a2)
{
  *a2 = off_101F5D770;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10165BEEC(id *a1)
{

  operator delete(a1);
}

void sub_10165BF28(uint64_t a1, uint64_t a2)
{
  v4 = *a2;
  v3 = *(a2 + 8);
  *a2 = 0;
  *(a2 + 8) = 0;
  v5 = sub_101735308(*(a2 + 16));
  if (v5)
  {
    v6 = 0;
  }

  else
  {
    v6 = sub_101735444(*v4);
  }

  (*(*(a1 + 8) + 16))();

  if (v3)
  {

    sub_100004A34(v3);
  }
}

void sub_10165BFD0(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10165BFF8(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F5D7D0))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10165C070(uint64_t a1)
{

  operator delete();
}

id sub_10165C124(uint64_t a1, void *a2)
{
  *a2 = off_101F5D7F0;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10165C174(id *a1)
{

  operator delete(a1);
}

void sub_10165C1B0(uint64_t a1, uint64_t a2)
{
  v4 = *a2;
  v3 = *(a2 + 8);
  *a2 = 0;
  *(a2 + 8) = 0;
  v5 = sub_101735308(*(a2 + 16));
  if (v5)
  {
    v6 = 0;
  }

  else
  {
    v6 = sub_101735514(*v4);
  }

  (*(*(a1 + 8) + 16))();

  if (v3)
  {

    sub_100004A34(v3);
  }
}

void sub_10165C258(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10165C280(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F5D850))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10165C2F8(uint64_t a1)
{

  operator delete();
}

id sub_10165C3AC(uint64_t a1, void *a2)
{
  *a2 = off_101F5D870;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10165C3FC(id *a1)
{

  operator delete(a1);
}

void sub_10165C438(uint64_t a1, int *a2)
{
  v2 = *(a1 + 8);
  v3 = sub_101735308(*a2);
  (*(v2 + 16))(v2);
}

uint64_t sub_10165C4B0(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F5D8D0))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10165C528(uint64_t a1)
{

  operator delete();
}

id sub_10165C5DC(uint64_t a1, void *a2)
{
  *a2 = off_101F5D8F0;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10165C62C(id *a1)
{

  operator delete(a1);
}

void sub_10165C668(uint64_t a1, uint64_t a2)
{
  v4 = *a2;
  v3 = *(a2 + 8);
  *a2 = 0;
  *(a2 + 8) = 0;
  v5 = sub_101735308(*(a2 + 16));
  if (v5)
  {
    v6 = 0;
  }

  else
  {
    v6 = sub_101735D78(*v4);
  }

  (*(*(a1 + 8) + 16))();

  if (v3)
  {

    sub_100004A34(v3);
  }
}

void sub_10165C710(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10165C738(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F5D950))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10165C7B0(uint64_t a1)
{

  operator delete();
}

id sub_10165C864(uint64_t a1, void *a2)
{
  *a2 = off_101F5D970;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10165C8B4(id *a1)
{

  operator delete(a1);
}

void sub_10165C8F0(uint64_t a1, int *a2)
{
  v2 = *(a1 + 8);
  v3 = sub_101735308(*a2);
  (*(v2 + 16))(v2);
}

uint64_t sub_10165C968(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F5D9D0))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10165C9E0(uint64_t a1)
{

  operator delete();
}

id sub_10165CA94(uint64_t a1, void *a2)
{
  *a2 = off_101F5D9F0;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10165CAE4(id *a1)
{

  operator delete(a1);
}

void sub_10165CB20(uint64_t a1, uint64_t a2)
{
  v4 = *a2;
  v3 = *(a2 + 8);
  *a2 = 0;
  *(a2 + 8) = 0;
  v5 = sub_101735308(*(a2 + 16));
  if (v5)
  {
    v6 = 0;
  }

  else
  {
    v6 = sub_1017362C8(*v4);
  }

  (*(*(a1 + 8) + 16))();

  if (v3)
  {

    sub_100004A34(v3);
  }
}

void sub_10165CBC8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10165CBF0(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F5DA50))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10165CC68(uint64_t a1)
{

  operator delete();
}

id sub_10165CD1C(uint64_t a1, void *a2)
{
  *a2 = off_101F5DA70;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10165CD6C(id *a1)
{

  operator delete(a1);
}

void sub_10165CDA8(uint64_t a1, int *a2)
{
  v2 = *(a1 + 8);
  v3 = sub_101735308(*a2);
  (*(v2 + 16))(v2);
}

uint64_t sub_10165CE20(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F5DAD0))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10165CE98(uint64_t a1)
{

  operator delete();
}

id sub_10165CF4C(uint64_t a1, void *a2)
{
  *a2 = off_101F5DAF0;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10165CF9C(id *a1)
{

  operator delete(a1);
}

void sub_10165CFD8(uint64_t a1, int *a2)
{
  v2 = *(a1 + 8);
  v3 = sub_101735308(*a2);
  (*(v2 + 16))(v2);
}

uint64_t sub_10165D050(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F5DB50))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10165D0C8(uint64_t a1)
{

  operator delete();
}

id sub_10165D17C(uint64_t a1, void *a2)
{
  *a2 = off_101F5DB70;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10165D1CC(id *a1)
{

  operator delete(a1);
}

void sub_10165D208(uint64_t a1, uint64_t a2)
{
  v4 = *a2;
  v3 = *(a2 + 8);
  *a2 = 0;
  *(a2 + 8) = 0;
  v5 = sub_101735308(*(a2 + 16));
  if (v5)
  {
    v6 = 0;
  }

  else
  {
    v6 = sub_101736398(*v4);
  }

  (*(*(a1 + 8) + 16))();

  if (v3)
  {

    sub_100004A34(v3);
  }
}

void sub_10165D2B0(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10165D2D8(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F5DBD0))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10165D350(uint64_t a1)
{

  operator delete();
}

id sub_10165D404(uint64_t a1, void *a2)
{
  *a2 = off_101F5DBF0;
  result = objc_retainBlock(*(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10165D454(id *a1)
{

  operator delete(a1);
}

void sub_10165D490(uint64_t a1, int *a2)
{
  v2 = *(a1 + 8);
  v3 = sub_101735308(*a2);
  (*(v2 + 16))(v2);
}

uint64_t sub_10165D508(uint64_t a1, uint64_t a2)
{
  if (sub_1000DF210(a2, &off_101F5DC50))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10165D554(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *a1 = 0;
  *(a1 + 2) = 0;
  *(a1 + 48) = 0;
  *(a1 + 40) = a1 + 48;
  *(a1 + 56) = 0;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  v11 = 0;
  v12 = @"Stewie";
  __p = 0;
  v10 = 0;
  sub_10005B328(&__p, &v12, &v13, 1uLL);
  sub_10079CA24(a1 + 64, a2, a3, &__p, 2);
  if (__p)
  {
    v10 = __p;
    operator delete(__p);
  }

  v11 = 0;
  v12 = @"Stewie";
  __p = 0;
  v10 = 0;
  sub_10005B328(&__p, &v12, &v13, 1uLL);
  sub_10079CA24(a1 + 80, a2, a4, &__p, 2);
  if (__p)
  {
    v10 = __p;
    operator delete(__p);
  }

  return a1;
}

void sub_10165D68C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
  {
    operator delete(__p);
  }

  sub_100DE6314(v11 + 64);
  sub_100009970(v12, *(v11 + 48));
  v14 = *(v11 + 32);
  if (v14)
  {
    sub_100004A34(v14);
  }

  v15 = *(v11 + 16);
  if (v15)
  {
    sub_100004A34(v15);
  }

  _Unwind_Resume(a1);
}

void sub_10165D6FC(uint64_t a1)
{
  *a1 = &off_101F5DC70;
  *(a1 + 8) = off_101F5DE80;
  *(a1 + 56) = off_101F5DEB8;
  *(a1 + 64) = off_101F5DEE8;
  *(a1 + 72) = off_101F5DF20;
  *(a1 + 80) = off_101F5E050;
  *(a1 + 88) = off_101F5E080;
  sub_101018D74((a1 + 2840));
  v2 = *(a1 + 2824);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(a1 + 2800);
  if (v3)
  {
    sub_100004A34(v3);
  }

  v4 = *(a1 + 2768);
  if (v4)
  {
    sub_100004A34(v4);
  }

  v5 = *(a1 + 2720);
  if (v5)
  {
    sub_100004A34(v5);
  }

  v6 = *(a1 + 2704);
  if (v6)
  {
    sub_100004A34(v6);
  }

  v7 = *(a1 + 2680);
  if (v7)
  {
    sub_100004A34(v7);
  }

  v8 = *(a1 + 2656);
  *(a1 + 2656) = 0;
  if (v8)
  {
    (*(*v8 + 32))(v8);
  }

  TMKXPCServer.shutdown()();
  v9 = *(a1 + 2640);
  *(a1 + 2640) = 0;
  if (v9)
  {
    (*(*v9 + 32))(v9);
  }

  TMKXPCServer.shutdown()();
  sub_100009970(a1 + 2608, *(a1 + 2616));
  v10 = *(a1 + 2600);
  if (v10)
  {
    sub_100004A34(v10);
  }

  v11 = *(a1 + 2584);
  if (v11)
  {
    sub_100004A34(v11);
  }

  v12 = *(a1 + 2560);
  *(a1 + 2560) = 0;
  if (v12)
  {
    (*(*v12 + 32))(v12);
  }

  TMKXPCServer.shutdown()();
  v13 = *(a1 + 2544);
  *(a1 + 2544) = 0;
  if (v13)
  {
    (*(*v13 + 32))(v13);
  }

  TMKXPCServer.shutdown()();
  sub_100009970(a1 + 2512, *(a1 + 2520));
  v14 = *(a1 + 2504);
  if (v14)
  {
    sub_100004A34(v14);
  }

  v15 = *(a1 + 2488);
  if (v15)
  {
    sub_100004A34(v15);
  }

  v16 = *(a1 + 2464);
  if (v16)
  {
    sub_100004A34(v16);
  }

  sub_101018D74((a1 + 2432));
  sub_101018D74((a1 + 2400));
  v17 = *(a1 + 2384);
  if (v17)
  {
    sub_100004A34(v17);
  }

  v18 = *(a1 + 2336);
  if (v18)
  {
    sub_100004A34(v18);
  }

  v19 = *(a1 + 2320);
  if (v19)
  {
    sub_100004A34(v19);
  }

  v20 = *(a1 + 2304);
  if (v20)
  {
    sub_100004A34(v20);
  }

  v21 = *(a1 + 2288);
  if (v21)
  {
    sub_100004A34(v21);
  }

  v22 = *(a1 + 2272);
  if (v22)
  {
    sub_100004A34(v22);
  }

  PersonalitiesTracker::~PersonalitiesTracker((a1 + 2096));
  v23 = *(a1 + 2088);
  if (v23)
  {
    sub_100004A34(v23);
  }

  sub_101329490(*(a1 + 2056));
  v24 = *(a1 + 2032);
  if (v24)
  {
    sub_100004A34(v24);
  }

  v25 = *(a1 + 2000);
  if (v25)
  {
    sub_100004A34(v25);
  }

  v26 = *(a1 + 1984);
  if (v26)
  {
    sub_100004A34(v26);
  }

  sub_100009970(a1 + 1944, *(a1 + 1952));
  sub_10006DCAC(a1 + 1912, *(a1 + 1920));
  sub_10006DCAC(a1 + 1888, *(a1 + 1896));
  sub_100009970(a1 + 1848, *(a1 + 1856));
  sub_10004C4EC(a1 + 1824, *(a1 + 1832));
  v27 = (a1 + 1800);
  sub_1000087B4(&v27);
  sub_100077CD4(a1 + 1768, *(a1 + 1776));
  sub_10004543C(a1 + 952);
  sub_10004543C(a1 + 144);
  sub_10166B1F4(a1 + 96);
  ctu::OsLogLogger::~OsLogLogger((a1 + 48));
  sub_1000C0544((a1 + 16));
  StewieInterface::~StewieInterface(a1);
}

uint64_t sub_10165DAA4(uint64_t a1)
{
  v2 = *(a1 + 88);
  *(a1 + 88) = 0;
  if (v2)
  {
    (*(*v2 + 32))(v2);
  }

  TMKXPCServer.shutdown()();
  v3 = *(a1 + 72);
  *(a1 + 72) = 0;
  if (v3)
  {
    (*(*v3 + 32))(v3);
  }

  TMKXPCServer.shutdown()();
  sub_100009970(a1 + 40, *(a1 + 48));
  v4 = *(a1 + 32);
  if (v4)
  {
    sub_100004A34(v4);
  }

  v5 = *(a1 + 16);
  if (v5)
  {
    sub_100004A34(v5);
  }

  return a1;
}

void sub_10165DB90(uint64_t a1)
{
  sub_10165D6FC(a1);

  operator delete();
}

void sub_10165DBC8(uint64_t a1)
{
  sub_10165D6FC(a1 - 8);

  operator delete();
}

void sub_10165DC04(uint64_t a1)
{
  sub_10165D6FC(a1 - 56);

  operator delete();
}

void sub_10165DC40(uint64_t a1)
{
  sub_10165D6FC(a1 - 64);

  operator delete();
}

void sub_10165DC7C(uint64_t a1)
{
  sub_10165D6FC(a1 - 72);

  operator delete();
}

void sub_10165DCB8(uint64_t a1)
{
  sub_10165D6FC(a1 - 80);

  operator delete();
}

void sub_10165DCF4(uint64_t a1)
{
  sub_10165D6FC(a1 - 88);

  operator delete();
}

void StewieController::create(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  if (capabilities::ct::supportsStewie(a1))
  {
    if (_os_feature_enabled_impl())
    {
      *buf = 0u;
      v5 = 0u;
      v7[0] = @"Stewie";
      memset(__p, 0, 24);
      sub_10005B328(__p, v7, &v7[1], 1uLL);
      sub_1010192B4(buf);
    }

    ctu::OsLogContext::OsLogContext(buf, kCtLoggingSystemName, "stw.ctr");
    v3 = *&buf[8];
    ctu::OsLogContext::~OsLogContext(buf);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Not enabled", buf, 2u);
    }
  }

  *a2 = 0;
  a2[1] = 0;
}

void sub_10165EA0C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    operator delete(__p);
  }

  JUMPOUT(0x10165E8F0);
}

uint64_t sub_10165EA2C(uint64_t a1)
{
  v2 = atomic_load((a1 + 2008));
  if (v2 == 1 && sub_10007AEAC(a1 + 2392, 0) == 1)
  {
    v3 = sub_10007AEAC(a1 + 2424, 0);
    result = 0;
    v5 = v3 == 1;
    v6 = (a1 + 2664);
    v7 = atomic_load((a1 + 2664));
    if (v5 == (v7 & 1))
    {
      return result;
    }
  }

  else
  {
    LOBYTE(v5) = 0;
    result = 0;
    v6 = (a1 + 2664);
    v8 = atomic_load((a1 + 2664));
    if ((v8 & 1) == 0)
    {
      return result;
    }
  }

  atomic_store(v5, (a1 + 2664));
  v9 = *(a1 + 48);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    v10 = atomic_load(v6);
    v11 = 136315138;
    v12 = asStringBool(v10 & 1);
    _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Stewie feature support status: %s", &v11, 0xCu);
  }

  return 1;
}

void sub_10165EB4C(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v42, *(a1 + 1976));
  ctu::RestModule::connect();
  if (v43)
  {
    sub_100004A34(v43);
  }

  cf[0] = 0;
  sub_10007B7D8(a1 + 2632);
  v2 = cf[0];
  if (cf[0])
  {
    LOWORD(v47.__r_.__value_.__l.__data_) = 0;
    v3 = CFGetTypeID(cf[0]);
    if (v3 == CFNumberGetTypeID())
    {
      ctu::cf::assign(&v47, v2, v4);
    }

    data_low = LOWORD(v47.__r_.__value_.__l.__data_);
    v6 = v47.__r_.__value_.__s.__data_[0] & 0x3F;
    if (*(a1 + 2570) == 1)
    {
      *(a1 + 2568) = v6;
      v7 = *(a1 + 48);
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        goto LABEL_15;
      }
    }

    else
    {
      *(a1 + 2570) = 1;
      *(a1 + 2568) = v6;
      v7 = *(a1 + 48);
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        goto LABEL_15;
      }
    }

    sub_10097642C(data_low & 0x3F, &v47);
    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v8 = &v47;
    }

    else
    {
      v8 = v47.__r_.__value_.__r.__words[0];
    }

    LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
    *(buf.__r_.__value_.__r.__words + 4) = v8;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(&buf.__r_.__value_.__r.__words[1] + 6) = data_low;
    _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [Bootstrap][Loaded][Bystander location based] Supported services: %{public}s, Raw stored value: %hu", &buf, 0x12u);
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v47.__r_.__value_.__l.__data_);
    }
  }

LABEL_15:
  sub_10000A1EC(cf);
  cf[0] = 0;
  sub_10007B7D8(a1 + 2536);
  v9 = cf[0];
  if (cf[0])
  {
    LOWORD(v47.__r_.__value_.__l.__data_) = 0;
    v10 = CFGetTypeID(cf[0]);
    if (v10 == CFNumberGetTypeID())
    {
      ctu::cf::assign(&v47, v9, v11);
    }

    v12 = LOWORD(v47.__r_.__value_.__l.__data_);
    v13 = v47.__r_.__value_.__s.__data_[0] & 0x3F;
    if (*(a1 + 2474) == 1)
    {
      *(a1 + 2472) = v13;
      v14 = *(a1 + 48);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        goto LABEL_27;
      }
    }

    else
    {
      *(a1 + 2474) = 1;
      *(a1 + 2472) = v13;
      v14 = *(a1 + 48);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        goto LABEL_27;
      }
    }

    sub_10097642C(v12 & 0x3F, &v47);
    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v15 = &v47;
    }

    else
    {
      v15 = v47.__r_.__value_.__r.__words[0];
    }

    LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
    *(buf.__r_.__value_.__r.__words + 4) = v15;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(&buf.__r_.__value_.__r.__words[1] + 6) = v12;
    _os_log_impl(&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I [Bootstrap][Loaded][MCC and MNC based] Supported services: %{public}s, Raw stored value: %hu", &buf, 0x12u);
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v47.__r_.__value_.__l.__data_);
    }
  }

LABEL_27:
  sub_10000A1EC(cf);
  cf[0] = 0;
  sub_10007B7D8(a1 + 2648);
  sub_10006DD00(cf, &v47.__r_.__value_.__l.__data_);
  sub_10000A1EC(&v47.__r_.__value_.__l.__data_);
  if (cf[0])
  {
    Count = CFArrayGetCount(cf[0]);
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(cf[0], i);
        if (ValueAtIndex)
        {
          v19 = CFGetTypeID(ValueAtIndex);
          if (v19 == CFStringGetTypeID())
          {
            memset(&buf, 0, sizeof(buf));
            memset(&v47, 0, sizeof(v47));
            ctu::cf::assign();
            buf = v47;
            v20 = *(a1 + 48);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              {
                p_buf = &buf;
              }

              else
              {
                p_buf = buf.__r_.__value_.__r.__words[0];
              }

              LODWORD(v47.__r_.__value_.__l.__data_) = 136315138;
              *(v47.__r_.__value_.__r.__words + 4) = p_buf;
              _os_log_impl(&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I [Bootstrap][Loaded][Derived ISO][Bystander location based] ISO: %s", &v47, 0xCu);
            }

            sub_10017695C(a1 + 2608, &buf.__r_.__value_.__l.__data_);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
          }
        }
      }
    }
  }

  sub_100010250(cf);
  cf[0] = 0;
  sub_10007B7D8(a1 + 2552);
  sub_10006DD00(cf, &v47.__r_.__value_.__l.__data_);
  sub_10000A1EC(&v47.__r_.__value_.__l.__data_);
  if (cf[0])
  {
    v22 = CFArrayGetCount(cf[0]);
    if (v22 >= 1)
    {
      for (j = 0; j != v22; ++j)
      {
        v24 = CFArrayGetValueAtIndex(cf[0], j);
        if (v24)
        {
          v25 = CFGetTypeID(v24);
          if (v25 == CFStringGetTypeID())
          {
            memset(&buf, 0, sizeof(buf));
            memset(&v47, 0, sizeof(v47));
            ctu::cf::assign();
            buf = v47;
            v26 = *(a1 + 48);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              {
                v27 = &buf;
              }

              else
              {
                v27 = buf.__r_.__value_.__r.__words[0];
              }

              LODWORD(v47.__r_.__value_.__l.__data_) = 136315138;
              *(v47.__r_.__value_.__r.__words + 4) = v27;
              _os_log_impl(&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I [Bootstrap][Loaded][Derived ISO][MCC and MNC based] ISO: %s", &v47, 0xCu);
            }

            sub_10017695C(a1 + 2512, &buf.__r_.__value_.__l.__data_);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
          }
        }
      }
    }
  }

  sub_100010250(cf);
  ServiceMap = Registry::getServiceMap(*(a1 + 1976));
  v29 = ServiceMap;
  if ((v30 & 0x8000000000000000) != 0)
  {
    v31 = (v30 & 0x7FFFFFFFFFFFFFFFLL);
    v32 = 5381;
    do
    {
      v30 = v32;
      v33 = *v31++;
      v32 = (33 * v32) ^ v33;
    }

    while (v33);
  }

  std::mutex::lock(ServiceMap);
  v47.__r_.__value_.__r.__words[0] = v30;
  v34 = sub_100009510(&v29[1].__m_.__sig, &v47);
  if (v34)
  {
    v35 = v34[3];
    v36 = v34[4];
    if (v36)
    {
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v29);
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v36);
      v37 = 0;
      if (!v35)
      {
LABEL_67:
        if ((v37 & 1) == 0)
        {
          sub_100004A34(v36);
        }

        v40 = *(a1 + 24);
        if (v40)
        {
          v41 = std::__shared_weak_count::lock(v40);
          if (v41)
          {
            atomic_fetch_add_explicit(&v41->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_100004A34(v41);
            v48 = 0;
            operator new();
          }
        }

        sub_100013CC4();
      }

LABEL_62:
      v38 = *(a1 + 24);
      if (v38)
      {
        v39 = std::__shared_weak_count::lock(v38);
        if (v39)
        {
          atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_100004A34(v39);
          if ((v37 & 1) == 0)
          {
            atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
          }

          v44 = 0;
          operator new();
        }
      }

      sub_100013CC4();
    }
  }

  else
  {
    v35 = 0;
  }

  std::mutex::unlock(v29);
  v36 = 0;
  v37 = 1;
  if (!v35)
  {
    goto LABEL_67;
  }

  goto LABEL_62;
}

uint64_t sub_101660624(uint64_t result)
{
  if ((*(result + 2014) & 1) == 0)
  {
    v1 = result;
    v2 = *(result + 48);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *v3 = 0;
      _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Entering E911 state", v3, 2u);
    }

    *(v1 + 2014) = 1;
    return sub_101665DA4(v1);
  }

  return result;
}

uint64_t sub_1016606A4(uint64_t result)
{
  if (*(result + 2014) == 1)
  {
    v6 = v1;
    v7 = v2;
    v3 = result;
    v4 = *(result + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *v5 = 0;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Exiting E911 state completed", v5, 2u);
    }

    *(v3 + 2014) = 0;
    return sub_101665DA4(v3);
  }

  return result;
}

void sub_101660724(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(**(a1 + 2296) + 80))(*(a1 + 2296));
  if (*(*a3 + 49))
  {
    return;
  }

  v77 = 0;
  v78 = 0;
  v75 = 0;
  v76 = &v77;
  v73 = &v74;
  v74 = 0;
  v5 = *(a1 + 2248);
  v7 = *v5;
  v6 = v5[1];
  if (*v5 != v6)
  {
    do
    {
      v8 = *v7;
      if (*(*v7 + 48) != 1 || *(v8 + 49))
      {
        goto LABEL_57;
      }

      v9 = *(v8 + 52);
      LODWORD(v69) = v9;
      if (*(v8 + 47) < 0)
      {
        sub_100005F2C(&__p, *(v8 + 24), *(v8 + 32));
        v8 = *v7;
        v9 = v69;
      }

      else
      {
        __p = *(v8 + 24);
        v71 = *(v8 + 40);
      }

      v72 = *(v8 + 62);
      v10 = v77;
LABEL_9:
      if (!v10)
      {
LABEL_15:
        operator new();
      }

      while (1)
      {
        v11 = v10;
        v12 = *(v10 + 8);
        if (v12 > v9)
        {
          v10 = *v11;
          goto LABEL_9;
        }

        if (v12 >= v9)
        {
          break;
        }

        v10 = *(v11 + 1);
        if (!v10)
        {
          goto LABEL_15;
        }
      }

      if (SHIBYTE(v71) < 0)
      {
        operator delete(__p);
      }

      v13 = *v7;
      if (*(*v7 + 62))
      {
        goto LABEL_57;
      }

      if ((*(v13 + 95) & 0x8000000000000000) != 0)
      {
        if (*(v13 + 80))
        {
LABEL_23:
          *buf = @"Roadside";
          *&buf[8] = @"SupportedProviderIds";
          __p = 0uLL;
          v69 = 0;
          sub_10005B328(&v69, buf, &buf[16], 2uLL);
          theArray = 0;
          ServiceMap = Registry::getServiceMap(*(a1 + 1976));
          v15 = ServiceMap;
          if (v16 < 0)
          {
            v17 = (v16 & 0x7FFFFFFFFFFFFFFFLL);
            v18 = 5381;
            do
            {
              v16 = v18;
              v19 = *v17++;
              v18 = (33 * v18) ^ v19;
            }

            while (v19);
          }

          std::mutex::lock(ServiceMap);
          *buf = v16;
          v20 = sub_100009510(&v15[1].__m_.__sig, buf);
          if (v20)
          {
            v22 = v20[3];
            v21 = v20[4];
            if (v21)
            {
              atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v15);
              atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_100004A34(v21);
              v23 = 0;
LABEL_31:
              (*(*v22 + 104))(&v67, v22, *(*v7 + 52), 1, &v69, 0, 0);
              sub_10006DD00(&theArray, &v67);
              sub_10000A1EC(&v67);
              if ((v23 & 1) == 0)
              {
                sub_100004A34(v21);
              }

              if (theArray)
              {
                Count = CFArrayGetCount(theArray);
                if (Count >= 1)
                {
                  for (i = 0; i != Count; ++i)
                  {
                    ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
                    v27 = ValueAtIndex;
                    if (ValueAtIndex && (v28 = CFGetTypeID(ValueAtIndex), v28 == CFNumberGetTypeID()))
                    {
                      *buf = 0;
                      ctu::cf::assign(buf, v27, v29);
                      v30 = *buf;
                      v31 = v74;
LABEL_39:
                      if (!v31)
                      {
LABEL_50:
                        operator new();
                      }

                      while (1)
                      {
                        v32 = v31;
                        v33 = *(v31 + 8);
                        if (v33 > *buf)
                        {
                          v31 = *v32;
                          goto LABEL_39;
                        }

                        if (v33 >= *buf)
                        {
                          break;
                        }

                        v31 = v32[1];
                        if (!v31)
                        {
                          goto LABEL_50;
                        }
                      }

                      sub_100005BA0((v32 + 5), (*v7 + 72));
                      v35 = *(a1 + 48);
                      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                      {
                        v37 = (*v7 + 72);
                        if (*(*v7 + 95) < 0)
                        {
                          v37 = *v37;
                        }

                        *buf = 67109378;
                        *&buf[4] = v30;
                        *&buf[8] = 2080;
                        *&buf[10] = v37;
                        _os_log_impl(&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I ProviderId: %u is associated with phone number: %s", buf, 0x12u);
                      }
                    }

                    else
                    {
                      v34 = *(a1 + 48);
                      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                      {
                        v38 = subscriber::asString();
                        *buf = 136315394;
                        *&buf[4] = v38;
                        *&buf[12] = 2048;
                        *&buf[14] = i;
                        _os_log_error_impl(&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "[Skipping] Found invalid entry in carrier bundle for slot: %s, at index: %ld, for SupportedProviderIds", buf, 0x16u);
                      }
                    }
                  }
                }
              }

              sub_100010250(&theArray);
              if (v69)
              {
                *&__p = v69;
                operator delete(v69);
              }

              goto LABEL_57;
            }
          }

          else
          {
            v22 = 0;
          }

          std::mutex::unlock(v15);
          v21 = 0;
          v23 = 1;
          goto LABEL_31;
        }
      }

      else if (*(v13 + 95))
      {
        goto LABEL_23;
      }

LABEL_57:
      v7 += 2;
    }

    while (v7 != v6);
  }

  v39 = *(a1 + 2328);
  if (v39)
  {
    if (v39[2] == v78)
    {
      v42 = *v39;
      v40 = v39 + 1;
      v41 = v42;
      if (v42 == v40)
      {
LABEL_76:
        v49 = 1;
        goto LABEL_79;
      }

      v43 = v76;
      while (*(v41 + 8) == *(v43 + 8) && sub_100071DF8(v41 + 5, v43 + 5) && *(v41 + 64) == *(v43 + 64))
      {
        v44 = v41[1];
        v45 = v41;
        if (v44)
        {
          do
          {
            v41 = v44;
            v44 = *v44;
          }

          while (v44);
        }

        else
        {
          do
          {
            v41 = v45[2];
            v46 = *v41 == v45;
            v45 = v41;
          }

          while (!v46);
        }

        v47 = v43[1];
        if (v47)
        {
          do
          {
            v48 = v47;
            v47 = *v47;
          }

          while (v47);
        }

        else
        {
          do
          {
            v48 = v43[2];
            v46 = *v48 == v43;
            v43 = v48;
          }

          while (!v46);
        }

        v43 = v48;
        if (v41 == v40)
        {
          goto LABEL_76;
        }
      }
    }

    v49 = 0;
  }

  else
  {
    v49 = v78 == 0;
  }

LABEL_79:
  if (*(a1 + 2064) != v75)
  {
    goto LABEL_110;
  }

  v50 = *(a1 + 2048);
  if (v50 != (a1 + 2056))
  {
    v51 = v73;
    while (*(v50 + 8) == *(v51 + 8) && v50[7] == v51[7])
    {
      v52 = v50[5];
      if (v52 != v50 + 6)
      {
        v53 = v51[5];
        while (sub_100022D3C(&v69, v52 + 4, v53 + 4))
        {
          v54 = v52[1];
          v55 = v52;
          if (v54)
          {
            do
            {
              v52 = v54;
              v54 = *v54;
            }

            while (v54);
          }

          else
          {
            do
            {
              v52 = v55[2];
              v46 = *v52 == v55;
              v55 = v52;
            }

            while (!v46);
          }

          v56 = v53[1];
          if (v56)
          {
            do
            {
              v57 = v56;
              v56 = *v56;
            }

            while (v56);
          }

          else
          {
            do
            {
              v57 = v53[2];
              v46 = *v57 == v53;
              v53 = v57;
            }

            while (!v46);
          }

          v53 = v57;
          if (v52 == v50 + 6)
          {
            goto LABEL_98;
          }
        }

        break;
      }

LABEL_98:
      v58 = v50[1];
      if (v58)
      {
        do
        {
          v59 = v58;
          v58 = *v58;
        }

        while (v58);
      }

      else
      {
        do
        {
          v59 = v50[2];
          v46 = *v59 == v50;
          v50 = v59;
        }

        while (!v46);
      }

      v60 = v51[1];
      if (v60)
      {
        do
        {
          v61 = v60;
          v60 = *v60;
        }

        while (v60);
      }

      else
      {
        do
        {
          v61 = v51[2];
          v46 = *v61 == v51;
          v51 = v61;
        }

        while (!v46);
      }

      v62 = 1;
      v51 = v61;
      v50 = v59;
      if (v59 == (a1 + 2056))
      {
        goto LABEL_111;
      }
    }

LABEL_110:
    v62 = 0;
LABEL_111:
    if (v49)
    {
      goto LABEL_118;
    }

    goto LABEL_112;
  }

  v62 = 1;
  if (!v49)
  {
LABEL_112:
    if (v78)
    {
      operator new();
    }

    *(a1 + 2328) = 0;
    v63 = *(a1 + 2336);
    *(a1 + 2336) = 0;
    if (v63)
    {
      sub_100004A34(v63);
    }
  }

LABEL_118:
  if (v62)
  {
    v64 = v74;
  }

  else
  {
    v65 = a1 + 2056;
    sub_101329490(*(a1 + 2056));
    v64 = v74;
    *(a1 + 2048) = v73;
    *(a1 + 2056) = v64;
    v66 = v75;
    *(a1 + 2064) = v75;
    if (v66)
    {
      v64[2] = v65;
      v73 = &v74;
      v74 = 0;
      v75 = 0;
      v64 = 0;
    }

    else
    {
      *(a1 + 2048) = v65;
    }
  }

  sub_101329490(v64);
  sub_100E27210(v77);
  if (!v49)
  {
    (*(**(a1 + 2280) + 120))(*(a1 + 2280), a1 + 2328);
  }

  if ((v62 & 1) == 0)
  {
    sub_101664BC0(a1);
  }

  sub_101666030(a1);
}

void sub_101661078(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, int a19, __int16 a20, char a21, char a22, void *__p, uint64_t a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, void *a32, uint64_t a33, uint64_t a34, char *a35)
{
  sub_101329490(a32);
  sub_100E27210(a35);
  _Unwind_Resume(a1);
}

void sub_101661150(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  sub_10000501C(__p, "com.apple.MobileSMS");
  v4 = sub_100007A6C(a2, __p);
  if (v13 < 0)
  {
    operator delete(__p[0]);
  }

  v5 = a2 + 8;
  if (a2 + 8 == v4)
  {
    v7 = 0;
  }

  else
  {
    if (*(a1 + 2881) == 1)
    {
      v6 = *(a1 + 2880);
    }

    else
    {
      v6 = 0;
    }

    v8 = *(v4 + 56);
    v7 = v8 != (v6 & 1);
    *(a1 + 2880) = v8 | 0x100;
  }

  sub_10000501C(__p, "com.apple.findmy");
  v9 = sub_100007A6C(a2, __p);
  if (v13 < 0)
  {
    operator delete(__p[0]);
  }

  if (v5 == v9)
  {
    if (v7)
    {
LABEL_18:
      sub_1016658D0(a1);
    }
  }

  else
  {
    if (*(a1 + 2883) == 1)
    {
      v10 = *(a1 + 2882);
    }

    else
    {
      v10 = 0;
    }

    v11 = *(v9 + 56);
    *(a1 + 2882) = v11 | 0x100;
    if (v11 != (v10 & 1) || v7)
    {
      goto LABEL_18;
    }
  }
}

void sub_101661280(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016612A0(uint64_t a1)
{
  v1 = a1;
  v2 = *(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] **************************", buf, 2u);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] * StewieController state *", buf, 2u);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] **************************", buf, 2u);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = atomic_load((v1 + 2664));
    v4 = asStringBool(v3 & 1);
    *buf = 136315138;
    *&buf[4] = v4;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Stewie feature support status: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v5 = atomic_load((v1 + 2008));
    v6 = sub_1009762A4(v5);
    *buf = 136315138;
    *&buf[4] = v6;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] HWSupport: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v7 = sub_10007AEAC(v1 + 2392, 0);
    v8 = sub_100A320A0(v7);
    *buf = 136315138;
    *&buf[4] = v8;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Supported based on min iOS version: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v9 = asStringBool(*(v1 + 2012));
    *buf = 136315138;
    *&buf[4] = v9;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] LazyBootstrapComplete: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v10 = asStringBool(*(v1 + 2013));
    *buf = 136315138;
    *&buf[4] = v10;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] LazyStartComplete: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v11 = asStringBool(*(v1 + 2014));
    *buf = 136315138;
    *&buf[4] = v11;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] In E911: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v12 = asStringBool(*(v1 + 2015));
    *buf = 136315138;
    *&buf[4] = v12;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] In Emergency: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(v1 + 2016))
    {
      v13 = "true";
    }

    else
    {
      v13 = "false";
    }

    *buf = 136315138;
    *&buf[4] = v13;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Is Emergency call active: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v14 = sub_1009768EC(*(v1 + 2017));
    *buf = 136315138;
    *&buf[4] = v14;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Cell Service Status: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v15 = asStringBool(*(v1 + 2018));
    *buf = 136315138;
    *&buf[4] = v15;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Can make Em call based on cell service status: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v16 = asStringBool(*(v1 + 2020));
    *buf = 136315138;
    *&buf[4] = v16;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Is Cellular Internet active: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v17 = *(v1 + 2024);
    if (*v17)
    {
      v18 = 1;
    }

    else
    {
      v18 = v17[1];
    }

    v19 = asStringBool(v18 & 1);
    v20 = asStringBool(**(v1 + 2024));
    v21 = asStringBool(*(*(v1 + 2024) + 1));
    *buf = 136315650;
    *&buf[4] = v19;
    *&buf[12] = 2080;
    *&buf[14] = v20;
    *&buf[22] = 2080;
    *&buf[24] = v21;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Internet active: %s [cellular: %s, wifi: %s]", buf, 0x20u);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v22 = asStringBool(*(v1 + 2040));
    *buf = 136315138;
    *&buf[4] = v22;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Is Provisioned: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v23 = asStringBool(*(v1 + 2041));
    *buf = 136315138;
    *&buf[4] = v23;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Is feature requested: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v24 = asStringBool(*(v1 + 2042));
    *buf = 136315138;
    *&buf[4] = v24;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Is Disabled by network: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v25 = asStringBool(*(v1 + 2043));
    *buf = 136315138;
    *&buf[4] = v25;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Is thermal pressure intolerable: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v26 = sub_100976854(*(v1 + 2072));
    *buf = 136315138;
    *&buf[4] = v26;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Preconditions Status: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v27 = sub_100976880(*(v1 + 2073));
    *buf = 136315138;
    *&buf[4] = v27;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Preconditions Reason: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v28 = sub_10007AEAC(v1 + 2424, 0) == 1;
    v29 = asStringBool(v28);
    *buf = 136315138;
    *&buf[4] = v29;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Did enter launch country once: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v30 = asStringBool(*(v1 + 2665));
    *buf = 136315138;
    *&buf[4] = v30;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Authorized for bystander location: %s", buf, 0xCu);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v31 = asStringBool(*(v1 + 2696) != 0);
    *buf = 134218242;
    *&buf[4] = 30;
    *&buf[12] = 2080;
    *&buf[14] = v31;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Min gap between bystander location checks: %lld (In gap: %s)", buf, 0x16u);
    v2 = *(v1 + 48);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v32 = asStringBool(*(v1 + 2672) != 0);
    v33 = asStringBool(*(v1 + 2688));
    *buf = 136315394;
    *&buf[4] = v32;
    *&buf[12] = 2080;
    *&buf[14] = v33;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Has cached bystander location: %s, did process: %s", buf, 0x16u);
  }

  v34 = *(v1 + 2608);
  if (v34 != (v1 + 2616))
  {
    do
    {
      v35 = *(v1 + 48);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        v36 = v34 + 4;
        if (*(v34 + 55) < 0)
        {
          v36 = *v36;
        }

        *buf = 136315138;
        *&buf[4] = v36;
        _os_log_impl(&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I [d] [Derived ISO][Bystander location based] ISO: %s", buf, 0xCu);
      }

      v37 = v34[1];
      if (v37)
      {
        do
        {
          v38 = v37;
          v37 = *v37;
        }

        while (v37);
      }

      else
      {
        do
        {
          v38 = v34[2];
          v39 = *v38 == v34;
          v34 = v38;
        }

        while (!v39);
      }

      v34 = v38;
    }

    while (v38 != (v1 + 2616));
  }

  v40 = *(v1 + 48);
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    if (*(v1 + 2570) == 1)
    {
      sub_10097642C(*(v1 + 2568), buf);
      if (buf[23] >= 0)
      {
        v41 = buf;
      }

      else
      {
        v41 = *buf;
      }

      LODWORD(v171.__r_.__value_.__l.__data_) = 136446210;
      *(v171.__r_.__value_.__r.__words + 4) = v41;
      _os_log_impl(&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I [d] [Bystander location based] Supported services: %{public}s", &v171, 0xCu);
      if ((buf[23] & 0x80000000) != 0)
      {
        operator delete(*buf);
      }
    }

    else
    {
      LODWORD(v171.__r_.__value_.__l.__data_) = 136446210;
      *(v171.__r_.__value_.__r.__words + 4) = "<Not determined>";
      _os_log_impl(&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I [d] [Bystander location based] Supported services: %{public}s", &v171, 0xCu);
    }

    v40 = *(v1 + 48);
  }

  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    v42 = asStringBool(*(v1 + 2570)) != 0;
    v43 = asStringBool(v42);
    *buf = 136315138;
    *&buf[4] = v43;
    _os_log_impl(&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I [d] Important: MCC and MNC fallback is only used when bystander location based is not known. Is fallback in use: %s", buf, 0xCu);
  }

  v44 = *(v1 + 2048);
  if (v44 != (v1 + 2056))
  {
    do
    {
      v45 = *(v1 + 48);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        v46 = *(v44 + 8);
        stewie::dumpToString(v44 + 5, buf);
        v47 = buf[23] >= 0 ? buf : *buf;
        LODWORD(v171.__r_.__value_.__l.__data_) = 67109378;
        HIDWORD(v171.__r_.__value_.__r.__words[0]) = v46;
        LOWORD(v171.__r_.__value_.__r.__words[1]) = 2080;
        *(&v171.__r_.__value_.__r.__words[1] + 2) = v47;
        _os_log_impl(&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I [d] [RoadsideProviderIdToPhoneNumbers] Provider id: %u, Associated phone numbers: %s", &v171, 0x12u);
        if ((buf[23] & 0x80000000) != 0)
        {
          operator delete(*buf);
        }
      }

      v48 = v44[1];
      if (v48)
      {
        do
        {
          v49 = v48;
          v48 = *v48;
        }

        while (v48);
      }

      else
      {
        do
        {
          v49 = v44[2];
          v39 = *v49 == v44;
          v44 = v49;
        }

        while (!v39);
      }

      v44 = v49;
    }

    while (v49 != (v1 + 2056));
  }

  v50 = *(v1 + 2576);
  if (v50)
  {
    v53 = *v50;
    v52 = v50 + 1;
    v51 = v53;
    if (v53 != v52)
    {
      while (1)
      {
        v54 = *(v1 + 48);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          break;
        }

LABEL_114:
        if (*(v51 + 128) == 1)
        {
          v67 = *(v1 + 48);
          if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
          {
            v68 = *(v51 + 10);
            stewie::dumpToString(v51 + 13, buf);
            v69 = buf;
            if (buf[23] < 0)
            {
              v69 = *buf;
            }

            LODWORD(v171.__r_.__value_.__l.__data_) = 67109378;
            HIDWORD(v171.__r_.__value_.__r.__words[0]) = v68;
            LOWORD(v171.__r_.__value_.__r.__words[1]) = 2080;
            *(&v171.__r_.__value_.__r.__words[1] + 2) = v69;
            _os_log_impl(&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I [d] [Providers][Bystander location based][Provider id: %u] Associated phone numbers: %s", &v171, 0x12u);
            if ((buf[23] & 0x80000000) != 0)
            {
              operator delete(*buf);
            }
          }
        }

        v70 = v51[1];
        if (v70)
        {
          do
          {
            v71 = v70;
            v70 = *v70;
          }

          while (v70);
        }

        else
        {
          do
          {
            v71 = v51[2];
            v39 = *v71 == v51;
            v51 = v71;
          }

          while (!v39);
        }

        v51 = v71;
        if (v71 == v52)
        {
          goto LABEL_126;
        }
      }

      v55 = v51 + 6;
      if (*(v51 + 71) < 0)
      {
        v55 = *v55;
      }

      v169 = v55;
      v56 = *(v51 + 10);
      v57 = asStringBool(*(v51 + 97));
      sub_100E26E1C(v51 + 136, &v171);
      v58 = v1;
      v59 = v52;
      if ((v171.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v60 = &v171;
      }

      else
      {
        v60 = v171.__r_.__value_.__r.__words[0];
      }

      v61 = asStringBool(*(v51 + 96));
      v62 = v51 + 9;
      if (*(v51 + 95) < 0)
      {
        v62 = *v62;
      }

      v167 = v62;
      v63 = asStringBool(*(v51 + 138));
      if ((*(v51 + 97) != 1 || *(v51 + 137) != 1 || (v51[17] & 1) == 0) && *(v51 + 138) != 1)
      {
        goto LABEL_109;
      }

      if (*(v51 + 98) != 1)
      {
        v64 = 1;
        goto LABEL_111;
      }

      if (*(v51 + 128) == 1)
      {
        v64 = v51[15] != 0;
      }

      else
      {
LABEL_109:
        v64 = 0;
      }

LABEL_111:
      v65 = asStringBool(v64);
      v66 = asStringBool(*(v51 + 98));
      *buf = 67111170;
      *&buf[4] = v56;
      *&buf[8] = 2080;
      *&buf[10] = v169;
      *&buf[18] = 2082;
      *&buf[20] = v57;
      *&buf[28] = 2082;
      *&buf[30] = v60;
      v173 = 2080;
      v174 = v61;
      v175 = 2080;
      v176 = v167;
      v177 = 2080;
      v178 = v63;
      v179 = 2080;
      v180 = v65;
      v181 = 2080;
      v182 = v66;
      _os_log_impl(&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I [d] [Providers][Bystander location based] Provider id: %u, name: %s, supported by configuration: %{public}s, supported at location: %{public}s, supports pay per use: %s, bizID: %s, isTest: %s, isActive: %s, isCarrierProvider: %s", buf, 0x58u);
      if (SHIBYTE(v171.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v171.__r_.__value_.__l.__data_);
      }

      v52 = v59;
      v1 = v58;
      goto LABEL_114;
    }
  }

LABEL_126:
  v72 = *(v1 + 2592);
  if (v72)
  {
    if (*(v72 + 24) == 1)
    {
      v73 = (v72 + 8);
      v74 = *v72;
      if (*v72 != v72 + 8)
      {
        do
        {
          v75 = *(v1 + 48);
          if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
          {
            sub_10097642C(*(v74 + 16), buf);
            v76 = buf[23] >= 0 ? buf : *buf;
            LODWORD(v171.__r_.__value_.__l.__data_) = 136446210;
            *(v171.__r_.__value_.__r.__words + 4) = v76;
            _os_log_impl(&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I [d] [ServicePartners][Bystander location based] Services: %{public}s", &v171, 0xCu);
            if ((buf[23] & 0x80000000) != 0)
            {
              operator delete(*buf);
            }
          }

          v77 = v74[5];
          v78 = v74[6];
          while (v77 != v78)
          {
            v79 = *(v1 + 48);
            if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
            {
              v80 = v77;
              if (*(v77 + 23) < 0)
              {
                v80 = *v77;
              }

              *buf = 136446210;
              *&buf[4] = v80;
              _os_log_impl(&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#I [d] [ServicePartners][Bystander location based]    -> Partner: %{public}s", buf, 0xCu);
            }

            v77 += 3;
          }

          v81 = v74[1];
          if (v81)
          {
            do
            {
              v82 = v81;
              v81 = *v81;
            }

            while (v81);
          }

          else
          {
            do
            {
              v82 = v74[2];
              v39 = *v82 == v74;
              v74 = v82;
            }

            while (!v39);
          }

          v74 = v82;
        }

        while (v82 != v73);
        v72 = *(v1 + 2592);
      }
    }

    v83 = *(v72 + 32);
    if (*(v72 + 32))
    {
      v84 = *(v1 + 48);
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 67109120;
        *&buf[4] = v83;
        _os_log_impl(&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "#I [d] [ServicePartners][Bystander location based] Footnote mask: %hu", buf, 8u);
      }
    }
  }

  v85 = *(v1 + 48);
  if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
  {
    if (*(v1 + 2528))
    {
      v86 = "";
    }

    else
    {
      v86 = "<none>";
    }

    *buf = 136315138;
    *&buf[4] = v86;
    _os_log_impl(&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I [d] MCC and MNC based ISOs: %s", buf, 0xCu);
  }

  v87 = *(v1 + 2512);
  if (v87 != (v1 + 2520))
  {
    do
    {
      v88 = *(v1 + 48);
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
      {
        v89 = v87 + 4;
        if (*(v87 + 55) < 0)
        {
          v89 = *v89;
        }

        *buf = 136315138;
        *&buf[4] = v89;
        _os_log_impl(&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I [d] [Derived ISO][MCC and MNC based] ISO: %s", buf, 0xCu);
      }

      v90 = v87[1];
      if (v90)
      {
        do
        {
          v91 = v90;
          v90 = *v90;
        }

        while (v90);
      }

      else
      {
        do
        {
          v91 = v87[2];
          v39 = *v91 == v87;
          v87 = v91;
        }

        while (!v39);
      }

      v87 = v91;
    }

    while (v91 != (v1 + 2520));
  }

  v92 = *(v1 + 48);
  if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
  {
    if (*(v1 + 2474) == 1)
    {
      sub_10097642C(*(v1 + 2472), buf);
      if (buf[23] >= 0)
      {
        v93 = buf;
      }

      else
      {
        v93 = *buf;
      }

      LODWORD(v171.__r_.__value_.__l.__data_) = 136446210;
      *(v171.__r_.__value_.__r.__words + 4) = v93;
      _os_log_impl(&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I [d] [MCC and MNC based] Supported services: %{public}s", &v171, 0xCu);
      if ((buf[23] & 0x80000000) != 0)
      {
        operator delete(*buf);
      }
    }

    else
    {
      LODWORD(v171.__r_.__value_.__l.__data_) = 136446210;
      *(v171.__r_.__value_.__r.__words + 4) = "<Not determined>";
      _os_log_impl(&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I [d] [MCC and MNC based] Supported services: %{public}s", &v171, 0xCu);
    }
  }

  v94 = *(v1 + 2480);
  if (v94)
  {
    v97 = *v94;
    v96 = v94 + 1;
    v95 = v97;
    if (v97 != v96)
    {
      while (1)
      {
        v98 = *(v1 + 48);
        if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
        {
          break;
        }

LABEL_198:
        if (*(v95 + 128) == 1)
        {
          v111 = *(v1 + 48);
          if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
          {
            v112 = *(v95 + 10);
            stewie::dumpToString(v95 + 13, buf);
            v113 = buf;
            if (buf[23] < 0)
            {
              v113 = *buf;
            }

            LODWORD(v171.__r_.__value_.__l.__data_) = 67109378;
            HIDWORD(v171.__r_.__value_.__r.__words[0]) = v112;
            LOWORD(v171.__r_.__value_.__r.__words[1]) = 2080;
            *(&v171.__r_.__value_.__r.__words[1] + 2) = v113;
            _os_log_impl(&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I [d] [Providers][MCC and MNC based][Provider id: %u] Associated phone numbers: %s", &v171, 0x12u);
            if ((buf[23] & 0x80000000) != 0)
            {
              operator delete(*buf);
            }
          }
        }

        v114 = v95[1];
        if (v114)
        {
          do
          {
            v115 = v114;
            v114 = *v114;
          }

          while (v114);
        }

        else
        {
          do
          {
            v115 = v95[2];
            v39 = *v115 == v95;
            v95 = v115;
          }

          while (!v39);
        }

        v95 = v115;
        if (v115 == v96)
        {
          goto LABEL_210;
        }
      }

      v99 = v95 + 6;
      if (*(v95 + 71) < 0)
      {
        v99 = *v99;
      }

      v170 = v99;
      v100 = *(v95 + 10);
      v101 = asStringBool(*(v95 + 97));
      sub_100E26E1C(v95 + 136, &v171);
      v102 = v1;
      v103 = v96;
      if ((v171.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v104 = &v171;
      }

      else
      {
        v104 = v171.__r_.__value_.__r.__words[0];
      }

      v105 = asStringBool(*(v95 + 96));
      v106 = v95 + 9;
      if (*(v95 + 95) < 0)
      {
        v106 = *v106;
      }

      v168 = v106;
      v107 = asStringBool(*(v95 + 138));
      if ((*(v95 + 97) != 1 || *(v95 + 137) != 1 || (v95[17] & 1) == 0) && *(v95 + 138) != 1)
      {
        goto LABEL_193;
      }

      if (*(v95 + 98) != 1)
      {
        v108 = 1;
        goto LABEL_195;
      }

      if (*(v95 + 128) == 1)
      {
        v108 = v95[15] != 0;
      }

      else
      {
LABEL_193:
        v108 = 0;
      }

LABEL_195:
      v109 = asStringBool(v108);
      v110 = asStringBool(*(v95 + 98));
      *buf = 67111170;
      *&buf[4] = v100;
      *&buf[8] = 2080;
      *&buf[10] = v170;
      *&buf[18] = 2082;
      *&buf[20] = v101;
      *&buf[28] = 2082;
      *&buf[30] = v104;
      v173 = 2080;
      v174 = v105;
      v175 = 2080;
      v176 = v168;
      v177 = 2080;
      v178 = v107;
      v179 = 2080;
      v180 = v109;
      v181 = 2080;
      v182 = v110;
      _os_log_impl(&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "#I [d] [Providers][MCC and MNC based] Provider id: %u, name: %s, supported by configuration: %{public}s, supported at location: %{public}s, supports pay per use: %s, bizID: %s, isTest: %s, isActive: %s, isCarrierProvider: %s", buf, 0x58u);
      if (SHIBYTE(v171.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v171.__r_.__value_.__l.__data_);
      }

      v96 = v103;
      v1 = v102;
      goto LABEL_198;
    }
  }

LABEL_210:
  v116 = *(v1 + 2496);
  if (v116)
  {
    if (*(v116 + 24) == 1)
    {
      v117 = (v116 + 8);
      v118 = *v116;
      if (*v116 != v116 + 8)
      {
        do
        {
          v119 = *(v1 + 48);
          if (os_log_type_enabled(v119, OS_LOG_TYPE_DEFAULT))
          {
            sub_10097642C(*(v118 + 16), buf);
            v120 = buf[23] >= 0 ? buf : *buf;
            LODWORD(v171.__r_.__value_.__l.__data_) = 136446210;
            *(v171.__r_.__value_.__r.__words + 4) = v120;
            _os_log_impl(&_mh_execute_header, v119, OS_LOG_TYPE_DEFAULT, "#I [d] [ServicePartners][MCC and MNC based] Services: %{public}s", &v171, 0xCu);
            if ((buf[23] & 0x80000000) != 0)
            {
              operator delete(*buf);
            }
          }

          v121 = v118[5];
          v122 = v118[6];
          while (v121 != v122)
          {
            v123 = *(v1 + 48);
            if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
            {
              v124 = v121;
              if (*(v121 + 23) < 0)
              {
                v124 = *v121;
              }

              *buf = 136446210;
              *&buf[4] = v124;
              _os_log_impl(&_mh_execute_header, v123, OS_LOG_TYPE_DEFAULT, "#I [d] [ServicePartners][MCC and MNC based]    - Partner: %{public}s", buf, 0xCu);
            }

            v121 += 3;
          }

          v125 = v118[1];
          if (v125)
          {
            do
            {
              v126 = v125;
              v125 = *v125;
            }

            while (v125);
          }

          else
          {
            do
            {
              v126 = v118[2];
              v39 = *v126 == v118;
              v118 = v126;
            }

            while (!v39);
          }

          v118 = v126;
        }

        while (v126 != v117);
        v116 = *(v1 + 2496);
      }
    }

    v127 = *(v116 + 32);
    if (*(v116 + 32))
    {
      v128 = *(v1 + 48);
      if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 67109120;
        *&buf[4] = v127;
        _os_log_impl(&_mh_execute_header, v128, OS_LOG_TYPE_DEFAULT, "#I [d] [ServicePartners][MCC and MNC based] Footnote mask: %hu", buf, 8u);
      }
    }
  }

  v129 = *(v1 + 48);
  if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
  {
    v130 = asStringBool(*(v1 + 2044));
    *buf = 136315138;
    *&buf[4] = v130;
    _os_log_impl(&_mh_execute_header, v129, OS_LOG_TYPE_DEFAULT, "#I [d] IMS registered for voice: %s", buf, 0xCu);
    v129 = *(v1 + 48);
  }

  if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
  {
    if (*(v1 + 2047) == 1)
    {
      v131 = asStringBool(*(v1 + 2046));
    }

    else
    {
      v131 = "Unknown";
    }

    *buf = 136315138;
    *&buf[4] = v131;
    _os_log_impl(&_mh_execute_header, v129, OS_LOG_TYPE_DEFAULT, "#I [d] Is emergency call possible based on cached cell scan result: %s", buf, 0xCu);
    v129 = *(v1 + 48);
  }

  if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
  {
    v132 = asStringBool(*(v1 + 2045));
    *buf = 136315138;
    *&buf[4] = v132;
    _os_log_impl(&_mh_execute_header, v129, OS_LOG_TYPE_DEFAULT, "#I [d] Is emergency call capable: %s", buf, 0xCu);
  }

  *buf = 0;
  *&buf[8] = 0;
  ServiceMap = Registry::getServiceMap(*(v1 + 1976));
  v134 = ServiceMap;
  v135 = "20ProfileManagedConfig";
  if (("20ProfileManagedConfig" & 0x8000000000000000) != 0)
  {
    v136 = ("20ProfileManagedConfig" & 0x7FFFFFFFFFFFFFFFLL);
    v137 = 5381;
    do
    {
      v135 = v137;
      v138 = *v136++;
      v137 = (33 * v137) ^ v138;
    }

    while (v138);
  }

  std::mutex::lock(ServiceMap);
  v171.__r_.__value_.__r.__words[0] = v135;
  v139 = sub_100009510(&v134[1].__m_.__sig, &v171);
  if (v139)
  {
    v141 = v139[3];
    v140 = v139[4];
    if (v140)
    {
      atomic_fetch_add_explicit(&v140->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v134);
      atomic_fetch_add_explicit(&v140->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v140);
      v142 = 0;
      goto LABEL_253;
    }
  }

  else
  {
    v141 = 0;
  }

  std::mutex::unlock(v134);
  v140 = 0;
  v142 = 1;
LABEL_253:
  (**v141)(buf, v141);
  if ((v142 & 1) == 0)
  {
    sub_100004A34(v140);
  }

  v143 = *buf;
  if (*buf)
  {
    v144 = *(v1 + 48);
    if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v171.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&_mh_execute_header, v144, OS_LOG_TYPE_DEFAULT, "#I [Profile] Is installed", &v171, 2u);
      v143 = *buf;
    }

    if (v143[1])
    {
      v145 = *(v1 + 48);
      if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
      {
        v146 = asStringBool(*v143);
        LODWORD(v171.__r_.__value_.__l.__data_) = 136315138;
        *(v171.__r_.__value_.__r.__words + 4) = v146;
        _os_log_impl(&_mh_execute_header, v145, OS_LOG_TYPE_DEFAULT, "#I [Profile] Mock mode: %s", &v171, 0xCu);
        v143 = *buf;
      }
    }

    if (v143[3])
    {
      v147 = *(v1 + 48);
      if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
      {
        v148 = asStringBool(v143[2]);
        LODWORD(v171.__r_.__value_.__l.__data_) = 136315138;
        *(v171.__r_.__value_.__r.__words + 4) = v148;
        _os_log_impl(&_mh_execute_header, v147, OS_LOG_TYPE_DEFAULT, "#I [Profile] Test mode: %s", &v171, 0xCu);
        v143 = *buf;
      }
    }

    if (v143[5])
    {
      v149 = *(v1 + 48);
      if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
      {
        v150 = asStringBool(v143[4]);
        LODWORD(v171.__r_.__value_.__l.__data_) = 136315138;
        *(v171.__r_.__value_.__r.__words + 4) = v150;
        _os_log_impl(&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, "#I [Profile] Use Dev Namespace: %s", &v171, 0xCu);
      }
    }
  }

  if (*&buf[8])
  {
    sub_100004A34(*&buf[8]);
  }

  v151 = *(v1 + 48);
  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    v152 = *(v1 + 2328);
    if (v152)
    {
      v152 = *(v152 + 16);
    }

    *buf = 134217984;
    *&buf[4] = v152;
    _os_log_impl(&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Number of active SIMs: %lu", buf, 0xCu);
    v151 = *(v1 + 48);
  }

  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    v153 = asStringBool(*(v1 + 2666));
    *buf = 136315138;
    *&buf[4] = v153;
    _os_log_impl(&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Allow Emergency use cases in limited service: %s", buf, 0xCu);
    v151 = *(v1 + 48);
  }

  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    v154 = asStringBool(*(v1 + 2019));
    *buf = 136315138;
    *&buf[4] = v154;
    _os_log_impl(&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Apply policy for satellite system: %s", buf, 0xCu);
    v151 = *(v1 + 48);
  }

  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    sub_100E253C8(v1 + 2728, buf);
    if (buf[23] >= 0)
    {
      v155 = buf;
    }

    else
    {
      v155 = *buf;
    }

    LODWORD(v171.__r_.__value_.__l.__data_) = 136446210;
    *(v171.__r_.__value_.__r.__words + 4) = v155;
    _os_log_impl(&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Disconnect messaging after ScreenLock, seconds: %{public}s", &v171, 0xCu);
    if ((buf[23] & 0x80000000) != 0)
    {
      operator delete(*buf);
    }

    v151 = *(v1 + 48);
  }

  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    sub_100E253C8(v1 + 2744, buf);
    if (buf[23] >= 0)
    {
      v156 = buf;
    }

    else
    {
      v156 = *buf;
    }

    LODWORD(v171.__r_.__value_.__l.__data_) = 136446210;
    *(v171.__r_.__value_.__r.__words + 4) = v156;
    _os_log_impl(&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Disconnect messaging after ScreenLock when outgoing message is pending, seconds: %{public}s", &v171, 0xCu);
    if ((buf[23] & 0x80000000) != 0)
    {
      operator delete(*buf);
    }

    v151 = *(v1 + 48);
  }

  if (*(v1 + 2760) && os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] DisconnectMessagingAfterScreenLockTimer is running", buf, 2u);
    v151 = *(v1 + 48);
  }

  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    sub_100E253C8(v1 + 2776, buf);
    if (buf[23] >= 0)
    {
      v157 = buf;
    }

    else
    {
      v157 = *buf;
    }

    LODWORD(v171.__r_.__value_.__l.__data_) = 136446210;
    *(v171.__r_.__value_.__r.__words + 4) = v157;
    _os_log_impl(&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Disconnect messaging after Idle, seconds: %{public}s", &v171, 0xCu);
    if ((buf[23] & 0x80000000) != 0)
    {
      operator delete(*buf);
    }

    v151 = *(v1 + 48);
  }

  if (*(v1 + 2792) && os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] DisconnectMessagingAfterIdleTimer is running", buf, 2u);
    v151 = *(v1 + 48);
  }

  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    if (*(v1 + 2809) == 1)
    {
      if (*(v1 + 2808))
      {
        v158 = "true";
      }

      else
      {
        v158 = "false";
      }
    }

    else
    {
      v158 = "<none>";
    }

    *buf = 136315138;
    *&buf[4] = v158;
    _os_log_impl(&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Is SatSms provisioned: %s", buf, 0xCu);
    v151 = *(v1 + 48);
  }

  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    if (*(v1 + 2881) == 1)
    {
      if (*(v1 + 2880))
      {
        v159 = "true";
      }

      else
      {
        v159 = "false";
      }
    }

    else
    {
      v159 = "<none>";
    }

    *buf = 136315138;
    *&buf[4] = v159;
    _os_log_impl(&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Is Messages installed: %s", buf, 0xCu);
    v151 = *(v1 + 48);
  }

  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    if (*(v1 + 2883) == 1)
    {
      if (*(v1 + 2882))
      {
        v160 = "true";
      }

      else
      {
        v160 = "false";
      }
    }

    else
    {
      v160 = "<none>";
    }

    *buf = 136315138;
    *&buf[4] = v160;
    _os_log_impl(&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Is FindMy installed: %s", buf, 0xCu);
    v151 = *(v1 + 48);
  }

  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    v161 = asStringBool(*(v1 + 2456) != 0);
    *buf = 136315138;
    *&buf[4] = v161;
    _os_log_impl(&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Is BB Booted assertion acquired: %s", buf, 0xCu);
    v151 = *(v1 + 48);
  }

  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    if (*(v1 + 1969) == 1)
    {
      if (*(v1 + 1968))
      {
        v162 = "true";
      }

      else
      {
        v162 = "false";
      }
    }

    else
    {
      v162 = "<none>";
    }

    *buf = 136315138;
    *&buf[4] = v162;
    _os_log_impl(&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Telephony enabled: %s", buf, 0xCu);
  }

  v163 = *(v1 + 2280);
  if (v163)
  {
    (*(*v163 + 184))(v163);
  }

  v164 = *(v1 + 2080);
  if (v164)
  {
    (*(*v164 + 224))(v164);
  }

  v165 = *(v1 + 2264);
  if (v165)
  {
    (*(*v165 + 200))(v165);
  }

  return (*(**(v1 + 2296) + 136))(*(v1 + 2296));
}

void sub_10166316C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, std::__shared_weak_count *a25)
{
  if (a25)
  {
    sub_100004A34(a25);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016631D0(uint64_t a1, int a2)
{
  v2 = *(a1 + 136);
  if (v2 != a2)
  {
    v4 = *(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = "no";
      if (v2)
      {
        v5 = "yes";
      }

      v6 = 136315138;
      v7 = v5;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Emergency call in progress: %s", &v6, 0xCu);
    }

    sub_101665DA4(a1);
    if (*(a1 + 136) == 1 && *(a1 + 2041) == 1)
    {
      v6 = 4;
      LOBYTE(v7) = 0;
      BYTE2(v7) = 0;
      BYTE4(v7) = 0;
      sub_101665C5C(a1, &v6);
    }
  }
}

void sub_1016632D8(uint64_t a1, int a2)
{
  if (*(a1 + 140) != a2)
  {
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315138;
      v5 = asString();
      _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Airplane mode user preference: %s", &v4, 0xCu);
    }

    sub_10166491C(a1);
    if (*(a1 + 140) == 2 && *(a1 + 2041) == 1)
    {
      v4 = 2;
      LOBYTE(v5) = 0;
      BYTE2(v5) = 0;
      BYTE4(v5) = 1;
      sub_101665C5C(a1, &v4);
    }
  }
}

uint64_t sub_1016633D4(uint64_t a1)
{
  sub_101666FD0(a1);

  return sub_101666A80(a1);
}

uint64_t sub_10166340C(uint64_t result, int a2)
{
  if (*(result + 1760) != a2)
  {
    v2 = *(result + 48);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315138;
      v4 = asString();
      _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I WiFiStatus: %s", &v3, 0xCu);
    }

    sub_1016671CC();
  }

  return result;
}

uint64_t sub_101663548(uint64_t result, void *a2)
{
  v2 = result;
  if (*(result + 1784) == a2[2])
  {
    v3 = *(result + 1768);
    v4 = result + 1776;
    if (v3 == (result + 1776))
    {
      return result;
    }

    v5 = *a2;
    while (*(v3 + 8) == *(v5 + 8))
    {
      result = operator==();
      if (!result)
      {
        break;
      }

      v6 = v3[1];
      v7 = v3;
      if (v6)
      {
        do
        {
          v3 = v6;
          v6 = *v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          v3 = v7[2];
          v8 = *v3 == v7;
          v7 = v3;
        }

        while (!v8);
      }

      v9 = v5[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          v10 = v5[2];
          v8 = *v10 == v5;
          v5 = v10;
        }

        while (!v8);
      }

      v5 = v10;
      if (v3 == v4)
      {
        return result;
      }
    }
  }

  return sub_101666FD0(v2);
}

void sub_101663640(uint64_t a1, int a2)
{
  v2 = *(a1 + 1792);
  if (v2 != a2)
  {
    v4 = v2 > 39;
    v5 = *(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = "";
      if (v2 > 39)
      {
        v6 = "in";
      }

      v7 = 67109378;
      v8 = v2;
      v9 = 2080;
      v10 = v6;
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Thermal level changed to: %u, which is %stolerable", &v7, 0x12u);
    }

    if (*(a1 + 2043) != v4)
    {
      *(a1 + 2043) = v4;
      sub_10166491C(a1);
      if (v2 >= 40)
      {
        v7 = 11;
        LOBYTE(v8) = 0;
        BYTE2(v8) = 0;
        LOBYTE(v9) = 1;
        sub_101665C5C(a1, &v7);
      }
    }
  }
}

void sub_101663760(uint64_t a1)
{
  if (*(a1 + 1800) != *(a1 + 1808))
  {
    v2 = (a1 + 48);
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Preferred languages changed", buf, 2u);
    }

    v15 = 0;
    v16 = 0;
    sub_10000501C(buf, "/System/Library/Frameworks/CoreTelephony.framework/Support/CompressionConfig.plist");
    sub_101737D08(&v15);
    if (SHIBYTE(v14) < 0)
    {
      operator delete(*buf);
    }

    v4 = v15;
    if (v15)
    {
      v5 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 0;
        _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Determining codecs to download (Assuming USA):", buf, 2u);
      }

      *buf = 0;
      v13 = 0;
      v14 = 0;
      sub_10000501C(__p, "USA");
      (**v4)(buf, v4, a1 + 1800, __p);
      if (v18 < 0)
      {
        operator delete(*__p);
      }

      v6 = *buf;
      if (*buf != &v13)
      {
        do
        {
          v7 = *v2;
          if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
          {
            v8 = v6 + 32;
            if (v6[55] < 0)
            {
              v8 = *v8;
            }

            *__p = 136315138;
            *&__p[4] = v8;
            _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [codec]    %s", __p, 0xCu);
          }

          v9 = *(v6 + 1);
          if (v9)
          {
            do
            {
              v10 = v9;
              v9 = *v9;
            }

            while (v9);
          }

          else
          {
            do
            {
              v10 = *(v6 + 2);
              v11 = *v10 == v6;
              v6 = v10;
            }

            while (!v11);
          }

          v6 = v10;
        }

        while (v10 != &v13);
      }

      (*(**(a1 + 2264) + 176))(*(a1 + 2264), buf);
      sub_100009970(buf, v13);
    }

    if (v16)
    {
      sub_100004A34(v16);
    }
  }
}

void sub_1016639E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, char *a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  sub_100009970(&a11, a12);
  if (a19)
  {
    sub_100004A34(a19);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_101663A4C(uint64_t result)
{
  v1 = result;
  v2 = *(result + 1848);
  if (v2 == (result + 1856))
  {
LABEL_10:
    v6 = 0;
  }

  else
  {
    while (*(v2 + 14) != 1 || (*(v2 + 60) & 1) == 0)
    {
      v3 = v2[1];
      if (v3)
      {
        do
        {
          v4 = v3;
          v3 = *v3;
        }

        while (v3);
      }

      else
      {
        do
        {
          v4 = v2[2];
          v5 = *v4 == v2;
          v2 = v4;
        }

        while (!v5);
      }

      v2 = v4;
      if (v4 == (result + 1856))
      {
        goto LABEL_10;
      }
    }

    v6 = 1;
  }

  if (*(result + 2044) != v6)
  {
    *(result + 2044) = v6;
    v7 = *(result + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = "not ";
      if (v6)
      {
        v8 = "";
      }

      v9 = 136315138;
      v10 = v8;
      _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Voice call over IMS is %spossible", &v9, 0xCu);
    }

    return sub_101666964(v1);
  }

  return result;
}

void sub_101663B88(uint64_t a1, int a2)
{
  if (*(a1 + 1872) != a2)
  {
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315138;
      v5 = asString();
      _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Buddy state changed to: %s", &v4, 0xCu);
    }

    sub_10166491C(a1);
  }
}

void sub_101663C48(uint64_t a1)
{
  v2 = *(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = asStringBool(*(a1 + 1880));
    v4 = 136315138;
    v5 = v3;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I TurnOffCellular forAllSims is: %s", &v4, 0xCu);
  }

  sub_10166491C(a1);
}

uint64_t sub_101663CF4(uint64_t result, void *a2)
{
  v2 = result;
  if (*(result + 1928) == a2[2])
  {
    v3 = *(result + 1912);
    v4 = result + 1920;
    if (v3 == (result + 1920))
    {
      return result;
    }

    v5 = *a2;
    while (*(v3 + 7) == *(v5 + 7))
    {
      result = operator==();
      if (!result)
      {
        break;
      }

      v6 = v3[1];
      v7 = v3;
      if (v6)
      {
        do
        {
          v3 = v6;
          v6 = *v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          v3 = v7[2];
          v8 = *v3 == v7;
          v7 = v3;
        }

        while (!v8);
      }

      v9 = v5[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          v10 = v5[2];
          v8 = *v10 == v5;
          v5 = v10;
        }

        while (!v8);
      }

      v5 = v10;
      if (v3 == v4)
      {
        return result;
      }
    }
  }

  return sub_101666A80(v2);
}

uint64_t sub_101663DEC(uint64_t a1)
{
  v2 = *(a1 + 1940);
  if (capabilities::ct::requiresSeparateOperatingModeForStewie(a1))
  {
    v3 = 7;
  }

  else
  {
    v3 = 0;
  }

  v4 = *(a1 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136315650;
    v7 = asString();
    v8 = 2080;
    v9 = asString();
    v10 = 2080;
    v11 = asString();
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Operating mode is changing from: %s to: %s, required mode: %s", &v6, 0x20u);
  }

  return (*(**(a1 + 2280) + 104))(*(a1 + 2280), v2 == v3);
}

void sub_101663F14(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013) == 1)
  {
    v2 = *(a1 + 2080);
    v3 = sub_101665BEC(a1);
    v4 = *(*v2 + 208);

    v4(v2, v3);
  }
}

uint64_t sub_101663F98(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  v2 = *(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(a1 + 1969) == 1)
    {
      if (*(a1 + 1968))
      {
        v3 = "true";
      }

      else
      {
        v3 = "false";
      }
    }

    else
    {
      v3 = "<none>";
    }

    v5 = 136315138;
    v6 = v3;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Telephony enabled changed to: %s", &v5, 0xCu);
  }

  return (*(**(a1 + 2280) + 240))(*(a1 + 2280), *(a1 + 1968));
}

uint64_t sub_10166409C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  v2 = *(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(a1 + 1971) == 1)
    {
      if (*(a1 + 1970))
      {
        v3 = "true";
      }

      else
      {
        v3 = "false";
      }
    }

    else
    {
      v3 = "<none>";
    }

    v5 = 136315138;
    v6 = v3;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Brick mode enabled changed to: %s", &v5, 0xCu);
  }

  return (*(**(a1 + 2280) + 248))(*(a1 + 2280), *(a1 + 1970));
}

void sub_1016641A0(NSObject *a1)
{
  if (os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
  {
    *v2 = 0;
    _os_log_impl(&_mh_execute_header, a1, OS_LOG_TYPE_DEFAULT, "#I Lazy bootstrap", v2, 2u);
  }
}

uint64_t sub_1016641FC(uint64_t a1, int a2)
{
  result = sub_10165EA2C(a1);
  v5 = result;
  if ((result & 1) != 0 || a2)
  {
    v6 = *(a1 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      if (v5)
      {
        v7 = "[Support Changed] ";
      }

      else
      {
        v7 = "";
      }

      if (a2)
      {
        v8 = "[Forced notify] ";
      }

      else
      {
        v8 = "";
      }

      v9 = atomic_load((a1 + 2664));
      v10 = asStringBool(v9 & 1);
      v11 = atomic_load((a1 + 2008));
      v12 = 136315906;
      v13 = v7;
      v14 = 2080;
      v15 = v8;
      v16 = 2080;
      v17 = v10;
      v18 = 2080;
      v19 = sub_1009762A4(v11);
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sNotifying clients. Feature support status: %s, HWSupport: %s", &v12, 0x2Au);
    }

    return (***(a1 + 2712))(*(a1 + 2712));
  }

  return result;
}

uint64_t sub_101664348(uint64_t result)
{
  v1 = atomic_load((result + 2008));
  if (v1 == 1)
  {
    v2 = result;
    if ((*(result + 2013) & 1) == 0)
    {
      v3 = atomic_load((result + 2008));
      if (v3 == 1 && (*(result + 2012) & 1) == 0)
      {
        *(result + 2012) = 1;
        sub_1016641A0(*(result + 48));
      }

      v4 = *(v2 + 48);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 0;
        _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Lazy start", buf, 2u);
      }

      (*(**(v2 + 2280) + 16))(*(v2 + 2280));
      v5 = *(v2 + 2264);
      *buf = 0;
      (*(*v5 + 40))(v5, v2 + 2366, buf);
      if (*buf)
      {
        dispatch_group_leave(*buf);
        if (*buf)
        {
          dispatch_release(*buf);
        }
      }

      (*(**(v2 + 2264) + 48))(*(v2 + 2264));
      v6 = *(v2 + 2296);
      *buf = 0;
      (*(*v6 + 40))(v6, v2 + 2368, buf);
      if (*buf)
      {
        dispatch_group_leave(*buf);
        if (*buf)
        {
          dispatch_release(*buf);
        }
      }

      (*(**(v2 + 2296) + 48))(*(v2 + 2296));
      v43 = 0;
      memset(&buf[22], 0, 32);
      *buf = *(v2 + 2344);
      *&buf[14] = *(v2 + 2358);
      v7 = sub_101665964(v2);
      v8 = 0;
      if ((v7 & 1) == 0)
      {
        v8 = *(v2 + 2045);
      }

      buf[22] = v8 & 1;
      dispatch_assert_queue_V2(*(v2 + 32));
      if (*(v2 + 2364) == 2)
      {
        v9 = *(v2 + 1760);
        if (v9 != 1)
        {
          if (*(v2 + 2020))
          {
            v9 = 2;
          }

          else
          {
            v9 = 0;
          }
        }
      }

      else
      {
        v9 = 0;
      }

      *&buf[24] = v9;
      *&buf[28] = (*(**(v2 + 2312) + 8))(*(v2 + 2312));
      if (*(v2 + 1936) == 1)
      {
        if (*(v2 + 1939) == 1)
        {
          v10 = *(v2 + 1937) ^ 1;
        }

        else
        {
          v10 = 1;
        }
      }

      else
      {
        v10 = 0;
      }

      buf[30] = v10 & 1;
      buf[31] = *(v2 + 1938);
      dispatch_assert_queue_V2(*(v2 + 32));
      v11 = 2472;
      if (*(v2 + 2570))
      {
        v11 = 2568;
      }

      v12 = v2 + v11;
      v14 = *(v12 + 24);
      v13 = *(v12 + 32);
      *&buf[32] = v14;
      *&buf[40] = v13;
      if (v13)
      {
        atomic_fetch_add_explicit((v13 + 8), 1uLL, memory_order_relaxed);
      }

      buf[48] = sub_101665BEC(v2);
      v15 = *(v2 + 1984);
      v39 = *(v2 + 1976);
      v40 = v15;
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      v16 = *(v2 + 32);
      object = v16;
      if (v16)
      {
        dispatch_retain(v16);
      }

      v17 = *(v2 + 24);
      if (!v17 || (v18 = *(v2 + 16), (v19 = std::__shared_weak_count::lock(v17)) == 0))
      {
        sub_100013CC4();
      }

      v20 = v19;
      atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v19);
      v21 = std::__shared_weak_count::lock(v20);
      if (v21)
      {
        v22 = v21;
        v23 = v18 + 56;
        if (!v18)
        {
          v23 = 0;
        }

        atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        v36 = v23;
        v37 = v21;
        std::__shared_weak_count::__release_weak(v20);
        sub_100004A34(v22);
      }

      else
      {
        v36 = 0;
        v37 = 0;
        std::__shared_weak_count::__release_weak(v20);
      }

      stewie::StewieConnectionAssistantFactory::create(&v39, &object, &v36, &v41);
      v24 = v41;
      v41 = 0uLL;
      v25 = *(v2 + 2088);
      *(v2 + 2080) = v24;
      if (v25)
      {
        sub_100004A34(v25);
        if (*(&v41 + 1))
        {
          sub_100004A34(*(&v41 + 1));
        }
      }

      if (v37)
      {
        std::__shared_weak_count::__release_weak(v37);
      }

      if (object)
      {
        dispatch_release(object);
      }

      if (v40)
      {
        sub_100004A34(v40);
      }

      StewieController::setupQueryableMetrics(v2);
      if (*&buf[40])
      {
        sub_100004A34(*&buf[40]);
      }

      *(v2 + 2013) = 1;
      if (*(v2 + 2624))
      {
        memset(buf, 0, 40);
        (*(**(v2 + 2264) + 120))(buf);
        v27 = *&buf[8];
        v26 = *&buf[16];
        if (*&buf[16])
        {
          atomic_fetch_add_explicit((*&buf[16] + 8), 1uLL, memory_order_relaxed);
        }

        *(v2 + 2576) = v27;
        v28 = *(v2 + 2584);
        *(v2 + 2584) = v26;
        if (v28)
        {
          sub_100004A34(v28);
        }

        v30 = *&buf[24];
        v29 = *&buf[32];
        if (*&buf[32])
        {
          atomic_fetch_add_explicit((*&buf[32] + 8), 1uLL, memory_order_relaxed);
        }

        *(v2 + 2592) = v30;
        v31 = *(v2 + 2600);
        *(v2 + 2600) = v29;
        if (v31)
        {
          sub_100004A34(v31);
        }

        sub_101664BC0(v2);
        sub_101664D38(v2);
        if (*&buf[32])
        {
          sub_100004A34(*&buf[32]);
        }

        if (*&buf[16])
        {
          sub_100004A34(*&buf[16]);
        }
      }

      v32 = *(v2 + 2280);
      dispatch_assert_queue_V2(*(v2 + 32));
      v33 = 2472;
      if (*(v2 + 2570))
      {
        v33 = 2568;
      }

      v34 = (v2 + v33);
      if (*(v34 + 2) == 1)
      {
        v35 = *v34;
      }

      else
      {
        v35 = 0;
      }

      (*(*v32 + 160))(v32, v35);
      sub_101664DF8(v2);
      sub_101664EE8(v2, 0);
      sub_1016651E0(v2);
      return sub_1016658D0(v2);
    }
  }

  return result;
}

void sub_10166489C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, dispatch_object_t object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, dispatch_group_t group, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, std::__shared_weak_count *a22)
{
  if (a22)
  {
    sub_100004A34(a22);
  }

  _Unwind_Resume(exception_object);
}

void sub_10166491C(uint64_t a1)
{
  if (sub_10007AEAC(a1 + 2392, 0))
  {
    v2 = atomic_load((a1 + 2008));
    if (v2 == 2)
    {
      v3 = 0;
      v4 = 2;
    }

    else
    {
      v5 = atomic_load((a1 + 2008));
      if (v5 == 1)
      {
        if (*(a1 + 2040) == 1)
        {
          dispatch_assert_queue_V2(*(a1 + 32));
          v6 = 2472;
          if (*(a1 + 2570))
          {
            v6 = 2568;
          }

          v7 = a1 + v6;
          if (*(v7 + 2) == 1 && *v7)
          {
            if (*(a1 + 2042))
            {
              v3 = 0;
              v4 = 5;
            }

            else if (*(a1 + 2043))
            {
              v3 = 0;
              v4 = 8;
            }

            else if (*(a1 + 140) == 2)
            {
              v3 = 0;
              v4 = 7;
            }

            else if (*(a1 + 1872) == 1)
            {
              v3 = 0;
              v4 = 9;
            }

            else
            {
              v3 = *(a1 + 1880) ^ 1;
              if (*(a1 + 1880))
              {
                v4 = 10;
              }

              else
              {
                v4 = 0;
              }
            }
          }

          else
          {
            v3 = 0;
            v4 = 6;
          }
        }

        else
        {
          v3 = 0;
          v4 = 4;
        }
      }

      else
      {
        v3 = 0;
        v4 = 3;
      }
    }
  }

  else
  {
    v3 = 0;
    v4 = 1;
  }

  if (*(a1 + 2072) != v3 || *(a1 + 2073) != v4)
  {
    v9 = *(a1 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 136315394;
      v11 = sub_100976854(v3);
      v12 = 2080;
      v13 = sub_100976880(v4);
      _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Preconditions status: %s, Reason: %s", &v10, 0x16u);
    }

    *(a1 + 2072) = v3;
    *(a1 + 2073) = v4;
    (*(**(a1 + 2280) + 128))(*(a1 + 2280), a1 + 2072);
  }
}

void sub_101664B44()
{
  sub_10000501C(&__p, "/cc/assertions/baseband_booted");
  ctu::rest::AssertionHandle::create();
  if (v1 < 0)
  {
    operator delete(__p);
  }
}

void sub_101664BA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_101664BC0(uint64_t a1)
{
  v2 = *(a1 + 2576);
  if (v2)
  {
    sub_101261654(v2, a1 + 2048);
  }

  v3 = *(a1 + 2480);
  if (v3)
  {
    sub_101261654(v3, a1 + 2048);
  }

  dispatch_assert_queue_V2(*(a1 + 32));
  v4 = 2472;
  if (*(a1 + 2570))
  {
    v4 = 2568;
  }

  v5 = a1 + v4;
  v6 = *(a1 + v4 + 8);
  v7 = *(v5 + 16);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  if (!v6 || (v10 = *v6, v8 = v6 + 1, v9 = v10, v10 == v8))
  {
LABEL_24:
    v14 = 0;
  }

  else
  {
    while ((*(v9 + 97) != 1 || *(v9 + 137) != 1 || (v9[17] & 1) == 0) && *(v9 + 138) != 1 || *(v9 + 98) == 1 && (*(v9 + 128) != 1 || !v9[15]))
    {
      v11 = v9[1];
      if (v11)
      {
        do
        {
          v12 = v11;
          v11 = *v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          v12 = v9[2];
          v13 = *v12 == v9;
          v9 = v12;
        }

        while (!v13);
      }

      v9 = v12;
      if (v12 == v8)
      {
        goto LABEL_24;
      }
    }

    v14 = 1;
  }

  (*(**(a1 + 2280) + 208))(*(a1 + 2280), v14);
  if (v7)
  {

    sub_100004A34(v7);
  }
}

void sub_101664D20(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_101664D38(uint64_t a1)
{
  if (*(a1 + 2013) == 1)
  {
    v2 = *(a1 + 2080);
    dispatch_assert_queue_V2(*(a1 + 32));
    v3 = 2472;
    if (*(a1 + 2570))
    {
      v3 = 2568;
    }

    v4 = a1 + v3;
    v6 = *(v4 + 24);
    v5 = *(v4 + 32);
    v7 = v6;
    v8 = v5;
    if (v5)
    {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    (*(*v2 + 112))(v2, &v7);
    if (v8)
    {
      sub_100004A34(v8);
    }
  }
}

void sub_101664DE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_101664DF8(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  v2 = 2472;
  if (*(a1 + 2570))
  {
    v2 = 2568;
  }

  v3 = a1 + v2;
  sub_10000501C(__p, "JPN");
  v4 = sub_100007A6C(v3 + 40, __p);
  v5 = v3 + 48;
  if (v8 < 0)
  {
    operator delete(__p[0]);
  }

  v6 = v5 != v4;
  if (*(a1 + 2666) != v6)
  {
    *(a1 + 2666) = v6;
    (*(**(a1 + 2280) + 176))(*(a1 + 2280), v5 != v4);
    sub_101665FA0(a1);
  }
}

void sub_101664ECC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_101664EE8(uint64_t a1, _BOOL4 a2)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (a2)
  {
    *(a1 + 2688) = 0;
    v4 = *(a1 + 2704);
    *(a1 + 2696) = 0u;
    if (v4)
    {
      sub_100004A34(v4);
    }
  }

  if (*(a1 + 2013) == 1 && *(a1 + 2040) == 1)
  {
    v5 = *(a1 + 2672);
    if (v5)
    {
      if (*(a1 + 2665) == 1 && !*(a1 + 2696) && (*(a1 + 2688) != 1 || a2))
      {
        *(a1 + 2688) = 1;
        v6 = *(a1 + 48);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          v7 = *v5;
          *buf = 134218498;
          *&buf[4] = v7;
          *&buf[12] = 2080;
          *&buf[14] = asStringBool(a2);
          v17 = 2048;
          v18 = 30;
          _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Processing bystander location, location timestamp: %lld, forced: %s (Min gap between checks unless forced: %lld seconds)", buf, 0x20u);
        }

        sub_10000501C(&__p, "ReduceBystanderLocationProcessing");
        Registry::getTimerService(&v11, *(a1 + 1976));
        *buf = off_101F5F3F0;
        *&buf[8] = a1;
        v18 = buf;
        AutoStartTimer::create();
        v8 = v15;
        v15 = 0uLL;
        v9 = *(a1 + 2704);
        *(a1 + 2696) = v8;
        if (v9)
        {
          sub_100004A34(v9);
          if (*(&v15 + 1))
          {
            sub_100004A34(*(&v15 + 1));
          }
        }

        sub_10002B644(buf);
        if (v12)
        {
          sub_100004A34(v12);
        }

        if (v14 < 0)
        {
          operator delete(__p);
        }

        sub_100E13114(&v10 + 1, *(a1 + 16), *(a1 + 24));
        operator new();
      }
    }
  }
}

uint64_t sub_1016651E0(uint64_t result)
{
  if (*(result + 2013) == 1 && *(result + 2040) == 1)
  {
    operator new();
  }

  return result;
}

void sub_101665810(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100029A48(va);
  if (a5)
  {
    sub_100004A34(a5);
  }

  if (a3)
  {
    sub_100004A34(a3);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1016658D0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  v2 = *(**(a1 + 2280) + 232);

  return v2();
}

uint64_t sub_101665964(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  v24 = 0;
  v25 = 0;
  ServiceMap = Registry::getServiceMap(*(a1 + 1976));
  v3 = ServiceMap;
  v4 = "20ProfileManagedConfig";
  if (("20ProfileManagedConfig" & 0x8000000000000000) != 0)
  {
    v5 = ("20ProfileManagedConfig" & 0x7FFFFFFFFFFFFFFFLL);
    v6 = 5381;
    do
    {
      v4 = v6;
      v7 = *v5++;
      v6 = (33 * v6) ^ v7;
    }

    while (v7);
  }

  std::mutex::lock(ServiceMap);
  v26 = v4;
  v8 = sub_100009510(&v3[1].__m_.__sig, &v26);
  if (v8)
  {
    v10 = v8[3];
    v9 = v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v9);
      v11 = 0;
      goto LABEL_9;
    }
  }

  else
  {
    v10 = 0;
  }

  std::mutex::unlock(v3);
  v9 = 0;
  v11 = 1;
LABEL_9:
  (**v10)(&v24, v10);
  if ((v11 & 1) == 0)
  {
    sub_100004A34(v9);
  }

  if (v24 && *(v24 + 3) == 1 && (*(v24 + 2) & 1) != 0)
  {
    v12 = 1;
    goto LABEL_31;
  }

  v13 = Registry::getServiceMap(*(a1 + 1976));
  v14 = v13;
  if ((v15 & 0x8000000000000000) != 0)
  {
    v16 = (v15 & 0x7FFFFFFFFFFFFFFFLL);
    v17 = 5381;
    do
    {
      v15 = v17;
      v18 = *v16++;
      v17 = (33 * v17) ^ v18;
    }

    while (v18);
  }

  std::mutex::lock(v13);
  v26 = v15;
  v19 = sub_100009510(&v14[1].__m_.__sig, &v26);
  if (v19)
  {
    v21 = v19[3];
    v20 = v19[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v14);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v20);
      v22 = 0;
      goto LABEL_23;
    }
  }

  else
  {
    v21 = 0;
  }

  std::mutex::unlock(v14);
  v20 = 0;
  v22 = 1;
LABEL_23:
  if (!(*(*v21 + 16))(v21))
  {
    if ((v22 & 1) == 0)
    {
      sub_100004A34(v20);
    }

    goto LABEL_30;
  }

  v12 = sub_10007AEAC(a1 + 2832, 0);
  if ((v22 & 1) == 0)
  {
    sub_100004A34(v20);
  }

  if (v12 != 1)
  {
LABEL_30:
    v12 = 0;
  }

LABEL_31:
  if (v25)
  {
    sub_100004A34(v25);
  }

  return v12;
}

void sub_101665BAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if ((v12 & 1) == 0)
  {
    sub_100004A34(v11);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_101665BEC(uint64_t a1)
{
  v1 = *(a1 + 1944);
  if (v1 == (a1 + 1952))
  {
    v2 = 0;
  }

  else
  {
    v2 = 0;
    while (1)
    {
      v3 = *(v1 + 56);
      if (v3)
      {
        break;
      }

      v4 = v1[1];
      if (v4)
      {
        do
        {
          v5 = v4;
          v4 = *v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          v5 = v1[2];
          v6 = *v5 == v1;
          v1 = v5;
        }

        while (!v6);
      }

      v2 |= v3;
      v1 = v5;
      if (v5 == (a1 + 1952))
      {
        return v2 & 1;
      }
    }

    v2 = 1;
  }

  return v2 & 1;
}

void sub_101665C5C(uint64_t a1, _DWORD *a2)
{
  if (*(a1 + 2013))
  {
    if (*(a1 + 2041) == 1)
    {
      v4 = *(a1 + 132);
      if (*a2 == 3)
      {
        v5 = *(a1 + 48);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *v7 = 0;
          _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Network has requested Stewie disablement. Stewie won't be allowed until process is restarted.", v7, 2u);
        }

        *(a1 + 2042) = 1;
        sub_10166491C(a1);
      }

      if ((*(**(a1 + 2280) + 40))(*(a1 + 2280), a2))
      {
        (*(**(a1 + 2080) + 24))(*(a1 + 2080), v4, *a2);
        *(a1 + 2041) = 0;
      }
    }
  }

  else
  {
    v6 = *(a1 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
  }
}

uint64_t sub_101665DA4(uint64_t result)
{
  v1 = result;
  if (*(result + 2014))
  {
    v2 = 1;
  }

  else
  {
    v2 = *(result + 136);
  }

  if (*(result + 2015) == (v2 & 1))
  {
    v3 = *(result + 136);
    if (*(result + 2016) == v3)
    {
      return result;
    }
  }

  else
  {
    LOBYTE(v3) = *(result + 136);
  }

  *(result + 2015) = v2 & 1;
  *(result + 2016) = v3;
  v4 = *(result + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = "no";
    if (v2)
    {
      v5 = "yes";
    }

    v6 = 136315138;
    v7 = v5;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Re-evaluated InEmergency: %s", &v6, 0xCu);
    LOBYTE(v3) = *(v1 + 2016);
    v2 = *(v1 + 2015);
  }

  return (*(**(v1 + 2280) + 72))(*(v1 + 2280), v2 & 1, v3 & 1);
}

void sub_101665EDC(uint64_t a1)
{
  if (sub_10007AEAC(a1 + 2424, 0) != 1)
  {
    dispatch_assert_queue_V2(*(a1 + 32));
    v2 = 2472;
    if (*(a1 + 2570))
    {
      v2 = 2568;
    }

    v3 = a1 + v2;
    if (*(v3 + 2) == 1 && *v3)
    {
      v4 = *(a1 + 48);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *v5 = 0;
        _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Saving information that user is in a launch country", v5, 2u);
      }

      sub_1001A937C(a1 + 2424, 1u);
      sub_1016641FC(a1, 0);
    }
  }
}

uint64_t sub_101665FA0(uint64_t result)
{
  if (*(result + 2013) == 1)
  {
    v2 = result;
    if (*(result + 2045) == 1)
    {
      sub_101665964(result);
    }

    v3 = *(**(v2 + 2080) + 88);

    return v3();
  }

  return result;
}

void sub_101666030(uint64_t a1)
{
  ServiceMap = Registry::getServiceMap(*(a1 + 1976));
  v3 = ServiceMap;
  if (v4 < 0)
  {
    v5 = (v4 & 0x7FFFFFFFFFFFFFFFLL);
    v6 = 5381;
    do
    {
      v4 = v6;
      v7 = *v5++;
      v6 = (33 * v6) ^ v7;
    }

    while (v7);
  }

  std::mutex::lock(ServiceMap);
  *&buf = v4;
  v8 = sub_100009510(&v3[1].__m_.__sig, &buf);
  if (!v8)
  {
    std::mutex::unlock(v3);
    return;
  }

  v10 = v8[3];
  v9 = v8[4];
  if (v9)
  {
    v11 = v8[4];
    p_shared_owners = &v9->__shared_owners_;
    atomic_fetch_add_explicit(p_shared_owners, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v3);
    atomic_fetch_add_explicit(p_shared_owners, 1uLL, memory_order_relaxed);
    v9 = v11;
    sub_100004A34(v11);
    if (!v10)
    {
LABEL_66:
      sub_100004A34(v9);
      return;
    }
  }

  else
  {
    std::mutex::unlock(v3);
    if (!v10)
    {
      return;
    }
  }

  v54 = v9;
  v70 = 0;
  v71 = 0;
  v69 = &v70;
  v13 = *(a1 + 1824);
  v14 = (a1 + 1832);
  if (v13 == (a1 + 1832))
  {
    v32 = 0;
    goto LABEL_65;
  }

  v55 = a1;
  do
  {
    MCCAndMNC::getMcc(&buf, (v13 + 5));
    v15 = MCC::valid(&buf);
    v16 = v15;
    if (v74 < 0)
    {
      operator delete(*(&buf + 1));
      if (!v16)
      {
        goto LABEL_26;
      }
    }

    else if (!v15)
    {
      goto LABEL_26;
    }

    v17 = v70;
    if (!v70)
    {
      goto LABEL_25;
    }

    v18 = &v70;
    while (1)
    {
      while (1)
      {
        v19 = v17;
        if (!MCCAndMNC::operator<())
        {
          break;
        }

        v17 = *v19;
        v18 = v19;
        if (!*v19)
        {
          goto LABEL_25;
        }
      }

      if (!MCCAndMNC::operator<())
      {
        break;
      }

      v18 = v19 + 1;
      v17 = v19[1];
      if (!v17)
      {
        goto LABEL_25;
      }
    }

    if (!*v18)
    {
LABEL_25:
      operator new();
    }

LABEL_26:
    v20 = v13[1];
    if (v20)
    {
      do
      {
        v21 = v20;
        v20 = *v20;
      }

      while (v20);
    }

    else
    {
      do
      {
        v21 = v13[2];
        v22 = *v21 == v13;
        v13 = v21;
      }

      while (!v22);
    }

    v13 = v21;
  }

  while (v21 != v14);
  if (!v71)
  {
    v32 = v70;
LABEL_65:
    sub_1015FC450(v32);
    if (!v9)
    {
      return;
    }

    goto LABEL_66;
  }

  v67 = 0;
  v68 = 0;
  v66 = &v67;
  v23 = v69;
  if (v69 == &v70)
  {
    v31 = 0;
  }

  else
  {
    do
    {
      MCCAndMNC::getMcc(&buf, (v23 + 4));
      v64 = 0uLL;
      v65 = 0;
      MCCAndMNC::getMnc(theArray, (v23 + 4));
      if (MCC::valid(theArray))
      {
        MCC::getStringValue(v58, &buf);
        sub_10000501C(__p, "");
      }

      else
      {
        MCC::getStringValue(v58, &buf);
        MCC::getStringValue(__p, theArray);
      }

      (*(*v10 + 88))(&v60, v10, v58, __p);
      sub_100071A6C(&v64);
      v64 = v60;
      v65 = v61;
      v61 = 0;
      v60 = 0uLL;
      v72 = &v60;
      sub_1000087B4(&v72);
      if (v57 < 0)
      {
        operator delete(__p[0]);
      }

      if (v59 < 0)
      {
        operator delete(v58[0]);
      }

      v24 = *(&v64 + 1);
      v25 = v64;
      if (v64 != *(&v64 + 1))
      {
        do
        {
          v26 = *(v25 + 23);
          if (v26 < 0)
          {
            v28 = *v25;
            v27 = (*v25 + *(v25 + 8));
          }

          else
          {
            v27 = (v25 + v26);
            v28 = v25;
          }

          while (v28 != v27)
          {
            *v28 = __toupper(*v28);
            ++v28;
          }

          v25 += 24;
        }

        while (v25 != v24);
        v24 = *(&v64 + 1);
        v25 = v64;
      }

      *&v60 = &v66;
      *(&v60 + 1) = &v67;
      while (v25 != v24)
      {
        sub_101381464(&v60, v25);
        v25 += 24;
      }

      if (v63 < 0)
      {
        operator delete(theArray[1]);
      }

      theArray[0] = &v64;
      sub_1000087B4(theArray);
      if (v74 < 0)
      {
        operator delete(*(&buf + 1));
      }

      v29 = v23[1];
      if (v29)
      {
        do
        {
          v30 = v29;
          v29 = *v29;
        }

        while (v29);
      }

      else
      {
        do
        {
          v30 = v23[2];
          v22 = *v30 == v23;
          v23 = v30;
        }

        while (!v22);
      }

      v23 = v30;
    }

    while (v30 != &v70);
    v31 = v68;
  }

  if (*(v55 + 2528) != v31)
  {
    goto LABEL_85;
  }

  v33 = *(v55 + 2512);
  if (v33 != (v55 + 2520))
  {
    v34 = v66;
    while (sub_100022D3C(&buf, v33 + 4, v34 + 4))
    {
      v35 = v33[1];
      v36 = v33;
      if (v35)
      {
        do
        {
          v33 = v35;
          v35 = *v35;
        }

        while (v35);
      }

      else
      {
        do
        {
          v33 = v36[2];
          v22 = *v33 == v36;
          v36 = v33;
        }

        while (!v22);
      }

      v37 = v34[1];
      if (v37)
      {
        do
        {
          v38 = v37;
          v37 = *v37;
        }

        while (v37);
      }

      else
      {
        do
        {
          v38 = v34[2];
          v22 = *v38 == v34;
          v34 = v38;
        }

        while (!v22);
      }

      v34 = v38;
      if (v33 == (v55 + 2520))
      {
        goto LABEL_114;
      }
    }

LABEL_85:
    theArray[0] = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    v39 = v66;
    if (v66 != &v67)
    {
      do
      {
        v40 = (v39 + 4);
        *&buf = 0;
        if (*(v39 + 55) < 0)
        {
          v40 = *v40;
        }

        *&buf = CFStringCreateWithCString(kCFAllocatorDefault, v40, 0x8000100u);
        CFArrayAppendValue(theArray[0], buf);
        sub_100005978(&buf);
        v41 = v39[1];
        if (v41)
        {
          do
          {
            v42 = v41;
            v41 = *v41;
          }

          while (v41);
        }

        else
        {
          do
          {
            v42 = v39[2];
            v22 = *v42 == v39;
            v39 = v42;
          }

          while (!v22);
        }

        v39 = v42;
      }

      while (v42 != &v67);
    }

    sub_10079CC40(v55 + 2552);
    v43 = *(v55 + 48);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      if (v68)
      {
        v44 = "";
      }

      else
      {
        v44 = "<none>";
      }

      LODWORD(buf) = 136315138;
      *(&buf + 4) = v44;
      _os_log_impl(&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I MCC and MNC based ISOs: %s", &buf, 0xCu);
    }

    v45 = (v55 + 2512);
    v46 = v66;
    if (v66 != &v67)
    {
      do
      {
        v47 = *(v55 + 48);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          v48 = v46 + 4;
          if (*(v46 + 55) < 0)
          {
            v48 = *v48;
          }

          LODWORD(buf) = 136315138;
          *(&buf + 4) = v48;
          _os_log_impl(&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I [Derived ISO][MCC and MNC based]: %s", &buf, 0xCu);
        }

        v49 = v46[1];
        if (v49)
        {
          do
          {
            v50 = v49;
            v49 = *v49;
          }

          while (v49);
        }

        else
        {
          do
          {
            v50 = v46[2];
            v22 = *v50 == v46;
            v46 = v50;
          }

          while (!v22);
        }

        v46 = v50;
      }

      while (v50 != &v67);
    }

    v51 = v55 + 2520;
    sub_100009970(v45, *(v55 + 2520));
    v52 = v67;
    *(v55 + 2512) = v66;
    *(v55 + 2520) = v52;
    v53 = v68;
    *(v55 + 2528) = v68;
    if (v53)
    {
      *(v52 + 2) = v51;
      v66 = &v67;
      v67 = 0;
      v68 = 0;
    }

    else
    {
      *v45 = v51;
    }

    sub_101664DF8(v55);
    sub_1016651E0(v55);
    sub_1000279DC(theArray);
  }

LABEL_114:
  v9 = v54;
  sub_100009970(&v66, v67);
  sub_1015FC450(v70);
  if (v54)
  {
    goto LABEL_66;
  }
}

void sub_10166680C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, void *a32, uint64_t a33, int a34, __int16 a35, char a36, char a37, char a38, uint64_t a39, uint64_t a40, char a41, char *a42)
{
  sub_100009970(&a41, a42);
  sub_1015FC450(*(v42 - 168));
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_101666964(uint64_t result)
{
  v1 = result;
  if (*(result + 140) == 2 || (*(result + 2019) & 1) != 0)
  {
    goto LABEL_3;
  }

  if (*(result + 2044) & 1) != 0 || (*(result + 2018))
  {
    v2 = 1;
  }

  else
  {
    if (*(result + 2047) != 1)
    {
LABEL_3:
      v2 = 0;
      goto LABEL_4;
    }

    v2 = *(result + 2046);
  }

LABEL_4:
  v3 = v2 & 1;
  if (*(result + 2045) != v3)
  {
    *(result + 2045) = v3;
    v4 = *(result + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = "not";
      if (v3)
      {
        v5 = "";
      }

      v6 = 136315138;
      v7 = v5;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [Aggregate] Device can%s make emergency calls", &v6, 0xCu);
    }

    return sub_101665FA0(v1);
  }

  return result;
}

uint64_t sub_101666A80(uint64_t a1)
{
  v2 = *(a1 + 152);
  v3 = v2 > 6;
  v4 = 0x78u >> v2;
  v5 = 0x4Fu >> v2;
  v6 = 7u >> v2;
  v7 = 0x1020201000000uLL >> (8 * v2);
  if (v3)
  {
    result = 0;
  }

  else
  {
    result = v4;
  }

  if (v3)
  {
    v5 = 1;
    v9 = 1;
  }

  else
  {
    v9 = v6;
  }

  if (v3)
  {
    v10 = 0;
  }

  else
  {
    v10 = v7;
  }

  v11 = *(a1 + 948);
  v12 = *(a1 + 960);
  v13 = 0x1020201000000uLL >> (8 * v12);
  if (v12 >= 7)
  {
    LOBYTE(v13) = 0;
  }

  v14 = *(a1 + 1756);
  if (v10 <= v13)
  {
    v15 = v13;
  }

  else
  {
    v15 = v10;
  }

  if ((result & 1) != 0 && *(a1 + 948) && (v12 > 6) | ((0x4Fu >> v12) | v14) & 1)
  {
    v16 = 1;
  }

  else
  {
    v16 = (v12 < 7) & (0x78u >> v12) & v14 & (v5 | v11);
  }

  v17 = *(a1 + 1920);
  if (v17)
  {
    v18 = a1 + 1920;
    v19 = a1 + 1920;
    v20 = *(a1 + 1920);
    do
    {
      if (*(v20 + 28) >= 1)
      {
        v19 = v20;
      }

      v20 = *(v20 + 8 * (*(v20 + 28) < 1));
    }

    while (v20);
    v21 = v19 == v18 || *(v19 + 28) > 1 || *(v19 + 36) != 1;
    if ((v9 | v21 & v11))
    {
      v22 = a1 + 1920;
      do
      {
        if (*(v17 + 28) >= 2)
        {
          v22 = v17;
        }

        v17 = *(v17 + 8 * (*(v17 + 28) < 2));
      }

      while (v17);
      if (v22 != v18 && *(v22 + 28) <= 2 && *(v22 + 36) == 1)
      {
        goto LABEL_42;
      }

      goto LABEL_38;
    }

LABEL_40:
    LOBYTE(v23) = 1;
    goto LABEL_43;
  }

  if (((v9 | v11) & 1) == 0)
  {
    goto LABEL_40;
  }

LABEL_38:
  if (!*(a1 + 1756))
  {
LABEL_42:
    v23 = 6u >> (v13 & 7);
    goto LABEL_43;
  }

  LOBYTE(v23) = 0;
LABEL_43:
  v24 = v23 & 1;
  if (*(a1 + 2017) != v15 || *(a1 + 2019) != v16 || *(a1 + 2018) != v24)
  {
    v25 = *(a1 + 48);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      v26 = 136315650;
      v27 = sub_1009768EC(v15);
      v28 = 2080;
      v29 = asStringBool(v16);
      v30 = 2080;
      v31 = asStringBool(v24);
      _os_log_impl(&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Cell service status: %s, Apply policy for Satellite System: %s, Can make Em call based on cell service status: %s", &v26, 0x20u);
    }

    *(a1 + 2017) = v15;
    *(a1 + 2019) = v16;
    *(a1 + 2018) = v24;
    sub_101666964(a1);
    return (*(**(a1 + 2280) + 136))(*(a1 + 2280), v15, v16);
  }

  return result;
}

void sub_101666D5C(uint64_t a1, int a2)
{
  v4 = a1 + 32;
  dispatch_assert_queue_V2(*(a1 + 32));
  v5 = *(v4 + 100);
  v6 = v5 & 0x30;
  v7 = v5 & 0xFFFFFFCF;
  v8 = (v4 + 2760);
  if (v6)
  {
    v9 = v7 == 0;
  }

  else
  {
    v9 = 0;
  }

  if (v9)
  {
    if (*v8)
    {
      v11 = a2 == 0;
    }

    else
    {
      v11 = 0;
    }

    if (!v11)
    {
      v12 = *(a1 + 2800);
      *v8 = 0;
      *(v4 + 2768) = 0;
      if (v12)
      {
        sub_100004A34(v12);
      }

      v13 = (a1 + 2776);
      if (!*(a1 + 2784))
      {
        v13 = &unk_1019A8638;
      }

      v14 = *v13;
      if (*v13 >= 1)
      {
        v15 = *(a1 + 48);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *buf = 134218240;
          *&buf[4] = v14;
          *&buf[12] = 1024;
          *&buf[14] = a2;
          _os_log_impl(&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Starting %llu seconds timer to disconnect messaging after idle; resetDuration: %{BOOL}d", buf, 0x12u);
        }

        sub_10000501C(&__p, "DisconnectMessagingOnIdle");
        Registry::getTimerService(&v18, *(a1 + 1976));
        *buf = off_101F5F118;
        *&buf[8] = a1;
        *&buf[16] = v6;
        v24 = buf;
        AutoStartTimer::create();
        v16 = v22;
        v22 = 0uLL;
        v17 = *(a1 + 2800);
        *v8 = v16;
        if (v17)
        {
          sub_100004A34(v17);
          if (*(&v22 + 1))
          {
            sub_100004A34(*(&v22 + 1));
          }
        }

        sub_10002B644(buf);
        if (v19)
        {
          sub_100004A34(v19);
        }

        if (v21 < 0)
        {
          operator delete(__p);
        }
      }
    }
  }

  else
  {
    v10 = *(a1 + 2800);
    *v8 = 0;
    *(v4 + 2768) = 0;
    if (v10)
    {

      sub_100004A34(v10);
    }
  }
}

void sub_101666F90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, char a20)
{
  sub_10002B644(&a20);
  if (a11)
  {
    sub_100004A34(a11);
  }

  if (a17 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_101666FD0(uint64_t result)
{
  v1 = *(result + 152);
  if (v1 >= 7)
  {
    v2 = 0;
  }

  else
  {
    v2 = 0x1020201000000uLL >> (8 * v1);
  }

  v3 = *(result + 960);
  if (v3 >= 7)
  {
    v4 = 0;
  }

  else
  {
    v4 = 0x1020201000000uLL >> (8 * v3);
  }

  v5 = *(result + 1768);
  if (v5 == (result + 1776))
  {
LABEL_19:
    v10 = 0;
  }

  else
  {
    while (1)
    {
      if (*(v5 + 16) == 2)
      {
        v6 = *(v5 + 8) == 1 ? v2 : v4;
        if (v6 == 2)
        {
          break;
        }
      }

      v7 = v5[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          v8 = v5[2];
          v9 = *v8 == v5;
          v5 = v8;
        }

        while (!v9);
      }

      v5 = v8;
      if (v8 == (result + 1776))
      {
        goto LABEL_19;
      }
    }

    v10 = 1;
  }

  if (*(result + 2020) != v10)
  {
    *(result + 2020) = v10;
    v11 = *(result + 48);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = "inactive";
      if (v10)
      {
        v12 = "active";
      }

      v13 = 136315138;
      v14 = v12;
      _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Cellular Internet: %s", &v13, 0xCu);
    }

    sub_1016671CC();
  }

  return result;
}

uint64_t sub_101667484(uint64_t a1, uint64_t a2)
{
  v2 = atomic_load((a1 + 2664));
  v3 = atomic_load((a1 + 2008));
  return sub_100447630(a2, v2 & 1, v3 == 1);
}

void sub_1016674AC(uint64_t a1, char *a2, uint64_t a3)
{
  v5[4] = a1;
  v6 = *a2;
  LOBYTE(v7) = 0;
  v9 = 0;
  if (a2[32] == 1)
  {
    v7 = *(a2 + 8);
    v8 = *(a2 + 3);
    *(a2 + 2) = 0;
    *(a2 + 3) = 0;
    *(a2 + 1) = 0;
    v9 = 1;
  }

  v10 = *(a2 + 20);
  *__p = *(a2 + 3);
  v12 = *(a2 + 8);
  *(a2 + 6) = 0;
  *(a2 + 7) = 0;
  *(a2 + 8) = 0;
  v4 = *(a2 + 88);
  v13 = *(a2 + 72);
  v14 = v4;
  *(a2 + 11) = 0;
  *(a2 + 12) = 0;
  v15 = *(a2 + 104);
  *(a2 + 13) = 0;
  *(a2 + 14) = 0;
  v16 = *(a2 + 15);
  sub_10166F230(&v17, a3);
  v5[0] = 0;
  v5[1] = 0;
  sub_100004AA0(v5, (a1 + 16));
  operator new();
}

void sub_101667724(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_101667734(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_100004AA0(v1, (a1 + 16));
  operator new();
}

void sub_101667834(uint64_t a1, uint64_t a2)
{
  v3[4] = a1;
  sub_10135D5F0(&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_100004AA0(v3, (a1 + 16));
  operator new();
}

void sub_101667960(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_101667970(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_100004AA0(v1, (a1 + 16));
  operator new();
}

void sub_101667A5C(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4)
{
  v6 = a2;
  v7 = a1;
  *__p = *a3;
  v9 = *(a3 + 16);
  *a3 = 0;
  *(a3 + 8) = 0;
  *(a3 + 16) = 0;
  sub_100E2C3A8(&v10, a4);
  v5[0] = 0;
  v5[1] = 0;
  sub_100004AA0(v5, (a1 + 16));
  operator new();
}

void sub_101667BCC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_101667BDC(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_100004AA0(v1, (a1 + 16));
  operator new();
}

void sub_101667CC0(uint64_t a1, uint64_t a2)
{
  v3[4] = a1;
  sub_101670E40(&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_100004AA0(v3, (a1 + 16));
  operator new();
}

void sub_101667DEC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_101667DFC(uint64_t a1, __int128 *a2, uint64_t a3)
{
  v4[4] = a1;
  v5 = *a2;
  *a2 = 0;
  *(a2 + 1) = 0;
  sub_1016711D0(&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_100004AA0(v4, (a1 + 16));
  operator new();
}

void sub_101667F58(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_101667F68(uint64_t a1, uint64_t a2)
{
  v3[4] = a1;
  sub_1016715DC(&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_100004AA0(v3, (a1 + 16));
  operator new();
}

void sub_101668094(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_1016680A4(uint64_t a1, uint64_t a2)
{
  v3[4] = a1;
  sub_10135D784(&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_100004AA0(v3, (a1 + 16));
  operator new();
}

void sub_1016681D0(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_1016681E0(uint64_t a1, uint64_t a2)
{
  v3[4] = a1;
  sub_10135D918(&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_100004AA0(v3, (a1 + 16));
  operator new();
}

void sub_10166830C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_10166831C(uint64_t a1, char a2, uint64_t a3)
{
  v4[4] = a1;
  v5 = a2;
  sub_10166F230(&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_100004AA0(v4, (a1 + 16));
  operator new();
}

void sub_10166845C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_10166846C(uint64_t a1, void **a2, uint64_t a3)
{
  v5 = *a2;
  v6[4] = a1;
  object_8 = v5;
  if (v5)
  {
    xpc_retain(v5);
  }

  else
  {
    object_8 = xpc_null_create();
  }

  sub_101362508(&v8, a3);
  v6[0] = 0;
  v6[1] = 0;
  sub_100004AA0(v6, (a1 + 16));
  operator new();
}

void sub_1016685CC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1016685FC(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  v2 = *(**(a1 + 2312) + 16);

  return v2();
}

uint64_t sub_101668664(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 - 24));
  v2 = *(**(a1 + 2256) + 16);

  return v2();
}

void sub_1016686CC(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2040) != a2)
  {
    *(a1 + 2040) = a2;
    sub_101664EE8(a1, 1);
    sub_1016651E0(a1);
    sub_10166491C(a1);
    v4 = *(**(a1 + 2280) + 80);

    v4();
  }
}

void sub_101668770(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_100004AA0(v1, (a1 + 16));
  operator new();
}

void sub_101668854(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  v2 = *(a1 + 2376);
  if (v2)
  {
    v3 = (*(*v2 + 8))(v2);
    v4 = sub_10007AEAC(a1 + 2392, 0);
    if (v3 != (v4 == 1))
    {
      v5 = v4;
      v6 = *(a1 + 48);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = 136315394;
        v8 = asStringBool(v5 == 1);
        v9 = 2080;
        v10 = asStringBool(v3);
        _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Min iOS based support changed from %s to %s", &v7, 0x16u);
      }

      sub_1001A937C(a1 + 2392, v3);
      sub_1016641FC(a1, 0);
      sub_10166491C(a1);
    }
  }
}

void sub_101668994(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_100004AA0(v1, (a1 + 16));
  operator new();
}

void sub_101668A78(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_100004AA0(v1, (a1 + 16));
  operator new();
}

uint64_t (***sub_101668B64@<X0>(uint64_t a1@<X0>, void *a2@<X8>))(void)
{
  result = *(a1 + 2312);
  if (result)
  {
    return (**result)(result);
  }

  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t (***sub_101668B98@<X0>(uint64_t a1@<X0>, void *a2@<X8>))(void)
{
  result = *(a1 + 2232);
  if (result)
  {
    return (**result)(result);
  }

  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t sub_101668BCC(uint64_t a1)
{
  v2 = *(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *v4 = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I idsContactsUpdated", v4, 2u);
  }

  dispatch_assert_queue_V2(*(a1 + 32));
  return (*(**(a1 + 2296) + 96))(*(a1 + 2296));
}

void sub_101668C68(uint64_t a1, uint64_t a2)
{
  v3[4] = a1;
  sub_1016744B0(&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_100004AA0(v3, (a1 + 16));
  operator new();
}

void sub_101668D94(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_101668DA4(uint64_t a1, int a2, void *a3, CFTypeRef cf)
{
  if (cf)
  {
    CFRetain(cf);
  }

  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  if (cf)
  {
    CFRetain(cf);
  }

  v7[0] = 0;
  v7[1] = 0;
  sub_100004AA0(v7, (a1 + 16));
  operator new();
}

void sub_101668F28(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_100004AA0(v1, (a1 + 16));
  operator new();
}

void sub_101669004(uint64_t a1, uint64_t a2)
{
  v3[4] = a1;
  sub_10167488C(&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_100004AA0(v3, (a1 + 16));
  operator new();
}

void sub_101669130(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_101669148(uint64_t a1, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4)
{
  if (cf)
  {
    CFRetain(cf);
  }

  if (a3)
  {
    CFRetain(a3);
  }

  if (a4)
  {
    CFRetain(a4);
  }

  if (cf)
  {
    CFRetain(cf);
  }

  if (a3)
  {
    CFRetain(a3);
  }

  if (a4)
  {
    CFRetain(a4);
  }

  v8[0] = 0;
  v8[1] = 0;
  sub_100004AA0(v8, (a1 + 16));
  operator new();
}

void sub_1016692FC(uint64_t a1, char a2, uint64_t a3)
{
  v4[4] = a1;
  v5 = a2;
  sub_10010BE30(&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_100004AA0(v4, (a1 + 16));
  operator new();
}

void sub_10166943C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_101669454(uint64_t a1, unsigned int a2)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  v4 = atomic_load((a1 + 2008));
  if (v4 != a2)
  {
    atomic_store(a2, (a1 + 2008));
    v5 = *(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = atomic_load((a1 + 2008));
      v9 = 136315138;
      v10 = sub_1009762A4(v6);
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Determined HW support: %s", &v9, 0xCu);
    }

    if (*(a1 + 2456))
    {
      v7 = *(a1 + 48);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v9) = 0;
        _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [Releasing] BB booted assertion", &v9, 2u);
      }

      v8 = *(a1 + 2464);
      *(a1 + 2456) = 0;
      *(a1 + 2464) = 0;
      if (v8)
      {
        sub_100004A34(v8);
      }
    }

    sub_101664348(a1);
    sub_1016641FC(a1, 1);
    sub_10166491C(a1);
  }
}

void sub_1016695A0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v2 = *(**(a1 + 2080) + 64);

    v2();
  }

  else
  {
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *v4 = 0;
      _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_101669680(uint64_t a1)
{
  if (*(a1 + 2013))
  {
    v3 = *(**(a1 + 2080) + 152);

    v3();
  }

  else
  {
    v6 = v1;
    v7 = v2;
    v4 = *(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *v5 = 0;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v5, 2u);
    }
  }
}

void sub_101669728(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v2 = *(**(a1 + 2080) + 136);

    v2();
  }

  else
  {
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *v4 = 0;
      _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_1016697F4(uint64_t a1, int *a2)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v4 = *(a1 + 2080);
    v6 = *a2;
    *__p = *(a2 + 2);
    v8 = *(a2 + 3);
    *(a2 + 1) = 0;
    *(a2 + 2) = 0;
    *(a2 + 3) = 0;
    (*(*v4 + 144))(v4, &v6);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }

  else
  {
    v5 = *(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
  }
}

void sub_1016698CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016698F0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v2 = *(**(a1 + 2080) + 72);

    v2();
  }

  else
  {
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *v4 = 0;
      _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_1016699D0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  sub_10000501C(&__p, "/cc/assertions/stewie_mode_assertion");
  ctu::rest::AssertionHandle::create();
  if (v2 < 0)
  {
    operator delete(__p);
  }
}

void sub_101669A38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_101669A5C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  sub_10000501C(&__p, "/cc/assertions/prevent_nvm_sync");
  ctu::rest::AssertionHandle::create();
  if (v2 < 0)
  {
    operator delete(__p);
  }
}

void sub_101669AC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_101669AE8()
{
  sub_10000501C(&__p, "/cc/assertions/prevent_baseband_reset");
  ctu::rest::AssertionHandle::create();
  if (v1 < 0)
  {
    operator delete(__p);
  }
}

void sub_101669B48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_101669B74(uint64_t a1, char a2)
{
  dispatch_assert_queue_V2(*(a1 + 32));

  sub_101669BB8(a1 + 1992, a2);
}

void sub_101669BB8(uint64_t a1, char a2)
{
  v2 = xpc_BOOL_create(a2 & 1);
  if (!v2)
  {
    v2 = xpc_null_create();
  }

  sub_10000501C(&__p, "/cc/events/stewie_block_cellular_tx_event");
  object = v2;
  v3 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v6 < 0)
  {
    operator delete(__p);
  }

  xpc_release(v3);
}

void sub_101669C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  xpc_release(v15);
  _Unwind_Resume(a1);
}

void sub_101669C9C(uint64_t a1, char a2)
{
  dispatch_assert_queue_V2(*(a1 - 40));

  sub_101669BB8(a1 + 1920, a2);
}

void sub_101669CE0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v2 = *(**(a1 + 2080) + 200);

    v2();
  }

  else
  {
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *v4 = 0;
      _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_101669DAC(uint64_t a1, __int16 a2)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  *(a1 + 2366) = a2 | 0x100;
  if (*(a1 + 2013) == 1)
  {
    v4 = *(**(a1 + 2264) + 192);

    v4();
  }
}

void sub_101669E38(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  *(a1 + 2368) = a2 | 0x100;
  if (*(a1 + 2013) == 1)
  {
    (*(**(a1 + 2296) + 112))(*(a1 + 2296), a2);
    v4 = xpc_dictionary_create(0, 0, 0);
    if (v4 || (v4 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v4) == &_xpc_type_dictionary)
      {
        xpc_retain(v4);
        v5 = v4;
      }

      else
      {
        v5 = xpc_null_create();
      }
    }

    else
    {
      v5 = xpc_null_create();
      v4 = 0;
    }

    xpc_release(v4);
    v7 = v5;
    if (v5)
    {
      xpc_retain(v5);
    }

    else
    {
      v7 = xpc_null_create();
    }

    object = xpc_null_create();
    sub_10002A37C(117, &v7, &object);
    xpc_release(object);
    xpc_release(v7);
    v7 = 0;
    xpc_release(v5);
  }
}

void sub_101669F78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, xpc_object_t a10)
{
  xpc_release(object);
  xpc_release(a10);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

void sub_101669FC8(uint64_t a1, int a2)
{
  v2 = a2 & 0xFFFFFFFD;
  v3 = (a2 & 0xFFFFFFFD) == 0;
  if (*(a1 + 2665) != v3)
  {
    *(a1 + 2665) = v3;
    v5 = *(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v17 = 136315138;
      v18 = asStringBool(v2 == 0);
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Authorized for bystander location: %s", &v17, 0xCu);
    }

    if (v2)
    {
      v6 = *(a1 + 48);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v17) = 0;
        _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [Bystander location based] Lost authorization. Clear bystander cache and fallback to MCC and MNC based approach", &v17, 2u);
      }

      v7 = *(a1 + 2680);
      v8 = 0uLL;
      *(a1 + 2672) = 0u;
      if (v7)
      {
        sub_100004A34(v7);
        v8 = 0uLL;
      }

      *(a1 + 2688) = 0;
      v9 = *(a1 + 2704);
      *(a1 + 2696) = v8;
      if (v9)
      {
        sub_100004A34(v9);
      }

      if (*(a1 + 2570) == 1)
      {
        *(a1 + 2570) = 0;
      }

      v10 = *(a1 + 2584);
      v11 = 0uLL;
      *(a1 + 2576) = 0u;
      if (v10)
      {
        sub_100004A34(v10);
        v11 = 0uLL;
      }

      v12 = *(a1 + 2600);
      *(a1 + 2592) = v11;
      if (v12)
      {
        sub_100004A34(v12);
      }

      sub_100009970(a1 + 2608, *(a1 + 2616));
      *(a1 + 2608) = a1 + 2616;
      *(a1 + 2616) = 0u;
      sub_10079CC68(a1 + 2632);
      sub_10079CC68(a1 + 2648);
      sub_101664DF8(a1);
      sub_1016651E0(a1);
      if (*(a1 + 2013) == 1)
      {
        v13 = *(a1 + 2280);
        dispatch_assert_queue_V2(*(a1 + 32));
        v14 = 2472;
        if (*(a1 + 2570))
        {
          v14 = 2568;
        }

        v15 = (a1 + v14);
        if (*(v15 + 2) == 1)
        {
          v16 = *v15;
        }

        else
        {
          v16 = 0;
        }

        (*(*v13 + 160))(v13, v16);
      }
    }

    sub_101664EE8(a1, 0);
    sub_10166491C(a1);
  }
}

void sub_10166A200(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v2 = *(**(a1 + 2080) + 160);

    v2();
  }

  else
  {
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *v4 = 0;
      _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_10166A2CC(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v2 = *(**(a1 + 2080) + 168);

    v2();
  }

  else
  {
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *v4 = 0;
      _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_10166A3AC(uint64_t a1, char a2)
{
  if ((a2 & 0x30) != 0)
  {
    sub_101666D5C(a1, 1);
  }
}

void sub_10166A3C0(uint64_t a1, char a2)
{
  if ((a2 & 0x30) != 0)
  {
    sub_101666D5C(a1 - 72, 1);
  }
}

void sub_10166A3D8(uint64_t a1, char a2)
{
  if ((a2 & 0x30) != 0)
  {
    sub_101666D5C(a1, 1);
  }
}

void sub_10166A3EC(uint64_t a1, char a2)
{
  if ((a2 & 0x30) != 0)
  {
    sub_101666D5C(a1 - 72, 1);
  }
}

void sub_10166A404(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v2 = *(**(a1 + 2080) + 176);

    v2();
  }

  else
  {
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *v4 = 0;
      _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_10166A4D0(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_100004AA0(v1, (a1 + 16));
  operator new();
}

void sub_10166A5D8(uint64_t a1, BOOL *a2)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  v4 = *(a1 + 2047);
  v5 = a2[1];
  if (v4 != v5 || v4 == 0)
  {
    if (v4 == v5)
    {
      return;
    }
  }

  else if (*(a1 + 2046) == *a2)
  {
    return;
  }

  v7 = *(a1 + 48);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (v5)
    {
      v8 = asStringBool(*a2);
    }

    else
    {
      v8 = "Unknown";
    }

    v9 = 136315138;
    v10 = v8;
    _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Emergency call is possible based on cell scan result: %s", &v9, 0xCu);
  }

  *(a1 + 2046) = *a2;
  sub_101666964(a1);
}

void sub_10166A6E8(uint64_t a1, uint64_t **a2)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (!*a2)
  {
    __TUAssertTrigger();
  }

  if (!*(a1 + 2672))
  {
    v4 = *(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = **a2;
      v9 = 134217984;
      v10 = v5;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received first bystander location, location timestamp: %lld", &v9, 0xCu);
    }
  }

  v7 = *a2;
  v6 = a2[1];
  if (v6)
  {
    atomic_fetch_add_explicit(v6 + 1, 1uLL, memory_order_relaxed);
  }

  *(a1 + 2672) = v7;
  v8 = *(a1 + 2680);
  *(a1 + 2680) = v6;
  if (v8)
  {
    sub_100004A34(v8);
  }

  *(a1 + 2688) = 0;
  sub_101664EE8(a1, 0);
}

void sub_10166A7FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v14 = 0u;
    memset(v13, 0, sizeof(v13));
    *buf = a1;
    sub_10101B938(v13, a3);
    v5 = *(a1 + 24);
    if (v5)
    {
      v6 = *(a1 + 16);
      v7 = std::__shared_weak_count::lock(v5);
      if (v7)
      {
        *&v14 = v6;
        *(&v14 + 1) = v7;
        atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v7);
        sub_10101B938(&v9, v13);
        *v10 = v14;
        v14 = 0uLL;
        v11 = 0;
        operator new();
      }
    }

    sub_100013CC4();
  }

  v8 = *(a1 + 48);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *buf = 0;
    _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
  }

  *buf = 0;
  *&v13[0] = 0;
  sub_100E22D6C(a3);
  if (*&v13[0])
  {
    sub_100004A34(*&v13[0]);
  }
}

void sub_10166AA0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, std::__shared_weak_count *a22)
{
  if (a22)
  {
    sub_100004A34(a22);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10166AA5C(uint64_t a1)
{
  v2 = *(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  sub_100E76F18(a1 + 8);
  return a1;
}

void sub_10166AA9C(uint64_t a1@<X0>, void *a2@<X8>)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v4 = *(**(a1 + 2296) + 120);

    v4();
  }

  else
  {
    v5 = *(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *v6 = 0;
      _os_log_error_impl(&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v6, 2u);
    }

    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_10166AB6C(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v4 = *(**(a1 + 2264) + 136);

    v4();
  }

  else
  {
    v5 = *(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v6) = 0;
      _os_log_error_impl(&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Not ready. Pending start", &v6, 2u);
    }

    v6 = 0;
    v7 = 0;
    sub_100E22F04(a2);
    if (v7)
    {
      sub_100004A34(v7);
    }
  }
}

void sub_10166AC4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_10166AC6C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v2 = *(**(a1 + 2264) + 64);

    v2();
  }

  else
  {
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *v4 = 0;
      _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_10166AD38(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    (*(**(a1 + 2264) + 72))(*(a1 + 2264));
    v2 = *(**(a1 + 2080) + 120);

    v2();
  }

  else
  {
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *v4 = 0;
      _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_10166AE24(uint64_t a1@<X0>, void *a2@<X8>)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    *a2 = 0;
    a2[1] = 0;
    (*(**(a1 + 2264) + 96))(*(a1 + 2264));
    (*(**(a1 + 2080) + 128))(*(a1 + 2080), a2);
  }

  else
  {
    v4 = *(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *v5 = 0;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v5, 2u);
    }

    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_10166AF04(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 8);
  if (v3)
  {
    sub_100004A34(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_10166AF24(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v2 = *(**(a1 + 2264) + 144);

    v2();
  }

  else
  {
    v3 = *(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *v4 = 0;
      _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

uint64_t sub_10166AFF0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  if (*(a1 + 2013))
  {
    v2 = *(**(a1 + 2264) + 168);

    return v2();
  }

  else
  {
    v4 = *(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *v5 = 0;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v5, 2u);
    }

    return 0;
  }
}

uint64_t sub_10166B0C0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v4 = *(a1 + 1800);
  v5 = *(a1 + 1808);

  return sub_10004EFD0(a2, v4, v5, 0xAAAAAAAAAAAAAAABLL * ((v5 - v4) >> 3));
}

uint64_t sub_10166B12C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 + 32));
  v2 = *(**(a1 + 2264) + 184);

  return v2();
}

uint64_t sub_10166B190(uint64_t a1)
{
  dispatch_assert_queue_V2(*(a1 - 40));
  v2 = *(**(a1 + 2192) + 184);

  return v2();
}

uint64_t sub_10166B1F4(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void sub_10166B278(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10166B2CC(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10166B30C(uint64_t result)
{
  if (result)
  {
    return (*(*result + 32))();
  }

  return result;
}

void sub_10166B338(ServiceManager::Service *this)
{
  *this = off_101F5E208;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10166B394(ServiceManager::Service *this)
{
  *this = off_101F5E208;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_10166B414@<X0>(void *a1@<X8>)
{
  v2 = 2;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  return sub_1000FF040(a1, &v2, &vars0, 1);
}

void sub_10166B458(uint64_t a1, dispatch_object_t *a2)
{
  v2 = *(a1 + 8);
  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }

  v4[0] = 0;
  v4[1] = 0;
  sub_100004AA0(v4, (v2 + 16));
  operator new();
}

void sub_10166B568(uint64_t a1)
{
  v1 = *(a1 + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_100004AA0(v2, (v1 + 16));
  operator new();
}

void sub_10166B644(uint64_t a1, int a2, ServiceStage *this)
{
  v3 = *(a1 + 8);
  ServiceStage::holdOffStage(&group[1], this);
  v5[0] = 0;
  v5[1] = 0;
  sub_100004AA0(v5, (v3 + 16));
  operator new();
}

void sub_10166B754(uint64_t **a1)
{
  v1 = *a1;
  v2 = a1;
  v3 = v1;
  sub_10165EB4C(*v1);
}

void sub_10166B798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_10166B7B4(uint64_t **a1)
{
  v1 = **a1;
  v2 = *(v1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }

  sub_1016641FC(v1, 1);
  (*(**(v1 + 2280) + 8))(*(v1 + 2280));
  sub_101664348(v1);
  sub_10166491C(v1);
  v3 = atomic_load((v1 + 2008));
  if (v3 == 2)
  {
    v4 = *(v1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [Acquiring] BB booted assertion", buf, 2u);
    }

    sub_101664B44();
    v5 = *buf;
    memset(buf, 0, sizeof(buf));
    v6 = *(v1 + 2464);
    *(v1 + 2456) = v5;
    if (v6)
    {
      sub_100004A34(v6);
      if (*&buf[8])
      {
        sub_100004A34(*&buf[8]);
      }
    }
  }

  operator delete();
}

uint64_t *sub_10166B938(uint64_t *a1)
{
  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v2 = *v1;
  (*(**(*v1 + 2264) + 160))(*(*v1 + 2264), *v1 + 64);
  (*(**(v2 + 2296) + 72))(*(v2 + 2296), v2 + 80);
  ctu::RestModule::disconnect((v2 + 1992));
  *(v2 + 2013) = 0;
  sub_1000FF844(&v5);
  return sub_1000049E0(&v4);
}

void sub_10166B9DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void *sub_10166B9F8(void *a1)
{
  *a1 = off_101F5E288;
  v2 = a1[5];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = a1[3];
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  return a1;
}

void sub_10166BA50(void *a1)
{
  *a1 = off_101F5E288;
  v2 = a1[5];
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = a1[3];
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

uint64_t sub_10166BB54(uint64_t result, uint64_t a2)
{
  *a2 = off_101F5E288;
  *(a2 + 8) = *(result + 8);
  v2 = *(result + 24);
  *(a2 + 24) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 16), 1uLL, memory_order_relaxed);
  }

  v3 = *(result + 40);
  *(a2 + 32) = *(result + 32);
  *(a2 + 40) = v3;
  if (v3)
  {
    atomic_fetch_add_explicit((v3 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_10166BBB4(void *a1)
{
  sub_1001E3C94(a1 + 8);

  operator delete(a1);
}

void sub_10166BBF0(uint64_t a1, uint64_t a2)
{
  LOBYTE(__p[0]) = 0;
  v22 = 0;
  v3 = *(a2 + 24);
  if (v3 == 1)
  {
    *__p = *a2;
    v21 = *(a2 + 16);
    *(a2 + 8) = 0;
    *(a2 + 16) = 0;
    *a2 = 0;
    v22 = 1;
  }

  v4 = *(a1 + 24);
  if (v4)
  {
    v5 = *(a1 + 8);
    v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      v7 = v6;
      if (!*(a1 + 16))
      {
LABEL_33:
        sub_100004A34(v7);
        LOBYTE(v3) = v22;
        goto LABEL_34;
      }

      if (v3)
      {
        v8 = *(v5 + 48);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          v9 = __p;
          if (v21 < 0)
          {
            v9 = __p[0];
          }

          *buf = 136315138;
          *&buf[4] = v9;
          _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "[Bootstrap] Error returned from waiting for system app migration completion: %s", buf, 0xCu);
        }

        goto LABEL_33;
      }

      v25 = 0;
      v26[0] = 0;
      v26[1] = 0;
      sub_10000501C(buf, "com.apple.MobileSMS");
      sub_10000501C(v29, "com.apple.findmy");
      sub_10011C9B0(&v25, buf, 2);
      for (i = 0; i != -6; i -= 3)
      {
        if (SHIBYTE(v29[i + 2]) < 0)
        {
          operator delete(*&buf[i * 8 + 24]);
        }
      }

      *(&v23 + 1) = 0;
      v24 = 0;
      *&v23 = &v23 + 8;
      v11 = v25;
      if (v25 == v26)
      {
        v19 = (v5 + 16);
        *buf = v5;
        *&buf[8] = &v23 + 8;
        v29[0] = 0;
      }

      else
      {
        do
        {
          v12 = v11 + 4;
          v13 = (*(**(a1 + 32) + 128))(*(a1 + 32), v11 + 4);
          *buf = v11 + 4;
          *(sub_100170224(&v23, v11 + 4) + 56) = v13;
          v14 = *(v5 + 48);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            if (*(v11 + 55) < 0)
            {
              v12 = *v12;
            }

            *buf = 136315394;
            v15 = "false";
            if (v13)
            {
              v15 = "true";
            }

            *&buf[4] = v12;
            *&buf[12] = 2080;
            *&buf[14] = v15;
            _os_log_impl(&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I [Bootstrap] %s installed: %s", buf, 0x16u);
          }

          v16 = v11[1];
          if (v16)
          {
            do
            {
              v17 = v16;
              v16 = *v16;
            }

            while (v16);
          }

          else
          {
            do
            {
              v17 = v11[2];
              v18 = *v17 == v11;
              v11 = v17;
            }

            while (!v18);
          }

          v11 = v17;
        }

        while (v17 != v26);
        v19 = (v5 + 16);
        *buf = v5;
        *&buf[8] = v23;
        v29[0] = v24;
        if (v24)
        {
          *(*(&v23 + 1) + 16) = &buf[16];
          *&v23 = &v23 + 8;
          *(&v23 + 1) = 0;
          v24 = 0;
          goto LABEL_32;
        }
      }

      *&buf[8] = &buf[16];
LABEL_32:
      v27[0] = 0;
      v27[1] = 0;
      sub_100004AA0(v27, v19);
      operator new();
    }
  }

LABEL_34:
  if ((v3 & 1) != 0 && SHIBYTE(v21) < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_10166C034(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, void *a33, uint64_t a34, int a35, __int16 a36, char a37, char a38)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10166C0EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_10166C138(uint64_t **a1)
{
  v1 = *a1;
  v6 = a1;
  v7 = v1;
  v2 = *v1;
  v3 = v1 + 2;
  v4 = v1[2];
  v8 = v1[1];
  v9 = v4;
  if (v1[3])
  {
    *(v4 + 16) = &v9;
    v1[1] = v3;
    *v3 = 0;
    v1[3] = 0;
  }

  else
  {
    v8 = &v9;
  }

  sub_101661150(v2, &v8);
  sub_100009970(&v8, v9);
  sub_100A7C384(&v7);
  return sub_1000049E0(&v6);
}

void sub_10166C1C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, char *a13)
{
  sub_100009970(&a12, a13);
  sub_100A7C384(&a11);
  sub_1000049E0(&a10);
  _Unwind_Resume(a1);
}

void *sub_10166C1E8(void *a1)
{
  *a1 = off_101F5E308;
  v2 = a1[3];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return a1;
}

void sub_10166C234(void *a1)
{
  *a1 = off_101F5E308;
  v1 = a1[3];
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

uint64_t sub_10166C314(uint64_t result, uint64_t a2)
{
  *a2 = off_101F5E308;
  *(a2 + 8) = *(result + 8);
  v2 = *(result + 24);
  *(a2 + 24) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 16), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_10166C354(uint64_t a1)
{
  v1 = *(a1 + 24);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10166C364(void *__p)
{
  v2 = __p[3];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10166C3A4(void *a1)
{
  v2 = a1[3];
  if (v2)
  {
    v3 = a1[1];
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (a1[2])
      {
        sub_101668854(v3);
      }

      sub_100004A34(v5);
    }
  }
}

uint64_t sub_10166C42C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166C4F4(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5E388;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166C52C(void *a1)
{
  v1 = a1[2];
  v2 = a1[3];
  v3 = (a1[1] + (v2 >> 1));
  if (v2)
  {
    return (*(*v3 + v1))();
  }

  else
  {
    return v1(v3);
  }
}

uint64_t sub_10166C574(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166C63C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5E408;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166C674(void *a1)
{
  v1 = a1[2];
  v2 = a1[3];
  v3 = (a1[1] + (v2 >> 1));
  if (v2)
  {
    return (*(*v3 + v1))();
  }

  else
  {
    return v1(v3);
  }
}

uint64_t sub_10166C6BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166C784(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5E488;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166C7BC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = a1[2];
  v5 = a1[3];
  v6 = (a1[1] + (v5 >> 1));
  if (v5)
  {
    v4 = *(*v6 + v4);
  }

  return v4(v6, a3, a4);
}

uint64_t sub_10166C80C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166C8D4(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5E508;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166C90C(void *a1, xpc_object_t *a2)
{
  v7 = 0;
  sub_10011E4A4(&v7, a2);
  v3 = a1[2];
  v4 = a1[3];
  v5 = (a1[1] + (v4 >> 1));
  if (v4)
  {
    v3 = *(*v5 + v3);
  }

  return v3(v5, &v7);
}

uint64_t sub_10166C98C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166CA54(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5E588;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_10166CA8C(void *a1, xpc_object_t *a2)
{
  v9 = 0;
  v10 = 0;
  v8 = &v9;
  sub_101038210(&v8, a2);
  v3 = a1[2];
  v4 = a1[3];
  v5 = (a1[1] + (v4 >> 1));
  if (v4)
  {
    v3 = *(*v5 + v3);
  }

  v6 = v8;
  v7[0] = v9;
  v7[1] = v10;
  if (v10)
  {
    *(v9 + 2) = v7;
    v8 = &v9;
    v9 = 0;
    v10 = 0;
  }

  else
  {
    v6 = v7;
  }

  v3(v5, &v6);
  sub_100009970(&v6, v7[0]);
  sub_100009970(&v8, v9);
}

void sub_10166CB60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char *a10, uint64_t a11, char a12, char *a13)
{
  sub_100009970(&a9, a10);
  sub_100009970(&a12, a13);
  _Unwind_Resume(a1);
}

uint64_t sub_10166CB8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166CC54(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5E608;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166CC8C(void *a1)
{
  v1 = a1[2];
  v2 = a1[3];
  v3 = (a1[1] + (v2 >> 1));
  if (v2)
  {
    return (*(*v3 + v1))();
  }

  else
  {
    return v1(v3);
  }
}

uint64_t sub_10166CCD4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10166CD90(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F5E688;
  a2[1] = v2;
  return result;
}

void sub_10166CDBC(uint64_t a1, const StewieFeatureState *a2)
{
  v5 = 0;
  write_rest_value(a2);
  sub_10000501C(&__p, "/cc/props/stewie_feature_state");
  object = v5;
  if (v5)
  {
    xpc_retain(v5);
  }

  else
  {
    object = xpc_null_create();
  }

  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0)
  {
    operator delete(__p);
  }

  xpc_release(v5);
}

void sub_10166CE60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0)
  {
    operator delete(__p);
  }

  xpc_release(*(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10166CEA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166CF6C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5E718;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166CFA4(void *a1, xpc *this, BOOL a3)
{
  v4 = a1[1];
  v5 = *v4;
  *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  return v6(v8, v5);
}

uint64_t sub_10166D03C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166D104(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5E798;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166D13C(void *a1, xpc_object_t *a2)
{
  v4 = a1[1];
  v5 = *v4;
  type = xpc_get_type(*a2);
  if (type == &_xpc_type_string)
  {
    v14 = *v4;
    ctu::rest::detail::read_enum_string_value(&v14, a2, v7);
    *v4 = v14;
  }

  else if (type == &_xpc_type_BOOL || type == &_xpc_type_int64 || type == &_xpc_type_uint64)
  {
    *v4 = xpc::dyn_cast_or_default(a2, 0, v7);
  }

  v10 = a1[3];
  v11 = a1[4];
  v12 = (a1[2] + (v11 >> 1));
  if (v11)
  {
    v10 = *(*v12 + v10);
  }

  return v10(v12, v5);
}

uint64_t sub_10166D234(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166D2FC(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5E818;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166D334(uint64_t a1, const xpc::object *a2)
{
  read_rest_value(*(a1 + 8), a2);
  v3 = *(a1 + 24);
  v4 = *(a1 + 32);
  v5 = (*(a1 + 16) + (v4 >> 1));
  if (v4)
  {
    v3 = *(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10166D3B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166D478(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5E898;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166D4B0(uint64_t a1, const xpc::object *a2)
{
  read_rest_value(*(a1 + 8), a2);
  v3 = *(a1 + 24);
  v4 = *(a1 + 32);
  v5 = (*(a1 + 16) + (v4 >> 1));
  if (v4)
  {
    v3 = *(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10166D52C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166D5F4(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5E918;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166D62C(void *a1, xpc_object_t *a2)
{
  v4 = a1[1];
  v5 = *v4;
  type = xpc_get_type(*a2);
  if (type == &_xpc_type_string)
  {
    v14 = *v4;
    ctu::rest::detail::read_enum_string_value(&v14, a2, v7);
    *v4 = v14;
  }

  else if (type == &_xpc_type_BOOL || type == &_xpc_type_int64 || type == &_xpc_type_uint64)
  {
    *v4 = xpc::dyn_cast_or_default(a2, 0, v7);
  }

  v10 = a1[3];
  v11 = a1[4];
  v12 = (a1[2] + (v11 >> 1));
  if (v11)
  {
    v10 = *(*v12 + v10);
  }

  return v10(v12, v5);
}

uint64_t sub_10166D724(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166D7EC(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5E998;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_10166D824(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v4 = v3 + 1;
  v5 = v3[1];
  v9 = *v3;
  v10 = v5;
  if (v3[2])
  {
    *(v5 + 16) = &v10;
    *v3 = v4;
    *v4 = 0;
    v3[2] = 0;
  }

  else
  {
    v9 = &v10;
  }

  sub_10035A2E4(v3, a2);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  v6(v8, &v9);
  sub_100077CD4(&v9, v10);
}

uint64_t sub_10166D8FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166D9C4(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5EA18;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166D9FC(void *a1, xpc *this, uint64_t a3)
{
  v4 = a1[1];
  v5 = *v4;
  *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  return v6(v8, v5);
}

uint64_t sub_10166DA94(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166DB5C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5EA98;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166DB94(uint64_t *a1, xpc_object_t *a2)
{
  sub_100008A9C(a1[1], a2);
  v3 = a1[3];
  v4 = a1[4];
  v5 = (a1[2] + (v4 >> 1));
  if (v4)
  {
    v3 = *(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10166DC10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166DCD8(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5EB18;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166DD10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166DDD8(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5EB98;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166DE10(uint64_t *a1, xpc_object_t *a2)
{
  sub_1008E2524(a1[1], a2);
  v3 = a1[3];
  v4 = a1[4];
  v5 = (a1[2] + (v4 >> 1));
  if (v4)
  {
    v3 = *(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10166DE8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166DF54(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5EC18;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166DF8C(void *a1, xpc_object_t *a2)
{
  v4 = a1[1];
  v5 = *v4;
  type = xpc_get_type(*a2);
  if (type == &_xpc_type_string)
  {
    v14 = *v4;
    ctu::rest::detail::read_enum_string_value(&v14, a2, v7);
    *v4 = v14;
  }

  else if (type == &_xpc_type_BOOL || type == &_xpc_type_int64 || type == &_xpc_type_uint64)
  {
    *v4 = xpc::dyn_cast_or_default(a2, 0, v7);
  }

  v10 = a1[3];
  v11 = a1[4];
  v12 = (a1[2] + (v11 >> 1));
  if (v11)
  {
    v10 = *(*v12 + v10);
  }

  return v10(v12, v5);
}

uint64_t sub_10166E084(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166E14C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5EC98;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166E184(void *a1)
{
  rest::read_rest_value();
  v2 = a1[3];
  v3 = a1[4];
  v4 = (a1[2] + (v3 >> 1));
  if (v3)
  {
    v2 = *(*v4 + v2);
  }

  return v2(v4);
}

uint64_t sub_10166E200(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166E2C8(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5ED18;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_10166E300(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v4 = v3 + 1;
  v5 = v3[1];
  v9 = *v3;
  v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *v3 = v4;
    *v4 = 0;
    v3[2] = 0;
  }

  else
  {
    v9 = &v10;
  }

  sub_100AF1E40(v3, a2);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  v6(v8, &v9);
  sub_10006DCAC(&v9, v10);
}

uint64_t sub_10166E3D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166E4A0(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5ED98;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166E4D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166E5A0(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5EE18;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166E5D8(void *a1, xpc_object_t *a2)
{
  v4 = a1[1];
  v13 = *v4;
  type = xpc_get_type(*a2);
  if (type == &_xpc_type_string)
  {
    v14 = *v4;
    ctu::rest::detail::read_enum_string_value(&v14, a2, v6);
    *v4 = v14;
  }

  else if (type == &_xpc_type_BOOL || type == &_xpc_type_int64 || type == &_xpc_type_uint64)
  {
    *v4 = xpc::dyn_cast_or_default(a2, 0, v6);
  }

  v9 = a1[3];
  v10 = a1[4];
  v11 = (a1[2] + (v10 >> 1));
  if (v10)
  {
    v9 = *(*v11 + v9);
  }

  return v9(v11, &v13);
}

uint64_t sub_10166E6D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166E79C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5EE98;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166E7D4(uint64_t *a1, xpc_object_t *a2)
{
  sub_10151F9DC(a1[1], a2);
  v3 = a1[3];
  v4 = a1[4];
  v5 = (a1[2] + (v4 >> 1));
  if (v4)
  {
    v3 = *(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10166E850(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166E918(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5EF18;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166E950(void *a1, xpc *a2)
{
  v4 = a1[1];
  if (xpc_get_type(*a2) == &_xpc_type_null)
  {
    if (*(v4 + 1))
    {
      *(v4 + 1) = 0;
    }
  }

  else
  {
    if ((*(v4 + 1) & 1) == 0)
    {
      *v4 = 256;
    }

    *v4 = xpc::dyn_cast_or_default(a2, 0, v5);
  }

  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  return v6(v8);
}

uint64_t sub_10166EA18(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166EAE0(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5EF98;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10166EB18(void *a1, xpc *a2)
{
  v4 = a1[1];
  if (xpc_get_type(*a2) == &_xpc_type_null)
  {
    if (*(v4 + 1))
    {
      *(v4 + 1) = 0;
    }
  }

  else
  {
    if ((*(v4 + 1) & 1) == 0)
    {
      *v4 = 256;
    }

    *v4 = xpc::dyn_cast_or_default(a2, 0, v5);
  }

  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  return v6(v8);
}

uint64_t sub_10166EBE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10166EC9C(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F5F018;
  a2[1] = v2;
  return result;
}

void sub_10166ECC8(uint64_t a1)
{
  v1 = *(a1 + 8);
  v2 = *(v1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Timer to disconnect TryOut after screen lock expired", buf, 2u);
  }

  v3 = *(v1 + 2824);
  *(v1 + 2816) = 0u;
  if (v3)
  {
    sub_100004A34(v3);
  }

  v4 = 16;
  v5 = 2;
  v6 = 1;
  v7 = 1;
  sub_101665C5C(v1, &v4);
}

uint64_t sub_10166ED68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166EE2C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5F098;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  *(a2 + 20) = 0;
  return result;
}

void sub_10166EE60(uint64_t a1)
{
  v2 = *(a1 + 8);
  v3 = *(v2 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Timer to disconnect messaging after screen lock expired", buf, 2u);
  }

  v4 = *(v2 + 2768);
  *(v2 + 2760) = 0u;
  if (v4)
  {
    sub_100004A34(v4);
  }

  v5 = 16;
  v6 = *(a1 + 16);
  v7 = 1;
  v8 = 0;
  sub_101665C5C(v2, &v5);
}

uint64_t sub_10166EF10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10166EFD4(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5F118;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  *(a2 + 20) = 0;
  return result;
}

void sub_10166F008(uint64_t a1)
{
  v2 = *(a1 + 8);
  v3 = *(v2 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7) = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Timer to disconnect messaging after idle expired", &v7, 2u);
  }

  v4 = *(v2 + 2800);
  *(v2 + 2792) = 0u;
  if (v4)
  {
    sub_100004A34(v4);
  }

  if (*(v2 + 1936) != 1 || *(v2 + 1939) == 1 && *(v2 + 1937) == 1)
  {
    v5 = *(v2 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Display is OFF, exiting stewie", &v7, 2u);
    }

    v7 = 17;
    v8 = *(a1 + 16);
    v9 = 1;
    v10 = 0;
    sub_101665C5C(v2, &v7);
  }

  else
  {
    v6 = *(v2 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Display is ON, restarting timer", &v7, 2u);
    }

    sub_101666D5C(v2, 1);
  }
}

uint64_t sub_10166F164(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_10166F1D0(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F5F198;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10166F230(uint64_t a1, uint64_t a2)
{
  v3 = (a2 + 24);
  v4 = *(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(a1 + 24) = a1;
      (*(**v3 + 24))(*v3, a1);
      return a1;
    }

    *(a1 + 24) = v4;
  }

  else
  {
    v3 = (a1 + 24);
  }

  *v3 = 0;
  return a1;
}

uint64_t *sub_10166F2B0(uint64_t *a1)
{
  v1 = *a1;
  v57 = a1;
  v58 = v1;
  v2 = *v1;
  if ((*(*v1 + 2013) & 1) == 0)
  {
    v55 = *(v2 + 48);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v62[0]) = 0;
      _os_log_error_impl(&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v62, 2u);
    }

    sub_10000501C(v62, "Not ready to service request");
    sub_1016700F4(*(v1 + 160), 0);
    goto LABEL_69;
  }

  if (*(v1 + 48) != 1)
  {
    if (*(v1 + 8) != 1)
    {
      v9 = *(v1 + 132);
      if (v9 == 10 || v9 == 8)
      {
        (*(**(v2 + 2296) + 120))(v62);
        v11 = *v62;
        v62[0] = 0;
        v62[1] = 0;
        v12 = *(v1 + 120);
        *(v1 + 112) = v11;
        if (v12)
        {
          sub_100004A34(v12);
          if (v62[1])
          {
            sub_100004A34(v62[1]);
          }
        }
      }

      else if (v9 == 7 && !*(v1 + 96))
      {
        v20 = *(v2 + 24);
        if (v20)
        {
          v21 = *(v2 + 16);
          v22 = std::__shared_weak_count::lock(v20);
          if (v22)
          {
            v62[0] = v21;
            v62[1] = v22;
            atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_100004A34(v22);
            LOBYTE(v62[2]) = *(v1 + 8);
            LOBYTE(v62[3]) = 0;
            LOBYTE(v63) = 0;
            if (*(v1 + 40) == 1)
            {
              v23 = *(v1 + 16);
              v62[5] = *(v1 + 32);
              *&v62[3] = v23;
              *(v1 + 24) = 0;
              *(v1 + 32) = 0;
              *(v1 + 16) = 0;
              LOBYTE(v63) = 1;
            }

            WORD4(v63) = *(v1 + 48);
            v24 = *(v1 + 56);
            v65[0] = *(v1 + 72);
            *__p = v24;
            *(v1 + 64) = 0;
            *(v1 + 72) = 0;
            *(v1 + 56) = 0;
            *&v65[1] = *(v1 + 80);
            *&v65[3] = *(v1 + 96);
            *(v1 + 96) = 0;
            *(v1 + 104) = 0;
            *&v65[5] = *(v1 + 112);
            *(v1 + 112) = 0;
            *(v1 + 120) = 0;
            v65[7] = *(v1 + 128);
            sub_10166F230(&v66, v1 + 136);
            operator new();
          }
        }

        sub_100013CC4();
      }

      goto LABEL_48;
    }

LABEL_7:
    v6 = *(v1 + 132);
    if (v6 - 8 >= 3)
    {
      sub_10000501C(v62, "Offer is not supported for this request reason");
      sub_1016700F4(*(v1 + 160), 0);
      goto LABEL_69;
    }

    v7 = *(v2 + 128);
    if ((sub_100976D20(v6) & v7) != 0)
    {
      memset(v65, 0, 40);
      v63 = 0u;
      *__p = 0u;
      memset(v62, 0, sizeof(v62));
      v8 = *(v1 + 132);
      if (*(v1 + 79) < 0)
      {
        sub_100005F2C(buf, *(v1 + 56), *(v1 + 64));
      }

      else
      {
        *buf = *(v1 + 56);
        *&v61[0] = *(v1 + 72);
      }

      LODWORD(v62[0]) = v8;
      LOBYTE(v62[1]) = 0;
      LOBYTE(v62[4]) = 0;
      LOBYTE(v62[5]) = 0;
      BYTE2(v62[5]) = 0;
      LOBYTE(v63) = 0;
      BYTE8(v63) = 0;
      LOBYTE(v65[1]) = 0;
      *&v65[2] = *buf;
      v65[4] = *&v61[0];
      memset(buf, 0, sizeof(buf));
      *&v61[0] = 0;
      BYTE4(v62[0]) = 1;
      sub_10012BF3C(&v62[1], (v1 + 16));
      (*(**(v2 + 2080) + 16))(*(v2 + 2080), v62);
      if (SHIBYTE(v65[4]) < 0)
      {
        operator delete(v65[2]);
      }

      if (LOBYTE(v62[4]) == 1 && SHIBYTE(v62[3]) < 0)
      {
        operator delete(v62[1]);
      }

      goto LABEL_68;
    }

    goto LABEL_31;
  }

  v3 = (v1 + 56);
  v4 = *(v1 + 79);
  if (v4 < 0)
  {
    if (*(v1 + 64) != 19)
    {
      goto LABEL_28;
    }

    v5 = *v3;
  }

  else
  {
    v5 = (v1 + 56);
    if (v4 != 19)
    {
      goto LABEL_28;
    }
  }

  v13 = *v5;
  v14 = v5[1];
  v15 = *(v5 + 11);
  if (v13 != 0x697463656E6E6F63 || v14 != 0x7473697373416E6FLL || v15 != 0x746E617473697373)
  {
LABEL_28:
    v18 = *(v2 + 130);
    if ((sub_100976D20(*(v1 + 132)) & v18) != 0)
    {
      memset(v65, 0, 40);
      v63 = 0u;
      *__p = 0u;
      memset(v62, 0, sizeof(v62));
      v19 = *(v1 + 132);
      if (*(v1 + 79) < 0)
      {
        sub_100005F2C(buf, *(v1 + 56), *(v1 + 64));
      }

      else
      {
        *buf = *v3;
        *&v61[0] = *(v1 + 72);
      }

      LODWORD(v62[0]) = v19;
      BYTE4(v62[0]) = 0;
      LOBYTE(v62[1]) = 0;
      LOBYTE(v62[4]) = 0;
      BYTE2(v62[5]) = 0;
      LOBYTE(v63) = 0;
      BYTE8(v63) = 0;
      LOBYTE(v65[1]) = 0;
      *&v65[2] = *buf;
      v65[4] = *&v61[0];
      memset(buf, 0, sizeof(buf));
      *&v61[0] = 0;
      v25 = *(v2 + 2080);
      v26 = *v25;
      LOBYTE(v62[5]) = 1;
      (*(v26 + 16))(v25, v62);
      if (SHIBYTE(v65[4]) < 0)
      {
        operator delete(v65[2]);
      }

      if (LOBYTE(v62[4]) == 1 && SHIBYTE(v62[3]) < 0)
      {
        operator delete(v62[1]);
      }

      goto LABEL_68;
    }

LABEL_31:
    sub_10000501C(v62, "Stewie is not permitted right now");
    sub_1016700F4(*(v1 + 160), 0);
    goto LABEL_69;
  }

  if (*(v1 + 8))
  {
    goto LABEL_7;
  }

LABEL_48:
  memset(v61, 0, sizeof(v61));
  *buf = 0u;
  v27 = *(v2 + 2280);
  v28 = (*(**(v2 + 2264) + 80))(*(v2 + 2264));
  (*(*v27 + 32))(buf, v27, v1 + 8, v28);
  if (buf[1] == 1)
  {
    v29 = *(v2 + 48);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v62[0]) = 0;
      _os_log_impl(&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Awaiting user action...", v62, 2u);
    }

    goto LABEL_68;
  }

  StewieController::submitStewieRequestMetric(v2, *(v1 + 132), *(v1 + 48), buf[0]);
  Registry::getTimerService(v62, *(v2 + 1976));
  v30 = (**v62[0])(v62[0]);
  if ((*(v2 + 2872) & 1) == 0)
  {
    *(v2 + 2872) = 1;
  }

  *(v2 + 2864) = v30;
  if (v62[1])
  {
    sub_100004A34(v62[1]);
  }

  if (buf[0])
  {
    if (buf[4] == 1)
    {
LABEL_68:
      sub_10000501C(v62, "");
      sub_1016700F4(*(v1 + 160), 1);
      goto LABEL_69;
    }

    if (buf[9] == 1)
    {
      isServiceActive = StewieFeatureState::isServiceActive();
      if (*(v1 + 48))
      {
        v34 = 5;
      }

      else
      {
        v34 = *(v1 + 132);
      }

      v40 = *(v2 + 2080);
      v41 = buf[7];
      v42 = buf[8];
      if (isServiceActive)
      {
        v43 = 65544;
      }

      else
      {
        v43 = 0;
      }

      if (*(v1 + 79) < 0)
      {
        sub_100005F2C(&__dst, *(v1 + 56), *(v1 + 64));
      }

      else
      {
        __dst = *(v1 + 56);
      }

      LODWORD(v62[0]) = v34;
      BYTE4(v62[0]) = 0;
      LOBYTE(v62[1]) = 0;
      LOBYTE(v62[4]) = 0;
      LOBYTE(v62[5]) = 0;
      BYTE2(v62[5]) = v41;
      BYTE3(v62[5]) = v42;
      HIDWORD(v62[5]) = v43;
      LOBYTE(v63) = 1;
      BYTE8(v63) = 0;
      LOBYTE(v65[1]) = 0;
      *&v65[2] = __dst;
      memset(&__dst, 0, sizeof(__dst));
      (*(*v40 + 16))(v40, v62);
      sub_101356A00(v62);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }

      LODWORD(v62[0]) = 1;
      WORD2(v62[0]) = 8;
      goto LABEL_112;
    }

    if (BYTE8(v61[1]) == 1)
    {
      v35 = StewieFeatureState::isServiceActive();
      v36 = v35;
      if (*(v1 + 48))
      {
        v37 = 5;
      }

      else
      {
        v37 = *(v1 + 132);
      }

      v45 = *(v2 + 2080);
      v46 = v61[0];
      v47 = BYTE1(v61[0]);
      v48 = *(v61 + 8);
      if (v35)
      {
        v49 = 0x10000;
      }

      else
      {
        v49 = 0;
      }

      if (*(v1 + 79) < 0)
      {
        v56 = *(v61 + 8);
        sub_100005F2C(&__dst, *(v1 + 56), *(v1 + 64));
        v48 = v56;
      }

      else
      {
        __dst = *(v1 + 56);
      }

      LODWORD(v62[0]) = v37;
      BYTE4(v62[0]) = 0;
      LOBYTE(v62[1]) = 0;
      LOBYTE(v62[4]) = 0;
      LOBYTE(v62[5]) = 0;
      BYTE2(v62[5]) = 0;
      LOBYTE(v63) = 0;
      BYTE8(v63) = v46;
      BYTE9(v63) = v47;
      *__p = v48;
      LODWORD(v65[0]) = v49 | v36;
      LOBYTE(v65[1]) = 1;
      *&v65[2] = __dst;
      memset(&__dst, 0, sizeof(__dst));
      (*(*v45 + 16))(v45, v62);
      sub_101356A00(v62);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }

      LODWORD(v62[0]) = 1;
      WORD2(v62[0]) = 1;
LABEL_112:
      BYTE6(v62[0]) = 1;
      LOBYTE(v62[1]) = 0;
      sub_101667734(v2);
    }

    v38 = *(v2 + 48);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v62[0]) = 0;
      _os_log_impl(&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I No conversation info was provided", v62, 2u);
    }

    if (*(v1 + 48))
    {
      v39 = 5;
    }

    else
    {
      v39 = *(v1 + 132);
    }

    v44 = *(v2 + 2080);
    if (*(v1 + 79) < 0)
    {
      sub_100005F2C(&__dst, *(v1 + 56), *(v1 + 64));
    }

    else
    {
      __dst = *(v1 + 56);
    }

    LODWORD(v62[0]) = v39;
    BYTE4(v62[0]) = 0;
    LOBYTE(v62[1]) = 0;
    LOBYTE(v62[4]) = 0;
    LOBYTE(v62[5]) = 0;
    BYTE2(v62[5]) = 0;
    LOBYTE(v63) = 0;
    BYTE8(v63) = 0;
    LOBYTE(v65[1]) = 0;
    *&v65[2] = __dst;
    memset(&__dst, 0, sizeof(__dst));
    (*(*v44 + 16))(v44, v62);
    sub_101356A00(v62);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }

    if (*(v2 + 2041) != 1)
    {
      *(v2 + 2041) = 1;
      sub_1016701C0();
    }

    sub_10000501C(v62, "");
    sub_1016700F4(*(v1 + 160), 1);
  }

  else
  {
    v31 = *(v2 + 48);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      v50 = sub_100976680(*(v1 + 132));
      sub_10097642C(*&buf[2], &__dst);
      v51 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
      v52 = __dst.__r_.__value_.__r.__words[0];
      v53 = asStringBool(*(v1 + 48));
      p_dst = &__dst;
      LODWORD(v62[0]) = 136315650;
      if (v51 < 0)
      {
        p_dst = v52;
      }

      *(v62 + 4) = v50;
      WORD2(v62[1]) = 2082;
      *(&v62[1] + 6) = p_dst;
      HIWORD(v62[2]) = 2080;
      v62[3] = v53;
      _os_log_error_impl(&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Request for reason: %s failed, requested services: %{public}s, isTryOut: %s", v62, 0x20u);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }

    sub_10000501C(v62, "Stewie is not permitted right now");
    sub_1016700F4(*(v1 + 160), 0);
  }

LABEL_69:
  if (SHIBYTE(v62[2]) < 0)
  {
    operator delete(v62[0]);
  }

  sub_101670060(&v58);
  return sub_1000049E0(&v57);
}

void sub_10166FFA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *__p, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
  }

  sub_101670060(&a12);
  sub_1000049E0(&a11);
  _Unwind_Resume(a1);
}

uint64_t *sub_101670060(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100DD6D4C(v1 + 136);
    v2 = *(v1 + 120);
    if (v2)
    {
      sub_100004A34(v2);
    }

    v3 = *(v1 + 104);
    if (v3)
    {
      sub_100004A34(v3);
    }

    if (*(v1 + 79) < 0)
    {
      operator delete(*(v1 + 56));
    }

    if (*(v1 + 40) == 1 && *(v1 + 39) < 0)
    {
      operator delete(*(v1 + 16));
    }

    operator delete();
  }

  return result;
}

uint64_t sub_1016700F4(uint64_t a1, char a2)
{
  v3 = a2;
  if (!a1)
  {
    sub_100022DB4();
  }

  return (*(*a1 + 48))(a1, &v3);
}

uint64_t sub_101670144(uint64_t a1)
{
  sub_100DD6D4C(a1 + 144);
  v2 = *(a1 + 128);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(a1 + 112);
  if (v3)
  {
    sub_100004A34(v3);
  }

  if (*(a1 + 87) < 0)
  {
    operator delete(*(a1 + 64));
  }

  if (*(a1 + 48) == 1 && *(a1 + 47) < 0)
  {
    operator delete(*(a1 + 24));
  }

  v4 = *(a1 + 8);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }

  return a1;
}

void sub_1016701C0()
{
  sub_10000501C(&__p, "/cc/events/stewie_requested_event");
  object = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0)
  {
    operator delete(__p);
  }
}

void sub_101670230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_101670260(uint64_t a1)
{
  *a1 = off_101F5F1E8;
  sub_100DD6D4C(a1 + 152);
  v2 = *(a1 + 136);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(a1 + 120);
  if (v3)
  {
    sub_100004A34(v3);
  }

  if (*(a1 + 95) < 0)
  {
    operator delete(*(a1 + 72));
  }

  if (*(a1 + 56) == 1 && *(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }

  return a1;
}

void sub_1016702F4(uint64_t a1)
{
  *a1 = off_101F5F1E8;
  sub_100DD6D4C(a1 + 152);
  v2 = *(a1 + 136);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(a1 + 120);
  if (v3)
  {
    sub_100004A34(v3);
  }

  if (*(a1 + 95) < 0)
  {
    operator delete(*(a1 + 72));
  }

  if (*(a1 + 56) == 1 && *(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete();
}

void sub_10167044C(uint64_t a1)
{
  sub_100DD6D4C(a1 + 152);
  v2 = *(a1 + 136);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(a1 + 120);
  if (v3)
  {
    sub_100004A34(v3);
  }

  if (*(a1 + 95) < 0)
  {
    operator delete(*(a1 + 72));
  }

  if (*(a1 + 56) == 1 && *(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  v4 = *(a1 + 16);
  if (v4)
  {

    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_1016704DC(uint64_t a1)
{
  sub_100DD6D4C(a1 + 152);
  v2 = *(a1 + 136);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(a1 + 120);
  if (v3)
  {
    sub_100004A34(v3);
  }

  if (*(a1 + 95) < 0)
  {
    operator delete(*(a1 + 72));
  }

  if (*(a1 + 56) == 1 && *(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete(a1);
}

void sub_101670568(uint64_t a1, uint64_t *a2)
{
  v3 = *(a1 + 16);
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = *(a1 + 8);
      if (v6)
      {
        v7 = *a2;
        if (*a2 && *(v7 + 16))
        {
          v8 = a2[1];
          *a2 = 0;
          a2[1] = 0;
          v9 = *(a1 + 120);
          *(a1 + 112) = v7;
          *(a1 + 120) = v8;
          if (v9)
          {
            sub_100004A34(v9);
          }

          sub_1016674AC(v6, (a1 + 24), a1 + 152);
        }

        ctu::OsLogContext::OsLogContext(__p, kCtLoggingSystemName, "stw.ctr");
        v10 = __p[1];
        ctu::OsLogContext::~OsLogContext(__p);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p[0]) = 0;
          _os_log_error_impl(&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No roadside providers found! Failing request for Roadside assitance", __p, 2u);
        }

        sub_10000501C(__p, "No roadside providers found!");
        sub_1016700F4(*(a1 + 176), 0);
        if (v12 < 0)
        {
          operator delete(__p[0]);
        }

LABEL_18:
        sub_100004A34(v5);
        return;
      }
    }
  }

  else
  {
    v5 = 0;
  }

  sub_10000501C(__p, "Failed to process request");
  sub_1016700F4(*(a1 + 176), 0);
  if (v12 < 0)
  {
    operator delete(__p[0]);
  }

  if (v5)
  {
    goto LABEL_18;
  }
}

void sub_1016706CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  sub_100004A34(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_101670720(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_10167076C(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 8);
  *a1 = *a2;
  *(a1 + 8) = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 16), 1uLL, memory_order_relaxed);
  }

  *(a1 + 16) = *(a2 + 16);
  sub_10006F264(a1 + 24, (a2 + 24));
  *(a1 + 56) = *(a2 + 56);
  if (*(a2 + 87) < 0)
  {
    sub_100005F2C((a1 + 64), *(a2 + 64), *(a2 + 72));
  }

  else
  {
    v5 = *(a2 + 64);
    *(a1 + 80) = *(a2 + 80);
    *(a1 + 64) = v5;
  }

  *(a1 + 88) = *(a2 + 88);
  v6 = *(a2 + 112);
  *(a1 + 104) = *(a2 + 104);
  *(a1 + 112) = v6;
  if (v6)
  {
    atomic_fetch_add_explicit((v6 + 8), 1uLL, memory_order_relaxed);
  }

  v7 = *(a2 + 128);
  *(a1 + 120) = *(a2 + 120);
  *(a1 + 128) = v7;
  if (v7)
  {
    atomic_fetch_add_explicit((v7 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 136) = *(a2 + 136);
  v8 = *(a2 + 168);
  if (v8)
  {
    if (v8 == a2 + 144)
    {
      *(a1 + 168) = a1 + 144;
      (*(**(a2 + 168) + 24))(*(a2 + 168));
      return a1;
    }

    v8 = (*(*v8 + 16))(v8);
  }

  *(a1 + 168) = v8;
  return a1;
}

void sub_1016708AC(_Unwind_Exception *exception_object)
{
  if (*(v1 + 48) == 1 && *(v1 + 47) < 0)
  {
    operator delete(*(v2 + 8));
  }

  v4 = *(v1 + 8);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016708F8(uint64_t **a1)
{
  v1 = a1;
  sub_101665C5C(**a1, *a1 + 2);
  operator delete();
}

uint64_t *sub_10167097C(void **a1)
{
  v1 = *a1;
  v6 = a1;
  v7 = v1;
  v2 = *v1;
  if (*(*v1 + 2013))
  {
    (*(**(v2 + 2080) + 32))(*(v2 + 2080), v1 + 1);
  }

  else
  {
    v4 = *(v2 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }

    *buf = 0;
    v9 = 0;
    v5 = v1[4];
    if (!v5)
    {
      sub_100022DB4();
    }

    (*(*v5 + 48))(v5, buf);
    if (v9)
    {
      sub_100004A34(v9);
    }
  }

  sub_101670AAC(&v7);
  return sub_1000049E0(&v6);
}

void sub_101670A7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    sub_100004A34(a12);
  }

  sub_101670AAC(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101670AAC(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100DD7078(v1 + 8);
    operator delete();
  }

  return result;
}

void sub_101670AFC(uint64_t **a1)
{
  v1 = *a1;
  v2 = **a1;
  if (*(v2 + 2013))
  {
    (*(**(v2 + 2280) + 152))(*(v2 + 2280), v1 + 1);
    (*(**(v2 + 2080) + 96))(*(v2 + 2080), v1 + 1);
  }

  else
  {
    v3 = *(v2 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
  }

  operator delete();
}

uint64_t *sub_101670C18(unsigned __int16 **a1)
{
  v1 = *a1;
  v5 = a1;
  v6 = v1;
  v2 = *(v1 + 1);
  if (*(v2 + 2013))
  {
    (*(**(v2 + 2280) + 56))(*(v2 + 2280), *v1, v1 + 8, v1 + 20);
  }

  else
  {
    v4 = *(v2 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
  }

  sub_101670CF0(&v6);
  return sub_1000049E0(&v5);
}

void sub_101670CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_101670CF0(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101670CF0(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100DD7CE0(v1 + 40);
    v2 = *(v1 + 16);
    if (v2)
    {
      *(v1 + 24) = v2;
      operator delete(v2);
    }

    operator delete();
  }

  return result;
}

void sub_101670D50(uint64_t **a1)
{
  v1 = **a1;
  if (*(v1 + 2013))
  {
    (*(**(v1 + 2080) + 56))(*(v1 + 2080), *(*a1 + 2));
  }

  else
  {
    v2 = *(v1 + 48);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
  }

  operator delete();
}

uint64_t sub_101670E40(uint64_t a1, uint64_t a2)
{
  v3 = (a2 + 24);
  v4 = *(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(a1 + 24) = a1;
      (*(**v3 + 24))(*v3, a1);
      return a1;
    }

    *(a1 + 24) = v4;
  }

  else
  {
    v3 = (a1 + 24);
  }

  *v3 = 0;
  return a1;
}

uint64_t *sub_101670EC0(void **a1)
{
  v1 = *a1;
  v13 = a1;
  v14 = v1;
  v2 = *v1;
  if ((*(*v1 + 2013) & 1) == 0)
  {
    v11 = *(v2 + 48);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }

    *buf = 0;
    *&v18 = 0;
    v12 = v1[4];
    if (!v12)
    {
      sub_100022DB4();
    }

    (*(*v12 + 48))(v12, buf);
    v6 = v18;
    if (v18)
    {
      goto LABEL_23;
    }

    goto LABEL_24;
  }

  dispatch_assert_queue_V2(*(v2 + 32));
  v3 = 2472;
  if (*(v2 + 2570))
  {
    v3 = 2568;
  }

  v4 = v2 + v3;
  v5 = *(v2 + v3 + 8);
  v6 = *(v4 + 16);
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    if (v5)
    {
      *buf = v5;
      *&v18 = v6;
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      goto LABEL_9;
    }

LABEL_13:
    v8 = *(v2 + 2264);
    sub_10000501C(__p, "");
    (*(*v8 + 120))(buf, v8, __p);
    v20 = v18;
    v18 = 0uLL;
    v9 = v1[4];
    if (!v9)
    {
      sub_100022DB4();
    }

    (*(*v9 + 48))(v9, &v20);
    if (*(&v20 + 1))
    {
      sub_100004A34(*(&v20 + 1));
    }

    if (v19)
    {
      sub_100004A34(v19);
    }

    if (*(&v18 + 1))
    {
      sub_100004A34(*(&v18 + 1));
    }

    if (v16 < 0)
    {
      operator delete(__p[0]);
    }

    goto LABEL_22;
  }

  if (!v5)
  {
    goto LABEL_13;
  }

  *buf = v5;
  *&v18 = 0;
LABEL_9:
  v7 = v1[4];
  if (!v7)
  {
    sub_100022DB4();
  }

  (*(*v7 + 48))(v7, buf);
  if (v18)
  {
    sub_100004A34(v18);
    if (!v6)
    {
      goto LABEL_24;
    }

    goto LABEL_23;
  }

LABEL_22:
  if (v6)
  {
LABEL_23:
    sub_100004A34(v6);
  }

LABEL_24:
  sub_101671180(&v14);
  return sub_1000049E0(&v13);
}

void sub_1016710FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, std::__shared_weak_count *a19)
{
  if (a19)
  {
    sub_100004A34(a19);
  }

  sub_101671180(&a11);
  sub_1000049E0(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_101671180(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100DD8700(v1 + 8);
    operator delete();
  }

  return result;
}

uint64_t sub_1016711D0(uint64_t a1, uint64_t a2)
{
  v3 = (a2 + 24);
  v4 = *(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(a1 + 24) = a1;
      (*(**v3 + 24))(*v3, a1);
      return a1;
    }

    *(a1 + 24) = v4;
  }

  else
  {
    v3 = (a1 + 24);
  }

  *v3 = 0;
  return a1;
}

uint64_t *sub_101671250(void **a1)
{
  v1 = *a1;
  v13 = a1;
  v14 = v1;
  v2 = *v1;
  if ((*(*v1 + 2013) & 1) == 0)
  {
    v12 = *(v2 + 48);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }

    *buf = 0;
    v18 = 0;
    v11 = v1[6];
    if (!v11)
    {
      sub_100022DB4();
    }

LABEL_19:
    (*(*v11 + 48))(v11, buf);
    v8 = v18;
    if (!v18)
    {
      goto LABEL_15;
    }

    goto LABEL_14;
  }

  if (!v1[1])
  {
    v10 = *(v2 + 48);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Context is missing", buf, 2u);
    }

    *buf = 0;
    v18 = 0;
    v11 = v1[6];
    if (!v11)
    {
      sub_100022DB4();
    }

    goto LABEL_19;
  }

  v32 = 0;
  v33 = 0;
  (*(**(v2 + 2280) + 192))(&v32);
  if (v32 && v32[1] == 1)
  {
    v3 = *(v2 + 2080);
    v4 = *v32;
    v5 = *(v32 + 1);
    v6 = *(v32 + 2);
    sub_10000501C(v15, "connectionAssistant");
    *buf = 7;
    buf[4] = 0;
    LOBYTE(v18) = 0;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v24 = v4;
    v25 = 1;
    v26 = v5;
    v27 = v6;
    v28 = 0;
    v29 = 1;
    v31 = v16;
    *__p = *v15;
    v15[0] = 0;
    v15[1] = 0;
    v16 = 0;
    (*(*v3 + 16))(v3, buf);
    if (SHIBYTE(v31) < 0)
    {
      operator delete(__p[0]);
    }

    if (v20 == 1 && v19 < 0)
    {
      operator delete(v18);
    }

    if (SHIBYTE(v16) < 0)
    {
      operator delete(v15[0]);
    }
  }

  v7 = v1[6];
  if (!v7)
  {
    sub_100022DB4();
  }

  (*(*v7 + 48))(v7, &v32);
  v8 = v33;
  if (v33)
  {
LABEL_14:
    sub_100004A34(v8);
  }

LABEL_15:
  sub_101671580(&v14);
  return sub_1000049E0(&v13);
}

void sub_101671518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, std::__shared_weak_count *a19)
{
  if (a19)
  {
    sub_100004A34(a19);
  }

  sub_101671580(&a11);
  sub_1000049E0(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_101671580(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100DD8A58(v1 + 24);
    v2 = *(v1 + 16);
    if (v2)
    {
      sub_100004A34(v2);
    }

    operator delete();
  }

  return result;
}

uint64_t sub_1016715DC(uint64_t a1, uint64_t a2)
{
  v3 = (a2 + 24);
  v4 = *(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(a1 + 24) = a1;
      (*(**v3 + 24))(*v3, a1);
      return a1;
    }

    *(a1 + 24) = v4;
  }

  else
  {
    v3 = (a1 + 24);
  }

  *v3 = 0;
  return a1;
}

uint64_t *sub_10167165C(void **a1)
{
  v1 = *a1;
  v6 = a1;
  v7 = v1;
  v2 = *v1;
  if (*(*v1 + 2013))
  {
    (*(**(v2 + 2280) + 200))(buf);
    v10 = 1;
    v3 = v1[4];
    if (!v3)
    {
      sub_100022DB4();
    }
  }

  else
  {
    v5 = *(v2 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }

    *buf = 0;
    v9 = 0;
    v10 = 0;
    v3 = v1[4];
    if (!v3)
    {
      sub_100022DB4();
    }
  }

  (*(*v3 + 48))(v3, &v10, buf);
  if (v9)
  {
    sub_100004A34(v9);
  }

  sub_1016717DC(&v7);
  return sub_1000049E0(&v6);
}

void sub_1016717A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    sub_100004A34(a12);
  }

  sub_1016717DC(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1016717DC(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100DD8D78(v1 + 8);
    operator delete();
  }

  return result;
}

uint64_t *sub_10167182C(void **a1)
{
  v1 = *a1;
  v6 = a1;
  v7 = v1;
  v2 = *v1;
  if (*(*v1 + 2013))
  {
    (*(**(v2 + 2080) + 40))(*(v2 + 2080), v1 + 1);
  }

  else
  {
    v4 = *(v2 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }

    *buf = 0;
    v9 = 0;
    v5 = v1[4];
    if (!v5)
    {
      sub_100022DB4();
    }

    (*(*v5 + 48))(v5, buf);
    if (v9)
    {
      sub_100004A34(v9);
    }
  }

  sub_10167195C(&v7);
  return sub_1000049E0(&v6);
}

void sub_10167192C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    sub_100004A34(a12);
  }

  sub_10167195C(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10167195C(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100DD7374(v1 + 8);
    operator delete();
  }

  return result;
}

uint64_t *sub_1016719AC(void **a1)
{
  v1 = *a1;
  v6 = a1;
  v7 = v1;
  v2 = *v1;
  if (*(*v1 + 2013))
  {
    (*(**(v2 + 2080) + 48))(*(v2 + 2080), v1 + 1);
  }

  else
  {
    v4 = *(v2 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }

    *buf = 0;
    v9 = 0;
    v5 = v1[4];
    if (!v5)
    {
      sub_100022DB4();
    }

    (*(*v5 + 48))(v5, buf);
    if (v9)
    {
      sub_100004A34(v9);
    }
  }

  sub_101671ADC(&v7);
  return sub_1000049E0(&v6);
}

void sub_101671AAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    sub_100004A34(a12);
  }

  sub_101671ADC(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101671ADC(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100DD7670(v1 + 8);
    operator delete();
  }

  return result;
}

uint64_t *sub_101671B2C(uint64_t *a1)
{
  v1 = *a1;
  v9 = a1;
  v10 = v1;
  v2 = *v1;
  if (*(*v1 + 2013))
  {
    v3 = *(v1 + 8);
    if (*(v2 + 2042) == v3)
    {
      sub_10000501C(buf, "");
      sub_1016700F4(*(v1 + 40), 1);
      goto LABEL_16;
    }

    v4 = *(v2 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = "unblocked";
      if (v3)
      {
        v5 = "blocked. Stewie won't be allowed until process is restarted.";
      }

      *buf = 136315138;
      *&buf[4] = v5;
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Stewie is %s", buf, 0xCu);
      LOBYTE(v3) = *(v1 + 8);
    }

    if (v3)
    {
      if (*(v2 + 2041) == 1)
      {
        *buf = 3;
        buf[4] = 0;
        buf[6] = 0;
        buf[8] = 1;
        sub_101665C5C(v2, buf);
        sub_10000501C(buf, "");
        sub_1016700F4(*(v1 + 40), 1);
        goto LABEL_16;
      }

      *(v2 + 2042) = v3;
      v6 = *(v2 + 48);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *buf = 0;
        _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Presenting popup: device lost access to network", buf, 2u);
      }

      sub_100F38CC4((v2 + 1976), @"BIFROST_DISABLED_BY_NETWORK_OVER_INTERNET_TITLE", @"BIFROST_DISABLED_BY_NETWORK_OVER_INTERNET_MESSAGE");
    }

    else
    {
      *(v2 + 2042) = v3;
    }

    sub_10166491C(v2);
    sub_10000501C(buf, "");
    sub_1016700F4(*(v1 + 40), 1);
  }

  else
  {
    v8 = *(v2 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }

    sub_10000501C(buf, "Not ready to service request");
    sub_1016700F4(*(v1 + 40), 0);
  }

LABEL_16:
  if (v12 < 0)
  {
    operator delete(*buf);
  }

  sub_101671DD4(&v10);
  return sub_1000049E0(&v9);
}

void sub_101671D94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
  {
    operator delete(__p);
  }

  sub_101671DD4(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101671DD4(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100DD6D4C(v1 + 16);
    operator delete();
  }

  return result;
}

uint64_t *sub_101671E24(uint64_t **a1)
{
  v2 = a1;
  v3 = *a1;
  sub_101671E84(v3);
  sub_101673C64(&v3);
  return sub_1000049E0(&v2);
}

void sub_101671E68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_101673C64(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_101671E84(uint64_t *a1)
{
  v2 = *a1;
  if ((*(*a1 + 2013) & 1) == 0)
  {
    v79 = *(v2 + 48);
    if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v88[0]) = 0;
      _os_log_error_impl(&_mh_execute_header, v79, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v88, 2u);
    }

    sub_10000501C(v88, "StewieInterface is down");
    sub_1014CAAAC((a1 + 2), v88, 0);
    if (SBYTE7(v89) < 0)
    {
      operator delete(v88[0]);
    }

    return;
  }

  v96[0] = 0;
  v3 = a1 + 1;
  v88[0] = a1 + 1;
  v88[1] = "service-info";
  sub_100048A24(v88, v96);
  if (xpc_get_type(v96[0]) != &_xpc_type_dictionary)
  {
    goto LABEL_3;
  }

  v88[0] = 0;
  v88[1] = 0;
  DWORD2(v89) = 0;
  *&v89 = 0;
  v95 = 0;
  __p[0] = v96;
  __p[1] = "connectionStatus";
  sub_100006354(__p, &v95);
  if (xpc_get_type(v95) != &_xpc_type_null)
  {
    if (xpc_get_type(v95) != &_xpc_type_string)
    {
      sub_10000501C(__p, "service-info: connectionStatus - invalid format, string expected");
      sub_1014CAAAC((a1 + 2), __p, 0);
      if (SHIBYTE(v83) < 0)
      {
        v5 = __p[0];
LABEL_59:
        operator delete(v5);
      }

LABEL_137:
      xpc_release(v95);
LABEL_168:
      v4 = 0;
      goto LABEL_169;
    }

    v93 = 0uLL;
    v94 = 0;
    object = v95;
    if (v95)
    {
      xpc_retain(v95);
    }

    else
    {
      object = xpc_null_create();
    }

    __p[0] = 0;
    __p[1] = 0;
    v83 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v83) < 0)
    {
      operator delete(__p[0]);
    }

    xpc_release(object);
    if ((v94 & 0x8000000000000000) == 0)
    {
      if (HIBYTE(v94) != 6)
      {
        if (HIBYTE(v94) != 7)
        {
          if (HIBYTE(v94) == 9)
          {
            v6 = &v93;
LABEL_51:
            v15 = *v6;
            v16 = *(v6 + 8);
            if (v15 != 0x657463656E6E6F63 || v16 != 100)
            {
              goto LABEL_55;
            }

            v12 = 3;
            goto LABEL_64;
          }

          goto LABEL_55;
        }

        if (v93 != 1852534389 || *(&v93 + 3) != 1853321070)
        {
          if (v93 != 1668184435 || *(&v93 + 3) != 1735289187)
          {
            goto LABEL_55;
          }

          goto LABEL_38;
        }

LABEL_62:
        LODWORD(v88[0]) = 0;
        goto LABEL_65;
      }

      if (v93 != 1668184435 || WORD2(v93) != 25701)
      {
        goto LABEL_55;
      }

LABEL_63:
      v12 = 2;
      goto LABEL_64;
    }

    v7 = *(&v93 + 1);
    if (*(&v93 + 1) == 6)
    {
      if (*v93 == 1668184435 && *(v93 + 4) == 25701)
      {
        goto LABEL_63;
      }
    }

    else
    {
      if (*(&v93 + 1) == 7)
      {
        if (*v93 == 1852534389 && *(v93 + 3) == 1853321070)
        {
          goto LABEL_62;
        }

        if (*v93 == 1668184435 && *(v93 + 3) == 1735289187)
        {
LABEL_38:
          v12 = 1;
LABEL_64:
          LODWORD(v88[0]) = v12;
LABEL_65:
          if (v94 < 0)
          {
            operator delete(v93);
          }

          goto LABEL_67;
        }
      }

      v7 = *(&v93 + 1);
    }

    if (v7 == 9)
    {
      v6 = v93;
      goto LABEL_51;
    }

LABEL_55:
    sub_10000501C(__p, "service-info: connectionStatus - invalid value");
    sub_1014CAAAC((a1 + 2), __p, 0);
    if (SHIBYTE(v83) < 0)
    {
      operator delete(__p[0]);
    }

    if ((SHIBYTE(v94) & 0x80000000) == 0)
    {
      goto LABEL_137;
    }

    v5 = v93;
    goto LABEL_59;
  }

LABEL_67:
  xpc_release(v95);
  v95 = 0;
  __p[0] = v96;
  __p[1] = "registrationStatus";
  sub_100006354(__p, &v95);
  if (xpc_get_type(v95) == &_xpc_type_null)
  {
    goto LABEL_121;
  }

  if (xpc_get_type(v95) != &_xpc_type_string)
  {
    sub_10000501C(__p, "service-info: registrationStatus - invalid format, string expected");
    sub_1014CAAAC((a1 + 2), __p, 0);
    if ((SHIBYTE(v83) & 0x80000000) == 0)
    {
      goto LABEL_137;
    }

    v18 = __p[0];
LABEL_115:
    operator delete(v18);
    goto LABEL_137;
  }

  v93 = 0uLL;
  v94 = 0;
  object = v95;
  if (v95)
  {
    xpc_retain(v95);
  }

  else
  {
    object = xpc_null_create();
  }

  __p[0] = 0;
  __p[1] = 0;
  v83 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v83) < 0)
  {
    operator delete(__p[0]);
  }

  xpc_release(object);
  if (v94 < 0)
  {
    if (*(&v93 + 1) == 7)
    {
      if (*v93 == 1852534389 && *(v93 + 3) == 1853321070)
      {
        goto LABEL_118;
      }
    }

    else if (*(&v93 + 1) == 13 && *v93 == 0x7369676552746F6ELL && *(v93 + 5) == 0x6465726574736967)
    {
LABEL_93:
      v21 = 1;
      goto LABEL_119;
    }

    if (*(&v93 + 1) != 10)
    {
LABEL_111:
      sub_10000501C(__p, "service-info: registrationStatus - invalid value");
      sub_1014CAAAC((a1 + 2), __p, 0);
      if (SHIBYTE(v83) < 0)
      {
        operator delete(__p[0]);
      }

      if ((SHIBYTE(v94) & 0x80000000) == 0)
      {
        goto LABEL_137;
      }

      v18 = v93;
      goto LABEL_115;
    }

    v22 = v93;
    goto LABEL_107;
  }

  if (HIBYTE(v94) != 7)
  {
    if (HIBYTE(v94) != 10)
    {
      if (HIBYTE(v94) != 13)
      {
        goto LABEL_111;
      }

      if (v93 != 0x7369676552746F6ELL || *(&v93 + 5) != 0x6465726574736967)
      {
        goto LABEL_111;
      }

      goto LABEL_93;
    }

    v22 = &v93;
LABEL_107:
    v25 = *v22;
    v26 = *(v22 + 4);
    if (v25 != 0x7265747369676572 || v26 != 25701)
    {
      goto LABEL_111;
    }

    v21 = 2;
    goto LABEL_119;
  }

  if (v93 != 1852534389 || *(&v93 + 3) != 1853321070)
  {
    goto LABEL_111;
  }

LABEL_118:
  v21 = 0;
LABEL_119:
  HIDWORD(v88[0]) = v21;
  if (v94 < 0)
  {
    operator delete(v93);
  }

LABEL_121:
  xpc_release(v95);
  *&v93 = 0;
  __p[0] = v96;
  __p[1] = "rssi";
  sub_100006354(__p, &v93);
  if (xpc_get_type(v93) != &_xpc_type_null)
  {
    if (xpc_get_type(v93) != &_xpc_type_int64)
    {
      sub_10000501C(__p, "service-info: rssi - invalid format, integer expected");
      sub_1014CAAAC((a1 + 2), __p, 0);
      if (SHIBYTE(v83) < 0)
      {
        operator delete(__p[0]);
      }

LABEL_167:
      xpc_release(v93);
      goto LABEL_168;
    }

    __p[0] = v93;
    if (v93)
    {
      xpc_retain(v93);
    }

    else
    {
      __p[0] = xpc_null_create();
    }

    v29 = xpc::dyn_cast_or_default(__p, 0, v28);
    if ((BYTE4(v88[1]) & 1) == 0)
    {
      BYTE4(v88[1]) = 1;
    }

    LODWORD(v88[1]) = v29;
    xpc_release(__p[0]);
  }

  xpc_release(v93);
  v95 = 0;
  __p[0] = v96;
  __p[1] = "congestionStatus";
  sub_100006354(__p, &v95);
  if (xpc_get_type(v95) != &_xpc_type_null)
  {
    if (xpc_get_type(v95) != &_xpc_type_string)
    {
      sub_10000501C(__p, "service-info: congestionStatus - invalid format, string expected");
      sub_1014CAAAC((a1 + 2), __p, 0);
      if ((SHIBYTE(v83) & 0x80000000) == 0)
      {
        goto LABEL_137;
      }

      v30 = __p[0];
LABEL_136:
      operator delete(v30);
      goto LABEL_137;
    }

    v93 = 0uLL;
    v94 = 0;
    object = v95;
    if (v95)
    {
      xpc_retain(v95);
    }

    else
    {
      object = xpc_null_create();
    }

    __p[0] = 0;
    __p[1] = 0;
    v83 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v83) < 0)
    {
      operator delete(__p[0]);
    }

    xpc_release(object);
    if (SHIBYTE(v94) < 0)
    {
      if (*(&v93 + 1) != 7)
      {
        goto LABEL_152;
      }

      v31 = v93;
    }

    else
    {
      if (SHIBYTE(v94) != 7)
      {
        goto LABEL_152;
      }

      v31 = &v93;
    }

    v32 = *v31;
    v33 = *(v31 + 3);
    if (v32 == 1852534389 && v33 == 1853321070)
    {
      v35 = 0;
LABEL_161:
      LODWORD(v89) = v35;
      BYTE4(v89) = 1;
      if (SHIBYTE(v94) < 0)
      {
        operator delete(v93);
      }

      goto LABEL_163;
    }

LABEL_152:
    if (sub_100318068(&v93, "none"))
    {
      v35 = 1;
    }

    else if (sub_100318068(&v93, "light"))
    {
      v35 = 2;
    }

    else if (sub_100318068(&v93, "moderate"))
    {
      v35 = 3;
    }

    else
    {
      if (!sub_100318068(&v93, "severe"))
      {
        sub_10000501C(__p, "service-info: congestionStatus - invalid value");
        sub_1014CAAAC((a1 + 2), __p, 0);
        if (SHIBYTE(v83) < 0)
        {
          operator delete(__p[0]);
        }

        if ((SHIBYTE(v94) & 0x80000000) == 0)
        {
          goto LABEL_137;
        }

        v30 = v93;
        goto LABEL_136;
      }

      v35 = 4;
    }

    goto LABEL_161;
  }

LABEL_163:
  xpc_release(v95);
  *&v93 = 0;
  __p[0] = v96;
  __p[1] = "currentLLCTargetID";
  sub_100006354(__p, &v93);
  if (xpc_get_type(v93) != &_xpc_type_null)
  {
    if (xpc_get_type(v93) != &_xpc_type_int64)
    {
      sub_10000501C(__p, "service-info: currentLLCTargetID - invalid format, integer expected");
      sub_1014CAAAC((a1 + 2), __p, 0);
      if (SHIBYTE(v83) < 0)
      {
        operator delete(__p[0]);
      }

      goto LABEL_167;
    }

    __p[0] = v93;
    if (v93)
    {
      xpc_retain(v93);
    }

    else
    {
      __p[0] = xpc_null_create();
    }

    v78 = xpc::dyn_cast_or_default(__p, 0, v70);
    if ((BYTE9(v89) & 1) == 0)
    {
      BYTE9(v89) = 1;
    }

    BYTE8(v89) = v78;
    xpc_release(__p[0]);
  }

  xpc_release(v93);
  sub_101669728(v2);
LABEL_3:
  v4 = 1;
LABEL_169:
  xpc_release(v96[0]);
  if (v4)
  {
    *&v93 = 0;
    v88[0] = a1 + 1;
    v88[1] = "gps-time-and-loc";
    sub_100048A24(v88, &v93);
    if (xpc_get_type(v93) == &_xpc_type_dictionary)
    {
      __p[0] = 0;
      v88[0] = &v93;
      v88[1] = "lat";
      sub_100006354(v88, __p);
      if (xpc_get_type(__p[0]) != &_xpc_type_null && xpc_get_type(__p[0]) == &_xpc_type_double)
      {
        v88[0] = __p[0];
        if (__p[0])
        {
          xpc_retain(__p[0]);
        }

        else
        {
          v88[0] = xpc_null_create();
        }

        xpc::dyn_cast_or_default(v88, v37, 0.0);
        xpc_release(v88[0]);
        v36 = 0;
      }

      else
      {
        v36 = 1;
      }

      xpc_release(__p[0]);
      __p[0] = 0;
      v88[0] = &v93;
      v88[1] = "lng";
      sub_100006354(v88, __p);
      if (xpc_get_type(__p[0]) != &_xpc_type_null && xpc_get_type(__p[0]) == &_xpc_type_double)
      {
        v88[0] = __p[0];
        if (__p[0])
        {
          xpc_retain(__p[0]);
        }

        else
        {
          v88[0] = xpc_null_create();
        }

        xpc::dyn_cast_or_default(v88, v40, 0.0);
        v38 = v2;
        xpc_release(v88[0]);
        v39 = 0;
      }

      else
      {
        v38 = v2;
        v39 = 1;
      }

      xpc_release(__p[0]);
      __p[0] = 0;
      v88[0] = &v93;
      v88[1] = "alt";
      sub_100006354(v88, __p);
      if (xpc_get_type(__p[0]) != &_xpc_type_null && xpc_get_type(__p[0]) == &_xpc_type_double)
      {
        v88[0] = __p[0];
        if (__p[0])
        {
          xpc_retain(__p[0]);
        }

        else
        {
          v88[0] = xpc_null_create();
        }

        xpc::dyn_cast_or_default(v88, v42, 0.0);
        xpc_release(v88[0]);
        v41 = 0;
      }

      else
      {
        v41 = 1;
      }

      xpc_release(__p[0]);
      __p[0] = 0;
      v88[0] = &v93;
      v88[1] = "timeNsec";
      sub_100006354(v88, __p);
      if (xpc_get_type(__p[0]) != &_xpc_type_null && xpc_get_type(__p[0]) == &_xpc_type_int64)
      {
        v88[0] = __p[0];
        if (__p[0])
        {
          xpc_retain(__p[0]);
        }

        else
        {
          v88[0] = xpc_null_create();
        }

        xpc::dyn_cast_or_default(v88, 0, v44);
        xpc_release(v88[0]);
        v43 = 0;
      }

      else
      {
        v43 = 1;
      }

      xpc_release(__p[0]);
      if ((v36 | v39 | v41 | v43) != 1)
      {
        operator new();
      }

      sub_10000501C(v88, "gps-time-and-loc: invalid format");
      v2 = v38;
      v3 = a1 + 1;
      sub_1014CAAAC((a1 + 2), v88, 0);
      if (SBYTE7(v89) < 0)
      {
        operator delete(v88[0]);
      }

      v45 = 0;
    }

    else
    {
      v45 = 1;
    }

    xpc_release(v93);
    if (v45)
    {
      v91 = 0;
      v88[0] = v3;
      v88[1] = "message-status";
      sub_100048A24(v88, &v91);
      if (xpc_get_type(v91) != &_xpc_type_dictionary)
      {
LABEL_207:
        v46 = 1;
        goto LABEL_208;
      }

      memset(v90, 0, 7);
      *v88 = 0u;
      v89 = 0u;
      v96[0] = 0;
      __p[0] = &v91;
      __p[1] = "UUID";
      sub_100006354(__p, v96);
      if (xpc_get_type(v96[0]) != &_xpc_type_null && xpc_get_type(v96[0]) == &_xpc_type_string)
      {
        v95 = v96[0];
        if (v96[0])
        {
          xpc_retain(v96[0]);
        }

        else
        {
          v95 = xpc_null_create();
        }

        __p[0] = 0;
        __p[1] = 0;
        v83 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v83) < 0)
        {
          operator delete(__p[0]);
        }

        v50 = *(&v93 + 1);
        __src = v93;
        v90[0] = v94;
        *(v90 + 3) = *(&v94 + 3);
        v49 = HIBYTE(v94);
        v93 = 0uLL;
        v94 = 0;
        xpc_release(v95);
        v48 = 1;
      }

      else
      {
        v48 = 0;
        v49 = 0;
        v50 = 0;
        __src = 0;
      }

      xpc_release(v96[0]);
      v96[0] = 0;
      __p[0] = &v91;
      __p[1] = "status";
      sub_100006354(__p, v96);
      if (xpc_get_type(v96[0]) != &_xpc_type_null && xpc_get_type(v96[0]) == &_xpc_type_string)
      {
        v95 = v96[0];
        if (v96[0])
        {
          xpc_retain(v96[0]);
        }

        else
        {
          v95 = xpc_null_create();
        }

        __p[0] = 0;
        __p[1] = 0;
        v83 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v83) < 0)
        {
          operator delete(__p[0]);
        }

        *v88 = v93;
        *&v89 = v94;
        v93 = 0uLL;
        v94 = 0;
        BYTE8(v89) = 1;
        xpc_release(v95);
        v55 = 1;
      }

      else
      {
        v55 = 0;
      }

      xpc_release(v96[0]);
      *&v93 = 0;
      __p[0] = &v91;
      __p[1] = "sizeBytes";
      sub_100006354(__p, &v93);
      if (xpc_get_type(v93) != &_xpc_type_null && xpc_get_type(v93) == &_xpc_type_int64)
      {
        __p[0] = v93;
        if (v93)
        {
          xpc_retain(v93);
        }

        else
        {
          __p[0] = xpc_null_create();
        }

        v56 = xpc::dyn_cast_or_default(__p, 0, v59);
        xpc_release(__p[0]);
        v57 = v56 & 0xFFFFFFFFFFFFFF00;
        v56 = v56;
        v58 = 1;
      }

      else
      {
        v56 = 0;
        v57 = 0;
        v58 = 0;
      }

      xpc_release(v93);
      if ((v48 & v58 & v55 & 1) == 0)
      {
        sub_10000501C(__p, "progress: invalid format");
        sub_1014CAAAC((a1 + 2), __p, 0);
        if (SHIBYTE(v83) < 0)
        {
          operator delete(__p[0]);
        }

        if (SBYTE7(v89) < 0)
        {
          v60 = v55;
        }

        else
        {
          v60 = 0;
        }

        if (v60 == 1)
        {
          operator delete(v88[0]);
        }

        if (v49 < 0)
        {
          v61 = v48;
        }

        else
        {
          v61 = 0;
        }

        if (v61 == 1)
        {
          operator delete(__src);
        }

        v46 = 0;
LABEL_208:
        xpc_release(v91);
        if (!v46)
        {
          return;
        }

        __p[0] = 0;
        v88[0] = v3;
        v88[1] = "conversation-committed";
        sub_100006354(v88, __p);
        if (xpc_get_type(__p[0]) != &_xpc_type_null)
        {
          if (xpc_get_type(__p[0]) != &_xpc_type_int64)
          {
            goto LABEL_220;
          }

          v88[0] = __p[0];
          if (__p[0])
          {
            xpc_retain(__p[0]);
          }

          else
          {
            v88[0] = xpc_null_create();
          }

          v51 = xpc::dyn_cast_or_default(v88, 0, v47);
          xpc_release(v88[0]);
          if (v51 >= 0x100)
          {
LABEL_220:
            sub_10000501C(v88, "conversation-committed: invalid format");
            sub_1014CAAAC((a1 + 2), v88, 0);
            if (SBYTE7(v89) < 0)
            {
              operator delete(v88[0]);
            }

            v52 = 0;
LABEL_225:
            xpc_release(__p[0]);
            if (!v52)
            {
              return;
            }

            __p[0] = 0;
            v88[0] = v3;
            v88[1] = "stewie-tx-defer-time";
            sub_100006354(v88, __p);
            if (xpc_get_type(__p[0]) != &_xpc_type_null)
            {
              if (xpc_get_type(__p[0]) != &_xpc_type_int64)
              {
                sub_10000501C(v88, "stewie-tx-defer-time: expected time ms, int64 value");
                sub_1014CAAAC((a1 + 2), v88, 0);
                if (SBYTE7(v89) < 0)
                {
                  operator delete(v88[0]);
                }

                v53 = 0;
LABEL_309:
                xpc_release(__p[0]);
                if (!v53)
                {
                  return;
                }

                __p[0] = 0;
                v88[0] = v3;
                v88[1] = "set-gps-time-adjustment";
                sub_100006354(v88, __p);
                if (xpc_get_type(__p[0]) != &_xpc_type_null)
                {
                  if (xpc_get_type(__p[0]) != &_xpc_type_int64)
                  {
                    v72 = *(v2 + 48);
                    if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
                    {
                      LOWORD(v88[0]) = 0;
                      _os_log_error_impl(&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "testStewieCommand::set-gps-time-adjustment - invalid format", v88, 2u);
                    }

                    sub_10000501C(v88, "set-gps-time-adjustment: invalid format");
                    sub_1014CAAAC((a1 + 2), v88, 0);
                    if (SBYTE7(v89) < 0)
                    {
                      operator delete(v88[0]);
                    }

                    v73 = 0;
                    goto LABEL_322;
                  }

                  v88[0] = __p[0];
                  if (__p[0])
                  {
                    xpc_retain(__p[0]);
                  }

                  else
                  {
                    v88[0] = xpc_null_create();
                  }

                  v75 = xpc::dyn_cast_or_default(v88, 0, v74);
                  xpc_release(v88[0]);
                  (*(**(v2 + 2280) + 216))(*(v2 + 2280), v75);
                }

                v73 = 1;
LABEL_322:
                xpc_release(__p[0]);
                if (v73)
                {
                  __p[0] = 0;
                  v88[0] = v3;
                  v88[1] = "sat-msg-provisioning";
                  sub_100048A24(v88, __p);
                  type = xpc_get_type(__p[0]);
                  if (type == &_xpc_type_dictionary)
                  {
                    (*(**(v2 + 2296) + 144))(*(v2 + 2296), __p, a1 + 2);
                  }

                  xpc_release(__p[0]);
                  if (type != &_xpc_type_dictionary)
                  {
                    v77 = *(v2 + 2080);
                    sub_100FB57F0(&v81, v3);
                    (*(*v77 + 232))(v77, &v81, a1 + 2);
                    xpc_release(v81);
                  }
                }

                return;
              }

              v88[0] = __p[0];
              if (__p[0])
              {
                xpc_retain(__p[0]);
              }

              else
              {
                v88[0] = xpc_null_create();
              }

              v71 = xpc::dyn_cast_or_default(v88, 0, v54);
              xpc_release(v88[0]);
              v88[0] = v71;
              sub_101669680(v2);
            }

            v53 = 1;
            goto LABEL_309;
          }

          sub_10166A200(v2);
        }

        v52 = 1;
        goto LABEL_225;
      }

      uuidStr = 0;
      if (v49 < 0)
      {
        sub_100005F2C(__dst, __src, v50);
        if (SHIBYTE(v86) < 0)
        {
          sub_100005F2C(&v93, __dst[0], __dst[1]);
LABEL_271:
          object = 0;
          if (SHIBYTE(v94) < 0)
          {
            sub_100005F2C(__p, v93, *(&v93 + 1));
          }

          else
          {
            *__p = v93;
            v83 = v94;
          }

          v95 = 0;
          if (ctu::cf::convert_copy())
          {
            v62 = object;
            object = v95;
            v96[0] = v62;
            sub_100005978(v96);
          }

          if (SHIBYTE(v83) < 0)
          {
            operator delete(__p[0]);
          }

          uuidStr = object;
          object = 0;
          sub_100005978(&object);
          if (SHIBYTE(v94) < 0)
          {
            operator delete(v93);
          }

          if (SHIBYTE(v86) < 0)
          {
            operator delete(__dst[0]);
          }

          *&v93 = 0;
          v63 = CFUUIDCreateFromString(0, uuidStr);
          *&v93 = v63;
          v64 = SBYTE7(v89);
          if (SBYTE7(v89) < 0)
          {
            if (v88[1] == 7)
            {
              v65 = v88[0];
LABEL_287:
              v66 = 1936027236;
              v67 = bswap32(*v65);
              if (v67 == 1936027236 && (v66 = 1684631143, v67 = bswap32(*(v65 + 3)), v67 == 1684631143))
              {
                v68 = 0;
              }

              else if (v67 < v66)
              {
                v68 = -1;
              }

              else
              {
                v68 = 1;
              }

              if (v68)
              {
                v69 = 2;
              }

              else
              {
                v69 = 1;
              }

              goto LABEL_297;
            }
          }

          else if (SBYTE7(v89) == 7)
          {
            v65 = v88;
            goto LABEL_287;
          }

          v69 = 2;
LABEL_297:
          __p[0] = v63;
          if (v63)
          {
            CFRetain(v63);
          }

          LODWORD(__p[1]) = 3;
          BYTE4(__p[1]) = 1;
          LODWORD(v83) = v69;
          v84 = v57 | v56;
          sub_10166A404(v2);
          sub_1000475BC(__p);
          sub_1000475BC(&v93);
          sub_100005978(&uuidStr);
          if (v64 < 0)
          {
            operator delete(v88[0]);
          }

          if (v49 < 0)
          {
            operator delete(__src);
          }

          goto LABEL_207;
        }
      }

      else
      {
        __dst[0] = __src;
        __dst[1] = v50;
        LODWORD(v86) = v90[0];
        *(&v86 + 3) = *(v90 + 3);
        HIBYTE(v86) = v49;
      }

      v93 = *__dst;
      v94 = v86;
      goto LABEL_271;
    }
  }
}

void sub_101673584(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, xpc_object_t a12, xpc_object_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, char a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, uint64_t a34, uint64_t a35, xpc_object_t object, xpc_object_t a37, xpc_object_t a38, uint64_t a39, int a40, __int16 a41, char a42, char a43)
{
  if (a32 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t *sub_101673C64(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100DD80C0(v1 + 16);
    xpc_release(*(v1 + 8));
    *(v1 + 8) = 0;
    operator delete();
  }

  return result;
}

void sub_101673CC4(uint64_t a1)
{
  v1 = a1;
  (*(**(**a1 + 2280) + 88))(*(**a1 + 2280));
  operator delete();
}

void sub_101673D68(uint64_t **a1)
{
  v1 = **a1;
  sub_101664EE8(v1, 1);
  sub_1016651E0(v1);
  (*(**(v1 + 2280) + 96))(*(v1 + 2280));
  if (*(v1 + 2013))
  {
    v2 = *(v1 + 24);
    if (v2)
    {
      v3 = std::__shared_weak_count::lock(v2);
      if (v3)
      {
        atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v3);
        operator new();
      }
    }

    sub_100013CC4();
  }

  v4 = *(v1 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *buf = 0;
    _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
  }

  operator delete();
}

void sub_101673F1C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10167432C(va);
  operator delete();
}

void *sub_101673F68(void *a1)
{
  *a1 = off_101F5F268;
  v2 = a1[3];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return a1;
}

void sub_101673FB4(void *a1)
{
  *a1 = off_101F5F268;
  v1 = a1[3];
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

uint64_t sub_101674094(uint64_t result, uint64_t a2)
{
  *a2 = off_101F5F268;
  *(a2 + 8) = *(result + 8);
  v2 = *(result + 24);
  *(a2 + 24) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 16), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_1016740D4(uint64_t a1)
{
  v1 = *(a1 + 24);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1016740E4(void *__p)
{
  v2 = __p[3];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_101674124(uint64_t a1, void *a2)
{
  v3 = *(a1 + 24);
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = *(a1 + 16);
      if (v6)
      {
        *a2 = 0;
        v7[0] = 0;
        v7[1] = 0;
        sub_100004AA0(v7, (v6 + 16));
        operator new();
      }

      sub_100004A34(v5);
    }
  }
}

uint64_t sub_101674250(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_10167429C(uint64_t *a1)
{
  v4 = *a1;
  v1 = *v4;
  v3 = a1;
  (***(v1 + 2376))(*(v1 + 2376), (v4 + 1));
  sub_101668854(v1);
  sub_10004B740(&v4);
  return sub_1000049E0(&v3);
}

void sub_101674310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004B740(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10167432C(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void sub_1016743AC(uint64_t **a1)
{
  v1 = *a1;
  v2 = **a1;
  v3 = *(*a1 + 8);
  if (*(v2 + 2809) != 1 || *(v2 + 2808) != v3)
  {
    *(v2 + 2808) = v3 | 0x100;
    v5 = *(v2 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 0;
      _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I satMsg Provisioning Changed", buf, 2u);
    }

    (*(**(v2 + 2280) + 224))(*(v2 + 2280), *(v1 + 8));
  }

  operator delete();
}

uint64_t sub_1016744B0(uint64_t a1, uint64_t a2)
{
  v3 = (a2 + 24);
  v4 = *(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(a1 + 24) = a1;
      (*(**v3 + 24))(*v3, a1);
      return a1;
    }

    *(a1 + 24) = v4;
  }

  else
  {
    v3 = (a1 + 24);
  }

  *v3 = 0;
  return a1;
}

uint64_t *sub_101674530(uint64_t *a1)
{
  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v2 = *(*v1 + 2264);
  sub_101674658(v6, v1 + 8);
  (**v2)(v2, v6);
  sub_1012A003C(v6);
  sub_101674608(&v5);
  return sub_1000049E0(&v4);
}

void sub_1016745DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  va_copy(va2, va1);
  v5 = va_arg(va2, void);
  sub_1012A003C(va2);
  sub_101674608(va1);
  sub_1000049E0(va);
  _Unwind_Resume(a1);
}

uint64_t *sub_101674608(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_1012A003C(v1 + 8);
    operator delete();
  }

  return result;
}

uint64_t sub_101674658(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

uint64_t *sub_1016746F0(uint64_t *a1)
{
  v1 = *a1;
  v3 = a1;
  v4 = v1;
  (*(**(*v1 + 2264) + 8))(*(*v1 + 2264), *(v1 + 8), v1 + 16, *(v1 + 40));
  sub_101674780(&v4);
  return sub_1000049E0(&v3);
}

void sub_101674764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_101674780(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101674780(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100005978((v1 + 40));
    v2 = (v1 + 16);
    sub_10129FBD4(&v2);
    operator delete();
  }

  return result;
}

void sub_1016747E8(uint64_t a1)
{
  v1 = a1;
  (*(**(**a1 + 2264) + 16))(*(**a1 + 2264));
  operator delete();
}

uint64_t sub_10167488C(uint64_t a1, uint64_t a2)
{
  v3 = (a2 + 24);
  v4 = *(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(a1 + 24) = a1;
      (*(**v3 + 24))(*v3, a1);
      return a1;
    }

    *(a1 + 24) = v4;
  }

  else
  {
    v3 = (a1 + 24);
  }

  *v3 = 0;
  return a1;
}

uint64_t *sub_10167490C(void **a1)
{
  v1 = *a1;
  v5 = a1;
  v6 = v1;
  v2 = *(*v1 + 2296);
  v3 = v1[4];
  if (v3)
  {
    if (v3 == v1 + 1)
    {
      v8 = v7;
      (*(*v3 + 24))(v3, v7);
      goto LABEL_6;
    }

    v3 = (*(*v3 + 16))(v3);
  }

  v8 = v3;
LABEL_6:
  (**v2)(v2, v7);
  sub_1012A03F8(v7);
  sub_101674A4C(&v6);
  return sub_1000049E0(&v5);
}

void sub_101674A20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  sub_101674A4C(va1);
  sub_1000049E0(va);
  _Unwind_Resume(a1);
}

uint64_t *sub_101674A4C(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_1012A03F8(v1 + 8);
    operator delete();
  }

  return result;
}

uint64_t *sub_101674A9C(void *a1)
{
  v1 = *a1;
  v3 = a1;
  v4 = v1;
  (*(**(*v1 + 2296) + 8))(*(*v1 + 2296), *(v1 + 8), *(v1 + 16), *(v1 + 24));
  sub_101674B24(&v4);
  return sub_1000049E0(&v3);
}

void sub_101674B08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void **a10)
{
  sub_101674B24(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

const void ***sub_101674B24(const void ***result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100005978(v1 + 3);
    sub_1000475BC(v1 + 2);
    sub_1003A5A8C(v1 + 1);
    operator delete();
  }

  return result;
}

uint64_t *sub_101674B84(unsigned __int8 **a1)
{
  v1 = *a1;
  v5 = a1;
  v6 = v1;
  v2 = *(*v1 + 2296);
  v3 = v1[8];
  v7[0] = off_101F5F2F8;
  v7[1] = v1 + 16;
  v7[3] = v7;
  (*(*v2 + 16))(v2, v3, v7);
  sub_10002B644(v7);
  sub_10028C5E0(&v6);
  return sub_1000049E0(&v5);
}

void sub_101674C50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  va_copy(va2, va1);
  v5 = va_arg(va2, void);
  sub_10002B644(va2);
  sub_10028C5E0(va1);
  sub_1000049E0(va);
  _Unwind_Resume(a1);
}

uint64_t sub_101674CE4(uint64_t result, void *a2)
{
  *a2 = off_101F5F2F8;
  a2[1] = *(result + 8);
  return result;
}

uint64_t sub_101674D14(uint64_t a1)
{
  v2 = *(*(a1 + 8) + 24);
  if (!v2)
  {
    sub_100022DB4();
  }

  v3 = *(*v2 + 48);

  return v3();
}

uint64_t sub_101674D60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_101674DAC(uint64_t **a1)
{
  v1 = *a1;
  v2 = **a1;
  v3 = *(*a1 + 1);
  *(v2 + 2358) = *(*a1 + 22);
  *(v2 + 2344) = v3;
  StewieFeatureState::StewieFeatureState(buf, v1[4], v1[10], v1[5]);
  if (operator!=())
  {
    *(v2 + 128) = *buf;
    *(v2 + 132) = v9;
    v4 = *(v2 + 120);
    if (v4)
    {
      (*(*v4 + 48))(v4, v2 + 128);
    }
  }

  if (*(v2 + 2013))
  {
    v5 = *(v2 + 2080);
    dispatch_assert_queue_V2(*(v2 + 32));
    if (*(v2 + 2364) == 2)
    {
      if (*(v2 + 1760) == 1)
      {
        v6 = 1;
      }

      else if (*(v2 + 2020))
      {
        v6 = 2;
      }

      else
      {
        v6 = 0;
      }
    }

    else
    {
      v6 = 0;
    }

    (*(*v5 + 80))(v5, v1 + 4, v6);
    sub_1000786CC(v2);
    sub_101666D5C(v2, 0);
    sub_10007A5E4(v2);
  }

  else
  {
    v7 = *(v2 + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_error_impl(&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
  }

  operator delete();
}

uint64_t sub_101674FEC(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F5F3F0;
  a2[1] = v2;
  return result;
}

void sub_101675018(uint64_t a1)
{
  v1 = *(a1 + 8);
  v2 = *(v1 + 2704);
  *(v1 + 2696) = 0u;
  if (v2)
  {
    sub_100004A34(v2);
  }

  sub_101664EE8(v1, 0);
}

uint64_t sub_101675068(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void *sub_1016750B4(void *a1)
{
  *a1 = off_101F5F470;
  v2 = a1[3];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return a1;
}

void sub_101675100(void *a1)
{
  *a1 = off_101F5F470;
  v1 = a1[3];
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

uint64_t sub_1016751E0(uint64_t result, uint64_t a2)
{
  *a2 = off_101F5F470;
  *(a2 + 8) = *(result + 8);
  v2 = *(result + 24);
  *(a2 + 24) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 16), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_101675220(uint64_t a1)
{
  v1 = *(a1 + 24);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_101675230(void *__p)
{
  v2 = __p[3];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

const void **sub_101675270(void *a1, __int16 *a2)
{
  v3 = *a2;
  v4 = *(a2 + 4);
  *(a2 + 1) = 0;
  *(a2 + 2) = 0;
  v13 = v4;
  v14 = v4;
  v5 = *(a2 + 3);
  v6 = *(a2 + 4);
  v15 = v5;
  v16 = v6;
  v7 = *(a2 + 5);
  v17 = v7;
  *(a2 + 4) = 0;
  *(a2 + 5) = 0;
  *(a2 + 3) = 0;
  v8 = a1[3];
  if (v8)
  {
    v9 = a1[1];
    v10 = std::__shared_weak_count::lock(v8);
    if (v10)
    {
      v11 = a1[2];
      if (v11)
      {
        v18 = v9;
        v19 = v3;
        v14 = 0uLL;
        v20 = v13;
        v15 = 0;
        v21 = v5;
        v22 = v6;
        v23 = v7;
        v24[0] = 0;
        v16 = 0;
        v17 = 0;
        v24[1] = 0;
        sub_100004AA0(v24, (v11 + 16));
        operator new();
      }

      sub_100004A34(v10);
    }
  }

  if (v7)
  {
    sub_100004A34(v7);
    v5 = v15;
  }

  if (v5)
  {
    sub_100004A34(v5);
  }

  return sub_100005978(&v14);
}

uint64_t sub_101675440(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t *sub_10167548C(uint64_t *a1)
{
  v1 = *a1;
  v35 = a1;
  v36 = v1;
  v2 = *v1;
  v4 = *(v1 + 24);
  v3 = *(v1 + 32);
  if (v3)
  {
    atomic_fetch_add_explicit((v3 + 8), 1uLL, memory_order_relaxed);
  }

  *(v2 + 2576) = v4;
  v5 = *(v2 + 2584);
  *(v2 + 2584) = v3;
  if (v5)
  {
    sub_100004A34(v5);
  }

  sub_101664BC0(v2);
  v6 = *(v2 + 2592);
  v7 = *(v1 + 40);
  if (v6 != v7)
  {
    if (v6)
    {
      v8 = v7 == 0;
    }

    else
    {
      v8 = 1;
    }

    if (!v8)
    {
      if (sub_1016D5958(v6, v7))
      {
        goto LABEL_17;
      }

      v7 = *(v1 + 40);
    }

    v9 = *(v1 + 48);
    if (v9)
    {
      atomic_fetch_add_explicit((v9 + 8), 1uLL, memory_order_relaxed);
    }

    *(v2 + 2592) = v7;
    v10 = *(v2 + 2600);
    *(v2 + 2600) = v9;
    if (v10)
    {
      sub_100004A34(v10);
    }

    sub_101664D38(v2);
  }

LABEL_17:
  v38 = 0;
  v39 = 0;
  v37 = &v38;
  if (!*(v1 + 16))
  {
    v13 = 0;
    goto LABEL_30;
  }

  memset(&__p, 0, sizeof(__p));
  memset(&theArray, 0, sizeof(theArray));
  ctu::cf::assign();
  __p = theArray;
  size = SHIBYTE(theArray.__r_.__value_.__r.__words[2]);
  if ((SHIBYTE(theArray.__r_.__value_.__r.__words[2]) & 0x8000000000000000) != 0)
  {
    size = __p.__r_.__value_.__l.__size_;
    if (!__p.__r_.__value_.__l.__size_)
    {
LABEL_28:
      operator delete(__p.__r_.__value_.__l.__data_);
      goto LABEL_29;
    }

    p_p = __p.__r_.__value_.__r.__words[0];
LABEL_24:
    v14 = (p_p + size);
    while (p_p != v14)
    {
      p_p->__r_.__value_.__s.__data_[0] = __toupper(p_p->__r_.__value_.__s.__data_[0]);
      p_p = (p_p + 1);
    }

    sub_10017695C(&v37, &__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_29;
    }

    goto LABEL_28;
  }

  if (*(&theArray.__r_.__value_.__s + 23))
  {
    p_p = &__p;
    goto LABEL_24;
  }

LABEL_29:
  v13 = v39;
LABEL_30:
  v15 = (v2 + 2608);
  if (v13 == *(v2 + 2624))
  {
    v16 = v37;
    if (v37 == &v38)
    {
      goto LABEL_58;
    }

    v17 = *v15;
    while (sub_100022D3C(&theArray, v16 + 4, v17 + 4))
    {
      v18 = v16[1];
      v19 = v16;
      if (v18)
      {
        do
        {
          v16 = v18;
          v18 = *v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          v16 = v19[2];
          v8 = *v16 == v19;
          v19 = v16;
        }

        while (!v8);
      }

      v20 = v17[1];
      if (v20)
      {
        do
        {
          v21 = v20;
          v20 = *v20;
        }

        while (v20);
      }

      else
      {
        do
        {
          v21 = v17[2];
          v8 = *v21 == v17;
          v17 = v21;
        }

        while (!v8);
      }

      v17 = v21;
      if (v16 == &v38)
      {
        goto LABEL_58;
      }
    }
  }

  if (v15 != &v37)
  {
    sub_1001730B8((v2 + 2608), v37, &v38);
  }

  theArray.__r_.__value_.__r.__words[0] = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v22 = v37;
  if (v37 != &v38)
  {
    do
    {
      v23 = v22 + 32;
      __p.__r_.__value_.__r.__words[0] = 0;
      if (v22[55] < 0)
      {
        v23 = *v23;
      }

      __p.__r_.__value_.__r.__words[0] = CFStringCreateWithCString(kCFAllocatorDefault, v23, 0x8000100u);
      CFArrayAppendValue(theArray.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__data_);
      sub_100005978(&__p.__r_.__value_.__l.__data_);
      v24 = *(v22 + 1);
      if (v24)
      {
        do
        {
          v25 = v24;
          v24 = *v24;
        }

        while (v24);
      }

      else
      {
        do
        {
          v25 = *(v22 + 2);
          v8 = *v25 == v22;
          v22 = v25;
        }

        while (!v8);
      }

      v22 = v25;
    }

    while (v25 != &v38);
  }

  sub_10079CC40(v2 + 2648);
  sub_101664DF8(v2);
  sub_1000279DC(&theArray.__r_.__value_.__l.__data_);
LABEL_58:
  v26 = *(v1 + 8);
  dispatch_assert_queue_V2(*(v2 + 32));
  if (((*(v2 + 2665) & 1) != 0 || *(v2 + 2672)) && (*(v2 + 2570) != 1 || *(v2 + 2568) != v26))
  {
    *(v2 + 2568) = v26;
    *(v2 + 2570) = 1;
    v41 = 0;
    theArray.__r_.__value_.__r.__words[0] = v26;
    v27 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &theArray);
    if (v27)
    {
      v41 = v27;
      theArray.__r_.__value_.__r.__words[0] = 0;
      sub_100029A48(&theArray.__r_.__value_.__l.__data_);
      sub_10079CC40(v2 + 2632);
    }

    v28 = *(v2 + 48);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      if ((*(v2 + 2570) & 1) == 0)
      {
        sub_1000D1644();
      }

      sub_10097642C(*(v2 + 2568), &theArray);
      if ((theArray.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        p_theArray = &theArray;
      }

      else
      {
        p_theArray = theArray.__r_.__value_.__r.__words[0];
      }

      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(__p.__r_.__value_.__r.__words + 4) = p_theArray;
      _os_log_impl(&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I [Bystander location based] Supported services: %{public}s", &__p, 0xCu);
      if (SHIBYTE(theArray.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(theArray.__r_.__value_.__l.__data_);
      }
    }

    v30 = *(v2 + 2280);
    dispatch_assert_queue_V2(*(v2 + 32));
    v31 = 2472;
    if (*(v2 + 2570))
    {
      v31 = 2568;
    }

    v32 = (v2 + v31);
    if (*(v32 + 2) == 1)
    {
      v33 = *v32;
    }

    else
    {
      v33 = 0;
    }

    (*(*v30 + 160))(v30, v33);
    if (*(v2 + 2570) == 1 && *(v2 + 2568))
    {
      sub_101665EDC(v2);
    }

    sub_10166491C(v2);
    sub_100029A48(&v41);
  }

  sub_100009970(&v37, v38);
  sub_1016759FC(&v36);
  return sub_1000049E0(&v35);
}

void sub_10167595C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, char *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a24 < 0)
  {
    operator delete(a19);
  }

  sub_100009970(&a12, a13);
  sub_1016759FC(&a11);
  sub_1000049E0(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_1016759FC(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    v2 = *(v1 + 48);
    if (v2)
    {
      sub_100004A34(v2);
    }

    v3 = *(v1 + 32);
    if (v3)
    {
      sub_100004A34(v3);
    }

    sub_100005978((v1 + 16));
    operator delete();
  }

  return result;
}

uint64_t sub_101675A64(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void *sub_101675AE4(void *a1)
{
  *a1 = off_101F5F500;
  v2 = a1[7];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  sub_100E76F18((a1 + 2));
  return a1;
}

void sub_101675B38(void *a1)
{
  *a1 = off_101F5F500;
  v2 = a1[7];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  sub_100E76F18((a1 + 2));

  operator delete();
}

uint64_t sub_101675C40(void *a1, void *a2)
{
  v4 = a1[1];
  *a2 = off_101F5F500;
  a2[1] = v4;
  result = sub_10101BF00((a2 + 2), (a1 + 2));
  v6 = a1[7];
  a2[6] = a1[6];
  a2[7] = v6;
  if (v6)
  {
    atomic_fetch_add_explicit((v6 + 16), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_101675CB0(void *a1)
{
  sub_101675F58(a1 + 8);

  operator delete(a1);
}

void sub_101675CEC(void *a1, uint64_t *a2)
{
  v4 = a1[7];
  if (v4)
  {
    v5 = a1[1];
    v6 = std::__shared_weak_count::lock(v4);
    if (v6 && a1[6])
    {
      v8 = *a2;
      v7 = a2[1];
      v10[4] = v5;
      v10[5] = v8;
      v10[6] = v7;
      if (v7)
      {
        atomic_fetch_add_explicit((v7 + 8), 1uLL, memory_order_relaxed);
      }

      sub_10101BF00(&v11, (a1 + 2));
      v10[0] = 0;
      v10[1] = 0;
      sub_100004AA0(v10, (v5 + 16));
      operator new();
    }
  }

  else
  {
    v6 = 0;
  }

  v9 = a1[5];
  if (!v9)
  {
    sub_100022DB4();
  }

  (*(*v9 + 48))(v9, a2);
  if (v6)
  {
    sub_100004A34(v6);
  }
}

void sub_101675ECC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_101675F0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101675F58(uint64_t a1)
{
  v2 = *(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return sub_100E76F18(a1 + 8);
}

uint64_t *sub_101675F98(void **a1)
{
  v1 = *a1;
  v10 = a1;
  v11 = v1;
  v2 = *v1;
  v4 = v1 + 1;
  v3 = v1[1];
  if (v3)
  {
    (*(**(v2 + 2280) + 160))(*(v2 + 2280), *(v3 + 160));
    v5 = *(v2 + 2280);
    v6 = *v4;
    v13 = 0;
    v14 = 0;
    __p = 0;
    sub_100034C50(&__p, *(v6 + 72), *(v6 + 80), *(v6 + 80) - *(v6 + 72));
    (*(*v5 + 168))(v5, &__p);
    if (__p)
    {
      v13 = __p;
      operator delete(__p);
    }

    v7 = *(*v4 + 184);
    *(v2 + 2728) = *(*v4 + 168);
    *(v2 + 2744) = v7;
    *(v2 + 2776) = *(*v4 + 200);
  }

  v8 = v1[6];
  if (!v8)
  {
    sub_100022DB4();
  }

  (*(*v8 + 48))(v8, v1 + 1);
  (*(**(v2 + 2080) + 104))(*(v2 + 2080), v1 + 1);
  sub_10101C218(&v11);
  return sub_1000049E0(&v10);
}

void sub_1016760FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
  {
    a13 = __p;
    operator delete(__p);
  }

  sub_10101C218(&a11);
  sub_1000049E0(&a10);
  _Unwind_Resume(a1);
}

void sub_101676130(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1016761BC(uint64_t a1, int a2, __int16 a3)
{
  v4 = a2;
  v3 = a3;
  operator new();
}

void sub_101676274(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10002B210(va);
  _Unwind_Resume(a1);
}

void sub_101676288(CTXPCEnhancedLQMNotificationInterface *this)
{
  *this = off_101F5F580;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  CTXPCEnhancedLQMNotificationInterface::~CTXPCEnhancedLQMNotificationInterface(this);
}

void sub_1016762E4(CTXPCEnhancedLQMNotificationInterface *this)
{
  *this = off_101F5F580;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  CTXPCEnhancedLQMNotificationInterface::~CTXPCEnhancedLQMNotificationInterface(this);

  operator delete();
}

void sub_1016763BC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    (*(*v1 + 8))(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016763F8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101676430(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t sub_101676460(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

__n128 sub_10167651C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5F638;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_101676554(uint64_t a1, id *a2)
{
  v7 = *a2;
  v3 = *(a1 + 8);
  v4 = *(a1 + 16);
  v5 = *v3;
  *v3 = 0;
  v6 = [CTXPCPlaceholder simSlot:*v4];
  [v7 taggedInfoIndicationChanged:v6 type:**(a1 + 24) payload:v5];
}

uint64_t sub_10167660C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101676658@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  ProvisioningProfileSupport = capabilities::ct::getProvisioningProfileSupport(a1);
  if (ProvisioningProfileSupport == 1 || (result = capabilities::ct::supportsVoiceCall(ProvisioningProfileSupport), (result & 1) == 0))
  {
    operator new();
  }

  return result;
}

void sub_10167698C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17)
  {
    (*(a17->isa + 1))(a17);
  }

  if (a12)
  {
    sub_100004A34(a12);
  }

  sub_100004A34(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_101676AB8(uint64_t a1)
{
  *a1 = off_101F5F6B8;
  v2 = *(a1 + 408);
  *(a1 + 408) = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  if (*(a1 + 399) < 0)
  {
    operator delete(*(a1 + 376));
  }

  v6 = (a1 + 344);
  sub_1000B2AF8(&v6);
  if (*(a1 + 327) < 0)
  {
    operator delete(*(a1 + 304));
  }

  if (*(a1 + 296) == 1)
  {
    sub_100E3A5D4(a1 + 80);
  }

  v3 = *(a1 + 72);
  if (v3)
  {
    sub_100004A34(v3);
  }

  v4 = *(a1 + 56);
  if (v4)
  {
    sub_100004A34(v4);
  }

  BootstrapControllerInterface::~BootstrapControllerInterface(a1);
  ctu::OsLogLogger::~OsLogLogger((a1 + 40));
  sub_1000C0544((a1 + 8));
  return a1;
}

void sub_101676BA8(uint64_t a1)
{
  sub_101676AB8(a1);

  operator delete();
}

void sub_101676BE0(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_101676CE0(uint64_t a1)
{
  v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_101679824;
  v5[3] = &unk_101F5FBE8;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  v6 = v5;
  v2 = a1 + 24;
  v1 = *(a1 + 24);
  if (*(v2 + 8))
  {
    v13 = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_101679A7C;
    v10 = &unk_101F5FC28;
    v11 = &v13;
    v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }

  else
  {
    v13 = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_101679A40;
    v10 = &unk_101F5FC08;
    v11 = &v13;
    v12 = &v6;
    dispatch_sync(v1, &block);
  }

  return v13;
}

void sub_101676E08(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_101676EF8(uint64_t result, unsigned __int8 *a2)
{
  if (*a2 != *(result + 333))
  {
    return sub_101676F10(result);
  }

  return result;
}

uint64_t sub_101676F10(uint64_t result)
{
  if (*(result + 404) == 1 || *(result + 333) == 1 || (*(result + 402) & 1) != 0 || *(result + 403) == 1 || *(result + 332) == 1)
  {
    v1 = 256;
  }

  else
  {
    v1 = 257;
  }

  *(result + 400) = v1;
  return result;
}

uint64_t sub_101676F5C(uint64_t result, unsigned __int8 *a2)
{
  if (*a2 != *(result + 332))
  {
    return sub_101676F10(result);
  }

  return result;
}

uint64_t sub_101676F74(uint64_t a1, int a2)
{
  v2 = *(a1 + 369);
  if (v2 != a2 && (v2 & 1) == 0)
  {
    sub_101676F8C(a1);
  }

  return a1;
}

void sub_101676F8C(uint64_t a1)
{
  v2 = *(a1 + 408);
  if (v2)
  {
    *(a1 + 408) = 0;
    (*(*v2 + 8))(v2);
  }

  v3 = *(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Delaying recommendation", buf, 2u);
  }

  Registry::getTimerService(&v8, *(a1 + 64));
  sub_10000501C(v6, "BootstrapRecommendation Timer");
  v4 = *(a1 + 16);
  if (v4)
  {
    v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v5);
      *__p = *v6;
      v10 = v7;
      v6[0] = 0;
      v6[1] = 0;
      v7 = 0;
      v12 = 0;
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_1016771DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, char a25)
{
  sub_10002B644(&a25);
  if (a23 < 0)
  {
    operator delete(__p);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  if (a16)
  {
    sub_100004A34(a16);
  }

  _Unwind_Resume(a1);
}

void sub_101677244(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 216);
  v5 = *(a1 + 296);
  if (v4 != v5 || v4 == 0)
  {
    if (v4 == v5)
    {
      return;
    }

    if (!*(a2 + 216))
    {
      goto LABEL_17;
    }

    goto LABEL_11;
  }

  v7 = VinylProfileDetails::operator==();
  if ((v7 & 1) == 0)
  {
    LOBYTE(v5) = *(a1 + 296);
    if ((*(a2 + 216) & 1) == 0)
    {
      goto LABEL_17;
    }

LABEL_11:
    if ((v5 & 1) == 0)
    {
LABEL_15:
      v8 = *(a1 + 40);
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        return;
      }

      *buf = 0;
      v9 = "Bootstrap no longer valid";
LABEL_27:
      _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v9, buf, 2u);
      return;
    }

    *buf = a2 + 96;
    v23 = a2 + 120;
    v24 = a2 + 144;
    v25 = a2 + 168;
    v26 = a2 + 16;
    v21[0] = a1 + 176;
    v21[1] = a1 + 200;
    v21[2] = a1 + 224;
    v21[3] = a1 + 248;
    v21[4] = a1 + 96;
    if (sub_101130D58(&v27, buf, v21))
    {
      return;
    }

    LOBYTE(v5) = *(a1 + 296);
    if (*(a2 + 216))
    {
      if ((*(a1 + 296) & 1) == 0)
      {
        goto LABEL_15;
      }

LABEL_18:
      ServiceMap = Registry::getServiceMap(*(a1 + 64));
      v11 = ServiceMap;
      if (v12 < 0)
      {
        v13 = (v12 & 0x7FFFFFFFFFFFFFFFLL);
        v14 = 5381;
        do
        {
          v12 = v14;
          v15 = *v13++;
          v14 = (33 * v14) ^ v15;
        }

        while (v15);
      }

      std::mutex::lock(ServiceMap);
      *buf = v12;
      v16 = sub_100009510(&v11[1].__m_.__sig, buf);
      if (v16)
      {
        v18 = v16[3];
        v17 = v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_100004A34(v17);
          v19 = 0;
          if (!v18)
          {
LABEL_31:
            if ((v19 & 1) == 0)
            {
              sub_100004A34(v17);
            }

            return;
          }

LABEL_30:
          v20 = (*(*v18 + 808))(v18);
          sub_10167749C(a1, v20);
          goto LABEL_31;
        }
      }

      else
      {
        v18 = 0;
      }

      std::mutex::unlock(v11);
      v17 = 0;
      v19 = 1;
      if (!v18)
      {
        goto LABEL_31;
      }

      goto LABEL_30;
    }

LABEL_17:
    if ((v5 & 1) == 0)
    {
      v8 = *(a1 + 40);
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        return;
      }

      *buf = 0;
      v9 = "No Bootstrap profile details";
      goto LABEL_27;
    }

    goto LABEL_18;
  }
}

void sub_101677484(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_10167749C(uint64_t a1, uint64_t a2)
{
  if (*(a1 + 296))
  {
    *__p = 0u;
    v29 = 0u;
    sub_101206320(__p, (a1 + 64), (a1 + 40), a1 + 80);
    v27 = 0;
    *buf = 0u;
    v26 = 0u;
    sub_1012072A4(__p, buf);
    if ((v27 & 1) == 0)
    {
      v5 = *(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *v31 = 0;
        _os_log_error_impl(&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "No proxy settings", v31, 2u);
      }

      goto LABEL_40;
    }

    memset(&__str, 0, sizeof(__str));
    if (SBYTE7(v26) < 0)
    {
      sub_100005F2C(&__str, *buf, *&buf[8]);
    }

    else
    {
      *&__str.__r_.__value_.__l.__data_ = *buf;
      __str.__r_.__value_.__r.__words[2] = v26;
    }

    v6 = DWORD2(v26);
    v7 = *(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = subscriber::asString();
      p_str = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        p_str = __str.__r_.__value_.__r.__words[0];
      }

      *v31 = 136315650;
      *&v31[4] = v8;
      v32 = 2080;
      v33 = p_str;
      v34 = 1024;
      v35 = v6;
      _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I updating proxy : %s : %s : %u", v31, 0x1Cu);
    }

    std::string::operator=((a1 + 304), &__str);
    *(a1 + 328) = v6;
    ServiceMap = Registry::getServiceMap(*(a1 + 64));
    v11 = ServiceMap;
    if (v12 < 0)
    {
      v13 = (v12 & 0x7FFFFFFFFFFFFFFFLL);
      v14 = 5381;
      do
      {
        v12 = v14;
        v15 = *v13++;
        v14 = (33 * v14) ^ v15;
      }

      while (v15);
    }

    std::mutex::lock(ServiceMap);
    *v31 = v12;
    v16 = sub_100009510(&v11[1].__m_.__sig, v31);
    if (v16)
    {
      v18 = v16[3];
      v17 = v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v17);
        v19 = 0;
        if (!v18)
        {
          goto LABEL_33;
        }

        goto LABEL_24;
      }
    }

    else
    {
      v18 = 0;
    }

    std::mutex::unlock(v11);
    v17 = 0;
    v19 = 1;
    if (!v18)
    {
LABEL_33:
      if ((v19 & 1) == 0)
      {
        sub_100004A34(v17);
      }

      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__str.__r_.__value_.__l.__data_);
      }

      if ((v27 & 1) != 0 && SBYTE7(v26) < 0)
      {
        operator delete(*buf);
      }

LABEL_40:
      if (SBYTE7(v29) < 0)
      {
        operator delete(__p[0]);
      }

      return;
    }

LABEL_24:
    v20 = *(a1 + 328);
    *v30 = 0;
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      *v30 = Mutable;
      *v31 = 0;
      sub_1000296E0(v31);
    }

    if (*(a1 + 327) >= 0)
    {
      v22 = (a1 + 304);
    }

    else
    {
      v22 = *(a1 + 304);
    }

    *v31 = CFStringCreateWithCString(kCFAllocatorDefault, v22, 0x8000100u);
    sub_1001768B8(*v30, kSCPropNetProxiesHTTPSProxy, *v31);
    if (v20 == 443)
    {
      sub_1016780CC(*v30, kSCPropNetProxiesHTTPSPort, 0x1BBu, kCFAllocatorDefault);
      sub_1003C16CC(*v30, kSCPropNetProxiesHTTPSEnable, 1, kCFAllocatorDefault);
      sub_1003C16CC(*v30, @"HTTPSOverTLSEnable", 1, kCFAllocatorDefault);
    }

    else
    {
      sub_1016780CC(*v30, kSCPropNetProxiesHTTPSPort, v20, kCFAllocatorDefault);
    }

    sub_100010180(&v23, v30);
    sub_100005978(v31);
    sub_1000296E0(v30);
    (*(*v18 + 1032))(v18, a2, 19, &v23);
    sub_10001021C(&v23);
    goto LABEL_33;
  }

  v4 = *(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *buf = 0;
    _os_log_error_impl(&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "No Bootstrap profile details", buf, 2u);
  }
}

void sub_101677900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, char a25, uint64_t a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, uint64_t a34, const void *a35)
{
  sub_100005978((v37 - 128));
  sub_1000296E0(&a35);
  if ((v36 & 1) == 0)
  {
    sub_100004A34(v35);
  }

  if (a16 < 0)
  {
    operator delete(__p);
  }

  if (a25 == 1 && a23 < 0)
  {
    operator delete(a18);
  }

  if (a32 < 0)
  {
    operator delete(a27);
  }

  _Unwind_Resume(a1);
}

void sub_1016779CC(uint64_t a1, uint64_t *a2)
{
  v3 = *a2;
  v4 = a2[1];
  v5 = v4 - *a2;
  v6 = *(a1 + 344);
  v7 = *(a1 + 352);
  v8 = v7 - v6;
  if (v5 == v7 - v6)
  {
    if (v3 == v4)
    {
      return;
    }

    while (BasicSimInfo::operator==())
    {
      v3 += 168;
      v6 += 168;
      if (v3 == v4)
      {
        return;
      }
    }

    v6 = *(a1 + 344);
    v7 = *(a1 + 352);
    v5 = a2[1] - *a2;
    v8 = v7 - v6;
  }

  if (v5 != v8 && v6 != v7)
  {
    do
    {
      v11 = *v6;
      v6 += 168;
      sub_10167749C(a1, v11);
    }

    while (v6 != v7);
    v6 = *(a1 + 344);
    v7 = *(a1 + 352);
  }

  while (v6 != v7)
  {
    if (!*(v6 + 2))
    {

      sub_101676F8C(a1);
    }

    v6 += 168;
  }
}

void sub_101677AB4(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_101677BAC(uint64_t a1, const void **a2)
{
  v3 = (a1 + 376);
  v4 = *(a2 + 23);
  if (v4 >= 0)
  {
    v5 = *(a2 + 23);
  }

  else
  {
    v5 = a2[1];
  }

  v6 = *(a1 + 399);
  if (v6 >= 0)
  {
    v7 = *(a1 + 399);
  }

  else
  {
    v7 = *(a1 + 384);
  }

  if (v5 == v7)
  {
    if (v4 >= 0)
    {
      v8 = a2;
    }

    else
    {
      v8 = *a2;
    }

    if (v6 >= 0)
    {
      v9 = v3;
    }

    else
    {
      v9 = *v3;
    }

    v10 = memcmp(v8, v9, v5);
    if (v5)
    {
      v11 = v10 == 0;
    }

    else
    {
      v11 = 1;
    }

    if (v11)
    {
      return;
    }
  }

  else if (!v7)
  {
    return;
  }

  if (*(a1 + 296) == 1)
  {
    v12 = *(a1 + 119);
    v13 = v12;
    if ((v12 & 0x80u) != 0)
    {
      v12 = *(a1 + 104);
    }

    if (v12 == v7)
    {
      v14 = v13 >= 0 ? (a1 + 96) : *(a1 + 96);
      v15 = v6 >= 0 ? v3 : *(a1 + 376);
      if (!memcmp(v14, v15, v7))
      {
        v37 = 0u;
        v39 = 0x400000000000000;
        v38 = 0u;
        v41 = 0u;
        v45 = 0u;
        v44 = 0u;
        memset(&v42, 0, sizeof(v42));
        v43 = 23;
        HIBYTE(v37) = 8;
        v36 = 0x72616C756C6C6543;
        LODWORD(v38) = 1296651109;
        HIBYTE(v41) = 9;
        LOBYTE(v41) = 112;
        v40 = *"Bootstrap";
        sub_1000167D4(&v42, "activation ticket rejected", 0x1AuLL);
        v43 |= 0x13uLL;
        ServiceMap = Registry::getServiceMap(*(a1 + 64));
        v17 = ServiceMap;
        if (v18 < 0)
        {
          v19 = (v18 & 0x7FFFFFFFFFFFFFFFLL);
          v20 = 5381;
          do
          {
            v18 = v20;
            v21 = *v19++;
            v20 = (33 * v20) ^ v21;
          }

          while (v21);
        }

        std::mutex::lock(ServiceMap);
        __dst[0] = v18;
        v22 = sub_100009510(&v17[1].__m_.__sig, __dst);
        if (v22)
        {
          v24 = v22[3];
          v23 = v22[4];
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v17);
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_100004A34(v23);
            v25 = 0;
LABEL_40:
            if (v24)
            {
              sub_100D9EC48(__dst, &v36);
              v47 = 0;
              (*(*v24 + 16))(v24, __dst, v46);
              sub_10010DF14(v46);
              if (v35 < 0)
              {
                operator delete(__p);
              }

              if (v33 < 0)
              {
                operator delete(v32);
              }

              if (v31 < 0)
              {
                operator delete(v30);
              }

              if (v29 < 0)
              {
                operator delete(v28);
              }

              if (v27 < 0)
              {
                operator delete(__dst[0]);
              }
            }

            if ((v25 & 1) == 0)
            {
              sub_100004A34(v23);
            }

            if (SBYTE7(v45) < 0)
            {
              operator delete(v44);
            }

            if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v42.__r_.__value_.__l.__data_);
            }

            if (SHIBYTE(v41) < 0)
            {
              operator delete(v40);
            }

            if (SHIBYTE(v39) < 0)
            {
              operator delete(v38);
            }

            if (SHIBYTE(v37) < 0)
            {
              operator delete(v36);
            }

            return;
          }
        }

        else
        {
          v24 = 0;
        }

        std::mutex::unlock(v17);
        v23 = 0;
        v25 = 1;
        goto LABEL_40;
      }
    }
  }
}

void sub_101677F00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
  sub_10010DF14(v29 - 88);
  sub_100D9E764(&a10);
  if ((v28 & 1) == 0)
  {
    sub_100004A34(v27);
  }

  sub_100D9E764(&a27);
  _Unwind_Resume(a1);
}

void sub_101677F54(uint64_t a1)
{
  v2 = *(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = (a1 + 304);
    if (*(a1 + 327) < 0)
    {
      v3 = *v3;
    }

    v4 = *(a1 + 328);
    v9 = 136315394;
    *v10 = v3;
    *&v10[8] = 1024;
    v11 = v4;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Boostrap Proxy {%s:%u}", &v9, 0x12u);
    v2 = *(a1 + 40);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(a1 + 404);
    v6 = *(a1 + 400);
    v9 = 67109376;
    *v10 = v5;
    *&v10[4] = 1024;
    *&v10[6] = v6;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Restricted: %{BOOL}d - Bootstrap recommendation: %{BOOL}d", &v9, 0xEu);
    v2 = *(a1 + 40);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(a1 + 402);
    v8 = *(a1 + 403);
    v9 = 67109376;
    *v10 = v7;
    *&v10[4] = 1024;
    *&v10[6] = v8;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I MonitorModes Provisioning:%{BOOL}d Expiry:%{BOOL}d", &v9, 0xEu);
  }
}

const void **sub_1016780CC(__CFDictionary *a1, CFTypeRef cf, unsigned int a3, CFAllocatorRef allocator)
{
  v11 = cf;
  if (cf)
  {
    CFRetain(cf);
  }

  valuePtr = a3;
  v8 = CFNumberCreate(allocator, kCFNumberLongLongType, &valuePtr);
  v10 = v8;
  if (cf && v8)
  {
    CFDictionaryAddValue(a1, cf, v8);
  }

  sub_100DA3324(&v10);
  return sub_100DA3324(&v11);
}

void sub_10167815C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  sub_100DA3324(va);
  sub_100DA3324(va1);
  _Unwind_Resume(a1);
}

void sub_101678184(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1016781D8(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101678218(uint64_t result)
{
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void sub_101678244(ServiceManager::Service *this)
{
  *this = off_101F5F7F8;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1016782A0(ServiceManager::Service *this)
{
  *this = off_101F5F7F8;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_101678320@<X0>(void *a1@<X8>)
{
  v2 = 4;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  return sub_1000FF040(a1, &v2, &vars0, 1);
}

void sub_101678364(uint64_t a1, dispatch_object_t *a2)
{
  v2 = *(a1 + 8);
  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_101676BE0(v2, v3);
  }

  v4 = *(a1 + 8);

  sub_101676BE0(v4, 0);
}

void sub_101678408(uint64_t a1, int a2, ServiceStage *this)
{
  v3 = *(a1 + 8);
  ServiceStage::holdOffStage(&group[1], this);
  v4 = *(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t *sub_10167851C(uint64_t *a1)
{
  v1 = *a1;
  v3 = a1;
  v4 = v1;
  ctu::RestModule::disconnect((*v1 + 48));
  sub_1000FF844(&v4);
  return sub_1000049E0(&v3);
}

void sub_101678564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_101678580(uint64_t **a1)
{
  v1 = **a1;
  v2 = *(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Boostrap Controller : started", buf, 2u);
  }

  Registry::createRestModuleOneTimeUseConnection(&v3, *(v1 + 64));
  ctu::RestModule::connect();
  if (v4)
  {
    sub_100004A34(v4);
  }

  sub_10000501C(&__p, "/cc/props/vinyl_info");
  operator new();
}

void sub_101678A30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20)
{
  sub_1000062D4(&a20);
  if (a19 < 0)
  {
    operator delete(__p);
  }

  sub_1000FF844(&a11);
  sub_1000049E0(&a10);
  _Unwind_Resume(a1);
}

__n128 sub_101678B34(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5F878;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_101678B6C(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v11 = 0uLL;
  v12 = 0;
  sub_10011D868(&v11, a2);
  v15 = 0u;
  memset(v14, 0, sizeof(v14));
  sub_10011DD74(v14, v3);
  v9 = v11;
  v10 = v12;
  v12 = 0;
  v11 = 0uLL;
  sub_101131F94(v3, &v9);
  v13 = &v9;
  sub_100112048(&v13);
  v4 = *(v3 + 216);
  v5 = BYTE8(v15) != v4;
  if (BYTE8(v15) == v4 && BYTE8(v15))
  {
    v5 = VinylProfileDetails::operator!=();
  }

  if (v5)
  {
    v6 = a1[3];
    v7 = a1[4];
    v8 = (a1[2] + (v7 >> 1));
    if (v7)
    {
      v6 = *(*v8 + v6);
    }

    v6(v8, v14);
  }

  if (BYTE8(v15) == 1)
  {
    sub_100E3A5D4(v14);
  }

  *&v14[0] = &v11;
  sub_100112048(v14);
}

void sub_101678CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, char a44)
{
  if (a44 == 1)
  {
    sub_100E3A5D4(&a17);
  }

  a17 = &a13;
  sub_100112048(&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_101678D20(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_101678DE8(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5F8F8;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_101678E20(void *a1, xpc_object_t *a2)
{
  v4 = a1[1];
  v13 = *v4;
  type = xpc_get_type(*a2);
  if (type == &_xpc_type_string)
  {
    v14 = *v4;
    ctu::rest::detail::read_enum_string_value(&v14, a2, v6);
    *v4 = v14;
  }

  else if (type == &_xpc_type_BOOL || type == &_xpc_type_int64 || type == &_xpc_type_uint64)
  {
    *v4 = xpc::dyn_cast_or_default(a2, 0, v6);
  }

  v9 = a1[3];
  v10 = a1[4];
  v11 = (a1[2] + (v10 >> 1));
  if (v10)
  {
    v9 = *(*v11 + v9);
  }

  return v9(v11, &v13);
}

uint64_t sub_101678F1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_101678FE4(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5F978;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_10167901C(void *a1, xpc_object_t *a2)
{
  v4 = a1[1];
  v13 = *v4;
  type = xpc_get_type(*a2);
  if (type == &_xpc_type_string)
  {
    v14 = *v4;
    ctu::rest::detail::read_enum_string_value(&v14, a2, v6);
    *v4 = v14;
  }

  else if (type == &_xpc_type_BOOL || type == &_xpc_type_int64 || type == &_xpc_type_uint64)
  {
    *v4 = xpc::dyn_cast_or_default(a2, 0, v6);
  }

  v9 = a1[3];
  v10 = a1[4];
  v11 = (a1[2] + (v10 >> 1));
  if (v10)
  {
    v9 = *(*v11 + v9);
  }

  return v9(v11, &v13);
}

uint64_t sub_101679118(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1016791E0(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5F9F8;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_101679218(void *a1, xpc_object_t *a2)
{
  v3 = a1[1];
  v7 = *v3;
  v8 = v3[2];
  *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  sub_10010A62C(v3, a2);
  v4 = a1[3];
  v5 = a1[4];
  v6 = (a1[2] + (v5 >> 1));
  if (v5)
  {
    v4 = *(*v6 + v4);
  }

  v4(v6, &v7);
  v9 = &v7;
  sub_1000B2AF8(&v9);
}

void sub_1016792BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = &a9;
  sub_1000B2AF8(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1016792D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1016793A0(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5FA78;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_1016793D8(void *a1, xpc *this, BOOL a3)
{
  v4 = a1[1];
  v5 = *v4;
  *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  v6 = a1[3];
  v7 = a1[4];
  v8 = (a1[2] + (v7 >> 1));
  if (v7)
  {
    v6 = *(*v8 + v6);
  }

  return v6(v8, v5);
}

uint64_t sub_101679470(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_101679538(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5FAF8;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void sub_101679570(void *a1)
{
  v2 = a1[1];
  v3 = *v2;
  v9 = *(v2 + 2);
  *__p = v3;
  *(v2 + 1) = 0;
  *(v2 + 2) = 0;
  *v2 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  xpc::dyn_cast_or_default();
  if (*(v2 + 23) < 0)
  {
    operator delete(*v2);
  }

  v4 = v10;
  *(v2 + 2) = v11;
  *v2 = v4;
  v5 = a1[3];
  v6 = a1[4];
  v7 = (a1[2] + (v6 >> 1));
  if (v6)
  {
    v5 = *(*v7 + v5);
  }

  v5(v7, __p);
  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_10167965C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_101679690(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_101679758(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5FB78;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_101679790(void *a1)
{
  v1 = a1[2];
  v2 = a1[3];
  v3 = (a1[1] + (v2 >> 1));
  if (v2)
  {
    return (*(*v3 + v1))();
  }

  else
  {
    return v1(v3);
  }
}

uint64_t sub_1016797D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_101679824(capabilities::ct *a1)
{
  v1 = **(a1 + 5);
  if (*(v1 + 296) != 1)
  {
    return 0;
  }

  if (*(v1 + 170))
  {
    return 1;
  }

  v3 = capabilities::ct::dataOnlySingleSIMDevice(a1);
  if ((v3 & 1) == 0 && (!capabilities::ct::supportsGemini(v3) || (_os_feature_enabled_impl() & 1) == 0))
  {
    v4 = *(v1 + 40);
    result = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (!result)
    {
      return result;
    }

    LOWORD(v8) = 0;
    v5 = "#I Bootstrap recommendation not-supported in this device";
    goto LABEL_14;
  }

  if (*(v1 + 336) == 1 || *(v1 + 296) != 1 || *(v1 + 408))
  {
    v4 = *(v1 + 40);
    result = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (!result)
    {
      return result;
    }

    LOWORD(v8) = 0;
    v5 = "#I Bootstrap recommendation not-available";
    goto LABEL_14;
  }

  if (*(v1 + 369) == 1)
  {
    v4 = *(v1 + 40);
    result = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (result)
    {
      LOWORD(v8) = 0;
      v5 = "#I APM mode recommendation not-available";
LABEL_14:
      _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, &v8, 2u);
      return 0;
    }
  }

  else
  {
    if ((*(v1 + 368) & 1) == 0)
    {
      for (i = *(v1 + 344); i != *(v1 + 352); i += 168)
      {
        if (*(i + 8) == 5)
        {
          v4 = *(v1 + 40);
          result = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
          if (!result)
          {
            return result;
          }

          LOWORD(v8) = 0;
          v5 = "#I Bootstrap recommendation not-available when data disabled on active user sim";
          goto LABEL_14;
        }
      }
    }

    v6 = *(v1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 136315138;
      v9 = printers::asString();
      _os_log_impl(&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Bootstrap recommendation:%s", &v8, 0xCu);
    }

    if ((*(v1 + 400) & ((*(v1 + 400) & 0x100) >> 8)) != 0)
    {
      return 2;
    }

    else
    {
      return 0;
    }
  }

  return result;
}

uint64_t sub_101679A40(uint64_t a1)
{
  result = (*(**(a1 + 40) + 16))();
  **(a1 + 32) = result;
  return result;
}

uint64_t sub_101679A7C(uint64_t a1)
{
  result = (*(**(a1 + 40) + 16))();
  **(a1 + 32) = result;
  return result;
}

void sub_101679AB8(uint64_t **a1)
{
  v4 = a1;
  v1 = *a1;
  v2 = **a1;
  v3 = *(v1 + 8);
  if (*(v2 + 404) != v3)
  {
    *(v2 + 404) = v3;
    sub_101676F10(v2);
  }

  operator delete();
}

void *sub_101679B20(void *a1)
{
  *a1 = off_101F5FC58;
  v2 = a1[3];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return a1;
}

void sub_101679B6C(void *a1)
{
  *a1 = off_101F5FC58;
  v1 = a1[3];
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

uint64_t sub_101679C4C(uint64_t result, uint64_t a2)
{
  *a2 = off_101F5FC58;
  *(a2 + 8) = *(result + 8);
  v2 = *(result + 24);
  *(a2 + 24) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 16), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_101679C8C(uint64_t a1)
{
  v1 = *(a1 + 24);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_101679C9C(void *__p)
{
  v2 = __p[3];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_101679CDC(void *a1)
{
  v2 = a1[3];
  if (v2)
  {
    v3 = a1[1];
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[2])
      {
        v5 = *(v3 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5))
          {
            operator new();
          }
        }

        sub_100013CC4();
      }

      sub_100004A34(v4);
    }
  }
}

uint64_t sub_101679DEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_101679E38(uint64_t **a1)
{
  v1 = **a1;
  v2 = *(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Enabling recommendation now", buf, 2u);
  }

  v3 = *(v1 + 408);
  *(v1 + 408) = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  sub_101676F10(v1);
  operator delete();
}

void sub_101679F04(void ***a1)
{
  v6 = a1;
  v1 = *a1;
  v2 = **a1;
  if (*(*a1 + 11) == 1)
  {
    *(v2 + 402) = v1[10];
  }

  if (v1[9] == 1)
  {
    *(v2 + 403) = v1[8];
  }

  v3 = v2[5];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 136315394;
    v8 = printers::asString((v2 + 402), v4);
    v9 = 2080;
    v10 = printers::asString((v2 + 403), v5);
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Monitor Mode: Provisioning:%s Expiry:%s", buf, 0x16u);
  }

  sub_101676F10(v2);
  operator delete();
}

uint64_t sub_10167A04C()
{
  sub_10000501C(byte_101FCAFF0, "sq-device-proxy-stage.apple.com");
  __cxa_atexit(&std::string::~string, byte_101FCAFF0, &_mh_execute_header);
  sub_10000501C(byte_101FCB008, "sq-device-proxy.apple.com");

  return __cxa_atexit(&std::string::~string, byte_101FCB008, &_mh_execute_header);
}

ctu::OsLogLogger *sub_10167A0DC(ctu::OsLogLogger *a1, void *a2, NSObject **a3, void *a4)
{
  ctu::OsLogContext::OsLogContext(&v12, kCtLoggingSystemName, "wea");
  ctu::OsLogLogger::OsLogLogger(v13, &v12);
  ctu::OsLogLogger::OsLogLogger(a1, v13);
  ctu::OsLogLogger::~OsLogLogger(v13);
  ctu::OsLogContext::~OsLogContext(&v12);
  v8 = a2[1];
  *(a1 + 1) = *a2;
  *(a1 + 2) = v8;
  if (v8)
  {
    atomic_fetch_add_explicit((v8 + 8), 1uLL, memory_order_relaxed);
  }

  v9 = *a3;
  *(a1 + 3) = *a3;
  if (v9)
  {
    dispatch_retain(v9);
  }

  *(a1 + 4) = 0;
  *(a1 + 5) = 0;
  *(a1 + 6) = 0;
  v10 = a4[1];
  *(a1 + 7) = *a4;
  *(a1 + 8) = v10;
  if (v10)
  {
    atomic_fetch_add_explicit((v10 + 8), 1uLL, memory_order_relaxed);
  }

  return a1;
}

void sub_10167A1A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger(va1);
  ctu::OsLogContext::~OsLogContext(va);
  _Unwind_Resume(a1);
}

void sub_10167A1CC(uint64_t a1)
{
  v2 = *(a1 + 64);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v5 = (a1 + 32);
  sub_1000212F4(&v5);
  v3 = *(a1 + 24);
  if (v3)
  {
    dispatch_release(v3);
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    sub_100004A34(v4);
  }

  ctu::OsLogLogger::~OsLogLogger(a1);
}

uint64_t sub_10167A230(uint64_t result, void *a2, void *a3)
{
  *(result + 32) = 0;
  *result = 0u;
  *(result + 16) = 0u;
  *(result + 32) = 1065353216;
  if (a2 != a3)
  {
    v4 = a2;
    v5 = result;
    do
    {
      v9 = 0;
      v7 = 0u;
      v8 = 0u;
      sub_1011D8830(&v7, *v4 + 80);
      for (i = v8; i; i = *i)
      {
        sub_1011D88A8(v5, i + 2);
      }

      result = sub_1011D8D24(&v7);
      v4 += 2;
    }

    while (v4 != a3);
  }

  return result;
}

uint64_t sub_10167A2F8(uint64_t a1, uint64_t *a2)
{
  v3 = *(a1 + 32);
  v4 = *(a1 + 40);
  if (v3 == v4)
  {
LABEL_15:
    v12 = *a1;
    v13 = os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT);
    v14 = *a2;
    if (v13)
    {
      sub_10160E230(&v112);
      if ((SBYTE7(v113) & 0x80u) == 0)
      {
        v15 = &v112;
      }

      else
      {
        v15 = v112;
      }

      LODWORD(buf) = 136446210;
      *(&buf + 4) = v15;
      _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %{public}s <-- New alert", &buf, 0xCu);
      if (SBYTE7(v113) < 0)
      {
        operator delete(v112);
      }

      v14 = *a2;
    }

    __p = 0u;
    v106 = 0u;
    v107 = 1065353216;
    v16 = a2[1];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    v17 = *(v14 + 16);
    v18 = *(v14 + 24);
    v114 = 1065353216;
    v112 = 0uLL;
    v113 = 0uLL;
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    buf = 0uLL;
    *&v116 = 0;
    sub_101703264(&buf, *(v17 + 48), *(v17 + 56), (*(v17 + 56) - *(v17 + 48)) >> 4);
    if (v18)
    {
      sub_100004A34(v18);
    }

    __dst = 0uLL;
    ServiceMap = Registry::getServiceMap(*(a1 + 8));
    v20 = ServiceMap;
    v22 = v21;
    if (v21 < 0)
    {
      v23 = (v21 & 0x7FFFFFFFFFFFFFFFLL);
      v24 = 5381;
      do
      {
        v22 = v24;
        v25 = *v23++;
        v24 = (33 * v24) ^ v25;
      }

      while (v25);
    }

    std::mutex::lock(ServiceMap);
    *&v102 = v22;
    v26 = sub_100009510(&v20[1].__m_.__sig, &v102);
    v93 = a2;
    if (v26)
    {
      v28 = v26[3];
      v27 = v26[4];
      if (v27)
      {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v20);
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v27);
        v29 = 0;
        goto LABEL_43;
      }
    }

    else
    {
      v28 = 0;
    }

    std::mutex::unlock(v20);
    v27 = 0;
    v29 = 1;
LABEL_43:
    (*(*v28 + 136))(&__dst, v28);
    if ((v29 & 1) == 0)
    {
      sub_100004A34(v27);
    }

    if (buf != *(&buf + 1))
    {
      v108 = 0uLL;
      v33 = *(*buf + 80);
      v102 = *(*buf + 64);
      *&v103 = v33;
      operator new();
    }

    if (*(&__dst + 1))
    {
      sub_100004A34(*(&__dst + 1));
    }

    *&v102 = &buf;
    sub_1000212F4(&v102);
    sub_1011D9C18(&__p);
    v34 = v112;
    *&v112 = 0;
    v35 = __p;
    *&__p = v34;
    if (v35)
    {
      operator delete(v35);
    }

    v36 = *(&v112 + 1);
    *(&v112 + 1) = 0;
    v106 = v113;
    LODWORD(v107) = v114;
    *(&__p + 1) = v36;
    if (*(&v113 + 1))
    {
      v37 = *(v113 + 8);
      if ((v36 & (v36 - 1)) != 0)
      {
        if (v37 >= v36)
        {
          v37 %= v36;
        }
      }

      else
      {
        v37 &= v36 - 1;
      }

      *(__p + 8 * v37) = &v106;
      v113 = 0uLL;
    }

    sub_1011D8D24(&v112);
    if (v16)
    {
      sub_100004A34(v16);
    }

    v104 = 0;
    v102 = 0u;
    v103 = 0u;
    v38 = *v93;
    v39 = v93[1];
    if (v39)
    {
      atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    v40 = *(v38 + 16);
    v41 = *(v38 + 24);
    v102 = 0uLL;
    v103 = 0uLL;
    v104 = 1065353216;
    if (v41)
    {
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    v112 = 0uLL;
    *&v113 = 0;
    sub_101703158(&v112, *(v40 + 24), *(v40 + 32), (*(v40 + 32) - *(v40 + 24)) >> 4);
    if (v41)
    {
      sub_100004A34(v41);
    }

    __dst = 0uLL;
    v42 = Registry::getServiceMap(*(a1 + 8));
    v43 = v42;
    v44 = v21;
    if (v21 < 0)
    {
      v45 = (v21 & 0x7FFFFFFFFFFFFFFFLL);
      v46 = 5381;
      do
      {
        v44 = v46;
        v47 = *v45++;
        v46 = (33 * v46) ^ v47;
      }

      while (v47);
    }

    std::mutex::lock(v42);
    *&buf = v44;
    v48 = sub_100009510(&v43[1].__m_.__sig, &buf);
    if (v48)
    {
      v50 = v48[3];
      v49 = v48[4];
      if (v49)
      {
        atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v43);
        atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v49);
        v51 = 0;
        goto LABEL_73;
      }
    }

    else
    {
      v50 = 0;
    }

    std::mutex::unlock(v43);
    v49 = 0;
    v51 = 1;
LABEL_73:
    (*(*v50 + 136))(&__dst, v50);
    if ((v51 & 1) == 0)
    {
      sub_100004A34(v49);
    }

    if (v112 != *(&v112 + 1))
    {
      v52 = *v112;
      buf = 0uLL;
      *&v116 = 0;
      sub_100ECB804(&buf, *(v52 + 64), *(v52 + 72), (*(v52 + 72) - *(v52 + 64)) >> 4);
      v108 = 0uLL;
      operator new();
    }

    if (*(&__dst + 1))
    {
      sub_100004A34(*(&__dst + 1));
    }

    *&buf = &v112;
    sub_1000212F4(&buf);
    if (v39)
    {
      sub_100004A34(v39);
    }

    for (i = v103; i; i = *i)
    {
      sub_1011D88A8(&__p, i + 2);
    }

    sub_1011D9C18(&v102);
    v101 = 0;
    v99 = 0u;
    v100 = 0u;
    sub_1011D8830(&v95, &__p);
    v54 = *(a1 + 32);
    v55 = *(a1 + 40);
    v114 = 0;
    v112 = 0u;
    v113 = 0u;
    sub_10167A230(&v112, v54, v55);
    v117 = 1065353216;
    buf = 0u;
    v116 = 0u;
    v56 = v113;
    if (!v113)
    {
      goto LABEL_149;
    }

    while (1)
    {
      v57 = v97;
      if (!v97)
      {
        goto LABEL_146;
      }

      while (1)
      {
        v58 = *(v57 + 2);
        v59 = *(v57 + 3);
        if (v59)
        {
          atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        if (*(v58 + 63) < 0)
        {
          sub_100005F2C(&__dst, *(v58 + 40), *(v58 + 48));
        }

        else
        {
          __dst = *(v58 + 40);
          v111 = *(v58 + 56);
        }

        v60 = v56[2];
        if (*(v60 + 63) < 0)
        {
          sub_100005F2C(&v108, *(v60 + 40), *(v60 + 48));
        }

        else
        {
          v108 = *(v60 + 40);
          v109 = *(v60 + 56);
        }

        v61 = HIBYTE(v111);
        if (v111 >= 0)
        {
          v62 = HIBYTE(v111);
        }

        else
        {
          v62 = *(&__dst + 1);
        }

        v63 = HIBYTE(v109);
        v64 = SHIBYTE(v109);
        if (v109 < 0)
        {
          v63 = *(&v108 + 1);
        }

        if (v62 == v63)
        {
          if (v111 >= 0)
          {
            p_dst = &__dst;
          }

          else
          {
            p_dst = __dst;
          }

          if (v109 >= 0)
          {
            v66 = &v108;
          }

          else
          {
            v66 = v108;
          }

          v67 = memcmp(p_dst, v66, v62) == 0;
          if ((v64 & 0x80000000) == 0)
          {
LABEL_108:
            if ((v61 & 0x80) == 0)
            {
              goto LABEL_109;
            }

            goto LABEL_112;
          }
        }

        else
        {
          v67 = 0;
          if ((SHIBYTE(v109) & 0x80000000) == 0)
          {
            goto LABEL_108;
          }
        }

        operator delete(v108);
        if ((v111 & 0x8000000000000000) == 0)
        {
LABEL_109:
          if (v67)
          {
            break;
          }

          goto LABEL_113;
        }

LABEL_112:
        operator delete(__dst);
        if (v67)
        {
          break;
        }

LABEL_113:
        if (v59)
        {
          sub_100004A34(v59);
        }

        v57 = *v57;
        if (!v57)
        {
          goto LABEL_146;
        }
      }

      v68 = v96;
      v69 = *(v57 + 1);
      v70 = vcnt_s8(v96);
      v70.i16[0] = vaddlv_u8(v70);
      if (v70.u32[0] > 1uLL)
      {
        if (v69 >= *&v96)
        {
          v69 %= *&v96;
        }
      }

      else
      {
        v69 &= *&v96 - 1;
      }

      v71 = *v57;
      v72 = *(v95 + 8 * v69);
      do
      {
        v73 = v72;
        v72 = *v72;
      }

      while (v72 != v57);
      if (v73 == &v97)
      {
        goto LABEL_134;
      }

      v74 = *(v73 + 1);
      if (v70.u32[0] > 1uLL)
      {
        if (v74 >= *&v96)
        {
          v74 %= *&v96;
        }
      }

      else
      {
        v74 &= *&v96 - 1;
      }

      if (v74 == v69)
      {
LABEL_136:
        if (v71)
        {
          v75 = *(v71 + 1);
          goto LABEL_138;
        }
      }

      else
      {
LABEL_134:
        if (!v71)
        {
          goto LABEL_135;
        }

        v75 = *(v71 + 1);
        if (v70.u32[0] > 1uLL)
        {
          v76 = *(v71 + 1);
          if (v75 >= *&v96)
          {
            v76 = v75 % *&v96;
          }
        }

        else
        {
          v76 = v75 & (*&v96 - 1);
        }

        if (v76 != v69)
        {
LABEL_135:
          *(v95 + 8 * v69) = 0;
          v71 = *v57;
          goto LABEL_136;
        }

LABEL_138:
        if (v70.u32[0] > 1uLL)
        {
          if (v75 >= *&v68)
          {
            v75 %= *&v68;
          }
        }

        else
        {
          v75 &= *&v68 - 1;
        }

        if (v75 != v69)
        {
          *(v95 + 8 * v75) = v73;
          v71 = *v57;
        }
      }

      *v73 = v71;
      *v57 = 0;
      --*(&v97 + 1);
      LOBYTE(v111) = 1;
      *(&v111 + 1) = 0;
      HIDWORD(v111) = 0;
      *&__dst = 0;
      *(&__dst + 1) = &v95;
      sub_1011D8CC4(&__dst + 8, v57);
      sub_1011D88A8(&buf, v56 + 2);
      if (v59)
      {
        sub_100004A34(v59);
      }

LABEL_146:
      v56 = *v56;
      if (!v56)
      {
        for (j = v116; j; j = *j)
        {
          sub_1011D88A8(&v95, j + 2);
        }

LABEL_149:
        v78 = v95;
        v79 = v96;
        v95 = 0;
        v96 = 0;
        *&v99 = v78;
        *(&v99 + 1) = v79;
        v100 = v97;
        LODWORD(v101) = v98;
        if (*(&v97 + 1))
        {
          v80 = *(v97 + 8);
          if ((*&v79 & (*&v79 - 1)) != 0)
          {
            if (v80 >= *&v79)
            {
              v80 %= *&v79;
            }
          }

          else
          {
            v80 &= *&v79 - 1;
          }

          *(v78 + 8 * v80) = &v100;
          v97 = 0uLL;
        }

        sub_1011D8D24(&buf);
        sub_1011D8D24(&v112);
        sub_1011D8D24(&v95);
        sub_1011D9C18(&__p);
        v81 = v100;
        if (!v100)
        {
LABEL_172:
          operator new();
        }

        while (2)
        {
          v82 = v81[3];
          if (v82 && !*(v82 + 8))
          {
            v87 = sub_101565DD4(v81[2]);
            v88 = *a1;
            v89 = os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT);
            if (!v87)
            {
              if (v89)
              {
                sub_1015653F8(v81[2], &v112);
                v92 = (SBYTE7(v113) & 0x80u) == 0 ? &v112 : v112;
                LODWORD(buf) = 136446210;
                *(&buf + 4) = v92;
                _os_log_impl(&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I %{public}s Monitoring could not be started...", &buf, 0xCu);
                if (SBYTE7(v113) < 0)
                {
                  operator delete(v112);
                }
              }

              v32 = 0;
              sub_1011D8D24(&v99);
              sub_1011D8D24(&v102);
              sub_1011D8D24(&__p);
              return v32;
            }

            if (v89)
            {
              sub_1015653F8(v81[2], &v112);
              if ((SBYTE7(v113) & 0x80u) == 0)
              {
                v90 = &v112;
              }

              else
              {
                v90 = v112;
              }

              LODWORD(buf) = 136446210;
              *(&buf + 4) = v90;
              v85 = v88;
              v86 = "#I %{public}s Monitoring start triggered...";
LABEL_169:
              _os_log_impl(&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, v86, &buf, 0xCu);
              if (SBYTE7(v113) < 0)
              {
                operator delete(v112);
              }
            }
          }

          else
          {
            v83 = *a1;
            if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
            {
              sub_1015653F8(v81[2], &v112);
              if ((SBYTE7(v113) & 0x80u) == 0)
              {
                v84 = &v112;
              }

              else
              {
                v84 = v112;
              }

              LODWORD(buf) = 136446210;
              *(&buf + 4) = v84;
              v85 = v83;
              v86 = "#I %{public}s Already being monitored...";
              goto LABEL_169;
            }
          }

          v81 = *v81;
          if (!v81)
          {
            goto LABEL_172;
          }

          continue;
        }
      }
    }
  }

  while (1)
  {
    v5 = *(*a2 + 68);
    v6 = *(*v3 + 64);
    v7 = *(*v3 + 72);
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    if (v5 != *(v6 + 68))
    {
      v11 = 0;
      if (!v7)
      {
        goto LABEL_10;
      }

LABEL_9:
      sub_100004A34(v7);
      goto LABEL_10;
    }

    v8 = *(*a2 + 72);
    v10 = *(*v3 + 64);
    v9 = *(*v3 + 72);
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      v11 = v8 == *(v10 + 72);
      sub_100004A34(v9);
      if (v7)
      {
        goto LABEL_9;
      }
    }

    else
    {
      v11 = v8 == *(v10 + 72);
      if (v7)
      {
        goto LABEL_9;
      }
    }

LABEL_10:
    if (v11)
    {
      break;
    }

    v3 += 2;
    if (v3 == v4)
    {
      goto LABEL_15;
    }
  }

  v30 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    sub_10160E230(&v112);
    v31 = (SBYTE7(v113) & 0x80u) == 0 ? &v112 : v112;
    LODWORD(buf) = 136446210;
    *(&buf + 4) = v31;
    _os_log_impl(&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %{public}s already being monitoried...", &buf, 0xCu);
    if (SBYTE7(v113) < 0)
    {
      operator delete(v112);
    }
  }

  sub_1011D8558(*v3);
  return 1;
}

void sub_10167B6A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, void *__p, uint64_t a46, int a47, __int16 a48, char a49, char a50)
{
  sub_1011D8D24(&a23);
  sub_1011D8D24(&a29);
  sub_1011D8D24(&a35);
  _Unwind_Resume(a1);
}

uint64_t sub_10167B984(uint64_t result, __int128 *a2)
{
  v3 = result;
  v4 = *(result + 8);
  v5 = *(result + 16);
  if (v4 >= v5)
  {
    v8 = (v4 - *result) >> 4;
    v9 = v8 + 1;
    if ((v8 + 1) >> 60)
    {
      sub_1000CE3D4();
    }

    v10 = v5 - *result;
    if (v10 >> 3 > v9)
    {
      v9 = v10 >> 3;
    }

    if (v10 >= 0x7FFFFFFFFFFFFFF0)
    {
      v11 = 0xFFFFFFFFFFFFFFFLL;
    }

    else
    {
      v11 = v9;
    }

    v18[4] = result;
    if (v11)
    {
      sub_1000210A8(result, v11);
    }

    v12 = 16 * v8;
    v13 = *a2;
    *(16 * v8) = *a2;
    if (*(&v13 + 1))
    {
      atomic_fetch_add_explicit((*(&v13 + 1) + 8), 1uLL, memory_order_relaxed);
    }

    v7 = (v12 + 16);
    v14 = *(result + 8) - *result;
    v15 = v12 - v14;
    memcpy((v12 - v14), *result, v14);
    v16 = *v3;
    *v3 = v15;
    v3[1] = v7;
    v17 = v3[2];
    v3[2] = 0;
    v18[2] = v16;
    v18[3] = v17;
    v18[0] = v16;
    v18[1] = v16;
    result = sub_1012290A0(v18);
  }

  else
  {
    v6 = *(a2 + 1);
    *v4 = *a2;
    v4[1] = v6;
    if (v6)
    {
      atomic_fetch_add_explicit((v6 + 8), 1uLL, memory_order_relaxed);
    }

    v7 = v4 + 2;
  }

  v3[1] = v7;
  return result;
}

void sub_10167BA98(uint64_t a1, uint64_t a2)
{
  v3 = *(*a2 + 160);
  v4 = *(*a2 + 168);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v58 = v4;
  v74 = 0;
  v75 = 0;
  v73 = 0;
  sub_1015DA6B4(&v73, *(v3 + 8), *(v3 + 16), (*(v3 + 16) - *(v3 + 8)) >> 4);
  v71 = 0uLL;
  v72 = 0;
  v69 = 0uLL;
  v70 = 0;
  v5 = v73;
  v6 = v74;
  if (v73 == v74)
  {
    goto LABEL_61;
  }

  v59 = a1;
  do
  {
    v60 = *v5;
    v7 = *(v5 + 1);
    if (v7)
    {
      atomic_fetch_add_explicit((*(v5 + 1) + 8), 1uLL, memory_order_relaxed);
    }

    if (*(v60 + 4))
    {
      v8 = &v69;
    }

    else
    {
      v8 = &v71;
    }

    v9 = *(v8 + 1);
    v10 = *(v8 + 2);
    if (v9 >= v10)
    {
      v12 = (v9 - *v8) >> 4;
      v13 = v12 + 1;
      if ((v12 + 1) >> 60)
      {
        sub_1015DA664();
      }

      v14 = v10 - *v8;
      if (v14 >> 3 > v13)
      {
        v13 = v14 >> 3;
      }

      if (v14 >= 0x7FFFFFFFFFFFFFF0)
      {
        v15 = 0xFFFFFFFFFFFFFFFLL;
      }

      else
      {
        v15 = v13;
      }

      v78 = v8;
      if (v15)
      {
        sub_1000210A8(v8, v15);
      }

      v16 = 16 * v12;
      *(16 * v12) = v60;
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      v11 = (v16 + 16);
      v17 = *(v8 + 1) - *v8;
      v18 = v16 - v17;
      memcpy((v16 - v17), *v8, v17);
      v19 = *v8;
      *v8 = v18;
      *(v8 + 1) = v11;
      v20 = *(v8 + 2);
      *(v8 + 2) = 0;
      v76.__r_.__value_.__r.__words[2] = v19;
      v77 = v20;
      v76.__r_.__value_.__r.__words[0] = v19;
      v76.__r_.__value_.__l.__size_ = v19;
      sub_1000210F0(&v76.__r_.__value_.__l.__data_);
    }

    else
    {
      *v9 = v60;
      v9[1] = v7;
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      v11 = v9 + 2;
    }

    *(v8 + 1) = v11;
    if (v7)
    {
      sub_100004A34(v7);
    }

    ++v5;
  }

  while (v5 != v6);
  v21 = *(&v71 + 1);
  v22 = v71;
  if (*(&v71 + 1) == v71)
  {
    goto LABEL_61;
  }

  memset(&v76, 0, sizeof(v76));
  do
  {
    v23 = *(v22 + 8);
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    sub_1015D9650(&v80);
    sub_1000D1054(&v76, &v80);
    if ((SHIBYTE(v80.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      if (!v23)
      {
        goto LABEL_35;
      }

LABEL_34:
      sub_100004A34(v23);
      goto LABEL_35;
    }

    operator delete(v80.__r_.__value_.__l.__data_);
    if (v23)
    {
      goto LABEL_34;
    }

LABEL_35:
    v22 += 16;
  }

  while (v22 != v21);
  v24 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000D1184(v76.__r_.__value_.__l.__data_, v76.__r_.__value_.__l.__size_, " ", 1uLL, &v80);
    v26 = (v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &v80 : v80.__r_.__value_.__r.__words[0];
    *buf = 136446210;
    *&buf[4] = v26;
    _os_log_impl(&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Wham Alerts (Active Tuple) :- %{public}s", buf, 0xCu);
    if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v80.__r_.__value_.__l.__data_);
    }
  }

  v66 = 0;
  v67 = 0;
  v68 = 0;
  sub_1015DA6B4(&v66, v71, *(&v71 + 1), (*(&v71 + 1) - v71) >> 4);
  v27 = v66;
  v28 = v67;
  while (v27 != v28)
  {
    v29 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      v30 = **v27;
      v31 = (*v27)[1];
      LODWORD(v80.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(v80.__r_.__value_.__r.__words[0]) = v30;
      LOWORD(v80.__r_.__value_.__r.__words[1]) = 1024;
      *(&v80.__r_.__value_.__r.__words[1] + 2) = v31;
      _os_log_impl(&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Processing Wham [%u, %u]..", &v80, 0xEu);
    }

    v32 = *(a1 + 32);
    v33 = *(a1 + 40);
    while (v32 != v33)
    {
      v35 = *(*v32 + 64);
      v34 = *(*v32 + 72);
      if (v34)
      {
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        v36 = *(v35 + 68);
        sub_100004A34(v34);
        v35 = *(*v32 + 64);
        v37 = *(*v32 + 72);
        if (v37)
        {
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
          v38 = *(v35 + 72);
          sub_100004A34(v37);
          goto LABEL_55;
        }
      }

      else
      {
        v36 = *(v35 + 68);
      }

      v38 = *(v35 + 72);
LABEL_55:
      if (v38 == **v27 && v36 == (*v27)[1])
      {
        sub_1011D8558(*v32);
      }

      v32 += 2;
    }

    v27 += 2;
    a1 = v59;
  }

  v80.__r_.__value_.__r.__words[0] = &v66;
  sub_1000212F4(&v80);
  v80.__r_.__value_.__r.__words[0] = &v76;
  sub_1000087B4(&v80);
LABEL_61:
  v39 = *(&v69 + 1);
  v40 = v69;
  if (*(&v69 + 1) == v69)
  {
    goto LABEL_99;
  }

  memset(&v80, 0, sizeof(v80));
  while (2)
  {
    v41 = *(v40 + 8);
    if (v41)
    {
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    sub_1015D9650(&v76);
    sub_1000D1054(&v80, &v76);
    if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v76.__r_.__value_.__l.__data_);
      if (v41)
      {
LABEL_67:
        sub_100004A34(v41);
      }
    }

    else if (v41)
    {
      goto LABEL_67;
    }

    v40 += 16;
    if (v40 != v39)
    {
      continue;
    }

    break;
  }

  v42 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000D1184(v80.__r_.__value_.__l.__data_, v80.__r_.__value_.__l.__size_, " ", 1uLL, &v76);
    v44 = (v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &v76 : v76.__r_.__value_.__r.__words[0];
    *buf = 136446210;
    *&buf[4] = v44;
    _os_log_impl(&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Wham Alerts (Active Tuple - Common warning area) :- %{public}s", buf, 0xCu);
    if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v76.__r_.__value_.__l.__data_);
    }
  }

  v63 = 0;
  v64 = 0;
  v65 = 0;
  sub_1015DA6B4(&v63, v69, *(&v69 + 1), (*(&v69 + 1) - v69) >> 4);
  v46 = *(a1 + 32);
  v45 = *(a1 + 40);
  memset(&v76, 0, sizeof(v76));
  if (v46 != v45)
  {
    while (1)
    {
      v48 = *(*v46 + 64);
      v47 = *(*v46 + 72);
      if (v47)
      {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
        v49 = *(v48 + 68);
        sub_100004A34(v47);
        v48 = *(*v46 + 64);
        v50 = *(*v46 + 72);
        if (v50)
        {
          atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
          v51 = *(v48 + 72);
          sub_100004A34(v50);
          goto LABEL_84;
        }
      }

      else
      {
        v49 = *(v48 + 68);
      }

      v51 = *(v48 + 72);
LABEL_84:
      v52 = v63;
      v53 = v64;
      while (v52 != v53)
      {
        v54 = *v52;
        v55 = v52[1];
        if (v55)
        {
          atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        if (v51 == *v54 && v49 == v54[1])
        {
          sub_10167B984(&v76, v46);
        }

        if (v55)
        {
          sub_100004A34(v55);
        }

        v52 += 2;
      }

      if (++v46 == v45)
      {
        size = v76.__r_.__value_.__l.__size_;
        for (i = v76.__r_.__value_.__r.__words[0]; i != size; i += 2)
        {
          sub_1011D8558(*i);
        }

        break;
      }
    }
  }

  *buf = &v76;
  sub_1000212F4(buf);
  v76.__r_.__value_.__r.__words[0] = &v63;
  sub_1000212F4(&v76);
  v76.__r_.__value_.__r.__words[0] = &v80;
  sub_1000087B4(&v76);
LABEL_99:
  sub_10000501C(__p, "After Wham handling");
  sub_10167C2C4(a1, __p);
  if (v62 < 0)
  {
    operator delete(__p[0]);
  }

  v76.__r_.__value_.__r.__words[0] = &v69;
  sub_1000212F4(&v76);
  v76.__r_.__value_.__r.__words[0] = &v71;
  sub_1000212F4(&v76);
  v76.__r_.__value_.__r.__words[0] = &v73;
  sub_1000212F4(&v76);
  if (v58)
  {
    sub_100004A34(v58);
  }
}

void sub_10167C164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, char **a26, uint64_t a27, uint64_t a28, uint64_t a29, char *a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34)
{
  *(v34 - 128) = v34 - 184;
  sub_1000087B4((v34 - 128));
  *(v34 - 128) = &a26;
  sub_1000212F4((v34 - 128));
  a26 = &a30;
  sub_1000212F4(&a26);
  a30 = &a34;
  sub_1000212F4(&a30);
  if (a9)
  {
    sub_100004A34(a9);
  }

  _Unwind_Resume(a1);
}

void sub_10167C2C4(uint64_t a1, uint64_t *a2)
{
  v4 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (*(a1 + 40) - *(a1 + 32)) >> 4;
    if (*(a2 + 23) < 0)
    {
      a2 = *a2;
    }

    v10 = 134218242;
    v11 = v5;
    v12 = 2082;
    v13 = a2;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ====== %lu Active Alerts ======(%{public}s)", &v10, 0x16u);
  }

  v6 = *(a1 + 32);
  v7 = *(a1 + 40);
  while (v6 != v7)
  {
    v8 = *v6;
    v6 += 2;
    sub_1011D7C54(v8);
  }

  v9 = *a1;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10) = 0;
    _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I ===============================", &v10, 2u);
  }
}

void sub_10167C3E4(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v4 = *(a1 + 32);
  v5 = *(a1 + 40);
  while (v4 != v5)
  {
    if (sub_1011D7A4C(*v4))
    {
      sub_10167B984(a2, v4);
    }

    ++v4;
  }

  sub_10000501C(__p, "After checking any alert for dispatch");
  sub_10167C2C4(a1, __p);
  if (v7 < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_10167C478(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  sub_1000212F4(&a15);
  _Unwind_Resume(a1);
}

void sub_10167C4AC(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 32);
  if (v2 >= *(a1 + 40))
  {
    return;
  }

  for (i = -v2; ; i -= 16)
  {
    v6 = *(*v2 + 64);
    v7 = *(*v2 + 72);
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    if (*(v6 + 68) != *(*a2 + 68))
    {
      v10 = 0;
      if (!v7)
      {
        goto LABEL_11;
      }

LABEL_10:
      sub_100004A34(v7);
      goto LABEL_11;
    }

    v9 = *(*v2 + 64);
    v8 = *(*v2 + 72);
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      v10 = *(v9 + 72) == *(*a2 + 72);
      sub_100004A34(v8);
      if (v7)
      {
        goto LABEL_10;
      }
    }

    else
    {
      v10 = *(v9 + 72) == *(*a2 + 72);
      if (v7)
      {
        goto LABEL_10;
      }
    }

LABEL_11:
    if (v10)
    {
      break;
    }

    v2 += 16;
    if (v2 >= *(a1 + 40))
    {
      return;
    }
  }

  sub_1011D8294(*v2);
  v11 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    sub_10160E230(__p);
    v12 = v22 >= 0 ? __p : __p[0];
    *buf = 136446210;
    v24 = v12;
    _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %{public}s <- Alert removed", buf, 0xCu);
    if (v22 < 0)
    {
      operator delete(__p[0]);
    }
  }

  v13 = *(a1 + 40);
  if (16 - i == v13)
  {
    v19 = -i;
  }

  else
  {
    v14 = *(a1 + 32);
    v15 = v14 - i;
    do
    {
      v16 = v15 - v14;
      v17 = *(v15 - v14 + 16);
      *(v16 + 16) = 0;
      *(v16 + 24) = 0;
      v18 = *(v15 - v14 + 8);
      *v16 = v17;
      if (v18)
      {
        sub_100004A34(v18);
      }

      v15 += 16;
    }

    while (v15 - v14 + 16 != v13);
    v13 = *(a1 + 40);
    v19 = v15 - v14;
  }

  while (v13 != v19)
  {
    v20 = *(v13 - 8);
    if (v20)
    {
      sub_100004A34(v20);
    }

    v13 -= 16;
  }

  *(a1 + 40) = v19;
}

void *sub_10167C6D4(void *result, __int128 *a2, __int128 *a3, const void **a4)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  if (a2 == a3)
  {
    return result;
  }

  v6 = a2;
  v7 = result;
  do
  {
    v21 = 0;
    v19 = 0u;
    v20 = 0u;
    sub_1011D8830(&v19, *v6 + 80);
    v8 = v20;
    if (!v20)
    {
      goto LABEL_27;
    }

    while (1)
    {
      v9 = v8[2];
      if (*(v9 + 63) < 0)
      {
        sub_100005F2C(__p, *(v9 + 40), *(v9 + 48));
      }

      else
      {
        *__p = *(v9 + 40);
        v18 = *(v9 + 56);
      }

      v10 = SHIBYTE(v18);
      if (v18 >= 0)
      {
        v11 = HIBYTE(v18);
      }

      else
      {
        v11 = __p[1];
      }

      v12 = *(a4 + 23);
      v13 = v12;
      if (v12 < 0)
      {
        v12 = a4[1];
      }

      if (v11 == v12)
      {
        if (v18 >= 0)
        {
          v14 = __p;
        }

        else
        {
          v14 = __p[0];
        }

        if (v13 >= 0)
        {
          v15 = a4;
        }

        else
        {
          v15 = *a4;
        }

        v16 = memcmp(v14, v15, v11) == 0;
        if (v10 < 0)
        {
LABEL_20:
          operator delete(__p[0]);
        }
      }

      else
      {
        v16 = 0;
        if (SHIBYTE(v18) < 0)
        {
          goto LABEL_20;
        }
      }

      if (v16)
      {
        break;
      }

      v8 = *v8;
      if (!v8)
      {
        goto LABEL_27;
      }
    }

    sub_10167B984(v7, v6);
LABEL_27:
    result = sub_1011D8D24(&v19);
    ++v6;
  }

  while (v6 != a3);
  return result;
}

void sub_10167C820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1011D8D24(va);
  sub_1000212F4(va);
  _Unwind_Resume(a1);
}

void sub_10167C84C(uint64_t a1, uint64_t a2)
{
  v3 = *(a1 + 32);
  v4 = *(a1 + 40);
  if (v3 == v4)
  {
    goto LABEL_16;
  }

  while (1)
  {
    v6 = (*v3)[8];
    v7 = (*v3)[9];
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    if (*(v6 + 68) != *(*a2 + 68))
    {
      v10 = 0;
      if (!v7)
      {
        goto LABEL_10;
      }

LABEL_9:
      sub_100004A34(v7);
      goto LABEL_10;
    }

    v9 = (*v3)[8];
    v8 = (*v3)[9];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      v10 = *(v9 + 72) == *(*a2 + 72);
      sub_100004A34(v8);
      if (v7)
      {
        goto LABEL_9;
      }
    }

    else
    {
      v10 = *(v9 + 72) == *(*a2 + 72);
      if (v7)
      {
        goto LABEL_9;
      }
    }

LABEL_10:
    if (v10)
    {
      break;
    }

    v3 += 2;
    if (v3 == v4)
    {
      goto LABEL_16;
    }
  }

  sub_1011D81A0(*v3);
LABEL_16:
  sub_10000501C(__p, "After alert dispatch");
  sub_10167C2C4(a1, __p);
  if (v12 < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_10167C96C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_10167C988(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v2 = *(a1 + 32);
  for (i = *(a1 + 40); v2 != i; v2 += 2)
  {
    v5 = *v2;
    if (*(*v2 + 104))
    {
      v7 = *(v5 + 64);
      v6 = *(v5 + 72);
      *&v8 = v7;
      *(&v8 + 1) = v6;
      if (v6)
      {
        atomic_fetch_add_explicit((v6 + 8), 1uLL, memory_order_relaxed);
      }

      sub_10167CA38(a2, &v8);
      if (*(&v8 + 1))
      {
        sub_100004A34(*(&v8 + 1));
      }
    }
  }
}

void sub_10167CA14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    sub_100004A34(a10);
  }

  sub_1000212F4(&a9);
  _Unwind_Resume(a1);
}

void sub_10167CA38(uint64_t a1, __int128 *a2)
{
  v3 = *(a1 + 8);
  v4 = *(a1 + 16);
  if (v3 >= v4)
  {
    v7 = (v3 - *a1) >> 4;
    v8 = v7 + 1;
    if ((v7 + 1) >> 60)
    {
      sub_1000CE3D4();
    }

    v9 = v4 - *a1;
    if (v9 >> 3 > v8)
    {
      v8 = v9 >> 3;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFF0)
    {
      v10 = 0xFFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    if (v10)
    {
      if (!(v10 >> 60))
      {
        operator new();
      }

      sub_100013D10();
    }

    v11 = 16 * v7;
    v12 = *a2;
    *(16 * v7) = *a2;
    if (*(&v12 + 1))
    {
      atomic_fetch_add_explicit((*(&v12 + 1) + 8), 1uLL, memory_order_relaxed);
    }

    v6 = (v11 + 16);
    v13 = *a1;
    v14 = *(a1 + 8) - *a1;
    v15 = v11 - v14;
    memcpy((v11 - v14), *a1, v14);
    *a1 = v15;
    *(a1 + 8) = v6;
    *(a1 + 16) = 0;
    if (v13)
    {
      operator delete(v13);
    }
  }

  else
  {
    v5 = *(a2 + 1);
    *v3 = *a2;
    v3[1] = v5;
    if (v5)
    {
      atomic_fetch_add_explicit((v5 + 8), 1uLL, memory_order_relaxed);
    }

    v6 = v3 + 2;
  }

  *(a1 + 8) = v6;
}

uint64_t sub_10167CB5C(void *a1, uint64_t a2, const void **a3)
{
  v20 = 0;
  v18 = 0u;
  v19 = 0u;
  sub_10167A230(&v18, *(a2 + 32), *(a2 + 40));
  v6 = v19;
  if (!v19)
  {
LABEL_23:
    v15 = *a2;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      if (*(a3 + 23) < 0)
      {
        a3 = *a3;
      }

      LODWORD(__p[0]) = 136446210;
      *(__p + 4) = a3;
      _os_log_error_impl(&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%{public}s Failed to match shape...", __p, 0xCu);
    }

    *a1 = 0;
    a1[1] = 0;
    return sub_1011D8D24(&v18);
  }

  while (1)
  {
    v7 = v6[2];
    if (*(v7 + 63) < 0)
    {
      sub_100005F2C(__p, *(v7 + 40), *(v7 + 48));
    }

    else
    {
      *__p = *(v7 + 40);
      v22 = *(v7 + 56);
    }

    v8 = SHIBYTE(v22);
    if (v22 >= 0)
    {
      v9 = HIBYTE(v22);
    }

    else
    {
      v9 = __p[1];
    }

    v10 = *(a3 + 23);
    v11 = v10;
    if (v10 < 0)
    {
      v10 = a3[1];
    }

    if (v9 != v10)
    {
      v14 = 0;
      if ((SHIBYTE(v22) & 0x80000000) == 0)
      {
        goto LABEL_21;
      }

LABEL_20:
      operator delete(__p[0]);
      goto LABEL_21;
    }

    if (v22 >= 0)
    {
      v12 = __p;
    }

    else
    {
      v12 = __p[0];
    }

    if (v11 >= 0)
    {
      v13 = a3;
    }

    else
    {
      v13 = *a3;
    }

    v14 = memcmp(v12, v13, v9) == 0;
    if (v8 < 0)
    {
      goto LABEL_20;
    }

LABEL_21:
    if (v14)
    {
      break;
    }

    v6 = *v6;
    if (!v6)
    {
      goto LABEL_23;
    }
  }

  v16 = v6[3];
  *a1 = v6[2];
  a1[1] = v16;
  if (v16)
  {
    atomic_fetch_add_explicit((v16 + 8), 1uLL, memory_order_relaxed);
  }

  return sub_1011D8D24(&v18);
}

void sub_10167CD38(uint64_t a1, void **a2)
{
  v2 = a2;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, a2[1]);
  }

  else
  {
    *__p = *a2;
    v17 = a2[2];
  }

  v18 = 0;
  v19 = 0;
  sub_10167CB5C(&v18, a1, __p);
  if (SHIBYTE(v17) < 0)
  {
    operator delete(__p[0]);
  }

  v4 = v18;
  if (v18)
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    if (*(v2 + 23) < 0)
    {
      sub_100005F2C(__dst, *v2, v2[1]);
    }

    else
    {
      *__dst = *v2;
      v12 = v2[2];
    }

    sub_10167C6D4(&v13, *(a1 + 32), *(a1 + 40), __dst);
    if (SHIBYTE(v12) < 0)
    {
      operator delete(__dst[0]);
    }

    if (v14 == v13)
    {
      v8 = *a1;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        if (*(v2 + 23) < 0)
        {
          v2 = *v2;
        }

        *buf = 136446210;
        *&buf[4] = v2;
        _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Empty Alert for :- %{public}s", buf, 0xCu);
      }
    }

    else
    {
      sub_101565884(v4);
      v5 = v19;
      v19 = 0;
      if (v5)
      {
        sub_100004A34(v5);
      }

      v6 = v13;
      v7 = v14;
      while (v6 != v7)
      {
        sub_1011D86C0(*v6);
        v6 += 2;
      }

      sub_10000501C(v9, "After monitoring-did-start");
      sub_10167C2C4(a1, v9);
      if (v10 < 0)
      {
        operator delete(v9[0]);
      }
    }

    *buf = &v13;
    sub_1000212F4(buf);
  }

  if (v19)
  {
    sub_100004A34(v19);
  }
}

void sub_10167CF20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, char a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
  v32 = *(v30 - 72);
  if (v32)
  {
    sub_100004A34(v32);
  }

  _Unwind_Resume(exception_object);
}

void sub_10167CFA4(uint64_t a1, void **a2)
{
  v2 = a2;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, a2[1]);
  }

  else
  {
    *__p = *a2;
    v35 = a2[2];
  }

  v36 = 0;
  v37 = 0;
  sub_10167CB5C(&v36, a1, __p);
  if (SHIBYTE(v35) < 0)
  {
    operator delete(__p[0]);
  }

  v4 = v36;
  if (v36)
  {
    v31 = 0;
    v32 = 0;
    v33 = 0;
    if (*(v2 + 23) < 0)
    {
      sub_100005F2C(__dst, *v2, v2[1]);
    }

    else
    {
      *__dst = *v2;
      v30 = v2[2];
    }

    sub_10167C6D4(&v31, *(a1 + 32), *(a1 + 40), __dst);
    if (SHIBYTE(v30) < 0)
    {
      operator delete(__dst[0]);
    }

    if (v32 == v31)
    {
      v14 = *a1;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        if (*(v2 + 23) < 0)
        {
          v2 = *v2;
        }

        *buf = 136446210;
        *&buf[4] = v2;
        _os_log_error_impl(&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Empty Alert for :- %{public}s", buf, 0xCu);
      }

      goto LABEL_46;
    }

    ServiceMap = Registry::getServiceMap(*(a1 + 8));
    v6 = ServiceMap;
    if (v7 < 0)
    {
      v8 = (v7 & 0x7FFFFFFFFFFFFFFFLL);
      v9 = 5381;
      do
      {
        v7 = v9;
        v10 = *v8++;
        v9 = (33 * v9) ^ v10;
      }

      while (v10);
    }

    std::mutex::lock(ServiceMap);
    *buf = v7;
    v11 = sub_100009510(&v6[1].__m_.__sig, buf);
    v22 = v4;
    if (v11)
    {
      v12 = v11[3];
      v13 = v11[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        v23 = v13;
        sub_100004A34(v13);
        v24 = 0;
LABEL_25:
        v16 = v31;
        for (i = v32; v16 != i; v16 += 2)
        {
          v18 = (*v16)[8];
          v17 = (*v16)[9];
          if (v17)
          {
            atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          }

          v19 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
          {
            sub_10160E230(buf);
            v20 = buf;
            if (v39 < 0)
            {
              v20 = *buf;
            }

            *v40 = 136446210;
            v41 = v20;
            _os_log_impl(&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %{public}s will be dispatched because of geofence error", v40, 0xCu);
            if (v39 < 0)
            {
              operator delete(*buf);
            }
          }

          v27 = v18;
          v28 = v17;
          if (v17)
          {
            atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          }

          (*(*v12 + 128))(v12, &v27);
          if (v28)
          {
            sub_100004A34(v28);
          }

          sub_1011D81A0(*v16);
          if (v17)
          {
            sub_100004A34(v17);
          }
        }

        sub_1015655C0(v22);
        v21 = v37;
        v37 = 0;
        if (v21)
        {
          sub_100004A34(v21);
        }

        sub_10000501C(v25, "After geofence-setup-error");
        sub_10167C2C4(a1, v25);
        if (v26 < 0)
        {
          operator delete(v25[0]);
        }

        if ((v24 & 1) == 0)
        {
          sub_100004A34(v23);
        }

LABEL_46:
        *buf = &v31;
        sub_1000212F4(buf);
        goto LABEL_47;
      }
    }

    else
    {
      v12 = 0;
    }

    std::mutex::unlock(v6);
    v23 = 0;
    v24 = 1;
    goto LABEL_25;
  }

LABEL_47:
  if (v37)
  {
    sub_100004A34(v37);
  }
}

void sub_10167D358(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, char a31, uint64_t a32, uint64_t a33, void *a34, uint64_t a35, int a36, __int16 a37, char a38, char a39, uint64_t a40, uint64_t a41, std::__shared_weak_count *a42)
{
  if (a42)
  {
    sub_100004A34(a42);
  }

  _Unwind_Resume(exception_object);
}

void sub_10167D42C(uint64_t a1, uint64_t *a2)
{
  v2 = a2;
  v31 = 0uLL;
  v32 = 0;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, a2[1]);
  }

  else
  {
    *__p = *a2;
    v30 = a2[2];
  }

  sub_10167C6D4(&v31, *(a1 + 32), *(a1 + 40), __p);
  if (SHIBYTE(v30) < 0)
  {
    operator delete(__p[0]);
  }

  v24 = *(&v31 + 1);
  v4 = v31;
  if (*(&v31 + 1) != v31)
  {
    while (1)
    {
      ServiceMap = Registry::getServiceMap(*(a1 + 8));
      v6 = ServiceMap;
      if (v7 < 0)
      {
        v8 = (v7 & 0x7FFFFFFFFFFFFFFFLL);
        v9 = 5381;
        do
        {
          v7 = v9;
          v10 = *v8++;
          v9 = (33 * v9) ^ v10;
        }

        while (v10);
      }

      std::mutex::lock(ServiceMap);
      *v33 = v7;
      v11 = sub_100009510(&v6[1].__m_.__sig, v33);
      if (v11)
      {
        v13 = v11[3];
        v12 = v11[4];
        if (v12)
        {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v6);
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_100004A34(v12);
          v14 = 0;
          goto LABEL_15;
        }
      }

      else
      {
        v13 = 0;
      }

      std::mutex::unlock(v6);
      v12 = 0;
      v14 = 1;
LABEL_15:
      v15 = *v4;
      v17 = (*v4)[8];
      v16 = (*v4)[9];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        v15 = *v4;
      }

      v18 = *(v15 + 104);
      v19 = *a1;
      v20 = os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT);
      if (v18)
      {
        if (v20)
        {
          sub_10160E230(v33);
          v21 = v33;
          if (v34 < 0)
          {
            v21 = *v33;
          }

          *buf = 136446210;
          v36 = v21;
          _os_log_impl(&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %{public}s will be dispatched because of monitoring failure", buf, 0xCu);
          if (v34 < 0)
          {
            operator delete(*v33);
          }
        }

        v27 = v17;
        v28 = v16;
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        (*(*v13 + 128))(v13, &v27);
        if (v28)
        {
          sub_100004A34(v28);
        }

        sub_1011D81A0(*v4);
      }

      else if (v20)
      {
        sub_10160E230(v33);
        v22 = v33;
        if (v34 < 0)
        {
          v22 = *v33;
        }

        *buf = 136446210;
        v36 = v22;
        _os_log_impl(&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %{public}s is inactive.. no action for monitoringDidFail", buf, 0xCu);
        if (v34 < 0)
        {
          operator delete(*v33);
          if (!v16)
          {
            goto LABEL_34;
          }

LABEL_33:
          sub_100004A34(v16);
          goto LABEL_34;
        }
      }

      if (v16)
      {
        goto LABEL_33;
      }

LABEL_34:
      if ((v14 & 1) == 0)
      {
        sub_100004A34(v12);
      }

      v4 += 2;
      if (v4 == v24)
      {
        sub_10000501C(v25, "After monitoring-did-fail");
        sub_10167C2C4(a1, v25);
        if (v26 < 0)
        {
          operator delete(v25[0]);
        }

        goto LABEL_43;
      }
    }
  }

  v23 = *a1;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    if (*(v2 + 23) < 0)
    {
      v2 = *v2;
    }

    *v33 = 136446210;
    *&v33[4] = v2;
    _os_log_error_impl(&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Empty Alert for :- %{public}s", v33, 0xCu);
  }

LABEL_43:
  *v33 = &v31;
  sub_1000212F4(v33);
}

void sub_10167D88C(uint64_t a1, void **a2, int a3)
{
  v4 = a2;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, a2[1]);
  }

  else
  {
    *__p = *a2;
    v19 = a2[2];
  }

  v20 = 0;
  v21 = 0;
  sub_10167CB5C(&v20, a1, __p);
  if (SHIBYTE(v19) < 0)
  {
    operator delete(__p[0]);
  }

  v6 = v20;
  if (v20)
  {
    v15 = 0;
    v16 = 0;
    v17 = 0;
    if (*(v4 + 23) < 0)
    {
      sub_100005F2C(__dst, *v4, v4[1]);
    }

    else
    {
      *__dst = *v4;
      v14 = v4[2];
    }

    sub_10167C6D4(&v15, *(a1 + 32), *(a1 + 40), __dst);
    if (SHIBYTE(v14) < 0)
    {
      operator delete(__dst[0]);
    }

    if (v16 == v15)
    {
      v10 = *a1;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        if (*(v4 + 23) < 0)
        {
          v4 = *v4;
        }

        *buf = 136446210;
        *&buf[4] = v4;
        _os_log_error_impl(&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Empty Alert for :- %{public}s", buf, 0xCu);
      }
    }

    else
    {
      sub_101565CEC(v6, a3);
      v7 = v21;
      v21 = 0;
      if (v7)
      {
        sub_100004A34(v7);
      }

      v8 = v15;
      v9 = v16;
      while (v8 != v9)
      {
        sub_1011D876C(*v8);
        v8 += 2;
      }

      sub_10000501C(v11, "After determine-state");
      sub_10167C2C4(a1, v11);
      if (v12 < 0)
      {
        operator delete(v11[0]);
      }
    }

    *buf = &v15;
    sub_1000212F4(buf);
  }

  if (v21)
  {
    sub_100004A34(v21);
  }
}

void sub_10167DA7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, char a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
  v32 = *(v30 - 72);
  if (v32)
  {
    sub_100004A34(v32);
  }

  _Unwind_Resume(exception_object);
}

void sub_10167DB00(uint64_t a1, void **a2)
{
  v2 = a2;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, a2[1]);
  }

  else
  {
    *__p = *a2;
    v17 = a2[2];
  }

  v18 = 0;
  v19 = 0;
  sub_10167CB5C(&v18, a1, __p);
  if (SHIBYTE(v17) < 0)
  {
    operator delete(__p[0]);
  }

  v4 = v18;
  if (v18)
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    if (*(v2 + 23) < 0)
    {
      sub_100005F2C(__dst, *v2, v2[1]);
    }

    else
    {
      *__dst = *v2;
      v12 = v2[2];
    }

    sub_10167C6D4(&v13, *(a1 + 32), *(a1 + 40), __dst);
    if (SHIBYTE(v12) < 0)
    {
      operator delete(__dst[0]);
    }

    if (v14 == v13)
    {
      v8 = *a1;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        if (*(v2 + 23) < 0)
        {
          v2 = *v2;
        }

        *buf = 136446210;
        *&buf[4] = v2;
        _os_log_error_impl(&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Empty Alert for :- %{public}s", buf, 0xCu);
      }
    }

    else
    {
      sub_1015659FC(v4);
      v5 = v19;
      v19 = 0;
      if (v5)
      {
        sub_100004A34(v5);
      }

      v6 = v13;
      v7 = v14;
      while (v6 != v7)
      {
        sub_1011D876C(*v6);
        v6 += 2;
      }

      sub_10000501C(v9, "After enter-region");
      sub_10167C2C4(a1, v9);
      if (v10 < 0)
      {
        operator delete(v9[0]);
      }
    }

    *buf = &v13;
    sub_1000212F4(buf);
  }

  if (v19)
  {
    sub_100004A34(v19);
  }
}

void sub_10167DCE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, char a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
  v32 = *(v30 - 72);
  if (v32)
  {
    sub_100004A34(v32);
  }

  _Unwind_Resume(exception_object);
}

void sub_10167DD6C(uint64_t a1, void **a2)
{
  v2 = a2;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, a2[1]);
  }

  else
  {
    *__p = *a2;
    v14 = a2[2];
  }

  v15 = 0;
  v16 = 0;
  sub_10167CB5C(&v15, a1, __p);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__p[0]);
  }

  if (v15)
  {
    sub_101565B74(v15);
    if (v16)
    {
      sub_100004A34(v16);
    }

    v11 = 0uLL;
    v12 = 0;
    if (*(v2 + 23) < 0)
    {
      sub_100005F2C(__dst, *v2, v2[1]);
    }

    else
    {
      *__dst = *v2;
      v10 = v2[2];
    }

    sub_10167C6D4(&v11, *(a1 + 32), *(a1 + 40), __dst);
    if (SHIBYTE(v10) < 0)
    {
      operator delete(__dst[0]);
    }

    v4 = *(&v11 + 1);
    v5 = v11;
    if (*(&v11 + 1) == v11)
    {
      v6 = *a1;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        if (*(v2 + 23) < 0)
        {
          v2 = *v2;
        }

        *buf = 136446210;
        *&buf[4] = v2;
        _os_log_error_impl(&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Empty Alert for :- %{public}s", buf, 0xCu);
      }
    }

    else
    {
      do
      {
        sub_1011D876C(*v5);
        v5 += 2;
      }

      while (v5 != v4);
      sub_10000501C(v7, "After exit-region");
      sub_10167C2C4(a1, v7);
      if (v8 < 0)
      {
        operator delete(v7[0]);
      }
    }

    *buf = &v11;
    sub_1000212F4(buf);
  }

  else if (v16)
  {
    sub_100004A34(v16);
  }
}

void sub_10167DFF4(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F5FCD8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t vinyl::asClosestVinylError(unsigned int a1)
{
  if (a1 > 0xA)
  {
    return 0;
  }

  else
  {
    return byte_1019AD3AE[a1];
  }
}

void sub_10167E074(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10167E460(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t a9, dispatch_object_t a10, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t object)
{
  if (object)
  {
    (*(object->isa + 1))(object);
  }

  if (a12)
  {
    sub_100004A34(a12);
  }

  sub_100004A34(v17);
  _Unwind_Resume(a1);
}

NotifySubscription **sub_10167E614(NotifySubscription **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    NotifySubscription::~NotifySubscription(v2);
    operator delete();
  }

  return a1;
}

uint64_t sub_10167E65C(uint64_t a1)
{
  *a1 = off_101F5FD28;
  sub_1010DD940(*(a1 + 216));
  sub_101680C98(*(a1 + 184));
  sub_1000DD0AC(a1 + 152, *(a1 + 160));
  v5 = (a1 + 128);
  sub_1000087B4(&v5);
  v5 = (a1 + 104);
  sub_1000087B4(&v5);
  sub_10167E614((a1 + 88));
  sub_10167E614((a1 + 80));
  v2 = *(a1 + 72);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(a1 + 56);
  if (v3)
  {
    sub_100004A34(v3);
  }

  ManagedConfigurationInterface::~ManagedConfigurationInterface(a1);
  ctu::OsLogLogger::~OsLogLogger((a1 + 40));
  sub_1000C0544((a1 + 8));
  return a1;
}

void sub_10167E724(uint64_t a1)
{
  sub_10167E65C(a1);

  operator delete();
}

void sub_10167E75C(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_10167E85C(uint64_t a1)
{
  v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_101681200;
  v6[3] = &unk_101EA6CB8;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  v7 = objc_retainBlock(v6);
  v2 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v14 = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_1016811C4;
    v11 = &unk_101E26940;
    v12 = &v14;
    v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    v14 = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_100058A30;
    v11 = &unk_101E26940;
    v12 = &v14;
    v13 = &v7;
    dispatch_sync(v2, &block);
  }

  v3 = v14;

  return v3 & 1;
}

void sub_10167E9AC(uint64_t a1@<X0>, void *a2@<X8>)
{
  v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_101681210;
  v6[3] = &unk_101F5FF48;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  v7 = objc_retainBlock(v6);
  v4 = *(a1 + 24);
  if (*(a1 + 32))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_1016812B0;
    v11 = &unk_101E26940;
    v12 = a2;
    v13 = &v7;
    dispatch_async_and_wait(v4, &block);
  }

  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_101681240;
    v11 = &unk_101E26940;
    v12 = a2;
    v13 = &v7;
    dispatch_sync(v4, &block);
  }
}

uint64_t sub_10167EAF8(uint64_t a1, uint64_t a2)
{
  v3 = a1 + 8;
  v7 = a1;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    v9 = *(a2 + 16);
  }

  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_101681320;
  v10[3] = &unk_101EA6CB8;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = objc_retainBlock(v10);
  v4 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 3221225472;
    v14 = sub_1016811C4;
    v15 = &unk_101E26940;
    v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }

  else
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 3221225472;
    v14 = sub_100058A30;
    v15 = &unk_101E26940;
    v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }

  v5 = v18;

  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }

  return v5 & 1;
}

void sub_10167EC8C(uint64_t a1@<X0>, void *a2@<X8>)
{
  v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1016813C4;
  v6[3] = &unk_101F5FF48;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  v7 = objc_retainBlock(v6);
  v4 = *(a1 + 24);
  if (*(a1 + 32))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_1016812B0;
    v11 = &unk_101E26940;
    v12 = a2;
    v13 = &v7;
    dispatch_async_and_wait(v4, &block);
  }

  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_101681240;
    v11 = &unk_101E26940;
    v12 = a2;
    v13 = &v7;
    dispatch_sync(v4, &block);
  }
}

uint64_t sub_10167EDD8(uint64_t a1, uint64_t a2)
{
  v3 = a1 + 8;
  v7 = a1;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    v9 = *(a2 + 16);
  }

  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1016813F4;
  v10[3] = &unk_101EA6CB8;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = objc_retainBlock(v10);
  v4 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 3221225472;
    v14 = sub_1016811C4;
    v15 = &unk_101E26940;
    v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }

  else
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 3221225472;
    v14 = sub_100058A30;
    v15 = &unk_101E26940;
    v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }

  v5 = v18;

  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }

  return v5 & 1;
}

uint64_t sub_10167EF6C(uint64_t a1, uint64_t a2)
{
  v3 = a1 + 8;
  v7 = a1;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    v9 = *(a2 + 16);
  }

  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_101681498;
  v10[3] = &unk_101EA6CB8;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = objc_retainBlock(v10);
  v4 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 3221225472;
    v14 = sub_1016811C4;
    v15 = &unk_101E26940;
    v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }

  else
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 3221225472;
    v14 = sub_100058A30;
    v15 = &unk_101E26940;
    v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }

  v5 = v18;

  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }

  return v5 & 1;
}

uint64_t sub_10167F100(uint64_t a1)
{
  v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1016814D0;
  v6[3] = &unk_101EA6CB8;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  v7 = objc_retainBlock(v6);
  v2 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v14 = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_1016811C4;
    v11 = &unk_101E26940;
    v12 = &v14;
    v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    v14 = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_100058A30;
    v11 = &unk_101E26940;
    v12 = &v14;
    v13 = &v7;
    dispatch_sync(v2, &block);
  }

  v3 = v14;

  return v3 & 1;
}

uint64_t sub_10167F250(uint64_t a1)
{
  v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1016814E0;
  v6[3] = &unk_101EA6CB8;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  v7 = objc_retainBlock(v6);
  v2 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v14 = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_1016811C4;
    v11 = &unk_101E26940;
    v12 = &v14;
    v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    v14 = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_100058A30;
    v11 = &unk_101E26940;
    v12 = &v14;
    v13 = &v7;
    dispatch_sync(v2, &block);
  }

  v3 = v14;

  return v3 & 1;
}

uint64_t sub_10167F3A0(uint64_t a1)
{
  v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1016814F0;
  v6[3] = &unk_101EA6CB8;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  v7 = objc_retainBlock(v6);
  v2 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v14 = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_1016811C4;
    v11 = &unk_101E26940;
    v12 = &v14;
    v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    v14 = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_100058A30;
    v11 = &unk_101E26940;
    v12 = &v14;
    v13 = &v7;
    dispatch_sync(v2, &block);
  }

  v3 = v14;

  return v3 & 1;
}

uint64_t sub_10167F4F0(uint64_t a1, uint64_t a2)
{
  v3 = a1 + 8;
  v7 = a1;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    v9 = *(a2 + 16);
  }

  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_101681500;
  v10[3] = &unk_101EA6CB8;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = objc_retainBlock(v10);
  v4 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 3221225472;
    v14 = sub_1016811C4;
    v15 = &unk_101E26940;
    v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }

  else
  {
    v18 = 0;
    block = _NSConcreteStackBlock;
    v13 = 3221225472;
    v14 = sub_100058A30;
    v15 = &unk_101E26940;
    v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }

  v5 = v18;

  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[0]);
  }

  return v5 & 1;
}

uint64_t sub_10167F684(uint64_t a1)
{
  v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_101681548;
  v6[3] = &unk_101F5FF68;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  v7 = objc_retainBlock(v6);
  v2 = *(a1 + 24);
  if (*(a1 + 32))
  {
    v14 = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_101681594;
    v11 = &unk_101E26940;
    v12 = &v14;
    v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }

  else
  {
    v14 = 0;
    block = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_101681558;
    v11 = &unk_101E26940;
    v12 = &v14;
    v13 = &v7;
    dispatch_sync(v2, &block);
  }

  v3 = v14;

  return v3;
}

void sub_10167F7D4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v8 = a2;
  if (*(a3 + 23) < 0)
  {
    sub_100005F2C(v9, *a3, *(a3 + 8));
  }

  else
  {
    *v9 = *a3;
    v10 = *(a3 + 16);
  }

  if (*(a4 + 23) < 0)
  {
    sub_100005F2C(__p, *a4, *(a4 + 8));
  }

  else
  {
    *__p = *a4;
    v12 = *(a4 + 16);
  }

  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1016815D0;
  v13[3] = &unk_101E26920;
  v13[4] = a2 + 8;
  v13[5] = &v8;
  v14 = objc_retainBlock(v13);
  v7 = *(a2 + 24);
  if (*(a2 + 32))
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    block = _NSConcreteStackBlock;
    v16 = 3221225472;
    v17 = sub_1016817BC;
    v18 = &unk_101E26940;
    v19 = a1;
    v20 = &v14;
    dispatch_async_and_wait(v7, &block);
  }

  else
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    block = _NSConcreteStackBlock;
    v16 = 3221225472;
    v17 = sub_101681758;
    v18 = &unk_101E26940;
    v19 = a1;
    v20 = &v14;
    dispatch_sync(v7, &block);
  }

  if (SHIBYTE(v12) < 0)
  {
    operator delete(__p[0]);
  }

  if (SHIBYTE(v10) < 0)
  {
    operator delete(v9[0]);
  }
}

void sub_10167F9A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_10167F9C4(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  sub_10000501C(__p, "DNN:");
  sub_10167F7D4(a3, a1, a2, __p);
  if (v7 < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_10167FA30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_10167FA4C(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  sub_10000501C(__p, "AppCategory:");
  sub_10167F7D4(a3, a1, a2, __p);
  if (v7 < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_10167FAB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_10167FAD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = a1;
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    __p[2] = *(a2 + 16);
  }

  sub_10010BE30(&v8, a3);
  v5 = *(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_10167FC6C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    sub_10004F058(a1);
  }

  _Unwind_Resume(a1);
}

void sub_10167FC7C(uint64_t a1, uint64_t a2)
{
  if (*(a2 + 23) < 0)
  {
    sub_100005F2C(__p, *a2, *(a2 + 8));
  }

  else
  {
    *__p = *a2;
    v5 = *(a2 + 16);
  }

  v3 = *(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_10167FDC4(uint64_t a1)
{
  v2 = *(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = CSIBOOLAsString(*(a1 + 96));
    *buf = 136315138;
    v40 = v3;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I eSimModificationAllowed: %s", buf, 0xCu);
    v2 = *(a1 + 40);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4 = CSIBOOLAsString(*(a1 + 97));
    *buf = 136315138;
    v40 = v4;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I eSimOutgoingTransferAllowed: %s", buf, 0xCu);
    v2 = *(a1 + 40);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v5 = CSIBOOLAsString(*(a1 + 200));
    *buf = 136315138;
    v40 = v5;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I isSupervised: %s", buf, 0xCu);
    v2 = *(a1 + 40);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v6 = CSIBOOLAsString(*(a1 + 201));
    *buf = 136315138;
    v40 = v6;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I isRCSMessagingAllowedForDevice: %s", buf, 0xCu);
    v2 = *(a1 + 40);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v7 = CSIBOOLAsString(*(a1 + 202));
    *buf = 136315138;
    v40 = v7;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I isIDSAllowedForDevice: %s", buf, 0xCu);
    v2 = *(a1 + 40);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(a1 + 204) == 1)
    {
      v8 = CSIBOOLAsString(*(a1 + 203));
    }

    else
    {
      v8 = "unknown";
    }

    *buf = 136315138;
    v40 = v8;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fIsSatelliteConnectionAllowed: %s", buf, 0xCu);
    v2 = *(a1 + 40);
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v9 = 0xAAAAAAAAAAAAAAABLL * ((*(a1 + 112) - *(a1 + 104)) >> 3);
    *buf = 134217984;
    v40 = v9;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %lu blocked bundle IDs", buf, 0xCu);
  }

  v10 = *(a1 + 104);
  for (i = *(a1 + 112); v10 != i; v10 += 24)
  {
    v12 = *(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = v10;
      if (*(v10 + 23) < 0)
      {
        v13 = *v10;
      }

      *buf = 136446210;
      v40 = v13;
      _os_log_impl(&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %{public}s", buf, 0xCu);
    }
  }

  v14 = *(a1 + 128);
  v15 = *(a1 + 136);
  if (v15 != v14)
  {
    v16 = *(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 134217984;
      v40 = 0xAAAAAAAAAAAAAAABLL * ((v15 - v14) >> 3);
      _os_log_impl(&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %lu managed bundle IDs", buf, 0xCu);
      v14 = *(a1 + 128);
      v15 = *(a1 + 136);
    }

    for (; v14 != v15; v14 += 24)
    {
      v17 = *(a1 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        v18 = v14;
        if (*(v14 + 23) < 0)
        {
          v18 = *v14;
        }

        *buf = 136446210;
        v40 = v18;
        _os_log_impl(&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %{public}s", buf, 0xCu);
      }
    }
  }

  v19 = *(a1 + 168);
  if (v19)
  {
    v20 = *(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 134217984;
      v40 = v19;
      _os_log_impl(&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %lu managed slice bundle IDs", buf, 0xCu);
    }

    v21 = *(a1 + 152);
    if (v21 != (a1 + 160))
    {
      do
      {
        v22 = *(a1 + 40);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          v23 = v21 + 4;
          if (*(v21 + 55) < 0)
          {
            v23 = *v23;
          }

          v24 = (v21 + 7);
          if (*(v21 + 79) < 0)
          {
            v24 = *v24;
          }

          *buf = 136446466;
          v40 = v23;
          v41 = 2082;
          v42 = v24;
          _os_log_impl(&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %{public}s : %{public}s", buf, 0x16u);
        }

        v25 = v21[1];
        if (v25)
        {
          do
          {
            v26 = v25;
            v25 = *v25;
          }

          while (v25);
        }

        else
        {
          do
          {
            v26 = v21[2];
            v27 = *v26 == v21;
            v21 = v26;
          }

          while (!v27);
        }

        v21 = v26;
      }

      while (v26 != (a1 + 160));
    }
  }

  v28 = *(a1 + 224);
  if (v28)
  {
    v29 = *(a1 + 40);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 134217984;
      v40 = v28;
      _os_log_impl(&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %lu ICCID policies", buf, 0xCu);
    }

    v30 = *(a1 + 208);
    if (v30 != (a1 + 216))
    {
      do
      {
        v31 = *(a1 + 40);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          v32 = v30 + 4;
          if (*(v30 + 55) < 0)
          {
            v32 = *v32;
          }

          v33 = CSIBOOLAsString(*(v30 + 56));
          v34 = CSIBOOLAsString(*(v30 + 57));
          *buf = 136446722;
          v40 = v32;
          v41 = 2080;
          v42 = v33;
          v43 = 2080;
          v44 = v34;
          _os_log_impl(&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I ICCID: %{public}s -> isRCSMessagingAllowed: %s, isIDSAllowed: %s", buf, 0x20u);
        }

        v35 = v30[1];
        if (v35)
        {
          do
          {
            v36 = v35;
            v35 = *v35;
          }

          while (v35);
        }

        else
        {
          do
          {
            v36 = v30[2];
            v27 = *v36 == v30;
            v30 = v36;
          }

          while (!v27);
        }

        v30 = v36;
      }

      while (v36 != (a1 + 216));
    }
  }

  v37 = *(a1 + 192);
  if (v37)
  {
    v38 = *(a1 + 40);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *buf = 134217984;
      v40 = v37;
      _os_log_impl(&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I %lu managed slice callbacks", buf, 0xCu);
    }
  }
}

void sub_101680488()
{
  v0 = 0;
  v1 = 0;
  v2 = "ManagedConfiguration";
  sub_1001048A4();
}

void sub_1016805E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

void sub_101680680(uint64_t a1, uint64_t a2)
{
  v4 = (a1 + 128);
  if (v4 != (a2 + 32))
  {
    sub_100008234(v4, *(a2 + 32), *(a2 + 40), 0xAAAAAAAAAAAAAAABLL * ((*(a2 + 40) - *(a2 + 32)) >> 3));
  }

  *(a1 + 200) = *(a2 + 2);
  if (a1 + 152 != a2 + 56)
  {
    sub_1001732FC((a1 + 152), *(a2 + 56), (a2 + 64));
  }

  v5 = *(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 0xAAAAAAAAAAAAAAABLL * ((*(a1 + 136) - *(a1 + 128)) >> 3);
    v7 = *(a1 + 168);
    v8 = *(a1 + 200);
    v15 = 134218496;
    v16 = v6;
    v17 = 2048;
    v18 = v7;
    v19 = 1024;
    v20 = v8;
    _os_log_impl(&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %lu managed bundleids; %lu managed slice bundleids, supervised = %d", &v15, 0x1Cu);
  }

  v9 = *(a1 + 176);
  v10 = (a1 + 184);
  if (v9 != v10)
  {
    do
    {
      v11 = v9[10];
      if (!v11)
      {
        sub_100022DB4();
      }

      (*(*v11 + 48))(v11);
      v12 = v9[1];
      if (v12)
      {
        do
        {
          v13 = v12;
          v12 = *v12;
        }

        while (v12);
      }

      else
      {
        do
        {
          v13 = v9[2];
          v14 = *v13 == v9;
          v9 = v13;
        }

        while (!v14);
      }

      v9 = v13;
    }

    while (v13 != v10);
  }
}

void sub_101680824(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101680878(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1016808B8(uint64_t result)
{
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void sub_1016808E4(ServiceManager::Service *this)
{
  *this = off_101F5FED8;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_101680940(ServiceManager::Service *this)
{
  *this = off_101F5FED8;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_1016809C0@<X0>(void *a1@<X8>)
{
  v2 = 3;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  return sub_1000FF040(a1, &v2, &vars0, 1);
}

void sub_101680A04(uint64_t a1, dispatch_object_t *a2)
{
  v2 = *(a1 + 8);
  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_10167E75C(v2, v3);
  }

  v4 = *(a1 + 8);

  sub_10167E75C(v4, 0);
}

void sub_101680AA4(uint64_t a1)
{
  v1 = *(*(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_101680B84(uint64_t a1, int a2, ServiceStage *this)
{
  v3 = *(a1 + 8);
  ServiceStage::holdOffStage(&group[1], this);
  v4 = *(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_101680C98(void *a1)
{
  if (a1)
  {
    sub_101680C98(*a1);
    sub_101680C98(a1[1]);
    sub_101680CEC((a1 + 4));

    operator delete(a1);
  }
}

void sub_101680CEC(uint64_t a1)
{
  sub_10002B644(a1 + 24);
  if (*(a1 + 23) < 0)
  {
    v2 = *a1;

    operator delete(v2);
  }
}

uint64_t *sub_101680D3C(uint64_t *a1)
{
  v1 = *a1;
  v3 = a1;
  v4 = v1;
  ctu::RestModule::disconnect((*v1 + 64));
  sub_1000FF844(&v4);
  return sub_1000049E0(&v3);
}

void sub_101680D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_101680DA0(void *a1)
{
  v1 = *a1;
  v2 = a1;
  v3 = v1;
  sub_10000501C(&__p, "/cc/events/dump_state");
  operator new();
}

void sub_1016810BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, std::__shared_weak_count *a22)
{
  if (a22)
  {
    sub_100004A34(a22);
  }

  sub_100004A34(v22);
  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1016811C4(uint64_t a1)
{
  result = (*(**(a1 + 40) + 16))();
  **(a1 + 32) = result;
  return result;
}

uint64_t sub_101681210@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v2 = **(a1 + 40);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  return sub_10004EFD0(a2, *(v2 + 104), *(v2 + 112), 0xAAAAAAAAAAAAAAABLL * ((*(v2 + 112) - *(v2 + 104)) >> 3));
}

void sub_101681240(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v3);
  v2 = *(a1 + 32);
  sub_100071A6C(v2);
  *v2 = v3;
  *(v2 + 16) = v4;
  v3 = 0uLL;
  v4 = 0;
  v5 = &v3;
  sub_1000087B4(&v5);
}

void sub_1016812B0(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v3);
  v2 = *(a1 + 32);
  sub_100071A6C(v2);
  *v2 = v3;
  *(v2 + 16) = v4;
  v3 = 0uLL;
  v4 = 0;
  v5 = &v3;
  sub_1000087B4(&v5);
}

BOOL sub_101681320(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *(*v1 + 104);
  v3 = *(*v1 + 112);
  if (v2 != v3)
  {
    v6 = v1[1];
    v4 = v1 + 1;
    v5 = v6;
    v7 = *(v4 + 23);
    if (v7 >= 0)
    {
      v8 = *(v4 + 23);
    }

    else
    {
      v8 = v4[1];
    }

    if (v7 >= 0)
    {
      v9 = v4;
    }

    else
    {
      v9 = v5;
    }

    while (1)
    {
      v10 = *(v2 + 23);
      v11 = v10;
      if ((v10 & 0x80u) != 0)
      {
        v10 = *(v2 + 8);
      }

      if (v10 == v8)
      {
        v12 = v11 >= 0 ? v2 : *v2;
        if (!memcmp(v12, v9, v8))
        {
          break;
        }
      }

      v2 += 24;
      if (v2 == v3)
      {
        v2 = v3;
        return v2 != v3;
      }
    }
  }

  return v2 != v3;
}

uint64_t sub_1016813C4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v2 = **(a1 + 40);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  return sub_10004EFD0(a2, *(v2 + 128), *(v2 + 136), 0xAAAAAAAAAAAAAAABLL * ((*(v2 + 136) - *(v2 + 128)) >> 3));
}

BOOL sub_1016813F4(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *(*v1 + 128);
  v3 = *(*v1 + 136);
  if (v2 != v3)
  {
    v6 = v1[1];
    v4 = v1 + 1;
    v5 = v6;
    v7 = *(v4 + 23);
    if (v7 >= 0)
    {
      v8 = *(v4 + 23);
    }

    else
    {
      v8 = v4[1];
    }

    if (v7 >= 0)
    {
      v9 = v4;
    }

    else
    {
      v9 = v5;
    }

    while (1)
    {
      v10 = *(v2 + 23);
      v11 = v10;
      if ((v10 & 0x80u) != 0)
      {
        v10 = *(v2 + 8);
      }

      if (v10 == v8)
      {
        v12 = v11 >= 0 ? v2 : *v2;
        if (!memcmp(v12, v9, v8))
        {
          break;
        }
      }

      v2 += 24;
      if (v2 == v3)
      {
        v2 = v3;
        return v2 != v3;
      }
    }
  }

  return v2 != v3;
}

BOOL sub_101681498(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  return v2 + 160 != sub_100007A6C(*v1 + 152, v1 + 1);
}

uint64_t sub_101681500(uint64_t a1)
{
  v1 = *(a1 + 40);
  v2 = *v1;
  v3 = sub_100007A6C(*v1 + 208, v1 + 1);
  if (v2 + 216 == v3)
  {
    v4 = 1;
  }

  else
  {
    v4 = *(v3 + 56);
  }

  return v4 & 1;
}

uint64_t sub_101681558(uint64_t a1)
{
  result = (*(**(a1 + 40) + 16))();
  **(a1 + 32) = result;
  return result;
}

uint64_t sub_101681594(uint64_t a1)
{
  result = (*(**(a1 + 40) + 16))();
  **(a1 + 32) = result;
  return result;
}

std::string *sub_1016815D0@<X0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  v3 = *(a1 + 40);
  v4 = *v3;
  if (v4 + 160 != sub_100007A6C(*v3 + 152, v3 + 1))
  {
    v5 = sub_1000E20F0((v4 + 152), v3 + 1);
    v6 = v5;
    v7 = *(v3 + 55);
    if ((v7 & 0x8000000000000000) != 0)
    {
      v7 = v3[5];
    }

    v8 = *(v5 + 23);
    if ((v8 & 0x80u) != 0)
    {
      v8 = *(v5 + 8);
    }

    if (v8 > v7)
    {
      std::string::basic_string(&__p, v5, 0, v7, &v18);
      v9 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }

      else
      {
        size = __p.__r_.__value_.__l.__size_;
      }

      v11 = *(v3 + 55);
      v12 = v11;
      if (v11 < 0)
      {
        v11 = v3[5];
      }

      if (size == v11)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          p_p = &__p;
        }

        else
        {
          p_p = __p.__r_.__value_.__r.__words[0];
        }

        if (v12 >= 0)
        {
          v14 = v3 + 4;
        }

        else
        {
          v14 = v3[4];
        }

        v15 = memcmp(p_p, v14, size) == 0;
        if (v9 < 0)
        {
LABEL_27:
          operator delete(__p.__r_.__value_.__l.__data_);
          if (!v15)
          {
            return sub_10000501C(a2, "");
          }

          return std::string::basic_string(a2, v6, v7, 0xFFFFFFFFFFFFFFFFLL, &__p);
        }
      }

      else
      {
        v15 = 0;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          goto LABEL_27;
        }
      }

      if (!v15)
      {
        return sub_10000501C(a2, "");
      }

      return std::string::basic_string(a2, v6, v7, 0xFFFFFFFFFFFFFFFFLL, &__p);
    }
  }

  return sub_10000501C(a2, "");
}

__n128 sub_101681758(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v4);
  v2 = *(a1 + 32);
  if (*(v2 + 23) < 0)
  {
    operator delete(*v2);
  }

  result = v4;
  *(v2 + 16) = v5;
  *v2 = result;
  return result;
}

__n128 sub_1016817BC(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(&v4);
  v2 = *(a1 + 32);
  if (*(v2 + 23) < 0)
  {
    operator delete(*v2);
  }

  result = v4;
  *(v2 + 16) = v5;
  *v2 = result;
  return result;
}

uint64_t *sub_101681820(void ***a1)
{
  v1 = *a1;
  v6 = a1;
  v7 = v1;
  v3 = *v1 + 184;
  v2 = *v3;
  if (!*v3)
  {
    goto LABEL_7;
  }

  while (1)
  {
    while (1)
    {
      v4 = v2;
      if ((sub_1000068BC(v1 + 1, (v2 + 32)) & 0x80) == 0)
      {
        break;
      }

      v2 = *v4;
      v3 = v4;
      if (!*v4)
      {
        goto LABEL_7;
      }
    }

    if ((sub_1000068BC(v4 + 4, v1 + 1) & 0x80) == 0)
    {
      break;
    }

    v3 = (v4 + 1);
    v2 = v4[1];
    if (!v2)
    {
      goto LABEL_7;
    }
  }

  if (!*v3)
  {
LABEL_7:
    operator new();
  }

  sub_10025ABF0((*v3 + 56), (v1 + 4));
  sub_1016819BC(&v7);
  return sub_1000049E0(&v6);
}

void sub_101681990(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void);
  va_copy(va2, va1);
  v5 = va_arg(va2, void);
  sub_101681A1C(va2);
  sub_1016819BC(va1);
  sub_1000049E0(va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1016819BC(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_10002B644(v1 + 32);
    if (*(v1 + 31) < 0)
    {
      operator delete(*(v1 + 8));
    }

    operator delete();
  }

  return result;
}

uint64_t sub_101681A1C(uint64_t a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(a1 + 16) == 1)
    {
      sub_101680CEC(v2 + 32);
    }

    operator delete(v2);
  }

  return a1;
}

uint64_t *sub_101681A68(void **a1)
{
  v1 = *a1;
  v15 = a1;
  v16 = v1;
  v4 = *v1;
  v2 = (v1 + 1);
  v3 = v4;
  v5 = v4 + 23;
  v6 = v4[23];
  if (v6)
  {
    v7 = v5;
    do
    {
      v8 = sub_1000068BC(v6 + 4, v2);
      if ((v8 & 0x80u) == 0)
      {
        v7 = v6;
      }

      v6 = *(v6 + ((v8 >> 4) & 8));
    }

    while (v6);
    if (v7 != v5 && (sub_1000068BC(v2, v7 + 4) & 0x80) == 0)
    {
      v9 = v7[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *v9;
        }

        while (v9);
      }

      else
      {
        v11 = v7;
        do
        {
          v10 = v11[2];
          v12 = *v10 == v11;
          v11 = v10;
        }

        while (!v12);
      }

      if (v3[22] == v7)
      {
        v3[22] = v10;
      }

      v13 = v3[23];
      --v3[24];
      sub_100018288(v13, v7);
      sub_101680CEC((v7 + 4));
      operator delete(v7);
    }
  }

  sub_1000EF424(&v16);
  return sub_1000049E0(&v15);
}

__n128 sub_101681BE8(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F5FF98;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_101681C20(void *a1)
{
  v1 = a1[2];
  v2 = a1[3];
  v3 = (a1[1] + (v2 >> 1));
  if (v2)
  {
    return (*(*v3 + v1))();
  }

  else
  {
    return v1(v3);
  }
}

uint64_t sub_101681C68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_101681CB4(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = *(v1 + 16);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      if (*(v1 + 8))
      {
        sub_101680488();
      }

      sub_100004A34(v3);
    }
  }
}

uint64_t sub_101681D3C(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 40);
  *(result + 32) = *(a2 + 32);
  *(result + 40) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_101681D58(uint64_t a1)
{
  v1 = *(a1 + 40);
  if (v1)
  {
    sub_100004A34(v1);
  }
}

void sub_101681D88(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F60048;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101681DDC(uint64_t a1)
{
  v1 = *(a1 + 40);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_101681DF0(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = *(v1 + 16);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      if (*(v1 + 8))
      {
        sub_1001048A4();
      }

      sub_100004A34(v3);
    }
  }
}

void sub_101681FB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10168205C(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 40);
  *(result + 32) = *(a2 + 32);
  *(result + 40) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_101682078(uint64_t a1)
{
  v1 = *(a1 + 40);
  if (v1)
  {
    sub_100004A34(v1);
  }
}

void sub_1016820A8(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F600C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1016820FC(uint64_t a1)
{
  v1 = *(a1 + 40);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void *sub_101682110(void *a1)
{
  *a1 = off_101F60118;
  v2 = a1[3];
  if (v2)
  {
    sub_100004A34(v2);
  }

  return a1;
}

void sub_10168215C(void *a1)
{
  *a1 = off_101F60118;
  v1 = a1[3];
  if (v1)
  {
    sub_100004A34(v1);
  }

  operator delete();
}

uint64_t sub_10168223C(uint64_t result, uint64_t a2)
{
  *a2 = off_101F60118;
  *(a2 + 8) = *(result + 8);
  v2 = *(result + 24);
  *(a2 + 24) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_10168227C(uint64_t a1)
{
  v1 = *(a1 + 24);
  if (v1)
  {
    sub_100004A34(v1);
  }
}

void sub_10168228C(void *__p)
{
  v2 = __p[3];
  if (v2)
  {
    sub_100004A34(v2);
  }

  operator delete(__p);
}

void sub_1016822CC(uint64_t a1, xpc_object_t *a2)
{
  object = *a2;
  *a2 = xpc_null_create();
  v40 = 0x101000101;
  v45 = &v46;
  v46 = 0;
  v49 = 0;
  v50 = 0;
  v47 = 0;
  v48 = &v49;
  rest::read_rest_value();
  *v30 = 16777473;
  *&v30[4] = 1;
  v31 = 0u;
  v32 = 0;
  v42 = 0;
  v41 = 0uLL;
  v33 = 0uLL;
  v44 = 0;
  v43 = 0uLL;
  v34 = 0;
  v35 = &v46;
  v36[0] = v46;
  v36[1] = v47;
  if (v47)
  {
    v46[2] = v36;
    v45 = &v46;
    v46 = 0;
    v47 = 0;
  }

  else
  {
    v35 = v36;
  }

  v37 = v48;
  v38 = v49;
  v39 = v50;
  if (v50)
  {
    *(v49 + 2) = &v38;
    v48 = &v49;
    v49 = 0;
    v50 = 0;
  }

  else
  {
    v37 = &v38;
  }

  v3 = *(a1 + 8);
  v4 = *(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    rest::asString();
    v5 = v54 >= 0 ? v51 : *v51;
    LODWORD(buf[0]) = 136315138;
    *(buf + 4) = v5;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I UPD get_managed_configuration_info: %s", buf, 0xCu);
    if (SHIBYTE(v54) < 0)
    {
      operator delete(*v51);
    }
  }

  *(v3 + 96) = *v30;
  if ((v3 + 104) != &v31)
  {
    sub_100008234((v3 + 104), v31, *(&v31 + 1), 0xAAAAAAAAAAAAAAABLL * ((*(&v31 + 1) - v31) >> 3));
  }

  v7 = v3 + 216;
  v6 = *(v3 + 216);
  *(v3 + 201) = *&v30[3];
  *(v3 + 203) = v30[5] | 0x100;
  sub_1010DD940(v6);
  v8 = v38;
  *(v3 + 208) = v37;
  *(v3 + 216) = v8;
  v9 = v39;
  *(v3 + 224) = v39;
  if (v9)
  {
    *(v8 + 2) = v7;
    v37 = &v38;
    v38 = 0;
    v39 = 0;
  }

  else
  {
    *(v3 + 208) = v7;
  }

  v10 = *(v3 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    v11 = CSIBOOLAsString(*(v3 + 96));
    v12 = CSIBOOLAsString(*(v3 + 97));
    v14 = *(v3 + 104);
    v13 = *(v3 + 112);
    v15 = CSIBOOLAsString(*(v3 + 201));
    v16 = CSIBOOLAsString(*(v3 + 202));
    v17 = *(v3 + 224);
    *v51 = 136316418;
    *&v51[4] = v11;
    v52 = 2080;
    v53 = v12;
    v54 = 2048;
    v55 = 0xAAAAAAAAAAAAAAABLL * ((v13 - v14) >> 3);
    v56 = 2080;
    v57 = v15;
    v58 = 2080;
    v59 = v16;
    v60 = 2048;
    v61 = v17;
    _os_log_impl(&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I eSimModificationAllowed: %s - eSimOutgoingTransferAllowed: %s - %lu blocked bundleids - isRCSMessagingAllowedForDevice: %s - isIDSAllowedForDevice: %s - %lu ICCID policies", v51, 0x3Eu);
  }

  sub_101680680(v3, v30);
  if ((*(v3 + 96) & 1) == 0)
  {
    ServiceMap = Registry::getServiceMap(*(v3 + 48));
    v19 = ServiceMap;
    if (v20 < 0)
    {
      v21 = (v20 & 0x7FFFFFFFFFFFFFFFLL);
      v22 = 5381;
      do
      {
        v20 = v22;
        v23 = *v21++;
        v22 = (33 * v22) ^ v23;
      }

      while (v23);
    }

    std::mutex::lock(ServiceMap);
    *v51 = v20;
    v24 = sub_100009510(&v19[1].__m_.__sig, v51);
    if (v24)
    {
      v26 = v24[3];
      v25 = v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v19);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100004A34(v25);
        v27 = 0;
        if (!v26)
        {
          goto LABEL_27;
        }

        goto LABEL_31;
      }
    }

    else
    {
      v26 = 0;
    }

    std::mutex::unlock(v19);
    v25 = 0;
    v27 = 1;
    if (!v26)
    {
LABEL_27:
      v28 = *(v3 + 40);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *v51 = 0;
        _os_log_error_impl(&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "No followupController", v51, 2u);
      }

      goto LABEL_32;
    }

LABEL_31:
    (*(*v26 + 24))(v26, 3);
LABEL_32:
    if ((v27 & 1) == 0)
    {
      sub_100004A34(v25);
    }
  }

  sub_10000501C(v51, "/cc/events/managed_configuration_changed");
  buf[0] = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(buf[0]);
  buf[0] = 0;
  if (SHIBYTE(v54) < 0)
  {
    operator delete(*v51);
  }

  sub_1010DD940(v38);
  sub_1000DD0AC(&v35, v36[0]);
  *v51 = &v33;
  sub_1000087B4(v51);
  *v51 = &v31;
  sub_1000087B4(v51);
  sub_1010DD940(v49);
  sub_1000DD0AC(&v45, v46);
  *v51 = &v43;
  sub_1000087B4(v51);
  *v51 = &v41;
  sub_1000087B4(v51);
  xpc_release(object);
}

void sub_1016827D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  if ((v25 & 1) == 0)
  {
    sub_100004A34(v24);
  }

  sub_1016828AC(&a11);
  sub_1016828AC(&a24);
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_101682860(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1016828AC(uint64_t a1)
{
  sub_1010DD940(*(a1 + 88));
  sub_1000DD0AC(a1 + 56, *(a1 + 64));
  v3 = (a1 + 32);
  sub_1000087B4(&v3);
  v3 = (a1 + 8);
  sub_1000087B4(&v3);
  return a1;
}

void *sub_10168290C(void *a1)
{
  *a1 = off_101F60198;
  v2 = a1[3];
  if (v2)
  {
    sub_100004A34(v2);
  }

  return a1;
}

void sub_101682958(void *a1)
{
  *a1 = off_101F60198;
  v1 = a1[3];
  if (v1)
  {
    sub_100004A34(v1);
  }

  operator delete();
}

uint64_t sub_101682A38(uint64_t result, uint64_t a2)
{
  *a2 = off_101F60198;
  *(a2 + 8) = *(result + 8);
  v2 = *(result + 24);
  *(a2 + 24) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_101682A78(uint64_t a1)
{
  v1 = *(a1 + 24);
  if (v1)
  {
    sub_100004A34(v1);
  }
}

void sub_101682A88(void *__p)
{
  v2 = __p[3];
  if (v2)
  {
    sub_100004A34(v2);
  }

  operator delete(__p);
}

void sub_101682AC8(uint64_t a1, xpc_object_t *a2)
{
  object = *a2;
  *a2 = xpc_null_create();
  v13[2] = (&loc_101000100 + 1);
  v18 = &v19;
  v19 = 0;
  v22 = 0;
  v23 = 0;
  v20 = 0;
  v21 = &v22;
  rest::read_rest_value();
  v4 = 16777473;
  v5 = 1;
  v6 = 0u;
  v7 = 0;
  v15 = 0;
  v14 = 0uLL;
  v8 = 0uLL;
  v17 = 0;
  v16 = 0uLL;
  v9 = 0;
  v10 = &v19;
  v11[0] = v19;
  v11[1] = v20;
  if (v20)
  {
    v19[2] = v11;
    v18 = &v19;
    v19 = 0;
    v20 = 0;
  }

  else
  {
    v10 = v11;
  }

  v12 = v21;
  v13[0] = v22;
  v13[1] = v23;
  if (v23)
  {
    *(v22 + 2) = v13;
    v21 = &v22;
    v22 = 0;
    v23 = 0;
  }

  else
  {
    v12 = v13;
  }

  sub_101680680(*(a1 + 8), &v4);
  sub_1010DD940(v13[0]);
  sub_1000DD0AC(&v10, v11[0]);
  v24 = &v8;
  sub_1000087B4(&v24);
  v24 = &v6;
  sub_1000087B4(&v24);
  sub_1010DD940(v22);
  sub_1000DD0AC(&v18, v19);
  v24 = &v16;
  sub_1000087B4(&v24);
  v24 = &v14;
  sub_1000087B4(&v24);
  xpc_release(object);
}

void sub_101682C78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23)
{
  sub_1016828AC(&a10);
  sub_1016828AC(&a23);
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_101682CAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void stewie::TargetFactory::create(uint64_t *a1@<X0>, os_log_t *a2@<X2>, void *a3@<X8>)
{
  v5 = *a1;
  if (v5)
  {
    *v10 = 0u;
    v11 = 0u;
    (*(*v5 + 16))(v10);
    if (BYTE8(v11))
    {
      v9[0] = 0;
      v9[1] = 0;
      *v8 = v9;
      if (*v10 != *&v10[8])
      {
        stewie::TargetData::create();
      }

      operator new();
    }

    v7 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
    {
      *v8 = 0;
      _os_log_error_impl(&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to create targetCoords", v8, 2u);
    }

    *a3 = 0;
    a3[1] = 0;
    if (BYTE8(v11) == 1)
    {
      *v8 = v10;
      sub_101459A2C(v8);
    }
  }

  else
  {
    v6 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
    {
      *v10 = 0;
      _os_log_error_impl(&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "targetCoordsFactory must be provided", v10, 2u);
    }

    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_10168307C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, void *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, char a20)
{
  (*(*v20 + 8))(v20);
  sub_100D92208(a14);
  if (a20)
  {
    a13 = &a17;
    sub_101459A2C(&a13);
  }

  _Unwind_Resume(a1);
}

void sub_1016830FC(uint64_t a1)
{
  v1 = *(a1 + 32);
  if (v1 && *v1 != v1 + 1)
  {
    operator new();
  }

  v2 = *(a1 + 8);
  if (v2 != a1 + 16)
  {
    v3 = *(a1 + 32);
    if (v3)
    {
        ;
      }
    }

    operator new();
  }

  stewie::Targets::create();
}

void sub_101683484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, void *a12, uint64_t a13, char a14, void *a15)
{
  sub_10006EC28(&a11, a12);
  sub_10006DCAC(&a14, a15);
  _Unwind_Resume(a1);
}

uint64_t sub_1016834C4@<X0>(uint64_t a1@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  v6 = *(a1 + 16);
  result = a1 + 16;
  v5 = v6;
  if (v6)
  {
    v7 = *a2;
    v8 = result;
    do
    {
      v9 = *(v5 + 32);
      v10 = v9 >= v7;
      v11 = v9 < v7;
      if (v10)
      {
        v8 = v5;
      }

      v5 = *(v5 + 8 * v11);
    }

    while (v5);
    if (v8 != result && v7 >= *(v8 + 32))
    {
      operator new();
    }
  }

  *a3 = 0;
  a3[1] = 0;
  return result;
}

uint64_t sub_1016835F8(uint64_t a1)
{
  *a1 = off_101F60218;
  v2 = *(a1 + 40);
  if (v2)
  {
    sub_100004A34(v2);
  }

  sub_100D92208(*(a1 + 16));
  return a1;
}

void sub_10168364C(uint64_t a1)
{
  *a1 = off_101F60218;
  v2 = *(a1 + 40);
  if (v2)
  {
    sub_100004A34(v2);
  }

  sub_100D92208(*(a1 + 16));

  operator delete();
}

void sub_1016836C4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1016836FC(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

uint64_t sub_10168372C(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

void sub_10168378C(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F602D8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101683808(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F60328;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101683930(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object)
{
  if (a11)
  {
    (*(*a11 + 8))(a11);
  }

  if (object)
  {
    dispatch_release(object);
  }

  _Unwind_Resume(exception_object);
}

void sub_101683A2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object)
{
  if (a11)
  {
    (*(*a11 + 8))(a11);
  }

  if (object)
  {
    dispatch_release(object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_101683A7C@<X0>(capabilities::ct *a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  result = capabilities::ct::getCDMASettingsSupport(a1);
  if (result == 1)
  {
    *a2 = 0;
    sub_101556F68();
  }

  if (result == 2)
  {
    *a2 = 0;
    sub_101650300();
  }

  *a3 = 0;
  a3[1] = 0;
  return result;
}

void sub_101683BC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t object, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a10)
  {
    (*(*a10 + 8))(a10);
  }

  if (object)
  {
    dispatch_release(object);
  }

  _Unwind_Resume(exception_object);
}

void sub_101683C4C(uint64_t a1@<X0>, NSObject **a2@<X1>, _OWORD *a3@<X8>)
{
  v5 = *a2;
  if (*a2)
  {
    dispatch_retain(v5);
  }

  sub_100EA809C((a1 + 8), &v6);
  *a3 = v6;
  v6 = 0uLL;
  if (v5)
  {
    dispatch_release(v5);
  }
}

void sub_101683CBC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_release(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_101683CD4(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2)
  {
    dispatch_retain(*a2);
  }

  sub_10159BCDC();
}

void sub_101683D4C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_release(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_101683D64(SettingsFactoryInterface *this)
{
  *this = off_101F60378;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  SettingsFactoryInterface::~SettingsFactoryInterface(this);
}

void sub_101683DC0(SettingsFactoryInterface *this)
{
  *this = off_101F60378;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  SettingsFactoryInterface::~SettingsFactoryInterface(this);

  operator delete();
}

void *sub_101683E30(void *a1, uint64_t *a2, uint64_t *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_101446658(a1, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  sub_101686600((a1 + 3), *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3));
  return a1;
}

void sub_101683EB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001DFF90(va);
  _Unwind_Resume(a1);
}

void *sub_101683EC8(void *a1, uint64_t *a2)
{
  memset(v4, 0, sizeof(v4));
  sub_101683E30(a1, v4, a2);
  v5 = v4;
  sub_1001DFF90(&v5);
  return a1;
}

void sub_101683F18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1001DFF90(va);
  _Unwind_Resume(a1);
}

void sub_101683F30(void *a1, uint64_t *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_101446658(a1, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  v4 = a2[3];
  v5 = a2[4];
  while (v4 != v5)
  {
    sub_101684AF8(__p, v4, 0x14u);
    sub_100FD7EB0(a1, __p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    v4 += 3;
  }
}

double *sub_101683FFC(double *a1, const void **a2)
{
  *a1 = xmmword_1019ADE70;
  a1[2] = 0.65;
  if (*a2)
  {
    v12 = 0.0;
    valuePtr = 0.0;
    v11 = 0.0;
    sub_100010024(&theDict, a2);
    v15 = 0;
    Value = CFDictionaryGetValue(theDict, @"R");
    sub_1002AF4F0(&v15, &Value);
    if (v15)
    {
      CFNumberGetValue(v15, kCFNumberDoubleType, &valuePtr);
    }

    sub_100029A48(&v15);
    sub_10001021C(&theDict);
    sub_100010024(&v9, a2);
    v15 = 0;
    Value = CFDictionaryGetValue(v9, @"I");
    sub_1002AF4F0(&v15, &Value);
    if (v15)
    {
      CFNumberGetValue(v15, kCFNumberDoubleType, &v12);
    }

    sub_100029A48(&v15);
    sub_10001021C(&v9);
    sub_100010024(&v8, a2);
    v15 = 0;
    Value = CFDictionaryGetValue(v8, @"S");
    sub_1002AF4F0(&v15, &Value);
    if (v15)
    {
      CFNumberGetValue(v15, kCFNumberDoubleType, &v11);
    }

    sub_100029A48(&v15);
    sub_10001021C(&v8);
    v4 = valuePtr;
    if (valuePtr <= 0.0)
    {
      v4 = a1[1];
    }

    a1[1] = v4;
    v5 = v12;
    if (v12 <= 0.0 || v12 >= 1.0)
    {
      v5 = *a1;
    }

    *a1 = v5;
    v6 = v11;
    if (v11 <= 0.0 || v11 >= 1.0)
    {
      v6 = a1[2];
    }

    a1[2] = v6;
  }

  return a1;
}

void sub_1016841A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_100029A48((v9 - 24));
  sub_10001021C(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_101684200@<X0>(_BYTE *a1@<X8>)
{
  v22 = 0;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  *__p = 0u;
  v11 = 0u;
  v8 = 0u;
  memset(v9, 0, sizeof(v9));
  v7 = 0u;
  sub_10000C320(&v7);
  *(&v7 + *(v7 - 24) + 16) = 2;
  *(&v9[-1] + *(v8 - 24) + 8) = *(&v9[-1] + *(v8 - 24) + 8) & 0xFFFFFEFB | 4;
  sub_10000C030(&v8);
  v2 = std::ostream::operator<<();
  sub_10000C030(v2);
  v3 = std::ostream::operator<<();
  sub_10000C030(v3);
  v4 = std::ostream::operator<<();
  sub_10000C030(v4);
  sub_100061574(&v7, a1);
  *&v8 = v5;
  if (SHIBYTE(v11) < 0)
  {
    operator delete(__p[1]);
  }

  std::locale::~locale(v9);
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

uint64_t sub_101684468@<X0>(uint64_t *a1@<X0>, std::string *a2@<X8>)
{
  v37 = 0;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  *v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  memset(v24, 0, sizeof(v24));
  v22 = 0u;
  sub_10000C320(&v22);
  *(&v24[-1] + *(v23 - 24) + 8) = *(&v24[-1] + *(v23 - 24) + 8) & 0xFFFFFEFB | 4;
  *(&v22 + *(v22 - 24) + 16) = 6;
  v4 = *a1;
  v5 = a1[1];
  if (*a1 == v5)
  {
    v7 = *a1;
  }

  else
  {
    v6 = 1;
    do
    {
      std::ostream::operator<<();
      std::ostream::operator<<();
      std::ostream::operator<<();
      ++v6;
      v4 += 16;
    }

    while (v4 != v5);
    v4 = *a1;
    v7 = a1[1];
  }

  std::to_string(&v20, (v7 - v4) >> 4);
  v8 = std::string::insert(&v20, 0, "P_", 2uLL);
  v9 = *&v8->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *&v21.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  sub_100061574(&v22, __p);
  v10 = sub_1000D3314(&v18, __p);
  std::to_string(&v19, v10 % 0xF4240);
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v11 = &v19;
  }

  else
  {
    v11 = v19.__r_.__value_.__r.__words[0];
  }

  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(v19.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = v19.__r_.__value_.__l.__size_;
  }

  v13 = std::string::append(&v21, v11, size);
  *a2 = *v13;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v19.__r_.__value_.__l.__data_);
  }

  if (v17 < 0)
  {
    operator delete(__p[0]);
  }

  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v21.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v20.__r_.__value_.__l.__data_);
  }

  *&v23 = v14;
  if (SHIBYTE(v26) < 0)
  {
    operator delete(v25[1]);
  }

  std::locale::~locale(v24);
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1016847A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, uint64_t a34, char a35)
{
  if (a21 < 0)
  {
    operator delete(__p);
  }

  if (a14 < 0)
  {
    operator delete(a9);
  }

  if (a33 < 0)
  {
    operator delete(a28);
  }

  if (a27 < 0)
  {
    operator delete(a22);
  }

  sub_10068C9D8(&a35);
  _Unwind_Resume(a1);
}

uint64_t sub_101684818@<X0>(std::string *a1@<X8>)
{
  v25 = 0;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  memset(v12, 0, sizeof(v12));
  v10 = 0u;
  sub_10000C320(&v10);
  *(&v10 + *(v10 - 24) + 16) = 6;
  *(&v12[-1] + *(v11 - 24) + 8) = *(&v12[-1] + *(v11 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<();
  std::ostream::operator<<();
  std::ostream::operator<<();
  sub_100061574(&v10, __p);
  v2 = sub_1000D3314(&v8, __p);
  std::to_string(&v9, v2 % 0xF4240);
  v3 = std::string::insert(&v9, 0, "C_", 2uLL);
  *a1 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v9.__r_.__value_.__l.__data_);
  }

  if (v7 < 0)
  {
    operator delete(__p[0]);
  }

  *&v11 = v4;
  if (SHIBYTE(v14) < 0)
  {
    operator delete(*(&v13 + 1));
  }

  std::locale::~locale(v12);
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_101684AB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, char a23)
{
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (a15 < 0)
  {
    operator delete(a10);
  }

  sub_10068C9D8(&a23);
  _Unwind_Resume(a1);
}

void sub_101684AF8(void *a1, double *a2, unsigned int a3)
{
  v16[0] = xmmword_1019ADF7C;
  v16[1] = unk_1019ADF8C;
  v16[2] = xmmword_1019ADF9C;
  v17 = 72;
  v14 = 0;
  v15 = 0;
  __p = 0;
  sub_10090C590(&__p, v16, &v18, 0xDuLL);
  v6 = __p;
  v7 = *(v14 - 1);
  while (v6 != v14)
  {
    if (*v6 >= a3)
    {
      v7 = *v6;
      break;
    }

    ++v6;
  }

  v8 = 0;
  if (v7 <= 1)
  {
    v9 = 1;
  }

  else
  {
    v9 = v7;
  }

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v10 = 0x168 / v7;
  do
  {
    *&v16[0] = sub_101686540(*a2, a2[1], a2[2], (v8 * v10));
    *(&v16[0] + 1) = v11;
    sub_101686EC4(a1, v16);
    ++v8;
    --v9;
  }

  while (v9);
  *&v16[0] = sub_101686540(*a2, a2[1], a2[2], 0.0);
  *(&v16[0] + 1) = v12;
  sub_101686EC4(a1, v16);
  if (__p)
  {
    v14 = __p;
    operator delete(__p);
  }
}

void sub_101684C48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  v13 = *v11;
  if (*v11)
  {
    *(v11 + 8) = v13;
    operator delete(v13);
  }

  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_101684C80(uint64_t *a1, uint64_t *a2, uint64_t a3, const void **a4)
{
  if (*(a3 + 23) < 0)
  {
    **a3 = 0;
    *(a3 + 8) = 0;
  }

  else
  {
    *a3 = 0;
    *(a3 + 23) = 0;
  }

  v78 = 0;
  v76 = 0u;
  v77 = 0u;
  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  v70 = 0u;
  v71 = 0u;
  v68 = 0u;
  v69 = 0u;
  *v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  memset(v65, 0, sizeof(v65));
  v63 = 0u;
  sub_10000C320(&v63);
  *(&v63 + *(v63 - 24) + 16) = 2;
  *(&v65[-1] + *(v64 - 24) + 8) = *(&v65[-1] + *(v64 - 24) + 8) & 0xFFFFFEFB | 4;
  __p[0] = 0;
  __p[1] = 0;
  v87 = 0;
  sub_101683F30(__p, a1);
  v80 = 0;
  v81 = 0;
  v82 = 0;
  sub_101683F30(&v80, a2);
  if (__p[1] - __p[0] == v81 - v80)
  {
    if (__p[1] == __p[0])
    {
LABEL_14:
      v109 = &v80;
      sub_1001DFF90(&v109);
      v80 = __p;
      sub_1001DFF90(&v80);
      sub_1000167D4(a3, "(SC=1.0) [Regions exactly same !]", 0x21uLL);
      v22 = 0x3FF0000000000000;
      goto LABEL_76;
    }

    v8 = 0;
    v9 = 0;
    while (1)
    {
      v10 = 3 * v8;
      v13 = (__p[0] + 24 * v8);
      v11 = *v13;
      v12 = v13[1];
      v15 = &v80[v10];
      v14 = *v15;
      if (v12 - v11 != v15[1] - *v15)
      {
        break;
      }

      if (v12 != v11)
      {
        v16 = 0;
        v17 = (v12 - v11) >> 4;
        v18 = 1;
        do
        {
          v19 = (v11 + 16 * v16);
          v20 = &v14[16 * v16];
          if (vabdd_f64(v19[1], v20[1]) > 0.0001 || vabdd_f64(*v19, *v20) > 0.0001)
          {
            goto LABEL_15;
          }

          v16 = v18;
        }

        while (v17 > v18++);
      }

      v8 = ++v9;
      if (0xAAAAAAAAAAAAAAABLL * ((__p[1] - __p[0]) >> 3) <= v9)
      {
        goto LABEL_14;
      }
    }
  }

LABEL_15:
  v109 = &v80;
  sub_1001DFF90(&v109);
  v80 = __p;
  sub_1001DFF90(&v80);
  memset(v62, 0, sizeof(v62));
  sub_100010024(&v61, a4);
  sub_101683FFC(v62, &v61);
  sub_10001021C(&v61);
  v100 = 0;
  v99 = 0;
  v101 = 0;
  sub_101446658(&v99, *a1, a1[1], 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3));
  v24 = a1[3];
  v23 = a1[4];
  while (v24 != v23)
  {
    sub_101684AF8(__p, v24, 0x48u);
    sub_100FD7EB0(&v99, __p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    v24 += 3;
  }

  v97 = 0;
  v96 = 0;
  v98 = 0;
  sub_101446658(&v96, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  v26 = a2[3];
  v25 = a2[4];
  while (v26 != v25)
  {
    sub_101684AF8(__p, v26, 0x48u);
    sub_100FD7EB0(&v96, __p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    v26 += 3;
  }

  v93 = 0;
  v94 = 0;
  v95 = 0;
  sub_101686F9C(&v93, v99, v100);
  v90 = 0;
  v91 = 0;
  v92 = 0;
  sub_101686F9C(&v90, v96, v97);
  v117 = 0;
  v118 = 0;
  v119 = 0;
  sub_100ECB804(&v117, v93, v94, (v94 - v93) >> 4);
  memset(v85, 0, sizeof(v85));
  sub_101446C3C(v85, &v117, &v120, 1uLL);
  v80 = 0;
  v81 = 0;
  v82 = 0;
  sub_101683E30(__p, v85, &v80);
  v114 = 0;
  v115 = 0;
  v116 = 0;
  sub_100ECB804(&v114, v90, v91, (v91 - v90) >> 4);
  memset(v79, 0, sizeof(v79));
  sub_101446C3C(v79, &v114, &v117, 1uLL);
  v109 = 0;
  v110 = 0;
  v111 = 0;
  sub_101683E30(&v80, v79, &v109);
  v107 = 0;
  v106 = 0;
  v108 = 0;
  sub_10168614C(&v106, __p);
  memset(v105, 0, sizeof(v105));
  sub_10168614C(v105, &v80);
  v103 = 0;
  __src = 0;
  v104 = 0;
  if (v107 == v106)
  {
    v54 = 0.0;
  }

  else
  {
    v27 = 0;
    if (0xAAAAAAAAAAAAAAABLL * ((v107 - v106) >> 4) <= 1)
    {
      v28 = 1;
    }

    else
    {
      v28 = 0xAAAAAAAAAAAAAAABLL * ((v107 - v106) >> 4);
    }

    do
    {
      v29 = &v106[6 * v27];
      v109 = &v109;
      v110 = &v109;
      v111 = 0;
      v30 = &v105[0][6 * v27];
      *v113 = 0;
      sub_10168B2B4(v29, v30, v113, &v109, &v112, &v113[1]);
      *&v113[1] = 0x3FF0000000000000;
      v31 = sub_1016866CC(v29, &v113[1]);
      *&v113[1] = 0x3FF0000000000000;
      v32 = sub_1016866CC(v30, &v113[1]);
      v33 = fabs(v31 * 40680631.6);
      v34 = fabs(v32 * 40680631.6);
      if (v33 >= v34)
      {
        v35 = v33;
      }

      else
      {
        v35 = v34;
      }

      v36 = v110;
      v37 = 0.0;
      while (v36 != &v109)
      {
        *&v113[1] = 0x3FF0000000000000;
        v37 = v37 + fabs(sub_1016866CC(v36 + 2, &v113[1]) * 40680631.6);
        v36 = v36[1];
      }

      v38 = 1.0;
      if (fabs(v37 + -0.0001) > 0.0001)
      {
        v38 = 1.0 - v37 / v35;
      }

      sub_1016AEBDC(&v109);
      v39 = v103;
      if (v103 >= v104)
      {
        v41 = __src;
        v42 = v103 - __src;
        v43 = (v103 - __src) >> 3;
        v44 = v43 + 1;
        if ((v43 + 1) >> 61)
        {
          sub_1000CE3D4();
        }

        v45 = v104 - __src;
        if ((v104 - __src) >> 2 > v44)
        {
          v44 = v45 >> 2;
        }

        if (v45 >= 0x7FFFFFFFFFFFFFF8)
        {
          v46 = 0x1FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v46 = v44;
        }

        if (v46)
        {
          sub_10006A8B4(&__src, v46);
        }

        *(8 * v43) = v38;
        v40 = (8 * v43 + 8);
        memcpy(0, v41, v42);
        v47 = __src;
        __src = 0;
        v103 = v40;
        v104 = 0;
        if (v47)
        {
          operator delete(v47);
        }
      }

      else
      {
        *v103 = v38;
        v40 = v39 + 1;
      }

      v103 = v40;
      ++v27;
    }

    while (v27 != v28);
    v48 = __src;
    if (__src != v40)
    {
      v49 = (__src + 8);
      v48 = __src;
      if (__src + 8 != v40)
      {
        v50 = *__src;
        v48 = __src;
        v51 = (__src + 8);
        do
        {
          v52 = *v51++;
          v53 = v52;
          if (v50 < v52)
          {
            v50 = v53;
            v48 = v49;
          }

          v49 = v51;
        }

        while (v51 != v40);
      }
    }

    v54 = *v48;
    if (__src)
    {
      v103 = __src;
      operator delete(__src);
    }
  }

  v109 = v105;
  sub_10168B230(&v109);
  v109 = &v106;
  sub_10168B230(&v109);
  if (v83)
  {
    v84 = v83;
    operator delete(v83);
  }

  v109 = &v80;
  sub_1001DFF90(&v109);
  v109 = v79;
  sub_1001DFF90(&v109);
  if (v114)
  {
    v115 = v114;
    operator delete(v114);
  }

  if (v88)
  {
    v89 = v88;
    operator delete(v88);
  }

  v80 = __p;
  sub_1001DFF90(&v80);
  v80 = v85;
  sub_1001DFF90(&v80);
  if (v117)
  {
    v118 = v117;
    operator delete(v117);
  }

  if (v90)
  {
    v91 = v90;
    operator delete(v90);
  }

  if (v93)
  {
    v94 = v93;
    operator delete(v93);
  }

  __p[0] = &v96;
  sub_1001DFF90(__p);
  __p[0] = &v99;
  sub_1001DFF90(__p);
  sub_10000C030(&v64);
  v55 = 1.0 - v54;
  v56 = std::ostream::operator<<();
  sub_10000C030(v56);
  v57 = std::ostream::operator<<();
  v58 = sub_10000C030(v57);
  sub_101684200(__p);
  sub_10000C030(v58);
  if (SHIBYTE(v87) < 0)
  {
    operator delete(__p[0]);
  }

  sub_100061574(&v63, __p);
  if (*(a3 + 23) < 0)
  {
    operator delete(*a3);
  }

  *a3 = *__p;
  *(a3 + 16) = v87;
  v22 = *&v55;
LABEL_76:
  *&v64 = v59;
  if (SHIBYTE(v67) < 0)
  {
    operator delete(v66[1]);
  }

  std::locale::~locale(v65);
  std::iostream::~basic_iostream();
  std::ios::~ios();
  return v22;
}

void sub_101685658(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_10068C9D8(va);
  _Unwind_Resume(a1);
}

void sub_101685810(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, uint64_t a54, uint64_t a55, uint64_t a56, uint64_t a57, uint64_t a58, uint64_t a59, uint64_t a60, uint64_t a61, uint64_t a62, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }

  JUMPOUT(0x1016857E8);
}

void sub_101685828(uint64_t *a1@<X0>, double **a2@<X1>, const void **a3@<X2>, uint64_t a4@<X8>, double a5@<D0>, uint64_t a6@<D1>)
{
  v67 = 0;
  v68 = 0;
  v69 = 0;
  sub_101446658(&v67, *a1, a1[1], 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3));
  v11 = *a2;
  v10 = a2[1];
  while (v11 != v10)
  {
    sub_101684AF8(&__p, v11, 0x14u);
    sub_100FD7EB0(&v67, &__p);
    if (__p)
    {
      *(&__p + 1) = __p;
      operator delete(__p);
    }

    v11 += 3;
  }

  v64 = 0;
  v65 = 0;
  v66 = 0;
  __src = 0;
  v62 = 0;
  v63 = 0;
  v12 = v67;
  v54 = v68;
  if (v67 == v68)
  {
    goto LABEL_71;
  }

  v51 = a6;
  v52 = a5;
  v53 = a4;
  do
  {
    v60 = 0.0;
    *v58 = 0u;
    v59 = 0u;
    sub_100010024(&cf, a3);
    v83 = 0;
    v84 = 0;
    v85 = 0;
    sub_100ECB804(&v83, *v12, v12[1], (v12[1] - *v12) >> 4);
    v70 = 0;
    v71 = 0.0;
    v72 = 0;
    sub_101446C3C(&v70, &v83, &v86, 1uLL);
    __p = 0uLL;
    *&v80 = 0;
    sub_101683E30(&v73, &v70, &__p);
    v77 = 0uLL;
    v78 = 0.0;
    sub_101446658(&v77, v73, *(&v73 + 1), 0xAAAAAAAAAAAAAAABLL * ((*(&v73 + 1) - v73) >> 3));
    v86 = 0;
    v87 = 0;
    v88 = 0;
    sub_101686600(&v86, v75, v76, 0xAAAAAAAAAAAAAAABLL * ((v76 - v75) >> 3));
    v13 = *(&v77 + 1);
    v14 = v77;
    if (*(&v77 + 1) == v77)
    {
      v28 = 0.0;
    }

    else
    {
      v56 = v12;
      v15 = 0.0;
      do
      {
        v80 = 0u;
        v81 = 0u;
        __p = 0u;
        v17 = *v14;
        v16 = v14[1];
        if (*v14 != v16)
        {
          v18 = 0;
          do
          {
            v20 = *v17;
            v19 = v17[1];
            if (v18 >= v80)
            {
              v21 = (v18 - __p) >> 4;
              if ((v21 + 1) >> 60)
              {
                sub_1000CE3D4();
              }

              v22 = (v80 - __p) >> 3;
              if (v22 <= v21 + 1)
              {
                v22 = v21 + 1;
              }

              if (v80 - __p >= 0x7FFFFFFFFFFFFFF0uLL)
              {
                v23 = 0xFFFFFFFFFFFFFFFLL;
              }

              else
              {
                v23 = v22;
              }

              if (v23)
              {
                sub_100F7E530(v23);
              }

              v24 = (16 * v21);
              *v24 = v19;
              v24[1] = v20;
              v18 = (16 * v21 + 16);
              v25 = 16 * v21 - (*(&__p + 1) - __p);
              memcpy(v24 - (*(&__p + 1) - __p), __p, *(&__p + 1) - __p);
              v26 = __p;
              *&__p = v25;
              *(&__p + 1) = v18;
              *&v80 = 0;
              if (v26)
              {
                operator delete(v26);
              }
            }

            else
            {
              *v18 = v19;
              v18[1] = v20;
              v18 += 2;
            }

            *(&__p + 1) = v18;
            v17 += 2;
          }

          while (v17 != v16);
        }

        v82 = 0x3FF0000000000000;
        v27 = sub_1016866CC(&__p, &v82);
        v82 = &v80 + 8;
        sub_101686E34(&v82);
        if (__p)
        {
          *(&__p + 1) = __p;
          operator delete(__p);
        }

        v15 = v15 + v27;
        v14 += 3;
      }

      while (v14 != v13);
      v28 = v15 * 40680631.6;
      v12 = v56;
    }

    if (v87 != v86)
    {
      v29 = v86;
      do
      {
        v28 = v28 + v29[2] * v29[2] * 3.14159265;
        v29 += 3;
      }

      while (v29 != v87);
    }

    if (v86)
    {
      v87 = v86;
      operator delete(v86);
    }

    *&__p = &v77;
    sub_1001DFF90(&__p);
    if (v75)
    {
      v76 = v75;
      operator delete(v75);
    }

    *&__p = &v73;
    sub_1001DFF90(&__p);
    *&__p = &v70;
    sub_1001DFF90(&__p);
    if (v83)
    {
      v84 = v83;
      operator delete(v83);
    }

    v86 = cf;
    if (cf)
    {
      CFRetain(cf);
      __p = 0uLL;
      *&v80 = 0;
      *&v73 = v86;
      if (v86)
      {
        CFRetain(v86);
      }
    }

    else
    {
      __p = 0uLL;
      *&v80 = 0;
      *&v73 = 0;
    }

    sub_101683FFC(&__p, &v73);
    v30 = fabs(v28);
    sub_10001021C(&v73);
    v31 = *(&__p + 1);
    v32 = v31 / (pow(2.71828183, *&v80 * (*(&__p + 1) * 0.5 - sqrt(v30 / 3.14159265) * 0.5)) + 1.0);
    sub_10001021C(&v86);
    __p = 0uLL;
    *&v80 = 0;
    v33 = *v12;
    v34 = v12[1];
    if (*v12 == v34)
    {
      v36 = 0;
      v35 = 0;
    }

    else
    {
      do
      {
        v77 = *v33;
        v78 = v32;
        sub_101684AF8(&v73, &v77, 8u);
        sub_100FD7EB0(&__p, &v73);
        if (v73)
        {
          *(&v73 + 1) = v73;
          operator delete(v73);
        }

        ++v33;
      }

      while (v33 != v34);
      v36 = *(&__p + 1);
      v35 = __p;
    }

    sub_101686F9C(&v73, v35, v36);
    *&v77 = &__p;
    sub_1001DFF90(&v77);
    *v58 = v73;
    *&v59 = v74;
    *(&v59 + 1) = v32;
    v60 = v30;
    sub_10001021C(&cf);
    sub_100FD8724(&v64, v58);
    v37 = v62;
    if (v62 >= v63)
    {
      v39 = __src;
      v40 = v62 - __src;
      v41 = (v62 - __src) >> 3;
      v42 = v41 + 1;
      if ((v41 + 1) >> 61)
      {
        sub_1000CE3D4();
      }

      v43 = v63 - __src;
      if ((v63 - __src) >> 2 > v42)
      {
        v42 = v43 >> 2;
      }

      v44 = v43 >= 0x7FFFFFFFFFFFFFF8;
      v45 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v44)
      {
        v45 = v42;
      }

      if (v45)
      {
        sub_10006A8B4(&__src, v45);
      }

      v46 = (8 * v41);
      v47 = &v46[-((v62 - __src) >> 3)];
      *v46 = *(&v59 + 1);
      v38 = v46 + 1;
      memcpy(v47, v39, v40);
      v48 = __src;
      __src = v47;
      v62 = v38;
      v63 = 0;
      if (v48)
      {
        operator delete(v48);
      }
    }

    else
    {
      *v62 = *(&v59 + 1);
      v38 = v37 + 1;
    }

    v62 = v38;
    if (v58[0])
    {
      v58[1] = v58[0];
      operator delete(v58[0]);
    }

    v12 += 3;
  }

  while (v12 != v54);
  v49 = v64;
  v50 = v65;
  v70 = v51;
  v71 = v52;
  a4 = v53;
  if (v64 == v65)
  {
LABEL_71:
    *a4 = 0;
    *(a4 + 16) = 0;
    *(a4 + 24) = 0;
    *(a4 + 8) = 0;
    sub_1016AEC50(a4 + 8, __src, v62, (v62 - __src) >> 3);
  }

  else
  {
    while (1)
    {
      v58[0] = 0;
      v58[1] = 0;
      *&v59 = 0;
      v86 = 0;
      v87 = 0;
      v88 = 0;
      sub_100ECB804(&v86, *v49, v49[1], (v49[1] - *v49) >> 4);
      v77 = 0uLL;
      v78 = 0.0;
      sub_101446C3C(&v77, &v86, v89, 1uLL);
      v73 = 0uLL;
      v74 = 0;
      sub_101683E30(&__p, &v77, &v73);
      sub_10168614C(v58, &__p);
      if (*(&v80 + 1))
      {
        *&v81 = *(&v80 + 1);
        operator delete(*(&v80 + 1));
      }

      *&v73 = &__p;
      sub_1001DFF90(&v73);
      *&v73 = &v77;
      sub_1001DFF90(&v73);
      if (v86)
      {
        v87 = v86;
        operator delete(v86);
      }

      if (v58[1] != v58[0] && sub_10169DA48(&v70, v58[0]) >= 1)
      {
        break;
      }

      *&__p = v58;
      sub_10168B230(&__p);
      v49 += 3;
      if (v49 == v50)
      {
        goto LABEL_71;
      }
    }

    *v53 = 1;
    *(v53 + 16) = 0;
    *(v53 + 24) = 0;
    *(v53 + 8) = 0;
    sub_1016AEC50(v53 + 8, __src, v62, (v62 - __src) >> 3);
    *&__p = v58;
    sub_10168B230(&__p);
  }

  if (__src)
  {
    v62 = __src;
    operator delete(__src);
  }

  *&__p = &v64;
  sub_1001DFF90(&__p);
  *&__p = &v67;
  sub_1001DFF90(&__p);
}

void sub_101685F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, char *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, char a32, uint64_t a33, uint64_t a34, void *a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, char **a45, uint64_t a46)
{
  a45 = &a17;
  sub_10168B230(&a45);
  if (__p)
  {
    a24 = __p;
    operator delete(__p);
  }

  a17 = &a26;
  sub_1001DFF90(&a17);
  a17 = &a29;
  sub_1001DFF90(&a17);
  _Unwind_Resume(a1);
}

void sub_10168614C(void ***a1, uint64_t *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  sub_101446658(&v34, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  v4 = a2[3];
  v5 = a2[4];
  while (v4 != v5)
  {
    sub_101684AF8(__p, v4, 0x48u);
    sub_100FD7EB0(&v34, __p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    v4 += 3;
  }

  v6 = v34;
  for (i = v35; v6 != i; v6 += 3)
  {
    memset(v33, 0, sizeof(v33));
    *__p = 0u;
    v8 = *v6;
    v9 = v6[1];
    if (*v6 != v9)
    {
      v10 = 0;
      do
      {
        v11 = *v8;
        v12 = v8[1];
        if (v10 >= *&v33[0])
        {
          v13 = (v10 - __p[0]) >> 4;
          if ((v13 + 1) >> 60)
          {
            sub_1000CE3D4();
          }

          v14 = (*&v33[0] - __p[0]) >> 3;
          if (v14 <= v13 + 1)
          {
            v14 = v13 + 1;
          }

          if (*&v33[0] - __p[0] >= 0x7FFFFFFFFFFFFFF0)
          {
            v15 = 0xFFFFFFFFFFFFFFFLL;
          }

          else
          {
            v15 = v14;
          }

          if (v15)
          {
            sub_100F7E530(v15);
          }

          v16 = (16 * v13);
          *v16 = v12;
          v16[1] = v11;
          v10 = (16 * v13 + 16);
          v17 = (16 * v13 - (__p[1] - __p[0]));
          memcpy(v16 - (__p[1] - __p[0]), __p[0], __p[1] - __p[0]);
          v18 = __p[0];
          __p[0] = v17;
          __p[1] = v10;
          *&v33[0] = 0;
          if (v18)
          {
            operator delete(v18);
          }
        }

        else
        {
          *v10 = v12;
          *(v10 + 1) = v11;
          v10 += 16;
        }

        __p[1] = v10;
        v8 += 2;
      }

      while (v8 != v9);
    }

    v20 = a1[1];
    v19 = a1[2];
    if (v20 >= v19)
    {
      v22 = 0xAAAAAAAAAAAAAAABLL * ((v20 - *a1) >> 4);
      v23 = v22 + 1;
      if (v22 + 1 > 0x555555555555555)
      {
        sub_1000CE3D4();
      }

      v24 = 0xAAAAAAAAAAAAAAABLL * ((v19 - *a1) >> 4);
      if (2 * v24 > v23)
      {
        v23 = 2 * v24;
      }

      if (v24 >= 0x2AAAAAAAAAAAAAALL)
      {
        v25 = 0x555555555555555;
      }

      else
      {
        v25 = v23;
      }

      v41 = a1;
      if (v25)
      {
        if (v25 <= 0x555555555555555)
        {
          operator new();
        }

        sub_100013D10();
      }

      v37 = 0;
      v38 = 48 * v22;
      v39 = 48 * v22;
      v40 = 0;
      sub_1016AE7E8((48 * v22), __p);
      v21 = v39 + 48;
      v39 += 48;
      v26 = *a1;
      v27 = a1[1];
      v28 = v38 + *a1 - v27;
      if (*a1 != v27)
      {
        v29 = *a1;
        v30 = (v38 + *a1 - v27);
        do
        {
          *v30 = 0;
          v30[1] = 0;
          v30[2] = 0;
          *v30 = *v29;
          v30[2] = v29[2];
          *v29 = 0;
          v29[1] = 0;
          v29[2] = 0;
          v30[3] = 0;
          v30[4] = 0;
          v30[5] = 0;
          *(v30 + 3) = *(v29 + 3);
          v30[5] = v29[5];
          v29[3] = 0;
          v29[4] = 0;
          v29[5] = 0;
          v29 += 6;
          v30 += 6;
        }

        while (v29 != v27);
        do
        {
          sub_101687F08(v26);
          v26 += 6;
        }

        while (v26 != v27);
        v26 = *a1;
        v21 = v39;
      }

      *a1 = v28;
      a1[1] = v21;
      v31 = a1[2];
      a1[2] = v40;
      v39 = v26;
      v40 = v31;
      v37 = v26;
      v38 = v26;
      sub_101687F6C(&v37);
    }

    else
    {
      sub_1016AE7E8(a1[1], __p);
      v21 = (v20 + 6);
    }

    a1[1] = v21;
    v37 = v33 + 1;
    sub_101686E34(&v37);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }

  __p[0] = &v34;
  sub_1001DFF90(__p);
}

long double sub_101686540(double a1, double a2, double a3, double a4)
{
  v4 = a4 * 0.0174532925;
  v5 = a3 / 6378.137;
  v6 = __sincos_stret(a1 * 0.0174532925);
  v7 = __sincos_stret(v5);
  v8 = __sincos_stret(v4);
  v9 = asin(v6.__cosval * v7.__sinval * v8.__cosval + v6.__sinval * v7.__cosval);
  v10 = sin(v9);
  atan2(v6.__cosval * (v7.__sinval * v8.__sinval), v7.__cosval - v6.__sinval * v10);
  return v9 * 57.2957795;
}

uint64_t sub_101686600(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    sub_101446D74(result, a4);
  }

  return result;
}

void sub_101686664(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_101686680(uint64_t a1)
{
  v4 = (a1 + 24);
  sub_101686E34(&v4);
  v2 = *a1;
  if (*a1)
  {
    *(a1 + 8) = v2;
    operator delete(v2);
  }

  return a1;
}

double sub_1016866CC(uint64_t *a1, double *a2)
{
  v4 = *a1;
  v5 = a1[1];
  v6 = 0.0;
  v7 = 0.0;
  if (v5 - *a1 >= 0x40)
  {
    v8 = *a2;
    v9 = (v4 + 16);
    if ((v4 + 16) == v5)
    {
      v11 = 0.0;
    }

    else
    {
      v10 = 0;
      v11 = 0.0;
      do
      {
        v12 = *(v9 - 2);
        v13 = *v9;
        if (v12 != *v9)
        {
          if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v13 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_9;
          }

          v15 = fabs(v12);
          v16 = fabs(v13);
          v17 = vabdd_f64(v12, v13);
          if (v15 >= v16)
          {
            v18 = v15;
          }

          else
          {
            v18 = v16;
          }

          if (v18 < 1.0)
          {
            v18 = 1.0;
          }

          if (v17 > v18 * 2.22044605e-16)
          {
LABEL_9:
            v11 = v11 + sub_101686964(v9 - 2, v9);
            v10 += sub_101686BB8(v9 - 2, v9);
          }
        }

        v9 += 2;
      }

      while (v9 != v5);
      if (v10)
      {
        v19 = ((v10 >> 1) + 1);
        v20 = fabs(v11);
        v21 = -v20;
        v22 = -(v20 - v19 * 6.28318531);
        v23 = -(v21 + v19 * 6.28318531);
        if (v11 <= 0.0)
        {
          v11 = v22;
        }

        else
        {
          v11 = v23;
        }
      }
    }

    v7 = v8 * v8 * v11;
  }

  v25 = a1[3];
  v24 = a1[4];
  if (v25 != v24)
  {
    v6 = 0.0;
    do
    {
      v26 = *v25;
      v27 = v25[1];
      v28 = 0.0;
      if (v27 - *v25 >= 0x40)
      {
        v29 = *a2;
        v30 = (v26 + 16);
        if ((v26 + 16) == v27)
        {
          v32 = 0.0;
        }

        else
        {
          v31 = 0;
          v32 = 0.0;
          do
          {
            v33 = *(v30 - 2);
            v34 = *v30;
            if (v33 != *v30)
            {
              if ((*&v33 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v34 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                goto LABEL_35;
              }

              v36 = fabs(v33);
              v37 = fabs(v34);
              v38 = vabdd_f64(v33, v34);
              if (v36 >= v37)
              {
                v39 = v36;
              }

              else
              {
                v39 = v37;
              }

              if (v39 < 1.0)
              {
                v39 = 1.0;
              }

              if (v38 > v39 * 2.22044605e-16)
              {
LABEL_35:
                v32 = v32 + sub_101686964(v30 - 2, v30);
                v31 += sub_101686BB8(v30 - 2, v30);
              }
            }

            v30 += 2;
          }

          while (v30 != v27);
          if (v31)
          {
            v40 = (v31 >> 1) + 1;
            v41 = fabs(v32);
            v42 = -v41;
            v43 = -(v41 - v40 * 6.28318531);
            if (v32 <= 0.0)
            {
              v32 = v43;
            }

            else
            {
              v32 = -(v42 + v40 * 6.28318531);
            }
          }
        }

        v28 = v29 * v29 * v32;
        v24 = a1[4];
      }

      v6 = v6 + v28;
      v25 += 3;
    }

    while (v25 != v24);
  }

  return v7 + v6;
}

long double sub_101686964(double *a1, double *a2)
{
  v2 = a1[1];
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v25 = a2;
    v29 = a1;
    v16 = __cxa_guard_acquire(&qword_101FCB028);
    a2 = v25;
    a1 = v29;
    if (v16)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      a2 = v25;
      a1 = v29;
    }
  }

  v3 = *&qword_101FCB020;
  v4 = a2[1];
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v26 = a2;
    v30 = a1;
    v17 = v3;
    v18 = __cxa_guard_acquire(&qword_101FCB028);
    v3 = v17;
    v19 = v18;
    a2 = v26;
    a1 = v30;
    if (v19)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      v3 = v17;
      a2 = v26;
      a1 = v30;
    }
  }

  v5 = *&qword_101FCB020;
  v6 = *a2;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v31 = a1;
    v27 = v3;
    v20 = v6;
    v21 = __cxa_guard_acquire(&qword_101FCB028);
    v6 = v20;
    v3 = v27;
    v22 = v21;
    a1 = v31;
    if (v22)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      v6 = v20;
      v3 = v27;
      a1 = v31;
    }
  }

  v7 = *&qword_101FCB020;
  v8 = *a1;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v24 = v6;
    v28 = v3;
    v32 = v7;
    v23 = __cxa_guard_acquire(&qword_101FCB028);
    v3 = v28;
    v7 = v32;
    v6 = v24;
    if (v23)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      v3 = v28;
      v7 = v32;
      v6 = v24;
    }
  }

  v9 = v6 * v7;
  v10 = tan(v2 * v3 * 0.5);
  v11 = tan(v4 * v5 * 0.5);
  v12 = (v10 + v11) / (v10 * v11 + 1.0);
  v13 = tan((v9 - v8 * *&qword_101FCB020) * 0.5);
  v14 = atan(v12 * v13);
  return v14 + v14;
}

BOOL sub_101686BB8(double *a1, double *a2)
{
  v2 = *a1;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v23 = a1;
    v29 = a2;
    v27 = v2;
    v14 = __cxa_guard_acquire(&qword_101FCB028);
    v2 = v27;
    a2 = v29;
    v15 = v14;
    a1 = v23;
    if (v15)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      v2 = v27;
      a1 = v23;
      a2 = v29;
    }
  }

  v3 = *&qword_101FCB020;
  v4 = *a1;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v30 = a2;
    v28 = v2;
    v20 = v3;
    v24 = v4;
    v16 = __cxa_guard_acquire(&qword_101FCB028);
    v3 = v20;
    v4 = v24;
    v2 = v28;
    a2 = v30;
    if (v16)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      v3 = v20;
      v4 = v24;
      v2 = v28;
      a2 = v30;
    }
  }

  v5 = v2 * v3;
  v6 = floor(v4 * *&qword_101FCB020 / 6.28318531);
  v7 = *a2;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v31 = a2;
    v19 = v7;
    v21 = v5;
    v25 = v6;
    v17 = __cxa_guard_acquire(&qword_101FCB028);
    v5 = v21;
    v6 = v25;
    v7 = v19;
    a2 = v31;
    if (v17)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      v5 = v21;
      v6 = v25;
      v7 = v19;
      a2 = v31;
    }
  }

  v8 = v5 - v6 * 6.28318531;
  v9 = v7 * *&qword_101FCB020;
  v10 = *a2;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v22 = v8;
    v32 = v9;
    v26 = v10;
    v18 = __cxa_guard_acquire(&qword_101FCB028);
    v8 = v22;
    v10 = v26;
    v9 = v32;
    if (v18)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      v8 = v22;
      v10 = v26;
      v9 = v32;
    }
  }

  result = 0;
  v12 = v9 - floor(v10 * *&qword_101FCB020 / 6.28318531) * 6.28318531;
  if (v8 >= v12)
  {
    v13 = v8;
  }

  else
  {
    v13 = v12;
  }

  if (v12 < v8)
  {
    v8 = v12;
  }

  if (v13 > 3.14159265 && v8 < 3.14159265)
  {
    return v13 - v8 > 3.14159265;
  }

  return result;
}

void sub_101686E34(void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v1[1];
      do
      {
        v8 = *(v6 - 3);
        v6 -= 24;
        v7 = v8;
        if (v8)
        {
          *(v4 - 2) = v7;
          operator delete(v7);
        }

        v4 = v6;
      }

      while (v6 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void sub_101686EC4(uint64_t a1, _OWORD *a2)
{
  v5 = *(a1 + 8);
  v4 = *(a1 + 16);
  if (v5 >= v4)
  {
    v7 = (v5 - *a1) >> 4;
    v8 = v7 + 1;
    if ((v7 + 1) >> 60)
    {
      sub_100ECB8BC();
    }

    v9 = v4 - *a1;
    if (v9 >> 3 > v8)
    {
      v8 = v9 >> 3;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFF0)
    {
      v10 = 0xFFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    if (v10)
    {
      sub_1003BCAB4(a1, v10);
    }

    v11 = (16 * v7);
    *v11 = *a2;
    v6 = 16 * v7 + 16;
    v12 = *(a1 + 8) - *a1;
    v13 = v11 - v12;
    memcpy(v11 - v12, *a1, v12);
    v14 = *a1;
    *a1 = v13;
    *(a1 + 8) = v6;
    *(a1 + 16) = 0;
    if (v14)
    {
      operator delete(v14);
    }
  }

  else
  {
    *v5 = *a2;
    v6 = (v5 + 1);
  }

  *(a1 + 8) = v6;
}

void sub_101686F9C(void *a1, int8x16_t **a2, int8x16_t **a3)
{
  v110 = 0uLL;
  v111 = 0;
  if (a2 == a3)
  {
    v108 = 0u;
    v109 = 0u;
    *v107 = 0u;
LABEL_36:
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    goto LABEL_37;
  }

  v4 = a2;
  v104 = a1;
  do
  {
    v113 = 0u;
    v114 = 0u;
    *__p = 0u;
    v5 = *v4;
    v6 = v4[1];
    while (v5 != v6)
    {
      *v107 = vextq_s8(*v5, *v5, 8uLL);
      sub_1013B02F4(__p, v107);
      ++v5;
    }

    v7 = *(&v110 + 1);
    if (*(&v110 + 1) >= v111)
    {
      v9 = 0xAAAAAAAAAAAAAAABLL * ((*(&v110 + 1) - v110) >> 4);
      v10 = v9 + 1;
      if (v9 + 1 > 0x555555555555555)
      {
        sub_1000CE3D4();
      }

      if (0x5555555555555556 * ((v111 - v110) >> 4) > v10)
      {
        v10 = 0x5555555555555556 * ((v111 - v110) >> 4);
      }

      if (0xAAAAAAAAAAAAAAABLL * ((v111 - v110) >> 4) >= 0x2AAAAAAAAAAAAAALL)
      {
        v11 = 0x555555555555555;
      }

      else
      {
        v11 = v10;
      }

      *&v109 = &v110;
      if (v11)
      {
        if (v11 <= 0x555555555555555)
        {
          operator new();
        }

        sub_100013D10();
      }

      v12 = (16 * ((*(&v110 + 1) - v110) >> 4));
      v107[0] = 0;
      v107[1] = v12;
      v108 = v12;
      v12[1] = 0;
      v12[2] = 0;
      *v12 = 0;
      sub_101687D3C(48 * v9, __p[0], __p[1], (__p[1] - __p[0]) >> 4);
      v12[3] = 0;
      v12[4] = 0;
      v12[5] = 0;
      sub_101687DD4(48 * v9 + 24, *(&v113 + 1), v114, 0xAAAAAAAAAAAAAAABLL * ((v114 - *(&v113 + 1)) >> 3));
      v8 = (v108 + 48);
      *&v108 = v108 + 48;
      v14 = *(&v110 + 1);
      v13 = v110;
      v15 = v107[1] + v110 - *(&v110 + 1);
      if (v110 != *(&v110 + 1))
      {
        v16 = v110;
        v17 = v107[1] + v110 - *(&v110 + 1);
        do
        {
          *v17 = 0;
          v17[1] = 0;
          v17[2] = 0;
          *v17 = *v16;
          v17[2] = *(v16 + 2);
          *v16 = 0;
          *(v16 + 1) = 0;
          *(v16 + 2) = 0;
          v17[3] = 0;
          v17[4] = 0;
          v17[5] = 0;
          *(v17 + 3) = *(v16 + 24);
          v17[5] = *(v16 + 5);
          *(v16 + 3) = 0;
          *(v16 + 4) = 0;
          *(v16 + 5) = 0;
          v16 += 48;
          v17 += 6;
        }

        while (v16 != v14);
        do
        {
          sub_101687F08(v13);
          v13 += 48;
        }

        while (v13 != v14);
        v13 = v110;
        v8 = v108;
      }

      *&v110 = v15;
      *(&v110 + 1) = v8;
      v18 = v111;
      v111 = *(&v108 + 1);
      *&v108 = v13;
      *(&v108 + 1) = v18;
      v107[0] = v13;
      v107[1] = v13;
      sub_101687F6C(v107);
    }

    else
    {
      **(&v110 + 1) = 0;
      v7[1] = 0;
      v7[2] = 0;
      sub_101687D3C(v7, __p[0], __p[1], (__p[1] - __p[0]) >> 4);
      v7[3] = 0;
      v7[4] = 0;
      v7[5] = 0;
      sub_101687DD4((v7 + 3), *(&v113 + 1), v114, 0xAAAAAAAAAAAAAAABLL * ((v114 - *(&v113 + 1)) >> 3));
      v8 = v7 + 6;
    }

    *(&v110 + 1) = v8;
    v107[0] = &v113 + 8;
    sub_101686E34(v107);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    v4 += 3;
  }

  while (v4 != a3);
  v19 = *(&v110 + 1);
  v20 = v110;
  v108 = 0u;
  v109 = 0u;
  *v107 = 0u;
  a1 = v104;
  if (v110 == *(&v110 + 1))
  {
    goto LABEL_36;
  }

  v21 = v110;
  while (*v21 == v21[1])
  {
    for (i = v21[3]; i != v21[4]; i += 3)
    {
      if (*i != i[1])
      {
        goto LABEL_40;
      }
    }

    v21 += 6;
    if (v21 == *(&v110 + 1))
    {
      goto LABEL_36;
    }
  }

LABEL_40:
  v116 = 0;
  v114 = 0u;
  *v115 = 0u;
  *__p = 0u;
  v113 = 0u;
  v122 = 0uLL;
  v23 = 1;
  v24 = v110;
  v121 = 0uLL;
  do
  {
    v25 = *v24;
    v26 = v24[1];
    if (*v24 == v26)
    {
      goto LABEL_142;
    }

    v27 = v25 + 2;
    v28 = *v24;
    while (v27 != v26)
    {
      v29 = *v27;
      v30 = *v25;
      if (*v27 == *v25)
      {
        goto LABEL_45;
      }

      if ((*&v29 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v30 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_56;
      }

      v40 = fabs(v29);
      v41 = fabs(v30);
      v42 = vabdd_f64(v29, v30);
      if (v40 < v41)
      {
        v40 = v41;
      }

      if (v40 < 1.0)
      {
        v40 = 1.0;
      }

      if (v42 <= v40 * 2.22044605e-16)
      {
LABEL_45:
        v31 = v27[1];
        v32 = v25[1];
        if (v31 != v32)
        {
          if ((*&v31 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v32 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            if (v31 >= v32)
            {
              goto LABEL_58;
            }

LABEL_57:
            v25 = v27;
            goto LABEL_58;
          }

          v46 = fabs(v31);
          v47 = fabs(v32);
          if (v46 < v47)
          {
            v46 = v47;
          }

          if (v46 < 1.0)
          {
            v46 = 1.0;
          }

          if (v31 < v32 && vabdd_f64(v31, v32) > v46 * 2.22044605e-16)
          {
            goto LABEL_57;
          }
        }
      }

      else
      {
LABEL_56:
        if (v29 < v30)
        {
          goto LABEL_57;
        }
      }

LABEL_58:
      v35 = *v28;
      if (*v28 != v29)
      {
        if ((*&v35 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v29 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_70;
        }

        v43 = fabs(v35);
        v44 = fabs(v29);
        v45 = vabdd_f64(v35, v29);
        if (v43 < v44)
        {
          v43 = v44;
        }

        if (v43 < 1.0)
        {
          v43 = 1.0;
        }

        if (v45 > v43 * 2.22044605e-16)
        {
LABEL_70:
          if (v35 >= v29)
          {
            goto LABEL_72;
          }

LABEL_71:
          v28 = v27;
          goto LABEL_72;
        }
      }

      v36 = v28[1];
      v37 = v27[1];
      if (v36 == v37)
      {
        goto LABEL_72;
      }

      if ((*&v36 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v37 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v48 = fabs(v36);
        v49 = fabs(v37);
        if (v48 < v49)
        {
          v48 = v49;
        }

        if (v48 < 1.0)
        {
          v48 = 1.0;
        }

        if (v36 < v37 && vabdd_f64(v36, v37) > v48 * 2.22044605e-16)
        {
          goto LABEL_71;
        }
      }

      else if (v36 < v37)
      {
        goto LABEL_71;
      }

LABEL_72:
      v27 += 2;
    }

    if (v23)
    {
      v122 = *v25;
      goto LABEL_140;
    }

    v50 = *v25;
    v51 = v122.f64[0];
    if (*v25 == v122.f64[0])
    {
      goto LABEL_102;
    }

    if ((*&v50 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v122.f64[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_119;
    }

    v63 = fabs(v50);
    v64 = fabs(v122.f64[0]);
    v65 = vabdd_f64(v50, v122.f64[0]);
    if (v63 < v64)
    {
      v63 = v64;
    }

    if (v63 < 1.0)
    {
      v63 = 1.0;
    }

    if (v65 <= v63 * 2.22044605e-16)
    {
LABEL_102:
      v50 = v25[1];
      v51 = v122.f64[1];
      if (v50 != v122.f64[1])
      {
        if ((*&v50 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v122.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_119;
        }

        v53 = fabs(v50);
        v54 = fabs(v122.f64[1]);
        if (v53 < v54)
        {
          v53 = v54;
        }

        if (v53 < 1.0)
        {
          v53 = 1.0;
        }

        if (v50 < v122.f64[1] && vabdd_f64(v50, v122.f64[1]) > v53 * 2.22044605e-16)
        {
LABEL_120:
          v122 = *v25;
        }
      }
    }

    else
    {
LABEL_119:
      if (v50 < v51)
      {
        goto LABEL_120;
      }
    }

    v56 = v121.f64[0];
    v57 = *v28;
    if (v121.f64[0] == *v28)
    {
      goto LABEL_122;
    }

    if ((*&v121.f64[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v57 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_139;
    }

    v60 = fabs(v121.f64[0]);
    v61 = fabs(v57);
    v62 = vabdd_f64(v121.f64[0], v57);
    if (v60 < v61)
    {
      v60 = v61;
    }

    if (v60 < 1.0)
    {
      v60 = 1.0;
    }

    if (v62 <= v60 * 2.22044605e-16)
    {
LABEL_122:
      v56 = v121.f64[1];
      v57 = v28[1];
      if (v121.f64[1] == v57)
      {
        goto LABEL_141;
      }

      if ((*&v121.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v57 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_139;
      }

      v23 = 0;
      v58 = fabs(v121.f64[1]);
      v59 = fabs(v57);
      if (v58 < v59)
      {
        v58 = v59;
      }

      if (v58 < 1.0)
      {
        v58 = 1.0;
      }

      if (v121.f64[1] < v57 && vabdd_f64(v121.f64[1], v57) > v58 * 2.22044605e-16)
      {
LABEL_140:
        v23 = 0;
        v121 = *v28;
      }
    }

    else
    {
LABEL_139:
      if (v56 < v57)
      {
        goto LABEL_140;
      }

LABEL_141:
      v23 = 0;
    }

LABEL_142:
    v24 += 6;
  }

  while (v24 != *(&v110 + 1));
  v119 = 0uLL;
  v120 = 0;
  v117 = 0uLL;
  v118 = 0;
  v105 = v121;
  v106 = v122;
  do
  {
    for (j = *v20; j != v20[1]; ++j)
    {
      v123.f64[0] = 1.0;
      v126 = v105;
      v127[0] = v106;
      v125 = *j;
      sub_101687FBC(v127, &v126, &v125, v123.f64);
      if (v67 != 0.0 && ((*&v67 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || fabs(v67) > v123.f64[0] * 2.22044605e-16))
      {
        if (v67 <= 0.0)
        {
          v68 = &v119;
        }

        else
        {
          v68 = &v117;
        }

        sub_1013B02F4(v68, j);
      }
    }

    v20 += 6;
  }

  while (v20 != v19);
  v69 = *(&v117 + 1);
  v70 = v117;
  v71 = 126 - 2 * __clz((*(&v117 + 1) - v117) >> 4);
  v72 = *(&v119 + 1);
  v73 = v119;
  if (*(&v117 + 1) == v117)
  {
    v74 = 0;
  }

  else
  {
    v74 = v71;
  }

  v75 = 126 - 2 * __clz((*(&v119 + 1) - v119) >> 4);
  if (*(&v119 + 1) == v119)
  {
    v76 = 0;
  }

  else
  {
    v76 = v75;
  }

  sub_10168870C(v119, *(&v119 + 1), v76, 1);
  sub_10168870C(v70, v69, v74, 1);
  sub_1013B02F4(__p, &v122);
  if (v72 != v73)
  {
    v77 = v73;
    do
    {
      sub_1013B02F4(__p, v77);
      v78 = (__p[1] - __p[0]) >> 4;
      if (v78 >= 3)
      {
        do
        {
          v123 = *(__p[1] - 1);
          v124 = 1.0;
          v79 = *(__p[1] - 3);
          v126 = v123;
          v127[0] = v79;
          v80 = __p[1] - 32;
          v125 = *(__p[1] - 2);
          sub_101687FBC(v127, &v126, &v125, &v124);
          if (v81 != 0.0 && ((*&v81 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || fabs(v81) > v124 * 2.22044605e-16) && v81 <= 0.0)
          {
            break;
          }

          __p[1] = v80;
          sub_1013B02F4(__p, &v123);
          --v78;
        }

        while (v78 > 2);
      }

      ++v77;
    }

    while (v77 != v72);
  }

  sub_1013B02F4(__p, &v121);
  v82 = (__p[1] - __p[0]) >> 4;
  if (v82 >= 3)
  {
    do
    {
      v123 = *(__p[1] - 1);
      v124 = 1.0;
      v83 = *(__p[1] - 3);
      v126 = v123;
      v127[0] = v83;
      v84 = __p[1] - 32;
      v125 = *(__p[1] - 2);
      sub_101687FBC(v127, &v126, &v125, &v124);
      if (v85 != 0.0 && ((*&v85 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || fabs(v85) > v124 * 2.22044605e-16) && v85 <= 0.0)
      {
        break;
      }

      __p[1] = v84;
      sub_1013B02F4(__p, &v123);
      --v82;
    }

    while (v82 > 2);
  }

  sub_1013B02F4(&v113 + 8, &v122);
  if (v69 != v70)
  {
    v86 = v70;
    do
    {
      sub_1013B02F4(&v113 + 8, v86);
      v87 = (v114 - *(&v113 + 1)) >> 4;
      if (v87 >= 3)
      {
        do
        {
          v123 = *(v114 - 16);
          v124 = 1.0;
          v88 = *(v114 - 48);
          v126 = v123;
          v127[0] = v88;
          v89 = v114 - 32;
          v125 = *(v114 - 32);
          sub_101687FBC(v127, &v126, &v125, &v124);
          if (v90 != 0.0 && ((*&v90 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || fabs(v90) > v124 * 2.22044605e-16) && v90 > 0.0)
          {
            break;
          }

          *&v114 = v89;
          sub_1013B02F4(&v113 + 8, &v123);
          --v87;
        }

        while (v87 > 2);
      }

      v86 += 2;
    }

    while (v86 != v69);
  }

  sub_1013B02F4(&v113 + 8, &v121);
  v91 = (v114 - *(&v113 + 1)) >> 4;
  if (v91 >= 3)
  {
    do
    {
      v123 = *(v114 - 16);
      v124 = 1.0;
      v92 = *(v114 - 48);
      v126 = v123;
      v127[0] = v92;
      v93 = v114 - 32;
      v125 = *(v114 - 32);
      sub_101687FBC(v127, &v126, &v125, &v124);
      if (v94 != 0.0 && ((*&v94 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || fabs(v94) > v124 * 2.22044605e-16) && v94 > 0.0)
      {
        break;
      }

      *&v114 = v93;
      sub_1013B02F4(&v113 + 8, &v123);
      --v91;
    }

    while (v91 > 2);
  }

  if (v70)
  {
    operator delete(v70);
  }

  if (v73)
  {
    operator delete(v73);
  }

  v96 = *(&v113 + 1);
  v95 = v114;
  if (*(&v113 + 1) != v114)
  {
    v97 = *(&v113 + 1);
    do
    {
      sub_1013B02F4(v107, v97++);
    }

    while (v97 != v95);
  }

  v98 = __p[0];
  v99 = __p[1];
  if (__p[0] == __p[1])
  {
    __assert_rtn("output_ranges", "graham_andrew.hpp", 289, "closed ? !boost::empty(second) : boost::size(second) > 1");
  }

  if (__p[1] - 16 != __p[0])
  {
    v100 = __p[1] - 32;
    do
    {
      sub_1013B02F4(v107, v100);
    }

    while (v100-- != v98);
  }

  if ((v95 - v96 + ((v99 - v98) >> 4) - 1) <= 3)
  {
    sub_1013B02F4(v107, v96);
  }

  if (v115[0])
  {
    operator delete(v115[0]);
  }

  if (v96)
  {
    operator delete(v96);
  }

  if (v98)
  {
    operator delete(v98);
  }

  v102 = v107[0];
  v103 = v107[1];
  v104[1] = 0;
  v104[2] = 0;
  *v104 = 0;
  while (v102 != v103)
  {
    *__p = vextq_s8(*v102, *v102, 8uLL);
    sub_101686EC4(v104, __p);
    ++v102;
  }

LABEL_37:
  __p[0] = &v108 + 8;
  sub_101686E34(__p);
  if (v107[0])
  {
    v107[1] = v107[0];
    operator delete(v107[0]);
  }

  __p[0] = &v110;
  sub_10168B230(__p);
}

void sub_101687C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, char *a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, void *__p)
{
  if (v39)
  {
    operator delete(v39);
  }

  if (__p)
  {
    operator delete(__p);
  }

  sub_100C78DE8(&a25);
  sub_101686680(&a15);
  a25 = &a21;
  sub_10168B230(&a25);
  _Unwind_Resume(a1);
}

void sub_101687D3C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (!(a4 >> 60))
    {
      sub_100F7E530(a4);
    }

    sub_1000CE3D4();
  }
}

void sub_101687DB8(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_101687DD4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 < 0xAAAAAAAAAAAAAABLL)
    {
      operator new();
    }

    sub_1000CE3D4();
  }
}

void sub_101687F08(uint64_t a1)
{
  v3 = (a1 + 24);
  sub_101686E34(&v3);
  v2 = *a1;
  if (*a1)
  {
    *(a1 + 8) = v2;

    operator delete(v2);
  }
}

uint64_t sub_101687F6C(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 48;
    sub_101687F08(i - 48);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

float64x2_t *sub_101687FBC(float64x2_t *result, float64x2_t *a2, float64x2_t *a3, double *a4)
{
  v4 = vsubq_f64(*result, *a3);
  _Q1 = vsubq_f64(*a2, *a3);
  v6 = vextq_s8(_Q1, _Q1, 8uLL);
  v7 = fabs(v4.f64[0]);
  v8 = fabs(*&_Q1.i64[1]);
  _D8 = v4.f64[1];
  v10 = fabs(v4.f64[1]);
  v11 = fabs(*_Q1.i64);
  if (v7 < v8)
  {
    v7 = v8;
  }

  if (v7 < v10)
  {
    v7 = v10;
  }

  if (v7 < v11)
  {
    v7 = v11;
  }

  if (v7 < 1.0)
  {
    v7 = 1.0;
  }

  *a4 = v7;
  v12 = vmulq_f64(v4, v6).f64[0];
  v13 = vmuld_lane_f64(*_Q1.i64, v4, 1);
  v14 = fabs(v12) + fabs(v13);
  if (vabdd_f64(v12, v13) < v14 * 3.33066907e-16 && (v12 <= 0.0 || v13 > 0.0) && (v12 >= 0.0 || v13 < 0.0))
  {
    v15 = 0;
    v16 = -(v12 - v4.f64[0] * *&_Q1.i64[1]);
    v17 = -(v13 - v4.f64[1] * *_Q1.i64);
    v18 = v16 - v17;
    v19 = v16 - (v16 - v17) - v17 + v16 - (v16 - v17 + v16 - (v16 - v17));
    v20 = v12 + v18;
    v21 = v18 - (v12 + v18 - v12) + v12 - (v12 + v18 - (v12 + v18 - v12));
    v108[0] = v19;
    v108[1] = v21 - (v21 - v13) - v13 + v21 - (v21 - v13 + v21 - (v21 - v13));
    v108[2] = v21 - v13 - (v20 + v21 - v13 - v20) + v20 - (v20 + v21 - v13 - (v20 + v21 - v13 - v20));
    v108[3] = v20 + v21 - v13;
    v22 = 0.0;
    do
    {
      v22 = v22 + v108[v15] + v108[v15 + 1];
      v15 += 2;
    }

    while (v15 != 4);
    v23 = fabs(v22);
    if (v23 < v14 * 2.22044605e-16)
    {
      v24 = vsubq_f64(*result, v4);
      _Q18 = vaddq_f64(vsubq_f64(v24, *a3), vsubq_f64(*result, vaddq_f64(v4, v24)));
      v26 = vextq_s8(*a2, *a2, 8uLL);
      v27 = vsubq_f64(v26, v6);
      v28 = vaddq_f64(vsubq_f64(v27, vextq_s8(*a3, *a3, 8uLL)), vsubq_f64(v26, vaddq_f64(v6, v27)));
      if (vmaxv_u16(vmovn_s32(vmvnq_s8(vuzp1q_s32(vceqzq_f64(_Q18), vceqzq_f64(v28))))))
      {
        v29 = v23 * 3.33066907e-16 + v14 * 1.10933565e-31;
        v30 = vmulq_f64(v6, _Q18);
        v31 = vmlaq_f64(v30, v28, v4);
        if (fabs(v22 + vsubq_f64(v31, vdupq_laneq_s64(v31, 1)).f64[0]) < v29)
        {
          memset(v107, 0, sizeof(v107));
          v32 = -(v30.f64[0] - _Q18.f64[0] * *&_Q1.i64[1]);
          v33 = _Q18.f64[1];
          __asm { FMLA            D4, D1, V18.D[1] }

          v39 = v32 - _D4;
          v40 = v32 - (v32 - _D4) - _D4 + v32 - (v32 - _D4 + v32 - (v32 - _D4));
          v41 = v30.f64[0] + v39;
          v42 = v39 - (v30.f64[0] + v39 - v30.f64[0]) + v30.f64[0] - (v30.f64[0] + v39 - (v30.f64[0] + v39 - v30.f64[0]));
          *&v97 = v40;
          *(&v97 + 1) = v42 - (v42 - v30.f64[1]) - v30.f64[1] + v42 - (v42 - v30.f64[1] + v42 - (v42 - v30.f64[1]));
          *&v98 = v42 - v30.f64[1] - (v41 + v42 - v30.f64[1] - v41) + v41 - (v41 + v42 - v30.f64[1] - (v41 + v42 - v30.f64[1] - v41));
          *(&v98 + 1) = v41 + v42 - v30.f64[1];
          v95 = v4;
          v96 = _Q18;
          v94 = v28;
          v43 = sub_101688598(v108, &v97, v107);
          memset(v106, 0, sizeof(v106));
          _V5.D[1] = v94.f64[1];
          v45 = vmulq_f64(v95, v94).f64[0];
          v46 = -(v45 - v95.f64[0] * v94.f64[0]);
          _D2 = v94.f64[1];
          v48 = vmuld_lane_f64(_D8, v94, 1);
          __asm { FMLA            D4, D8, V5.D[1] }

          v50 = v46 - _D4;
          v51 = v46 - (v46 - _D4) - _D4 + v46 - (v46 - _D4 + v46 - (v46 - _D4));
          v52 = v45 + v50;
          v53 = v50 - (v45 + v50 - v45) + v45 - (v45 + v50 - (v45 + v50 - v45));
          *&v97 = v51;
          *(&v97 + 1) = v53 - (v53 - v48) - v48 + v53 - (v53 - v48 + v53 - (v53 - v48));
          *&v98 = v53 - v48 - (v52 + v53 - v48 - v52) + v52 - (v52 + v53 - v48 - (v52 + v53 - v48 - v52));
          *(&v98 + 1) = v52 + v53 - v48;
          v54 = vmulq_f64(v96, v94).f64[0];
          v55 = -(v54 - v96.f64[0] * v94.f64[0]);
          _V5.D[1] = v96.f64[1];
          v57 = vmuld_lane_f64(v33, v94, 1);
          __asm { FMLA            D4, D2, V5.D[1] }

          v59 = v55 - _D4;
          v60 = v55 - (v55 - _D4) - _D4 + v55 - (v55 - _D4 + v55 - (v55 - _D4));
          v61 = v54 + v59;
          v62 = v59 - (v54 + v59 - v54) + v54 - (v54 + v59 - (v54 + v59 - v54));
          v105[0] = v60;
          v105[1] = v62 - (v62 - v57) - v57 + v62 - (v62 - v57 + v62 - (v62 - v57));
          v105[2] = v62 - v57 - (v61 + v62 - v57 - v61) + v61 - (v61 + v62 - v57 - (v61 + v62 - v57 - v61));
          v105[3] = v61 + v62 - v57;
          result = sub_101688598(&v97, v105, v106);
          v63 = 0;
          v103 = 0u;
          v104 = 0u;
          v101 = 0u;
          v102 = 0u;
          v99 = 0u;
          v100 = 0u;
          v97 = 0u;
          v98 = 0u;
          v64 = *v106;
          v65 = fabs(*v106);
          v66 = fabs(*v107);
          v67 = v65 <= v66;
          v68 = v65 > v66;
          if (v65 > v66)
          {
            v64 = *v107;
          }

          if (v43 <= v68 || result <= v67)
          {
            v77 = v64;
          }

          else
          {
            v69 = v65 <= v66;
            v70 = *(v106 | (8 * (v65 <= v66)));
            v71 = fabs(v70);
            v72 = fabs(*(v107 | (8 * v68)));
            if (v69)
            {
              v73 = 2;
            }

            else
            {
              v73 = 1;
            }

            if (v69)
            {
              v74 = 1;
            }

            else
            {
              v74 = 2;
            }

            v75 = v71 <= v72;
            if (v71 <= v72)
            {
              v76 = v70;
            }

            else
            {
              v76 = *(v107 | (8 * v68));
            }

            if (v75)
            {
              v67 = v73;
            }

            if (!v75)
            {
              LODWORD(v68) = v74;
            }

            v77 = v64 + v76;
            v78 = v64 - (v64 + v76 - v76);
            if (v78 == 0.0)
            {
              v63 = 0;
            }

            else
            {
              *&v97 = v78;
              v63 = 1;
            }

            if (v68 < v43 && v67 < result)
            {
              do
              {
                v79 = v77;
                v80 = fabs(*(v106 + v67));
                v81 = fabs(*(v107 + v68));
                v82 = v80 <= v81;
                if (v80 > v81)
                {
                  v83 = *(v107 + v68);
                }

                else
                {
                  v83 = *(v106 + v67);
                }

                if (v82)
                {
                  ++v67;
                }

                else
                {
                  LODWORD(v68) = v68 + 1;
                }

                v77 = v77 + v83;
                v84 = v83 - (v79 + v83 - v79) + v79 - (v79 + v83 - (v79 + v83 - v79));
                if (v84 != 0.0)
                {
                  *(&v97 + v63++) = v84;
                }
              }

              while (v68 < v43 && v67 < result);
            }
          }

          if (v68 < v43)
          {
            v86 = v107 + v68;
            v87 = v43 - v68;
            do
            {
              v88 = v77;
              v77 = v77 + *v86;
              v89 = *v86 - (v77 - v88) + v88 - (v77 - (v77 - v88));
              if (v89 != 0.0)
              {
                *(&v97 + v63++) = v89;
              }

              ++v86;
              --v87;
            }

            while (v87);
          }

          if (v67 < result)
          {
            v90 = v106 + v67;
            v91 = result - v67;
            do
            {
              v92 = v77;
              v77 = v77 + *v90;
              v93 = *v90 - (v77 - v92) + v92 - (v77 - (v77 - v92));
              if (v93 != 0.0)
              {
                *(&v97 + v63++) = v93;
              }

              ++v90;
              --v91;
            }

            while (v91);
          }
        }
      }
    }
  }

  return result;
}

uint64_t sub_101688598(double *a1, double *a2, double *a3)
{
  v4 = fabs(*a2);
  v5 = fabs(*a1);
  v6 = v4 <= v5;
  v7 = v4 > v5;
  v8 = v4 <= v5;
  if (v4 > v5)
  {
    v9 = *a1;
  }

  else
  {
    v9 = *a2;
  }

  v10 = fabs(a2[v8]);
  v11 = fabs(a1[v7]);
  if (v6)
  {
    v12 = 2;
  }

  else
  {
    v12 = 1;
  }

  if (v6)
  {
    v13 = 1;
  }

  else
  {
    v13 = 2;
  }

  v14 = v10 <= v11;
  if (v10 <= v11)
  {
    v15 = a2[v8];
  }

  else
  {
    v15 = a1[v7];
  }

  if (v14)
  {
    v8 = v12;
  }

  if (!v14)
  {
    v7 = v13;
  }

  v16 = v9 + v15;
  v17 = v9 - (v9 + v15 - v15);
  if (v17 == 0.0)
  {
    result = 0;
  }

  else
  {
    *a3 = v17;
    result = 1;
  }

  do
  {
    v19 = v16;
    v20 = fabs(a2[v8]);
    v21 = fabs(a1[v7]);
    v22 = v20 <= v21;
    if (v20 > v21)
    {
      v23 = a1[v7];
    }

    else
    {
      v23 = a2[v8];
    }

    if (v22)
    {
      ++v8;
    }

    else
    {
      ++v7;
    }

    v16 = v16 + v23;
    v24 = v23 - (v19 + v23 - v19) + v19 - (v19 + v23 - (v19 + v23 - v19));
    if (v24 != 0.0)
    {
      a3[result] = v24;
      result = (result + 1);
    }
  }

  while (v7 <= 3 && v8 < 4);
  if (v7 <= 3)
  {
    v26 = v7;
    do
    {
      v27 = v16;
      v28 = a1[v26];
      v16 = v16 + v28;
      v29 = v28 - (v16 - v27) + v27 - (v16 - (v16 - v27));
      if (v29 != 0.0)
      {
        a3[result] = v29;
        result = (result + 1);
      }

      ++v26;
    }

    while (v26 != 4);
  }

  if (v8 <= 3)
  {
    v30 = v8;
    do
    {
      v31 = v16;
      v32 = a2[v30];
      v16 = v16 + v32;
      v33 = v32 - (v16 - v31) + v31 - (v16 - (v16 - v31));
      if (v33 != 0.0)
      {
        a3[result] = v33;
        result = (result + 1);
      }

      ++v30;
    }

    while (v30 != 4);
  }

  if (v16 != 0.0 || result == 0)
  {
    a3[result] = v16;
    return (result + 1);
  }

  return result;
}

void sub_10168870C(double *a1, double *a2, uint64_t a3, char a4)
{
LABEL_1:
  v7 = a2 - 2;
  i = a1;
  while (1)
  {
    a1 = i;
    v9 = (a2 - i) >> 4;
    if (v9 > 2)
    {
      switch(v9)
      {
        case 3:

          sub_10168A160(i, i + 2, a2 - 2);
          return;
        case 4:

          sub_10168A678(i, i + 2, i + 4, a2 - 2);
          return;
        case 5:

          sub_10168A9BC(i, i + 2, i + 4, (i + 6), a2 - 2);
          return;
      }
    }

    else
    {
      if (v9 < 2)
      {
        return;
      }

      if (v9 == 2)
      {
        v115 = a2 - 2;
        v116 = *(a2 - 2);
        v117 = *i;
        if (v116 != *i)
        {
          if ((*&v116 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v117 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_695;
          }

          v266 = fabs(v116);
          v267 = fabs(v117);
          v268 = vabdd_f64(v116, v117);
          if (v266 < v267)
          {
            v266 = v267;
          }

          if (v266 < 1.0)
          {
            v266 = 1.0;
          }

          if (v268 > v266 * 2.22044605e-16)
          {
            goto LABEL_695;
          }
        }

        v116 = *(a2 - 1);
        v117 = i[1];
        if (v116 == v117)
        {
          return;
        }

        if ((*&v116 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v117 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v118 = fabs(v116);
          v119 = fabs(v117);
          if (v118 < v119)
          {
            v118 = v119;
          }

          if (v118 < 1.0)
          {
            v118 = 1.0;
          }

          if (v116 >= v117 || vabdd_f64(v116, v117) <= v118 * 2.22044605e-16)
          {
            return;
          }
        }

        else
        {
LABEL_695:
          if (v116 >= v117)
          {
            return;
          }
        }

        v274 = *i;
        *i = *v115;
        *v115 = v274;
        return;
      }
    }

    if (v9 <= 23)
    {
      break;
    }

    if (!a3)
    {
      if (i == a2)
      {
        return;
      }

      v149 = (v9 - 2) >> 1;
      v150 = v149;
      while (1)
      {
        v151 = v150;
        if (v149 < v150)
        {
          goto LABEL_515;
        }

        v152 = (2 * v150) | 1;
        v153 = &i[2 * v152];
        if (2 * v151 + 2 >= v9)
        {
          goto LABEL_443;
        }

        v154 = v153[2];
        v155 = *v153;
        if (*v153 != v154)
        {
          if ((*&v155 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v154 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            break;
          }

          v195 = fabs(v155);
          v196 = fabs(v154);
          v197 = vabdd_f64(v155, v154);
          if (v195 < v196)
          {
            v195 = v196;
          }

          if (v195 < 1.0)
          {
            v195 = 1.0;
          }

          if (v197 > v195 * 2.22044605e-16)
          {
            break;
          }
        }

        v156 = v153[1];
        v157 = v153[3];
        if (v156 == v157)
        {
          goto LABEL_443;
        }

        if ((*&v156 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v157 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v198 = fabs(v156);
          v199 = fabs(v157);
          if (v198 < v199)
          {
            v198 = v199;
          }

          if (v198 < 1.0)
          {
            v198 = 1.0;
          }

          if (v156 >= v157 || vabdd_f64(v156, v157) <= v198 * 2.22044605e-16)
          {
            goto LABEL_443;
          }

LABEL_442:
          v153 += 2;
          v152 = 2 * v151 + 2;
          goto LABEL_443;
        }

        if (v156 < v157)
        {
          goto LABEL_442;
        }

LABEL_443:
        v160 = &i[2 * v151];
        v161 = *v153;
        v162 = *v160;
        if (*v153 == *v160)
        {
          goto LABEL_444;
        }

        if ((*&v161 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v162 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_455;
        }

        v190 = fabs(v161);
        v191 = fabs(v162);
        v192 = vabdd_f64(v161, v162);
        if (v190 < v191)
        {
          v190 = v191;
        }

        if (v190 < 1.0)
        {
          v190 = 1.0;
        }

        if (v192 <= v190 * 2.22044605e-16)
        {
LABEL_444:
          v163 = v153[1];
          v164 = v160[1];
          if (v163 != v164)
          {
            if ((*&v163 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v164 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
            {
              v193 = fabs(v163);
              v194 = fabs(v164);
              if (v193 < v194)
              {
                v193 = v194;
              }

              if (v193 < 1.0)
              {
                v193 = 1.0;
              }

              if (v163 < v164 && vabdd_f64(v163, v164) > v193 * 2.22044605e-16)
              {
                goto LABEL_515;
              }
            }

            else if (v163 < v164)
            {
              goto LABEL_515;
            }
          }
        }

        else
        {
LABEL_455:
          if (v161 < v162)
          {
            goto LABEL_515;
          }

          v164 = v160[1];
        }

        *v160 = *v153;
        if (v149 < v152)
        {
          goto LABEL_514;
        }

        v167 = fabs(v162);
        v168 = fabs(v164);
        while (1)
        {
          v169 = v153;
          v170 = 2 * v152;
          v152 = (2 * v152) | 1;
          v153 = &i[2 * v152];
          v171 = v170 + 2;
          if (v171 < v9)
          {
            v172 = v153[2];
            v173 = *v153;
            if (*v153 == v172)
            {
              goto LABEL_461;
            }

            if ((*&v173 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v172 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_472;
            }

            v185 = fabs(v173);
            v186 = fabs(v172);
            v187 = vabdd_f64(v173, v172);
            if (v185 < v186)
            {
              v185 = v186;
            }

            if (v185 < 1.0)
            {
              v185 = 1.0;
            }

            if (v187 <= v185 * 2.22044605e-16)
            {
LABEL_461:
              v174 = v153[1];
              v175 = v153[3];
              if (v174 != v175)
              {
                if ((*&v174 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v175 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  if (v174 >= v175)
                  {
                    goto LABEL_474;
                  }

LABEL_473:
                  v153 += 2;
                  v152 = v171;
                  goto LABEL_474;
                }

                v188 = fabs(v174);
                v189 = fabs(v175);
                if (v188 < v189)
                {
                  v188 = v189;
                }

                if (v188 < 1.0)
                {
                  v188 = 1.0;
                }

                if (v174 < v175 && vabdd_f64(v174, v175) > v188 * 2.22044605e-16)
                {
                  goto LABEL_473;
                }
              }
            }

            else
            {
LABEL_472:
              if (v173 < v172)
              {
                goto LABEL_473;
              }
            }
          }

LABEL_474:
          v178 = *v153;
          if (*v153 != v162)
          {
            if ((*&v162 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v178 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_495;
            }

            v183 = fabs(v178);
            v184 = vabdd_f64(v178, v162);
            if (v183 < v167)
            {
              v183 = v167;
            }

            if (v183 < 1.0)
            {
              v183 = 1.0;
            }

            if (v184 > v183 * 2.22044605e-16)
            {
LABEL_495:
              if (v178 < v162)
              {
                break;
              }

              goto LABEL_498;
            }
          }

          v179 = v153[1];
          if (v179 != v164)
          {
            if ((*&v179 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v164 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              if (v179 < v164)
              {
                break;
              }

              goto LABEL_498;
            }

            v180 = fabs(v179);
            v181 = vabdd_f64(v179, v164);
            if (v180 < v168)
            {
              v180 = v168;
            }

            if (v180 < 1.0)
            {
              v180 = 1.0;
            }

            if (v181 > v180 * 2.22044605e-16 && v179 < v164)
            {
              break;
            }
          }

LABEL_498:
          *v169 = *v153;
          if (v149 < v152)
          {
            goto LABEL_514;
          }
        }

        v153 = v169;
LABEL_514:
        *v153 = v162;
        v153[1] = v164;
LABEL_515:
        v150 = v151 - 1;
        if (!v151)
        {
LABEL_543:
          v200 = 0;
          v273 = *i;
          v201 = i;
          while (1)
          {
            v202 = v201;
            v203 = &v201[2 * v200];
            v201 = v203 + 2;
            v204 = 2 * v200;
            v200 = (2 * v200) | 1;
            v205 = v204 + 2;
            if (v205 < v9)
            {
              v206 = v203[4];
              v207 = v203[2];
              if (v207 == v206)
              {
                goto LABEL_546;
              }

              if ((*&v207 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v206 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                goto LABEL_557;
              }

              v212 = fabs(v207);
              v213 = fabs(v206);
              v214 = vabdd_f64(v207, v206);
              if (v212 < v213)
              {
                v212 = v213;
              }

              if (v212 < 1.0)
              {
                v212 = 1.0;
              }

              if (v214 <= v212 * 2.22044605e-16)
              {
LABEL_546:
                v208 = v203[3];
                v209 = v203[5];
                if (v208 != v209)
                {
                  if ((*&v208 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v209 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    v215 = fabs(v208);
                    v216 = fabs(v209);
                    if (v215 < v216)
                    {
                      v215 = v216;
                    }

                    if (v215 < 1.0)
                    {
                      v215 = 1.0;
                    }

                    if (v208 >= v209 || vabdd_f64(v208, v209) <= v215 * 2.22044605e-16)
                    {
                      goto LABEL_559;
                    }
                  }

                  else if (v208 >= v209)
                  {
                    goto LABEL_559;
                  }

LABEL_558:
                  v201 = v203 + 4;
                  v200 = v205;
                }
              }

              else
              {
LABEL_557:
                if (v207 < v206)
                {
                  goto LABEL_558;
                }
              }
            }

LABEL_559:
            *v202 = *v201;
            if (v200 > ((v9 - 2) >> 1))
            {
              a2 -= 2;
              if (v201 == a2)
              {
                *v201 = v273;
                goto LABEL_585;
              }

              *v201 = *a2;
              *a2 = v273;
              v217 = (v201 - i + 16) >> 4;
              v218 = v217 - 2;
              if (v217 < 2)
              {
                goto LABEL_585;
              }

              v219 = v218 >> 1;
              v220 = &i[2 * (v218 >> 1)];
              v221 = *v220;
              v222 = *v201;
              if (*v220 == *v201)
              {
                goto LABEL_577;
              }

              if ((*&v221 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v222 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                goto LABEL_592;
              }

              v238 = fabs(v221);
              v239 = fabs(v222);
              v240 = vabdd_f64(v221, v222);
              if (v238 < v239)
              {
                v238 = v239;
              }

              if (v238 < 1.0)
              {
                v238 = 1.0;
              }

              if (v240 <= v238 * 2.22044605e-16)
              {
LABEL_577:
                v223 = v220[1];
                v224 = v201[1];
                if (v223 == v224)
                {
                  goto LABEL_585;
                }

                if ((*&v223 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v224 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                {
                  v241 = fabs(v223);
                  v242 = fabs(v224);
                  if (v241 < v242)
                  {
                    v241 = v242;
                  }

                  if (v241 < 1.0)
                  {
                    v241 = 1.0;
                  }

                  if (v223 >= v224 || vabdd_f64(v223, v224) <= v241 * 2.22044605e-16)
                  {
                    goto LABEL_585;
                  }
                }

                else if (v223 >= v224)
                {
                  goto LABEL_585;
                }
              }

              else
              {
LABEL_592:
                if (v221 >= v222)
                {
                  goto LABEL_585;
                }

                v224 = v201[1];
              }

              *v201 = *v220;
              if (v218 < 2)
              {
                goto LABEL_628;
              }

              v227 = fabs(v222);
              v228 = fabs(v224);
              while (2)
              {
                v229 = v220;
                v230 = v219 - 1;
                v219 = (v219 - 1) >> 1;
                v220 = &i[2 * v219];
                v231 = *v220;
                if (*v220 != v222)
                {
                  if ((*&v222 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v231 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    goto LABEL_616;
                  }

                  v236 = fabs(v231);
                  v237 = vabdd_f64(v231, v222);
                  if (v236 < v227)
                  {
                    v236 = v227;
                  }

                  if (v236 < 1.0)
                  {
                    v236 = 1.0;
                  }

                  if (v237 > v236 * 2.22044605e-16)
                  {
LABEL_616:
                    if (v231 >= v222)
                    {
                      break;
                    }

                    goto LABEL_619;
                  }
                }

                v232 = v220[1];
                if (v232 == v224)
                {
                  break;
                }

                if ((*&v232 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v224 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  if (v232 >= v224)
                  {
                    break;
                  }

                  goto LABEL_619;
                }

                v233 = fabs(v232);
                v234 = vabdd_f64(v232, v224);
                if (v233 < v228)
                {
                  v233 = v228;
                }

                if (v233 < 1.0)
                {
                  v233 = 1.0;
                }

                if (v234 > v233 * 2.22044605e-16 && v232 < v224)
                {
LABEL_619:
                  *v229 = *v220;
                  if (v230 <= 1)
                  {
                    goto LABEL_628;
                  }

                  continue;
                }

                break;
              }

              v220 = v229;
LABEL_628:
              *v220 = v222;
              v220[1] = v224;
LABEL_585:
              v130 = v9-- <= 2;
              if (v130)
              {
                return;
              }

              goto LABEL_543;
            }
          }
        }
      }

      if (v155 >= v154)
      {
        goto LABEL_443;
      }

      goto LABEL_442;
    }

    v10 = v9 >> 1;
    v11 = &i[2 * (v9 >> 1)];
    if (v9 < 0x81)
    {
      sub_10168A160(&a1[2 * (v9 >> 1)], a1, a2 - 2);
    }

    else
    {
      sub_10168A160(a1, &a1[2 * (v9 >> 1)], a2 - 2);
      sub_10168A160(a1 + 2, v11 - 2, a2 - 4);
      sub_10168A160(a1 + 4, &a1[2 * v10 + 2], a2 - 6);
      sub_10168A160(v11 - 2, v11, &a1[2 * v10 + 2]);
      v270 = *a1;
      *a1 = *v11;
      *v11 = v270;
    }

    --a3;
    v12 = *a1;
    v13 = fabs(*a1);
    if (a4)
    {
      goto LABEL_42;
    }

    v14 = *(a1 - 2);
    if (v14 != v12)
    {
      if ((*&v14 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_28;
      }

      v17 = fabs(v14);
      v18 = vabdd_f64(v14, v12);
      if (v17 < v13)
      {
        v17 = v13;
      }

      if (v17 < 1.0)
      {
        v17 = 1.0;
      }

      if (v18 > v17 * 2.22044605e-16)
      {
LABEL_28:
        if (v14 >= v12)
        {
          v16 = a1[1];
          goto LABEL_30;
        }

        goto LABEL_42;
      }
    }

    v15 = *(a1 - 1);
    v16 = a1[1];
    if (v15 == v16)
    {
      goto LABEL_30;
    }

    if ((*&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v16 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      if (v15 >= v16)
      {
        goto LABEL_30;
      }

      goto LABEL_42;
    }

    v22 = fabs(v15);
    v23 = fabs(v16);
    if (v22 < v23)
    {
      v22 = v23;
    }

    if (v22 < 1.0)
    {
      v22 = 1.0;
    }

    if (v15 >= v16 || vabdd_f64(v15, v16) <= v22 * 2.22044605e-16)
    {
LABEL_30:
      v19 = *v7;
      if (v12 == *v7)
      {
        goto LABEL_31;
      }

      if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v19 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_190;
      }

      v69 = fabs(v19);
      v70 = vabdd_f64(v12, v19);
      if (v13 >= v69)
      {
        v69 = v13;
      }

      if (v69 < 1.0)
      {
        v69 = 1.0;
      }

      if (v70 <= v69 * 2.22044605e-16)
      {
LABEL_31:
        v20 = *(a2 - 1);
        if (v16 != v20)
        {
          v21 = fabs(v16);
          if ((*&v16 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v20 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            v78 = fabs(v20);
            v79 = vabdd_f64(v16, v20);
            if (v21 >= v78)
            {
              v78 = v21;
            }

            if (v78 < 1.0)
            {
              v78 = 1.0;
            }

            if (v79 > v78 * 2.22044605e-16 && v16 < v20)
            {
              goto LABEL_192;
            }
          }

          else if (v16 < v20)
          {
            goto LABEL_192;
          }
        }
      }

      else
      {
LABEL_190:
        if (v12 < v19)
        {
          v21 = fabs(v16);
LABEL_192:
          for (i = a1 + 2; ; i += 2)
          {
            v71 = *i;
            if (v12 == *i)
            {
              goto LABEL_194;
            }

            if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v71 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_206;
            }

            v73 = fabs(v71);
            v74 = vabdd_f64(v12, v71);
            if (v13 >= v73)
            {
              v73 = v13;
            }

            if (v73 < 1.0)
            {
              v73 = 1.0;
            }

            if (v74 <= v73 * 2.22044605e-16)
            {
LABEL_194:
              v72 = i[1];
              if (v16 != v72)
              {
                if (v21 == INFINITY || (*&v72 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  if (v16 < v72)
                  {
                    goto LABEL_253;
                  }
                }

                else
                {
                  v75 = fabs(v72);
                  v76 = vabdd_f64(v16, v72);
                  if (v21 >= v75)
                  {
                    v75 = v21;
                  }

                  if (v75 < 1.0)
                  {
                    v75 = 1.0;
                  }

                  if (v76 > v75 * 2.22044605e-16 && v16 < v72)
                  {
                    goto LABEL_253;
                  }
                }
              }
            }

            else
            {
LABEL_206:
              if (v12 < v71)
              {
                goto LABEL_253;
              }
            }
          }
        }
      }

      i = a1 + 2;
      if (a1 + 2 < a2)
      {
        v81 = fabs(v16);
        do
        {
          v82 = *i;
          if (v12 == *i)
          {
            goto LABEL_229;
          }

          if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v82 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_241;
          }

          v84 = fabs(v82);
          v85 = vabdd_f64(v12, v82);
          if (v13 >= v84)
          {
            v84 = v13;
          }

          if (v84 < 1.0)
          {
            v84 = 1.0;
          }

          if (v85 <= v84 * 2.22044605e-16)
          {
LABEL_229:
            v83 = i[1];
            if (v16 != v83)
            {
              if ((*&v16 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v83 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                v86 = fabs(v83);
                v87 = vabdd_f64(v16, v83);
                if (v81 >= v86)
                {
                  v86 = v81;
                }

                if (v86 < 1.0)
                {
                  v86 = 1.0;
                }

                if (v87 > v86 * 2.22044605e-16 && v16 < v83)
                {
                  break;
                }
              }

              else if (v16 < v83)
              {
                break;
              }
            }
          }

          else
          {
LABEL_241:
            if (v12 < v82)
            {
              break;
            }
          }

          i += 2;
        }

        while (i < a2);
      }

LABEL_253:
      j = a2;
      if (i < a2)
      {
        v90 = fabs(v16);
        for (j = a2 - 2; ; j -= 2)
        {
          if (v12 == v19)
          {
            goto LABEL_256;
          }

          if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v19 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_268;
          }

          v92 = fabs(v19);
          v93 = vabdd_f64(v12, v19);
          if (v13 >= v92)
          {
            v92 = v13;
          }

          if (v92 < 1.0)
          {
            v92 = 1.0;
          }

          if (v93 <= v92 * 2.22044605e-16)
          {
LABEL_256:
            v91 = j[1];
            if (v16 == v91)
            {
              break;
            }

            if ((*&v16 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v91 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
            {
              v94 = fabs(v91);
              v95 = vabdd_f64(v16, v91);
              if (v90 >= v94)
              {
                v94 = v90;
              }

              if (v94 < 1.0)
              {
                v94 = 1.0;
              }

              if (v95 <= v94 * 2.22044605e-16 || v16 >= v91)
              {
                break;
              }
            }

            else if (v16 >= v91)
            {
              break;
            }
          }

          else
          {
LABEL_268:
            if (v12 >= v19)
            {
              break;
            }
          }

          v97 = *(j - 2);
          v19 = v97;
        }
      }

      if (i < j)
      {
        v98 = fabs(v16);
        do
        {
          v272 = *i;
          *i = *j;
          *j = v272;
          do
          {
            while (1)
            {
              do
              {
                while (1)
                {
                  v99 = i[2];
                  i += 2;
                  v100 = v99;
                  if (v12 == v99)
                  {
                    break;
                  }

                  if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v100 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    v102 = fabs(v100);
                    v103 = vabdd_f64(v12, v100);
                    if (v13 >= v102)
                    {
                      v102 = v13;
                    }

                    if (v102 < 1.0)
                    {
                      v102 = 1.0;
                    }

                    if (v103 <= v102 * 2.22044605e-16)
                    {
                      break;
                    }
                  }

                  if (v12 < v100)
                  {
                    goto LABEL_326;
                  }
                }

                v101 = i[1];
              }

              while (v16 == v101);
              if ((*&v16 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v101 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                break;
              }

              if (v16 < v101)
              {
                goto LABEL_326;
              }
            }

            v104 = fabs(v101);
            v105 = vabdd_f64(v16, v101);
            if (v98 >= v104)
            {
              v104 = v98;
            }

            if (v104 < 1.0)
            {
              v104 = 1.0;
            }
          }

          while (v105 <= v104 * 2.22044605e-16 || v16 >= v101);
          while (1)
          {
LABEL_326:
            while (1)
            {
              v112 = *(j - 2);
              j -= 2;
              v113 = v112;
              if (v12 == v112)
              {
                break;
              }

              if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v113 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                v107 = fabs(v113);
                v108 = vabdd_f64(v12, v113);
                if (v13 >= v107)
                {
                  v107 = v13;
                }

                if (v107 < 1.0)
                {
                  v107 = 1.0;
                }

                if (v108 <= v107 * 2.22044605e-16)
                {
                  break;
                }
              }

              if (v12 >= v113)
              {
                goto LABEL_331;
              }
            }

            v114 = j[1];
            if (v16 == v114)
            {
              break;
            }

            if ((*&v16 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v114 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
            {
              v109 = fabs(v114);
              v110 = vabdd_f64(v16, v114);
              if (v98 >= v109)
              {
                v109 = v98;
              }

              if (v109 < 1.0)
              {
                v109 = 1.0;
              }

              if (v110 <= v109 * 2.22044605e-16 || v16 >= v114)
              {
                break;
              }
            }

            else if (v16 >= v114)
            {
              break;
            }
          }

LABEL_331:
          ;
        }

        while (i < j);
      }

      if (i - 2 != a1)
      {
        *a1 = *(i - 1);
      }

      a4 = 0;
      *(i - 2) = v12;
      *(i - 1) = v16;
    }

    else
    {
LABEL_42:
      v24 = 0;
      v25 = a1[1];
      v26 = fabs(v25);
      while (1)
      {
        v27 = a1[v24 + 2];
        if (v27 != v12)
        {
          if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v27 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_63;
          }

          v32 = fabs(v27);
          v33 = vabdd_f64(v27, v12);
          if (v32 < v13)
          {
            v32 = v13;
          }

          if (v32 < 1.0)
          {
            v32 = 1.0;
          }

          if (v33 > v32 * 2.22044605e-16)
          {
LABEL_63:
            if (v27 >= v12)
            {
              goto LABEL_67;
            }

            goto LABEL_66;
          }
        }

        v28 = a1[v24 + 3];
        if (v28 == v25)
        {
          goto LABEL_67;
        }

        if ((*&v28 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v25 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          break;
        }

        if (v28 >= v25)
        {
          goto LABEL_67;
        }

LABEL_66:
        v24 += 2;
      }

      v29 = fabs(v28);
      v30 = vabdd_f64(v28, v25);
      if (v29 < v26)
      {
        v29 = v26;
      }

      if (v29 < 1.0)
      {
        v29 = 1.0;
      }

      if (v30 > v29 * 2.22044605e-16 && v28 < v25)
      {
        goto LABEL_66;
      }

LABEL_67:
      v34 = &a1[v24 + 2];
      k = a2 - 2;
      if (v24 * 8)
      {
        while (1)
        {
          v36 = *k;
          if (*k == v12)
          {
            goto LABEL_69;
          }

          if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v36 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_89;
          }

          v41 = fabs(v36);
          v42 = vabdd_f64(v36, v12);
          if (v41 < v13)
          {
            v41 = v13;
          }

          if (v41 < 1.0)
          {
            v41 = 1.0;
          }

          if (v42 <= v41 * 2.22044605e-16)
          {
LABEL_69:
            v37 = k[1];
            if (v37 != v25)
            {
              if ((*&v37 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v25 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                if (v37 < v25)
                {
                  goto LABEL_126;
                }
              }

              else
              {
                v38 = fabs(v37);
                v39 = vabdd_f64(v37, v25);
                if (v38 < v26)
                {
                  v38 = v26;
                }

                if (v38 < 1.0)
                {
                  v38 = 1.0;
                }

                if (v39 > v38 * 2.22044605e-16 && v37 < v25)
                {
                  goto LABEL_126;
                }
              }
            }
          }

          else
          {
LABEL_89:
            if (v36 < v12)
            {
              goto LABEL_126;
            }
          }

          k -= 2;
        }
      }

      k = a2;
      if (v34 < a2)
      {
        for (k = a2 - 2; ; k -= 2)
        {
          v43 = *k;
          if (*k == v12)
          {
            goto LABEL_96;
          }

          if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v43 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_106;
          }

          v45 = fabs(v43);
          v46 = vabdd_f64(v43, v12);
          if (v45 < v13)
          {
            v45 = v13;
          }

          if (v45 < 1.0)
          {
            v45 = 1.0;
          }

          if (v46 <= v45 * 2.22044605e-16)
          {
LABEL_96:
            v44 = k[1];
            if (v44 == v25)
            {
              if (v34 >= k)
              {
                break;
              }
            }

            else if ((*&v44 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v25 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              if (v34 >= k || v44 < v25)
              {
                break;
              }
            }

            else
            {
              v48 = fabs(v44);
              v49 = vabdd_f64(v44, v25);
              if (v48 < v26)
              {
                v48 = v26;
              }

              if (v48 < 1.0)
              {
                v48 = 1.0;
              }

              v50 = v49 <= v48 * 2.22044605e-16;
              if (v44 >= v25)
              {
                v50 = 1;
              }

              if (v34 >= k || !v50)
              {
                break;
              }
            }
          }

          else
          {
LABEL_106:
            if (v43 < v12 || v34 >= k)
            {
              break;
            }
          }
        }
      }

LABEL_126:
      i = v34;
      if (v34 < k)
      {
        v51 = k;
        do
        {
          v271 = *i;
          *i = *v51;
          *v51 = v271;
          while (1)
          {
            while (1)
            {
              v52 = i[2];
              i += 2;
              v53 = v52;
              if (v52 == v12)
              {
                break;
              }

              if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v53 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                v58 = fabs(v53);
                v59 = vabdd_f64(v53, v12);
                if (v58 < v13)
                {
                  v58 = v13;
                }

                if (v58 < 1.0)
                {
                  v58 = 1.0;
                }

                if (v59 <= v58 * 2.22044605e-16)
                {
                  break;
                }
              }

              if (v53 >= v12)
              {
                goto LABEL_152;
              }
            }

            v54 = i[1];
            if (v54 == v25)
            {
              break;
            }

            if ((*&v54 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v25 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              if (v54 >= v25)
              {
                goto LABEL_152;
              }
            }

            else
            {
              v55 = fabs(v54);
              v56 = vabdd_f64(v54, v25);
              if (v55 < v26)
              {
                v55 = v26;
              }

              if (v55 < 1.0)
              {
                v55 = 1.0;
              }

              if (v56 <= v55 * 2.22044605e-16 || v54 >= v25)
              {
                goto LABEL_152;
              }
            }
          }

          do
          {
            while (1)
            {
              do
              {
LABEL_152:
                while (1)
                {
                  v60 = *(v51 - 2);
                  v51 -= 2;
                  v61 = v60;
                  if (v60 == v12)
                  {
                    break;
                  }

                  if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v61 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    v66 = fabs(v61);
                    v67 = vabdd_f64(v61, v12);
                    if (v66 < v13)
                    {
                      v66 = v13;
                    }

                    if (v66 < 1.0)
                    {
                      v66 = 1.0;
                    }

                    if (v67 <= v66 * 2.22044605e-16)
                    {
                      break;
                    }
                  }

                  if (v61 < v12)
                  {
                    goto LABEL_176;
                  }
                }

                v62 = v51[1];
              }

              while (v62 == v25);
              if ((*&v62 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v25 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                break;
              }

              if (v62 < v25)
              {
                goto LABEL_176;
              }
            }

            v63 = fabs(v62);
            v64 = vabdd_f64(v62, v25);
            if (v63 < v26)
            {
              v63 = v26;
            }

            if (v63 < 1.0)
            {
              v63 = 1.0;
            }
          }

          while (v64 <= v63 * 2.22044605e-16 || v62 >= v25);
LABEL_176:
          ;
        }

        while (i < v51);
      }

      if (i - 2 != a1)
      {
        *a1 = *(i - 1);
      }

      *(i - 2) = v12;
      *(i - 1) = v25;
      if (v34 < k)
      {
LABEL_182:
        sub_10168870C(a1, i - 2, a3, a4 & 1);
        a4 = 0;
      }

      else
      {
        v68 = sub_10168AE00(a1, i - 2);
        if (sub_10168AE00(i, a2))
        {
          a2 = i - 2;
          if (v68)
          {
            return;
          }

          goto LABEL_1;
        }

        if (!v68)
        {
          goto LABEL_182;
        }
      }
    }
  }

  v120 = i + 2;
  v122 = i == a2 || v120 == a2;
  if ((a4 & 1) == 0)
  {
    if (v122)
    {
      return;
    }

    while (1)
    {
      v243 = a1;
      a1 = v120;
      v244 = v243[2];
      v245 = *v243;
      if (v244 == *v243)
      {
        goto LABEL_638;
      }

      if ((*&v244 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v245 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_649;
      }

      v261 = fabs(v244);
      v262 = fabs(v245);
      v263 = vabdd_f64(v244, v245);
      if (v261 < v262)
      {
        v261 = v262;
      }

      if (v261 < 1.0)
      {
        v261 = 1.0;
      }

      if (v263 <= v261 * 2.22044605e-16)
      {
LABEL_638:
        v246 = v243[3];
        v247 = v243[1];
        if (v246 == v247)
        {
          goto LABEL_676;
        }

        v248 = fabs(v246);
        if ((*&v246 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v247 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v264 = fabs(v247);
          if (v248 >= v264)
          {
            v264 = v248;
          }

          if (v264 < 1.0)
          {
            v264 = 1.0;
          }

          if (v246 >= v247 || vabdd_f64(v246, v247) <= v264 * 2.22044605e-16)
          {
            goto LABEL_676;
          }
        }

        else if (v246 >= v247)
        {
          goto LABEL_676;
        }
      }

      else
      {
LABEL_649:
        if (v244 >= v245)
        {
          goto LABEL_676;
        }

        v246 = v243[3];
        v248 = fabs(v246);
      }

      v251 = fabs(v244);
      do
      {
        while (1)
        {
          while (1)
          {
            v252 = v243;
            *(v243 + 1) = *v243;
            v253 = *(v243 - 2);
            v243 -= 2;
            v254 = v253;
            if (v244 == v253)
            {
              break;
            }

            if ((*&v244 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v254 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
            {
              v256 = fabs(v254);
              v257 = vabdd_f64(v244, v254);
              if (v251 >= v256)
              {
                v256 = v251;
              }

              if (v256 < 1.0)
              {
                v256 = 1.0;
              }

              if (v257 <= v256 * 2.22044605e-16)
              {
                break;
              }
            }

            if (v244 >= v254)
            {
              goto LABEL_675;
            }
          }

          v255 = *(v252 - 1);
          if (v246 == v255)
          {
            goto LABEL_675;
          }

          if (v248 != INFINITY && (*&v255 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            break;
          }

          if (v246 >= v255)
          {
            goto LABEL_675;
          }
        }

        v258 = fabs(v255);
        v259 = vabdd_f64(v246, v255);
        if (v248 >= v258)
        {
          v258 = v248;
        }

        if (v258 < 1.0)
        {
          v258 = 1.0;
        }
      }

      while (v259 > v258 * 2.22044605e-16 && v246 < v255);
LABEL_675:
      *v252 = v244;
      v252[1] = v246;
LABEL_676:
      v120 += 2;
      if (a1 + 2 == a2)
      {
        return;
      }
    }
  }

  if (v122)
  {
    return;
  }

  v123 = 0;
  v124 = i;
  while (2)
  {
    v125 = v124;
    v124 = v120;
    v126 = v125[2];
    v127 = *v125;
    if (v126 == *v125)
    {
      goto LABEL_367;
    }

    if ((*&v126 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v127 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_378;
    }

    v144 = fabs(v126);
    v145 = fabs(v127);
    v146 = vabdd_f64(v126, v127);
    if (v144 < v145)
    {
      v144 = v145;
    }

    if (v144 < 1.0)
    {
      v144 = 1.0;
    }

    if (v146 <= v144 * 2.22044605e-16)
    {
LABEL_367:
      v128 = v125[3];
      v129 = v125[1];
      if (v128 == v129)
      {
        goto LABEL_423;
      }

      v130 = (*&v128 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v129 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL;
      if (v130)
      {
        v147 = fabs(v128);
        v148 = fabs(v129);
        if (v147 < v148)
        {
          v147 = v148;
        }

        if (v147 < 1.0)
        {
          v147 = 1.0;
        }

        if (v128 >= v129 || vabdd_f64(v128, v129) <= v147 * 2.22044605e-16)
        {
          goto LABEL_423;
        }
      }

      else if (v128 >= v129)
      {
        goto LABEL_423;
      }
    }

    else
    {
LABEL_378:
      if (v126 >= v127)
      {
        goto LABEL_423;
      }

      v128 = v125[3];
    }

    *v120 = *v125;
    v132 = i;
    if (v125 == i)
    {
      goto LABEL_422;
    }

    v133 = fabs(v126);
    v134 = fabs(v128);
    v135 = v123;
    while (2)
    {
      v136 = (i + v135);
      v137 = *(i + v135 - 16);
      if (v126 != v137)
      {
        if ((*&v126 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v137 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_395;
        }

        v139 = fabs(v137);
        v140 = vabdd_f64(v126, v137);
        if (v133 >= v139)
        {
          v139 = v133;
        }

        if (v139 < 1.0)
        {
          v139 = 1.0;
        }

        if (v140 > v139 * 2.22044605e-16)
        {
LABEL_395:
          if (v126 >= v137)
          {
            goto LABEL_414;
          }

          goto LABEL_406;
        }
      }

      v138 = *(v136 - 1);
      if (v128 == v138)
      {
        goto LABEL_414;
      }

      if ((*&v128 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v138 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        if (v128 >= v138)
        {
          v132 = (i + v135);
          goto LABEL_422;
        }

LABEL_406:
        v125 -= 2;
        *v136 = *(i + v135 - 16);
        v135 -= 16;
        if (!v135)
        {
          v132 = i;
          goto LABEL_422;
        }

        continue;
      }

      break;
    }

    v141 = fabs(v138);
    v142 = vabdd_f64(v128, v138);
    if (v134 >= v141)
    {
      v141 = v134;
    }

    if (v141 < 1.0)
    {
      v141 = 1.0;
    }

    if (v142 > v141 * 2.22044605e-16 && v128 < v138)
    {
      goto LABEL_406;
    }

LABEL_414:
    v132 = v125;
LABEL_422:
    *v132 = v126;
    v132[1] = v128;
LABEL_423:
    v120 = v124 + 2;
    v123 += 16;
    if (v124 + 2 != a2)
    {
      continue;
    }

    break;
  }
}

double *sub_10168A160(double *result, double *a2, double *a3)
{
  v3 = *a2;
  v4 = *result;
  if (*a2 != *result)
  {
    if ((*&v3 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v4 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_13;
    }

    v14 = fabs(v3);
    v15 = fabs(v4);
    v16 = vabdd_f64(v3, v4);
    if (v14 < v15)
    {
      v14 = v15;
    }

    if (v14 < 1.0)
    {
      v14 = 1.0;
    }

    if (v16 > v14 * 2.22044605e-16)
    {
LABEL_13:
      if (v3 < v4)
      {
        goto LABEL_14;
      }

LABEL_38:
      v19 = *a3;
      if (*a3 == v3)
      {
        goto LABEL_39;
      }

      if ((*&v19 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v3 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_50;
      }

      v33 = fabs(v19);
      v34 = fabs(v3);
      v35 = vabdd_f64(v19, v3);
      if (v33 < v34)
      {
        v33 = v34;
      }

      if (v33 < 1.0)
      {
        v33 = 1.0;
      }

      if (v35 <= v33 * 2.22044605e-16)
      {
LABEL_39:
        v20 = a3[1];
        v21 = a2[1];
        if (v20 == v21)
        {
          return result;
        }

        if ((*&v20 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v21 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v36 = fabs(v20);
          v37 = fabs(v21);
          if (v36 < v37)
          {
            v36 = v37;
          }

          if (v36 < 1.0)
          {
            v36 = 1.0;
          }

          if (v20 >= v21 || vabdd_f64(v20, v21) <= v36 * 2.22044605e-16)
          {
            return result;
          }
        }

        else if (v20 >= v21)
        {
          return result;
        }
      }

      else
      {
LABEL_50:
        if (v19 >= v3)
        {
          return result;
        }
      }

      v24 = *a2;
      *a2 = *a3;
      *a3 = v24;
      v25 = *a2;
      v26 = *result;
      if (*a2 != *result)
      {
        if ((*&v25 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v26 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_69;
        }

        v29 = fabs(v25);
        v30 = fabs(v26);
        v31 = vabdd_f64(v25, v26);
        if (v29 < v30)
        {
          v29 = v30;
        }

        if (v29 < 1.0)
        {
          v29 = 1.0;
        }

        if (v31 > v29 * 2.22044605e-16)
        {
          goto LABEL_69;
        }
      }

      v25 = a2[1];
      v26 = result[1];
      if (v25 == v26)
      {
        return result;
      }

      if ((*&v25 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v26 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v27 = fabs(v25);
        v28 = fabs(v26);
        if (v27 < v28)
        {
          v27 = v28;
        }

        if (v27 < 1.0)
        {
          v27 = 1.0;
        }

        if (v25 >= v26 || vabdd_f64(v25, v26) <= v27 * 2.22044605e-16)
        {
          return result;
        }
      }

      else
      {
LABEL_69:
        if (v25 >= v26)
        {
          return result;
        }
      }

      v32 = *result;
      *result = *a2;
      *a2 = v32;
      return result;
    }
  }

  v5 = a2[1];
  v6 = result[1];
  if (v5 == v6)
  {
    goto LABEL_38;
  }

  if ((*&v5 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v17 = fabs(v5);
    v18 = fabs(v6);
    if (v17 < v18)
    {
      v17 = v18;
    }

    if (v17 < 1.0)
    {
      v17 = 1.0;
    }

    if (v5 >= v6 || vabdd_f64(v5, v6) <= v17 * 2.22044605e-16)
    {
      goto LABEL_38;
    }
  }

  else if (v5 >= v6)
  {
    goto LABEL_38;
  }

LABEL_14:
  v9 = *a3;
  if (*a3 == v3)
  {
    goto LABEL_15;
  }

  if ((*&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v3 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    goto LABEL_24;
  }

  v38 = fabs(v9);
  v39 = fabs(v3);
  v40 = vabdd_f64(v9, v3);
  if (v38 < v39)
  {
    v38 = v39;
  }

  if (v38 < 1.0)
  {
    v38 = 1.0;
  }

  if (v40 <= v38 * 2.22044605e-16)
  {
LABEL_15:
    v10 = a3[1];
    v11 = a2[1];
    if (v10 != v11)
    {
      if ((*&v10 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v11 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v41 = fabs(v10);
        v42 = fabs(v11);
        if (v41 < v42)
        {
          v41 = v42;
        }

        if (v41 < 1.0)
        {
          v41 = 1.0;
        }

        if (v10 < v11 && vabdd_f64(v10, v11) > v41 * 2.22044605e-16)
        {
          goto LABEL_25;
        }
      }

      else if (v10 < v11)
      {
LABEL_25:
        v13 = *result;
        *result = *a3;
LABEL_116:
        *a3 = v13;
        return result;
      }
    }
  }

  else
  {
LABEL_24:
    if (v9 < v3)
    {
      goto LABEL_25;
    }
  }

  v43 = *result;
  *result = *a2;
  *a2 = v43;
  v44 = *a3;
  v45 = *a2;
  if (*a3 != *a2)
  {
    if ((*&v44 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v45 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_114;
    }

    v48 = fabs(v44);
    v49 = fabs(v45);
    v50 = vabdd_f64(v44, v45);
    if (v48 < v49)
    {
      v48 = v49;
    }

    if (v48 < 1.0)
    {
      v48 = 1.0;
    }

    if (v50 > v48 * 2.22044605e-16)
    {
      goto LABEL_114;
    }
  }

  v44 = a3[1];
  v45 = a2[1];
  if (v44 == v45)
  {
    return result;
  }

  if ((*&v44 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v45 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
LABEL_114:
    if (v44 >= v45)
    {
      return result;
    }

    goto LABEL_115;
  }

  v46 = fabs(v44);
  v47 = fabs(v45);
  if (v46 < v47)
  {
    v46 = v47;
  }

  if (v46 < 1.0)
  {
    v46 = 1.0;
  }

  if (v44 < v45 && vabdd_f64(v44, v45) > v46 * 2.22044605e-16)
  {
LABEL_115:
    v13 = *a2;
    *a2 = *a3;
    goto LABEL_116;
  }

  return result;
}

__n128 sub_10168A678(double *a1, double *a2, double *a3, unint64_t *a4)
{
  sub_10168A160(a1, a2, a3);
  result.n128_u64[0] = *a4;
  v9 = *a3;
  if (*a4 != *a3)
  {
    if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_19;
    }

    v23 = fabs(result.n128_f64[0]);
    v24 = fabs(v9);
    v25 = vabdd_f64(result.n128_f64[0], v9);
    if (v23 < v24)
    {
      v23 = v24;
    }

    if (v23 < 1.0)
    {
      v23 = 1.0;
    }

    if (v25 > v23 * 2.22044605e-16)
    {
      goto LABEL_19;
    }
  }

  result.n128_u64[0] = a4[1];
  v9 = a3[1];
  if (result.n128_f64[0] == v9)
  {
    return result;
  }

  if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
LABEL_19:
    if (result.n128_f64[0] >= v9)
    {
      return result;
    }

    goto LABEL_20;
  }

  v11 = fabs(result.n128_f64[0]);
  v12 = fabs(v9);
  if (v11 < v12)
  {
    v11 = v12;
  }

  if (v11 < 1.0)
  {
    v11 = 1.0;
  }

  if (result.n128_f64[0] < v9)
  {
    result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v9);
    if (result.n128_f64[0] > v11 * 2.22044605e-16)
    {
LABEL_20:
      result = *a3;
      *a3 = *a4;
      *a4 = result;
      result.n128_f64[0] = *a3;
      v14 = *a2;
      if (*a3 != *a2)
      {
        if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v14 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_38;
        }

        v17 = fabs(result.n128_f64[0]);
        v18 = fabs(v14);
        v19 = vabdd_f64(result.n128_f64[0], v14);
        if (v17 < v18)
        {
          v17 = v18;
        }

        if (v17 < 1.0)
        {
          v17 = 1.0;
        }

        if (v19 > v17 * 2.22044605e-16)
        {
          goto LABEL_38;
        }
      }

      result.n128_f64[0] = a3[1];
      v14 = a2[1];
      if (result.n128_f64[0] == v14)
      {
        return result;
      }

      if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v14 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v15 = fabs(result.n128_f64[0]);
        v16 = fabs(v14);
        if (v15 < v16)
        {
          v15 = v16;
        }

        if (v15 < 1.0)
        {
          v15 = 1.0;
        }

        if (result.n128_f64[0] >= v14)
        {
          return result;
        }

        result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v14);
        if (result.n128_f64[0] <= v15 * 2.22044605e-16)
        {
          return result;
        }
      }

      else
      {
LABEL_38:
        if (result.n128_f64[0] >= v14)
        {
          return result;
        }
      }

      result = *a2;
      *a2 = *a3;
      *a3 = result;
      result.n128_f64[0] = *a2;
      v20 = *a1;
      if (*a2 != *a1)
      {
        if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v20 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_63;
        }

        v26 = fabs(result.n128_f64[0]);
        v27 = fabs(v20);
        v28 = vabdd_f64(result.n128_f64[0], v20);
        if (v26 < v27)
        {
          v26 = v27;
        }

        if (v26 < 1.0)
        {
          v26 = 1.0;
        }

        if (v28 > v26 * 2.22044605e-16)
        {
          goto LABEL_63;
        }
      }

      result.n128_f64[0] = a2[1];
      v20 = a1[1];
      if (result.n128_f64[0] == v20)
      {
        return result;
      }

      if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v20 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v21 = fabs(result.n128_f64[0]);
        v22 = fabs(v20);
        if (v21 < v22)
        {
          v21 = v22;
        }

        if (v21 < 1.0)
        {
          v21 = 1.0;
        }

        if (result.n128_f64[0] >= v20)
        {
          return result;
        }

        result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v20);
        if (result.n128_f64[0] <= v21 * 2.22044605e-16)
        {
          return result;
        }
      }

      else
      {
LABEL_63:
        if (result.n128_f64[0] >= v20)
        {
          return result;
        }
      }

      result = *a1;
      *a1 = *a2;
      *a2 = result;
    }
  }

  return result;
}

__n128 sub_10168A9BC(double *a1, double *a2, double *a3, uint64_t a4, unint64_t *a5)
{
  sub_10168A678(a1, a2, a3, a4);
  result.n128_u64[0] = *a5;
  v11 = *a4;
  if (*a5 != *a4)
  {
    if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_19;
    }

    v25 = fabs(result.n128_f64[0]);
    v26 = fabs(v11);
    v27 = vabdd_f64(result.n128_f64[0], v11);
    if (v25 < v26)
    {
      v25 = v26;
    }

    if (v25 < 1.0)
    {
      v25 = 1.0;
    }

    if (v27 > v25 * 2.22044605e-16)
    {
      goto LABEL_19;
    }
  }

  result.n128_u64[0] = a5[1];
  v11 = *(a4 + 8);
  if (result.n128_f64[0] == v11)
  {
    return result;
  }

  if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
LABEL_19:
    if (result.n128_f64[0] >= v11)
    {
      return result;
    }

    goto LABEL_20;
  }

  v13 = fabs(result.n128_f64[0]);
  v14 = fabs(v11);
  if (v13 < v14)
  {
    v13 = v14;
  }

  if (v13 < 1.0)
  {
    v13 = 1.0;
  }

  if (result.n128_f64[0] < v11)
  {
    result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v11);
    if (result.n128_f64[0] > v13 * 2.22044605e-16)
    {
LABEL_20:
      result = *a4;
      *a4 = *a5;
      *a5 = result;
      result.n128_u64[0] = *a4;
      v16 = *a3;
      if (*a4 != *a3)
      {
        if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v16 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_38;
        }

        v19 = fabs(result.n128_f64[0]);
        v20 = fabs(v16);
        v21 = vabdd_f64(result.n128_f64[0], v16);
        if (v19 < v20)
        {
          v19 = v20;
        }

        if (v19 < 1.0)
        {
          v19 = 1.0;
        }

        if (v21 > v19 * 2.22044605e-16)
        {
          goto LABEL_38;
        }
      }

      result.n128_u64[0] = *(a4 + 8);
      v16 = a3[1];
      if (result.n128_f64[0] == v16)
      {
        return result;
      }

      if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v16 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v17 = fabs(result.n128_f64[0]);
        v18 = fabs(v16);
        if (v17 < v18)
        {
          v17 = v18;
        }

        if (v17 < 1.0)
        {
          v17 = 1.0;
        }

        if (result.n128_f64[0] >= v16)
        {
          return result;
        }

        result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v16);
        if (result.n128_f64[0] <= v17 * 2.22044605e-16)
        {
          return result;
        }
      }

      else
      {
LABEL_38:
        if (result.n128_f64[0] >= v16)
        {
          return result;
        }
      }

      result = *a3;
      *a3 = *a4;
      *a4 = result;
      result.n128_f64[0] = *a3;
      v22 = *a2;
      if (*a3 != *a2)
      {
        if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v22 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_63;
        }

        v28 = fabs(result.n128_f64[0]);
        v29 = fabs(v22);
        v30 = vabdd_f64(result.n128_f64[0], v22);
        if (v28 < v29)
        {
          v28 = v29;
        }

        if (v28 < 1.0)
        {
          v28 = 1.0;
        }

        if (v30 > v28 * 2.22044605e-16)
        {
          goto LABEL_63;
        }
      }

      result.n128_f64[0] = a3[1];
      v22 = a2[1];
      if (result.n128_f64[0] == v22)
      {
        return result;
      }

      if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v22 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v23 = fabs(result.n128_f64[0]);
        v24 = fabs(v22);
        if (v23 < v24)
        {
          v23 = v24;
        }

        if (v23 < 1.0)
        {
          v23 = 1.0;
        }

        if (result.n128_f64[0] >= v22)
        {
          return result;
        }

        result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v22);
        if (result.n128_f64[0] <= v23 * 2.22044605e-16)
        {
          return result;
        }
      }

      else
      {
LABEL_63:
        if (result.n128_f64[0] >= v22)
        {
          return result;
        }
      }

      result = *a2;
      *a2 = *a3;
      *a3 = result;
      result.n128_f64[0] = *a2;
      v31 = *a1;
      if (*a2 != *a1)
      {
        if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v31 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_82;
        }

        v34 = fabs(result.n128_f64[0]);
        v35 = fabs(v31);
        v36 = vabdd_f64(result.n128_f64[0], v31);
        if (v34 < v35)
        {
          v34 = v35;
        }

        if (v34 < 1.0)
        {
          v34 = 1.0;
        }

        if (v36 > v34 * 2.22044605e-16)
        {
          goto LABEL_82;
        }
      }

      result.n128_f64[0] = a2[1];
      v31 = a1[1];
      if (result.n128_f64[0] == v31)
      {
        return result;
      }

      if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v31 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v32 = fabs(result.n128_f64[0]);
        v33 = fabs(v31);
        if (v32 < v33)
        {
          v32 = v33;
        }

        if (v32 < 1.0)
        {
          v32 = 1.0;
        }

        if (result.n128_f64[0] >= v31)
        {
          return result;
        }

        result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v31);
        if (result.n128_f64[0] <= v32 * 2.22044605e-16)
        {
          return result;
        }
      }

      else
      {
LABEL_82:
        if (result.n128_f64[0] >= v31)
        {
          return result;
        }
      }

      result = *a1;
      *a1 = *a2;
      *a2 = result;
    }
  }

  return result;
}

BOOL sub_10168AE00(double *a1, double *a2)
{
  v4 = (a2 - a1) >> 4;
  if (v4 > 2)
  {
    switch(v4)
    {
      case 3:
        sub_10168A160(a1, a1 + 2, a2 - 2);
        return 1;
      case 4:
        sub_10168A678(a1, a1 + 2, a1 + 4, a2 - 2);
        return 1;
      case 5:
        sub_10168A9BC(a1, a1 + 2, a1 + 4, (a1 + 6), a2 - 2);
        return 1;
    }

    goto LABEL_20;
  }

  if (v4 < 2)
  {
    return 1;
  }

  if (v4 != 2)
  {
LABEL_20:
    v11 = a1 + 4;
    sub_10168A160(a1, a1 + 2, a1 + 4);
    v12 = a1 + 6;
    if (a1 + 6 == a2)
    {
      return 1;
    }

    v13 = 0;
    v14 = 0;
    while (1)
    {
      v15 = *v12;
      v16 = *v11;
      if (*v12 == *v11)
      {
        goto LABEL_23;
      }

      if ((*&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v16 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_95;
      }

      v31 = fabs(v15);
      v32 = fabs(v16);
      v33 = vabdd_f64(v15, v16);
      if (v31 < v32)
      {
        v31 = v32;
      }

      if (v31 < 1.0)
      {
        v31 = 1.0;
      }

      if (v33 <= v31 * 2.22044605e-16)
      {
LABEL_23:
        v17 = v12[1];
        v18 = v11[1];
        if (v17 == v18)
        {
          goto LABEL_71;
        }

        v19 = fabs(v17);
        if ((*&v17 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v18 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v34 = fabs(v18);
          if (v19 >= v34)
          {
            v34 = v19;
          }

          if (v34 < 1.0)
          {
            v34 = 1.0;
          }

          if (v17 >= v18 || vabdd_f64(v17, v18) <= v34 * 2.22044605e-16)
          {
            goto LABEL_71;
          }
        }

        else if (v17 >= v18)
        {
          goto LABEL_71;
        }
      }

      else
      {
LABEL_95:
        if (v15 >= v16)
        {
          goto LABEL_71;
        }

        v17 = v12[1];
        v19 = fabs(v17);
      }

      *v12 = *v11;
      v22 = fabs(v15);
      v23 = v13;
      while (1)
      {
        v24 = *(a1 + v23 + 16);
        if (v15 == v24)
        {
          break;
        }

        if ((*&v15 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v24 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v26 = fabs(v24);
          v27 = vabdd_f64(v15, v24);
          if (v22 >= v26)
          {
            v26 = v22;
          }

          if (v26 < 1.0)
          {
            v26 = 1.0;
          }

          if (v27 <= v26 * 2.22044605e-16)
          {
            break;
          }
        }

        if (v15 >= v24)
        {
          goto LABEL_70;
        }

LABEL_61:
        v11 -= 2;
        *(a1 + v23 + 32) = *(a1 + v23 + 16);
        v23 -= 16;
        if (v23 == -32)
        {
          v11 = a1;
          goto LABEL_70;
        }
      }

      v25 = *(a1 + v23 + 24);
      if (v17 != v25)
      {
        break;
      }

      v11 = (a1 + v23 + 32);
LABEL_70:
      *v11 = v15;
      v11[1] = v17;
      if (++v14 == 8)
      {
        return v12 + 2 == a2;
      }

LABEL_71:
      v11 = v12;
      v13 += 16;
      v12 += 2;
      if (v12 == a2)
      {
        return 1;
      }
    }

    if (v19 == INFINITY || (*&v25 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      if (v17 >= v25)
      {
        goto LABEL_70;
      }
    }

    else
    {
      v28 = fabs(v25);
      v29 = vabdd_f64(v17, v25);
      if (v19 >= v28)
      {
        v28 = v19;
      }

      if (v28 < 1.0)
      {
        v28 = 1.0;
      }

      if (v29 <= v28 * 2.22044605e-16 || v17 >= v25)
      {
        goto LABEL_70;
      }
    }

    goto LABEL_61;
  }

  v5 = a2 - 2;
  v6 = *(a2 - 2);
  v7 = *a1;
  if (v6 != *a1)
  {
    if ((*&v6 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v7 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_88;
    }

    v35 = fabs(v6);
    v36 = fabs(v7);
    v37 = vabdd_f64(v6, v7);
    if (v35 < v36)
    {
      v35 = v36;
    }

    if (v35 < 1.0)
    {
      v35 = 1.0;
    }

    if (v37 > v35 * 2.22044605e-16)
    {
      goto LABEL_88;
    }
  }

  v6 = *(a2 - 1);
  v7 = a1[1];
  if (v6 == v7)
  {
    return 1;
  }

  if ((*&v6 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v7 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
LABEL_88:
    if (v6 >= v7)
    {
      return 1;
    }

    goto LABEL_89;
  }

  v8 = fabs(v6);
  v9 = fabs(v7);
  if (v8 < v9)
  {
    v8 = v9;
  }

  if (v8 < 1.0)
  {
    v8 = 1.0;
  }

  result = 1;
  if (v6 < v7 && vabdd_f64(v6, v7) > v8 * 2.22044605e-16)
  {
LABEL_89:
    v38 = *a1;
    *a1 = *v5;
    *v5 = v38;
    return 1;
  }

  return result;
}

void sub_10168B230(void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 48;
        sub_101687F08(v4);
      }

      while (v4 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

uint64_t sub_10168B2B4(void *a1, void *a2, void *a3, uint64_t a4, void *a5, uint64_t a6)
{
  if (*a1 == a1[1])
  {
    v12 = a1[3];
    v13 = a1[4];
    if (v12 == v13)
    {
      v11 = 1;
    }

    else
    {
      do
      {
        v14 = *v12;
        v15 = v12[1];
        v12 += 3;
        v11 = v14 == v15;
        _ZF = !v11 || v12 == v13;
      }

      while (!_ZF);
    }
  }

  else
  {
    v11 = 0;
  }

  if (*a2 == a2[1])
  {
    for (i = a2[3]; i != a2[4]; i += 3)
    {
      if (*i != i[1])
      {
        goto LABEL_12;
      }
    }

    return a4;
  }

LABEL_12:
  if (v11)
  {
    return a4;
  }

  v723 = 0u;
  v724 = 0u;
  v722 = 0u;
  v721 = 0;
  v728 = 0;
  v729 = 0;
  v730 = 0;
  v725 = 0;
  v726 = 0;
  v727 = 0;
  sub_101690224(a1, &v728, 0);
  sub_101690224(a2, &v725, 1u);
  v749[0] = 0;
  v713 = a2;
  v714 = a1;
  v749[1] = a1;
  v749[2] = 1;
  v749[3] = a2;
  v749[4] = a5;
  v749[5] = a3;
  *&v750 = &v722;
  *(&v750 + 1) = &v721;
  v18 = v728;
  v17 = v729;
  v19 = v725;
  if (0xEEEEEEEEEEEEEEEFLL * ((v729 - v728) >> 3) < 0x11 || (v20 = v726, 0xEEEEEEEEEEEEEEEFLL * ((v726 - v725) >> 3) < 0x11))
  {
    if (v728 != v729)
    {
      v24 = v726;
      v25 = v728;
      do
      {
        if (v19 != v24)
        {
          v26 = v19;
          do
          {
            sub_101692FE0(v749, v25->f64, v26);
            v26 += 15;
          }

          while (v26 != v24);
        }

        v25 = (v25 + 120);
      }

      while (v25 != v17);
    }
  }

  else
  {
    v718[0] = 0;
    v718[1] = 0;
    *&v719 = 0;
    v746 = 0;
    __p = 0;
    v747 = 0;
    v731 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    v732 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    v715 = v728;
    if (v728 != v729)
    {
      v21 = v728;
      do
      {
        sub_1016932F4(&v731, v21 + 2);
        sub_1016931F4(v718, &v715);
        v21 = (v21 + 120);
        v715 = v21;
      }

      while (v21 != v17);
    }

    v715 = v19;
    if (v19 != v20)
    {
      v22 = v19;
      do
      {
        sub_1016932F4(&v731, v22 + 2);
        sub_1016931F4(&__p, &v715);
        v22 = (v22 + 120);
        v715 = v22;
      }

      while (v22 != v20);
    }

    sub_1016929C4(v731.f64, v718, &__p, 0, v749);
    if (__p)
    {
      operator delete(__p);
    }

    if (v718[0])
    {
      operator delete(v718[0]);
    }
  }

  if (v19)
  {
    operator delete(v19);
  }

  if (v18)
  {
    operator delete(v18);
  }

  if (*(&v724 + 1))
  {
    if (v714[4] != v714[3])
    {
      v731 = 0uLL;
      v732.i64[0] = 0;
      sub_101690224(v714, &v731, 0);
      v749[0] = v714;
      v749[1] = a5;
      v749[2] = a3;
      v749[3] = &v722;
      v749[5] = 0;
      v749[4] = &v721;
      sub_10169A73C(&v731, v749);
      if (*&v731.f64[0])
      {
        operator delete(*&v731.f64[0]);
      }
    }

    if (v713[4] != v713[3])
    {
      v731 = 0uLL;
      v732.i64[0] = 0;
      sub_101690224(v713, &v731, 0);
      v749[0] = v713;
      v749[1] = a5;
      v749[2] = a3;
      v749[3] = &v722;
      v749[5] = 1;
      v749[4] = &v721;
      sub_10169A73C(&v731, v749);
      if (*&v731.f64[0])
      {
        operator delete(*&v731.f64[0]);
      }
    }
  }

  v686 = a4;
  v729 = 0;
  v730 = 0;
  v727 = 0;
  v728 = &v729;
  v725 = &v726;
  v726 = 0;
  v749[2] = 0;
  v749[1] = 0;
  v749[0] = &v749[1];
  v27 = *(&v722 + 1);
  v28 = v723;
  if (v723 != *(&v722 + 1))
  {
    v29 = v724;
    v30 = v724 >> 4;
    v31 = (*(&v722 + 1) + 8 * (v724 >> 4));
    v32 = *v31;
    v33 = *v31 + 376 * (v724 & 0xF);
    v34 = *(*(&v722 + 1) + (((*(&v724 + 1) + v724) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((DWORD2(v724) + v724) & 0xF);
    if (v33 != v34)
    {
      v35 = 0;
      do
      {
        if (*(v33 + 16) == 7)
        {
          operator new();
        }

        v33 += 376;
        if (v33 - v32 == 6016)
        {
          v36 = v31[1];
          ++v31;
          v32 = v36;
          v33 = v36;
        }

        ++v35;
      }

      while (v33 != v34);
      v29 = v724;
      v27 = *(&v722 + 1);
      v28 = v723;
      v30 = v724 >> 4;
    }

    if (v28 != v27)
    {
      v37 = (v27 + 8 * v30);
      v38 = *v37;
      v39 = *v37 + 376 * (v29 & 0xF);
      v40 = *(v27 + (((*(&v724 + 1) + v29) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((DWORD2(v724) + v29) & 0xF);
      if (v39 != v40)
      {
        v690 = v40;
        do
        {
          v41 = *(v39 + 16);
          if (v41 != 2 && v41 != 7)
          {
              ;
            }

            v38 = *v37;
            v40 = v690;
          }

          v39 += 376;
          if (v39 - v38 == 6016)
          {
            v43 = v37[1];
            ++v37;
            v38 = v43;
            v39 = v43;
          }
        }

        while (v39 != v40);
      }
    }
  }

  sub_10169BFC4(v749[1]);
  if (v723 == *(&v722 + 1) || (v45 = (*(&v722 + 1) + 8 * (v724 >> 4)), v46 = *v45 + 376 * (v724 & 0xF), v47 = *(*(&v722 + 1) + (((*(&v724 + 1) + v724) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((DWORD2(v724) + v724) & 0xF), v46 == v47))
  {
    __src = 0;
    v702 = 0;
    v48 = 0;
  }

  else
  {
    __src = 0;
    v702 = 0;
    v48 = 0;
    v49 = 0;
    do
    {
      if ((*(v46 + 32) & 1) == 0)
      {
        v51 = *v46;
        v50 = *(v46 + 8);
        v52 = 0xAAAAAAAAAAAAAAABLL * ((v48 - __src) >> 3);
        v53 = v52 + 1;
        if (v52 + 1 > 0xAAAAAAAAAAAAAAALL)
        {
          sub_1000CE3D4();
        }

        if (0x5555555555555556 * (-__src >> 3) > v53)
        {
          v53 = 0x5555555555555556 * (-__src >> 3);
        }

        if (0xAAAAAAAAAAAAAAABLL * (-__src >> 3) >= 0x555555555555555)
        {
          v54 = 0xAAAAAAAAAAAAAAALL;
        }

        else
        {
          v54 = v53;
        }

        if (v54)
        {
          if (v54 <= 0xAAAAAAAAAAAAAAALL)
          {
            operator new();
          }

          sub_100013D10();
        }

        v55 = (8 * ((v48 - __src) >> 3));
        *v55 = v49;
        v55[1] = v51;
        v55[2] = v50;
        v48 = (v55 + 3);
        v56 = 24 * v52 + 24 * ((v702 - __src) / -24);
        memcpy(&v55[3 * ((v702 - __src) / -24)], __src, v702 - __src);
        if (__src)
        {
          operator delete(__src);
        }

        __src = v56;
        v702 = v48;
      }

      v46 += 376;
      if (v46 - *v45 == 6016)
      {
        v57 = v45[1];
        ++v45;
        v46 = v57;
      }

      ++v49;
    }

    while (v46 != v47);
  }

  v58 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((v48 - __src) >> 3));
  if (v48 == __src)
  {
    v59 = 0;
  }

  else
  {
    v59 = v58;
  }

  sub_10169C020(__src, v48, v59, 1, v44);
  v718[0] = 0;
  v718[1] = 0;
  *&v719 = 0;
  v60 = v702;
  if (__src != v702)
  {
    v61 = &v731.f64[1];
    v62 = __src;
    do
    {
      v704 = (v62 + 24);
      if (v60 != (v62 + 24))
      {
        v63 = (v62 + 24);
        do
        {
          v64 = *(v62 + 16);
          v65 = v63[2];
          if (v64 - v65 > 0.001)
          {
            break;
          }

          v66 = *(v62 + 8);
          v67 = v63[1];
          v68 = fabs(v66);
          v69 = fabs(v67);
          v70 = fabs(v64);
          v71 = fabs(v65);
          if (v68 >= v69)
          {
            v69 = v68;
          }

          if (v69 < v70)
          {
            v69 = v70;
          }

          if (v69 < v71)
          {
            v69 = v71;
          }

          if (v69 < 1.0)
          {
            v69 = 1.0;
          }

          v72 = v69 * 1000.0;
          if (v66 != v67)
          {
            v87 = (*&v66 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v67 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000;
            if (v87 || vabdd_f64(v66, v67) > v72 * 2.22044605e-16)
            {
              continue;
            }
          }

          if (v64 == v65 || (*&v64 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v65 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000 && fabs(v64 - v65) <= v72 * 2.22044605e-16)
          {
            v74 = v718[0];
            v73 = v718[1];
            if (v718[0] == v718[1])
            {
LABEL_127:
              *v61 = 0.0;
              v61[1] = 0.0;
              *&v731.f64[0] = v61;
              v732.i64[1] = 0;
              sub_10169D6F8(v749, &v731);
              v82 = v732.i64[1];
              v749[3] = v732.i64[1];
              *&v749[4] = *(v62 + 8);
              v83 = v718[1];
              if (v718[1] >= v719)
              {
                v88 = v61;
                v89 = 0xAAAAAAAAAAAAAAABLL * ((v718[1] - v718[0]) >> 4);
                v90 = v89 + 1;
                if (v89 + 1 > 0x555555555555555)
                {
                  sub_1000CE3D4();
                }

                if (0x5555555555555556 * ((v719 - v718[0]) >> 4) > v90)
                {
                  v90 = 0x5555555555555556 * ((v719 - v718[0]) >> 4);
                }

                if (0xAAAAAAAAAAAAAAABLL * ((v719 - v718[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL)
                {
                  v91 = 0x555555555555555;
                }

                else
                {
                  v91 = v90;
                }

                if (v91)
                {
                  if (v91 <= 0x555555555555555)
                  {
                    operator new();
                  }

                  sub_100013D10();
                }

                v93 = (16 * ((v718[1] - v718[0]) >> 4));
                v94 = v749[1];
                *v93 = v749[0];
                *(48 * v89 + 8) = v94;
                v95 = 48 * v89 + 8;
                v96 = v749[2];
                v93[2] = v749[2];
                if (v96)
                {
                  v94[2] = v95;
                  v749[0] = &v749[1];
                  v749[1] = 0;
                  v749[2] = 0;
                }

                else
                {
                  *v93 = v95;
                }

                v97 = v718[0];
                v98 = v718[1];
                v99 = v93 - (v718[1] - v718[0]);
                *(48 * v89 + 0x18) = v749[3];
                *(48 * v89 + 0x20) = *&v749[4];
                if (v98 == v97)
                {
                  v61 = v88;
                }

                else
                {
                  v100 = 0;
                  v101 = -16 * ((v98 - v97) >> 4) + 48 * v89;
                  do
                  {
                    v102 = (v101 + v100);
                    *v102 = *&v97[v100];
                    v103 = &v99[v100 + 8];
                    v104 = &v97[v100 + 8];
                    v105 = *v104;
                    v102[1] = *v104;
                    v106 = *&v97[v100 + 16];
                    v102[2] = v106;
                    if (v106)
                    {
                      *(v105 + 16) = v103;
                      *&v97[v100] = v104;
                      *v104 = 0;
                      *&v97[v100 + 16] = 0;
                    }

                    else
                    {
                      *v102 = v103;
                    }

                    v107 = v101 + v100;
                    *(v107 + 24) = *&v97[v100 + 24];
                    *(v107 + 32) = *&v97[v100 + 32];
                    v100 += 48;
                  }

                  while (&v97[v100] != v98);
                  do
                  {
                    sub_100034450(*(v97 + 1));
                    v97 += 48;
                  }

                  while (v97 != v98);
                  v97 = v718[0];
                  v61 = v88;
                }

                v92 = v93 + 6;
                v718[0] = v99;
                v718[1] = v93 + 6;
                *&v719 = 0;
                if (v97)
                {
                  operator delete(v97);
                }

                v60 = v702;
              }

              else
              {
                *v718[1] = v749[0];
                v84 = v749[1];
                v83[1] = v749[1];
                v85 = (v83 + 1);
                v86 = v749[2];
                v83[2] = v749[2];
                if (v86)
                {
                  v84[2] = v85;
                  v749[0] = &v749[1];
                  v749[1] = 0;
                  v749[2] = 0;
                }

                else
                {
                  *v83 = v85;
                }

                v83[3] = v82;
                *(v83 + 2) = *&v749[4];
                v92 = v83 + 6;
              }

              v75 = 0xAAAAAAAAAAAAAAABLL * ((v73 - v74) >> 4);
              v718[1] = v92;
              sub_100034450(v749[1]);
              sub_100034450(*&v731.f64[1]);
              v74 = v718[0];
            }

            else
            {
              v75 = 0;
              v76 = v718[0];
              while (1)
              {
                v78 = v76[4];
                v77 = v76[5];
                v79 = fabs(v78);
                v80 = fabs(v77);
                if (v79 < v68)
                {
                  v79 = v68;
                }

                if (v79 < v80)
                {
                  v79 = v80;
                }

                if (v79 < v70)
                {
                  v79 = v70;
                }

                if (v79 < 1.0)
                {
                  v79 = 1.0;
                }

                v81 = v79 * 1000.0;
                if ((v78 == v66 || (*&v66 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v78 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000 && vabdd_f64(v78, v66) <= v81 * 2.22044605e-16) && (v77 == v64 || (*&v64 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v77 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000 && vabdd_f64(v77, v64) <= v81 * 2.22044605e-16))
                {
                  break;
                }

                ++v75;
                v76 += 6;
                if (v76 == v718[1])
                {
                  goto LABEL_127;
                }
              }
            }

            v749[0] = *v62;
            sub_10169D880(&v74[48 * v75], v749[0]);
            v749[0] = *v63;
            sub_10169D880(v718[0] + 48 * v75, v749[0]);
          }

          v63 += 3;
        }

        while (v63 != v60);
      }

      v62 += 24;
    }

    while (v704 != v60);
    v108 = v718[0];
    v109 = v718[1];
    if (v718[0] != v718[1])
    {
      k = 1;
      v705 = v718[1];
      do
      {
        v111 = v729;
LABEL_173:
        if (!v111)
        {
LABEL_179:
          operator new();
        }

        while (1)
        {
          v112 = v111;
          v113 = *(v111 + 4);
          if (v113 > k)
          {
            v111 = *v112;
            goto LABEL_173;
          }

          if (v113 >= k)
          {
            break;
          }

          v111 = *(v112 + 1);
          if (!v111)
          {
            goto LABEL_179;
          }
        }

        v114 = v112;
        v115 = (v112 + 40);
        if (v112 + 40 == v108)
        {
          goto LABEL_215;
        }

        v116 = v108 + 8;
        v117 = *v108;
        if (*(v112 + 7))
        {
          v708 = k;
          v119 = (v112 + 48);
          v118 = *(v112 + 6);
          v120 = *(v112 + 5);
          *(v112 + 5) = v112 + 48;
          *(v118 + 16) = 0;
          *(v112 + 6) = 0;
          *(v112 + 7) = 0;
          if (*(v120 + 8))
          {
            v121 = *(v120 + 8);
          }

          else
          {
            v121 = v120;
          }

          if (v121)
          {
            v122 = sub_1000685CC(v121);
            if (v117 == v116)
            {
              v123 = v121;
              v129 = v117;
            }

            else
            {
              do
              {
                v123 = v122;
                v124 = v117[4];
                v121[4] = v124;
                v125 = *v119;
                v126 = (v114 + 48);
                v127 = (v114 + 48);
                if (*v119)
                {
                  do
                  {
                    while (1)
                    {
                      v126 = v125;
                      if (v124 >= v125[4])
                      {
                        break;
                      }

                      v125 = *v125;
                      v127 = v126;
                      if (!*v126)
                      {
                        goto LABEL_193;
                      }
                    }

                    v125 = v125[1];
                  }

                  while (v125);
                  v127 = v126 + 1;
                }

LABEL_193:
                sub_1000070DC(v115, v126, v127, v121);
                if (v122)
                {
                  v122 = sub_1000685CC(v122);
                }

                else
                {
                  v122 = 0;
                }

                v128 = v117[1];
                if (v128)
                {
                  do
                  {
                    v129 = v128;
                    v128 = *v128;
                  }

                  while (v128);
                }

                else
                {
                  do
                  {
                    v129 = v117[2];
                    _ZF = *v129 == v117;
                    v117 = v129;
                  }

                  while (!_ZF);
                }

                if (!v123)
                {
                  break;
                }

                v121 = v123;
                v117 = v129;
              }

              while (v129 != v116);
            }

            sub_100034450(v123);
            if (v122)
            {
              v130 = v122[2];
              v109 = v705;
              for (k = v708; v130; v130 = v130[2])
              {
                v122 = v130;
              }

              sub_100034450(v122);
              goto LABEL_213;
            }

            v109 = v705;
          }

          else
          {
            v129 = v117;
          }

          k = v708;
        }

        else
        {
          v129 = *v108;
        }

LABEL_213:
        if (v129 != v116)
        {
          operator new();
        }

LABEL_215:
        ++k;
        *(v114 + 8) = *(v108 + 3);
        v108 += 48;
      }

      while (v108 != v109);
    }
  }

  v749[0] = v718;
  sub_10169D940(v749);
  if (__src)
  {
    operator delete(__src);
  }

  v131 = v713;
  __srca = v730;
  if (v730)
  {
    v132 = v724;
    v133 = *(&v722 + 1);
    if (v723 != *(&v722 + 1))
    {
      v134 = (*(&v722 + 1) + 8 * (v724 >> 4));
      v135 = *v134;
      v136 = *v134 + 376 * (v724 & 0xF);
      v137 = *(*(&v722 + 1) + (((*(&v724 + 1) + v724) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((DWORD2(v724) + v724) & 0xF);
      while (v136 != v137)
      {
        *(v136 + 24) = -1;
        v136 += 376;
        if (v136 - v135 == 6016)
        {
          v138 = v134[1];
          ++v134;
          v135 = v138;
          v136 = v138;
        }
      }
    }

    v139 = v728;
    if (v728 != &v729)
    {
      v140 = v728;
      do
      {
        v141 = v140[2].f64[1];
        if (*&v141 != &v140[3])
        {
          v142 = v140[2].f64[0];
          do
          {
            *(*(v133 + (((*(*&v141 + 32) + v132) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(*&v141 + 32) + v132) & 0xF) + 24) = v142;
            v143 = *(*&v141 + 8);
            if (*&v143 == 0.0)
            {
              do
              {
                v144 = *(*&v141 + 16);
                _ZF = *&v144->f64[0] == *&v141;
                v141 = *&v144;
              }

              while (!_ZF);
            }

            else
            {
              do
              {
                v144 = v143;
                v143 = *&v143->f64[0];
              }

              while (*&v143 != 0.0);
            }

            v141 = *&v144;
          }

          while (v144 != &v140[3]);
        }

        v145 = *&v140->f64[1];
        if (v145)
        {
          do
          {
            v146 = v145;
            v145 = *v145;
          }

          while (v145);
        }

        else
        {
          do
          {
            v146 = *&v140[1].f64[0];
            _ZF = *v146 == v140;
            v140 = v146;
          }

          while (!_ZF);
        }

        v140 = v146;
      }

      while (v146 != &v729);
      v147 = v724;
      v148 = *(&v722 + 1);
      v149 = v139;
      do
      {
        v150 = v149[5];
        v151 = v149 + 6;
        if (v150 != v149 + 6)
        {
          v152 = v149[5];
          while (1)
          {
            v153 = *(v148 + (((v152[4] + v147) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v152 + 8) + v147) & 0xF);
            if (*(v153 + 40) == 2 && *(v153 + 208) == 2)
            {
              break;
            }

            v154 = v152[1];
            if (v154)
            {
              do
              {
                v155 = v154;
                v154 = *v154;
              }

              while (v154);
            }

            else
            {
              do
              {
                v155 = v152[2];
                _ZF = *v155 == v152;
                v152 = v155;
              }

              while (!_ZF);
            }

            v152 = v155;
            if (v155 == v151)
            {
              goto LABEL_258;
            }
          }

          do
          {
            *(*(v148 + (((v150[4] + v147) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v150 + 8) + v147) & 0xF) + 33) = 1;
            v156 = v150[1];
            if (v156)
            {
              do
              {
                v157 = v156;
                v156 = *v156;
              }

              while (v156);
            }

            else
            {
              do
              {
                v157 = v150[2];
                _ZF = *v157 == v150;
                v150 = v157;
              }

              while (!_ZF);
            }

            v150 = v157;
          }

          while (v157 != v151);
        }

LABEL_258:
        v158 = v149[1];
        if (v158)
        {
          do
          {
            v159 = v158;
            v158 = *v158;
          }

          while (v158);
        }

        else
        {
          do
          {
            v159 = v149[2];
            _ZF = *v159 == v149;
            v149 = v159;
          }

          while (!_ZF);
        }

        v149 = v159;
      }

      while (v159 != &v729);
      v749[2] = 0;
      v749[1] = 0;
      v749[0] = &v749[1];
LABEL_265:
      sub_100034450(v749[1]);
      v160 = &v139[2].f64[1];
      v161 = v139[2].f64[1];
      v749[2] = 0;
      v749[0] = &v749[1];
      v749[1] = 0;
      v162 = v139 + 3;
      if (*&v161 == &v139[3])
      {
        goto LABEL_313;
      }

      while (1)
      {
        v163 = *(*(&v722 + 1) + (((v724 + *(*&v161 + 32)) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((v724 + *(*&v161 + 32)) & 0xF);
        v164 = *(v163 + 40);
        if (v164 == 3)
        {
          if (*(v163 + 208) == 1)
          {
            goto LABEL_271;
          }
        }

        else if (v164 == 1 && (*(v163 + 208) | 2) == 3)
        {
LABEL_271:
          v165 = *v160;
          if (*v160 != v162)
          {
            do
            {
              v166 = *&v165[2].f64[0];
              if (*(*&v161 + 32) != v166)
              {
                v167 = *(v163 + 48);
                v168 = *(v163 + 216);
                if (v167 != v168)
                {
                  v169 = *(*(&v722 + 1) + (((v724 + v166) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((v724 + v166) & 0xF);
                  v170 = *(v163 + 56) == *(v169 + 56) && *(v163 + 224) == *(v169 + 224);
                  if (v170 && (*(v163 + 64) & 0x8000000000000000) != 0 && (*(v169 + 64) & 0x8000000000000000) == 0 && *(v163 + 232) == *(v169 + 232))
                  {
                    v731.f64[0] = v165[2].f64[0];
                    *(v169 + 32) = 1;
                    *(v169 + 24) = -1;
                    sub_10169D880(v749, v166);
                    v168 = *(v163 + 216);
                    v167 = *(v163 + 48);
                  }

                  if (v168 != v167)
                  {
                    v173 = *(v163 + 224) == *(v169 + 224) && *(v163 + 56) == *(v169 + 56);
                    if (v173 && (*(v163 + 232) & 0x8000000000000000) != 0 && (*(v169 + 232) & 0x8000000000000000) == 0 && *(v163 + 64) == *(v169 + 64))
                    {
                      v731.f64[0] = v165[2].f64[0];
                      v174 = *&v731.f64[0];
                      *(v169 + 32) = 1;
                      *(v169 + 24) = -1;
                      sub_10169D880(v749, v174);
                    }
                  }
                }
              }

              v171 = v165->f64[1];
              if (v171 == 0.0)
              {
                do
                {
                  v172 = *&v165[1].f64[0];
                  _ZF = *&v172->f64[0] == v165;
                  v165 = v172;
                }

                while (!_ZF);
              }

              else
              {
                do
                {
                  v172 = *&v171;
                  v171 = **&v171;
                }

                while (v171 != 0.0);
              }

              v165 = v172;
            }

            while (v172 != v162);
          }
        }

        v175 = *(*&v161 + 8);
        if (*&v175 == 0.0)
        {
          do
          {
            v176 = *(*&v161 + 16);
            _ZF = *v176 == *&v161;
            v161 = *&v176;
          }

          while (!_ZF);
        }

        else
        {
          do
          {
            v176 = v175;
            v175 = *v175;
          }

          while (*&v175 != 0.0);
        }

        v161 = *&v176;
        if (v176 == v162)
        {
          v177 = v749[0];
          if (v749[0] != &v749[1])
          {
            do
            {
              sub_10169D9C8(&v139[2].f64[1], v177[4]);
              v178 = v177[1];
              if (v178)
              {
                do
                {
                  v179 = v178;
                  v178 = *v178;
                }

                while (v178);
              }

              else
              {
                do
                {
                  v179 = v177[2];
                  _ZF = *v179 == v177;
                  v177 = v179;
                }

                while (!_ZF);
              }

              v177 = v179;
            }

            while (v179 != &v749[1]);
          }

LABEL_313:
          v180 = *&v139->f64[1];
          if (v180)
          {
            do
            {
              v181 = v180;
              v180 = *v180;
            }

            while (v180);
          }

          else
          {
            do
            {
              v181 = *&v139[1].f64[0];
              _ZF = *v181 == v139;
              v139 = v181;
            }

            while (!_ZF);
          }

          v139 = v181;
          if (v181 == &v729)
          {
            v182 = v749[1];
            v131 = v713;
            goto LABEL_321;
          }

          goto LABEL_265;
        }
      }
    }

    v182 = 0;
    v749[2] = 0;
    v749[1] = 0;
    v749[0] = &v749[1];
LABEL_321:
    sub_100034450(v182);
  }

  v183 = v724;
  v184 = *(&v722 + 1);
  v185 = v723;
  v186 = (*(&v722 + 1) + 8 * (v724 >> 4));
  if (v723 == *(&v722 + 1))
  {
    v187 = 0;
  }

  else
  {
    v187 = *v186 + 376 * (v724 & 0xF);
  }

  v188 = 0;
LABEL_326:
  v189 = v187 - 6016;
  while (1)
  {
    v190 = v185 == v184 ? 0 : *(v184 + (((*(&v724 + 1) + v183) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((DWORD2(v724) + v183) & 0xF);
    if (v187 == v190)
    {
      break;
    }

    v191 = *(v187 + 40);
    if (v191 == 3)
    {
      if (*(v187 + 208) == 3)
      {
        goto LABEL_346;
      }
    }

    else if (v191 == 1)
    {
      if (*(v187 + 208) == 1)
      {
        goto LABEL_346;
      }
    }

    else if (!v191 && !*(v187 + 208))
    {
      goto LABEL_346;
    }

    if (*(v187 + 48) != *(v187 + 216) || *(v187 + 24) > 0)
    {
      if (v191 == 4 && (*(v187 + 32) & 1) == 0)
      {
        v188 |= *(v187 + 208) == 4;
      }

      goto LABEL_347;
    }

    if (v191 != 2 || *(v187 + 208) != 2)
    {
LABEL_346:
      *(v187 + 32) = 1;
      *(v187 + 24) = -1;
    }

LABEL_347:
    v189 += 376;
    v187 += 376;
    if (*v186 == v189)
    {
      v192 = v186[1];
      ++v186;
      v187 = v192;
      goto LABEL_326;
    }
  }

  v691 = v188;
  v193 = v728;
  if (v728 != &v729)
  {
    do
    {
      v194 = v729;
      if (*&v193[3].f64[1])
      {
        v195 = v729 == 0;
      }

      else
      {
        v195 = 1;
      }

      if (!v195)
      {
        v196 = *&v193[2].f64[0];
        v197 = &v729;
        do
        {
          if (*(v194 + 4) >= v196)
          {
            v197 = v194;
          }

          v194 = *&v194[8 * (*(v194 + 4) < v196)];
        }

        while (v194);
        if (v197 != &v729 && v197[4] <= v196)
        {
          v198 = v197[5];
          if (v198 == v197 + 6)
          {
LABEL_368:
            v202 = *(*&v193[2].f64[1] + 32) + v724;
            v203 = *(*(&v722 + 1) + ((v202 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * (v202 & 0xF);
            if (*(v203 + 48))
            {
              v204 = v714;
            }

            else
            {
              v204 = v131;
            }

            if (sub_10169DA48(v203, v204) <= 0)
            {
              v205 = v193[2].f64[1];
              if (*&v205 != &v193[3])
              {
                v206 = v724;
                v207 = *(&v722 + 1);
                do
                {
                  *(*(v207 + (((*(*&v205 + 32) + v206) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(*&v205 + 32) + v206) & 0xF) + 32) = 1;
                  v208 = *(*&v205 + 8);
                  if (*&v208 == 0.0)
                  {
                    do
                    {
                      v209 = *(*&v205 + 16);
                      _ZF = *&v209->f64[0] == *&v205;
                      v205 = *&v209;
                    }

                    while (!_ZF);
                  }

                  else
                  {
                    do
                    {
                      v209 = v208;
                      v208 = *&v208->f64[0];
                    }

                    while (*&v208 != 0.0);
                  }

                  v205 = *&v209;
                }

                while (v209 != &v193[3]);
              }
            }
          }

          else
          {
            while (1)
            {
              v199 = *(*(&v722 + 1) + ((&v198[4][v724] >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v198 + 8) + v724) & 0xF);
              if (*(v199 + 48) != *(v199 + 216))
              {
                break;
              }

              v200 = v198[1];
              if (v200)
              {
                do
                {
                  v201 = v200;
                  v200 = *v200;
                }

                while (v200);
              }

              else
              {
                do
                {
                  v201 = v198[2];
                  _ZF = *v201 == v198;
                  v198 = v201;
                }

                while (!_ZF);
              }

              v198 = v201;
              if (v201 == v197 + 6)
              {
                goto LABEL_368;
              }
            }
          }
        }
      }

      v210 = *&v193->f64[1];
      if (v210)
      {
        do
        {
          v211 = v210;
          v210 = *v210;
        }

        while (v210);
      }

      else
      {
        do
        {
          v211 = *&v193[1].f64[0];
          _ZF = *v211 == v193;
          v193 = v211;
        }

        while (!_ZF);
      }

      v193 = v211;
    }

    while (v211 != &v729);
    v184 = *(&v722 + 1);
    v185 = v723;
  }

  v212 = (v184 + 8 * (v724 >> 4));
  if (v185 == v184)
  {
    v213 = 0;
  }

  else
  {
    v213 = *v212 + 376 * (v724 & 0xF);
  }

  while (2)
  {
    if (v185 != v184)
    {
      if (v213 == *(v184 + (((*(&v724 + 1) + v724) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((DWORD2(v724) + v724) & 0xF))
      {
        v731.f64[1] = 0.0;
        v732.i64[0] = 0;
        *&v731.f64[0] = &v731.f64[1];
        v698 = (v184 + 8 * (v724 >> 4));
        v217 = *v698 + 376 * (v724 & 0xF);
        goto LABEL_405;
      }

      goto LABEL_394;
    }

    if (v213)
    {
LABEL_394:
      if ((*(v213 + 32) & 1) == 0)
      {
        v214 = *(v213 + 48);
        if (v214 == *(v213 + 216))
        {
          v215 = (v214 ? v714 : v131);
          if (sub_10169DA48(v213, v215) <= 0)
          {
            *(v213 + 144) = 0;
            *(v213 + 312) = 0;
          }
        }
      }

      v213 += 376;
      if (v213 - *v212 == 6016)
      {
        v216 = v212[1];
        ++v212;
        v213 = v216;
      }

      v184 = *(&v722 + 1);
      v185 = v723;
      continue;
    }

    break;
  }

  v217 = 0;
  v731.f64[1] = 0.0;
  v732.i64[0] = 0;
  *&v731.f64[0] = &v731.f64[1];
  v698 = (v184 + 8 * (v724 >> 4));
LABEL_405:
  v709 = 0;
  while (1)
  {
    v218 = v185 == v184 ? 0 : *(v184 + (((*(&v724 + 1) + v724) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((DWORD2(v724) + v724) & 0xF);
    if (v217 == v218)
    {
      break;
    }

    if ((*(v217 + 32) & 1) == 0)
    {
      operator new();
    }

    v217 += 376;
    if (v217 - *v698 == 6016)
    {
      v217 = v698[1];
      ++v698;
    }

    ++v709;
    v184 = *(&v722 + 1);
    v185 = v723;
    v131 = v713;
  }

  v219 = v731.f64[0];
  if (*&v731.f64[0] != &v731.f64[1])
  {
    do
    {
      v220 = *(*&v219 + 56);
      v221 = *(*&v219 + 64);
      v222 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * (&v221[-v220] >> 3));
      v749[0] = &v722;
      v749[1] = v714;
      v749[2] = v131;
      v749[3] = a3;
      v749[4] = v718;
      if (v221 == v220)
      {
        v223 = 0;
      }

      else
      {
        v223 = v222;
      }

      sub_10169F0D0(v220, v221, v749, v223, 1);
      v224 = *(*&v219 + 8);
      if (*&v224 == 0.0)
      {
        do
        {
          v225 = *(*&v219 + 16);
          _ZF = *&v225->f64[0] == *&v219;
          v219 = *&v225;
        }

        while (!_ZF);
      }

      else
      {
        do
        {
          v225 = v224;
          v224 = *&v224->f64[0];
        }

        while (*&v224 != 0.0);
      }

      v219 = *&v225;
    }

    while (v225 != &v731.f64[1]);
  }

  if (!__srca)
  {
    goto LABEL_569;
  }

  v226 = v728;
  if (v728 == &v729)
  {
    goto LABEL_536;
  }

  v227 = 0x6DB6DB6DB6DB6DB7;
  while (2)
  {
    v750 = 0u;
    memset(v749, 0, sizeof(v749));
    v718[0] = 0;
    v718[1] = 0;
    if (*&v226[3].f64[1])
    {
      v228 = v226;
      v229 = v226[2].f64[1];
      v703 = v228;
      f64 = v228[3].f64;
      if (*&v229 != &v228[3])
      {
        v231 = 1;
        do
        {
          v232 = v227;
          v233 = *(*&v229 + 32);
          v234 = (*(*(&v722 + 1) + (((v724 + v233) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((v724 + v233) & 0xF));
          if (v231)
          {
            *v718 = *v234;
          }

          v235 = 0;
          v236 = 1;
          do
          {
            v237 = v236;
            sub_1016A1008(v749, v234, &v234[21 * v235 + 5], v233, v235, v714, v131, v231 & 1);
            v236 = 0;
            v231 = 0;
            v235 = 1;
          }

          while ((v237 & 1) != 0);
          v238 = *(*&v229 + 8);
          if (*&v238 == 0.0)
          {
            do
            {
              v239 = *(*&v229 + 16);
              _ZF = *v239 == *&v229;
              v229 = *&v239;
            }

            while (!_ZF);
          }

          else
          {
            do
            {
              v239 = v238;
              v238 = *v238;
            }

            while (*&v238 != 0.0);
          }

          v231 = 0;
          v229 = *&v239;
          v227 = v232;
        }

        while (v239 != f64);
      }

      sub_1016A0DD4(v749, v718);
      LOWORD(__p) = 0;
      v240 = v749[1];
      v241 = v749[0];
      if (v749[1] == v749[0])
      {
        v253 = 0;
      }

      else
      {
        v242 = 0;
        do
        {
          v243 = &v241[112 * v242];
          if (!*(v243 + 11))
          {
            v244 = *(v243 + 9);
            if (v244 <= 1 && (*(&__p + v244) & 1) == 0)
            {
              v710 = &v241[112 * v242];
              v245 = ((v240 - v241) >> 4) * v227;
              if (v242 + 1 < v245)
              {
                v246 = v242 + 1;
              }

              else
              {
                v246 = 0;
              }

              while (*&v241[112 * v246 + 72] != v244)
              {
                if (v246 + 1 < v245)
                {
                  ++v246;
                }

                else
                {
                  v246 = 0;
                }
              }

              v247 = *&v241[112 * v242 + 16];
              v248 = 1;
              v249 = v247;
              while (1)
              {
                v250 = &v241[112 * v246];
                if (*(v250 + 2) != v249 && (v248 & 1) == 0)
                {
                  sub_1016A4404(v241, v240, v247, v249 - 1, 1);
                  sub_1016A4404(v749[0], v749[1], v247 + 1, v249, 2);
                }

                if (v246 == v242)
                {
                  break;
                }

                v251 = *(v250 + 11);
                if (v251 == 1)
                {
                  v248 = 0;
                }

                else if (!v251)
                {
                  v247 = *(v250 + 2);
                  v248 = 1;
                }

                v249 = *(v250 + 2);
                v252 = v246 + 1;
                v240 = v749[1];
                v241 = v749[0];
                while (1)
                {
                  if (v252 < ((v749[1] - v749[0]) >> 4) * v227)
                  {
                    ++v246;
                  }

                  else
                  {
                    v246 = 0;
                  }

                  if (*(v749[0] + 14 * v246 + 9) == v244)
                  {
                    break;
                  }

                  v252 = v246 + 1;
                }
              }

              *(&__p + *(v710 + 9)) = 1;
              v240 = v749[1];
              v241 = v749[0];
              v131 = v713;
            }
          }

          ++v242;
          v253 = ((v240 - v241) >> 4) * v227;
        }

        while (v242 < v253);
      }

      v226 = v703;
      if (v240 == v241)
      {
        v703[4].f64[0] = 0.0;
        if (v240)
        {
          goto LABEL_528;
        }
      }

      else
      {
        v254 = 0;
        v255 = 0;
        v256 = 0;
        v257 = v253 + 1;
        if (v253 <= 1)
        {
          v258 = 1;
        }

        else
        {
          v258 = v253;
        }

        v259 = v241 + 44;
        v260 = v241 + 44;
        do
        {
          v261 = *(v260 - 28);
          if (v261 > v255)
          {
            v255 = *(v260 - 28);
          }

          if (*v260 == 1 && *(v260 + 12) > 1uLL && *(v260 + 4) < 2uLL)
          {
            v257 = v261 + 1;
          }

          if (v256)
          {
            v263 = 0;
          }

          else
          {
            v263 = v261 == v257;
          }

          if (v263)
          {
            v256 = v254;
          }

          ++v254;
          v260 += 112;
        }

        while (v258 != v254);
        v264 = 0;
        v265 = 0;
        v266 = v258;
        v267 = v255 + 1;
        do
        {
          v268 = &v241[112 * v256];
          if (v256 + 1 == v253)
          {
            v256 = 0;
          }

          else
          {
            ++v256;
          }

          v269 = *(v268 + 2);
          if (v269 == v264)
          {
            v269 = v264;
          }

          else
          {
            if (v269 == v267)
            {
              ++v265;
              v267 = v255 + 1;
            }

            if (*(v268 + 11) == 1)
            {
              v270 = v269 < v255 ? v269 + 1 : 0;
              if (*(v268 + 6) <= 1uLL && *(v268 + 7) >= 2uLL)
              {
                v267 = v270;
              }
            }
          }

          *(v268 + 3) = v265;
          v264 = v269;
          --v266;
        }

        while (v266);
        v272 = 0;
        v273 = 0.0;
        v274 = v258;
        do
        {
          if (*(v259 - 28) > v272 && *v259 == 1)
          {
            *&v273 += (*(v259 + 4) < 2uLL) & (*(v259 + 12) > 1uLL);
            if (*(v259 + 4) < 2uLL && *(v259 + 12) > 1uLL)
            {
              v272 = *(v259 - 28);
            }
          }

          v259 += 112;
          --v274;
        }

        while (v274);
        v703[4].f64[0] = v273;
        v276 = v241 + 56;
        v277 = v724;
        v278 = *(&v722 + 1);
        do
        {
          v279 = *(v276 - 4);
          if (v279 >= 2)
          {
            __assert_rtn("operator[]", "array.hpp", 117, "(i < N)&&(out of range)");
          }

          if (*(v276 - 3) == 1)
          {
            v280 = *(v278 + (((*(v276 - 3) + v277) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v276 - 6) + v277) & 0xF);
            v281 = v280 + 168 * v279;
            *(v281 + 152) = *(v276 - 1);
            *(v281 + 168) = *(v276 - 5);
            if (*(v280 + 48) != *(v280 + 216) && *v276 != 2)
            {
              *(v281 + 144) = 0;
            }
          }

          v276 += 14;
          --v258;
        }

        while (v258);
LABEL_528:
        v749[1] = v241;
        operator delete(v241);
      }
    }

    v282 = *&v226->f64[1];
    if (v282)
    {
      do
      {
        v283 = v282;
        v282 = *v282;
      }

      while (v282);
    }

    else
    {
      do
      {
        v283 = *&v226[1].f64[0];
        _ZF = *v283 == v226;
        v226 = v283;
      }

      while (!_ZF);
    }

    v226 = v283;
    if (v283 != &v729)
    {
      continue;
    }

    break;
  }

  v226 = v728;
LABEL_536:
  if (v226 != &v729)
  {
    do
    {
      v284 = *&v226[2].f64[1];
      if (v284 != &v226[3])
      {
        do
        {
          v285 = v284[1];
          v286 = v284;
          if (v285)
          {
            do
            {
              v287 = v285;
              v285 = *v285;
            }

            while (v285);
          }

          else
          {
            do
            {
              v287 = v286[2];
              _ZF = *v287 == v286;
              v286 = v287;
            }

            while (!_ZF);
          }

          if (*(*(*(&v722 + 1) + (((v724 + v284[4]) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((v724 + *(v284 + 8)) & 0xF) + 32) == 1)
          {
            sub_100D7A2B0(&v226[2].f64[1], v284);
            operator delete(v284);
          }

          v284 = v287;
        }

        while (v287 != &v226[3]);
      }

      v288 = *&v226->f64[1];
      if (v288)
      {
        do
        {
          v289 = v288;
          v288 = *v288;
        }

        while (v288);
      }

      else
      {
        do
        {
          v289 = *&v226[1].f64[0];
          _ZF = *v289 == v226;
          v226 = v289;
        }

        while (!_ZF);
      }

      v226 = v289;
    }

    while (v289 != &v729);
    v226 = v728;
  }

  if (v226 != &v729)
  {
    do
    {
      v290 = v226->f64[1];
      v291 = *&v290;
      v292 = v226;
      if (v290 == 0.0)
      {
        do
        {
          v293 = v292[2];
          _ZF = *v293 == v292;
          v292 = v293;
        }

        while (!_ZF);
      }

      else
      {
        do
        {
          v293 = v291;
          v291 = *v291;
        }

        while (v291);
      }

      if (*&v226[3].f64[1] == 1)
      {
        v294 = v724 + *(*&v226[2].f64[1] + 32);
        *(*(*(&v722 + 1) + ((v294 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * (v294 & 0xF) + 24) = -1;
        v295 = v226;
        if (v290 == 0.0)
        {
          do
          {
            v296 = *&v295[1].f64[0];
            _ZF = *&v296->f64[0] == v295;
            v295 = v296;
          }

          while (!_ZF);
        }

        else
        {
          do
          {
            v296 = *&v290;
            v290 = **&v290;
          }

          while (v290 != 0.0);
        }

        if (v728 == v226)
        {
          v728 = v296;
        }

        --v730;
        sub_100018288(v729, v226);
        sub_100034450(*&v226[3].f64[0]);
        operator delete(v226);
      }

      v226 = v293;
    }

    while (v293 != &v729);
  }

LABEL_569:
  v297 = v731.f64[0];
  if (*&v731.f64[0] != &v731.f64[1])
  {
    v298 = "(i < N)&&(out of range)";
    v299 = "array.hpp";
    v300 = "operator[]";
    while (1)
    {
      v301 = *(*&v297 + 56);
      v302 = *(*&v297 + 64);
      v303 = v302 - v301;
      if (v302 != v301)
      {
        break;
      }

LABEL_623:
      v334 = *(*&v297 + 8);
      if (*&v334 == 0.0)
      {
        do
        {
          v335 = *(*&v297 + 16);
          _ZF = *&v335->f64[0] == *&v297;
          v297 = *&v335;
        }

        while (!_ZF);
      }

      else
      {
        do
        {
          v335 = v334;
          v334 = *&v334->f64[0];
        }

        while (*&v334 != 0.0);
      }

      v297 = *&v335;
      if (v335 == &v731.f64[1])
      {
        goto LABEL_629;
      }
    }

    v304 = *(&v722 + 1);
    v305 = v724;
    v306 = 0xCCCCCCCCCCCCCCCDLL * (v303 >> 3);
    if (v303 >= 41)
    {
      v307 = v301 + 40;
    }

    else
    {
      v307 = &v301[40 * (1 % v306)];
    }

    if (v303 >= 41)
    {
      v308 = 1;
    }

    else
    {
      v308 = 1 % v306;
    }

    v309 = *(*&v297 + 56);
    while (1)
    {
      v310 = *(v309 + 1);
      if (v310 > 1)
      {
LABEL_632:
        v341 = 117;
        goto LABEL_1203;
      }

      v311 = *v309;
      if (*v309 == *v307)
      {
        v312 = v308 + 1;
        if (v308 <= -2)
        {
          do
          {
            v312 += v306;
          }

          while (v312 < 0);
        }

        else if (v312 < v306)
        {
          v307 += 40;
          goto LABEL_587;
        }

        v312 %= v306;
        v307 = &v301[40 * v312];
      }

      else
      {
        v312 = v308;
      }

LABEL_587:
      v313 = *(v304 + (((v311 + v305) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((v311 + v305) & 0xF);
      v314 = v313 + 168 * v310;
      v315 = *(v313 + 24);
      if (v315 > 0)
      {
        while (1)
        {
          while (1)
          {
            if (v311 == *v307)
            {
              goto LABEL_603;
            }

            v316 = *(v304 + (((*v307 + v305) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*v307 + v305) & 0xF);
            if (v315 != *(v316 + 24))
            {
              goto LABEL_602;
            }

            v317 = *(v307 + 1);
            if (v317 > 1)
            {
              goto LABEL_632;
            }

            v318 = v316 + 168 * v317;
            v320 = *(v318 + 48);
            v319 = (v318 + 48);
            if (*(v314 + 48) != v320 || *(v314 + 72) != v319[3] || *(v314 + 64) != v319[2] || *(v314 + 80) != v319[4] || *(v314 + 56) != v319[1])
            {
LABEL_602:
              v311 = *v307;
              goto LABEL_603;
            }

            v321 = v312 + 1;
            if (v312 > -2)
            {
              break;
            }

            do
            {
              v321 += v306;
            }

            while (v321 < 0);
LABEL_600:
            v312 = v321 % v306;
            v307 = &v301[40 * (v321 % v306)];
          }

          if (v321 >= v306)
          {
            goto LABEL_600;
          }

          v307 += 40;
          ++v312;
        }
      }

      v311 = *v307;
LABEL_603:
      v308 = v312;
      v322 = *(v307 + 1);
      if (v322 > 1)
      {
        v341 = 122;
        goto LABEL_1203;
      }

      v323 = *(v304 + (((v311 + v305) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((v311 + v305) & 0xF) + 168 * v322;
      *(v314 + 128) = v311;
      *(v314 + 120) = *(*(v307 + 4) + 32);
      if (*(v314 + 72) == *(v323 + 72))
      {
        v324 = *(v314 + 104);
        v325 = *(v323 + 104);
        if (vabdd_f64(v324, v325) >= 50.0)
        {
          if (v324 >= v325)
          {
            goto LABEL_622;
          }

LABEL_621:
          *(v314 + 136) = v311;
          goto LABEL_622;
        }

        v326 = *(v314 + 96);
        if (v326 == 0.0)
        {
          v341 = 56;
          v300 = "apply";
          v299 = "segment_ratio.hpp";
          v298 = "lhs.denominator() != Type(0)";
          goto LABEL_1203;
        }

        v327 = *(v323 + 96);
        if (v327 == 0.0)
        {
          v341 = 57;
          v300 = "apply";
          v299 = "segment_ratio.hpp";
          v298 = "rhs.denominator() != Type(0)";
LABEL_1203:
          __assert_rtn(v300, v299, v341, v298);
        }

        v328 = *(v314 + 88) / v326;
        v329 = *(v323 + 88) / v327;
        if (v328 != v329)
        {
          if ((*&v328 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v329 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            v331 = fabs(v328);
            v332 = fabs(v329);
            v333 = vabdd_f64(v328, v329);
            if (v331 < v332)
            {
              v331 = v332;
            }

            if (v331 < 1.0)
            {
              v331 = 1.0;
            }

            v330 = v333 > v331 * 2.22044605e-16;
          }

          else
          {
            v330 = 1;
          }

          if (v328 < v329 && v330)
          {
            goto LABEL_621;
          }
        }
      }

LABEL_622:
      v309 += 40;
      if (v309 == v302)
      {
        goto LABEL_623;
      }
    }
  }

LABEL_629:
  if (v691)
  {
    v336 = v724;
    v337 = *(&v722 + 1);
    v338 = v723;
    v339 = (*(&v722 + 1) + 8 * (v724 >> 4));
    if (v723 == *(&v722 + 1))
    {
      v340 = 0;
    }

    else
    {
      v340 = *v339 + 376 * (v724 & 0xF);
    }

    v342 = (*(&v724 + 1) + v724) >> 4;
    v343 = (DWORD2(v724) + v724) & 0xF;
LABEL_635:
    v344 = v340 - 6016;
    while (1)
    {
      v345 = v338 == v337 ? 0 : *(v337 + 8 * v342) + 376 * v343;
      if (v340 == v345)
      {
        break;
      }

      if (*(v340 + 112) == 0.0 && *(v340 + 280) == 0.0)
      {
        v346 = *(v340 + 136);
        if (v346 == -1)
        {
          v346 = *(v340 + 128);
        }

        v347 = *(v340 + 304);
        if (v347 == -1)
        {
          v347 = *(v340 + 296);
        }

        if ((v346 & 0x8000000000000000) == 0 && (v347 & 0x8000000000000000) == 0 && v346 != v347)
        {
          v348 = (*(v337 + (((v346 + v336) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((v346 + v336) & 0xF));
          v349 = *v340;
          v350 = *(v340 + 8);
          *(v340 + 112) = (v350 - v348[1]) * (v350 - v348[1]) + (*v340 - *v348) * (*v340 - *v348);
          v351 = (*(v337 + (((v347 + v336) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((v347 + v336) & 0xF));
          *(v340 + 280) = (v350 - v351[1]) * (v350 - v351[1]) + (v349 - *v351) * (v349 - *v351);
        }
      }

      v340 += 376;
      v344 += 376;
      if (*v339 == v344)
      {
        v352 = v339[1];
        ++v339;
        v340 = v352;
        goto LABEL_635;
      }
    }
  }

  sub_1016A4484(*&v731.f64[1]);
  v719 = 0u;
  v720 = 0u;
  *v718 = 0u;
  *&v731.f64[0] = v714;
  *&v731.f64[1] = v713;
  v732.i64[0] = &v722;
  v732.i64[1] = &v728;
  v736 = 0;
  v737 = 0;
  v738 = a3;
  v739 = a6;
  v734[1] = 0;
  v735 = &v736;
  v733 = v734;
  v734[0] = 0;
  sub_1016A476C(0);
  v736 = 0;
  v737 = 0;
  v735 = &v736;
  v353 = v732.i64[0];
  if (!*(v732.i64[0] + 40))
  {
    goto LABEL_674;
  }

  v354 = 0;
  do
  {
    v355 = *(v353[1] + ((&v354[v353[4]] >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v353 + 8) + v354) & 0xF);
    if (*(v355 + 32))
    {
      goto LABEL_673;
    }

    for (m = 40; m != 376; m += 168)
    {
      v358 = *(v355 + m + 8);
      v357 = *(v355 + m + 16);
      v359 = *(v355 + m + 24);
      v360 = v734[0];
      if (!v734[0])
      {
LABEL_670:
        operator new();
      }

      while (1)
      {
        while (1)
        {
          v361 = v360;
          v362 = v360[4];
          if (v358 != v362)
          {
            if (v358 >= v362)
            {
              if (v362 >= v358)
              {
                goto LABEL_671;
              }

              goto LABEL_669;
            }

            goto LABEL_666;
          }

          v363 = v361[5];
          if (v357 != v363)
          {
            break;
          }

          v364 = v361[6];
          if (v359 >= v364)
          {
            if (v364 >= v359)
            {
              goto LABEL_671;
            }

            goto LABEL_669;
          }

LABEL_666:
          v360 = *v361;
          if (!*v361)
          {
            goto LABEL_670;
          }
        }

        if (v357 < v363)
        {
          goto LABEL_666;
        }

        if (v363 >= v357)
        {
          break;
        }

LABEL_669:
        v360 = v361[1];
        if (!v360)
        {
          goto LABEL_670;
        }
      }

LABEL_671:
      v749[0] = v354;
      sub_10169D880((v361 + 8), v354);
    }

    v353 = v732.i64[0];
LABEL_673:
    ++v354;
  }

  while (v354 < v353[5]);
LABEL_674:
  v715 = 1;
  v365 = v733;
  if (v733 != v734)
  {
    do
    {
      sub_1016A44E0(&v731, &v715, v365 + 4, v365 + 7, -1);
      v366 = v365[1];
      if (v366)
      {
        do
        {
          v367 = v366;
          v366 = *v366;
        }

        while (v366);
      }

      else
      {
        do
        {
          v367 = v365[2];
          _ZF = *v367 == v365;
          v365 = v367;
        }

        while (!_ZF);
      }

      v365 = v367;
    }

    while (v367 != v734);
    v365 = v733;
    v353 = v732.i64[0];
  }

  if (v365 != v734)
  {
    do
    {
      v368 = v365[8];
      if (v368 != v365 + 9)
      {
        v369 = v353[4];
        v370 = v353[1];
        do
        {
          v371 = v368[4] + v369;
          v372 = *(v370 + ((v371 >> 1) & 0x7FFFFFFFFFFFFFF8));
          v373 = v371 & 0xF;
          v374 = v372 + 376 * (v371 & 0xF);
          if ((*(v374 + 32) & 1) == 0)
          {
            v375 = *(v374 + 40);
            v376 = *(v374 + 208);
            if (v375 != 3 || v376 != 3)
            {
              v378 = v365[4];
              v379 = (v372 + 376 * v373 + 184);
              v380 = 336;
              do
              {
                if (*(v379 - 17) == v378 && *(v379 - 15) == v365[6] && *(v379 - 16) == v365[5])
                {
                  *v379 = v365[7];
                }

                v379 += 21;
                v380 -= 168;
              }

              while (v380);
            }
          }

          v381 = v368[1];
          if (v381)
          {
            do
            {
              v382 = v381;
              v381 = *v381;
            }

            while (v381);
          }

          else
          {
            do
            {
              v382 = v368[2];
              _ZF = *v382 == v368;
              v368 = v382;
            }

            while (!_ZF);
          }

          v368 = v382;
        }

        while (v382 != v365 + 9);
      }

      v383 = v365[1];
      if (v383)
      {
        do
        {
          v384 = v383;
          v383 = *v383;
        }

        while (v383);
      }

      else
      {
        do
        {
          v384 = v365[2];
          _ZF = *v384 == v365;
          v365 = v384;
        }

        while (!_ZF);
      }

      v365 = v384;
    }

    while (v384 != v734);
  }

  if (v353[5])
  {
    v385 = 0;
    do
    {
      v386 = *(v353[1] + (((v353[4] + v385) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v353 + 8) + v385) & 0xF);
      v389 = *(v386 + 184);
      v388 = (v386 + 184);
      v387 = v389;
      v390 = *(v388 - 20);
      if (v390 > 0)
      {
        v391 = -v390;
      }

      else
      {
        v391 = v385;
      }

      __p = v391;
      if (v387 == -1)
      {
        v393 = -1;
      }

      else
      {
        v749[0] = v388;
        sub_1016A481C(&v735, v387)[5] = v387;
        v749[0] = v388;
        v392 = sub_1016A481C(&v735, *v388);
        sub_10169D880((v392 + 7), v391);
        v393 = *v388;
      }

      v394 = v388 + 21;
      v395 = v388[21];
      if (v395 != -1 && v393 != v395)
      {
        v749[0] = v388 + 21;
        sub_1016A481C(&v735, v395)[5] = v395;
        v749[0] = v388 + 21;
        v397 = sub_1016A481C(&v735, *v394);
        sub_10169D880((v397 + 7), v391);
        v393 = *v388;
        v395 = *v394;
      }

      if (v395 != -1 && v393 != -1 && v393 != v395)
      {
        v749[0] = v388;
        v400 = sub_1016A481C(&v735, v393);
        v749[0] = v388 + 21;
        v401 = sub_1016A4924((v400 + 10), *v394);
        v749[0] = v388 + 21;
        v402 = sub_1016A481C(&v735, *v394);
        v749[0] = v388;
        v403 = sub_1016A4924((v402 + 10), *v388);
        for (n = v401[7]; n; n = *n)
        {
          v405 = n[4];
          if (v391 >= v405)
          {
            if (v405 >= v391)
            {
              goto LABEL_734;
            }

            ++n;
          }
        }

        ++v401[5];
        sub_10169D880((v401 + 6), v391);
LABEL_734:
        for (ii = v403[7]; ii; ii = *ii)
        {
          v407 = ii[4];
          if (v391 >= v407)
          {
            if (v407 >= v391)
            {
              goto LABEL_740;
            }

            ++ii;
          }
        }

        ++v403[5];
        sub_10169D880((v403 + 6), v391);
      }

LABEL_740:
      ++v385;
      v353 = v732.i64[0];
    }

    while (v385 < *(v732.i64[0] + 40));
  }

  v408 = v735;
  if (v735 != &v736)
  {
    while (2)
    {
      v409 = v408[12];
      if (v409)
      {
        if (v409 == 1)
        {
          if (v408[10][5] < 2uLL)
          {
            v410 = 1;
          }

          else
          {
            v410 = 2;
          }

LABEL_760:
          *(v408 + 12) = v410;
LABEL_761:
          v417 = v408[1];
          if (v417)
          {
            do
            {
              v418 = v417;
              v417 = *v417;
            }

            while (v417);
          }

          else
          {
            do
            {
              v418 = v408[2];
              _ZF = *v418 == v408;
              v408 = v418;
            }

            while (!_ZF);
          }

          v408 = v418;
          if (v418 == &v736)
          {
            goto LABEL_767;
          }

          continue;
        }

        v411 = v408[10];
        if (v411 != v408 + 11)
        {
          v412 = 0;
          v413 = 1;
          while (v411[5] == 1)
          {
            v414 = *(v411[6] + 32);
            if ((v413 & 1) == 0)
            {
              _ZF = v412 == v414;
              v414 = v412;
              if (!_ZF)
              {
                break;
              }
            }

            v415 = v411[1];
            if (v415)
            {
              do
              {
                v416 = v415;
                v415 = *v415;
              }

              while (v415);
            }

            else
            {
              do
              {
                v416 = v411[2];
                _ZF = *v416 == v411;
                v411 = v416;
              }

              while (!_ZF);
            }

            v413 = 0;
            v412 = v414;
            v411 = v416;
            if (v416 == v408 + 11)
            {
              goto LABEL_759;
            }
          }

          goto LABEL_761;
        }
      }

      break;
    }

LABEL_759:
    v410 = 1;
    goto LABEL_760;
  }

LABEL_767:
  v419 = 0;
  while (2)
  {
    v420 = v735;
    if (v419 >= v737 || v735 == &v736)
    {
      break;
    }

    v711 = 0;
    v706 = v419 + 1;
    while (2)
    {
      if (*(v420 + 12))
      {
        goto LABEL_774;
      }

      v424 = v420[10];
      if (v424 == v420 + 11)
      {
LABEL_857:
        v711 = 1;
        *(v420 + 12) = 1;
        goto LABEL_774;
      }

      v425 = 0;
      v426 = 1;
      while (2)
      {
        v427 = v736;
        if (!v736)
        {
          goto LABEL_774;
        }

        v428 = v424[4];
        v429 = &v736;
        do
        {
          if (v427[4] >= v428)
          {
            v429 = v427;
          }

          v427 = v427[v427[4] < v428];
        }

        while (v427);
        if (v429 == &v736 || v428 < v429[4])
        {
          goto LABEL_774;
        }

        if (v424[5] == 1)
        {
LABEL_846:
          if ((*(v429 + 12) - 1) >= 2)
          {
            if (v426)
            {
              v426 = 0;
              v425 = *(v424[6] + 32);
            }

            else
            {
              if (v425 != *(v424[6] + 32))
              {
                goto LABEL_774;
              }

              v426 = 0;
            }
          }

          v458 = v424[1];
          if (v458)
          {
            do
            {
              v459 = v458;
              v458 = *v458;
            }

            while (v458);
          }

          else
          {
            do
            {
              v459 = v424[2];
              _ZF = *v459 == v424;
              v424 = v459;
            }

            while (!_ZF);
          }

          v424 = v459;
          if (v459 == v420 + 11)
          {
            goto LABEL_857;
          }

          continue;
        }

        break;
      }

      if (*(v429 + 12) != 2)
      {
        goto LABEL_774;
      }

      memset(v749, 0, 24);
      sub_10169D6F8(v749, v420 + 7);
      v430 = v429[7];
      v431 = v429 + 8;
      if (v430 != v429 + 8)
      {
        do
        {
          sub_10169D9C8(v749, v430[4]);
          v432 = v430[1];
          if (v432)
          {
            do
            {
              v433 = v432;
              v432 = *v432;
            }

            while (v432);
          }

          else
          {
            do
            {
              v433 = v430[2];
              _ZF = *v433 == v430;
              v430 = v433;
            }

            while (!_ZF);
          }

          v430 = v433;
        }

        while (v433 != v431);
      }

      if (v749[2] != 1)
      {
        goto LABEL_858;
      }

      v434 = v429[7];
      if (v434 == v431)
      {
LABEL_845:
        sub_100034450(v749[1]);
        goto LABEL_846;
      }

      v435 = v420[5];
      v436 = v429[5];
      v437 = (v732.i64[1] + 8);
      while (1)
      {
        v438 = v434[4];
        if (v438 < 0)
        {
          break;
        }

        v439 = *(*(v732.i64[0] + 8) + (((*(v732.i64[0] + 32) + v438) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v732.i64[0] + 32) + v438) & 0xF);
        if (*(v439 + 40) != 2 || *(v439 + 208) != 2)
        {
          goto LABEL_858;
        }

        v440 = *(v439 + 184);
        v441 = *(v439 + 352);
        if ((v440 != v435 || v441 != v436) && (v441 != v435 || v440 != v436))
        {
          goto LABEL_858;
        }

LABEL_839:
        v456 = v434[1];
        if (v456)
        {
          do
          {
            v457 = v456;
            v456 = *v456;
          }

          while (v456);
        }

        else
        {
          do
          {
            v457 = v434[2];
            _ZF = *v457 == v434;
            v434 = v457;
          }

          while (!_ZF);
        }

        v434 = v457;
        if (v457 == v431)
        {
          goto LABEL_845;
        }
      }

      v444 = *v437;
      if (!*v437)
      {
        goto LABEL_839;
      }

      v445 = -v438;
      v446 = v732.i64[1] + 8;
      do
      {
        if (*(v444 + 32) >= v445)
        {
          v446 = v444;
        }

        v444 = *(v444 + 8 * (*(v444 + 32) < v445));
      }

      while (v444);
      if (v446 == v437)
      {
        goto LABEL_839;
      }

      if (*(v446 + 32) > v445)
      {
        goto LABEL_839;
      }

      v447 = *(v446 + 40);
      v448 = (v446 + 48);
      if (v447 == v448)
      {
        goto LABEL_839;
      }

      while (1)
      {
        v449 = *(*(v732.i64[0] + 8) + (((v447[4] + *(v732.i64[0] + 32)) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v447 + 8) + *(v732.i64[0] + 32)) & 0xF);
        if (*(v449 + 40) != 2 || *(v449 + 208) != 2)
        {
          break;
        }

        v450 = *(v449 + 184);
        v451 = *(v449 + 352);
        if ((v450 != v435 || v451 != v436) && (v451 != v435 || v450 != v436))
        {
          break;
        }

        v454 = v447[1];
        if (v454)
        {
          do
          {
            v455 = v454;
            v454 = *v454;
          }

          while (v454);
        }

        else
        {
          do
          {
            v455 = v447[2];
            _ZF = *v455 == v447;
            v447 = v455;
          }

          while (!_ZF);
        }

        v447 = v455;
        if (v455 == v448)
        {
          goto LABEL_839;
        }
      }

LABEL_858:
      sub_100034450(v749[1]);
LABEL_774:
      v422 = v420[1];
      if (v422)
      {
        do
        {
          v423 = v422;
          v422 = *v422;
        }

        while (v422);
      }

      else
      {
        do
        {
          v423 = v420[2];
          _ZF = *v423 == v420;
          v420 = v423;
        }

        while (!_ZF);
      }

      v420 = v423;
      if (v423 != &v736)
      {
        continue;
      }

      break;
    }

    v419 = v706;
    if (v711)
    {
      continue;
    }

    break;
  }

  v460 = *(v732.i64[0] + 8);
  if (*(v732.i64[0] + 16) != v460)
  {
    v461 = *(v732.i64[0] + 32);
    v462 = (v460 + 8 * (v461 >> 4));
    v463 = *v462;
    v464 = *v462 + 376 * (v461 & 0xF);
    v465 = *(v460 + (((*(v732.i64[0] + 40) + v461) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v732.i64[0] + 40) + v461) & 0xF);
    if (v464 != v465)
    {
      v466 = v736;
      do
      {
        v467 = v464 + 40;
        for (jj = 40; jj != 376; v467 = v464 + jj)
        {
          if (v466)
          {
            v469 = *(v467 + 144);
            v470 = &v736;
            v471 = v466;
            do
            {
              if (v471[4] >= v469)
              {
                v470 = v471;
              }

              v471 = v471[v471[4] < v469];
            }

            while (v471);
            if (v470 != &v736 && v469 >= v470[4])
            {
              *(v467 + 152) = *(v470 + 12) == 1;
            }
          }

          jj += 168;
        }

        v464 += 376;
        if (v464 - v463 == 6016)
        {
          v472 = v462[1];
          ++v462;
          v463 = v472;
          v464 = v472;
        }
      }

      while (v464 != v465);
    }
  }

  v473 = *(&v722 + 1);
  v474 = v723;
  v475 = (*(&v722 + 1) + 8 * (v724 >> 4));
  if (v723 == *(&v722 + 1))
  {
    v476 = 0;
  }

  else
  {
    v476 = *v475 + 376 * (v724 & 0xF);
  }

  v477 = *(&v724 + 1);
  v478 = (*(&v724 + 1) + v724) >> 4;
  v479 = (BYTE8(v724) + v724) & 0xF;
LABEL_880:
  v480 = v476 - 6016;
  while (1)
  {
    v481 = v474 == v473 ? 0 : *(v473 + 8 * v478) + 376 * v479;
    if (v476 == v481)
    {
      break;
    }

    *(v476 + 200) = 0;
    *(v476 + 204) = 0;
    *(v476 + 368) = 0;
    *(v476 + 372) = 0;
    v480 += 376;
    v476 += 376;
    if (*v475 == v480)
    {
      v482 = v475[1];
      ++v475;
      v476 = v482;
      goto LABEL_880;
    }
  }

  v749[0] = v714;
  v749[1] = v713;
  v749[2] = &v722;
  v749[3] = &v728;
  v749[5] = 0;
  v749[4] = a3;
  *&v750 = a6;
  *(&v750 + 1) = v714;
  v751 = v713;
  v752 = &v722;
  v753 = &v725;
  v754 = &v728;
  v755 = a5;
  v756 = a3;
  v757 = a6;
  __p = *(&v720 + 1);
  LOWORD(v715) = 257;
  if (v477)
  {
    v483 = 0;
    while (1)
    {
      v484 = *(*(&v722 + 1) + (((v483 + v724) >> 1) & 0x7FFFFFFFFFFFFFF8));
      v485 = v484 + 376 * ((v483 + v724) & 0xF);
      if ((*(v485 + 32) & 1) == 0)
      {
        break;
      }

LABEL_898:
      if (++v483 >= v477)
      {
        goto LABEL_899;
      }
    }

    v486 = *(v485 + 40);
    if (v486 == 4)
    {
      if (*(v485 + 208) == 4)
      {
        v487 = *(v485 + 112) > *(v485 + 280);
LABEL_897:
        sub_1016A4A18(v749, v485, v483, v487, v718, &__p, &v715);
        v477 = *(&v724 + 1);
        goto LABEL_898;
      }
    }

    else if (v486 == 3 && *(v485 + 208) == 3)
    {
      goto LABEL_898;
    }

    sub_1016A4A18(v749, v484 + 376 * ((v483 + v724) & 0xF), v483, 0, v718, &__p, &v715);
    v487 = 1;
    goto LABEL_897;
  }

LABEL_899:
  sub_1016A476C(v736);
  sub_1016A4718(v734[0]);
  v488 = *(&v722 + 1);
  v489 = v723;
  v490 = (*(&v722 + 1) + 8 * (v724 >> 4));
  if (v723 == *(&v722 + 1))
  {
    v491 = 0;
  }

  else
  {
    v491 = *v490 + 376 * (v724 & 0xF);
  }

  while (1)
  {
    v492 = v489 == v488 ? 0 : *(v488 + (((*(&v724 + 1) + v724) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((DWORD2(v724) + v724) & 0xF);
    if (v491 == v492)
    {
      break;
    }

    if (*(v491 + 48) != *(v491 + 216) || (*(v491 + 32) & 1) == 0)
    {
      v493 = 0;
      v494 = 0;
      v495 = (v491 + 40);
      v496 = v491 + 40;
      v497 = 40;
      while (1)
      {
        v749[2] = 0;
        v749[1] = 0;
        v749[0] = 0;
        v498 = *(v496 + 24);
        *v749 = *(v496 + 8);
        v749[2] = v498;
        if (*(v491 + 48) != *(v491 + 216) && *(v496 + 120) <= 2uLL)
        {
          goto LABEL_950;
        }

        if (*v495 == 3 || *(v491 + 208) == 3)
        {
          *&v731.f64[0] = v749;
          *(sub_1016A7650(&v725, v749) + 57) = 1;
        }

        *&v731.f64[0] = v749;
        if (sub_1016A7650(&v725, v749)[7])
        {
          goto LABEL_951;
        }

        *&v731.f64[0] = v749;
        if (*(sub_1016A7650(&v725, v749) + 57))
        {
          goto LABEL_951;
        }

        if (v493)
        {
          goto LABEL_917;
        }

        v499 = *(v491 + 24);
        if (v499 >= 1)
        {
          break;
        }

        v493 = 0;
        if (v494)
        {
LABEL_941:
          v494 = 1;
LABEL_950:
          *&v731.f64[0] = v749;
          *(sub_1016A7650(&v725, v749) + 57) = 1;
          goto LABEL_951;
        }

LABEL_942:
        if (*v496 == 1 && (*(v491 + 33) & 1) == 0)
        {
          if (*v495 == 1 && *(v491 + 208) == 1)
          {
            v494 = 0;
            if (*(v491 + 48) == *(v491 + 216))
            {
              goto LABEL_951;
            }
          }

          else
          {
            v494 = 0;
          }

          goto LABEL_950;
        }

        v494 = 0;
LABEL_951:
        v497 += 168;
        v496 = v491 + v497;
        if (v497 == 376)
        {
          goto LABEL_952;
        }
      }

      v500 = v729;
      if (!v729)
      {
        goto LABEL_939;
      }

      v501 = &v729;
      do
      {
        if (*(v500 + 4) >= v499)
        {
          v501 = v500;
        }

        v500 = *&v500[8 * (*(v500 + 4) < v499)];
      }

      while (v500);
      if (v501 == &v729 || v501[4] > v499 || (v502 = v501[5], v502 == v501 + 6))
      {
LABEL_939:
        v493 = 1;
        goto LABEL_942;
      }

      v494 = 0;
      do
      {
        v503 = *(*(&v722 + 1) + ((&v502[4][v724] >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v502 + 8) + v724) & 0xF);
        if (*(v503 + 40) == 3 || *(v503 + 208) == 3)
        {
          v494 = 1;
        }

        v504 = v502[1];
        if (v504)
        {
          do
          {
            v505 = v504;
            v504 = *v504;
          }

          while (v504);
        }

        else
        {
          do
          {
            v505 = v502[2];
            _ZF = *v505 == v502;
            v502 = v505;
          }

          while (!_ZF);
        }

        v502 = v505;
      }

      while (v505 != v501 + 6);
LABEL_917:
      v493 = 1;
      if (v494)
      {
        goto LABEL_941;
      }

      goto LABEL_942;
    }

LABEL_952:
    v491 += 376;
    if (v491 - *v490 == 6016)
    {
      v506 = v490[1];
      ++v490;
      v491 = v506;
    }

    v488 = *(&v722 + 1);
    v489 = v723;
  }

  v716 = 0;
  v717 = 0;
  v715 = &v716;
  v747 = 0;
  v746 = 0;
  __p = &v746;
  v749[0] = 0;
  v749[1] = -1;
  v749[2] = -1;
  sub_1016AB68C(v714, v749, &__p);
  v749[0] = 1;
  v749[1] = -1;
  v749[2] = -1;
  sub_1016AB68C(v713, v749, &__p);
  sub_1016ABC20(v716);
  v716 = 0;
  v717 = 0;
  v715 = &v716;
  v507 = __p;
  if (__p != &v746)
  {
    while (1)
    {
      v508 = *(v507 + 4);
      v509 = v726;
      if (!v726)
      {
        goto LABEL_977;
      }

      v511 = *(v507 + 5);
      v510 = *(v507 + 6);
      v512 = &v726;
      do
      {
        v513 = *(v509 + 4);
        v514 = v513 < v508;
        if (v513 == v508)
        {
          v515 = *(v509 + 5);
          v514 = v515 < v511;
          if (v515 == v511)
          {
            v514 = *(v509 + 6) < v510;
          }
        }

        v516 = v514;
        v517 = v516 == 0;
        if (v516)
        {
          v518 = 8;
        }

        else
        {
          v518 = 0;
        }

        if (v517)
        {
          v512 = v509;
        }

        v509 = *&v509[v518];
      }

      while (v509);
      if (&v726 == v512)
      {
        goto LABEL_977;
      }

      v519 = v512[4];
      v520 = v508 < v519;
      if (v508 == v519)
      {
        v521 = v512[5];
        v520 = v511 < v521;
        if (v511 == v521)
        {
          v520 = v510 < v512[6];
        }
      }

      if (v520)
      {
LABEL_977:
        v522 = 0;
      }

      else
      {
        if (v512[7] & 1) != 0 || (*(v512 + 57))
        {
          goto LABEL_992;
        }

        v522 = *(v512 + 58);
      }

      if (v508 == 1)
      {
        break;
      }

      if (!v508)
      {
        v523 = sub_1016ABA48(v507 + 8, v714, v713);
        goto LABEL_982;
      }

      if (v522)
      {
LABEL_985:
        v524 = *(v507 + 72);
        v731 = *(v507 + 56);
        v732 = v524;
        v525 = *(v507 + 105);
        *v749 = *(v507 + 89);
        *&v749[2] = v525;
        v526 = *(v507 + 16);
        *(&v749[3] + 7) = *(v507 + 15);
        v527 = *(v507 + 17);
        if (v527 != v526)
        {
          v528 = 0xAAAAAAAAAAAAAAABLL * ((v527 - v526) >> 3);
          if (v528 <= 0xAAAAAAAAAAAAAAALL)
          {
            sub_1016ABC7C(v528);
          }

          sub_1000CE3D4();
        }

        v748 = v507 + 32;
        v529 = sub_1016ABCD4(&v715, v507 + 4);
        v530 = v529[16];
        v531 = v732;
        *(v529 + 7) = v731;
        *(v529 + 9) = v531;
        v532 = *&v749[2];
        *(v529 + 89) = *v749;
        *(v529 + 88) = 0;
        *(v529 + 105) = v532;
        v529[15] = *(&v749[3] + 7);
        v529[17] = v530;
      }

LABEL_992:
      v533 = *(v507 + 1);
      if (v533)
      {
        do
        {
          v534 = v533;
          v533 = *v533;
        }

        while (v533);
      }

      else
      {
        do
        {
          v534 = *(v507 + 2);
          _ZF = *v534 == v507;
          v507 = v534;
        }

        while (!_ZF);
      }

      v507 = v534;
      if (v534 == &v746)
      {
        goto LABEL_998;
      }
    }

    v523 = sub_1016ABA48(v507 + 8, v713, v714);
LABEL_982:
    if (v523 > 0)
    {
      goto LABEL_985;
    }

    goto LABEL_992;
  }

LABEL_998:
  sub_1016ABC20(v746);
  v731 = xmmword_1019ADE80;
  v732.i64[0] = -1;
  v535 = v718[1];
  v536 = v719;
  v537 = v718[1] + 8 * (v720 / 0xAA);
  if (v719 == v718[1])
  {
    v538 = 0;
  }

  else
  {
    v538 = (*v537 + 24 * (v720 % 0xAA));
  }

  while (1)
  {
    v539 = v536 == v535 ? 0 : v535[(*(&v720 + 1) + v720) / 0xAAuLL] + 24 * ((*(&v720 + 1) + v720) % 0xAAuLL);
    if (v538 == v539)
    {
      break;
    }

    memset(v749 + 6, 255, 24);
    v540 = *v538;
    v541 = v538[1];
    v542 = 0.0;
    if ((v541 - *v538) >= 0x40)
    {
      v543 = (v540 + 2);
      if (v540 + 2 != v541)
      {
        v544 = 0;
        do
        {
          v545 = *(v543 - 2);
          v546 = *v543;
          if (v545 != *v543)
          {
            if ((*&v545 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v546 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_1013;
            }

            v548 = fabs(v545);
            v549 = fabs(v546);
            v550 = vabdd_f64(v545, v546);
            if (v548 >= v549)
            {
              v551 = v548;
            }

            else
            {
              v551 = v549;
            }

            if (v551 < 1.0)
            {
              v551 = 1.0;
            }

            if (v550 > v551 * 2.22044605e-16)
            {
LABEL_1013:
              v542 = v542 + sub_101686964(v543 - 2, v543);
              v544 += sub_101686BB8(v543 - 2, v543);
            }
          }

          v543 += 2;
        }

        while (v543 != v541);
        if (v544)
        {
          v552 = (v544 >> 1) + 1;
          v553 = fabs(v542);
          v554 = -v553;
          v555 = -(v553 - v552 * 6.28318531);
          if (v542 <= 0.0)
          {
            v542 = v555;
          }

          else
          {
            v542 = -(v554 + v552 * 6.28318531);
          }
        }
      }
    }

    v556 = *v538;
    v557 = v538[1];
    if (*v538 != v557)
    {
      v7 = *v556;
      v6 = v556[1];
    }

    __p = &v731;
    v558 = sub_1016ABCD4(&v715, &v731);
    v560 = v558 + 16;
    v559 = v558[16];
    *(v558 + 56) = v556 != v557;
    v558[8] = v7;
    v558[9] = v6;
    *(v558 + 10) = v542;
    *(v558 + 44) = 0;
    *(v558 + 90) = *v749;
    *(v558 + 13) = *(&v749[1] + 6);
    v558[15] = 0xBFF0000000000000;
    if (v559)
    {
      v558[17] = v559;
      operator delete(v559);
      *v560 = 0;
      v560[1] = 0;
      v560[2] = 0;
    }

    *v560 = 0;
    v560[1] = 0;
    v560[2] = 0;
    v749[0] = &v731;
    *(sub_1016ABCD4(&v715, &v731) + 88) = 0;
    ++*&v731.f64[1];
    v538 += 3;
    if ((v538 - *v537) == 4080)
    {
      v561 = v537[1];
      ++v537;
      v538 = v561;
    }

    v535 = v718[1];
    v536 = v719;
  }

  if (v717)
  {
    if (v717 < 0x38E38E38E38E38FLL)
    {
      operator new();
    }

    sub_1000CE3D4();
  }

  v562 = v715;
  if (v715 != &v716)
  {
    v563 = 0;
    v564 = 0;
    v565 = 0;
    v689 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    v692 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    __asm { FMOV            V1.2D, #1.0 }

    __srcb = vdupq_n_s64(0x3CB0000000000000uLL);
    v696 = _Q1;
    while (1)
    {
      v569 = *(v562 + 10);
      v570 = -v569;
      if (!*(v562 + 88))
      {
        v570 = *(v562 + 10);
      }

      v571 = 72 * v563;
      v572 = *(v562 + 2);
      *(v571 + 16) = v562[6];
      *v571 = v572;
      *(v571 + 24) = v570;
      *(v571 + 32) = fabs(v569);
      v573 = v562[4];
      if (!v573)
      {
        break;
      }

      if (v573 == 1)
      {
        v576 = v562[6];
        if (v576 < -1)
        {
          goto LABEL_1207;
        }

        v577 = v713;
LABEL_1051:
        v578 = v577[3];
        v579 = v577[4] - v578;
        v580 = 0xAAAAAAAAAAAAAAABLL * v579;
        if (v576 >= -1431655765 * v579)
        {
          v682 = 94;
          goto LABEL_1209;
        }

        v581 = v577;
        if ((v576 & 0x8000000000000000) == 0)
        {
          if (v580 < v576)
          {
            v682 = 96;
            v683 = "pos";
            v684 = "range.hpp";
            v685 = "i <= boost::size(rng)";
            goto LABEL_1213;
          }

          v581 = &v578[3 * v576];
        }

        goto LABEL_1057;
      }

      if (v573 == 2)
      {
        v574 = v562[5];
        if (*(&v720 + 1) < v574)
        {
          v682 = 96;
          v683 = "pos";
          v684 = "range.hpp";
          v685 = "i <= boost::size(rng)";
LABEL_1213:
          __assert_rtn(v683, v684, v682, v685);
        }

        if (v719 == v718[1])
        {
          v575 = 0;
        }

        else
        {
          v575 = (*(v718[1] + v720 / 0xAA) + 24 * (v720 % 0xAA));
        }

        v749[0] = v718[1] + 8 * (v720 / 0xAA);
        v749[1] = v575;
        sub_10164FCF4(v749, v574);
        v581 = v749[1];
LABEL_1057:
        v699 = v563;
        v700 = v565;
        v582 = v564;
        v584 = *v581;
        v583 = v581[1];
        *(v571 + 40) = v692;
        v585 = (v571 + 40);
        v586 = v583 - v584;
        v587 = 0x1FFFFFFFFFFFFFFELL;
        if ((v583 - v584) < 0x11)
        {
          v587 = 0;
        }

        v588 = &v583[v587];
        *(v571 + 56) = v689;
        if (v584 != &v583[v587])
        {
          if (!v584)
          {
            __assert_rtn("get", "pointing_segment.hpp", 101, "s.first != __null");
          }

          v589 = v584 + 2;
          if (v586 < 0x11)
          {
            v589 = v584;
          }

          v590 = v584[1];
          v592 = *v589;
          v591 = v589[1];
          v740 = *v584;
          v749[0] = v590;
          sub_101690AC8(&v740, v749, 1);
          v741 = v592;
          v749[0] = v591;
          sub_101690AC8(&v741, v749, 1);
          v749[0] = v590;
          *&v731.f64[0] = v591;
          sub_101690D84(&v740, v749, &v741, v731.f64);
          v593 = v741;
          v594 = v749[0];
          v595 = v731.f64[0];
          *(v571 + 40) = v740;
          *(v571 + 48) = v594;
          *(v571 + 56) = v593;
          *(v571 + 64) = v595;
          v596 = (v584 + 2);
          if (v596 != v588)
          {
            v597 = v596;
            do
            {
              v598 = v596 + 2;
              if (v586 < 0x11)
              {
                v598 = v596;
              }

              *&v749[4] = 0u;
              v750 = 0u;
              v599 = *(v597 + 1);
              v601 = *v598;
              v600 = v598[1];
              v744 = *v597;
              v731.f64[0] = v599;
              sub_101690AC8(&v744, v731.f64, 1);
              v748 = v601;
              *&v731.f64[0] = v600;
              sub_101690AC8(&v748, v731.f64, 1);
              v731.f64[0] = v599;
              __p = v600;
              sub_101690D84(&v744, v731.f64, &v748, &__p);
              v749[0] = v744;
              v749[1] = *&v731.f64[0];
              v749[2] = v748;
              v749[3] = __p;
              v602 = *v585;
              v603 = *(v571 + 56);
              if (vmaxv_u16(vmovn_s32(vmvnq_s8(vuzp1q_s32(vceqq_f64(*v585, vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL)), vceqq_f64(v603, vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL)))))))
              {
                __p = *(v571 + 48);
                v731.f64[0] = v602.f64[0];
                v742 = v603.f64[1];
                v707 = *&v603.f64[1];
                v743 = *&v603.f64[0];
                v712 = *&v602.f64[1];
                v604 = vabdd_f64(v602.f64[0], v603.f64[0]);
                if (v604 < 360.0)
                {
                  v610 = vabdd_f64(360.0, v604);
                  v611 = fmax(v604, 360.0);
                  if (v611 < 1.0)
                  {
                    v611 = 1.0;
                  }

                  v605 = v610 <= v611 * 2.22044605e-16;
                }

                else
                {
                  v605 = 1;
                }

                sub_101692350(v731.f64, &__p, &v743, &v742, v605);
                v608 = v712;
                v609 = v707;
                v607 = v731.f64[0];
                v606 = v743;
              }

              else
              {
                v606 = 0xFFEFFFFFFFFFFFFFLL;
                v607 = 1.79769313e308;
                v608 = 0x7FEFFFFFFFFFFFFFLL;
                v609 = 0xFFEFFFFFFFFFFFFFLL;
              }

              v749[4] = *&v607;
              v749[5] = v608;
              *&v750 = v606;
              *(&v750 + 1) = v609;
              sub_1016914BC(v749, (v571 + 40));
              v597 += 2;
              v596 += 2;
            }

            while (v597 != v588);
          }
        }

        v570 = *(v571 + 24);
        v564 = v582;
        v565 = v700;
        v563 = v699;
      }

      v612 = *(v571 + 40);
      v613 = vabsq_f64(v612);
      *(v571 + 40) = vsubq_f64(v612, vmulq_f64(vbslq_s8(vcgtq_f64(v696, v613), v696, v613), __srcb));
      v614 = *(v571 + 56);
      v615 = vabsq_f64(v614);
      *(v571 + 56) = vaddq_f64(v614, vmulq_f64(vbslq_s8(vcgtq_f64(v696, v615), v696, v615), __srcb));
      if (v570 > 0.0)
      {
        ++v565;
        v564 = v563;
      }

      v616 = v562[1];
      if (v616)
      {
        do
        {
          v617 = v616;
          v616 = *v616;
        }

        while (v616);
      }

      else
      {
        do
        {
          v617 = v562[2];
          _ZF = *v617 == v562;
          v562 = v617;
        }

        while (!_ZF);
      }

      ++v563;
      v562 = v617;
      if (v617 == &v716)
      {
        if (v565)
        {
          if (v565 == 1)
          {
            *v749 = *(72 * v564);
            v749[2] = *(72 * v564 + 0x10);
            *&v731.f64[0] = v749;
            sub_1016ABCD4(&v715, v749);
            v618 = 1;
          }

          else
          {
            v749[0] = v714;
            v749[1] = v713;
            v749[2] = v718;
            v749[3] = &v715;
            v749[5] = 0;
            v749[4] = a5;
            v618 = 0;
          }
        }

        else
        {
          v618 = 1;
        }

        v562 = v715;
        if (v715 == &v716)
        {
          v619 = 1;
        }

        else
        {
          v619 = v618;
        }

        if ((v619 & 1) == 0)
        {
          do
          {
            if ((v562[12] & 0x8000000000000000) == 0)
            {
              v749[0] = v562 + 12;
              v620 = sub_1016ABCD4(&v715, v562 + 12);
              sub_1016ABE24((v620 + 16), v562 + 2);
            }

            v621 = v562[1];
            if (v621)
            {
              do
              {
                v622 = v621;
                v621 = *v621;
              }

              while (v621);
            }

            else
            {
              do
              {
                v622 = v562[2];
                _ZF = *v622 == v562;
                v562 = v622;
              }

              while (!_ZF);
            }

            v562 = v622;
          }

          while (v622 != &v716);
          v562 = v715;
        }

        goto LABEL_1103;
      }
    }

    v576 = v562[6];
    if (v576 < -1)
    {
LABEL_1207:
      v682 = 94;
LABEL_1209:
      v683 = "apply";
      v684 = "get_ring.hpp";
      v685 = "id.ring_index >= -1 && id.ring_index < int(boost::size(interior_rings(polygon)))";
      goto LABEL_1213;
    }

    v577 = v714;
    goto LABEL_1051;
  }

LABEL_1103:
  if (v562 != &v716)
  {
    do
    {
      if ((*(v562 + 89) & 1) == 0 && v562[12] == -1)
      {
        memset(v749, 0, sizeof(v749));
        v731 = *(v562 + 2);
        v732.i64[0] = v562[6];
        sub_1016AE1DC(v749, v714, v713, v718, &v731, *(v562 + 88), 0);
        v624 = v562[16];
        v623 = v562[17];
        while (v624 != v623)
        {
          v625 = v716;
          if (v716)
          {
            v627 = *v624;
            v626 = v624[1];
            v628 = &v716;
            v629 = v624[2];
            do
            {
              v630 = v625[4];
              v631 = v630 < v627;
              if (v630 == v627)
              {
                v632 = v625[5];
                v631 = v632 < v626;
                if (v632 == v626)
                {
                  v631 = v625[6] < v629;
                }
              }

              v633 = v631;
              v634 = v633 == 0;
              if (v633)
              {
                v635 = 1;
              }

              else
              {
                v635 = 0;
              }

              if (v634)
              {
                v628 = v625;
              }

              v625 = v625[v635];
            }

            while (v625);
            if (&v716 != v628)
            {
              v636 = v628[4];
              v637 = v627 < v636;
              if (v627 == v636)
              {
                v638 = v628[5];
                v637 = v626 < v638;
                if (v626 == v638)
                {
                  v637 = v629 < v628[6];
                }
              }

              if (!v637 && (*(v628 + 89) & 1) == 0)
              {
                v731 = *v624;
                v732.i64[0] = v624[2];
                sub_1016AE1DC(v749, v714, v713, v718, &v731, *(v628 + 88), 1);
                v623 = v562[17];
              }
            }
          }

          v624 += 3;
        }

        v639 = v749[1];
        v640 = (v749[1] - v749[0]) >> 4;
        for (kk = v749[3]; kk != v749[4]; kk += 3)
        {
          v642 = *kk;
          v643 = kk[1];
          v640 += (v643 - v642) >> 4;
        }

        if (v640 >= 4)
        {
          v644 = 0.0;
          v645 = 0.0;
          if ((v749[1] - v749[0]) >= 0x40)
          {
            v646 = (v749[0] + 16);
            if (v749[0] + 16 != v749[1])
            {
              v647 = 0;
              do
              {
                v648 = *(v646 - 2);
                v649 = *v646;
                if (v648 != *v646)
                {
                  if ((*&v648 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v649 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    goto LABEL_1143;
                  }

                  v651 = fabs(v648);
                  v652 = fabs(v649);
                  v653 = vabdd_f64(v648, v649);
                  if (v651 >= v652)
                  {
                    v654 = v651;
                  }

                  else
                  {
                    v654 = v652;
                  }

                  if (v654 < 1.0)
                  {
                    v654 = 1.0;
                  }

                  if (v653 > v654 * 2.22044605e-16)
                  {
LABEL_1143:
                    v645 = v645 + sub_101686964(v646 - 2, v646);
                    v647 += sub_101686BB8(v646 - 2, v646);
                  }
                }

                v646 += 2;
              }

              while (v646 != v639);
              if (v647)
              {
                v655 = (v647 >> 1) + 1;
                v656 = fabs(v645);
                v657 = -v656;
                v658 = -(v656 - v655 * 6.28318531);
                if (v645 <= 0.0)
                {
                  v645 = v658;
                }

                else
                {
                  v645 = -(v657 + v655 * 6.28318531);
                }
              }
            }
          }

          v659 = v749[3];
          if (v749[3] != v749[4])
          {
            v644 = 0.0;
            do
            {
              v660 = *v659;
              v661 = v659[1];
              v662 = 0.0;
              if (v661 - *v659 >= 0x40)
              {
                v663 = (v660 + 16);
                if ((v660 + 16) != v661)
                {
                  v664 = 0;
                  do
                  {
                    v665 = *(v663 - 2);
                    v666 = *v663;
                    if (v665 != *v663)
                    {
                      if ((*&v665 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v666 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                      {
                        goto LABEL_1167;
                      }

                      v668 = fabs(v665);
                      v669 = fabs(v666);
                      v670 = vabdd_f64(v665, v666);
                      if (v668 >= v669)
                      {
                        v671 = v668;
                      }

                      else
                      {
                        v671 = v669;
                      }

                      if (v671 < 1.0)
                      {
                        v671 = 1.0;
                      }

                      if (v670 > v671 * 2.22044605e-16)
                      {
LABEL_1167:
                        v662 = v662 + sub_101686964(v663 - 2, v663);
                        v664 += sub_101686BB8(v663 - 2, v663);
                      }
                    }

                    v663 += 2;
                  }

                  while (v663 != v661);
                  if (v664)
                  {
                    v672 = (v664 >> 1) + 1;
                    v673 = fabs(v662);
                    v674 = -v673;
                    v675 = -(v673 - v672 * 6.28318531);
                    if (v662 <= 0.0)
                    {
                      v662 = v675;
                    }

                    else
                    {
                      v662 = -(v674 + v672 * 6.28318531);
                    }
                  }
                }
              }

              v644 = v644 + v662;
              v659 += 3;
            }

            while (v659 != v749[4]);
          }

          v676 = v645 + v644;
          if (v645 + v644 != 0.0)
          {
            if (COERCE_UNSIGNED_INT64(fabs(v645 + v644)) <= 0x7FEFFFFFFFFFFFFFLL)
            {
              v677 = fabs(v676);
              if (v677 >= 1.0)
              {
                v678 = v677;
              }

              else
              {
                v678 = 1.0;
              }

              if (v676 > 0.0 && v677 > v678 * 2.22044605e-16)
              {
LABEL_1191:
                operator new();
              }
            }

            else if (v676 > 0.0)
            {
              goto LABEL_1191;
            }
          }
        }

        *&v731.f64[0] = &v749[3];
        sub_101686E34(&v731);
        if (v749[0])
        {
          v749[1] = v749[0];
          operator delete(v749[0]);
        }
      }

      v679 = v562[1];
      if (v679)
      {
        do
        {
          v680 = v679;
          v679 = *v679;
        }

        while (v679);
      }

      else
      {
        do
        {
          v680 = v562[2];
          _ZF = *v680 == v562;
          v562 = v680;
        }

        while (!_ZF);
      }

      v562 = v680;
    }

    while (v680 != &v716);
  }

  sub_1016ABC20(v716);
  sub_1016AE940(v718);
  sub_100034450(v726);
  sub_1016AEABC(v729);
  sub_1016AEB10(&v722);
  return v686;
}

void sub_10168FFD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, void *a33, uint64_t a34, void *a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, char a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, void *a52, uint64_t a53)
{
  if (v53)
  {
    operator delete(v53);
  }

  sub_1016ABC20(a33);
  sub_1016AE940(&a35);
  sub_100034450(a50);
  sub_1016AEABC(a53);
  sub_1016AEB10(&a43);
  _Unwind_Resume(a1);
}

void sub_101690224(uint64_t a1, float64x2_t **a2, unsigned int a3)
{
  a2[1] = *a2;
  v5 = a3;
  v6 = *a1;
  v7 = *(a1 + 8);
  if (v7 - *a1 >= 0x11)
  {
    *&v25 = v5;
    *(&v25 + 1) = -1;
    v26 = -1;
    sub_101690334(a2, v6, v7, &v25);
  }

  v9 = *(a1 + 24);
  v8 = *(a1 + 32);
  if (v9 != v8)
  {
    v10 = 0;
    do
    {
      v11 = *v9;
      v12 = v9[1];
      if ((v12 - *v9) >= 0x11)
      {
        *&v25 = v5;
        *(&v25 + 1) = -1;
        v26 = v10;
        sub_101690334(a2, v11, v12, &v25);
        v8 = *(a1 + 32);
      }

      v9 += 3;
      ++v10;
    }

    while (v9 != v8);
  }

  v13 = *a2;
  v14 = a2[1];
  if (*a2 != v14)
  {
    __asm { FMOV            V0.2D, #1.0 }

    do
    {
      v20 = v13[2];
      v21 = v13[3];
      v22 = vabsq_f64(v20);
      v23 = vsubq_f64(v20, vmulq_f64(vbslq_s8(vcgtq_f64(_Q0, v22), _Q0, v22), xmmword_1019ADE90));
      v24 = vabsq_f64(v21);
      v13[2] = v23;
      v13[3] = vaddq_f64(v21, vmulq_f64(vbslq_s8(vcgtq_f64(_Q0, v24), _Q0, v24), xmmword_1019ADE90));
      v13 = (v13 + 120);
    }

    while (v13 != v14);
  }
}

void sub_101690334(void *a1, double *a2, double *a3, __int128 *a4)
{
  if (a3 == a2)
  {
    return;
  }

  v5 = a1;
  *(&v52 + 1) = -1;
  v53 = -1;
  v56 = -1;
  v57 = 0xFFFFFFFFFFFFFFFFLL;
  v58 = 0;
  v59 = 0;
  v60 = -1;
  v61 = 0;
  v47 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  v48 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  v54 = v48;
  v55 = v47;
  v51 = 0;
  *&v52 = -1;
  v6 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3);
  v7 = a2 + 2;
  if (a2 + 2 == a3)
  {
    goto LABEL_83;
  }

  v46 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3);
  v9 = 0;
  v10 = 0;
  v50 = (a3 - a2) >> 4;
  v12 = *a2;
  v11 = a2[1];
  v13 = 1;
  v14 = 1;
  do
  {
    v16 = *v7;
    v15 = v7[1];
    v17 = vabdd_f64(*v7, v12);
    v18 = 180.0;
    if (v17 == 180.0)
    {
      goto LABEL_5;
    }

    v19 = v16 - v12;
    if (COERCE__INT64(fabs(v16 - v12)) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v25 = fabs(v17 + -180.0);
      v18 = 180.0;
      if (v17 < 180.0)
      {
        v17 = 180.0;
      }

      if (v17 < 1.0)
      {
        v17 = 1.0;
      }

      if (v25 <= v17 * 2.22044605e-16)
      {
        goto LABEL_5;
      }
    }

    if (v19 <= 180.0)
    {
      if (v19 < -180.0)
      {
        v18 = fmod(v19 + -180.0, 360.0) + 180.0;
LABEL_5:
        v19 = v18;
      }
    }

    else
    {
      v19 = fmod(v19 + 180.0, 360.0) + -180.0;
      v18 = 180.0;
      if (v19 == -180.0)
      {
        goto LABEL_5;
      }

      if ((*&v19 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v26 = fabs(v19);
        v27 = fabs(v19 + 180.0);
        if (v26 < 180.0)
        {
          v26 = 180.0;
        }

        if (v26 < 1.0)
        {
          v26 = 1.0;
        }

        v28 = v27 > v26 * 2.22044605e-16;
        v18 = 180.0;
        if (!v28)
        {
          goto LABEL_5;
        }
      }
    }

    if (v19 >= 0.0)
    {
      v20 = 0;
    }

    else
    {
      v20 = -1;
    }

    if (v19 > 0.0)
    {
      v21 = 1;
    }

    else
    {
      v21 = v20;
    }

    if (v15 >= v11)
    {
      v22 = 0;
    }

    else
    {
      v22 = -1;
    }

    if (v15 > v11)
    {
      v23 = 1;
    }

    else
    {
      v23 = v22;
    }

    if (!v21)
    {
      if (v12 == v16)
      {
        goto LABEL_55;
      }

      if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v16 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v29 = fabs(v12);
        v30 = fabs(v16);
        v31 = vabdd_f64(v12, v16);
        if (v29 < v30)
        {
          v29 = v30;
        }

        if (v29 < 1.0)
        {
          v29 = 1.0;
        }

        if (v31 <= v29 * 2.22044605e-16)
        {
LABEL_55:
          if (v11 == v15)
          {
            goto LABEL_21;
          }

          if ((*&v11 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v15 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            v32 = fabs(v11);
            v33 = fabs(v15);
            v34 = vabdd_f64(v11, v15);
            if (v32 < v33)
            {
              v32 = v33;
            }

            if (v32 < 1.0)
            {
              v32 = 1.0;
            }

            if (v34 <= v32 * 2.22044605e-16)
            {
LABEL_21:
              v24 = 1;
              v21 = -99;
              v23 = -99;
              if (!v9)
              {
                goto LABEL_67;
              }

              goto LABEL_58;
            }
          }
        }
      }

      v21 = 0;
    }

    v24 = 0;
    if (!v9)
    {
      goto LABEL_67;
    }

LABEL_58:
    if (v21 != v51 || v9 > 0xA || v23 != HIDWORD(v51))
    {
      if ((v59 & 1) == 0)
      {
        v46 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3);
      }

      sub_101690964(a1, &v51);
      v57 = xmmword_1019ADEA0;
      v51 = 0;
      v54 = v48;
      v55 = v47;
      LOWORD(v61) = 0;
LABEL_67:
      v52 = *a4;
      v53 = *(a4 + 2);
      LOBYTE(v59) = v24;
      v60 = v10;
      v56 = v13 - 1;
      v58 = v50;
      if (!(v24 & 1 | ((v14 & 1) == 0)))
      {
        v14 = 0;
        LOBYTE(v61) = 1;
      }

      v51 = __PAIR64__(v23, v21);
      v67 = v11;
      v68[0] = v12;
      sub_101690AC8(v68, &v67, 1);
      v37 = v68[0];
      v67 = v15;
      v68[0] = v16;
      sub_101690AC8(v68, &v67, 1);
      v38 = v68[0];
      v67 = v11;
      v68[0] = v37;
      v65 = v15;
      v66 = v38;
      sub_101690D84(v68, &v67, &v66, &v65);
      v54.f64[0] = v68[0];
      v54.f64[1] = v67;
      v55.f64[0] = v66;
      v55.f64[1] = v65;
      v9 = 1;
      goto LABEL_70;
    }

    v62 = v12;
    v68[0] = v11;
    sub_101690AC8(&v62, v68, 1);
    v63 = v16;
    v68[0] = v15;
    sub_101690AC8(&v63, v68, 1);
    v67 = v11;
    v66 = v15;
    sub_101690D84(&v62, &v67, &v63, &v66);
    v68[0] = v62;
    v68[1] = v67;
    v68[2] = v63;
    v68[3] = v66;
    if (vmaxv_u16(vmovn_s32(vmvnq_s8(vuzp1q_s32(vceqq_f64(v54, vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL)), vceqq_f64(v55, vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL)))))))
    {
      v66 = v54.f64[1];
      v67 = v54.f64[0];
      v64 = v55.f64[1];
      v65 = v55.f64[0];
      v35 = vabdd_f64(v54.f64[0], v55.f64[0]);
      if (v35 < 360.0)
      {
        v43 = vabdd_f64(360.0, v35);
        v44 = fmax(v35, 360.0);
        if (v44 < 1.0)
        {
          v44 = 1.0;
        }

        v36 = v43 <= v44 * 2.22044605e-16;
      }

      else
      {
        v36 = 1;
      }

      v41 = v54.f64[1];
      v42 = v55.f64[1];
      sub_101692350(&v67, &v66, &v65, &v64, v36);
      v40 = v67;
      v39 = v65;
    }

    else
    {
      v39 = -1.79769313e308;
      v40 = 1.79769313e308;
      v41 = 1.79769313e308;
      v42 = -1.79769313e308;
    }

    v68[4] = v40;
    v68[5] = v41;
    v68[6] = v39;
    v68[7] = v42;
    sub_1016914BC(v68, v54.f64);
    v9 = *(&v57 + 1) + 1;
LABEL_70:
    v10 += v24 ^ 1u;
    v7 += 2;
    *&v57 = v13;
    *(&v57 + 1) = v9;
    ++v13;
    v12 = v16;
    v11 = v15;
  }

  while (v7 != a3);
  if (v9)
  {
    v5 = a1;
    v6 = v46;
    if ((v59 & 1) == 0)
    {
      v6 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3);
    }

    sub_101690964(a1, &v51);
  }

  else
  {
    v5 = a1;
    v6 = v46;
  }

LABEL_83:
  if (v6 < 0xEEEEEEEEEEEEEEEFLL * ((v5[1] - *v5) >> 3))
  {
    v45 = *v5 + 120 * v6;
    if ((*(v45 + 96) & 1) == 0)
    {
      *(v45 + 113) = 1;
    }
  }
}

void sub_101690964(uint64_t a1, __int128 *a2)
{
  v3 = *(a1 + 8);
  v4 = *(a1 + 16);
  if (v3 >= v4)
  {
    v12 = *a1;
    v13 = v3 - *a1;
    v14 = 0xEEEEEEEEEEEEEEEFLL * (v13 >> 3) + 1;
    if (v14 > 0x222222222222222)
    {
      sub_1000CE3D4();
    }

    v15 = 0xEEEEEEEEEEEEEEEFLL * ((v4 - v12) >> 3);
    if (2 * v15 > v14)
    {
      v14 = 2 * v15;
    }

    if (v15 >= 0x111111111111111)
    {
      v16 = 0x222222222222222;
    }

    else
    {
      v16 = v14;
    }

    if (v16)
    {
      if (v16 <= 0x222222222222222)
      {
        operator new();
      }

      sub_100013D10();
    }

    v17 = a2[5];
    v18 = 8 * (v13 >> 3);
    *(v18 + 64) = a2[4];
    *(v18 + 80) = v17;
    *(v18 + 96) = a2[6];
    *(v18 + 112) = *(a2 + 14);
    v19 = a2[1];
    *v18 = *a2;
    *(v18 + 16) = v19;
    v20 = a2[3];
    v11 = v18 + 120;
    v21 = v18 - v13;
    *(v18 + 32) = a2[2];
    *(v18 + 48) = v20;
    memcpy((v18 - v13), v12, v13);
    *a1 = v21;
    *(a1 + 8) = v11;
    *(a1 + 16) = 0;
    if (v12)
    {
      operator delete(v12);
    }
  }

  else
  {
    v5 = *a2;
    v6 = a2[1];
    v7 = a2[3];
    *(v3 + 32) = a2[2];
    *(v3 + 48) = v7;
    *v3 = v5;
    *(v3 + 16) = v6;
    v8 = a2[4];
    v9 = a2[5];
    v10 = a2[6];
    *(v3 + 112) = *(a2 + 14);
    *(v3 + 80) = v9;
    *(v3 + 96) = v10;
    *(v3 + 64) = v8;
    v11 = v3 + 120;
  }

  *(a1 + 8) = v11;
}

void sub_101690AC8(double *a1, double *a2, int a3)
{
  v6 = *a1;
  v7 = fabs(*a1);
  v8 = 180.0;
  if (v7 == 180.0)
  {
    goto LABEL_2;
  }

  if ((*&v6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v10 = fabs(v7 + -180.0);
    v8 = 180.0;
    if (v7 < 180.0)
    {
      v7 = 180.0;
    }

    if (v7 < 1.0)
    {
      v7 = 1.0;
    }

    if (v10 <= v7 * 2.22044605e-16)
    {
      goto LABEL_2;
    }
  }

  v8 = 180.0;
  if (v6 <= 180.0)
  {
    if (v6 >= -180.0)
    {
      goto LABEL_3;
    }

    v8 = fmod(v6 + -180.0, 360.0) + 180.0;
    goto LABEL_2;
  }

  v6 = fmod(v6 + 180.0, 360.0) + -180.0;
  *a1 = v6;
  if (v6 == -180.0)
  {
    goto LABEL_2;
  }

  if ((*&v6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v11 = fabs(v6);
    v8 = 180.0;
    v12 = fabs(v6 + 180.0);
    if (v11 < 180.0)
    {
      v11 = 180.0;
    }

    if (v11 < 1.0)
    {
      v11 = 1.0;
    }

    if (v12 <= v11 * 2.22044605e-16)
    {
LABEL_2:
      *a1 = v8;
      v6 = v8;
    }
  }

  if (!a3)
  {
    goto LABEL_27;
  }

LABEL_3:
  v9 = fabs(*a2);
  if (v9 == 90.0)
  {
    goto LABEL_5;
  }

  if ((*a2 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    goto LABEL_27;
  }

  v13 = fabs(v9 + -90.0);
  if (v9 < 90.0)
  {
    v9 = 90.0;
  }

  if (v9 < 1.0)
  {
    v9 = 1.0;
  }

  if (v13 <= v9 * 2.22044605e-16)
  {
LABEL_5:
    *a1 = 0.0;
    v6 = 0.0;
  }

  else
  {
LABEL_27:
    if (v6 <= -180.0)
    {
      goto LABEL_44;
    }
  }

  if ((*&v6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v14 = fabs(v6);
    v15 = fabs(v6 + 180.0);
    if (v14 < 180.0)
    {
      v14 = 180.0;
    }

    if (v14 < 1.0)
    {
      v14 = 1.0;
    }

    if (v15 <= v14 * 2.22044605e-16)
    {
LABEL_44:
      __assert_rtn("apply", "normalize_spheroidal_coordinates.hpp", 311, "math::smaller(constants::min_longitude(), longitude)");
    }
  }

  if (v6 > 180.0)
  {
    if (v6 == INFINITY)
    {
      goto LABEL_45;
    }

    v16 = fabs(v6 + -180.0);
    if (v6 < 180.0)
    {
      v6 = 180.0;
    }

    if (v6 < 1.0)
    {
      v6 = 1.0;
    }

    if (v16 > v6 * 2.22044605e-16)
    {
LABEL_45:
      __assert_rtn("apply", "normalize_spheroidal_coordinates.hpp", 312, "! math::larger(longitude, constants::max_longitude())");
    }
  }
}

void sub_101690D84(double *a1, double *a2, double *a3, double *a4)
{
  v8 = fabs(*a2);
  v9 = 90.0;
  if (v8 == 90.0)
  {
    v10 = 1;
  }

  else if ((*a2 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v11 = fabs(v8 + -90.0);
    if (v8 < 90.0)
    {
      v8 = 90.0;
    }

    if (v8 < 1.0)
    {
      v8 = 1.0;
    }

    v10 = v11 <= v8 * 2.22044605e-16;
  }

  else
  {
    v10 = 0;
  }

  v12 = fabs(*a4);
  if (v12 == 90.0)
  {
    v13 = 1;
  }

  else
  {
    if ((*a4 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
    {
      v13 = 0;
      v14 = !v10;
      v15 = 1;
      goto LABEL_22;
    }

    v16 = fabs(v12 + -90.0);
    if (v12 >= 90.0)
    {
      v9 = v12;
    }

    if (v9 < 1.0)
    {
      v9 = 1.0;
    }

    v13 = v16 <= v9 * 2.22044605e-16;
  }

  v14 = !v10;
  v15 = !v13;
  if (v10 && (v15 & 1) == 0)
  {
    *a1 = 0.0;
    *a3 = 0.0;
    v17 = *a1;
    v18 = 0.0;
    goto LABEL_28;
  }

LABEL_22:
  if (v14 || v13)
  {
    v17 = *a1;
    if ((v10 | v15))
    {
      v18 = *a3;
    }

    else
    {
      *a3 = v17;
      v18 = v17;
    }
  }

  else
  {
    v13 = 0;
    v18 = *a3;
    *a1 = *a3;
    v17 = v18;
  }

LABEL_28:
  if (v17 == v18)
  {
    v19 = *a2;
    v20 = *a4;
    if (*a2 <= *a4)
    {
      goto LABEL_37;
    }

    goto LABEL_36;
  }

  if (v10 || v13)
  {
    __assert_rtn("special_cases", "envelope_segment.hpp", 260, "!is_pole1 && !is_pole2");
  }

  if (v17 > v18)
  {
    *a1 = v18;
    *a3 = v17;
    v21 = *a2;
    *a2 = *a4;
    *a4 = v21;
    v18 = *a3;
  }

  v22 = *a1;
  if (vabdd_f64(*a1, v18) > 180.0)
  {
    *a1 = v22 + 360.0;
    *a1 = *a3;
    *a3 = v22 + 360.0;
    v19 = *a2;
    v20 = *a4;
LABEL_36:
    *a2 = v20;
    *a4 = v19;
  }

LABEL_37:
  v23 = *a1;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_101FCB028))
  {
    qword_101FCB020 = 0x3F91DF46A2529D39;
    __cxa_guard_release(&qword_101FCB028);
  }

  v24 = *&qword_101FCB020;
  v25 = *a2;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_101FCB028))
  {
    qword_101FCB020 = 0x3F91DF46A2529D39;
    __cxa_guard_release(&qword_101FCB028);
  }

  v26 = *&qword_101FCB020;
  v27 = *a3;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_101FCB028))
  {
    qword_101FCB020 = 0x3F91DF46A2529D39;
    __cxa_guard_release(&qword_101FCB028);
  }

  v28 = *&qword_101FCB020;
  v29 = *a4;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v63 = v28;
    v64 = v29;
    v56 = __cxa_guard_acquire(&qword_101FCB028);
    v28 = v63;
    v29 = v64;
    if (v56)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      v28 = v63;
      v29 = v64;
    }
  }

  v30 = v23 * v24;
  v31 = v29 * *&qword_101FCB020;
  v32 = __sincos_stret(v27 * v28 - v30);
  v33 = __sincos_stret(v25 * v26);
  v34 = __sincos_stret(v31);
  v35 = atan2(v32.__sinval * v34.__cosval, v32.__cosval * -(v33.__sinval * v34.__cosval) + v33.__cosval * v34.__sinval);
  v36 = atan2(v33.__cosval * v32.__sinval, v33.__cosval * v34.__sinval * v32.__cosval - v33.__sinval * v34.__cosval);
  if (*a1 > *a3)
  {
    __assert_rtn("compute_box_corners", "envelope_segment.hpp", 161, "lon1 <= lon2");
  }

  v37 = *a2;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v57 = v36;
    v58 = __cxa_guard_acquire(&qword_101FCB028);
    v36 = v57;
    if (v58)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      v36 = v57;
    }
  }

  v38 = *&qword_101FCB020;
  v39 = *a4;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v59 = v36;
    v60 = __cxa_guard_acquire(&qword_101FCB028);
    v36 = v59;
    if (v60)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      v36 = v59;
    }
  }

  if (v35 != v36)
  {
    v40 = fabs(v35);
    v41 = fabs(v36);
    if ((*&v35 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v36 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_50;
    }

    v54 = vabdd_f64(v35, v36);
    if (v40 >= v41)
    {
      v55 = v40;
    }

    else
    {
      v55 = v41;
    }

    if (v55 < 1.0)
    {
      v55 = 1.0;
    }

    if (v54 > v55 * 2.22044605e-16)
    {
LABEL_50:
      v43 = *a2;
      if (*a2 <= *a4)
      {
        v44 = v37 * v38;
        v45 = v36;
      }

      else
      {
        v44 = v39 * *&qword_101FCB020;
        *a2 = *a4;
        *a4 = v43;
        v40 = v41;
        v45 = v35;
        v35 = v36;
      }

      if (v40 != INFINITY && (*&v45 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v46 = fabs(v45);
        v47 = vabdd_f64(v35, v45);
        if (v40 >= v46)
        {
          v46 = v40;
        }

        if (v46 < 1.0)
        {
          v46 = 1.0;
        }

        if (v47 <= v46 * 2.22044605e-16)
        {
          __assert_rtn("contains_pi_half", "envelope_segment.hpp", 128, "! math::equals(a1, a2)");
        }
      }

      if ((atomic_load_explicit(&qword_101FCB038, memory_order_acquire) & 1) == 0)
      {
        v61 = v44;
        v62 = __cxa_guard_acquire(&qword_101FCB038);
        v44 = v61;
        if (v62)
        {
          qword_101FCB030 = 0x3FF921FB54442D18;
          __cxa_guard_release(&qword_101FCB038);
          v44 = v61;
        }
      }

      if (v35 >= v45)
      {
        if (v35 <= *&qword_101FCB030 || *&qword_101FCB030 <= v45)
        {
          return;
        }
      }

      else if (v35 >= *&qword_101FCB030 || *&qword_101FCB030 >= v45)
      {
        return;
      }

      v50 = cos(v44);
      v51 = sin(v35);
      v52 = acos(fabs(v50 * v51));
      if (*a2 + *a4 >= 0.0)
      {
        if ((atomic_load_explicit(&qword_101FCB048, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_101FCB048))
        {
          qword_101FCB040 = 0x404CA5DC1A63C1F8;
          __cxa_guard_release(&qword_101FCB048);
        }

        if (*a4 < v52 * *&qword_101FCB040)
        {
          *a4 = v52 * *&qword_101FCB040;
        }
      }

      else
      {
        v53 = -v52;
        if ((atomic_load_explicit(&qword_101FCB048, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_101FCB048))
        {
          qword_101FCB040 = 0x404CA5DC1A63C1F8;
          __cxa_guard_release(&qword_101FCB048);
        }

        if (*a2 > *&qword_101FCB040 * v53)
        {
          *a2 = *&qword_101FCB040 * v53;
        }
      }
    }
  }
}

void sub_1016914BC(double *a1, double *a2)
{
  v4 = a1[5];
  v5 = a1[1];
  v6 = a1;
  if (v4 < v5)
  {
    if ((*&v5 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v4 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_6;
    }

    v47 = fabs(v5);
    v48 = fabs(v4);
    v49 = vabdd_f64(v5, v4);
    if (v47 >= v48)
    {
      v50 = v47;
    }

    else
    {
      v50 = v48;
    }

    if (v50 < 1.0)
    {
      v50 = 1.0;
    }

    v6 = a1;
    if (v49 > v50 * 2.22044605e-16)
    {
LABEL_6:
      v6 = a1 + 4;
    }
  }

  v8 = a1[3];
  v9 = a1[7];
  v10 = a1;
  if (v8 < v9)
  {
    if ((*&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_12;
    }

    v51 = fabs(v9);
    v52 = fabs(v8);
    v53 = vabdd_f64(v9, v8);
    if (v51 >= v52)
    {
      v54 = v51;
    }

    else
    {
      v54 = v52;
    }

    if (v54 < 1.0)
    {
      v54 = 1.0;
    }

    v10 = a1;
    if (v53 > v54 * 2.22044605e-16)
    {
LABEL_12:
      v10 = a1 + 4;
    }
  }

  v55 = v10;
  v12 = 0;
  __p = 0;
  v60 = 0;
  v61 = 0;
  v13 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  v14 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  v57 = v14;
  v58 = v13;
  do
  {
    v15 = *&a1[v12];
    v16 = *&a1[v12 + 2];
    if ((vmaxv_u16(vmovn_s32(vmvnq_s8(vuzp1q_s32(vceqq_f64(v15, v14), vceqq_f64(v16, v13))))) & 1) != 0 && v15.f64[1] != 90.0)
    {
      if ((*&v15.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_28;
      }

      v17 = fabs(v15.f64[1]);
      v18 = fabs(v15.f64[1] + -90.0);
      if (v17 < 90.0)
      {
        v17 = 90.0;
      }

      if (v17 < 1.0)
      {
        v17 = 1.0;
      }

      if (v18 > v17 * 2.22044605e-16)
      {
LABEL_28:
        if (v16.f64[1] != -90.0)
        {
          if ((*&v16.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_36;
          }

          v19 = fabs(v16.f64[1]);
          v20 = fabs(v16.f64[1] + 90.0);
          if (v19 < 90.0)
          {
            v19 = 90.0;
          }

          if (v19 < 1.0)
          {
            v19 = 1.0;
          }

          if (v20 > v19 * 2.22044605e-16)
          {
            if (v16.f64[0] <= 180.0)
            {
              goto LABEL_38;
            }

LABEL_36:
            if (v16.f64[0] == INFINITY)
            {
              goto LABEL_37;
            }

            v21 = fabs(v16.f64[0] + -180.0);
            if (v16.f64[0] >= 180.0)
            {
              v22 = a1[v12 + 2];
            }

            else
            {
              v22 = 180.0;
            }

            if (v22 < 1.0)
            {
              v22 = 1.0;
            }

            if (v21 > v22 * 2.22044605e-16)
            {
LABEL_37:
              v56 = *&a1[v12 + 2];
              v62[0] = a1[v12];
              v62[1] = 180.0;
              sub_1016926DC(&__p, v62);
              v62[0] = -180.0;
              v62[1] = *&v56 + -360.0;
              sub_1016926DC(&__p, v62);
            }

            else
            {
LABEL_38:
              v62[0] = a1[v12];
              v62[1] = v16.f64[0];
              sub_1016926DC(&__p, v62);
            }

            v14 = v57;
            v13 = v58;
          }
        }
      }
    }

    v12 += 4;
  }

  while (v12 != 8);
  if (__p == v60)
  {
    v33 = 0.0;
    v42 = 0.0;
  }

  else
  {
    v23 = (__p + 16);
    if (__p + 16 == v60)
    {
      v33 = *__p;
      v34 = __p;
    }

    else
    {
      v24 = (__p + 16);
      v25 = __p;
      do
      {
        v26 = *v24;
        v27 = *v25;
        if (*v24 < *v25)
        {
          if ((*&v27 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v26 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_49;
          }

          v29 = fabs(v27);
          v30 = fabs(v26);
          v31 = vabdd_f64(v27, v26);
          if (v29 >= v30)
          {
            v32 = v29;
          }

          else
          {
            v32 = v30;
          }

          if (v32 < 1.0)
          {
            v32 = 1.0;
          }

          if (v31 > v32 * 2.22044605e-16)
          {
LABEL_49:
            v25 = v24;
          }
        }

        v24 += 2;
      }

      while (v24 != v60);
      v33 = *v25;
      v34 = __p;
      do
      {
        v35 = v34[1];
        v36 = v23[1];
        if (v35 < v36)
        {
          if ((*&v36 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v35 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_64;
          }

          v38 = fabs(v36);
          v39 = fabs(v35);
          v40 = vabdd_f64(v36, v35);
          if (v38 >= v39)
          {
            v41 = v38;
          }

          else
          {
            v41 = v39;
          }

          if (v41 < 1.0)
          {
            v41 = 1.0;
          }

          if (v40 > v41 * 2.22044605e-16)
          {
LABEL_64:
            v34 = v23;
          }
        }

        v23 += 2;
      }

      while (v23 != v60);
    }

    v42 = v34[1];
    v43 = v42 - v33;
    if (v42 - v33 > 180.0)
    {
      if (v43 == INFINITY)
      {
        goto LABEL_83;
      }

      v44 = fabs(v43 + -180.0);
      if (v43 < 180.0)
      {
        v43 = 180.0;
      }

      if (v43 < 1.0)
      {
        v43 = 1.0;
      }

      if (v44 > v43 * 2.22044605e-16)
      {
LABEL_83:
        v45 = (v60 - __p) >> 4;
        if (!(v45 >> 60))
        {
          sub_1016927E4(v45);
        }

        sub_1000CE3D4();
      }
    }
  }

  *a2 = v33;
  a2[1] = v6[1];
  a2[2] = v42;
  a2[3] = v55[3];
  v46 = __p;
  if (__p)
  {

    operator delete(v46);
  }
}

void sub_101692314(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p)
{
  operator delete(v18);
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

double sub_101692350(double *a1, double *a2, double *a3, double *a4, int a5)
{
  sub_101690AC8(a1, a2, 0);
  sub_101690AC8(a3, a4, 0);
  v10 = *a2;
  if (*a2 == -90.0)
  {
    goto LABEL_8;
  }

  if ((*&v10 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v14 = fabs(v10);
    v15 = fabs(v10 + 90.0);
    if (v14 < 90.0)
    {
      v14 = 90.0;
    }

    if (v14 < 1.0)
    {
      v14 = 1.0;
    }

    if (v15 <= v14 * 2.22044605e-16)
    {
LABEL_8:
      v11 = *a4;
      if (*a4 == -90.0)
      {
        goto LABEL_18;
      }

      if ((*&v11 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v12 = fabs(v11);
        v13 = fabs(v11 + 90.0);
        if (v12 < 90.0)
        {
          v12 = 90.0;
        }

        if (v12 < 1.0)
        {
          v12 = 1.0;
        }

        if (v13 <= v12 * 2.22044605e-16)
        {
          goto LABEL_18;
        }
      }
    }
  }

  if (v10 != 90.0)
  {
    if ((*&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_54;
    }

    v26 = fabs(v10);
    v27 = fabs(v10 + -90.0);
    if (v26 < 90.0)
    {
      v26 = 90.0;
    }

    if (v26 < 1.0)
    {
      v26 = 1.0;
    }

    if (v27 > v26 * 2.22044605e-16)
    {
      goto LABEL_54;
    }
  }

  v16 = *a4;
  if (*a4 == 90.0)
  {
    goto LABEL_18;
  }

  if ((*&v16 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    goto LABEL_54;
  }

  v28 = fabs(v16);
  v29 = fabs(v16 + -90.0);
  if (v28 >= 90.0)
  {
    v30 = v28;
  }

  else
  {
    v30 = 90.0;
  }

  if (v30 < 1.0)
  {
    v30 = 1.0;
  }

  if (v29 <= v30 * 2.22044605e-16)
  {
LABEL_18:
    *a3 = 0.0;
    *a1 = 0.0;
    v17 = 0.0;
  }

  else
  {
LABEL_54:
    if (a5)
    {
      *a1 = -180.0;
      v31 = 180.0;
LABEL_58:
      *a3 = v31;
      v17 = *a1;
      goto LABEL_19;
    }

    v17 = *a1;
    if (*a1 > *a3)
    {
      v31 = *a3 + 360.0;
      goto LABEL_58;
    }
  }

LABEL_19:
  v18 = *a3;
  if (*a3 < v17)
  {
    if ((*&v17 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v18 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_59;
    }

    v19 = fabs(v17);
    v20 = fabs(v18);
    v21 = vabdd_f64(v17, v18);
    if (v19 < v20)
    {
      v19 = v20;
    }

    if (v19 < 1.0)
    {
      v19 = 1.0;
    }

    if (v21 > v19 * 2.22044605e-16)
    {
LABEL_59:
      __assert_rtn("apply", "normalize_spheroidal_box_coordinates.hpp", 92, "! math::larger(longitude1, longitude2)");
    }
  }

  if (v17 < -180.0)
  {
    if ((*&v17 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_60;
    }

    v22 = vabdd_f64(-180.0, v17);
    v23 = fmax(fabs(v17), 180.0);
    if (v23 < 1.0)
    {
      v23 = 1.0;
    }

    if (v22 > v23 * 2.22044605e-16)
    {
LABEL_60:
      __assert_rtn("apply", "normalize_spheroidal_box_coordinates.hpp", 93, "! math::smaller(longitude1, constants::min_longitude())");
    }
  }

  result = v18 - v17;
  if (result > 360.0)
  {
    if (result == INFINITY)
    {
      goto LABEL_61;
    }

    v25 = fabs(result + -360.0);
    if (result < 360.0)
    {
      result = 360.0;
    }

    if (result < 1.0)
    {
      result = 1.0;
    }

    result = result * 2.22044605e-16;
    if (v25 > result)
    {
LABEL_61:
      __assert_rtn("apply", "normalize_spheroidal_box_coordinates.hpp", 95, "! math::larger(longitude2 - longitude1, constants::period())");
    }
  }

  return result;
}

void sub_1016926DC(uint64_t a1, _OWORD *a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (v4 >= v3)
  {
    v6 = *a1;
    v7 = v4 - *a1;
    v8 = v7 >> 4;
    v9 = (v7 >> 4) + 1;
    if (v9 >> 60)
    {
      sub_1000CE3D4();
    }

    v10 = v3 - v6;
    if (v10 >> 3 > v9)
    {
      v9 = v10 >> 3;
    }

    if (v10 >= 0x7FFFFFFFFFFFFFF0)
    {
      v11 = 0xFFFFFFFFFFFFFFFLL;
    }

    else
    {
      v11 = v9;
    }

    if (v11)
    {
      if (!(v11 >> 60))
      {
        operator new();
      }

      sub_100013D10();
    }

    v12 = (16 * v8);
    *v12 = *a2;
    v5 = 16 * v8 + 16;
    v13 = &v12[-(v7 >> 4)];
    memcpy(v13, v6, v7);
    *a1 = v13;
    *(a1 + 8) = v5;
    *(a1 + 16) = 0;
    if (v6)
    {
      operator delete(v6);
    }
  }

  else
  {
    *v4 = *a2;
    v5 = (v4 + 1);
  }

  *(a1 + 8) = v5;
}

void sub_1016927E4(unint64_t a1)
{
  if (!(a1 >> 60))
  {
    operator new();
  }

  sub_100013D10();
}

uint64_t sub_10169282C(uint64_t result, uint64_t a2, uint64_t a3)
{
  v3 = a3 - 2;
  if (a3 < 2)
  {
    return result;
  }

  v4 = v3 >> 1;
  v5 = (result + 16 * (v3 >> 1));
  v8 = *(a2 - 16);
  v6 = a2 - 16;
  v7 = v8;
  v9 = *(v6 + 8);
  v10 = 8;
  if (*(v6 + 8))
  {
    v11 = 0;
  }

  else
  {
    v11 = 8;
  }

  v12 = *(v7 + v11);
  if (*(v5 + 8))
  {
    v10 = 0;
  }

  v13 = *(*v5 + v10);
  if (v12 == v13)
  {
    goto LABEL_48;
  }

  if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v13 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    goto LABEL_15;
  }

  v26 = fabs(v12);
  v27 = fabs(v13);
  v28 = vabdd_f64(v12, v13);
  if (v26 < v27)
  {
    v26 = v27;
  }

  if (v26 < 1.0)
  {
    v26 = 1.0;
  }

  if (v28 <= v26 * 2.22044605e-16)
  {
LABEL_48:
    if (!*(v6 + 8) || *(v5 + 8))
    {
      return result;
    }
  }

  else
  {
LABEL_15:
    if (v12 >= v13)
    {
      return result;
    }
  }

  v15 = *v5;
  *(v6 + 8) = *(v5 + 8);
  *v6 = v15;
  if (v3 < 2)
  {
    goto LABEL_39;
  }

  v16 = (result + 16 * (v3 >> 1));
  while (1)
  {
    v17 = v4 - 1;
    v4 = (v4 - 1) >> 1;
    v5 = (result + 16 * v4);
    v18 = *(v7 + v11);
    v19 = *(v5 + 8) ? 0 : 8;
    v20 = *(*v5 + v19);
    if (v18 == v20)
    {
      break;
    }

    if ((*&v18 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v20 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v23 = fabs(v18);
      v24 = fabs(v20);
      v25 = vabdd_f64(v18, v20);
      if (v23 < v24)
      {
        v23 = v24;
      }

      if (v23 < 1.0)
      {
        v23 = 1.0;
      }

      if (v25 <= v23 * 2.22044605e-16)
      {
        break;
      }
    }

    if (v18 >= v20)
    {
      goto LABEL_38;
    }

LABEL_30:
    v22 = *v5;
    *(v16 + 8) = *(v5 + 8);
    *v16 = v22;
    v16 = (result + 16 * v4);
    if (v17 <= 1)
    {
      goto LABEL_39;
    }
  }

  if (v9 && !*(v5 + 8))
  {
    goto LABEL_30;
  }

LABEL_38:
  v5 = v16;
LABEL_39:
  *v5 = v7;
  *(v5 + 8) = v9;
  return result;
}

void sub_1016929C4(double *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  v8 = (*a1 + a1[2]) * 0.5;
  v9 = *(a1 + 1);
  v71 = *a1;
  v73 = *(&v9 + 1);
  v69[1] = *(&v71 + 1);
  v70 = v9;
  v72 = v8;
  v69[0] = v8;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  __p = 0;
  v52 = 0;
  v53 = 0;
  sub_101693508(&v71, v69, a2, &v66, &v63, &v60);
  sub_101693508(&v71, v69, a3, &v57, &v54, &__p);
  v10 = v60;
  v11 = v61;
  v12 = __p;
  v48 = v60;
  if (v60 == v61)
  {
    v14 = v52;
  }

  else
  {
    v13 = v61 - v60;
    v14 = v52;
    if ((v61 - v60) < 0x80 || a4 > 0x63 || (v52 - __p) < 0x79)
    {
      if (__p != v52)
      {
        v15 = v60;
        do
        {
          v16 = v12;
          do
          {
            sub_101692FE0(a5, *v15, *v16++);
          }

          while (v16 != v14);
          ++v15;
        }

        while (v15 != v11);
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v17 = v60;
      do
      {
        sub_1016932F4(&v74, *v10++ + 2);
      }

      while (v10 != v11);
      v18 = v74;
      v19 = v75;
      if (v12 != v14)
      {
        v20 = v12;
        do
        {
          sub_1016932F4(&v74, *v20++ + 2);
        }

        while (v20 != v14);
        v18 = v74;
        v19 = v75;
      }

      v49 = v18;
      v50 = v19;
      sub_1016938D4(v49.f64, &v60, &__p, a4 + 1, a5);
      v10 = v17;
    }

    v22 = v57;
    v21 = v58;
    if ((v58 - v57) < 0x80 || (v55 - v54) < 0x80 || a4 > 0x63 || v13 < 0x79)
    {
      if (v57 != v58)
      {
        v23 = v10;
        do
        {
          v24 = v22;
          do
          {
            sub_101692FE0(a5, *v23, *v24++);
          }

          while (v24 != v21);
          ++v23;
        }

        while (v23 != v11);
      }

      v25 = v54;
      v26 = v55;
      if (v54 != v55)
      {
        v27 = v10;
        do
        {
          v28 = v25;
          do
          {
            sub_101692FE0(a5, *v27, *v28++);
          }

          while (v28 != v26);
          ++v27;
        }

        while (v27 != v11);
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      do
      {
        sub_1016932F4(&v74, *v10++ + 2);
      }

      while (v10 != v11);
      v49 = v74;
      v50 = v75;
      sub_1016938D4(v49.f64, &v60, &v57, a4 + 1, a5);
      sub_1016938D4(v49.f64, &v60, &v54, a4 + 1, a5);
    }
  }

  v29 = v66;
  v30 = v67;
  v31 = v67 - v66;
  if (v12 != v14)
  {
    if (v31 < 0x80 || (v64 - v63) < 0x80 || a4 > 0x63 || (v14 - v12) < 0x79)
    {
      if (v66 != v67)
      {
        v32 = v66;
        do
        {
          v33 = v12;
          do
          {
            sub_101692FE0(a5, *v32, *v33++);
          }

          while (v33 != v14);
          ++v32;
        }

        while (v32 != v30);
      }

      v34 = v63;
      v35 = v64;
      while (v34 != v35)
      {
        v36 = v12;
        do
        {
          sub_101692FE0(a5, *v34, *v36++);
        }

        while (v36 != v14);
        ++v34;
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v37 = v12;
      do
      {
        sub_1016932F4(&v74, *v37++ + 2);
      }

      while (v37 != v14);
      v49 = v74;
      v50 = v75;
      sub_1016938D4(v49.f64, &v66, &__p, a4 + 1, a5);
      sub_1016938D4(v49.f64, &v63, &__p, a4 + 1, a5);
    }
  }

  if (v31 < 0x80 || a4 > 0x63 || (v58 - v57) < 0x79)
  {
    if (v29 != v30)
    {
      v38 = v57;
      v39 = v58;
      if (v57 != v58)
      {
        v40 = v29;
        do
        {
          v41 = v38;
          do
          {
            sub_101692FE0(a5, *v40, *v41++);
          }

          while (v41 != v39);
          ++v40;
        }

        while (v40 != v30);
      }
    }
  }

  else
  {
    sub_1016938D4(&v71, &v66, &v57, a4 + 1, a5);
  }

  v42 = v63;
  v43 = v64;
  if ((v64 - v63) < 0x80 || a4 > 0x63 || (v55 - v54) < 0x79)
  {
    if (v63 != v64)
    {
      v44 = v54;
      v45 = v55;
      if (v54 != v55)
      {
        v46 = v63;
        do
        {
          v47 = v44;
          do
          {
            sub_101692FE0(a5, *v46, *v47++);
          }

          while (v47 != v45);
          ++v46;
        }

        while (v46 != v43);
      }
    }
  }

  else
  {
    sub_1016938D4(v69, &v63, &v54, a4 + 1, a5);
  }

  if (v12)
  {
    operator delete(v12);
  }

  if (v54)
  {
    operator delete(v54);
  }

  if (v57)
  {
    operator delete(v57);
  }

  if (v48)
  {
    operator delete(v48);
  }

  if (v42)
  {
    operator delete(v42);
  }

  if (v29)
  {

    operator delete(v29);
  }
}

void sub_101692F4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, void *a30)
{
  if (v30)
  {
    operator delete(v30);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a21)
  {
    operator delete(a21);
  }

  if (a24)
  {
    operator delete(a24);
  }

  if (a27)
  {
    operator delete(a27);
  }

  if (a30)
  {
    operator delete(a30);
  }

  _Unwind_Resume(exception_object);
}

void sub_101692FE0(uint64_t a1, double *a2, double *a3)
{
  v6 = a2[4];
  v7 = a2[6];
  if (v7 - v6 >= 360.0 || (v8 = a3[4], v9 = a3[6], v10 = v9 - v8, v9 - v8 >= 360.0))
  {
LABEL_11:
    if (a2[7] >= a3[5] && a2[5] <= a3[7])
    {
      sub_101693EFC(*a1, *(a1 + 8), a2, *(a1 + 16), *(a1 + 24), a3, 0, *(a1 + 32), *(a1 + 40), *(a1 + 48));
    }

    return;
  }

  v11 = vabdd_f64(v8, v6);
  v12 = 180.0;
  if (v11 == 180.0)
  {
    goto LABEL_4;
  }

  v13 = v8 - v6;
  if ((*&v13 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v16 = fabs(v11 + -180.0);
    v12 = 180.0;
    if (v11 < 180.0)
    {
      v11 = 180.0;
    }

    if (v11 < 1.0)
    {
      v11 = 1.0;
    }

    if (v16 <= v11 * 2.22044605e-16)
    {
      goto LABEL_4;
    }
  }

  v12 = 180.0;
  if (v13 <= 180.0)
  {
    if (v13 >= -180.0)
    {
      goto LABEL_5;
    }

    v12 = fmod(v13 + -180.0, 360.0) + 180.0;
LABEL_4:
    v13 = v12;
    goto LABEL_5;
  }

  v13 = fmod(v13 + 180.0, 360.0) + -180.0;
  if (v13 == -180.0)
  {
    goto LABEL_4;
  }

  if ((*&v13 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v17 = fabs(v13);
    v12 = 180.0;
    v18 = fabs(v13 + 180.0);
    if (v17 < 180.0)
    {
      v17 = 180.0;
    }

    if (v17 < 1.0)
    {
      v17 = 1.0;
    }

    if (v18 <= v17 * 2.22044605e-16)
    {
      goto LABEL_4;
    }
  }

LABEL_5:
  if (v13 < 0.0)
  {
    v13 = v13 + 360.0;
  }

  v14 = v6 + v13;
  v15 = v10 + v6 + v13 + -360.0;
  if (vabdd_f64(v15, v9) < 180.0)
  {
    v15 = v9;
  }

  if (v14 <= v7 || v15 >= v6)
  {
    goto LABEL_11;
  }
}

void sub_1016931F4(uint64_t a1, void *a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (v4 >= v3)
  {
    v6 = *a1;
    v7 = v4 - *a1;
    v8 = (v7 >> 3) + 1;
    if (v8 >> 61)
    {
      sub_1000CE3D4();
    }

    v9 = v3 - v6;
    if (v9 >> 2 > v8)
    {
      v8 = v9 >> 2;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFF8)
    {
      v10 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    if (v10)
    {
      if (!(v10 >> 61))
      {
        operator new();
      }

      sub_100013D10();
    }

    v11 = (8 * (v7 >> 3));
    *v11 = *a2;
    v5 = v11 + 1;
    memcpy(0, v6, v7);
    *a1 = 0;
    *(a1 + 8) = v5;
    *(a1 + 16) = 0;
    if (v6)
    {
      operator delete(v6);
    }
  }

  else
  {
    *v4 = *a2;
    v5 = v4 + 1;
  }

  *(a1 + 8) = v5;
}

void sub_1016932F4(float64x2_t *a1, float64x2_t *a2)
{
  v3 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  v4 = *a2;
  v5 = a2[1];
  v6 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  if (vmaxv_u16(vmovn_s32(vmvnq_s8(vuzp1q_s32(vceqq_f64(*a2, v3), vceqq_f64(v5, v6))))))
  {
    v28 = v3;
    v7 = *a2;
    v32 = a2->f64[1];
    v33[0] = v7.f64[0];
    v30 = v5.f64[1];
    v31 = v5.f64[0];
    v8 = vabdd_f64(v4.f64[0], v5.f64[0]);
    v27 = v6;
    if (v8 < 360.0)
    {
      v14 = vabdd_f64(360.0, v8);
      v15 = fmax(v8, 360.0);
      if (v15 < 1.0)
      {
        v15 = 1.0;
      }

      v9 = v14 <= v15 * 2.22044605e-16;
    }

    else
    {
      v9 = 1;
    }

    v12 = v4.f64[1];
    v13 = v5.f64[1];
    sub_101692350(v33, &v32, &v31, &v30, v9);
    v11 = v33[0];
    v10 = v31;
    v6 = v27;
    v3 = v28;
  }

  else
  {
    v10 = -1.79769313e308;
    v11 = 1.79769313e308;
    v12 = 1.79769313e308;
    v13 = -1.79769313e308;
  }

  v33[0] = v11;
  v33[1] = v12;
  v33[2] = v10;
  v33[3] = v13;
  v16 = *a1;
  v17 = a1[1];
  if (vmaxv_u16(vmovn_s32(vmvnq_s8(vuzp1q_s32(vceqq_f64(*a1, v3), vceqq_f64(v17, v6))))))
  {
    v18 = *a1;
    v31 = a1->f64[1];
    v32 = v18.f64[0];
    v29 = v17.f64[1];
    v30 = v17.f64[0];
    v19 = vabdd_f64(v16.f64[0], v17.f64[0]);
    if (v19 < 360.0)
    {
      v25 = vabdd_f64(360.0, v19);
      v26 = fmax(v19, 360.0);
      if (v26 < 1.0)
      {
        v26 = 1.0;
      }

      v20 = v25 <= v26 * 2.22044605e-16;
    }

    else
    {
      v20 = 1;
    }

    v23 = v16.f64[1];
    v24 = v17.f64[1];
    sub_101692350(&v32, &v31, &v30, &v29, v20);
    v22 = v32;
    v21 = v30;
  }

  else
  {
    v21 = -1.79769313e308;
    v22 = 1.79769313e308;
    v23 = 1.79769313e308;
    v24 = -1.79769313e308;
  }

  v33[4] = v22;
  v33[5] = v23;
  v33[6] = v21;
  v33[7] = v24;
  sub_1016914BC(v33, a1->f64);
}

void sub_101693508(double *a1, double *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v6 = *a3;
  v7 = *(a3 + 8);
  if (*a3 != v7)
  {
    while (1)
    {
      v13 = *v6;
      v14 = *a1;
      v15 = a1[2];
      v16 = *(*v6 + 32);
      v17 = *(*v6 + 48);
      v18 = v17 - v16;
      if (v15 - *a1 < 360.0 && v18 < 360.0)
      {
        break;
      }

LABEL_12:
      if (a1[3] >= *(v13 + 40))
      {
        v24 = a1[1] <= *(v13 + 56);
        goto LABEL_15;
      }

LABEL_13:
      v24 = 0;
LABEL_15:
      v25 = *a2;
      v26 = a2[2];
      if (v26 - *a2 >= 360.0 || v18 >= 360.0)
      {
        goto LABEL_25;
      }

      v27 = vabdd_f64(v16, v25);
      v28 = 180.0;
      if (v27 == 180.0)
      {
        goto LABEL_18;
      }

      v29 = v16 - v25;
      if (COERCE__INT64(fabs(v16 - v25)) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v37 = fabs(v27 + -180.0);
        v28 = 180.0;
        if (v27 < 180.0)
        {
          v27 = 180.0;
        }

        if (v27 < 1.0)
        {
          v27 = 1.0;
        }

        if (v37 <= v27 * 2.22044605e-16)
        {
          goto LABEL_18;
        }
      }

      if (v29 <= 180.0)
      {
        if (v29 < -180.0)
        {
          v28 = fmod(v29 + -180.0, 360.0) + 180.0;
LABEL_18:
          v29 = v28;
        }
      }

      else
      {
        v29 = fmod(v29 + 180.0, 360.0) + -180.0;
        v28 = 180.0;
        if (v29 == -180.0)
        {
          goto LABEL_18;
        }

        if ((*&v29 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v38 = fabs(v29);
          v39 = fabs(v29 + 180.0);
          if (v38 < 180.0)
          {
            v38 = 180.0;
          }

          if (v38 < 1.0)
          {
            v38 = 1.0;
          }

          v34 = v39 > v38 * 2.22044605e-16;
          v28 = 180.0;
          if (!v34)
          {
            goto LABEL_18;
          }
        }
      }

      if (v29 < 0.0)
      {
        v29 = v29 + 360.0;
      }

      v30 = v25 + v29;
      v31 = v18 + v25 + v29 + -360.0;
      if (vabdd_f64(v31, v17) < 180.0)
      {
        v31 = v17;
      }

      if (v30 > v26 && v31 < v25)
      {
LABEL_27:
        v32 = a4;
        if (!v24)
        {
          goto LABEL_33;
        }

        goto LABEL_32;
      }

LABEL_25:
      if (a2[3] < *(v13 + 40) || a2[1] > *(v13 + 56))
      {
        goto LABEL_27;
      }

      if (v24)
      {
        v32 = a6;
      }

      else
      {
        v32 = a5;
      }

LABEL_32:
      sub_1016931F4(v32, v6);
      v7 = *(a3 + 8);
LABEL_33:
      if (++v6 == v7)
      {
        return;
      }
    }

    v19 = vabdd_f64(v16, v14);
    v20 = 180.0;
    if (v19 == 180.0)
    {
      goto LABEL_5;
    }

    v21 = v16 - v14;
    if (COERCE__INT64(fabs(v16 - v14)) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v33 = fabs(v19 + -180.0);
      if (v19 < 180.0)
      {
        v19 = 180.0;
      }

      if (v19 < 1.0)
      {
        v19 = 1.0;
      }

      v34 = v33 > v19 * 2.22044605e-16;
      v20 = 180.0;
      if (!v34)
      {
        goto LABEL_5;
      }
    }

    if (v21 <= 180.0)
    {
      if (v21 < -180.0)
      {
        v20 = fmod(v21 + -180.0, 360.0) + 180.0;
LABEL_5:
        v21 = v20;
      }
    }

    else
    {
      v21 = fmod(v21 + 180.0, 360.0) + -180.0;
      v20 = 180.0;
      if (v21 == -180.0)
      {
        goto LABEL_5;
      }

      if ((*&v21 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v35 = fabs(v21);
        v36 = fabs(v21 + 180.0);
        if (v35 < 180.0)
        {
          v35 = 180.0;
        }

        if (v35 < 1.0)
        {
          v35 = 1.0;
        }

        v34 = v36 > v35 * 2.22044605e-16;
        v20 = 180.0;
        if (!v34)
        {
          goto LABEL_5;
        }
      }
    }

    if (v21 < 0.0)
    {
      v21 = v21 + 360.0;
    }

    v22 = v14 + v21;
    v23 = v18 + v14 + v21 + -360.0;
    if (vabdd_f64(v23, v17) < 180.0)
    {
      v23 = v17;
    }

    if (v22 > v15 && v23 < v14)
    {
      goto LABEL_13;
    }

    goto LABEL_12;
  }
}

void sub_1016938D4(double *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  v8 = a1[1] + a1[3];
  v71 = *a1;
  v72 = *(a1 + 2);
  v9 = *(a1 + 1);
  *&v69[0] = v71;
  v70 = v9;
  v73 = v8 * 0.5;
  v69[1] = v8 * 0.5;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  __p = 0;
  v52 = 0;
  v53 = 0;
  sub_101693508(&v71, v69, a2, &v66, &v63, &v60);
  sub_101693508(&v71, v69, a3, &v57, &v54, &__p);
  v10 = v60;
  v11 = v61;
  v12 = __p;
  v48 = v60;
  if (v60 == v61)
  {
    v14 = v52;
  }

  else
  {
    v13 = v61 - v60;
    v14 = v52;
    if ((v61 - v60) < 0x80 || a4 > 0x63 || (v52 - __p) < 0x79)
    {
      if (__p != v52)
      {
        v15 = v60;
        do
        {
          v16 = v12;
          do
          {
            sub_101692FE0(a5, *v15, *v16++);
          }

          while (v16 != v14);
          ++v15;
        }

        while (v15 != v11);
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v17 = v60;
      do
      {
        sub_1016932F4(&v74, *v10++ + 2);
      }

      while (v10 != v11);
      v18 = v74;
      v19 = v75;
      if (v12 != v14)
      {
        v20 = v12;
        do
        {
          sub_1016932F4(&v74, *v20++ + 2);
        }

        while (v20 != v14);
        v18 = v74;
        v19 = v75;
      }

      v49 = v18;
      v50 = v19;
      sub_1016929C4(&v49, &v60, &__p, a4 + 1, a5);
      v10 = v17;
    }

    v22 = v57;
    v21 = v58;
    if ((v58 - v57) < 0x80 || (v55 - v54) < 0x80 || a4 > 0x63 || v13 < 0x79)
    {
      if (v57 != v58)
      {
        v23 = v10;
        do
        {
          v24 = v22;
          do
          {
            sub_101692FE0(a5, *v23, *v24++);
          }

          while (v24 != v21);
          ++v23;
        }

        while (v23 != v11);
      }

      v25 = v54;
      v26 = v55;
      if (v54 != v55)
      {
        v27 = v10;
        do
        {
          v28 = v25;
          do
          {
            sub_101692FE0(a5, *v27, *v28++);
          }

          while (v28 != v26);
          ++v27;
        }

        while (v27 != v11);
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      do
      {
        sub_1016932F4(&v74, *v10++ + 2);
      }

      while (v10 != v11);
      v49 = v74;
      v50 = v75;
      sub_1016929C4(&v49, &v60, &v57, a4 + 1, a5);
      sub_1016929C4(&v49, &v60, &v54, a4 + 1, a5);
    }
  }

  v29 = v66;
  v30 = v67;
  v31 = v67 - v66;
  if (v12 != v14)
  {
    if (v31 < 0x80 || (v64 - v63) < 0x80 || a4 > 0x63 || (v14 - v12) < 0x79)
    {
      if (v66 != v67)
      {
        v32 = v66;
        do
        {
          v33 = v12;
          do
          {
            sub_101692FE0(a5, *v32, *v33++);
          }

          while (v33 != v14);
          ++v32;
        }

        while (v32 != v30);
      }

      v34 = v63;
      v35 = v64;
      while (v34 != v35)
      {
        v36 = v12;
        do
        {
          sub_101692FE0(a5, *v34, *v36++);
        }

        while (v36 != v14);
        ++v34;
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v37 = v12;
      do
      {
        sub_1016932F4(&v74, *v37++ + 2);
      }

      while (v37 != v14);
      v49 = v74;
      v50 = v75;
      sub_1016929C4(&v49, &v66, &__p, a4 + 1, a5);
      sub_1016929C4(&v49, &v63, &__p, a4 + 1, a5);
    }
  }

  if (v31 < 0x80 || a4 > 0x63 || (v58 - v57) < 0x79)
  {
    if (v29 != v30)
    {
      v38 = v57;
      v39 = v58;
      if (v57 != v58)
      {
        v40 = v29;
        do
        {
          v41 = v38;
          do
          {
            sub_101692FE0(a5, *v40, *v41++);
          }

          while (v41 != v39);
          ++v40;
        }

        while (v40 != v30);
      }
    }
  }

  else
  {
    sub_1016929C4(&v71, &v66, &v57, a4 + 1, a5);
  }

  v42 = v63;
  v43 = v64;
  if ((v64 - v63) < 0x80 || a4 > 0x63 || (v55 - v54) < 0x79)
  {
    if (v63 != v64)
    {
      v44 = v54;
      v45 = v55;
      if (v54 != v55)
      {
        v46 = v63;
        do
        {
          v47 = v44;
          do
          {
            sub_101692FE0(a5, *v46, *v47++);
          }

          while (v47 != v45);
          ++v46;
        }

        while (v46 != v43);
      }
    }
  }

  else
  {
    sub_1016929C4(v69, &v63, &v54, a4 + 1, a5);
  }

  if (v12)
  {
    operator delete(v12);
  }

  if (v54)
  {
    operator delete(v54);
  }

  if (v57)
  {
    operator delete(v57);
  }

  if (v48)
  {
    operator delete(v48);
  }

  if (v42)
  {
    operator delete(v42);
  }

  if (v29)
  {

    operator delete(v29);
  }
}

void sub_101693E68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, void *a30)
{
  if (v30)
  {
    operator delete(v30);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a21)
  {
    operator delete(a21);
  }

  if (a24)
  {
    operator delete(a24);
  }

  if (a27)
  {
    operator delete(a27);
  }

  if (a30)
  {
    operator delete(a30);
  }

  _Unwind_Resume(exception_object);
}

void sub_101693EFC(int a1, double **a2, uint64_t a3, int a4, double **a5, uint64_t a6, int a7, uint64_t a8, uint64_t a9, void *a10)
{
  v10 = a6;
  if (*(a3 + 96) == 1 && (*(a3 + 80) + 1) < *(a3 + 88) || *(a6 + 96) == 1 && (*(a6 + 80) + 1) < *(a6 + 88))
  {
    return;
  }

  v11 = *(a3 + 24);
  if ((v11 & 0x8000000000000000) == 0)
  {
    v12 = a2[3];
    if (0xAAAAAAAAAAAAAAABLL * (a2[4] - v12) < v11)
    {
      goto LABEL_302;
    }

    a2 = &v12[3 * v11];
  }

  v13 = *a2;
  v14 = a2[1];
  v15 = *(a6 + 24);
  if ((v15 & 0x8000000000000000) != 0)
  {
    goto LABEL_11;
  }

  v16 = a5[3];
  if (0xAAAAAAAAAAAAAAABLL * (a5[4] - v16) < v15)
  {
LABEL_302:
    __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
  }

  a5 = &v16[3 * v15];
LABEL_11:
  v253 = a5[1];
  v254 = *a5;
  v17 = *a3;
  v225 = *a6;
  v19 = *(a3 + 64);
  v18 = *(a3 + 72);
  v20 = *(a3 + 104);
  v21 = &v13[2 * v19];
  v238 = &v13[2 * v18 + 2];
  if (16 * v19 == 16 * v18)
  {
    v244 = *(a3 + 104);
  }

  else
  {
    v22 = *(a3 + 32);
    v23 = *(a3 + 48);
    v24 = *(a6 + 32);
    v25 = *(a6 + 48);
    if (sub_101695318(v17, v21[2], v22, v23, v24, v25))
    {
      v26 = v19 + 1;
      v27 = v20 + 1;
      v28 = &v13[2 * v19 + 4];
      do
      {
        v29 = v26;
        v30 = v27;
        v31 = v28;
        if (v28 == v238)
        {
          break;
        }

        v28 += 16;
        v32 = sub_101695318(v17, *v31, v22, v23, v24, v25);
        v26 = v29 + 1;
        v27 = v30 + 1;
      }

      while (v32);
      v244 = v30;
      v21 = v31 - 2;
      v19 = v29;
    }

    else
    {
      v244 = v20;
      v21 = &v13[2 * v19];
    }
  }

  v242 = v21 + 2;
  v33 = a3;
  if (v21 + 2 != v238)
  {
    v34 = &v13[2 * (v21 != v13)];
    if (v242 != v14)
    {
      v34 = v21 + 2;
    }

    v35 = v34 != v13;
    v36 = v34 + 2;
    v37 = &v13[2 * v35];
    if (v36 != v14)
    {
      v37 = v36;
    }

    v38 = -v17;
    v39 = v37;
    v231 = v38;
    __asm { FMOV            V0.2D, #1.0 }

    v245 = _Q0;
    v241 = v10;
    v229 = v14;
    v230 = v13;
    while (1)
    {
      v243 = v21;
      v44 = *(v33 + 32);
      v45 = *(v33 + 48);
      v46 = *(v10 + 32);
      v47 = *(v10 + 48);
      v48 = sub_101695318(v231, *v21, v44, v45, v46, v47);
      v49 = v243;
      if (v48)
      {
        return;
      }

      v270 = 0u;
      v269 = 0u;
      v263[0] = v33;
      v250 = v19;
      v263[1] = v19;
      v264 = v243;
      v265 = v242;
      v239 = v39;
      v266 = v39;
      v267 = v13;
      v268 = v14;
      LOBYTE(v269) = 1;
      v50 = *(v10 + 104);
      v51 = *(v10 + 64);
      v52 = &v254[2 * v51];
      v251 = &v254[2 * *(v10 + 72) + 2];
      v53 = v33;
      if (v52 + 2 != v251)
      {
        if (sub_101695318(v225, v52[2], v46, v47, v44, v45))
        {
          v54 = v51 + 1;
          v55 = v50 + 1;
          v56 = v52 + 4;
          do
          {
            v51 = v54;
            v50 = v55;
            v57 = v56;
            if (v56 == v251)
            {
              break;
            }

            v56 += 2;
            v58 = sub_101695318(v225, *v57, v46, v47, v44, v45);
            v54 = v51 + 1;
            v55 = v50 + 1;
          }

          while (v58);
          v52 = v57 - 2;
          v53 = a3;
        }

        v49 = v243;
      }

      v59 = v52 + 2;
      if (v52 + 2 != v251)
      {
        break;
      }

      ++v244;
LABEL_296:
      v21 = v49 + 2;
      v224 = v242 + 2;
      v19 = v250 + 1;
      v14 = v229;
      v13 = v230;
      if (v239 + 2 == v229)
      {
        v39 = &v230[2 * (v239 != v230)];
      }

      else
      {
        v39 = v239 + 2;
      }

      v242 += 2;
      v33 = a3;
      if (v224 == v238)
      {
        return;
      }
    }

    v60 = &v254[2 * (v52 != v254)];
    if (v59 != v253)
    {
      v60 = v52 + 2;
    }

    v61 = v60 != v254;
    v62 = v60 + 2;
    v63 = &v254[2 * v61];
    if (v62 == v253)
    {
      v64 = v63;
    }

    else
    {
      v64 = v62;
    }

    ++v244;
    while (1)
    {
      if (sub_101695318(-v225, *v52, *(v10 + 32), *(v10 + 48), *(v53 + 32), *(v53 + 48)))
      {
LABEL_294:
        v49 = v243;
        goto LABEL_296;
      }

      if (a1 != a4 || *(v53 + 16) != *(v10 + 16) || *(v53 + 24) != *(v10 + 24) || !a7 || v50 != v244 && (v250 || *(v53 + 88) - 2 > v51))
      {
        break;
      }

LABEL_282:
      v52 += 2;
      v59 += 2;
      ++v51;
      if (v64 + 2 == v253)
      {
        v64 = &v254[2 * (v64 != v254)];
      }

      else
      {
        v64 += 2;
      }

      ++v50;
      if (v59 == v251)
      {
        goto LABEL_294;
      }
    }

    v65 = 0;
    v262 = 0u;
    v261 = 0u;
    v256[0] = v10;
    v256[1] = v51;
    v256[2] = v52;
    v257 = v59;
    v252 = v64;
    v258 = v64;
    v259 = v254;
    v260 = v253;
    BYTE8(v262) = 0;
    memset(&__src[2], 0, 344);
    memset(__src, 0, 24);
    *(&__src[1] + 1) = -1;
    *&v66 = -1;
    *(&v66 + 1) = -1;
    do
    {
      v67 = __src + v65;
      *(v67 + 10) = 0;
      *(v67 + 3) = v66;
      *(v67 + 4) = v66;
      *(v67 + 10) = -1;
      *(v67 + 88) = xmmword_1019ADEB0;
      *(v67 + 13) = 0;
      *(v67 + 14) = 0;
      *(v67 + 15) = -1;
      *(v67 + 16) = -1;
      *(v67 + 17) = -1;
      *(v67 + 72) = 257;
      *(v67 + 19) = 0;
      *(v67 + 20) = 0;
      *(v67 + 21) = -1;
      *(v67 + 22) = -1;
      *(v67 + 23) = -1;
      v67[192] = 0;
      *(v67 + 50) = 0;
      v65 += 168;
      *(v67 + 102) = 0;
    }

    while (v65 != 336);
    *&__src[3] = a1;
    *(&__src[3] + 8) = *(v53 + 16);
    *(&__src[4] + 1) = v250;
    *&__src[5] = -1;
    *(&__src[13] + 1) = a4;
    __src[14] = *(v10 + 16);
    *&__src[15] = v51;
    *(&__src[15] + 1) = -1;
    v289 = 0;
    v287 = 0u;
    v288 = 0u;
    v285 = 0u;
    v286 = 0u;
    memset(v284, 0, sizeof(v284));
    v282 = 0u;
    v283 = 0u;
    v281 = 0u;
    memset(v280, 0, sizeof(v280));
    v275 = 0;
    v277 = 0u;
    v273 = v263;
    v274 = v256;
    v276 = v263;
    *&v277 = v256;
    v278 = v256;
    v279 = v263;
    sub_101695BC8(v280, v264, v265, v52, v59);
    *(&v288 + 1) = a8;
    v289 = a9;
    if (BYTE8(v285) == 100)
    {
      goto LABEL_281;
    }

    memcpy(__dst, __src, 0x178uLL);
    if (BYTE8(v285) > 0x68u)
    {
      if (BYTE8(v285) == 105)
      {
        LODWORD(__dst[1]) = 2;
        if (!v280[0])
        {
          goto LABEL_301;
        }

        __dst[0] = *&v280[1];
        *(&__dst[5] + 8) = *&v280[5];
        *(&__dst[6] + 1) = v280[7];
        __dst[16] = v281;
        *&__dst[17] = v282;
        v85 = DWORD1(v287) == 1;
        *(&__dst[2] + 42 * (DWORD1(v287) != 1) + 2) = 1;
        *(&__dst[2] + 42 * v85 + 2) = 2;
        goto LABEL_279;
      }

      if (BYTE8(v285) != 116)
      {
        if (BYTE8(v285) == 109)
        {
          LODWORD(__dst[1]) = 4;
          __dst[0] = *&v280[1];
          v68 = 0;
          v69 = 1;
          v70 = 5;
          if (v288 == 1)
          {
            do
            {
              v71 = v69;
              v72 = *(&v287 + v68 + 3);
              if (v72 == -1)
              {
                v74 = &__dst[2] + 168 * v68 + 8;
                *(v74 + 3) = xmmword_1019ADEB0;
                *(v74 + 8) = 0;
              }

              else if (v72 == 1)
              {
                v73 = &__dst[2] + 168 * v68 + 8;
                *(v73 + 3) = v245;
                *(v73 + 8) = 0x412E848000000000;
              }

              else
              {
                v75 = &v280[v70];
                v76 = &__dst[2] + 168 * v68 + 8;
                *(v76 + 3) = *v75;
                *(v76 + 8) = v75[2];
              }

              v69 = 0;
              v70 = 8;
              v68 = 1;
            }

            while ((v71 & 1) != 0);
            v77 = DWORD1(v287);
            v78 = v276[2];
            v79 = v276[3];
            v80 = sub_1016989B0(v277);
            v81 = sub_10169A37C(v78, v79, v80);
            v82 = v81;
            if (!(v77 + v81))
            {
              v83 = v81 == -1;
              v84 = v81 != -1;
LABEL_120:
              *(&__dst[2] + 42 * v84 + 2) = 1;
              *(&__dst[2] + 42 * v83 + 2) = 2;
LABEL_152:
              v10 = v241;
LABEL_279:
              v185 = __dst;
LABEL_280:
              sub_101699EEC(a10, v185);
              goto LABEL_281;
            }

            v147 = v77;
            v148 = *(v277 + 16);
            v149 = *(v277 + 24);
            v233 = v147;
            v150 = sub_1016989B0(v277);
            v151 = sub_10169A37C(v148, v149, v150);
            v152 = *(v277 + 24);
            v153 = sub_1016989B0(v277);
            v154 = sub_10169A37C(v152, v153, v276[3]);
            if ((v82 & v233) != 0xFFFFFFFF || v151 != 1)
            {
              v156 = v154;
              if (v233 == 1 && v82 == 1 && v151 == -1)
              {
                if (v154 == -1)
                {
                  v157 = 1;
                }

                else
                {
                  v157 = 3;
                }

                DWORD2(__dst[2]) = 1;
                LODWORD(__dst[13]) = v157;
                BYTE4(__dst[1]) = 1;
                goto LABEL_152;
              }

              if (v233 == v82 && v233 == v151)
              {
                v188 = (v151 == 1) ^ (v154 == 0);
                if (v154 * v233 == -1)
                {
                  v235 = sub_10169A37C(v276[2], v276[3], *(v277 + 24));
                  v189 = v276[3];
                  v190 = sub_1016989B0(v276);
                  if (sub_10169A37C(v189, v190, *(v277 + 24)) * v235 == 1)
                  {
                    v191 = v277;
                    v192 = v276;
                    goto LABEL_229;
                  }
                }

                goto LABEL_231;
              }

              if (!v82)
              {
                if (v233 != v151)
                {
                  if (v151 == 1)
                  {
                    v196 = 2;
                  }

                  else
                  {
                    v196 = 1;
                  }

                  DWORD2(__dst[2]) = v196;
                  v197 = 3;
                  goto LABEL_289;
                }

LABEL_288:
                v197 = 4;
                DWORD2(__dst[2]) = 4;
LABEL_289:
                LODWORD(__dst[13]) = v197;
                goto LABEL_152;
              }

LABEL_248:
              LODWORD(__dst[1]) = 8;
              goto LABEL_152;
            }
          }

          else
          {
            do
            {
              v129 = v69;
              v130 = *(&v287 + v68 + 3);
              if (v130 == -1)
              {
                v132 = &__dst[2] + 168 * v68 + 8;
                *(v132 + 3) = xmmword_1019ADEB0;
                *(v132 + 8) = 0;
              }

              else if (v130 == 1)
              {
                v131 = &__dst[2] + 168 * v68 + 8;
                *(v131 + 3) = v245;
                *(v131 + 8) = 0x412E848000000000;
              }

              else
              {
                v133 = &v280[v70];
                v134 = &__dst[2] + 168 * v68 + 8;
                *(v134 + 3) = *v133;
                *(v134 + 8) = v133[2];
              }

              v69 = 0;
              v70 = 8;
              v68 = 1;
            }

            while ((v129 & 1) != 0);
            v135 = HIDWORD(v286);
            v136 = v278[2];
            v137 = v278[3];
            v138 = sub_1016989B0(v279);
            v139 = sub_10169A37C(v136, v137, v138);
            v140 = v139;
            if (!(v135 + v139))
            {
              v83 = v139 != -1;
              v84 = v139 == -1;
              goto LABEL_120;
            }

            v158 = v135;
            v159 = v279[2];
            v160 = v279[3];
            v234 = v158;
            v161 = sub_1016989B0(v279);
            v162 = sub_10169A37C(v159, v160, v161);
            v163 = v279[3];
            v164 = sub_1016989B0(v279);
            v165 = sub_10169A37C(v163, v164, v278[3]);
            if ((v140 & v234) != 0xFFFFFFFF || v162 != 1)
            {
              v156 = v165;
              if (v234 != 1 || v140 != 1 || v162 != -1)
              {
                if (v234 == v140 && v234 == v162)
                {
                  v188 = (v162 == 1) ^ (v165 != 0);
                  if (v165 * v234 == -1)
                  {
                    v236 = sub_10169A37C(v278[2], v278[3], v279[3]);
                    v193 = v278[3];
                    v194 = sub_1016989B0(v278);
                    if (sub_10169A37C(v193, v194, v279[3]) * v236 == 1)
                    {
                      v191 = v279;
                      v192 = v278;
LABEL_229:
                      if (sub_10169A37C(*(v191 + 16), *(v191 + 24), *(v192 + 24)) * v156 == -1)
                      {
                        v188 ^= 1u;
                      }
                    }
                  }

LABEL_231:
                  *(&__dst[2] + 42 * v188 + 2) = 1;
                  *(&__dst[2] + 42 * (v188 ^ 1) + 2) = 2;
                  BYTE4(__dst[1]) = 1;
                  goto LABEL_152;
                }

                if (!v140)
                {
                  if (v234 != v162)
                  {
                    if (v162 == 1)
                    {
                      v223 = 2;
                    }

                    else
                    {
                      v223 = 1;
                    }

                    LODWORD(__dst[13]) = v223;
                    DWORD2(__dst[2]) = 3;
                    goto LABEL_152;
                  }

                  goto LABEL_288;
                }

                goto LABEL_248;
              }

              if (v165 == -1)
              {
                v167 = 1;
              }

              else
              {
                v167 = 3;
              }

              DWORD2(__dst[2]) = v167;
              LODWORD(__dst[13]) = 1;
LABEL_151:
              BYTE4(__dst[1]) = 1;
              goto LABEL_152;
            }
          }

          DWORD2(__dst[2]) = 2;
          LODWORD(__dst[13]) = 2;
          goto LABEL_151;
        }

        goto LABEL_281;
      }

      v86 = 0;
      LODWORD(__dst[1]) = 3;
      __dst[0] = *&v280[1];
      v87 = 1;
      v88 = 5;
      do
      {
        v89 = v87;
        v90 = *(&v287 + v86 + 3);
        if (v90 == -1)
        {
          v92 = &__dst[2] + 168 * v86 + 8;
          *(v92 + 3) = xmmword_1019ADEB0;
          *(v92 + 8) = 0;
        }

        else if (v90 == 1)
        {
          v91 = &__dst[2] + 168 * v86 + 8;
          *(v91 + 3) = v245;
          *(v91 + 8) = 0x412E848000000000;
        }

        else
        {
          v93 = &v280[v88];
          v94 = &__dst[2] + 168 * v86 + 8;
          *(v94 + 3) = *v93;
          *(v94 + 8) = v93[2];
        }

        v87 = 0;
        v88 = 8;
        v86 = 1;
      }

      while ((v89 & 1) != 0);
      v95 = *(v277 + 16);
      v96 = *(v277 + 24);
      v97 = sub_1016989B0(v276);
      v228 = sub_10169A37C(v95, v96, v97);
      v98 = DWORD1(v287);
      v99 = v276[2];
      v100 = v276[3];
      v101 = sub_1016989B0(v277);
      v102 = v99;
      v103 = v98;
      v232 = sub_10169A37C(v102, v100, v101);
      if (v232 * v98 != -1)
      {
        v104 = *(v277 + 24);
        v105 = sub_1016989B0(v277);
        v106 = sub_1016989B0(v276);
        v226 = sub_10169A37C(v104, v105, v106);
        v108 = v276[2];
        v107 = v276[3];
        v109 = sub_1016989B0(v276);
        v227 = sub_10169A37C(v108, v107, v109);
        v110 = v103;
        v111 = *(v277 + 16);
        v112 = *(v277 + 24);
        v113 = sub_1016989B0(v277);
        v114 = sub_10169A37C(v111, v112, v113);
        if (v232)
        {
          _ZF = 1;
        }

        else
        {
          _ZF = v114 * v110 == 1;
        }

        v116 = !_ZF;
        if (v227 != v110 && v227 != v232 && (v232 | v110 || v227 == -1))
        {
          if (v114 == 1)
          {
            v176 = 2;
          }

          else
          {
            v176 = 1;
          }

          if (v232 == 1 || v110 == 1)
          {
            v178 = 1;
          }

          else
          {
            v178 = 2;
          }

          if (v116)
          {
            v178 = 3;
          }

          DWORD2(__dst[2]) = v176;
          LODWORD(__dst[13]) = v178;
          v10 = v241;
          if ((v116 & 1) == 0)
          {
            BYTE4(__dst[1]) = 1;
          }

          goto LABEL_279;
        }

        v10 = v241;
        if (!((v226 != 0) | v116 & 1))
        {
          v119 = 4;
          DWORD2(__dst[2]) = 4;
LABEL_218:
          LODWORD(__dst[13]) = v119;
          goto LABEL_279;
        }

        if (!v228)
        {
          if (v114 == 1)
          {
            v179 = 2;
          }

          else
          {
            v179 = 1;
          }

          if (v116)
          {
            v119 = 3;
          }

          else
          {
            v119 = v179;
          }

          DWORD2(__dst[2]) = 3;
          goto LABEL_218;
        }

        if (v228 != v226 || v114 * v228 == -1)
        {
          if (v226 + v114)
          {
            if (v228 != -v114)
            {
              goto LABEL_279;
            }

            if (v114 == 1)
            {
              v195 = 2;
            }

            else
            {
              v195 = 1;
            }

            DWORD2(__dst[2]) = v195;
            LODWORD(__dst[13]) = v195;
            if (v116)
            {
              v119 = 3;
              goto LABEL_218;
            }
          }

          else
          {
            if (v114 == 1)
            {
              v186 = 2;
            }

            else
            {
              v186 = 1;
            }

            if (v114 == 1)
            {
              v187 = 1;
            }

            else
            {
              v187 = 2;
            }

            DWORD2(__dst[2]) = v186;
            LODWORD(__dst[13]) = v187;
          }

          BYTE4(__dst[1]) = 1;
          goto LABEL_279;
        }

        if (v114 == 1)
        {
          v117 = 1;
        }

        else
        {
          v117 = 2;
        }

        if (v114 == 1)
        {
          v118 = 2;
        }

        else
        {
          v118 = 1;
        }

        if (v116)
        {
          v119 = 3;
        }

        else
        {
          v119 = v118;
        }

LABEL_217:
        DWORD2(__dst[2]) = v117;
        goto LABEL_218;
      }

      v141 = v276[2];
      v142 = v276[3];
      v143 = sub_1016989B0(v276);
      v144 = sub_10169A37C(v141, v142, v143);
      v10 = v241;
      v145 = v232;
      if (v144 != v103)
      {
        goto LABEL_307;
      }

      if (!v228)
      {
        if (v232 == 1)
        {
          v119 = 1;
        }

        else
        {
          v119 = 2;
        }

        v117 = 3;
        goto LABEL_217;
      }

      if (v228 == v232)
      {
        if (v232 == 1)
        {
          v146 = 1;
        }

        else
        {
          v146 = 2;
        }

        DWORD2(__dst[2]) = v146;
        LODWORD(__dst[13]) = v146;
      }

      else
      {
LABEL_307:
        if (v144 != v232)
        {
          goto LABEL_166;
        }

        v168 = *(v277 + 24);
        v169 = sub_1016989B0(v277);
        v170 = sub_1016989B0(v276);
        v171 = sub_10169A37C(v168, v169, v170);
        if (!v171)
        {
          goto LABEL_288;
        }

        v145 = v232;
        v10 = v241;
        if (v171 != v232)
        {
LABEL_166:
          if (v145 == 1)
          {
            v174 = 2;
          }

          else
          {
            v174 = 1;
          }

          if (v145 == 1)
          {
            v175 = 1;
          }

          else
          {
            v175 = 2;
          }

          DWORD2(__dst[2]) = v174;
          LODWORD(__dst[13]) = v175;
          goto LABEL_279;
        }

        if (v232 == 1)
        {
          v172 = 1;
        }

        else
        {
          v172 = 2;
        }

        if (v232 == 1)
        {
          v173 = 2;
        }

        else
        {
          v173 = 1;
        }

        DWORD2(__dst[2]) = v172;
        LODWORD(__dst[13]) = v173;
      }

      BYTE4(__dst[1]) = 1;
      goto LABEL_279;
    }

    if (BYTE8(v285) != 99)
    {
      if (BYTE8(v285) != 101 || (BYTE9(v285) & 1) != 0)
      {
        goto LABEL_281;
      }

      sub_101695974(__dst, v280, &v275);
      goto LABEL_279;
    }

    if ((BYTE9(v285) & 1) == 0)
    {
      if (HIDWORD(v287))
      {
        if (vabdd_f64(*&v282, *&v284[3]) >= 50.0)
        {
          v128 = *&v282 < *&v284[3];
        }

        else
        {
          if (*(&v281 + 1) == 0.0)
          {
            __assert_rtn("apply", "segment_ratio.hpp", 56, "lhs.denominator() != Type(0)");
          }

          if (*&v284[2] == 0.0)
          {
            __assert_rtn("apply", "segment_ratio.hpp", 57, "rhs.denominator() != Type(0)");
          }

          v126 = *&v281 / *(&v281 + 1);
          v127 = *&v284[1] / *&v284[2];
          if (*&v281 / *(&v281 + 1) == *&v284[1] / *&v284[2])
          {
            v128 = 0;
          }

          else if (COERCE_UNSIGNED_INT64(fabs(*&v281 / *(&v281 + 1))) <= 0x7FEFFFFFFFFFFFFFLL && COERCE_UNSIGNED_INT64(fabs(*&v284[1] / *&v284[2])) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            v198 = fabs(v126);
            v199 = fabs(v127);
            v200 = vabdd_f64(v126, v127);
            if (v198 < v199)
            {
              v198 = v199;
            }

            if (v198 < 1.0)
            {
              v198 = 1.0;
            }

            v128 = v200 > v198 * 2.22044605e-16;
          }

          else
          {
            v128 = 1;
          }

          if (v126 >= v127)
          {
            v128 = 0;
          }
        }

        LODWORD(__dst[1]) = 5;
        if (v280[0] <= v128)
        {
LABEL_301:
          __assert_rtn("assign_point", "get_turn_info.hpp", 164, "index < info.count");
        }

        __dst[0] = *&v280[2 * v128 + 1];
        v237 = HIDWORD(v287);
        v201 = &v280[7 * v128 + 5];
        *(&__dst[5] + 8) = *v201;
        *(&__dst[6] + 1) = v201[2];
        __dst[16] = *(v201 + 3);
        *&__dst[17] = v201[5];
        v202 = v276[2];
        v203 = v276[3];
        v204 = sub_1016989B0(v276);
        v205 = sub_10169A37C(v202, v203, v204);
        v206 = *(v277 + 16);
        v207 = *(v277 + 24);
        v208 = sub_1016989B0(v277);
        v209 = sub_10169A37C(v206, v207, v208);
        v210 = v209;
        if (v237 == 1)
        {
          v211 = v205;
        }

        else
        {
          v211 = v209;
        }

        if (v211 * v237 == 1)
        {
          v212 = 1;
        }

        else
        {
          v212 = 2;
        }

        if (v211 * v237 == 1)
        {
          v213 = 2;
        }

        else
        {
          v213 = 1;
        }

        v214 = v211 == 0;
        if (v211)
        {
          v215 = v212;
        }

        else
        {
          v215 = 4;
        }

        if (v214)
        {
          v216 = 4;
        }

        else
        {
          v216 = v213;
        }

        DWORD2(__dst[2]) = v215;
        LODWORD(__dst[13]) = v216;
        if (v205)
        {
          v217 = v265;
        }

        else
        {
          v217 = sub_1016989B0(v263);
        }

        v219 = *(__dst + 1);
        v218 = *__dst;
        *&__dst[7] = (*(__dst + 1) - v217[1]) * (*(__dst + 1) - v217[1]) + (*__dst - *v217) * (*__dst - *v217);
        v10 = v241;
        if (v210)
        {
          v220 = *v257;
          v221 = v257[1];
        }

        else
        {
          v222 = sub_1016989B0(v256);
          v219 = *(__dst + 1);
          v218 = *__dst;
          v220 = *v222;
          v221 = v222[1];
        }

        *(&__dst[17] + 1) = (v219 - v221) * (v219 - v221) + (v218 - v220) * (v218 - v220);
      }

      else
      {
        sub_101695974(__dst, v280, &v275);
        LODWORD(__dst[1]) = 5;
      }

      goto LABEL_279;
    }

    memcpy(v272, __src, sizeof(v272));
    v120 = v288;
    if (HIDWORD(v287) == 1)
    {
      v121 = v276[2];
      v122 = v276[3];
      v123 = sub_1016989B0(v276);
      v124 = sub_10169A37C(v121, v122, v123);
      if (v124 == 1)
      {
        v125 = 2;
        v10 = v241;
      }

      else
      {
        v10 = v241;
        if (!v124)
        {
          goto LABEL_197;
        }

        v125 = 1;
      }

      *&v272[208] = 3;
      *&v272[40] = v125;
      *&v272[16] = 5;
      if (v280[0] <= 1uLL)
      {
        goto LABEL_301;
      }

      *v272 = *&v280[3];
      *&v272[88] = v283;
      *&v272[104] = v284[0];
      *&v272[256] = *&v284[1];
      *&v272[272] = v284[3];
      sub_101699EEC(a10, v272);
    }

LABEL_197:
    if (v120 == 1)
    {
      v180 = *(v277 + 16);
      v181 = *(v277 + 24);
      v182 = sub_1016989B0(v277);
      v183 = sub_10169A37C(v180, v181, v182);
      if (v183 == 1)
      {
        v184 = 2;
        v10 = v241;
      }

      else
      {
        v10 = v241;
        if (!v183)
        {
          goto LABEL_281;
        }

        v184 = 1;
      }

      *&v272[208] = v184;
      *&v272[40] = 3;
      *&v272[16] = 5;
      if (!v280[0])
      {
        goto LABEL_301;
      }

      *v272 = *&v280[1];
      *&v272[88] = *&v280[5];
      *&v272[104] = v280[7];
      *&v272[256] = v281;
      *&v272[272] = v282;
      v185 = v272;
      goto LABEL_280;
    }

LABEL_281:
    v53 = a3;
    v64 = v252;
    goto LABEL_282;
  }
}

BOOL sub_101695318(int a1, double a2, double a3, double a4, double a5, double a6)
{
  result = 0;
  v9 = a2 > a6 || a2 < a5;
  if (!v9 || a6 - a5 >= 360.0)
  {
    return result;
  }

  v12 = a4;
  v14 = a2 - a5;
  v15 = vabdd_f64(a2, a5);
  v16 = 180.0;
  if (v15 != 180.0)
  {
    if (COERCE_UNSIGNED_INT64(fabs(a2 - a5)) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_32;
    }

    v23 = fabs(v15 + -180.0);
    v16 = 180.0;
    if (v15 >= 180.0)
    {
      v24 = v15;
    }

    else
    {
      v24 = 180.0;
    }

    if (v24 < 1.0)
    {
      v24 = 1.0;
    }

    if (v23 > v24 * 2.22044605e-16)
    {
LABEL_32:
      v16 = 180.0;
      if (v14 <= 180.0)
      {
        v17 = a2 - a5;
        if (v14 >= -180.0)
        {
          goto LABEL_9;
        }

        v38 = v14 + -180.0;
        v40 = a3;
        v41 = fmod(v38, 360.0);
        a3 = v40;
        v12 = a4;
        v14 = a2 - a5;
        v16 = v41 + 180.0;
      }

      else
      {
        v25 = v14 + 180.0;
        v27 = a3;
        v28 = fmod(v25, 360.0);
        a3 = v27;
        v12 = a4;
        v14 = a2 - a5;
        v17 = v28 + -180.0;
        if (v17 != -180.0)
        {
          if ((*&v17 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_9;
          }

          v29 = fabs(v17);
          v16 = 180.0;
          v30 = fabs(v17 + 180.0);
          if (v29 < 180.0)
          {
            v29 = 180.0;
          }

          if (v29 < 1.0)
          {
            v29 = 1.0;
          }

          if (v30 > v29 * 2.22044605e-16)
          {
            goto LABEL_9;
          }
        }
      }
    }
  }

  v17 = v16;
LABEL_9:
  if (v17 < 0.0)
  {
    v17 = v17 + 360.0;
  }

  if (v17 + a5 <= a6)
  {
    return 0;
  }

  if (a1 != -1)
  {
    if (a1 == 1)
    {
      v18 = 180.0;
      if (v15 != 180.0)
      {
        if ((*&v14 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_59;
        }

        v42 = fabs(v15 + -180.0);
        v18 = 180.0;
        if (v15 >= 180.0)
        {
          v43 = v15;
        }

        else
        {
          v43 = 180.0;
        }

        if (v43 < 1.0)
        {
          v43 = 1.0;
        }

        if (v42 > v43 * 2.22044605e-16)
        {
LABEL_59:
          v18 = 180.0;
          if (v14 <= 180.0)
          {
            if (v14 >= -180.0)
            {
              goto LABEL_16;
            }

            v58 = a3;
            v59 = fmod(v14 + -180.0, 360.0);
            a3 = v58;
            v18 = v59 + 180.0;
          }

          else
          {
            v44 = a3;
            v45 = fmod(v14 + 180.0, 360.0);
            a3 = v44;
            v14 = v45 + -180.0;
            if (v45 + -180.0 != -180.0)
            {
              if (COERCE_UNSIGNED_INT64(fabs(v45 + -180.0)) > 0x7FEFFFFFFFFFFFFFLL)
              {
                goto LABEL_16;
              }

              v46 = fabs(v14);
              v18 = 180.0;
              v47 = fabs(v14 + 180.0);
              if (v46 < 180.0)
              {
                v46 = 180.0;
              }

              if (v46 < 1.0)
              {
                v46 = 1.0;
              }

              if (v47 > v46 * 2.22044605e-16)
              {
LABEL_16:
                v19 = vabdd_f64(a3, a5);
                v20 = 180.0;
                if (v19 != 180.0)
                {
                  v21 = a3 - a5;
                  if (COERCE__INT64(fabs(a3 - a5)) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    goto LABEL_74;
                  }

                  v48 = fabs(v19 + -180.0);
                  v20 = 180.0;
                  if (v19 < 180.0)
                  {
                    v19 = 180.0;
                  }

                  if (v19 < 1.0)
                  {
                    v19 = 1.0;
                  }

                  if (v48 > v19 * 2.22044605e-16)
                  {
LABEL_74:
                    v20 = 180.0;
                    if (v21 <= 180.0)
                    {
                      if (v21 >= -180.0)
                      {
                        goto LABEL_18;
                      }

                      v20 = fmod(v21 + -180.0, 360.0) + 180.0;
                    }

                    else
                    {
                      v21 = fmod(v21 + 180.0, 360.0) + -180.0;
                      if (v21 != -180.0)
                      {
                        if ((*&v21 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                        {
                          goto LABEL_18;
                        }

                        v49 = fabs(v21);
                        v20 = 180.0;
                        v50 = fabs(v21 + 180.0);
                        if (v49 < 180.0)
                        {
                          v49 = 180.0;
                        }

                        if (v49 < 1.0)
                        {
                          v49 = 1.0;
                        }

                        if (v50 > v49 * 2.22044605e-16)
                        {
                          goto LABEL_18;
                        }
                      }
                    }
                  }
                }

                v21 = v20;
LABEL_18:
                v22 = v21 <= 0.0;
                if (v21 > v14)
                {
                  v22 = 0;
                }

                return v14 < 0.0 && v22;
              }
            }
          }
        }
      }

      v14 = v18;
      goto LABEL_16;
    }

    return 0;
  }

  v31 = vabdd_f64(a2, a6);
  v32 = 180.0;
  if (v31 == 180.0)
  {
    goto LABEL_42;
  }

  v33 = a2 - a6;
  if (COERCE__INT64(fabs(a2 - a6)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v51 = fabs(v31 + -180.0);
    v32 = 180.0;
    if (v31 < 180.0)
    {
      v31 = 180.0;
    }

    if (v31 < 1.0)
    {
      v31 = 1.0;
    }

    if (v51 <= v31 * 2.22044605e-16)
    {
      goto LABEL_42;
    }
  }

  v32 = 180.0;
  if (v33 <= 180.0)
  {
    if (v33 >= -180.0)
    {
      goto LABEL_43;
    }

    v32 = fmod(v33 + -180.0, 360.0) + 180.0;
    goto LABEL_42;
  }

  v52 = fmod(v33 + 180.0, 360.0);
  v33 = v52 + -180.0;
  if (v52 + -180.0 == -180.0)
  {
    goto LABEL_42;
  }

  if (COERCE_UNSIGNED_INT64(fabs(v52 + -180.0)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v53 = fabs(v33);
    v32 = 180.0;
    v54 = fabs(v33 + 180.0);
    if (v53 < 180.0)
    {
      v53 = 180.0;
    }

    if (v53 < 1.0)
    {
      v53 = 1.0;
    }

    if (v54 <= v53 * 2.22044605e-16)
    {
LABEL_42:
      v33 = v32;
    }
  }

LABEL_43:
  v34 = vabdd_f64(v12, a6);
  v35 = 180.0;
  if (v34 != 180.0)
  {
    v36 = v12 - a6;
    if (COERCE__INT64(fabs(v12 - a6)) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_104;
    }

    v55 = fabs(v34 + -180.0);
    v35 = 180.0;
    if (v34 < 180.0)
    {
      v34 = 180.0;
    }

    if (v34 < 1.0)
    {
      v34 = 1.0;
    }

    if (v55 > v34 * 2.22044605e-16)
    {
LABEL_104:
      v35 = 180.0;
      if (v36 <= 180.0)
      {
        if (v36 >= -180.0)
        {
          goto LABEL_45;
        }

        v35 = fmod(v36 + -180.0, 360.0) + 180.0;
      }

      else
      {
        v36 = fmod(v36 + 180.0, 360.0) + -180.0;
        if (v36 != -180.0)
        {
          if ((*&v36 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_45;
          }

          v56 = fabs(v36);
          v35 = 180.0;
          v57 = fabs(v36 + 180.0);
          if (v56 < 180.0)
          {
            v56 = 180.0;
          }

          if (v56 < 1.0)
          {
            v56 = 1.0;
          }

          if (v57 > v56 * 2.22044605e-16)
          {
            goto LABEL_45;
          }
        }
      }
    }
  }

  v36 = v35;
LABEL_45:
  v37 = v33 > 0.0;
  if (v36 < 0.0)
  {
    v37 = 0;
  }

  return v33 <= v36 && v37;
}

uint64_t sub_101695974(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(a2 + 80);
  v6 = *(a2 + 136);
  if (vabdd_f64(v5, v6) >= 50.0)
  {
    v11 = v5 < v6;
  }

  else
  {
    v7 = *(a2 + 72);
    if (v7 == 0.0)
    {
      __assert_rtn("apply", "segment_ratio.hpp", 56, "lhs.denominator() != Type(0)");
    }

    v8 = *(a2 + 128);
    if (v8 == 0.0)
    {
      __assert_rtn("apply", "segment_ratio.hpp", 57, "rhs.denominator() != Type(0)");
    }

    v9 = *(a2 + 64) / v7;
    v10 = *(a2 + 120) / v8;
    if (v9 == v10)
    {
      v11 = 0;
    }

    else if ((*&v9 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v10 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v12 = fabs(v9);
      v13 = fabs(v10);
      v14 = vabdd_f64(v9, v10);
      if (v12 < v13)
      {
        v12 = v13;
      }

      if (v12 < 1.0)
      {
        v12 = 1.0;
      }

      v11 = v14 > v12 * 2.22044605e-16;
    }

    else
    {
      v11 = 1;
    }

    if (v9 >= v10)
    {
      v11 = 0;
    }
  }

  *(a1 + 16) = 6;
  if (*a2 <= v11)
  {
    __assert_rtn("assign_point", "get_turn_info.hpp", 164, "index < info.count");
  }

  *a1 = *(a2 + 16 * v11 + 8);
  v15 = a2 + 56 * v11;
  v16 = *(v15 + 40);
  *(a1 + 104) = *(v15 + 56);
  *(a1 + 88) = v16;
  v17 = *(v15 + 64);
  *(a1 + 272) = *(v15 + 80);
  *(a1 + 256) = v17;
  v18 = *(a3 + 16);
  v19 = *(v18 + 24);
  v20 = sub_1016989B0(v18);
  v21 = sub_1016989B0(*(a3 + 8));
  v22 = sub_10169A37C(v19, v20, v21);
  v23 = *(a3 + 8);
  v24 = *(v23 + 16);
  v25 = *(v23 + 24);
  v26 = sub_1016989B0(v23);
  v27 = sub_10169A37C(v24, v25, v26);
  v29 = *(a3 + 8);
  v28 = *(a3 + 16);
  v30 = *(v29 + 16);
  v31 = *(v29 + 24);
  v32 = sub_1016989B0(v28);
  result = sub_10169A37C(v30, v31, v32);
  if (v22 || v27 != result)
  {
    if (result * v27 == -1)
    {
      v35 = v27 == -1;
    }

    else
    {
      v35 = v22 == -1;
    }

    if (v35)
    {
      v36 = 2;
    }

    else
    {
      v36 = 1;
    }

    *(a1 + 40) = v36;
    if (v35)
    {
      v34 = 1;
    }

    else
    {
      v34 = 2;
    }
  }

  else
  {
    v34 = 4;
    *(a1 + 40) = 4;
  }

  *(a1 + 208) = v34;
  return result;
}

void sub_101695BC8(uint64_t a1, double *a2, double *a3, double *a4, double *a5)
{
  v523 = 0;
  v10 = a2[1];
  *v524 = *a2;
  *v525 = v10;
  sub_101690AC8(v524, v525, 1);
  v11 = *v524;
  v12 = a3[1];
  *v524 = *a3;
  *v525 = v12;
  sub_101690AC8(v524, v525, 1);
  if (v11 != *v524)
  {
    if ((*&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v524[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_19;
    }

    v14 = fabs(v11);
    v15 = fabs(*v524);
    v16 = vabdd_f64(v11, *v524);
    if (v14 < v15)
    {
      v14 = v15;
    }

    if (v14 < 1.0)
    {
      v14 = 1.0;
    }

    if (v16 > v14 * 2.22044605e-16)
    {
      goto LABEL_19;
    }
  }

  if (v10 == v12)
  {
    goto LABEL_3;
  }

  if ((*&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    goto LABEL_19;
  }

  v17 = fabs(v10);
  v18 = fabs(v12);
  v19 = vabdd_f64(v10, v12);
  if (v17 < v18)
  {
    v17 = v18;
  }

  if (v17 < 1.0)
  {
    v17 = 1.0;
  }

  if (v19 <= v17 * 2.22044605e-16)
  {
LABEL_3:
    v13 = 1;
  }

  else
  {
LABEL_19:
    v13 = 0;
  }

  v20 = a4[1];
  *v524 = *a4;
  *v525 = v20;
  sub_101690AC8(v524, v525, 1);
  v21 = *v524;
  v22 = a5[1];
  *v524 = *a5;
  *v525 = v22;
  sub_101690AC8(v524, v525, 1);
  if (v21 != *v524)
  {
    if ((*&v21 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v524[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_38;
    }

    v28 = fabs(v21);
    v29 = fabs(*v524);
    v30 = vabdd_f64(v21, *v524);
    if (v28 < v29)
    {
      v28 = v29;
    }

    if (v28 < 1.0)
    {
      v28 = 1.0;
    }

    if (v30 > v28 * 2.22044605e-16)
    {
      goto LABEL_38;
    }
  }

  if (v20 == v22)
  {
    if (v13)
    {
      goto LABEL_23;
    }

    v31 = 1;
  }

  else
  {
    if ((*&v20 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v22 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
LABEL_38:
      v31 = 0;
      goto LABEL_40;
    }

    v142 = fabs(v20);
    v143 = fabs(v22);
    v144 = vabdd_f64(v20, v22);
    if (v142 < v143)
    {
      v142 = v143;
    }

    if (v142 < 1.0)
    {
      v142 = 1.0;
    }

    v145 = v142 * 2.22044605e-16;
    v31 = v144 <= v145;
    if (v144 <= v145)
    {
      v146 = v13;
    }

    else
    {
      v146 = 0;
    }

    if (v146)
    {
LABEL_23:
      v23 = a2[1];
      *v524 = *a2;
      *v525 = v23;
      sub_101690AC8(v524, v525, 1);
      v24 = *v524;
      v25 = a5[1];
      *v524 = *a5;
      *v525 = v25;
      sub_101690AC8(v524, v525, 1);
      if (v24 != *v524)
      {
        if ((*&v24 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v524[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_168;
        }

        v113 = fabs(v24);
        v114 = fabs(*v524);
        v115 = vabdd_f64(v24, *v524);
        if (v113 < v114)
        {
          v113 = v114;
        }

        if (v113 < 1.0)
        {
          v113 = 1.0;
        }

        if (v115 > v113 * 2.22044605e-16)
        {
          goto LABEL_168;
        }
      }

      if (v23 != v25)
      {
        if ((*&v23 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v25 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_168;
        }

        v147 = fabs(v23);
        v148 = fabs(v25);
        v149 = vabdd_f64(v23, v25);
        if (v147 < v148)
        {
          v147 = v148;
        }

        if (v147 < 1.0)
        {
          v147 = 1.0;
        }

        if (v149 > v147 * 2.22044605e-16)
        {
LABEL_168:
          v150 = 0;
          *&v524[0] = 0;
          do
          {
            v151 = v524 + v150;
            *(v151 + 40) = xmmword_1019ADEB0;
            *(v151 + 7) = 0;
            *(v151 + 8) = 0;
            *(v151 + 72) = xmmword_1019ADEC0;
            v150 += 56;
            v151[88] = 0;
          }

          while (v150 != 112);
          goto LABEL_636;
        }
      }

      v26 = 0;
      memset(&v524[1] + 8, 0, 128);
      do
      {
        v27 = v524 + v26;
        *(v27 + 40) = xmmword_1019ADEB0;
        *(v27 + 7) = 0;
        *(v27 + 8) = 0;
        *(v27 + 72) = xmmword_1019ADEC0;
        v26 += 56;
        v27[88] = 0;
      }

      while (v26 != 112);
      goto LABEL_58;
    }
  }

LABEL_40:
  v32 = sub_101698C54(a2);
  v34 = v33;
  v36 = v35;
  v522[0] = v32;
  v522[1] = v33;
  v522[2] = v35;
  v37 = sub_101698C54(a3);
  v39 = v38;
  v521[0] = v37;
  v521[1] = v40;
  v500 = v40;
  v521[2] = v38;
  v41 = sub_101698C54(a4);
  v43 = v42;
  v45 = v44;
  v520[0] = v41;
  v520[1] = v42;
  v520[2] = v44;
  v46 = sub_101698C54(a5);
  v48 = v45;
  v49 = v43;
  v50 = v41;
  v51 = v46;
  v53 = v52;
  v54 = v47;
  v519[0] = v46;
  v519[1] = v52;
  v519[2] = v47;
  v517 = 0;
  v518 = 0;
  v55 = v49 * v47 - v48 * v52;
  v56 = v48 * v46 - v50 * v47;
  v57 = v50 * v52 - v49 * v46;
  v514 = v55;
  v515 = v56;
  v516 = v57;
  v513 = 0.0;
  v58 = 0.0;
  if (v31)
  {
    v59 = 0;
    v60 = 0;
    v61 = 0;
    v62 = 1;
    v63 = 0.0;
    v64 = v500;
    goto LABEL_44;
  }

  v65 = 1.0;
  v63 = 1.0 - (v48 * v47 + v49 * v53 + v50 * v46);
  v513 = v63;
  v64 = v500;
  if (v63 == 0.0)
  {
    goto LABEL_43;
  }

  if (COERCE_UNSIGNED_INT64(fabs(1.0 - (v48 * v47 + v49 * v53 + v50 * v46))) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v88 = fabs(v63);
    if (v88 >= 1.0)
    {
      v65 = v88;
    }

    if (v88 <= v65 * 2.22044605e-16)
    {
LABEL_43:
      v59 = 0;
      v60 = 0;
      v513 = 0.0;
      v62 = 1;
      v63 = 0.0;
      v61 = 1;
      goto LABEL_44;
    }
  }

  v89 = v36 * v57 + v56 * v34 + v55 * v32;
  if (v89 == 0.0)
  {
    goto LABEL_65;
  }

  if (COERCE_UNSIGNED_INT64(fabs(v36 * v57 + v56 * v34 + v55 * v32)) < 0x7FF0000000000000)
  {
    v240 = fabs(v89);
    v241 = 1.0;
    if (v240 >= 1.0)
    {
      v241 = v240;
    }

    v242 = v241 * 2.22044605e-16;
    if (v89 > 0.0)
    {
      v60 = 1;
    }

    else
    {
      v60 = -1;
    }

    if (v240 <= v242)
    {
LABEL_65:
      v60 = 0;
    }
  }

  else if (v89 > 0.0)
  {
    v60 = 1;
  }

  else
  {
    v60 = -1;
  }

  v243 = v39 * v57 + v56 * v500 + v55 * v37;
  if (v243 != 0.0)
  {
    if (COERCE_UNSIGNED_INT64(fabs(v39 * v57 + v56 * v500 + v55 * v37)) >= 0x7FF0000000000000)
    {
      if (v243 > 0.0)
      {
        v59 = 1;
      }

      else
      {
        v59 = -1;
      }

      goto LABEL_334;
    }

    v244 = fabs(v243);
    v245 = 1.0;
    if (v244 >= 1.0)
    {
      v245 = v244;
    }

    v246 = v245 * 2.22044605e-16;
    if (v243 > 0.0)
    {
      v59 = 1;
    }

    else
    {
      v59 = -1;
    }

    if (v244 > v246)
    {
      goto LABEL_334;
    }
  }

  v59 = 0;
LABEL_334:
  v517 = __PAIR64__(v59, v60);
  if (v59 * v60 == 1)
  {
    v247 = 0;
    *&v524[0] = 0;
    do
    {
      v248 = v524 + v247;
      *(v248 + 40) = xmmword_1019ADEB0;
      *(v248 + 7) = 0;
      *(v248 + 8) = 0;
      *(v248 + 72) = xmmword_1019ADEC0;
      v247 += 56;
      v248[88] = 0;
    }

    while (v247 != 112);
    goto LABEL_636;
  }

  v62 = 0;
  v61 = 0;
LABEL_44:
  v66 = v34 * v39 - v36 * v64;
  v67 = v39;
  v68 = v36 * v37 - v32 * v39;
  v510 = v66;
  v511 = v68;
  v69 = v37;
  v70 = v32 * v64 - v34 * v37;
  v512 = v70;
  v509 = 0.0;
  v487 = v67;
  v493 = v69;
  if (v13)
  {
    v71 = 0;
    v72 = 0;
    goto LABEL_48;
  }

  v73 = 1.0 - (v36 * v67 + v34 * v64 + v32 * v69);
  v509 = v73;
  if (v73 != 0.0)
  {
    if (COERCE_UNSIGNED_INT64(fabs(1.0 - (v36 * v67 + v34 * v64 + v32 * v69))) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_70;
    }

    v90 = fabs(v73);
    v91 = 1.0;
    if (v90 >= 1.0)
    {
      v91 = v90;
    }

    if (v90 > v91 * 2.22044605e-16)
    {
LABEL_70:
      v92 = v70 * v48 + v68 * v49 + v66 * v50;
      if (v92 == 0.0)
      {
LABEL_71:
        v72 = 0;
        goto LABEL_345;
      }

      if (COERCE_UNSIGNED_INT64(fabs(v70 * v48 + v68 * v49 + v66 * v50)) < 0x7FF0000000000000)
      {
        v249 = fabs(v92);
        v250 = 1.0;
        if (v249 >= 1.0)
        {
          v250 = v249;
        }

        v251 = v250 * 2.22044605e-16;
        if (v92 > 0.0)
        {
          v72 = 1;
        }

        else
        {
          v72 = -1;
        }

        if (v249 <= v251)
        {
          goto LABEL_71;
        }
      }

      else if (v92 > 0.0)
      {
        v72 = 1;
      }

      else
      {
        v72 = -1;
      }

LABEL_345:
      v252 = v70 * v54 + v68 * v53 + v66 * v51;
      if (v252 == 0.0)
      {
LABEL_346:
        v71 = 0;
        goto LABEL_357;
      }

      if (COERCE_UNSIGNED_INT64(fabs(v70 * v54 + v68 * v53 + v66 * v51)) < 0x7FF0000000000000)
      {
        v253 = fabs(v252);
        v254 = 1.0;
        if (v253 >= 1.0)
        {
          v254 = v253;
        }

        v255 = v254 * 2.22044605e-16;
        if (v252 > 0.0)
        {
          v71 = 1;
        }

        else
        {
          v71 = -1;
        }

        if (v253 <= v255)
        {
          goto LABEL_346;
        }
      }

      else if (v252 > 0.0)
      {
        v71 = 1;
      }

      else
      {
        v71 = -1;
      }

LABEL_357:
      v518 = __PAIR64__(v71, v72);
      if (v71 * v72 == 1)
      {
        v256 = 0;
        *&v524[0] = 0;
        do
        {
          v257 = v524 + v256;
          *(v257 + 40) = xmmword_1019ADEB0;
          *(v257 + 7) = 0;
          *(v257 + 8) = 0;
          *(v257 + 72) = xmmword_1019ADEC0;
          v256 += 56;
          v257[88] = 0;
        }

        while (v256 != 112);
        goto LABEL_636;
      }

      v258 = sqrt(v70 * v70 + v68 * v68 + v66 * v66);
      if (v258 == 0.0)
      {
        goto LABEL_363;
      }

      if ((*&v258 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_370;
      }

      v259 = fabs(v258);
      v260 = 1.0;
      if (v259 >= 1.0)
      {
        v260 = v259;
      }

      if (v259 <= v260 * 2.22044605e-16)
      {
LABEL_363:
        if (!v59 || !v60)
        {
          v59 = 0;
          v60 = 0;
          v517 = 0;
        }

        v74 = 1;
      }

      else
      {
LABEL_370:
        v74 = 0;
        v66 = v66 / v258;
        v68 = v68 / v258;
        v510 = v66;
        v511 = v68;
        v70 = v70 / v258;
        v512 = v70;
      }

      v58 = v73;
      if (v62)
      {
        goto LABEL_53;
      }

      goto LABEL_49;
    }
  }

  v71 = 0;
  v72 = 0;
  v509 = 0.0;
  v61 = 1;
LABEL_48:
  v74 = 1;
  if (v62)
  {
LABEL_53:
    if (!v74)
    {
      v87 = 1;
      goto LABEL_77;
    }

    v76 = a2[1];
    *v524 = *a2;
    *v525 = v76;
    sub_101690AC8(v524, v525, 1);
    v77 = *v524;
    v78 = a5[1];
    *v524 = *a5;
    *v525 = v78;
    sub_101690AC8(v524, v525, 1);
    if (v77 != *v524)
    {
      if ((*&v77 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v524[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_149;
      }

      v110 = fabs(v77);
      v111 = fabs(*v524);
      v112 = vabdd_f64(v77, *v524);
      if (v110 < v111)
      {
        v110 = v111;
      }

      if (v110 < 1.0)
      {
        v110 = 1.0;
      }

      if (v112 > v110 * 2.22044605e-16)
      {
        goto LABEL_149;
      }
    }

    if (v76 != v78)
    {
      if ((*&v76 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v78 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_149;
      }

      v137 = fabs(v76);
      v138 = fabs(v78);
      v139 = vabdd_f64(v76, v78);
      if (v137 < v138)
      {
        v137 = v138;
      }

      if (v137 < 1.0)
      {
        v137 = 1.0;
      }

      if (v139 > v137 * 2.22044605e-16)
      {
LABEL_149:
        v140 = 0;
        *&v524[0] = 0;
        do
        {
          v141 = v524 + v140;
          *(v141 + 40) = xmmword_1019ADEB0;
          *(v141 + 7) = 0;
          *(v141 + 8) = 0;
          *(v141 + 72) = xmmword_1019ADEC0;
          v140 += 56;
          v141[88] = 0;
        }

        while (v140 != 112);
        goto LABEL_636;
      }
    }

    v79 = 0;
    memset(&v524[1] + 8, 0, 128);
    do
    {
      v80 = v524 + v79;
      *(v80 + 40) = xmmword_1019ADEB0;
      *(v80 + 7) = 0;
      *(v80 + 8) = 0;
      *(v80 + 72) = xmmword_1019ADEC0;
      v79 += 56;
      v80[88] = 0;
    }

    while (v79 != 112);
LABEL_58:
    *&v524[0] = 1;
    *(v524 + 8) = *a2;
    memset(&v525[2], 0, 32);
    v81 = v524[7];
    *(a1 + 96) = v524[6];
    *(a1 + 112) = v81;
    *(a1 + 128) = v524[8];
    v82 = v524[3];
    *(a1 + 32) = v524[2];
    *(a1 + 48) = v82;
    v83 = v524[5];
    *(a1 + 64) = v524[4];
    *(a1 + 80) = v83;
    v84 = v524[1];
    *a1 = v524[0];
    *(a1 + 16) = v84;
    v85 = *&v525[16];
    *(a1 + 154) = *v525;
    *&v525[34] = 0;
    *(a1 + 144) = *&v524[9];
    v86 = 48;
LABEL_637:
    *(a1 + 152) = v86;
    *(a1 + 170) = v85;
    v123 = *&v525[26];
    goto LABEL_638;
  }

LABEL_49:
  v75 = sqrt(v57 * v57 + v56 * v56 + v55 * v55);
  if (v75 == 0.0)
  {
    goto LABEL_51;
  }

  if ((*&v75 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v93 = fabs(v75);
    v94 = 1.0;
    if (v93 >= 1.0)
    {
      v94 = v93;
    }

    if (v93 <= v94 * 2.22044605e-16)
    {
LABEL_51:
      if (!v71 || !v72)
      {
        v71 = 0;
        v72 = 0;
        v518 = 0;
      }

      goto LABEL_53;
    }
  }

  v87 = 0;
  v55 = v55 / v75;
  v56 = v56 / v75;
  v514 = v55;
  v515 = v56;
  v57 = v57 / v75;
  v516 = v57;
LABEL_77:
  v95 = v72 | v71;
  v484 = v63;
  if (!(v60 | v59))
  {
    if (!v95)
    {
      goto LABEL_115;
    }

    v109 = &v518 + 4;
    LODWORD(v518) = 0;
LABEL_114:
    *v109 = 0;
LABEL_115:
    v96 = v70 * v57 + v68 * v56 + v66 * v55;
    if (!v74)
    {
LABEL_81:
      if (v87)
      {
        v98 = v58;
        v526[0] = 0.0;
        if (sub_101698D70(a2, a3, a4, v522, &v510, v520, v519, &v509, v526, v61))
        {
          v99 = v98;
          v100 = -v98;
          v101 = v98 == 0.0;
          v102 = v98 < 0.0;
          if (v98 >= 0.0)
          {
            v103 = v526[0];
          }

          else
          {
            v103 = -v526[0];
          }

          if (v102)
          {
            v104 = v100;
          }

          else
          {
            v104 = v99;
          }

          v105 = 0.0;
          if (!v101)
          {
            v105 = v103 * 1000000.0 / v104;
          }

          v106 = 0;
          *(a1 + 136) = 0u;
          *(a1 + 120) = 0u;
          *(a1 + 104) = 0u;
          *(a1 + 88) = 0u;
          *(a1 + 72) = 0u;
          *(a1 + 56) = 0u;
          *(a1 + 40) = 0u;
          *(a1 + 24) = 0u;
          do
          {
            v107 = a1 + v106;
            *(v107 + 40) = xmmword_1019ADEB0;
            *(v107 + 56) = 0;
            *(v107 + 64) = 0;
            *(v107 + 72) = xmmword_1019ADEC0;
            v106 += 56;
            *(v107 + 88) = 0;
          }

          while (v106 != 112);
          *a1 = 1;
          *(a1 + 8) = *a4;
          if ((atomic_load_explicit(&qword_101FCB058, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_101FCB058))
          {
            qword_101FCB050 = 0x3FF0000000000000;
            __cxa_guard_release(&qword_101FCB058);
          }

          v108 = qword_101FCB050;
          *(a1 + 88) = 1;
          *(a1 + 40) = v103;
          *(a1 + 48) = v104;
          *(a1 + 56) = v105;
          *(a1 + 64) = 0;
          *(a1 + 72) = v108;
          *(a1 + 80) = 0;
LABEL_129:
          memset(v524 + 2, 0, 40);
          *(a1 + 152) = 48;
          v122 = v524[1];
          *(a1 + 154) = v524[0];
          *(a1 + 170) = v122;
          v123 = *(&v524[1] + 10);
LABEL_638:
          *(a1 + 180) = v123;
          return;
        }

        v162 = 0;
        *&v524[0] = 0;
        do
        {
          v163 = v524 + v162;
          *(v163 + 40) = xmmword_1019ADEB0;
          *(v163 + 7) = 0;
          *(v163 + 8) = 0;
          *(v163 + 72) = xmmword_1019ADEC0;
          v162 += 56;
          v163[88] = 0;
        }

        while (v162 != 112);
        goto LABEL_636;
      }

      v483 = v96;
      v124 = -v36;
      v125 = -v32;
      v126 = -v34;
      v127 = v36 * v48 + v34 * v49 + v32 * v50;
      v128 = 1.0 - v127;
      v129 = -(1.0 - v127);
      if ((v50 * -v34 + v32 * v49) * v70 + v68 * (v48 * -v32 + v36 * v50) + v66 * (v49 * -v36 + v34 * v48) >= 0.0)
      {
        v130 = 1.0 - v127;
      }

      else
      {
        v130 = -(1.0 - v127);
      }

      if (v130 <= -2.0)
      {
        v131 = v130 + 4.0;
      }

      else
      {
        v131 = v130;
      }

      v132 = fabs(v131);
      if (v132 > 0.00000001)
      {
        goto LABEL_137;
      }

      v134 = 0.0;
      if (v131 != 0.0)
      {
        v155 = 1.0;
        if (v132 >= 1.0)
        {
          v155 = v132;
        }

        if (v132 > v155 * 2.22044605e-16)
        {
          v422 = v131;
          v437 = v129;
          v441 = v128;
          v427 = v58;
          v431 = v66;
          v477 = v48;
          v459 = v57;
          v465 = v56;
          v471 = v55;
          v447 = v50;
          v453 = v49;
          v156 = a2[1];
          *v524 = *a2;
          v416 = v156;
          *v525 = v156;
          sub_101690AC8(v524, v525, 1);
          v157 = *v524;
          v158 = a4[1];
          *v524 = *a4;
          v418 = v157;
          v420 = v158;
          *v525 = v158;
          sub_101690AC8(v524, v525, 1);
          v63 = v484;
          v58 = v427;
          v66 = v431;
          v64 = v500;
          v50 = v447;
          v49 = v453;
          v55 = v471;
          v48 = v477;
          v57 = v459;
          v56 = v465;
          v134 = 0.0;
          v129 = v437;
          v128 = v441;
          v125 = -v32;
          v126 = -v34;
          v131 = v422;
          v124 = -v36;
          if (v418 != *v524)
          {
            if ((*&v418 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v524[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_137;
            }

            v261 = fabs(v418);
            v262 = fabs(*v524);
            v263 = vabdd_f64(v418, *v524);
            if (v261 < v262)
            {
              v261 = v262;
            }

            if (v261 < 1.0)
            {
              v261 = 1.0;
            }

            if (v263 > v261 * 2.22044605e-16)
            {
              goto LABEL_137;
            }
          }

          if (v420 != v416)
          {
            if ((*&v416 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v420 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_137;
            }

            v159 = fabs(v416);
            v160 = fabs(v420);
            v161 = vabdd_f64(v416, v420);
            if (v159 < v160)
            {
              v159 = v160;
            }

            if (v159 < 1.0)
            {
              v159 = 1.0;
            }

            if (v161 > v159 * 2.22044605e-16)
            {
LABEL_137:
              v133 = vabdd_f64(v58, v131);
              if (v133 > 0.00000001)
              {
                goto LABEL_138;
              }

              v134 = v58;
              if (v58 - v131 != 0.0)
              {
                v164 = 1.0;
                if (v133 >= 1.0)
                {
                  v164 = v133;
                }

                v134 = v58;
                if (v133 > v164 * 2.22044605e-16)
                {
                  v423 = v131;
                  v424 = v124;
                  v425 = v125;
                  v426 = v126;
                  v438 = v129;
                  v442 = v128;
                  v428 = v58;
                  v432 = v66;
                  v478 = v48;
                  v460 = v57;
                  v466 = v56;
                  v472 = v55;
                  v448 = v50;
                  v454 = v49;
                  v165 = a3[1];
                  *v524 = *a3;
                  v419 = v165;
                  *v525 = v165;
                  sub_101690AC8(v524, v525, 1);
                  v421 = *v524;
                  v166 = a4[1];
                  *v524 = *a4;
                  v417 = v166;
                  *v525 = v166;
                  sub_101690AC8(v524, v525, 1);
                  v131 = v423;
                  v63 = v484;
                  v58 = v428;
                  v66 = v432;
                  v64 = v500;
                  v50 = v448;
                  v49 = v454;
                  v55 = v472;
                  v48 = v478;
                  v57 = v460;
                  v56 = v466;
                  v129 = v438;
                  v128 = v442;
                  v125 = v425;
                  v126 = v426;
                  v124 = v424;
                  if (v421 != *v524)
                  {
                    if ((*&v421 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v524[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                    {
                      goto LABEL_138;
                    }

                    v273 = fabs(v421);
                    v274 = fabs(*v524);
                    v275 = vabdd_f64(v421, *v524);
                    if (v273 < v274)
                    {
                      v273 = v274;
                    }

                    if (v273 < 1.0)
                    {
                      v273 = 1.0;
                    }

                    if (v275 > v273 * 2.22044605e-16)
                    {
                      goto LABEL_138;
                    }
                  }

                  v134 = v428;
                  if (v417 != v419)
                  {
                    if ((*&v419 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v417 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                    {
                      goto LABEL_138;
                    }

                    v382 = fabs(v419);
                    v383 = fabs(v417);
                    v384 = vabdd_f64(v419, v417);
                    if (v382 < v383)
                    {
                      v382 = v383;
                    }

                    if (v382 < 1.0)
                    {
                      v382 = 1.0;
                    }

                    v134 = v428;
                    if (v384 > v382 * 2.22044605e-16)
                    {
LABEL_138:
                      v134 = v131;
                    }
                  }
                }
              }
            }
          }
        }
      }

      if ((v51 * v126 + v32 * v53) * v70 + v68 * (v54 * v125 + v36 * v51) + v66 * (v53 * v124 + v34 * v54) >= 0.0)
      {
        v167 = 1.0 - (v54 * v36 + v34 * v53 + v32 * v51);
      }

      else
      {
        v167 = -(1.0 - (v54 * v36 + v34 * v53 + v32 * v51));
      }

      if (v167 <= -2.0)
      {
        v168 = v167 + 4.0;
      }

      else
      {
        v168 = v167;
      }

      v169 = fabs(v168);
      if (v169 > 0.00000001)
      {
        goto LABEL_217;
      }

      v171 = 0.0;
      if (v168 != 0.0)
      {
        v172 = 1.0;
        if (v169 >= 1.0)
        {
          v172 = v169;
        }

        if (v169 > v172 * 2.22044605e-16)
        {
          v439 = v129;
          v443 = v128;
          v479 = v48;
          v461 = v57;
          v467 = v56;
          v473 = v55;
          v449 = v50;
          v455 = v49;
          v173 = v58;
          v174 = a2[1];
          *v524 = *a2;
          v429 = v174;
          v433 = v134;
          *v525 = v174;
          sub_101690AC8(v524, v525, 1);
          v175 = *v524;
          v176 = a5[1];
          *v524 = *a5;
          *v525 = v176;
          sub_101690AC8(v524, v525, 1);
          v63 = v484;
          v58 = v173;
          v64 = v500;
          v50 = v449;
          v49 = v455;
          v55 = v473;
          v48 = v479;
          v57 = v461;
          v56 = v467;
          v134 = v433;
          v129 = v439;
          v128 = v443;
          if (v175 != *v524)
          {
            if ((*&v175 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v524[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_217;
            }

            v264 = fabs(v175);
            v265 = fabs(*v524);
            v266 = vabdd_f64(v175, *v524);
            if (v264 < v265)
            {
              v264 = v265;
            }

            if (v264 < 1.0)
            {
              v264 = 1.0;
            }

            if (v266 > v264 * 2.22044605e-16)
            {
              goto LABEL_217;
            }
          }

          if (v176 != v429)
          {
            if ((*&v429 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v176 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_217;
            }

            v177 = fabs(v429);
            v178 = fabs(v176);
            v179 = vabdd_f64(v429, v176);
            if (v177 < v178)
            {
              v177 = v178;
            }

            if (v177 < 1.0)
            {
              v177 = 1.0;
            }

            if (v179 > v177 * 2.22044605e-16)
            {
LABEL_217:
              v170 = vabdd_f64(v58, v168);
              if (v170 > 0.00000001)
              {
                goto LABEL_218;
              }

              v171 = v58;
              if (v58 - v168 != 0.0)
              {
                v180 = 1.0;
                if (v170 >= 1.0)
                {
                  v180 = v170;
                }

                v171 = v58;
                if (v170 > v180 * 2.22044605e-16)
                {
                  v440 = v129;
                  v444 = v128;
                  v480 = v48;
                  v434 = v134;
                  v462 = v57;
                  v468 = v56;
                  v474 = v55;
                  v181 = v49;
                  v182 = v50;
                  v183 = v58;
                  v184 = a3[1];
                  *v524 = *a3;
                  v456 = v184;
                  *v525 = v184;
                  sub_101690AC8(v524, v525, 1);
                  v185 = *v524;
                  v186 = a5[1];
                  *v524 = *a5;
                  v450 = v186;
                  *v525 = v186;
                  sub_101690AC8(v524, v525, 1);
                  v63 = v484;
                  v58 = v183;
                  v64 = v500;
                  v50 = v182;
                  v49 = v181;
                  v55 = v474;
                  v48 = v480;
                  v57 = v462;
                  v56 = v468;
                  v134 = v434;
                  v129 = v440;
                  v128 = v444;
                  if (v185 != *v524)
                  {
                    if ((*&v185 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v524[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                    {
                      goto LABEL_218;
                    }

                    v276 = fabs(v185);
                    v277 = fabs(*v524);
                    v278 = vabdd_f64(v185, *v524);
                    if (v276 < v277)
                    {
                      v276 = v277;
                    }

                    if (v276 < 1.0)
                    {
                      v276 = 1.0;
                    }

                    if (v278 > v276 * 2.22044605e-16)
                    {
                      goto LABEL_218;
                    }
                  }

                  v171 = v183;
                  if (v450 != v456)
                  {
                    if ((*&v456 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v450 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                    {
                      goto LABEL_218;
                    }

                    v385 = fabs(v456);
                    v386 = fabs(v450);
                    v387 = vabdd_f64(v456, v450);
                    if (v385 < v386)
                    {
                      v385 = v386;
                    }

                    if (v385 < 1.0)
                    {
                      v385 = 1.0;
                    }

                    v171 = v183;
                    if (v387 > v385 * 2.22044605e-16)
                    {
LABEL_218:
                      v171 = v168;
                    }
                  }
                }
              }
            }
          }
        }
      }

      v187 = -v48;
      v188 = -v50;
      v189 = -v49;
      if ((v32 * -v49 + v50 * v34) * v57 + v56 * (v36 * -v50 + v48 * v32) + v55 * (v34 * -v48 + v49 * v36) >= 0.0)
      {
        v190 = v128;
      }

      else
      {
        v190 = v129;
      }

      if (v190 <= -2.0)
      {
        v191 = v190 + 4.0;
      }

      else
      {
        v191 = v190;
      }

      v192 = fabs(v191);
      if (v192 > 0.00000001)
      {
        goto LABEL_246;
      }

      v194 = 0.0;
      if (v191 != 0.0)
      {
        v195 = 1.0;
        if (v192 >= 1.0)
        {
          v195 = v192;
        }

        if (v192 > v195 * 2.22044605e-16)
        {
          v481 = v48;
          v430 = v58;
          v435 = v134;
          v463 = v57;
          v469 = v56;
          v475 = v55;
          v451 = v50;
          v457 = v49;
          v196 = a4[1];
          *v524 = *a4;
          v445 = v196;
          *v525 = v196;
          sub_101690AC8(v524, v525, 1);
          v197 = *v524;
          v198 = a2[1];
          *v524 = *a2;
          v199 = v198;
          *v525 = v198;
          sub_101690AC8(v524, v525, 1);
          v63 = v484;
          v58 = v430;
          v134 = v435;
          v64 = v500;
          v50 = v451;
          v49 = v457;
          v55 = v475;
          v48 = v481;
          v57 = v463;
          v56 = v469;
          if (v197 != *v524)
          {
            if ((*&v197 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v524[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_246;
            }

            v267 = fabs(v197);
            v268 = fabs(*v524);
            v269 = vabdd_f64(v197, *v524);
            if (v267 < v268)
            {
              v267 = v268;
            }

            if (v267 < 1.0)
            {
              v267 = 1.0;
            }

            if (v269 > v267 * 2.22044605e-16)
            {
              goto LABEL_246;
            }
          }

          if (v199 != v445)
          {
            if ((*&v445 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v199 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_246;
            }

            v200 = fabs(v445);
            v201 = fabs(v199);
            v202 = vabdd_f64(v445, v199);
            if (v200 < v201)
            {
              v200 = v201;
            }

            if (v200 < 1.0)
            {
              v200 = 1.0;
            }

            if (v202 > v200 * 2.22044605e-16)
            {
LABEL_246:
              v193 = vabdd_f64(v63, v191);
              if (v193 > 0.00000001)
              {
                goto LABEL_247;
              }

              v194 = v63;
              if (v63 - v191 != 0.0)
              {
                v203 = 1.0;
                if (v193 >= 1.0)
                {
                  v203 = v193;
                }

                v194 = v63;
                if (v193 > v203 * 2.22044605e-16)
                {
                  v482 = v48;
                  v436 = v134;
                  v464 = v57;
                  v470 = v56;
                  v476 = v55;
                  v204 = v50;
                  v205 = v58;
                  v206 = a5[1];
                  *v524 = *a5;
                  v452 = v206;
                  v458 = v49;
                  *v525 = v206;
                  sub_101690AC8(v524, v525, 1);
                  v207 = *v524;
                  v208 = a2[1];
                  *v524 = *a2;
                  v446 = v208;
                  *v525 = v208;
                  sub_101690AC8(v524, v525, 1);
                  v63 = v484;
                  v58 = v205;
                  v64 = v500;
                  v50 = v204;
                  v49 = v458;
                  v57 = v464;
                  v55 = v476;
                  v48 = v482;
                  v56 = v470;
                  v134 = v436;
                  if (v207 != *v524)
                  {
                    if ((*&v207 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v524[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                    {
                      goto LABEL_247;
                    }

                    v279 = fabs(v207);
                    v280 = fabs(*v524);
                    v281 = vabdd_f64(v207, *v524);
                    if (v279 < v280)
                    {
                      v279 = v280;
                    }

                    if (v279 < 1.0)
                    {
                      v279 = 1.0;
                    }

                    if (v281 > v279 * 2.22044605e-16)
                    {
                      goto LABEL_247;
                    }
                  }

                  v194 = v484;
                  if (v446 != v452)
                  {
                    if ((*&v452 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v446 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                    {
                      goto LABEL_247;
                    }

                    v388 = fabs(v452);
                    v389 = fabs(v446);
                    v390 = vabdd_f64(v452, v446);
                    if (v388 < v389)
                    {
                      v388 = v389;
                    }

                    if (v388 < 1.0)
                    {
                      v388 = 1.0;
                    }

                    v194 = v484;
                    if (v390 > v388 * 2.22044605e-16)
                    {
LABEL_247:
                      v194 = v191;
                    }
                  }
                }
              }
            }
          }
        }
      }

      if (v57 * (v493 * v189 + v50 * v64) + v56 * (v487 * v188 + v48 * v493) + v55 * (v64 * v187 + v49 * v487) >= 0.0)
      {
        v209 = 1.0 - (v48 * v487 + v49 * v64 + v50 * v493);
      }

      else
      {
        v209 = -(1.0 - (v48 * v487 + v49 * v64 + v50 * v493));
      }

      if (v209 <= -2.0)
      {
        v210 = v209 + 4.0;
      }

      else
      {
        v210 = v209;
      }

      v211 = fabs(v210);
      if (v211 <= 0.00000001)
      {
        v213 = 0.0;
        if (v210 == 0.0)
        {
          goto LABEL_438;
        }

        v214 = 1.0;
        if (v211 >= 1.0)
        {
          v214 = v211;
        }

        if (v211 <= v214 * 2.22044605e-16)
        {
          goto LABEL_438;
        }

        v215 = v134;
        v216 = v58;
        v217 = a4[1];
        *v524 = *a4;
        v501 = v217;
        *v525 = v217;
        sub_101690AC8(v524, v525, 1);
        v218 = *v524;
        v219 = a3[1];
        *v524 = *a3;
        *v525 = v219;
        sub_101690AC8(v524, v525, 1);
        v63 = v484;
        v58 = v216;
        v134 = v215;
        if (v218 == *v524)
        {
          goto LABEL_289;
        }

        if ((*&v218 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v524[0] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v270 = fabs(v218);
          v271 = fabs(*v524);
          v272 = vabdd_f64(v218, *v524);
          if (v270 < v271)
          {
            v270 = v271;
          }

          if (v270 < 1.0)
          {
            v270 = 1.0;
          }

          if (v272 <= v270 * 2.22044605e-16)
          {
LABEL_289:
            if (v219 == v501)
            {
              goto LABEL_438;
            }

            if ((*&v501 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v219 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
            {
              v220 = fabs(v501);
              v221 = fabs(v219);
              v222 = vabdd_f64(v501, v219);
              if (v220 < v221)
              {
                v220 = v221;
              }

              if (v220 < 1.0)
              {
                v220 = 1.0;
              }

              if (v222 <= v220 * 2.22044605e-16)
              {
                goto LABEL_438;
              }
            }
          }
        }
      }

      v212 = vabdd_f64(v63, v210);
      if (v212 > 0.00000001)
      {
        goto LABEL_276;
      }

      v223 = v63;
      if (v63 - v210 != 0.0)
      {
        v224 = 1.0;
        if (v212 >= 1.0)
        {
          v224 = v212;
        }

        v225 = v212 > v224 * 2.22044605e-16;
        v223 = v63;
        if (v225)
        {
          v226 = v134;
          v227 = v58;
          v228 = a5[1];
          *v524 = *a5;
          *v525 = v228;
          sub_101690AC8(v524, v525, 1);
          v229 = *v524;
          v230 = a3[1];
          *v524 = *a3;
          *v525 = v230;
          sub_101690AC8(v524, v525, 1);
          v63 = v484;
          if (v229 != *v524)
          {
            if ((*&v229 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v524[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_437;
            }

            v282 = fabs(v229);
            v283 = fabs(*v524);
            v284 = vabdd_f64(v229, *v524);
            if (v282 < v283)
            {
              v282 = v283;
            }

            if (v282 < 1.0)
            {
              v282 = 1.0;
            }

            if (v284 > v282 * 2.22044605e-16)
            {
LABEL_437:
              v213 = v210;
              v58 = v227;
              v134 = v226;
              goto LABEL_438;
            }
          }

          v223 = v484;
          v58 = v227;
          v134 = v226;
          if (v230 != v228)
          {
            if ((*&v228 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v230 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
LABEL_276:
              v213 = v210;
LABEL_438:
              v223 = v213;
              goto LABEL_439;
            }

            v231 = fabs(v228);
            v232 = fabs(v230);
            v233 = vabdd_f64(v228, v230);
            if (v231 < v232)
            {
              v231 = v232;
            }

            if (v231 < 1.0)
            {
              v231 = 1.0;
            }

            v225 = v233 > v231 * 2.22044605e-16;
            v213 = v210;
            v223 = v484;
            if (v225)
            {
              goto LABEL_438;
            }
          }
        }
      }

LABEL_439:
      if (v63 >= 0.0)
      {
        v285 = v63;
      }

      else
      {
        v285 = -v63;
      }

      if (v63 >= 0.0)
      {
        v286 = v194;
      }

      else
      {
        v286 = -v194;
      }

      if (v63 == 0.0)
      {
        if (v63 >= 0.0)
        {
          v287 = v223;
        }

        else
        {
          v287 = -v223;
        }

        v288 = 0.0;
        v289 = 0.0;
      }

      else
      {
        v288 = v286 * 1000000.0 / v285;
        if (v63 >= 0.0)
        {
          v287 = v223;
        }

        else
        {
          v287 = -v223;
        }

        v289 = v287 * 1000000.0 / v285;
      }

      if (v58 >= 0.0)
      {
        v290 = v58;
      }

      else
      {
        v290 = -v58;
      }

      if (v58 >= 0.0)
      {
        v291 = v134;
      }

      else
      {
        v291 = -v134;
      }

      if (v58 == 0.0)
      {
        if (v58 >= 0.0)
        {
          v292 = v171;
        }

        else
        {
          v292 = -v171;
        }

        v293 = 0.0;
        v294 = 0.0;
      }

      else
      {
        v293 = v291 * 1000000.0 / v290;
        if (v58 >= 0.0)
        {
          v292 = v171;
        }

        else
        {
          v292 = -v171;
        }

        v294 = v292 * 1000000.0 / v290;
      }

      if (v134 == 0.0)
      {
        goto LABEL_470;
      }

      if ((*&v134 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v296 = fabs(v134);
        v297 = vabdd_f64(0.0, v134);
        if (v296 < 1.0)
        {
          v296 = 1.0;
        }

        if (v297 <= v296 * 2.22044605e-16)
        {
LABEL_470:
          v295 = 1;
          goto LABEL_477;
        }
      }

      if (v171 == 0.0)
      {
        goto LABEL_476;
      }

      if ((*&v171 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v302 = fabs(v171);
        v303 = vabdd_f64(0.0, v171);
        if (v302 < 1.0)
        {
          v302 = 1.0;
        }

        if (v303 <= v302 * 2.22044605e-16)
        {
LABEL_476:
          v295 = 3;
          goto LABEL_477;
        }
      }

      if (v134 >= v171)
      {
        if (v134 >= 0.0)
        {
          if (v171 <= 0.0)
          {
            v295 = 2;
          }

          else
          {
            v295 = 4;
          }

LABEL_477:
          if (v58 == v134)
          {
LABEL_478:
            v298 = 1;
            goto LABEL_517;
          }

          if ((*&v58 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            v299 = fabs(v58);
            if ((*&v134 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
            {
              v300 = fabs(v134);
              v301 = vabdd_f64(v58, v134);
              if (v299 >= v300)
              {
                v300 = v299;
              }

              if (v300 < 1.0)
              {
                v300 = 1.0;
              }

              if (v301 <= v300 * 2.22044605e-16)
              {
                goto LABEL_478;
              }
            }

            if (v58 != v171)
            {
              if ((*&v171 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                goto LABEL_505;
              }

              v304 = fabs(v171);
              v305 = vabdd_f64(v58, v171);
              if (v299 < v304)
              {
                v299 = v304;
              }

              if (v299 < 1.0)
              {
                v299 = 1.0;
              }

              if (v305 > v299 * 2.22044605e-16)
              {
LABEL_505:
                if (v134 >= v171)
                {
                  if (v58 <= v134)
                  {
                    if (v58 >= v171)
                    {
                      v298 = 2;
                    }

                    else
                    {
                      v298 = 4;
                    }

                    goto LABEL_517;
                  }
                }

                else if (v58 >= v134)
                {
                  if (v58 <= v171)
                  {
                    v298 = 2;
                  }

                  else
                  {
                    v298 = 4;
                  }

                  goto LABEL_517;
                }

                v298 = 0;
LABEL_517:
                if (v194 == 0.0)
                {
                  goto LABEL_518;
                }

                if ((*&v194 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                {
                  v307 = fabs(v194);
                  v308 = vabdd_f64(0.0, v194);
                  if (v307 < 1.0)
                  {
                    v307 = 1.0;
                  }

                  if (v308 <= v307 * 2.22044605e-16)
                  {
LABEL_518:
                    v306 = 1;
                    goto LABEL_525;
                  }
                }

                if (v223 == 0.0)
                {
                  goto LABEL_524;
                }

                if ((*&v223 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                {
                  v313 = fabs(v223);
                  v314 = vabdd_f64(0.0, v223);
                  if (v313 < 1.0)
                  {
                    v313 = 1.0;
                  }

                  if (v314 <= v313 * 2.22044605e-16)
                  {
LABEL_524:
                    v306 = 3;
                    goto LABEL_525;
                  }
                }

                if (v194 >= v223)
                {
                  if (v194 >= 0.0)
                  {
                    if (v223 <= 0.0)
                    {
                      v306 = 2;
                    }

                    else
                    {
                      v306 = 4;
                    }

LABEL_525:
                    if (v63 == v194)
                    {
LABEL_526:
                      v309 = 1;
                      goto LABEL_565;
                    }

                    if ((*&v63 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                    {
                      v310 = fabs(v63);
                      if ((*&v194 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                      {
                        v311 = fabs(v194);
                        v312 = vabdd_f64(v63, v194);
                        if (v310 >= v311)
                        {
                          v311 = v310;
                        }

                        if (v311 < 1.0)
                        {
                          v311 = 1.0;
                        }

                        if (v312 <= v311 * 2.22044605e-16)
                        {
                          goto LABEL_526;
                        }
                      }

                      if (v63 != v223)
                      {
                        if ((*&v223 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                        {
                          goto LABEL_553;
                        }

                        v315 = fabs(v223);
                        v316 = vabdd_f64(v63, v223);
                        if (v310 < v315)
                        {
                          v310 = v315;
                        }

                        if (v310 < 1.0)
                        {
                          v310 = 1.0;
                        }

                        if (v316 > v310 * 2.22044605e-16)
                        {
LABEL_553:
                          if (v194 >= v223)
                          {
                            if (v63 <= v194)
                            {
                              if (v63 >= v223)
                              {
                                v309 = 2;
                              }

                              else
                              {
                                v309 = 4;
                              }

LABEL_565:
                              if (v295 == 3)
                              {
                                v288 = 0.0;
                                if (v63 != 0.0)
                                {
                                  v288 = v285 * 1000000.0 / v285;
                                }

                                if (v58 >= 0.0)
                                {
                                  v292 = 0.0;
                                }

                                else
                                {
                                  v292 = -0.0;
                                }

                                if (v58 == 0.0)
                                {
                                  v294 = 0.0;
                                }

                                else
                                {
                                  v294 = v292 / v290;
                                }

                                v286 = v285;
                              }

                              else if (v295 == 1)
                              {
                                if (v63 >= 0.0)
                                {
                                  v286 = 0.0;
                                }

                                else
                                {
                                  v286 = -0.0;
                                }

                                if (v63 == 0.0)
                                {
                                  v288 = 0.0;
                                }

                                else
                                {
                                  v288 = v286 / v285;
                                }

                                if (v58 >= 0.0)
                                {
                                  v291 = 0.0;
                                }

                                else
                                {
                                  v291 = -0.0;
                                }

                                if (v58 == 0.0)
                                {
                                  v293 = 0.0;
                                }

                                else
                                {
                                  v293 = v291 / v290;
                                }
                              }

                              if (v298 == 3)
                              {
                                v294 = 0.0;
                                v289 = 0.0;
                                if (v63 != 0.0)
                                {
                                  v289 = v285 * 1000000.0 / v285;
                                }

                                v317 = v483;
                                if (v58 != 0.0)
                                {
                                  v294 = v290 * 1000000.0 / v290;
                                }

                                v287 = v285;
                                v292 = v290;
                              }

                              else if (v298 == 1)
                              {
                                v293 = 0.0;
                                if (v63 >= 0.0)
                                {
                                  v287 = 0.0;
                                }

                                else
                                {
                                  v287 = -0.0;
                                }

                                if (v63 == 0.0)
                                {
                                  v289 = 0.0;
                                }

                                else
                                {
                                  v289 = v287 / v285;
                                }

                                if (v58 != 0.0)
                                {
                                  v293 = v290 * 1000000.0 / v290;
                                }

                                v291 = v290;
                                v317 = v483;
                              }

                              else
                              {
                                v317 = v483;
                                if (!(v295 | v298) || v295 >= 4 && v298 >= 4)
                                {
                                  v337 = 0;
                                  *&v524[0] = 0;
                                  do
                                  {
                                    v338 = v524 + v337;
                                    *(v338 + 40) = xmmword_1019ADEB0;
                                    *(v338 + 7) = 0;
                                    *(v338 + 8) = 0;
                                    *(v338 + 72) = xmmword_1019ADEC0;
                                    v337 += 56;
                                    v338[88] = 0;
                                  }

                                  while (v337 != 112);
                                  goto LABEL_636;
                                }
                              }

                              v318 = 0;
                              memset(v524, 0, 152);
                              do
                              {
                                v319 = v524 + v318;
                                *(v319 + 40) = xmmword_1019ADEB0;
                                *(v319 + 7) = 0;
                                *(v319 + 8) = 0;
                                *(v319 + 72) = xmmword_1019ADEC0;
                                v318 += 56;
                                v319[88] = 0;
                              }

                              while (v318 != 112);
                              *v525 = 0;
                              *&v525[8] = 0x3FF0000000000000;
                              *&v525[16] = 0;
                              *&v525[24] = 0;
                              *&v525[32] = xmmword_1019ADEC0;
                              if (v295 - 1 > 2)
                              {
                                v320 = 0;
                              }

                              else
                              {
                                *(v524 + 8) = *a2;
                                if ((atomic_load_explicit(&qword_101FCB058, memory_order_acquire) & 1) == 0)
                                {
                                  v494 = v295;
                                  v391 = v298;
                                  v502 = v306;
                                  v392 = v309;
                                  v393 = v294;
                                  v394 = v289;
                                  v485 = v288;
                                  v488 = v287;
                                  v395 = __cxa_guard_acquire(&qword_101FCB058);
                                  v288 = v485;
                                  v287 = v488;
                                  v289 = v394;
                                  v294 = v393;
                                  v317 = v483;
                                  v309 = v392;
                                  v306 = v502;
                                  v298 = v391;
                                  v295 = v494;
                                  if (v395)
                                  {
                                    qword_101FCB050 = 0x3FF0000000000000;
                                    __cxa_guard_release(&qword_101FCB058);
                                    v288 = v485;
                                    v287 = v488;
                                    v289 = v394;
                                    v294 = v393;
                                    v317 = v483;
                                    v309 = v392;
                                    v306 = v502;
                                    v298 = v391;
                                    v295 = v494;
                                  }
                                }

                                BYTE8(v524[5]) = 1;
                                *(&v524[2] + 1) = 0;
                                v524[3] = qword_101FCB050;
                                *&v524[4] = v286;
                                *(&v524[4] + 1) = v285;
                                *&v524[5] = v288;
                                if ((atomic_load_explicit(&qword_101FCB058, memory_order_acquire) & 1) == 0)
                                {
                                  v495 = v295;
                                  v396 = v298;
                                  v503 = v306;
                                  v489 = v309;
                                  v397 = v294;
                                  v398 = v289;
                                  v399 = v287;
                                  v400 = __cxa_guard_acquire(&qword_101FCB058);
                                  v287 = v399;
                                  v289 = v398;
                                  v294 = v397;
                                  v317 = v483;
                                  v309 = v489;
                                  v306 = v503;
                                  v298 = v396;
                                  v295 = v495;
                                  if (v400)
                                  {
                                    qword_101FCB050 = 0x3FF0000000000000;
                                    __cxa_guard_release(&qword_101FCB058);
                                    v287 = v399;
                                    v289 = v398;
                                    v294 = v397;
                                    v317 = v483;
                                    v309 = v489;
                                    v306 = v503;
                                    v298 = v396;
                                    v295 = v495;
                                  }
                                }

                                *v525 = 0;
                                *&v525[8] = qword_101FCB050;
                                *&v525[16] = 0;
                                v320 = 1;
                              }

                              if (v306 == 2)
                              {
                                *(&v524[v320] + 8) = *a4;
                                v321 = v524 + 7 * v320;
                                if ((atomic_load_explicit(&qword_101FCB058, memory_order_acquire) & 1) == 0)
                                {
                                  v496 = v295;
                                  v486 = v298;
                                  v490 = v309;
                                  v401 = v294;
                                  v402 = v289;
                                  v403 = v287;
                                  v404 = __cxa_guard_acquire(&qword_101FCB058);
                                  v287 = v403;
                                  v289 = v402;
                                  v294 = v401;
                                  v317 = v483;
                                  v309 = v490;
                                  v306 = 2;
                                  v298 = v486;
                                  v295 = v496;
                                  if (v404)
                                  {
                                    qword_101FCB050 = 0x3FF0000000000000;
                                    __cxa_guard_release(&qword_101FCB058);
                                    v287 = v403;
                                    v289 = v402;
                                    v294 = v401;
                                    v317 = v483;
                                    v309 = v490;
                                    v306 = 2;
                                    v298 = v486;
                                    v295 = v496;
                                  }
                                }

                                v322 = qword_101FCB050;
                                *(v321 + 88) = 1;
                                v321[5] = v291;
                                v321[6] = v290;
                                v321[7] = v293;
                                v321[8] = 0.0;
                                *(v321 + 9) = v322;
                                v321[10] = 0.0;
                                v323 = &v525[24 * v320];
                                *v323 = v291;
                                v323[1] = v290;
                                v323[2] = v293;
                                ++v320;
                              }

                              v324 = v298 - 1;
                              if (v298 - 1 <= 2 && v320 <= 1)
                              {
                                *(&v524[v320] + 8) = *a3;
                                v325 = v524 + 56 * v320;
                                if ((atomic_load_explicit(&qword_101FCB078, memory_order_acquire) & 1) == 0)
                                {
                                  v497 = v295;
                                  v405 = v298;
                                  v504 = v306;
                                  v491 = v309;
                                  v406 = v294;
                                  v407 = v289;
                                  v408 = v287;
                                  v409 = __cxa_guard_acquire(&qword_101FCB078);
                                  v287 = v408;
                                  v289 = v407;
                                  v294 = v406;
                                  v317 = v483;
                                  v309 = v491;
                                  v306 = v504;
                                  v298 = v405;
                                  v295 = v497;
                                  if (v409)
                                  {
                                    *&xmmword_101FCB060 = 0x3FF0000000000000;
                                    *(&xmmword_101FCB060 + 1) = 0x3FF0000000000000;
                                    qword_101FCB070 = 0x412E848000000000;
                                    __cxa_guard_release(&qword_101FCB078);
                                    v287 = v408;
                                    v289 = v407;
                                    v294 = v406;
                                    v317 = v483;
                                    v309 = v491;
                                    v306 = v504;
                                    v298 = v405;
                                    v295 = v497;
                                  }
                                }

                                v326 = xmmword_101FCB060;
                                v327 = qword_101FCB070;
                                v325[88] = 1;
                                *(v325 + 40) = v326;
                                *(v325 + 7) = v327;
                                *(v325 + 8) = v287;
                                *(v325 + 9) = v285;
                                *(v325 + 10) = v289;
                                if ((atomic_load_explicit(&qword_101FCB078, memory_order_acquire) & 1) == 0)
                                {
                                  v498 = v295;
                                  v410 = v298;
                                  v505 = v306;
                                  v492 = v309;
                                  v411 = v294;
                                  v412 = __cxa_guard_acquire(&qword_101FCB078);
                                  v294 = v411;
                                  v317 = v483;
                                  v309 = v492;
                                  v306 = v505;
                                  v298 = v410;
                                  v295 = v498;
                                  if (v412)
                                  {
                                    *&xmmword_101FCB060 = 0x3FF0000000000000;
                                    *(&xmmword_101FCB060 + 1) = 0x3FF0000000000000;
                                    qword_101FCB070 = 0x412E848000000000;
                                    __cxa_guard_release(&qword_101FCB078);
                                    v294 = v411;
                                    v317 = v483;
                                    v309 = v492;
                                    v306 = v505;
                                    v298 = v410;
                                    v295 = v498;
                                  }
                                }

                                v328 = qword_101FCB070;
                                v329 = &v525[24 * v320];
                                *v329 = xmmword_101FCB060;
                                *(v329 + 2) = v328;
                                ++v320;
                              }

                              if (v309 == 2 && v320 <= 1)
                              {
                                *(&v524[v320] + 8) = *a5;
                                v330 = v524 + 7 * v320;
                                if ((atomic_load_explicit(&qword_101FCB078, memory_order_acquire) & 1) == 0)
                                {
                                  v499 = v295;
                                  v413 = v298;
                                  v506 = v306;
                                  v414 = v294;
                                  v415 = __cxa_guard_acquire(&qword_101FCB078);
                                  v294 = v414;
                                  v317 = v483;
                                  v309 = 2;
                                  v306 = v506;
                                  v298 = v413;
                                  v295 = v499;
                                  if (v415)
                                  {
                                    *&xmmword_101FCB060 = 0x3FF0000000000000;
                                    *(&xmmword_101FCB060 + 1) = 0x3FF0000000000000;
                                    qword_101FCB070 = 0x412E848000000000;
                                    __cxa_guard_release(&qword_101FCB078);
                                    v294 = v414;
                                    v317 = v483;
                                    v309 = 2;
                                    v306 = v506;
                                    v298 = v413;
                                    v295 = v499;
                                  }
                                }

                                v331 = xmmword_101FCB060;
                                v332 = qword_101FCB070;
                                *(v330 + 88) = 1;
                                v330[5] = v292;
                                v330[6] = v290;
                                v330[7] = v294;
                                *(v330 + 4) = v331;
                                *(v330 + 10) = v332;
                                v333 = &v525[24 * v320];
                                *v333 = v292;
                                v333[1] = v290;
                                v333[2] = v294;
                                ++v320;
                              }

                              if (v320 == 2)
                              {
                                if (vabdd_f64(*&v525[40], *&v525[16]) >= 50.0)
                                {
                                  if (*&v525[40] >= *&v525[16])
                                  {
                                    goto LABEL_655;
                                  }
                                }

                                else
                                {
                                  if (*&v525[32] == 0.0)
                                  {
                                    __assert_rtn("apply", "segment_ratio.hpp", 56, "lhs.denominator() != Type(0)");
                                  }

                                  if (*&v525[8] == 0.0)
                                  {
                                    __assert_rtn("apply", "segment_ratio.hpp", 57, "rhs.denominator() != Type(0)");
                                  }

                                  v334 = *&v525[24] / *&v525[32];
                                  v335 = *v525 / *&v525[8];
                                  if (*&v525[24] / *&v525[32] == *v525 / *&v525[8])
                                  {
                                    goto LABEL_655;
                                  }

                                  if (COERCE_UNSIGNED_INT64(fabs(*&v525[24] / *&v525[32])) <= 0x7FEFFFFFFFFFFFFFLL && COERCE_UNSIGNED_INT64(fabs(*v525 / *&v525[8])) <= 0x7FEFFFFFFFFFFFFFLL)
                                  {
                                    v343 = fabs(v334);
                                    v344 = fabs(v335);
                                    v345 = vabdd_f64(v334, v335);
                                    if (v343 < v344)
                                    {
                                      v343 = v344;
                                    }

                                    if (v343 < 1.0)
                                    {
                                      v343 = 1.0;
                                    }

                                    v336 = v345 > v343 * 2.22044605e-16;
                                  }

                                  else
                                  {
                                    v336 = 1;
                                  }

                                  if (v334 >= v335 || !v336)
                                  {
                                    goto LABEL_655;
                                  }
                                }

                                v346 = BYTE8(v524[5]);
                                v347 = *(&v524[2] + 8);
                                v348 = *(&v524[3] + 8);
                                *(&v524[2] + 8) = v524[6];
                                v349 = *(&v524[4] + 8);
                                *(&v524[3] + 8) = v524[7];
                                *(&v524[4] + 8) = v524[8];
                                BYTE8(v524[5]) = v524[9];
                                v524[7] = v348;
                                v524[8] = v349;
                                v524[6] = v347;
                                LOBYTE(v524[9]) = v346;
                                *v526 = *(v524 + 8);
                                *(v524 + 8) = *(&v524[1] + 8);
                                *(&v524[1] + 8) = *v526;
                              }

LABEL_655:
                              v350 = v298 & 0xFFFFFFFD;
                              if ((v298 & 0xFFFFFFFD) == 1)
                              {
                                v351 = 0;
                              }

                              else
                              {
                                v351 = -1;
                              }

                              v352 = v295 & 0xFFFFFFFD;
                              v353 = v295 - 4;
                              v354 = v353 < 0xFFFFFFFD;
                              v101 = v352 == 1;
                              v355 = v352 != 1;
                              v356 = !v101 || v353 < 0xFFFFFFFD;
                              if (v353 <= 0xFFFFFFFC)
                              {
                                v355 = 0;
                              }

                              if (v298 == 2)
                              {
                                v357 = 1;
                              }

                              else
                              {
                                v357 = v351;
                              }

                              if (v298 == 2)
                              {
                                v358 = v355;
                              }

                              else
                              {
                                v358 = v354;
                              }

                              v359 = v350 == 1;
                              v360 = !v356;
                              if (v359)
                              {
                                v361 = !v356;
                              }

                              else
                              {
                                v361 = v358;
                              }

                              v362 = !v359 || v324 >= 3;
                              *&v524[0] = v320;
                              v363 = v309 & 0xFFFFFFFD;
                              if (!v362)
                              {
                                v360 = v361 + 1;
                              }

                              v364 = v306 & 0xFFFFFFFD;
                              v365 = v306 - 4;
                              v366 = v365 < 0xFFFFFFFD;
                              v101 = v364 == 1;
                              v367 = v364 != 1;
                              v368 = !v101 || v365 < 0xFFFFFFFD;
                              v369 = v365 > 0xFFFFFFFC && v367;
                              v370 = !v368;
                              if (v309 != 2)
                              {
                                v369 = v366;
                              }

                              v371 = v309 - 1;
                              if (v363 == 1)
                              {
                                v372 = v370;
                              }

                              else
                              {
                                v372 = v369;
                              }

                              if (v363 == 1 && v371 < 3)
                              {
                                v370 = v372 + 1;
                              }

                              v374 = v361 == 0;
                              if (v324 < 3)
                              {
                                v374 = v354;
                              }

                              v375 = v372 == 0;
                              if (v371 < 3)
                              {
                                v375 = v366;
                              }

                              if (v360 == 1 && v370 == 1 && v374 && v375)
                              {
                                if (v317 >= 0.0)
                                {
                                  v376 = 97;
                                }

                                else if (v357)
                                {
                                  v376 = 102;
                                }

                                else
                                {
                                  v376 = 116;
                                }
                              }

                              else
                              {
                                v376 = 99;
                                if (v360 == 2 && v370 == 2)
                                {
                                  v376 = 101;
                                }
                              }

                              v377 = v524[7];
                              if (v363 == 1)
                              {
                                v378 = 0;
                              }

                              else
                              {
                                v378 = -1;
                              }

                              if (v309 == 2)
                              {
                                v378 = 1;
                              }

                              *(a1 + 96) = v524[6];
                              *(a1 + 112) = v377;
                              *(a1 + 128) = v524[8];
                              *(a1 + 144) = *&v524[9];
                              v379 = v524[3];
                              *(a1 + 32) = v524[2];
                              *(a1 + 48) = v379;
                              v380 = v524[5];
                              *(a1 + 64) = v524[4];
                              *(a1 + 80) = v380;
                              v381 = v524[1];
                              *a1 = v524[0];
                              *(a1 + 16) = v381;
                              *(a1 + 152) = v376 | ((v317 < 0.0) << 8);
                              *(a1 + 156) = 0u;
                              *(a1 + 172) = 0u;
                              *(a1 + 188) = v357;
                              *(a1 + 192) = v378;
                              return;
                            }
                          }

                          else if (v63 >= v194)
                          {
                            if (v63 <= v223)
                            {
                              v309 = 2;
                            }

                            else
                            {
                              v309 = 4;
                            }

                            goto LABEL_565;
                          }

                          v309 = 0;
                          goto LABEL_565;
                        }
                      }
                    }

                    else if (v63 != v223)
                    {
                      goto LABEL_553;
                    }

                    v309 = 3;
                    goto LABEL_565;
                  }
                }

                else if (v194 <= 0.0)
                {
                  if (v223 >= 0.0)
                  {
                    v306 = 2;
                  }

                  else
                  {
                    v306 = 4;
                  }

                  goto LABEL_525;
                }

                v306 = 0;
                goto LABEL_525;
              }
            }
          }

          else if (v58 != v171)
          {
            goto LABEL_505;
          }

          v298 = 3;
          goto LABEL_517;
        }
      }

      else if (v134 <= 0.0)
      {
        if (v171 >= 0.0)
        {
          v295 = 2;
        }

        else
        {
          v295 = 4;
        }

        goto LABEL_477;
      }

      v295 = 0;
      goto LABEL_477;
    }

LABEL_116:
    v526[0] = 0.0;
    if (sub_101698D70(a4, a5, a2, v520, &v514, v522, v521, &v513, v526, v61))
    {
      if (v484 >= 0.0)
      {
        v116 = v526[0];
      }

      else
      {
        v116 = -v526[0];
      }

      if (v484 >= 0.0)
      {
        v117 = v484;
      }

      else
      {
        v117 = -v484;
      }

      v118 = 0.0;
      if (v484 != 0.0)
      {
        v118 = v116 * 1000000.0 / v117;
      }

      v119 = 0;
      *(a1 + 136) = 0u;
      *(a1 + 120) = 0u;
      *(a1 + 104) = 0u;
      *(a1 + 88) = 0u;
      *(a1 + 72) = 0u;
      *(a1 + 56) = 0u;
      *(a1 + 40) = 0u;
      *(a1 + 24) = 0u;
      do
      {
        v120 = a1 + v119;
        *(v120 + 40) = xmmword_1019ADEB0;
        *(v120 + 56) = 0;
        *(v120 + 64) = 0;
        *(v120 + 72) = xmmword_1019ADEC0;
        v119 += 56;
        *(v120 + 88) = 0;
      }

      while (v119 != 112);
      *a1 = 1;
      *(a1 + 8) = *a2;
      if ((atomic_load_explicit(&qword_101FCB058, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_101FCB058))
      {
        qword_101FCB050 = 0x3FF0000000000000;
        __cxa_guard_release(&qword_101FCB058);
      }

      v121 = qword_101FCB050;
      *(a1 + 88) = 1;
      *(a1 + 40) = 0;
      *(a1 + 48) = v121;
      *(a1 + 56) = 0;
      *(a1 + 64) = v116;
      *(a1 + 72) = v117;
      *(a1 + 80) = v118;
      goto LABEL_129;
    }

    v135 = 0;
    *&v524[0] = 0;
    do
    {
      v136 = v524 + v135;
      *(v136 + 40) = xmmword_1019ADEB0;
      *(v136 + 7) = 0;
      *(v136 + 8) = 0;
      *(v136 + 72) = xmmword_1019ADEC0;
      v135 += 56;
      v136[88] = 0;
    }

    while (v135 != 112);
LABEL_636:
    memset(&v525[2], 0, 32);
    v339 = v524[7];
    *(a1 + 96) = v524[6];
    *(a1 + 112) = v339;
    *(a1 + 128) = v524[8];
    v340 = v524[3];
    *(a1 + 32) = v524[2];
    *(a1 + 48) = v340;
    v341 = v524[5];
    *(a1 + 64) = v524[4];
    *(a1 + 80) = v341;
    v342 = v524[1];
    *a1 = v524[0];
    *(a1 + 16) = v342;
    v85 = *&v525[16];
    *(a1 + 154) = *v525;
    *&v525[34] = 0;
    *(a1 + 144) = *&v524[9];
    v86 = 100;
    goto LABEL_637;
  }

  if (!v95)
  {
    v109 = &v517 + 4;
    LODWORD(v517) = 0;
    goto LABEL_114;
  }

  v96 = v70 * v57 + v68 * v56 + v66 * v55;
  v97 = fabs(v96);
  if (v97 == 1.0)
  {
    goto LABEL_80;
  }

  if (COERCE_UNSIGNED_INT64(fabs(v70 * v57 + v68 * v56 + v66 * v55)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v152 = fabs(v97 + -1.0);
    if (v97 < 1.0)
    {
      v97 = 1.0;
    }

    if (v152 <= v97 * 2.22044605e-16)
    {
LABEL_80:
      v517 = 0;
      v518 = 0;
      if (!v74)
      {
        goto LABEL_81;
      }

      goto LABEL_116;
    }
  }

  if ((v74 | v87) == 1)
  {
    v153 = 0;
    *&v524[0] = 0;
    do
    {
      v154 = v524 + v153;
      *(v154 + 40) = xmmword_1019ADEB0;
      *(v154 + 7) = 0;
      *(v154 + 8) = 0;
      *(v154 + 72) = xmmword_1019ADEC0;
      v153 += 56;
      v154[88] = 0;
    }

    while (v153 != 112);
    goto LABEL_636;
  }

  v234 = v58;
  memset(v525, 0, 24);
  v508 = 0;
  v526[0] = 0.0;
  v507 = 0.0;
  if (sub_1016991D0(a2, a3, a4, a5, v522, v521, v520, v519, &v510, &v514, &v517, &v509, &v513, v525, v526, &v507, &v508))
  {
    *(&v524[4] + 1) = 0;
    *&v524[5] = &v523;
    v235 = v526[0];
    *(&v524[1] + 1) = v526[0];
    *&v524[2] = v234;
    if (v234 < 0.0)
    {
      v235 = -v526[0];
      v234 = -v234;
      *(&v524[1] + 1) = -v526[0];
      *&v524[2] = v234;
    }

    v236 = v484;
    v237 = 0.0;
    if (v234 != 0.0)
    {
      v237 = v235 * 1000000.0 / v234;
    }

    v238 = v507;
    *(&v524[2] + 1) = v237;
    *&v524[3] = v507;
    *(&v524[3] + 1) = v484;
    if (v484 < 0.0)
    {
      v238 = -v507;
      v236 = -v484;
      *&v524[3] = -v507;
      *(&v524[3] + 1) = -v484;
    }

    v239 = 0.0;
    if (v236 != 0.0)
    {
      v239 = v238 * 1000000.0 / v236;
    }

    *&v524[4] = v239;
    v524[0] = *v525;
    *&v524[1] = *&v525[16];
    DWORD2(v524[4]) = v508;
    sub_101699AA4(a1, &v517, v524, a2, a3, a4, a5);
  }

  else
  {
    sub_101698B70(a1);
  }
}

uint64_t sub_1016989B0(uint64_t a1)
{
  if ((*(a1 + 80) & 1) == 0)
  {
    v2 = 0;
    v4 = *(a1 + 24);
    v3 = *(a1 + 32);
    v6 = *v4;
    v5 = v4[1];
    v7 = fabs(v5);
    while (1)
    {
      v9 = *v3;
      v8 = v3[1];
      v20 = v5;
      v21 = v6;
      sub_101690AC8(&v21, &v20, 1);
      v10 = v21;
      v20 = v8;
      v21 = v9;
      sub_101690AC8(&v21, &v20, 1);
      if (v10 != v21)
      {
        if ((*&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v21 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          break;
        }

        v12 = fabs(v10);
        v13 = fabs(v21);
        v14 = vabdd_f64(v10, v21);
        if (v12 < v13)
        {
          v12 = v13;
        }

        if (v12 < 1.0)
        {
          v12 = 1.0;
        }

        if (v14 > v12 * 2.22044605e-16)
        {
          break;
        }
      }

      if (v5 != v8)
      {
        if ((*&v5 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          break;
        }

        v15 = fabs(v8);
        v16 = vabdd_f64(v5, v8);
        if (v7 >= v15)
        {
          v15 = v7;
        }

        if (v15 < 1.0)
        {
          v15 = 1.0;
        }

        if (v16 > v15 * 2.22044605e-16)
        {
          break;
        }
      }

      if (v2 >= *(*a1 + 88))
      {
        break;
      }

      v17 = *(a1 + 32);
      v3 = v17 + 2;
      *(a1 + 32) = v17 + 2;
      if (v17 + 2 == *(a1 + 48))
      {
        v18 = *(a1 + 40);
        *(a1 + 32) = v18;
        v3 = v18;
        if (*(a1 + 56) == 1)
        {
          v3 = v18 + 2;
          *(a1 + 32) = v18 + 2;
          if (v17 == v18)
          {
            *(a1 + 32) = v18;
            v3 = v18;
          }
        }
      }

      ++v2;
    }

    *(a1 + 64) = **(a1 + 32);
    *(a1 + 80) = 1;
  }

  return a1 + 64;
}

double sub_101698B70(uint64_t a1)
{
  v1 = 0;
  *&v9[0] = 0;
  do
  {
    v2 = v9 + v1;
    *(v2 + 40) = xmmword_1019ADEB0;
    *(v2 + 7) = 0;
    *(v2 + 8) = 0;
    *(v2 + 72) = xmmword_1019ADEC0;
    v1 += 56;
    v2[88] = 0;
  }

  while (v1 != 112);
  memset(&v11[2], 0, 32);
  v3 = v9[7];
  *(a1 + 96) = v9[6];
  *(a1 + 112) = v3;
  *(a1 + 128) = v9[8];
  v4 = v9[3];
  *(a1 + 32) = v9[2];
  *(a1 + 48) = v4;
  v5 = v9[5];
  *(a1 + 64) = v9[4];
  *(a1 + 80) = v5;
  v6 = v9[1];
  *a1 = v9[0];
  *(a1 + 16) = v6;
  v7 = *&v11[16];
  *(a1 + 154) = *v11;
  *&v11[34] = 0;
  *(a1 + 144) = v10;
  *(a1 + 152) = 100;
  *(a1 + 170) = v7;
  result = *&v11[26];
  *(a1 + 180) = *&v11[26];
  return result;
}

double sub_101698C54(double *a1)
{
  v1 = *a1;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v8 = a1;
    v7 = __cxa_guard_acquire(&qword_101FCB028);
    a1 = v8;
    if (v7)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      a1 = v8;
    }
  }

  v2 = *&qword_101FCB020;
  v3 = a1[1];
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_101FCB028))
  {
    qword_101FCB020 = 0x3F91DF46A2529D39;
    __cxa_guard_release(&qword_101FCB028);
  }

  v4 = v1 * v2;
  cosval = __sincos_stret(v3 * *&qword_101FCB020).__cosval;
  return __sincos_stret(v4).__cosval * cosval;
}

BOOL sub_101698D70(double *a1, double *a2, double *a3, double *a4, double *a5, double *a6, double *a7, double *a8, double *a9, char a10)
{
  LOBYTE(v55) = 1;
  v17 = 1.0 - sub_101699E94(a5, a4, a6, &v55);
  *a9 = v17;
  if ((LOBYTE(v55) & 1) == 0)
  {
    v17 = -v17;
    *a9 = v17;
  }

  if (v17 <= -2.0)
  {
    v17 = v17 + 4.0;
    *a9 = v17;
  }

  v18 = fabs(v17);
  if (v18 <= 0.00000001)
  {
    if (v17 == 0.0)
    {
      goto LABEL_29;
    }

    v28 = 1.0;
    if (v18 >= 1.0)
    {
      v28 = v18;
    }

    if (v18 <= v28 * 2.22044605e-16)
    {
      goto LABEL_29;
    }

    v29 = *a1;
    v30 = a1[1];
    v54 = v30;
    v55 = v29;
    sub_101690AC8(&v55, &v54, 1);
    v31 = v55;
    v32 = *a3;
    v33 = a3[1];
    v54 = v33;
    v55 = v32;
    sub_101690AC8(&v55, &v54, 1);
    if (v31 == v55)
    {
      goto LABEL_61;
    }

    if ((*&v31 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v55 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v42 = fabs(v31);
      v43 = fabs(v55);
      v44 = vabdd_f64(v31, v55);
      if (v42 < v43)
      {
        v42 = v43;
      }

      if (v42 < 1.0)
      {
        v42 = 1.0;
      }

      if (v44 <= v42 * 2.22044605e-16)
      {
LABEL_61:
        if (v33 == v30)
        {
          goto LABEL_29;
        }

        if ((*&v30 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v33 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v45 = fabs(v30);
          v46 = fabs(v33);
          v47 = vabdd_f64(v30, v33);
          if (v45 < v46)
          {
            v45 = v46;
          }

          if (v45 < 1.0)
          {
            v45 = 1.0;
          }

          if (v47 <= v45 * 2.22044605e-16)
          {
            goto LABEL_29;
          }
        }
      }
    }
  }

  v19 = vabdd_f64(*a8, *a9);
  if (v19 <= 0.00000001)
  {
    if (*a8 - *a9 == 0.0)
    {
      goto LABEL_36;
    }

    v34 = 1.0;
    if (v19 >= 1.0)
    {
      v34 = v19;
    }

    if (v19 <= v34 * 2.22044605e-16)
    {
      goto LABEL_36;
    }

    v35 = *a2;
    v36 = a2[1];
    v54 = v36;
    v55 = v35;
    sub_101690AC8(&v55, &v54, 1);
    v37 = v55;
    v38 = *a3;
    v39 = a3[1];
    v54 = v39;
    v55 = v38;
    sub_101690AC8(&v55, &v54, 1);
    if (v37 == v55)
    {
      goto LABEL_77;
    }

    if ((*&v37 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v55 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v48 = fabs(v37);
      v49 = fabs(v55);
      v50 = vabdd_f64(v37, v55);
      if (v48 < v49)
      {
        v48 = v49;
      }

      if (v48 < 1.0)
      {
        v48 = 1.0;
      }

      if (v50 <= v48 * 2.22044605e-16)
      {
LABEL_77:
        if (v39 == v36)
        {
          goto LABEL_36;
        }

        if ((*&v36 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v39 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v51 = fabs(v36);
          v52 = fabs(v39);
          v53 = vabdd_f64(v36, v39);
          if (v51 < v52)
          {
            v51 = v52;
          }

          if (v51 < 1.0)
          {
            v51 = 1.0;
          }

          if (v53 <= v51 * 2.22044605e-16)
          {
LABEL_36:
            v24 = *a8;
            goto LABEL_37;
          }
        }
      }
    }
  }

  if (a10)
  {
    LOBYTE(v55) = 1;
    v20 = 1.0 - sub_101699E94(a5, a4, a7, &v55);
    if (!LOBYTE(v55))
    {
      v20 = -v20;
    }

    v21 = v20 + 4.0;
    if (v20 > -2.0)
    {
      v21 = v20;
    }

    if (v21 == 0.0)
    {
      goto LABEL_29;
    }

    if ((*&v21 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v22 = fabs(v21);
      v23 = 1.0;
      if (v22 >= 1.0)
      {
        v23 = v22;
      }

      if (v22 <= v23 * 2.22044605e-16)
      {
LABEL_29:
        *a9 = 0.0;
        return 1;
      }
    }

    v24 = *a8;
    v25 = *a8 - v21;
    if (v25 == 0.0)
    {
      goto LABEL_37;
    }

    if ((*&v25 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v26 = fabs(v25);
      v27 = 1.0;
      if (v26 >= 1.0)
      {
        v27 = v26;
      }

      if (v26 <= v27 * 2.22044605e-16)
      {
LABEL_37:
        *a9 = v24;
        return 1;
      }
    }
  }

  else
  {
    v24 = *a8;
  }

  v41 = *a9;
  if (v24 < 0.0)
  {
    v41 = -*a9;
  }

  if (v41 < 0.0)
  {
    return 0;
  }

  if (v24 < 0.0)
  {
    v24 = -v24;
  }

  return v41 <= v24;
}

uint64_t sub_1016991D0(double *a1, double *a2, double *a3, double *a4, double *a5, double *a6, double *a7, double *a8, double *a9, double *a10, _DWORD *a11, double *a12, double *a13, double *a14, double *a15, double *a16, int *a17)
{
  v21 = a10[1];
  v20 = a10[2];
  v23 = a9[1];
  v22 = a9[2];
  v24 = v23 * v20 - v22 * v21;
  v25 = v22 * *a10 - *a9 * v20;
  v26 = *a9 * v21 - v23 * *a10;
  v27 = sqrt(v26 * v26 + v25 * v25 + v24 * v24);
  v28 = v24 / v27;
  v29 = v25 / v27;
  v30 = v26 / v27;
  v32 = a5[1];
  v31 = a5[2];
  v33 = v22 * (*a5 * v29 - v32 * v28) + v23 * (v31 * v28 - *a5 * v30) + *a9 * (v32 * v30 - v31 * v29);
  v34 = 1.0 - (v31 * v30 + v32 * v29 + *a5 * v28);
  if (v33 >= 0.0)
  {
    v35 = v34;
  }

  else
  {
    v35 = -v34;
  }

  if (v35 <= -2.0)
  {
    v35 = v35 + 4.0;
  }

  *a15 = v35;
  *a14 = v28;
  a14[1] = v29;
  a14[2] = v30;
  v36 = *a15;
  if (*a15 >= 0.0)
  {
    if (v36 <= *a12)
    {
      goto LABEL_20;
    }

    v37 = v36 - *a12;
  }

  else
  {
    v37 = -v36;
  }

  if (v37 > 0.0)
  {
    if (v36 + -2.0 <= -2.0)
    {
      v38 = v36 + -2.0 + 4.0;
    }

    else
    {
      v38 = v36 + -2.0;
    }

    if (v38 >= 0.0)
    {
      v39 = 0.0;
      if (v38 > *a12)
      {
        v39 = v38 - *a12;
      }
    }

    else
    {
      v39 = -v38;
    }

    if (v39 < v37)
    {
      *a15 = v38;
      *a14 = -v28;
      a14[1] = -v29;
      a14[2] = -v30;
      v36 = *a15;
    }
  }

LABEL_20:
  v40 = -v36;
  v41 = -*a12;
  if (*a12 >= 0.0)
  {
    v40 = v36;
    v41 = *a12;
  }

  v42 = v40 <= v41 && v40 >= 0.0;
  v43 = fabs(v36);
  v44 = vabdd_f64(*a12, v36);
  if (!v42 && v43 > 0.00000001 && v44 > 0.00000001)
  {
    return 0;
  }

  LOBYTE(v110[0]) = 1;
  v45 = 1.0 - sub_101699E94(a10, a7, a14, v110);
  *a16 = v45;
  if ((LOBYTE(v110[0]) & 1) == 0)
  {
    v45 = -v45;
    *a16 = v45;
  }

  if (v45 <= -2.0)
  {
    v45 = v45 + 4.0;
    *a16 = v45;
  }

  v46 = -v45;
  v47 = -*a13;
  if (*a13 >= 0.0)
  {
    v46 = v45;
    v47 = *a13;
  }

  v48 = v46 <= v47 && v46 >= 0.0;
  v49 = fabs(v45);
  v50 = vabdd_f64(*a13, v45);
  if (!v48 && v49 > 0.00000001 && v50 > 0.00000001)
  {
    return 0;
  }

  if (v43 <= 0.00000001)
  {
    if (v49 > 0.00000001)
    {
      goto LABEL_80;
    }

    v52 = *a1;
    v53 = a1[1];
    v109 = v53;
    v110[0] = v52;
    v54 = v48;
    sub_101690AC8(v110, &v109, 1);
    v55 = v110[0];
    v56 = *a3;
    v57 = a3[1];
    v109 = v57;
    v110[0] = v56;
    sub_101690AC8(v110, &v109, 1);
    v48 = v54;
    if (v55 != v110[0])
    {
      if ((*&v55 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v110[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_80;
      }

      v58 = fabs(v55);
      v59 = fabs(v110[0]);
      v60 = vabdd_f64(v55, v110[0]);
      if (v58 < v59)
      {
        v58 = v59;
      }

      if (v58 < 1.0)
      {
        v58 = 1.0;
      }

      if (v60 > v58 * 2.22044605e-16)
      {
        goto LABEL_80;
      }
    }

    if (v53 == v57)
    {
      goto LABEL_45;
    }

    if ((*&v53 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v57 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_80;
    }

    v61 = fabs(v53);
    v62 = fabs(v57);
    v63 = vabdd_f64(v53, v57);
    if (v61 < v62)
    {
      v61 = v62;
    }

    if (v61 < 1.0)
    {
      v61 = 1.0;
    }

    if (v63 <= v61 * 2.22044605e-16)
    {
LABEL_45:
      *a15 = 0.0;
      *a16 = 0.0;
    }

    else
    {
LABEL_80:
      if (v50 > 0.00000001)
      {
        goto LABEL_81;
      }

      v64 = *a1;
      v65 = a1[1];
      v109 = v65;
      v110[0] = v64;
      v66 = v48;
      sub_101690AC8(v110, &v109, 1);
      v67 = v110[0];
      v68 = *a4;
      v69 = a4[1];
      v109 = v69;
      v110[0] = v68;
      sub_101690AC8(v110, &v109, 1);
      v48 = v66;
      if (v67 != v110[0])
      {
        if ((*&v67 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v110[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_81;
        }

        v71 = fabs(v67);
        v72 = fabs(v110[0]);
        v73 = vabdd_f64(v67, v110[0]);
        if (v71 < v72)
        {
          v71 = v72;
        }

        if (v71 < 1.0)
        {
          v71 = 1.0;
        }

        if (v73 > v71 * 2.22044605e-16)
        {
          goto LABEL_81;
        }
      }

      if (v65 != v69)
      {
        if ((*&v65 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v69 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_81;
        }

        v74 = fabs(v65);
        v75 = fabs(v69);
        v76 = vabdd_f64(v65, v69);
        if (v74 < v75)
        {
          v74 = v75;
        }

        if (v74 < 1.0)
        {
          v74 = 1.0;
        }

        if (v76 > v74 * 2.22044605e-16)
        {
          goto LABEL_81;
        }
      }

      *a15 = 0.0;
      *a16 = *a13;
    }

    result = 1;
    v70 = a17;
LABEL_139:
    *v70 = 1;
    return result;
  }

LABEL_81:
  if (v44 > 0.00000001)
  {
    goto LABEL_120;
  }

  if (v49 <= 0.00000001)
  {
    v77 = *a2;
    v78 = a2[1];
    v109 = v78;
    v110[0] = v77;
    v79 = v48;
    sub_101690AC8(v110, &v109, 1);
    v80 = v110[0];
    v81 = *a3;
    v82 = a3[1];
    v109 = v82;
    v110[0] = v81;
    sub_101690AC8(v110, &v109, 1);
    v48 = v79;
    if (v80 == v110[0])
    {
      goto LABEL_84;
    }

    if ((*&v80 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v110[0] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v83 = fabs(v80);
      v84 = fabs(v110[0]);
      v85 = vabdd_f64(v80, v110[0]);
      if (v83 < v84)
      {
        v83 = v84;
      }

      if (v83 < 1.0)
      {
        v83 = 1.0;
      }

      if (v85 <= v83 * 2.22044605e-16)
      {
LABEL_84:
        if (v78 == v82)
        {
          goto LABEL_85;
        }

        if ((*&v78 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v82 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v86 = fabs(v78);
          v87 = fabs(v82);
          v88 = vabdd_f64(v78, v82);
          if (v86 < v87)
          {
            v86 = v87;
          }

          if (v86 < 1.0)
          {
            v86 = 1.0;
          }

          if (v88 <= v86 * 2.22044605e-16)
          {
LABEL_85:
            *a15 = *a12;
            *a16 = 0.0;
LABEL_143:
            v102 = 2;
            goto LABEL_144;
          }
        }
      }
    }
  }

  if (v50 <= 0.00000001)
  {
    v89 = *a2;
    v90 = a2[1];
    v109 = v90;
    v110[0] = v89;
    v91 = v48;
    sub_101690AC8(v110, &v109, 1);
    v92 = v110[0];
    v93 = *a4;
    v94 = a4[1];
    v109 = v94;
    v110[0] = v93;
    sub_101690AC8(v110, &v109, 1);
    v48 = v91;
    if (v92 == v110[0])
    {
      goto LABEL_103;
    }

    if ((*&v92 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v110[0] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v95 = fabs(v92);
      v96 = fabs(v110[0]);
      v97 = vabdd_f64(v92, v110[0]);
      if (v95 < v96)
      {
        v95 = v96;
      }

      if (v95 < 1.0)
      {
        v95 = 1.0;
      }

      if (v97 <= v95 * 2.22044605e-16)
      {
LABEL_103:
        if (v90 == v94)
        {
          goto LABEL_104;
        }

        if ((*&v90 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v94 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v98 = fabs(v90);
          v99 = fabs(v94);
          v100 = vabdd_f64(v90, v94);
          if (v98 < v99)
          {
            v98 = v99;
          }

          if (v98 < 1.0)
          {
            v98 = 1.0;
          }

          if (v100 <= v98 * 2.22044605e-16)
          {
LABEL_104:
            *a15 = *a12;
            *a16 = *a13;
            goto LABEL_143;
          }
        }
      }
    }
  }

LABEL_120:
  if (v42)
  {
    if (v49 <= 0.00000001 && !a11[2])
    {
      LOBYTE(v110[0]) = 1;
      v101 = 1.0 - sub_101699E94(a9, a5, a7, v110);
      *a15 = v101;
      if ((LOBYTE(v110[0]) & 1) == 0)
      {
        v101 = -v101;
        *a15 = v101;
      }

      if (v101 <= -2.0)
      {
        *a15 = v101 + 4.0;
      }

      *a16 = 0.0;
      v102 = 3;
      goto LABEL_144;
    }

    if (v50 <= 0.00000001 && !a11[3])
    {
      sub_101699E1C(a5, a9, a8, a15);
      *a16 = *a13;
      v102 = 4;
LABEL_144:
      *a17 = v102;
      return 1;
    }
  }

  if (v48)
  {
    if (v43 <= 0.00000001 && !*a11)
    {
      *a15 = 0.0;
      LOBYTE(v110[0]) = 1;
      v103 = 1.0 - sub_101699E94(a10, a7, a5, v110);
      *a16 = v103;
      if ((LOBYTE(v110[0]) & 1) == 0)
      {
        v103 = -v103;
        *a16 = v103;
      }

      v70 = a17;
      if (v103 <= -2.0)
      {
        *a16 = v103 + 4.0;
      }

      result = 1;
      goto LABEL_139;
    }

    if (v44 <= 0.00000001 && !a11[1])
    {
      *a15 = *a12;
      sub_101699E1C(a7, a10, a6, a16);
      goto LABEL_143;
    }
  }

  *a17 = 0;
  return v42 & v48;
}

__n128 sub_101699AA4(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v10 = 0;
  memset(&v38[8], 0, 144);
  do
  {
    v11 = &v38[v10];
    *(v11 + 40) = xmmword_1019ADEB0;
    *(v11 + 7) = 0;
    *(v11 + 8) = 0;
    *(v11 + 72) = xmmword_1019ADEC0;
    v10 += 56;
    v11[88] = 0;
  }

  while (v10 != 112);
  *v38 = 1;
  v12 = *(a3 + 72);
  if (v12 > 1)
  {
    if (v12 != 2)
    {
      if (v12 == 3)
      {
        v13 = *a6;
        v14 = *(a6 + 8);
        goto LABEL_15;
      }

      goto LABEL_10;
    }

    v13 = *a5;
    v14 = *(a5 + 8);
  }

  else
  {
    if (v12)
    {
      if (v12 == 1)
      {
        v13 = *a4;
        v14 = *(a4 + 8);
        goto LABEL_15;
      }

LABEL_10:
      v13 = *a7;
      v14 = *(a7 + 8);
      goto LABEL_15;
    }

    v16 = *a3;
    v15 = *(a3 + 8);
    v17 = *(a3 + 16);
    if ((atomic_load_explicit(&qword_101FCB048, memory_order_acquire) & 1) == 0)
    {
      v36 = v16;
      v32 = v15;
      v33 = __cxa_guard_acquire(&qword_101FCB048);
      v15 = v32;
      v16 = v36;
      if (v33)
      {
        qword_101FCB040 = 0x404CA5DC1A63C1F8;
        __cxa_guard_release(&qword_101FCB048);
        v15 = v32;
        v16 = v36;
      }
    }

    v18 = *&qword_101FCB040;
    if ((atomic_load_explicit(&qword_101FCB048, memory_order_acquire) & 1) == 0)
    {
      v35 = v15;
      v37 = v16;
      v34 = __cxa_guard_acquire(&qword_101FCB048);
      v15 = v35;
      v16 = v37;
      if (v34)
      {
        qword_101FCB040 = 0x404CA5DC1A63C1F8;
        __cxa_guard_release(&qword_101FCB048);
        v15 = v35;
        v16 = v37;
      }
    }

    v19 = v18 * atan2(v15, v16);
    v14 = asin(v17) * *&qword_101FCB040;
    v39 = v14;
    v40 = v19;
    sub_101690AC8(&v40, &v39, 1);
    v13 = v40;
  }

LABEL_15:
  *&v38[8] = v13;
  *&v38[16] = v14;
  v38[88] = 1;
  *&v38[40] = *(a3 + 24);
  *&v38[56] = *(a3 + 40);
  *&v38[64] = *(a3 + 48);
  *&v38[80] = *(a3 + 64);
  v20 = *a2;
  v21 = a2[2];
  v22 = a2[3];
  if (!(*a2 | v21))
  {
    v21 = -1;
    if (v22 == 1)
    {
      v24 = -1;
    }

    else
    {
      v24 = 1;
    }

    if (v22 == 1)
    {
      v25 = 1;
    }

    else
    {
      v25 = -1;
    }

    v26 = 102;
    goto LABEL_37;
  }

  v23 = a2[1];
  if (v23 | v22)
  {
    if (v23 | v21)
    {
      if (v20 | v22)
      {
        if (v21)
        {
          if (v20)
          {
            if (v22)
            {
              if (v23)
              {
                v21 = -1;
                if (v22 == 1)
                {
                  v24 = -1;
                }

                else
                {
                  v24 = 1;
                }

                if (v22 == 1)
                {
                  v25 = 1;
                }

                else
                {
                  v25 = -1;
                }

                v26 = 105;
LABEL_37:
                v20 = -1;
                goto LABEL_55;
              }

              v20 = 0;
              if (v22 == 1)
              {
                v24 = 1;
              }

              else
              {
                v24 = -1;
              }

              v21 = 1;
            }

            else
            {
              v21 = 0;
              if (v23 == 1)
              {
                v24 = 1;
              }

              else
              {
                v24 = -1;
              }

              v20 = 1;
            }

            v26 = 109;
LABEL_54:
            v25 = v24;
            goto LABEL_55;
          }

          if (v22 == 1)
          {
            v25 = 1;
          }

          else
          {
            v25 = -1;
          }

          v21 = -1;
          if (v22 == 1)
          {
            v24 = -1;
          }

          else
          {
            v24 = 1;
          }
        }

        else
        {
          v20 = -1;
          if (v22 == 1)
          {
            v24 = -1;
          }

          else
          {
            v24 = 1;
          }

          if (v22 == 1)
          {
            v25 = 1;
          }

          else
          {
            v25 = -1;
          }
        }

        v26 = 115;
        goto LABEL_55;
      }

      if (v21 == 1)
      {
        v24 = 1;
      }

      else
      {
        v24 = -1;
      }

      v20 = 1;
      v21 = -1;
    }

    else
    {
      if (v22 == 1)
      {
        v24 = 1;
      }

      else
      {
        v24 = -1;
      }

      v20 = -1;
      v21 = 1;
    }

    v26 = 97;
    goto LABEL_54;
  }

  if (v21 == 1)
  {
    v24 = -1;
  }

  else
  {
    v24 = 1;
  }

  if (v21 == 1)
  {
    v25 = 1;
  }

  else
  {
    v25 = -1;
  }

  v21 = 1;
  v26 = 116;
  v20 = 1;
LABEL_55:
  v27 = *&v38[112];
  *(a1 + 96) = *&v38[96];
  *(a1 + 112) = v27;
  *(a1 + 128) = *&v38[128];
  *(a1 + 144) = *&v38[144];
  v28 = *&v38[48];
  *(a1 + 32) = *&v38[32];
  *(a1 + 48) = v28;
  v29 = *&v38[80];
  *(a1 + 64) = *&v38[64];
  *(a1 + 80) = v29;
  v30 = *&v38[16];
  *a1 = *v38;
  *(a1 + 16) = v30;
  *(a1 + 152) = v26;
  *(a1 + 153) = 0;
  *(a1 + 156) = v21;
  *(a1 + 160) = v20;
  *(a1 + 164) = v24;
  *(a1 + 168) = v25;
  result = *a2;
  *(a1 + 172) = *a2;
  *(a1 + 188) = v21;
  *(a1 + 192) = v20;
  return result;
}

double sub_101699E1C(double *a1, double *a2, double *a3, double *a4)
{
  v6 = 1;
  result = 1.0 - sub_101699E94(a2, a1, a3, &v6);
  *a4 = result;
  if ((v6 & 1) == 0)
  {
    result = -result;
    *a4 = result;
  }

  if (result <= -2.0)
  {
    result = result + 4.0;
    *a4 = result;
  }

  return result;
}

double sub_101699E94(double *a1, double *a2, double *a3, BOOL *a4)
{
  v5 = a3[1];
  v4 = a3[2];
  v7 = a2[1];
  v6 = a2[2];
  v8 = *a3;
  v9 = *a2;
  *a4 = (*a2 * v5 - v7 * *a3) * a1[2] + a1[1] * (v6 * *a3 - *a2 * v4) + *a1 * (v7 * v4 - v6 * v5) >= 0.0;
  return v4 * v6 + v7 * v5 + v9 * v8;
}

void *sub_101699EEC(void *a1, void *__src)
{
  v4 = a1[1];
  v5 = a1[2];
  if (v5 == v4)
  {
    v6 = 0;
  }

  else
  {
    v6 = 2 * (v5 - v4) - 1;
  }

  v7 = a1[4];
  v8 = a1[5] + v7;
  if (v6 == v8)
  {
    if (v7 < 0x10)
    {
      v9 = a1[3];
      v10 = v9 - *a1;
      if (v5 - v4 < v10)
      {
        operator new();
      }

      v11 = v10 >> 2;
      if (v9 == *a1)
      {
        v12 = 1;
      }

      else
      {
        v12 = v11;
      }

      sub_100EF4E80(v12);
    }

    a1[4] = v7 - 16;
    v14 = *v4;
    a1[1] = v4 + 8;
    sub_1010F098C(a1, &v14);
    v4 = a1[1];
    v8 = a1[5] + a1[4];
  }

  result = memcpy((*&v4[(v8 >> 1) & 0x7FFFFFFFFFFFFFF8] + 376 * (v8 & 0xF)), __src, 0x178uLL);
  ++a1[5];
  return result;
}

void sub_10169A350(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v1)
  {
    operator delete(v1);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10169A37C(double *a1, double *a2, double *a3)
{
  v3 = *a1;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v39 = a1;
    v41 = a2;
    v46 = a3;
    v29 = __cxa_guard_acquire(&qword_101FCB028);
    a2 = v41;
    a3 = v46;
    v30 = v29;
    a1 = v39;
    if (v30)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      a1 = v39;
      a2 = v41;
      a3 = v46;
    }
  }

  v4 = *&qword_101FCB020;
  v5 = a1[1];
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v42 = a2;
    v47 = a3;
    v31 = __cxa_guard_acquire(&qword_101FCB028);
    a2 = v42;
    a3 = v47;
    if (v31)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      a2 = v42;
      a3 = v47;
    }
  }

  v6 = *&qword_101FCB020;
  v7 = *a2;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v43 = a2;
    v48 = a3;
    v32 = __cxa_guard_acquire(&qword_101FCB028);
    a2 = v43;
    a3 = v48;
    if (v32)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      a2 = v43;
      a3 = v48;
    }
  }

  v8 = *&qword_101FCB020;
  v9 = a2[1];
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v49 = a3;
    v33 = v8;
    v34 = __cxa_guard_acquire(&qword_101FCB028);
    v8 = v33;
    a3 = v49;
    if (v34)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      v8 = v33;
      a3 = v49;
    }
  }

  v10 = *&qword_101FCB020;
  v11 = *a3;
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v50 = a3;
    v35 = v8;
    v40 = v10;
    v44 = v11;
    v36 = __cxa_guard_acquire(&qword_101FCB028);
    v10 = v40;
    v11 = v44;
    v8 = v35;
    a3 = v50;
    if (v36)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      v10 = v40;
      v11 = v44;
      v8 = v35;
      a3 = v50;
    }
  }

  v12 = v3 * v4;
  v13 = v5 * v6;
  v14 = v7 * v8;
  v15 = v9 * v10;
  v45 = v11 * *&qword_101FCB020;
  v16 = a3[1];
  if ((atomic_load_explicit(&qword_101FCB028, memory_order_acquire) & 1) == 0)
  {
    v37 = v5 * v6;
    v38 = __cxa_guard_acquire(&qword_101FCB028);
    v13 = v37;
    if (v38)
    {
      qword_101FCB020 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101FCB028);
      v13 = v37;
    }
  }

  v17 = v16 * *&qword_101FCB020;
  v18 = __sincos_stret(v13);
  v19 = __sincos_stret(v12);
  v20 = __sincos_stret(v15);
  v21 = __sincos_stret(v14);
  v22 = __sincos_stret(v17);
  v23 = __sincos_stret(v45);
  v24 = v23.__sinval * ((v18.__sinval * (v21.__cosval * v20.__cosval) - v19.__cosval * v18.__cosval * v20.__sinval) * v22.__cosval) + (v19.__sinval * v18.__cosval * v20.__sinval - v18.__sinval * (v21.__sinval * v20.__cosval)) * v22.__cosval * v23.__cosval + (v19.__cosval * v18.__cosval * (v21.__sinval * v20.__cosval) - v19.__sinval * v18.__cosval * (v21.__cosval * v20.__cosval)) * v22.__sinval;
  if (v24 == 0.0)
  {
    return 0;
  }

  if (COERCE_UNSIGNED_INT64(fabs(v23.__sinval * ((v18.__sinval * (v21.__cosval * v20.__cosval) - v19.__cosval * v18.__cosval * v20.__sinval) * v22.__cosval) + (v19.__sinval * v18.__cosval * v20.__sinval - v18.__sinval * (v21.__sinval * v20.__cosval)) * v22.__cosval * v23.__cosval + (v19.__cosval * v18.__cosval * (v21.__sinval * v20.__cosval) - v19.__sinval * v18.__cosval * (v21.__cosval * v20.__cosval)) * v22.__sinval)) < 0x7FF0000000000000)
  {
    v26 = fabs(v24);
    v27 = 1.0;
    if (v26 >= 1.0)
    {
      v27 = v26;
    }

    v28 = v27 * 2.22044605e-16;
    if (v24 > 0.0)
    {
      result = 1;
    }

    else
    {
      result = 0xFFFFFFFFLL;
    }

    if (v26 <= v28)
    {
      return 0;
    }
  }

  else if (v24 > 0.0)
  {
    return 1;
  }

  else
  {
    return 0xFFFFFFFFLL;
  }

  return result;
}

void sub_10169A73C(float64x2_t **a1, uint64_t a2)
{
  v5 = *a1;
  v4 = a1[1];
  if (0xEEEEEEEEEEEEEEEFLL * ((v4 - *a1) >> 3) < 0x11)
  {
    while (v5 != v4)
    {
      v6 = v5;
      v5 = (v5 + 120);
      if (v5 != v4)
      {
        v7 = v5;
        do
        {
          sub_10169AC38(a2, v6, v7);
          v7 += 120;
          v4 = a1[1];
        }

        while (v7 != v4);
      }
    }
  }

  else
  {
    memset(__p, 0, sizeof(__p));
    v10 = v5;
    v8[0] = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    v8[1] = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    while (v5 != v4)
    {
      sub_1016932F4(v8, v5 + 2);
      sub_1016931F4(__p, &v10);
      v5 = (v5 + 120);
      v10 = v5;
      v4 = a1[1];
    }

    sub_10169A860(v8[0].f64, __p, 0, a2);
    if (__p[0])
    {
      operator delete(__p[0]);
    }
  }
}

void sub_10169A844(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_10169A860(double *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  v6 = (*a1 + a1[2]) * 0.5;
  v7 = *(a1 + 1);
  v45 = *a1;
  v47 = *(&v7 + 1);
  v43[1] = *(&v45 + 1);
  v44 = v7;
  v46 = v6;
  v43[0] = v6;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  sub_101693508(&v45, v43, a2, &v40, &v37, &v34);
  v8 = v34;
  v9 = v35;
  if (v34 == v35)
  {
    goto LABEL_30;
  }

  v48 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  v49 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  v10 = v34;
  do
  {
    sub_1016932F4(&v48, *v10++ + 2);
  }

  while (v10 != v9);
  v33[0] = v48;
  v33[1] = v49;
  v11 = v9 - v8;
  v12 = v8;
  if (a3 > 0x63 || (v12 = v8, v11 < 0x79))
  {
    do
    {
      v14 = v12 + 1;
      if (v12 + 1 == v9)
      {
        break;
      }

      v13 = v12 + 1;
      do
      {
        sub_10169AC38(a4, *v12, *v13++);
      }

      while (v13 != v9);
      ++v12;
    }

    while (v14 != v9);
  }

  else
  {
    sub_10169AE5C(v33, &v34, a3 + 1, a4);
  }

  if (v11 >= 0x80 && a3 <= 0x63 && (v41 - v40) >= 0x79)
  {
    sub_10169B858(v33, &v34, &v40, a3 + 1, a4);
    goto LABEL_22;
  }

  v15 = v40;
  v16 = v41;
  if (v40 != v41)
  {
    v17 = v8;
    do
    {
      v18 = v15;
      do
      {
        sub_10169AC38(a4, *v17, *v18++);
      }

      while (v18 != v16);
      ++v17;
    }

    while (v17 != v9);
  }

  if (v11 >= 0x80)
  {
LABEL_22:
    if (a3 <= 0x63 && (v38 - v37) >= 0x79)
    {
      sub_10169B858(v33, &v34, &v37, a3 + 1, a4);
      goto LABEL_30;
    }
  }

  v19 = v37;
  v20 = v38;
  if (v37 != v38)
  {
    v21 = v8;
    do
    {
      v22 = v19;
      do
      {
        sub_10169AC38(a4, *v21, *v22++);
      }

      while (v22 != v20);
      ++v21;
    }

    while (v21 != v9);
  }

LABEL_30:
  v23 = v40;
  v24 = v41;
  if (a3 > 0x63 || (v41 - v40) < 0x79)
  {
    if (v40 != v41)
    {
      v25 = v40;
      do
      {
        v26 = v25 + 1;
        if (v25 + 1 == v24)
        {
          break;
        }

        v27 = v25 + 1;
        do
        {
          sub_10169AC38(a4, *v25, *v27++);
        }

        while (v27 != v24);
        ++v25;
      }

      while (v26 != v24);
    }
  }

  else
  {
    sub_10169AE5C(&v45, &v40, a3 + 1, a4);
  }

  v28 = v37;
  v29 = v38;
  if (a3 > 0x63 || (v38 - v37) < 0x79)
  {
    if (v37 != v38)
    {
      v30 = v37;
      do
      {
        v31 = v30 + 1;
        if (v30 + 1 == v29)
        {
          break;
        }

        v32 = v30 + 1;
        do
        {
          sub_10169AC38(a4, *v30, *v32++);
        }

        while (v32 != v29);
        ++v30;
      }

      while (v31 != v29);
    }
  }

  else
  {
    sub_10169AE5C(v43, &v37, a3 + 1, a4);
  }

  if (v8)
  {
    operator delete(v8);
  }

  if (v28)
  {
    operator delete(v28);
  }

  if (v23)
  {

    operator delete(v23);
  }
}

void sub_10169ABE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20)
{
  if (v20)
  {
    operator delete(v20);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a20)
  {
    operator delete(a20);
  }

  _Unwind_Resume(exception_object);
}

void sub_10169AC38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a2 + 32);
  v7 = *(a2 + 48);
  if (v7 - v6 >= 360.0 || (v8 = *(a3 + 32), v9 = *(a3 + 48), v10 = v9 - v8, v9 - v8 >= 360.0))
  {
LABEL_11:
    if (*(a2 + 56) >= *(a3 + 40) && *(a2 + 40) <= *(a3 + 56) && (*(a2 + 96) & 1) == 0 && (*(a3 + 96) & 1) == 0)
    {
      sub_101693EFC(*(a1 + 40), *a1, a2, *(a1 + 40), *a1, a3, *(a1 + 44), *(a1 + 8), *(a1 + 16), *(a1 + 24));
    }

    return;
  }

  v11 = vabdd_f64(v8, v6);
  v12 = 180.0;
  if (v11 == 180.0)
  {
    goto LABEL_4;
  }

  v13 = v8 - v6;
  if ((*&v13 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v16 = fabs(v11 + -180.0);
    v12 = 180.0;
    if (v11 < 180.0)
    {
      v11 = 180.0;
    }

    if (v11 < 1.0)
    {
      v11 = 1.0;
    }

    if (v16 <= v11 * 2.22044605e-16)
    {
      goto LABEL_4;
    }
  }

  v12 = 180.0;
  if (v13 <= 180.0)
  {
    if (v13 >= -180.0)
    {
      goto LABEL_5;
    }

    v12 = fmod(v13 + -180.0, 360.0) + 180.0;
LABEL_4:
    v13 = v12;
    goto LABEL_5;
  }

  v13 = fmod(v13 + 180.0, 360.0) + -180.0;
  if (v13 == -180.0)
  {
    goto LABEL_4;
  }

  if ((*&v13 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v17 = fabs(v13);
    v12 = 180.0;
    v18 = fabs(v13 + 180.0);
    if (v17 < 180.0)
    {
      v17 = 180.0;
    }

    if (v17 < 1.0)
    {
      v17 = 1.0;
    }

    if (v18 <= v17 * 2.22044605e-16)
    {
      goto LABEL_4;
    }
  }

LABEL_5:
  if (v13 < 0.0)
  {
    v13 = v13 + 360.0;
  }

  v14 = v6 + v13;
  v15 = v10 + v6 + v13 + -360.0;
  if (vabdd_f64(v15, v9) < 180.0)
  {
    v15 = v9;
  }

  if (v14 <= v7 || v15 >= v6)
  {
    goto LABEL_11;
  }
}

void sub_10169AE5C(double *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  v6 = (a1[1] + a1[3]) * 0.5;
  v47 = *(a1 + 2);
  v7 = *a1;
  v8 = *(a1 + 1);
  v44[0] = *a1;
  v45 = v8;
  v46 = v7;
  v48 = v6;
  v44[1] = v6;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_101693508(&v46, v44, a2, &v41, &v38, &v35);
  v9 = v35;
  v10 = v36;
  if (v35 == v36)
  {
    goto LABEL_30;
  }

  v49 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  v50 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  v11 = v35;
  do
  {
    sub_1016932F4(&v49, *v11++ + 2);
  }

  while (v11 != v10);
  v34[0] = v49;
  v34[1] = v50;
  v12 = v10 - v9;
  v13 = v9;
  if (a3 > 0x63 || (v13 = v9, v12 < 0x79))
  {
    do
    {
      v15 = v13 + 1;
      if (v13 + 1 == v10)
      {
        break;
      }

      v14 = v13 + 1;
      do
      {
        sub_10169AC38(a4, *v13, *v14++);
      }

      while (v14 != v10);
      ++v13;
    }

    while (v15 != v10);
  }

  else
  {
    sub_10169A860(v34, &v35, a3 + 1, a4);
  }

  if (v12 >= 0x80 && a3 <= 0x63 && (v42 - v41) >= 0x79)
  {
    sub_10169B23C(v34, &v35, &v41, a3 + 1, a4);
    goto LABEL_22;
  }

  v16 = v41;
  v17 = v42;
  if (v41 != v42)
  {
    v18 = v9;
    do
    {
      v19 = v16;
      do
      {
        sub_10169AC38(a4, *v18, *v19++);
      }

      while (v19 != v17);
      ++v18;
    }

    while (v18 != v10);
  }

  if (v12 >= 0x80)
  {
LABEL_22:
    if (a3 <= 0x63 && (v39 - v38) >= 0x79)
    {
      sub_10169B23C(v34, &v35, &v38, a3 + 1, a4);
      goto LABEL_30;
    }
  }

  v20 = v38;
  v21 = v39;
  if (v38 != v39)
  {
    v22 = v9;
    do
    {
      v23 = v20;
      do
      {
        sub_10169AC38(a4, *v22, *v23++);
      }

      while (v23 != v21);
      ++v22;
    }

    while (v22 != v10);
  }

LABEL_30:
  v24 = v41;
  v25 = v42;
  if (a3 > 0x63 || (v42 - v41) < 0x79)
  {
    if (v41 != v42)
    {
      v26 = v41;
      do
      {
        v27 = v26 + 1;
        if (v26 + 1 == v25)
        {
          break;
        }

        v28 = v26 + 1;
        do
        {
          sub_10169AC38(a4, *v26, *v28++);
        }

        while (v28 != v25);
        ++v26;
      }

      while (v27 != v25);
    }
  }

  else
  {
    sub_10169A860(&v46, &v41, a3 + 1, a4);
  }

  v29 = v38;
  v30 = v39;
  if (a3 > 0x63 || (v39 - v38) < 0x79)
  {
    if (v38 != v39)
    {
      v31 = v38;
      do
      {
        v32 = v31 + 1;
        if (v31 + 1 == v30)
        {
          break;
        }

        v33 = v31 + 1;
        do
        {
          sub_10169AC38(a4, *v31, *v33++);
        }

        while (v33 != v30);
        ++v31;
      }

      while (v32 != v30);
    }
  }

  else
  {
    sub_10169A860(v44, &v38, a3 + 1, a4);
  }

  if (v9)
  {
    operator delete(v9);
  }

  if (v29)
  {
    operator delete(v29);
  }

  if (v24)
  {

    operator delete(v24);
  }
}

void sub_10169B1E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20)
{
  if (v20)
  {
    operator delete(v20);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a20)
  {
    operator delete(a20);
  }

  _Unwind_Resume(exception_object);
}

void sub_10169B23C(double *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  v8 = (*a1 + a1[2]) * 0.5;
  v9 = *(a1 + 1);
  v71 = *a1;
  v73 = *(&v9 + 1);
  v69[1] = *(&v71 + 1);
  v70 = v9;
  v72 = v8;
  v69[0] = v8;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  __p = 0;
  v52 = 0;
  v53 = 0;
  sub_101693508(&v71, v69, a2, &v66, &v63, &v60);
  sub_101693508(&v71, v69, a3, &v57, &v54, &__p);
  v10 = v60;
  v11 = v61;
  v12 = __p;
  v48 = v60;
  if (v60 == v61)
  {
    v14 = v52;
  }

  else
  {
    v13 = v61 - v60;
    v14 = v52;
    if ((v61 - v60) < 0x80 || a4 > 0x63 || (v52 - __p) < 0x79)
    {
      if (__p != v52)
      {
        v15 = v60;
        do
        {
          v16 = v12;
          do
          {
            sub_10169AC38(a5, *v15, *v16++);
          }

          while (v16 != v14);
          ++v15;
        }

        while (v15 != v11);
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v17 = v60;
      do
      {
        sub_1016932F4(&v74, *v10++ + 2);
      }

      while (v10 != v11);
      v18 = v74;
      v19 = v75;
      if (v12 != v14)
      {
        v20 = v12;
        do
        {
          sub_1016932F4(&v74, *v20++ + 2);
        }

        while (v20 != v14);
        v18 = v74;
        v19 = v75;
      }

      v49 = v18;
      v50 = v19;
      sub_10169B858(v49.f64, &v60, &__p, a4 + 1, a5);
      v10 = v17;
    }

    v22 = v57;
    v21 = v58;
    if ((v58 - v57) < 0x80 || (v55 - v54) < 0x80 || a4 > 0x63 || v13 < 0x79)
    {
      if (v57 != v58)
      {
        v23 = v10;
        do
        {
          v24 = v22;
          do
          {
            sub_10169AC38(a5, *v23, *v24++);
          }

          while (v24 != v21);
          ++v23;
        }

        while (v23 != v11);
      }

      v25 = v54;
      v26 = v55;
      if (v54 != v55)
      {
        v27 = v10;
        do
        {
          v28 = v25;
          do
          {
            sub_10169AC38(a5, *v27, *v28++);
          }

          while (v28 != v26);
          ++v27;
        }

        while (v27 != v11);
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      do
      {
        sub_1016932F4(&v74, *v10++ + 2);
      }

      while (v10 != v11);
      v49 = v74;
      v50 = v75;
      sub_10169B858(v49.f64, &v60, &v57, a4 + 1, a5);
      sub_10169B858(v49.f64, &v60, &v54, a4 + 1, a5);
    }
  }

  v29 = v66;
  v30 = v67;
  v31 = v67 - v66;
  if (v12 != v14)
  {
    if (v31 < 0x80 || (v64 - v63) < 0x80 || a4 > 0x63 || (v14 - v12) < 0x79)
    {
      if (v66 != v67)
      {
        v32 = v66;
        do
        {
          v33 = v12;
          do
          {
            sub_10169AC38(a5, *v32, *v33++);
          }

          while (v33 != v14);
          ++v32;
        }

        while (v32 != v30);
      }

      v34 = v63;
      v35 = v64;
      while (v34 != v35)
      {
        v36 = v12;
        do
        {
          sub_10169AC38(a5, *v34, *v36++);
        }

        while (v36 != v14);
        ++v34;
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v37 = v12;
      do
      {
        sub_1016932F4(&v74, *v37++ + 2);
      }

      while (v37 != v14);
      v49 = v74;
      v50 = v75;
      sub_10169B858(v49.f64, &v66, &__p, a4 + 1, a5);
      sub_10169B858(v49.f64, &v63, &__p, a4 + 1, a5);
    }
  }

  if (v31 < 0x80 || a4 > 0x63 || (v58 - v57) < 0x79)
  {
    if (v29 != v30)
    {
      v38 = v57;
      v39 = v58;
      if (v57 != v58)
      {
        v40 = v29;
        do
        {
          v41 = v38;
          do
          {
            sub_10169AC38(a5, *v40, *v41++);
          }

          while (v41 != v39);
          ++v40;
        }

        while (v40 != v30);
      }
    }
  }

  else
  {
    sub_10169B858(&v71, &v66, &v57, a4 + 1, a5);
  }

  v42 = v63;
  v43 = v64;
  if ((v64 - v63) < 0x80 || a4 > 0x63 || (v55 - v54) < 0x79)
  {
    if (v63 != v64)
    {
      v44 = v54;
      v45 = v55;
      if (v54 != v55)
      {
        v46 = v63;
        do
        {
          v47 = v44;
          do
          {
            sub_10169AC38(a5, *v46, *v47++);
          }

          while (v47 != v45);
          ++v46;
        }

        while (v46 != v43);
      }
    }
  }

  else
  {
    sub_10169B858(v69, &v63, &v54, a4 + 1, a5);
  }

  if (v12)
  {
    operator delete(v12);
  }

  if (v54)
  {
    operator delete(v54);
  }

  if (v57)
  {
    operator delete(v57);
  }

  if (v48)
  {
    operator delete(v48);
  }

  if (v42)
  {
    operator delete(v42);
  }

  if (v29)
  {

    operator delete(v29);
  }
}

void sub_10169B7C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, void *a30)
{
  if (v30)
  {
    operator delete(v30);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a21)
  {
    operator delete(a21);
  }

  if (a24)
  {
    operator delete(a24);
  }

  if (a27)
  {
    operator delete(a27);
  }

  if (a30)
  {
    operator delete(a30);
  }

  _Unwind_Resume(exception_object);
}

void sub_10169B858(double *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  v8 = a1[1] + a1[3];
  v71 = *a1;
  v72 = *(a1 + 2);
  v9 = *(a1 + 1);
  *&v69[0] = v71;
  v70 = v9;
  v73 = v8 * 0.5;
  v69[1] = v8 * 0.5;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  __p = 0;
  v52 = 0;
  v53 = 0;
  sub_101693508(&v71, v69, a2, &v66, &v63, &v60);
  sub_101693508(&v71, v69, a3, &v57, &v54, &__p);
  v10 = v60;
  v11 = v61;
  v12 = __p;
  v48 = v60;
  if (v60 == v61)
  {
    v14 = v52;
  }

  else
  {
    v13 = v61 - v60;
    v14 = v52;
    if ((v61 - v60) < 0x80 || a4 > 0x63 || (v52 - __p) < 0x79)
    {
      if (__p != v52)
      {
        v15 = v60;
        do
        {
          v16 = v12;
          do
          {
            sub_10169AC38(a5, *v15, *v16++);
          }

          while (v16 != v14);
          ++v15;
        }

        while (v15 != v11);
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v17 = v60;
      do
      {
        sub_1016932F4(&v74, *v10++ + 2);
      }

      while (v10 != v11);
      v18 = v74;
      v19 = v75;
      if (v12 != v14)
      {
        v20 = v12;
        do
        {
          sub_1016932F4(&v74, *v20++ + 2);
        }

        while (v20 != v14);
        v18 = v74;
        v19 = v75;
      }

      v49 = v18;
      v50 = v19;
      sub_10169B23C(&v49, &v60, &__p, a4 + 1, a5);
      v10 = v17;
    }

    v22 = v57;
    v21 = v58;
    if ((v58 - v57) < 0x80 || (v55 - v54) < 0x80 || a4 > 0x63 || v13 < 0x79)
    {
      if (v57 != v58)
      {
        v23 = v10;
        do
        {
          v24 = v22;
          do
          {
            sub_10169AC38(a5, *v23, *v24++);
          }

          while (v24 != v21);
          ++v23;
        }

        while (v23 != v11);
      }

      v25 = v54;
      v26 = v55;
      if (v54 != v55)
      {
        v27 = v10;
        do
        {
          v28 = v25;
          do
          {
            sub_10169AC38(a5, *v27, *v28++);
          }

          while (v28 != v26);
          ++v27;
        }

        while (v27 != v11);
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      do
      {
        sub_1016932F4(&v74, *v10++ + 2);
      }

      while (v10 != v11);
      v49 = v74;
      v50 = v75;
      sub_10169B23C(&v49, &v60, &v57, a4 + 1, a5);
      sub_10169B23C(&v49, &v60, &v54, a4 + 1, a5);
    }
  }

  v29 = v66;
  v30 = v67;
  v31 = v67 - v66;
  if (v12 != v14)
  {
    if (v31 < 0x80 || (v64 - v63) < 0x80 || a4 > 0x63 || (v14 - v12) < 0x79)
    {
      if (v66 != v67)
      {
        v32 = v66;
        do
        {
          v33 = v12;
          do
          {
            sub_10169AC38(a5, *v32, *v33++);
          }

          while (v33 != v14);
          ++v32;
        }

        while (v32 != v30);
      }

      v34 = v63;
      v35 = v64;
      while (v34 != v35)
      {
        v36 = v12;
        do
        {
          sub_10169AC38(a5, *v34, *v36++);
        }

        while (v36 != v14);
        ++v34;
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v37 = v12;
      do
      {
        sub_1016932F4(&v74, *v37++ + 2);
      }

      while (v37 != v14);
      v49 = v74;
      v50 = v75;
      sub_10169B23C(&v49, &v66, &__p, a4 + 1, a5);
      sub_10169B23C(&v49, &v63, &__p, a4 + 1, a5);
    }
  }

  if (v31 < 0x80 || a4 > 0x63 || (v58 - v57) < 0x79)
  {
    if (v29 != v30)
    {
      v38 = v57;
      v39 = v58;
      if (v57 != v58)
      {
        v40 = v29;
        do
        {
          v41 = v38;
          do
          {
            sub_10169AC38(a5, *v40, *v41++);
          }

          while (v41 != v39);
          ++v40;
        }

        while (v40 != v30);
      }
    }
  }

  else
  {
    sub_10169B23C(&v71, &v66, &v57, a4 + 1, a5);
  }

  v42 = v63;
  v43 = v64;
  if ((v64 - v63) < 0x80 || a4 > 0x63 || (v55 - v54) < 0x79)
  {
    if (v63 != v64)
    {
      v44 = v54;
      v45 = v55;
      if (v54 != v55)
      {
        v46 = v63;
        do
        {
          v47 = v44;
          do
          {
            sub_10169AC38(a5, *v46, *v47++);
          }

          while (v47 != v45);
          ++v46;
        }

        while (v46 != v43);
      }
    }
  }

  else
  {
    sub_10169B23C(v69, &v63, &v54, a4 + 1, a5);
  }

  if (v12)
  {
    operator delete(v12);
  }

  if (v54)
  {
    operator delete(v54);
  }

  if (v57)
  {
    operator delete(v57);
  }

  if (v48)
  {
    operator delete(v48);
  }

  if (v42)
  {
    operator delete(v42);
  }

  if (v29)
  {

    operator delete(v29);
  }
}

void sub_10169BDEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, void *a30)
{
  if (v30)
  {
    operator delete(v30);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a21)
  {
    operator delete(a21);
  }

  if (a24)
  {
    operator delete(a24);
  }

  if (a27)
  {
    operator delete(a27);
  }

  if (a30)
  {
    operator delete(a30);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10169BE80(void *a1, void *a2, void *a3)
{
  if (*a3 != *a2)
  {
    __assert_rtn("segment_distance", "get_ring.hpp", 149, "second.source_index == first.source_index");
  }

  if (a3[1] != a2[1])
  {
    __assert_rtn("segment_distance", "get_ring.hpp", 150, "second.multi_index == first.multi_index");
  }

  v3 = a3[2];
  if (v3 != a2[2])
  {
    __assert_rtn("segment_distance", "get_ring.hpp", 151, "second.ring_index == first.ring_index");
  }

  v4 = a3[3];
  v5 = a2[3];
  v6 = v4 < v5;
  v7 = v4 - v5;
  if (v6)
  {
    if (v3 < -1 || (v8 = a1[3], v9 = 0xAAAAAAAAAAAAAAABLL * ((a1[4] - v8) >> 3), v3 >= v9))
    {
      __assert_rtn("apply", "get_ring.hpp", 94, "id.ring_index >= -1 && id.ring_index < int(boost::size(interior_rings(polygon)))");
    }

    if ((v3 & 0x8000000000000000) == 0)
    {
      if (v9 < v3)
      {
        __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
      }

      a1 = (v8 + 24 * v3);
    }

    return v7 + ((a1[1] - *a1) >> 4) - 1;
  }

  return v7;
}

void sub_10169BFC4(void *a1)
{
  if (a1)
  {
    sub_10169BFC4(*a1);
    sub_10169BFC4(a1[1]);
    v2 = a1[6];
    if (v2)
    {
      a1[7] = v2;
      operator delete(v2);
    }

    operator delete(a1);
  }
}

__n128 sub_10169C020(uint64_t a1, unint64_t a2, uint64_t a3, char a4, __n128 result)
{
LABEL_1:
  v9 = (a2 - 24);
  v10 = (a2 - 48);
  v11 = (a2 - 72);
  v12 = a1;
  while (1)
  {
    a1 = v12;
    v13 = a2 - v12;
    v14 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v12) >> 3);
    if (v14 <= 2)
    {
      if (v14 < 2)
      {
        return result;
      }

      if (v14 == 2)
      {
        result.n128_u64[0] = *(a2 - 8);
        if (result.n128_f64[0] > *(v12 + 16))
        {
          v192 = *(v12 + 16);
          v162 = *v12;
          v86 = *(a2 - 24);
          *(v12 + 16) = *(a2 - 8);
          *v12 = v86;
          result = v162;
          *(a2 - 8) = v192;
          *(a2 - 24) = v162;
        }

        return result;
      }

      goto LABEL_9;
    }

    if (v14 == 3)
    {
      break;
    }

    if (v14 == 4)
    {
      v90 = *(v12 + 40);
      v91 = *(v12 + 64);
      if (v90 <= *(v12 + 16))
      {
        if (v91 > v90)
        {
          v132 = *(v12 + 40);
          result = *(v12 + 24);
          *(v12 + 24) = *(v12 + 48);
          *(v12 + 40) = *(v12 + 64);
          *(v12 + 48) = result;
          *(v12 + 64) = v132;
          if (*(v12 + 40) > *(v12 + 16))
          {
            v196 = *(v12 + 16);
            v168 = *v12;
            *v12 = *(v12 + 24);
            *(v12 + 16) = *(v12 + 40);
            result.n128_u64[1] = v168.n128_u64[1];
            *(v12 + 24) = v168;
            *(v12 + 40) = v196;
          }
        }
      }

      else
      {
        if (v91 > v90)
        {
          v194 = *(v12 + 16);
          v164 = *v12;
          *v12 = *(v12 + 48);
          *(v12 + 16) = *(v12 + 64);
          result.n128_u64[1] = v164.n128_u64[1];
          *(v12 + 48) = v164;
          v92 = v194;
          goto LABEL_183;
        }

        v198 = *(v12 + 16);
        v171 = *v12;
        *v12 = *(v12 + 24);
        *(v12 + 16) = *(v12 + 40);
        *(v12 + 24) = v171;
        *(v12 + 40) = v198;
        if (v91 > *(v12 + 40))
        {
          v92 = *(v12 + 40);
          result = *(v12 + 24);
          *(v12 + 24) = *(v12 + 48);
          *(v12 + 40) = *(v12 + 64);
          *(v12 + 48) = result;
LABEL_183:
          *(v12 + 64) = v92;
        }
      }

      result.n128_u64[0] = *(a2 - 8);
      if (result.n128_f64[0] <= *(v12 + 64))
      {
        return result;
      }

      result = *(v12 + 48);
      v137 = *(v12 + 64);
      v138 = *(a2 - 8);
      *(v12 + 48) = *v9;
      *(v12 + 64) = v138;
      *(a2 - 8) = v137;
      *v9 = result;
      result.n128_u64[0] = *(v12 + 64);
      if (result.n128_f64[0] <= *(v12 + 40))
      {
        return result;
      }

      v139 = *(v12 + 40);
      result = *(v12 + 24);
      *(v12 + 24) = *(v12 + 48);
      *(v12 + 40) = *(v12 + 64);
      *(v12 + 48) = result;
      *(v12 + 64) = v139;
LABEL_187:
      result.n128_u64[0] = *(v12 + 40);
      if (result.n128_f64[0] > *(v12 + 16))
      {
        v199 = *(v12 + 16);
        v172 = *v12;
        *v12 = *(v12 + 24);
        *(v12 + 16) = *(v12 + 40);
        result = v172;
        *(v12 + 24) = v172;
        *(v12 + 40) = v199;
      }

      return result;
    }

    if (v14 == 5)
    {

      result.n128_u64[0] = sub_10169D014(v12, (v12 + 24), (v12 + 48), (v12 + 72), (a2 - 24), result).n128_u64[0];
      return result;
    }

LABEL_9:
    if (v13 <= 575)
    {
      v93 = (v12 + 24);
      v95 = v12 == a2 || v93 == a2;
      if (a4)
      {
        if (!v95)
        {
          v96 = 0;
          v97 = v12;
          do
          {
            result.n128_u64[0] = *(v97 + 5);
            v98 = *(v97 + 2);
            v97 = v93;
            if (result.n128_f64[0] > v98)
            {
              v165 = *v93;
              v99 = v96;
              while (1)
              {
                v100 = v12 + v99;
                *(v100 + 24) = *(v12 + v99);
                *(v100 + 40) = *(v12 + v99 + 16);
                if (!v99)
                {
                  break;
                }

                v99 -= 24;
                if (result.n128_f64[0] <= *(v100 - 8))
                {
                  v101 = v12 + v99 + 24;
                  goto LABEL_129;
                }
              }

              v101 = v12;
LABEL_129:
              *v101 = v165;
              *(v101 + 16) = result.n128_u64[0];
            }

            v93 = (v97 + 24);
            v96 += 24;
          }

          while ((v97 + 24) != a2);
        }
      }

      else if (!v95)
      {
        do
        {
          result.n128_u64[0] = *(a1 + 40);
          v133 = *(a1 + 16);
          a1 = v93;
          if (result.n128_f64[0] > v133)
          {
            v169 = *v93;
            v134 = v93;
            do
            {
              *v134 = *(v134 - 24);
              *(v134 + 2) = *(v134 - 1);
              v135 = *(v134 - 4);
              v134 = (v134 - 24);
            }

            while (result.n128_f64[0] > v135);
            *v134 = v169;
            *(v134 + 2) = result.n128_u64[0];
          }

          v93 = (v93 + 24);
        }

        while (a1 + 24 != a2);
      }

      return result;
    }

    if (!a3)
    {
      if (v12 != a2)
      {
        v102 = (v14 - 2) >> 1;
        v103 = v102;
        do
        {
          v104 = v103;
          if (v102 >= v103)
          {
            v105 = (2 * v103) | 1;
            v106 = v12 + 24 * v105;
            if (2 * v104 + 2 < v14 && *(v106 + 16) > *(v106 + 40))
            {
              v106 += 24;
              v105 = 2 * v104 + 2;
            }

            v107 = v12 + 24 * v104;
            v108 = *(v107 + 16);
            if (*(v106 + 16) <= v108)
            {
              v166 = *v107;
              do
              {
                v109 = v106;
                v110 = *v106;
                *(v107 + 16) = *(v106 + 16);
                *v107 = v110;
                if (v102 < v105)
                {
                  break;
                }

                v111 = 2 * v105;
                v105 = (2 * v105) | 1;
                v106 = v12 + 24 * v105;
                v112 = v111 + 2;
                if (v112 < v14 && *(v106 + 16) > *(v106 + 40))
                {
                  v106 += 24;
                  v105 = v112;
                }

                v107 = v109;
              }

              while (*(v106 + 16) <= v108);
              *v109 = v166;
              *(v109 + 16) = v108;
            }
          }

          v103 = v104 - 1;
        }

        while (v104);
        v113 = 0xAAAAAAAAAAAAAAABLL * (v13 >> 3);
        do
        {
          v114 = 0;
          v195 = *(v12 + 16);
          v167 = *v12;
          v115 = v12;
          do
          {
            v116 = v115 + 24 * v114;
            v117 = (v116 + 24);
            v118 = (2 * v114) | 1;
            v114 = 2 * v114 + 2;
            if (v114 >= v113)
            {
              v114 = v118;
            }

            else
            {
              v119 = *(v116 + 40);
              v120 = *(v116 + 64);
              v121 = (v116 + 48);
              if (v119 <= v120)
              {
                v114 = v118;
              }

              else
              {
                v117 = v121;
              }
            }

            v122 = *v117;
            *(v115 + 16) = v117[1].n128_u64[0];
            *v115 = v122;
            v115 = v117;
          }

          while (v114 <= ((v113 - 2) >> 1));
          a2 -= 24;
          if (v117 == a2)
          {
            result = v167;
            v117[1].n128_u64[0] = v195;
            *v117 = v167;
          }

          else
          {
            v123 = *a2;
            v117[1].n128_u64[0] = *(a2 + 16);
            *v117 = v123;
            result = v167;
            *(a2 + 16) = v195;
            *a2 = v167;
            v124 = &v117[1].n128_i64[1] - v12;
            if (v124 >= 25)
            {
              v125 = (-2 - 0x5555555555555555 * (v124 >> 3)) >> 1;
              v126 = v12 + 24 * v125;
              result.n128_u64[0] = v117[1].n128_u64[0];
              if (*(v126 + 16) > result.n128_f64[0])
              {
                v142 = *v117;
                do
                {
                  v127 = v126;
                  v128 = *v126;
                  v117[1].n128_u64[0] = *(v126 + 16);
                  *v117 = v128;
                  if (!v125)
                  {
                    break;
                  }

                  v125 = (v125 - 1) >> 1;
                  v126 = v12 + 24 * v125;
                  v117 = v127;
                }

                while (*(v126 + 16) > result.n128_f64[0]);
                *v127 = v142;
                *(v127 + 16) = result.n128_u64[0];
              }
            }
          }
        }

        while (v113-- > 2);
      }

      return result;
    }

    v15 = v14 >> 1;
    v16 = (v12 + 24 * (v14 >> 1));
    v17 = *(a2 - 8);
    if (v13 >= 0xC01)
    {
      v18 = v16[1].n128_f64[0];
      if (v18 <= *(v12 + 16))
      {
        if (v17 > v18)
        {
          v175 = v16[1].n128_u64[0];
          v145 = *v16;
          v22 = *v9;
          v16[1].n128_u64[0] = *(a2 - 8);
          *v16 = v22;
          *(a2 - 8) = v175;
          *v9 = v145;
          if (v16[1].n128_f64[0] > *(v12 + 16))
          {
            v176 = *(v12 + 16);
            v146 = *v12;
            v23 = *v16;
            *(v12 + 16) = v16[1].n128_u64[0];
            *v12 = v23;
            v16[1].n128_u64[0] = v176;
            *v16 = v146;
          }
        }
      }

      else
      {
        if (v17 > v18)
        {
          v173 = *(v12 + 16);
          v143 = *v12;
          v19 = *v9;
          *(v12 + 16) = *(a2 - 8);
          *v12 = v19;
          goto LABEL_26;
        }

        v179 = *(v12 + 16);
        v149 = *v12;
        v24 = *v16;
        *(v12 + 16) = v16[1].n128_u64[0];
        *v12 = v24;
        v16[1].n128_u64[0] = v179;
        *v16 = v149;
        if (*(a2 - 8) > v16[1].n128_f64[0])
        {
          v173 = v16[1].n128_u64[0];
          v143 = *v16;
          v25 = *v9;
          v16[1].n128_u64[0] = *(a2 - 8);
          *v16 = v25;
LABEL_26:
          *(a2 - 8) = v173;
          *v9 = v143;
        }
      }

      v26 = v12 + 24 * v15;
      v27 = (v26 - 24);
      v28 = *(v26 - 8);
      v29 = *(a2 - 32);
      if (v28 <= *(v12 + 40))
      {
        if (v29 > v28)
        {
          v180 = *(v26 - 8);
          v150 = *v27;
          v33 = *v10;
          *(v26 - 8) = *(a2 - 32);
          *v27 = v33;
          *(a2 - 32) = v180;
          *v10 = v150;
          if (*(v26 - 8) > *(v12 + 40))
          {
            v34 = *(v12 + 24);
            v35 = *(v12 + 40);
            v36 = v27[1].n128_i64[0];
            *(v12 + 24) = *v27;
            *(v12 + 40) = v36;
            v27[1].n128_u64[0] = v35;
            *v27 = v34;
          }
        }
      }

      else
      {
        if (v29 > v28)
        {
          v30 = *(v12 + 24);
          v31 = *(v12 + 40);
          v32 = *(a2 - 32);
          *(v12 + 24) = *v10;
          *(v12 + 40) = v32;
          goto LABEL_38;
        }

        v38 = *(v12 + 24);
        v39 = *(v12 + 40);
        v40 = v27[1].n128_i64[0];
        *(v12 + 24) = *v27;
        *(v12 + 40) = v40;
        v27[1].n128_u64[0] = v39;
        *v27 = v38;
        if (*(a2 - 32) > v27[1].n128_f64[0])
        {
          v182 = v27[1].n128_i64[0];
          v152 = *v27;
          v41 = *v10;
          v27[1].n128_u64[0] = *(a2 - 32);
          *v27 = v41;
          v30 = v152;
          v31 = v182;
LABEL_38:
          *(a2 - 32) = v31;
          *v10 = v30;
        }
      }

      v42 = v12 + 24 * v15;
      v43 = *(v42 + 40);
      v44 = *(a2 - 56);
      if (v43 <= *(v12 + 64))
      {
        if (v44 > v43)
        {
          v183 = *(v42 + 40);
          v153 = *(v42 + 24);
          v48 = *v11;
          *(v42 + 40) = *(a2 - 56);
          *(v42 + 24) = v48;
          *(a2 - 56) = v183;
          *v11 = v153;
          if (*(v42 + 40) > *(v12 + 64))
          {
            v49 = *(v12 + 48);
            v50 = *(v12 + 64);
            v51 = *(v42 + 40);
            *(v12 + 48) = *(v42 + 24);
            *(v12 + 64) = v51;
            *(v42 + 40) = v50;
            *(v42 + 24) = v49;
          }
        }
      }

      else
      {
        if (v44 > v43)
        {
          v45 = *(v12 + 48);
          v46 = *(v12 + 64);
          v47 = *(a2 - 56);
          *(v12 + 48) = *v11;
          *(v12 + 64) = v47;
          goto LABEL_47;
        }

        v52 = *(v12 + 48);
        v53 = *(v12 + 64);
        v54 = *(v42 + 40);
        *(v12 + 48) = *(v42 + 24);
        *(v12 + 64) = v54;
        *(v42 + 40) = v53;
        *(v42 + 24) = v52;
        if (*(a2 - 56) > *(v42 + 40))
        {
          v184 = *(v42 + 40);
          v154 = *(v42 + 24);
          v55 = *v11;
          *(v42 + 40) = *(a2 - 56);
          *(v42 + 24) = v55;
          v45 = v154;
          v46 = v184;
LABEL_47:
          *(a2 - 56) = v46;
          *v11 = v45;
        }
      }

      v56 = v16[1].n128_f64[0];
      v57 = *(v42 + 40);
      if (v56 <= v27[1].n128_f64[0])
      {
        if (v57 > v56)
        {
          v186 = v16[1].n128_u64[0];
          v156 = *v16;
          *v16 = *(v42 + 24);
          v16[1].n128_u64[0] = *(v42 + 40);
          *(v42 + 40) = v186;
          *(v42 + 24) = v156;
          if (v16[1].n128_f64[0] > v27[1].n128_f64[0])
          {
            v187 = v27[1].n128_u64[0];
            v157 = *v27;
            *v27 = *v16;
            v27[1].n128_u64[0] = v16[1].n128_u64[0];
            v16[1].n128_u64[0] = v187;
            *v16 = v157;
          }
        }
      }

      else
      {
        if (v57 > v56)
        {
          v185 = v27[1].n128_u64[0];
          v155 = *v27;
          *v27 = *(v42 + 24);
          v27[1].n128_u64[0] = *(v42 + 40);
          goto LABEL_56;
        }

        v188 = v27[1].n128_u64[0];
        v158 = *v27;
        *v27 = *v16;
        v27[1].n128_u64[0] = v16[1].n128_u64[0];
        v16[1].n128_u64[0] = v188;
        *v16 = v158;
        if (*(v42 + 40) > v16[1].n128_f64[0])
        {
          v185 = v16[1].n128_u64[0];
          v155 = *v16;
          *v16 = *(v42 + 24);
          v16[1].n128_u64[0] = *(v42 + 40);
LABEL_56:
          *(v42 + 40) = v185;
          *(v42 + 24) = v155;
        }
      }

      v189 = *(v12 + 16);
      v159 = *v12;
      result = *v16;
      *(v12 + 16) = v16[1].n128_u64[0];
      *v12 = result;
      result.n128_u64[1] = v159.n128_u64[1];
      v16[1].n128_u64[0] = v189;
      *v16 = v159;
      goto LABEL_58;
    }

    v20 = *(v12 + 16);
    if (v20 <= v16[1].n128_f64[0])
    {
      if (v17 > v20)
      {
        v177 = *(v12 + 16);
        v147 = *v12;
        result = *v9;
        *(v12 + 16) = *(a2 - 8);
        *v12 = result;
        result.n128_u64[1] = v147.n128_u64[1];
        *(a2 - 8) = v177;
        *v9 = v147;
        if (*(v12 + 16) > v16[1].n128_f64[0])
        {
          v178 = v16[1].n128_u64[0];
          v148 = *v16;
          result = *v12;
          v16[1].n128_u64[0] = *(v12 + 16);
          *v16 = result;
          result.n128_u64[1] = v148.n128_u64[1];
          *(v12 + 16) = v178;
          *v12 = v148;
        }
      }

      goto LABEL_58;
    }

    if (v17 > v20)
    {
      v174 = v16[1].n128_u64[0];
      v144 = *v16;
      v21 = *v9;
      v16[1].n128_u64[0] = *(a2 - 8);
      *v16 = v21;
LABEL_35:
      result.n128_u64[1] = v144.n128_u64[1];
      *(a2 - 8) = v174;
      *v9 = v144;
      goto LABEL_58;
    }

    v181 = v16[1].n128_u64[0];
    v151 = *v16;
    result = *v12;
    v16[1].n128_u64[0] = *(v12 + 16);
    *v16 = result;
    result.n128_u64[1] = v151.n128_u64[1];
    *(v12 + 16) = v181;
    *v12 = v151;
    if (*(a2 - 8) > *(v12 + 16))
    {
      v174 = *(v12 + 16);
      v144 = *v12;
      v37 = *v9;
      *(v12 + 16) = *(a2 - 8);
      *v12 = v37;
      goto LABEL_35;
    }

LABEL_58:
    --a3;
    if (a4)
    {
      result.n128_u64[0] = *(v12 + 16);
LABEL_61:
      v58 = 0;
      v140 = *v12;
      do
      {
        v59 = *(v12 + v58 + 40);
        v58 += 24;
      }

      while (v59 > result.n128_f64[0]);
      v60 = v12 + v58;
      v61 = a2;
      if (v58 == 24)
      {
        v64 = a2;
        while (v60 < v64)
        {
          v62 = v64 - 24;
          v65 = *(v64 - 8);
          v64 -= 24;
          if (v65 > result.n128_f64[0])
          {
            goto LABEL_71;
          }
        }

        v62 = v64;
      }

      else
      {
        do
        {
          v62 = v61 - 24;
          v63 = *(v61 - 8);
          v61 -= 24;
        }

        while (v63 <= result.n128_f64[0]);
      }

LABEL_71:
      v12 = v60;
      if (v60 < v62)
      {
        v66 = v62;
        do
        {
          v190 = *(v12 + 16);
          v160 = *v12;
          v67 = *v66;
          *(v12 + 16) = *(v66 + 16);
          *v12 = v67;
          *(v66 + 16) = v190;
          *v66 = v160;
          do
          {
            v68 = *(v12 + 40);
            v12 += 24;
          }

          while (v68 > result.n128_f64[0]);
          do
          {
            v69 = *(v66 - 8);
            v66 -= 24;
          }

          while (v69 <= result.n128_f64[0]);
        }

        while (v12 < v66);
      }

      v70 = (v12 - 24);
      if (v12 - 24 != a1)
      {
        v71 = *v70;
        *(a1 + 16) = *(v12 - 8);
        *a1 = v71;
      }

      *v70 = v140;
      *(v12 - 8) = result.n128_u64[0];
      if (v60 < v62)
      {
        goto LABEL_82;
      }

      v72 = sub_10169D25C(a1, v12 - 24, result);
      if (sub_10169D25C(v12, a2, v73))
      {
        a2 = v12 - 24;
        if (!v72)
        {
          goto LABEL_1;
        }

        return result;
      }

      if (!v72)
      {
LABEL_82:
        sub_10169C020(a1, v12 - 24, a3, a4 & 1);
        a4 = 0;
      }
    }

    else
    {
      result.n128_u64[0] = *(v12 + 16);
      if (*(v12 - 8) > result.n128_f64[0])
      {
        goto LABEL_61;
      }

      v141 = *v12;
      if (result.n128_f64[0] <= *(a2 - 8))
      {
        v76 = v12 + 24;
        do
        {
          v12 = v76;
          if (v76 >= a2)
          {
            break;
          }

          v77 = *(v76 + 16);
          v76 += 24;
        }

        while (result.n128_f64[0] <= v77);
      }

      else
      {
        v74 = v12;
        do
        {
          v12 = v74 + 24;
          v75 = *(v74 + 40);
          v74 += 24;
        }

        while (result.n128_f64[0] <= v75);
      }

      v78 = a2;
      if (v12 < a2)
      {
        v79 = a2;
        do
        {
          v78 = v79 - 24;
          v80 = *(v79 - 8);
          v79 -= 24;
        }

        while (result.n128_f64[0] > v80);
      }

      while (v12 < v78)
      {
        v191 = *(v12 + 16);
        v161 = *v12;
        v81 = *v78;
        *(v12 + 16) = *(v78 + 16);
        *v12 = v81;
        *(v78 + 16) = v191;
        *v78 = v161;
        do
        {
          v82 = *(v12 + 40);
          v12 += 24;
        }

        while (result.n128_f64[0] <= v82);
        do
        {
          v83 = *(v78 - 8);
          v78 -= 24;
        }

        while (result.n128_f64[0] > v83);
      }

      v84 = (v12 - 24);
      if (v12 - 24 != a1)
      {
        v85 = *v84;
        *(a1 + 16) = *(v12 - 8);
        *a1 = v85;
      }

      a4 = 0;
      *v84 = v141;
      *(v12 - 8) = result.n128_u64[0];
    }
  }

  result.n128_u64[0] = *(v12 + 40);
  v87 = *(a2 - 8);
  if (result.n128_f64[0] <= *(v12 + 16))
  {
    if (v87 <= result.n128_f64[0])
    {
      return result;
    }

    result = *(v12 + 24);
    v130 = *(v12 + 40);
    v131 = *(a2 - 8);
    *(v12 + 24) = *v9;
    *(v12 + 40) = v131;
    *(a2 - 8) = v130;
    *v9 = result;
    goto LABEL_187;
  }

  if (v87 <= result.n128_f64[0])
  {
    v197 = *(v12 + 16);
    v170 = *v12;
    *v12 = *(v12 + 24);
    *(v12 + 16) = *(v12 + 40);
    result.n128_u64[1] = v170.n128_u64[1];
    *(v12 + 24) = v170;
    *(v12 + 40) = v197;
    result.n128_u64[0] = *(a2 - 8);
    if (result.n128_f64[0] <= *(v12 + 40))
    {
      return result;
    }

    result = *(v12 + 24);
    v89 = *(v12 + 40);
    v136 = *(a2 - 8);
    *(v12 + 24) = *v9;
    *(v12 + 40) = v136;
  }

  else
  {
    v193 = *(v12 + 16);
    v163 = *v12;
    v88 = *v9;
    *(v12 + 16) = *(a2 - 8);
    *v12 = v88;
    result = v163;
    v89 = v193;
  }

  *(a2 - 8) = v89;
  *v9 = result;
  return result;
}

__n128 sub_10169D014(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5, __n128 result)
{
  v6 = a2[1].n128_f64[0];
  v7 = a3[1].n128_f64[0];
  if (v6 <= a1[1].n128_f64[0])
  {
    if (v7 > v6)
    {
      v10 = a2[1].n128_u64[0];
      result = *a2;
      v11 = a3[1].n128_u64[0];
      *a2 = *a3;
      a2[1].n128_u64[0] = v11;
      *a3 = result;
      a3[1].n128_u64[0] = v10;
      if (a2[1].n128_f64[0] > a1[1].n128_f64[0])
      {
        v12 = a1[1].n128_u64[0];
        result = *a1;
        v13 = a2[1].n128_u64[0];
        *a1 = *a2;
        a1[1].n128_u64[0] = v13;
        *a2 = result;
        a2[1].n128_u64[0] = v12;
      }
    }
  }

  else
  {
    if (v7 > v6)
    {
      v8 = a1[1].n128_u64[0];
      result = *a1;
      v9 = a3[1].n128_u64[0];
      *a1 = *a3;
      a1[1].n128_u64[0] = v9;
LABEL_9:
      *a3 = result;
      a3[1].n128_u64[0] = v8;
      goto LABEL_10;
    }

    v14 = a1[1].n128_u64[0];
    result = *a1;
    v15 = a2[1].n128_u64[0];
    *a1 = *a2;
    a1[1].n128_u64[0] = v15;
    *a2 = result;
    a2[1].n128_u64[0] = v14;
    if (a3[1].n128_f64[0] > a2[1].n128_f64[0])
    {
      v8 = a2[1].n128_u64[0];
      result = *a2;
      v16 = a3[1].n128_u64[0];
      *a2 = *a3;
      a2[1].n128_u64[0] = v16;
      goto LABEL_9;
    }
  }

LABEL_10:
  if (a4[1].n128_f64[0] > a3[1].n128_f64[0])
  {
    v17 = a3[1].n128_u64[0];
    result = *a3;
    v18 = a4[1].n128_u64[0];
    *a3 = *a4;
    a3[1].n128_u64[0] = v18;
    *a4 = result;
    a4[1].n128_u64[0] = v17;
    if (a3[1].n128_f64[0] > a2[1].n128_f64[0])
    {
      v19 = a2[1].n128_u64[0];
      result = *a2;
      v20 = a3[1].n128_u64[0];
      *a2 = *a3;
      a2[1].n128_u64[0] = v20;
      *a3 = result;
      a3[1].n128_u64[0] = v19;
      if (a2[1].n128_f64[0] > a1[1].n128_f64[0])
      {
        v21 = a1[1].n128_u64[0];
        result = *a1;
        v22 = a2[1].n128_u64[0];
        *a1 = *a2;
        a1[1].n128_u64[0] = v22;
        *a2 = result;
        a2[1].n128_u64[0] = v21;
      }
    }
  }

  result.n128_u64[0] = a5[1].n128_u64[0];
  if (result.n128_f64[0] > a4[1].n128_f64[0])
  {
    v23 = a4[1].n128_i64[0];
    result = *a4;
    v24 = a5[1].n128_u64[0];
    *a4 = *a5;
    a4[1].n128_u64[0] = v24;
    *a5 = result;
    a5[1].n128_u64[0] = v23;
    result.n128_u64[0] = a4[1].n128_u64[0];
    if (result.n128_f64[0] > a3[1].n128_f64[0])
    {
      v25 = a3[1].n128_u64[0];
      result = *a3;
      v26 = a4[1].n128_u64[0];
      *a3 = *a4;
      a3[1].n128_u64[0] = v26;
      *a4 = result;
      a4[1].n128_u64[0] = v25;
      result.n128_u64[0] = a3[1].n128_u64[0];
      if (result.n128_f64[0] > a2[1].n128_f64[0])
      {
        v27 = a2[1].n128_u64[0];
        result = *a2;
        v28 = a3[1].n128_u64[0];
        *a2 = *a3;
        a2[1].n128_u64[0] = v28;
        *a3 = result;
        a3[1].n128_u64[0] = v27;
        result.n128_u64[0] = a2[1].n128_u64[0];
        if (result.n128_f64[0] > a1[1].n128_f64[0])
        {
          v29 = a1[1].n128_u64[0];
          result = *a1;
          v30 = a2[1].n128_u64[0];
          *a1 = *a2;
          a1[1].n128_u64[0] = v30;
          *a2 = result;
          a2[1].n128_u64[0] = v29;
        }
      }
    }
  }

  return result;
}

BOOL sub_10169D25C(uint64_t a1, uint64_t a2, __n128 a3)
{
  v3 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  if (v3 > 2)
  {
    if (v3 == 3)
    {
      v7 = (a2 - 24);
      v8 = *(a1 + 40);
      v9 = *(a2 - 8);
      if (v8 > *(a1 + 16))
      {
        if (v9 <= v8)
        {
          v35 = *(a1 + 16);
          v36 = *a1;
          *a1 = *(a1 + 24);
          *(a1 + 16) = *(a1 + 40);
          *(a1 + 24) = v36;
          *(a1 + 40) = v35;
          if (*(a2 - 8) <= *(a1 + 40))
          {
            return 1;
          }

          v10 = *(a1 + 40);
          v11 = *(a1 + 24);
          v37 = *(a2 - 8);
          *(a1 + 24) = *v7;
          *(a1 + 40) = v37;
        }

        else
        {
          v10 = *(a1 + 16);
          v11 = *a1;
          v12 = *(a2 - 8);
          *a1 = *v7;
          *(a1 + 16) = v12;
        }

        *v7 = v11;
        *(a2 - 8) = v10;
        return 1;
      }

      if (v9 <= v8)
      {
        return 1;
      }

      v24 = *(a1 + 40);
      v25 = *(a1 + 24);
      v26 = *(a2 - 8);
      *(a1 + 24) = *v7;
      *(a1 + 40) = v26;
      *v7 = v25;
      *(a2 - 8) = v24;
LABEL_50:
      if (*(a1 + 40) > *(a1 + 16))
      {
        v55 = *(a1 + 16);
        v56 = *a1;
        *a1 = *(a1 + 24);
        *(a1 + 16) = *(a1 + 40);
        *(a1 + 24) = v56;
        *(a1 + 40) = v55;
      }

      return 1;
    }

    if (v3 != 4)
    {
      if (v3 != 5)
      {
        goto LABEL_13;
      }

      sub_10169D014(a1, (a1 + 24), (a1 + 48), (a1 + 72), (a2 - 24), a3);
      return 1;
    }

    v19 = *(a1 + 40);
    v20 = *(a1 + 16);
    v21 = *(a1 + 64);
    if (v19 <= v20)
    {
      if (v21 > v19)
      {
        v31 = *(a1 + 40);
        v32 = *(a1 + 24);
        *(a1 + 24) = *(a1 + 48);
        *(a1 + 40) = *(a1 + 64);
        *(a1 + 48) = v32;
        *(a1 + 64) = v31;
        if (*(a1 + 40) > v20)
        {
          v33 = *(a1 + 16);
          v34 = *a1;
          *a1 = *(a1 + 24);
          *(a1 + 16) = *(a1 + 40);
          *(a1 + 24) = v34;
          *(a1 + 40) = v33;
        }
      }

      goto LABEL_47;
    }

    if (v21 <= v19)
    {
      v47 = *(a1 + 16);
      v48 = *a1;
      *a1 = *(a1 + 24);
      *(a1 + 16) = *(a1 + 40);
      *(a1 + 24) = v48;
      *(a1 + 40) = v47;
      if (v21 <= *(a1 + 40))
      {
        goto LABEL_47;
      }

      v22 = *(a1 + 40);
      v23 = *(a1 + 24);
      *(a1 + 24) = *(a1 + 48);
      *(a1 + 40) = *(a1 + 64);
    }

    else
    {
      v22 = *(a1 + 16);
      v23 = *a1;
      *a1 = *(a1 + 48);
      *(a1 + 16) = *(a1 + 64);
    }

    *(a1 + 48) = v23;
    *(a1 + 64) = v22;
LABEL_47:
    if (*(a2 - 8) <= *(a1 + 64))
    {
      return 1;
    }

    v49 = a2 - 24;
    v50 = *(a1 + 64);
    v51 = *(a1 + 48);
    v52 = *(a2 - 8);
    *(a1 + 48) = *(a2 - 24);
    *(a1 + 64) = v52;
    *v49 = v51;
    *(v49 + 16) = v50;
    if (*(a1 + 64) <= *(a1 + 40))
    {
      return 1;
    }

    v53 = *(a1 + 40);
    v54 = *(a1 + 24);
    *(a1 + 24) = *(a1 + 48);
    *(a1 + 40) = *(a1 + 64);
    *(a1 + 48) = v54;
    *(a1 + 64) = v53;
    goto LABEL_50;
  }

  if (v3 < 2)
  {
    return 1;
  }

  if (v3 == 2)
  {
    if (*(a2 - 8) > *(a1 + 16))
    {
      v4 = *(a1 + 16);
      v5 = *a1;
      v6 = *(a2 - 8);
      *a1 = *(a2 - 24);
      *(a1 + 16) = v6;
      *(a2 - 24) = v5;
      *(a2 - 8) = v4;
    }

    return 1;
  }

LABEL_13:
  v13 = a1 + 48;
  v14 = *(a1 + 40);
  v15 = *(a1 + 16);
  v16 = *(a1 + 64);
  if (v14 <= v15)
  {
    if (v16 > v14)
    {
      v27 = *(a1 + 40);
      v28 = *(a1 + 24);
      *(a1 + 24) = *v13;
      *(a1 + 40) = *(a1 + 64);
      *v13 = v28;
      *(a1 + 64) = v27;
      if (*(a1 + 40) > v15)
      {
        v29 = *(a1 + 16);
        v30 = *a1;
        *a1 = *(a1 + 24);
        *(a1 + 16) = *(a1 + 40);
        *(a1 + 24) = v30;
        *(a1 + 40) = v29;
      }
    }
  }

  else
  {
    if (v16 <= v14)
    {
      v38 = *(a1 + 16);
      v39 = *a1;
      *a1 = *(a1 + 24);
      *(a1 + 16) = *(a1 + 40);
      *(a1 + 24) = v39;
      *(a1 + 40) = v38;
      if (v16 <= *(a1 + 40))
      {
        goto LABEL_33;
      }

      v17 = *(a1 + 40);
      v18 = *(a1 + 24);
      *(a1 + 24) = *v13;
      *(a1 + 40) = *(a1 + 64);
    }

    else
    {
      v17 = *(a1 + 16);
      v18 = *a1;
      *a1 = *v13;
      *(a1 + 16) = *(a1 + 64);
    }

    *v13 = v18;
    *(a1 + 64) = v17;
  }

LABEL_33:
  v40 = a1 + 72;
  if (a1 + 72 == a2)
  {
    return 1;
  }

  v41 = 0;
  v42 = 0;
  while (1)
  {
    v43 = *(v40 + 16);
    if (v43 > *(v13 + 16))
    {
      v58 = *v40;
      v44 = v41;
      while (1)
      {
        v45 = a1 + v44;
        *(v45 + 72) = *(a1 + v44 + 48);
        *(v45 + 88) = *(a1 + v44 + 64);
        if (v44 == -48)
        {
          break;
        }

        v44 -= 24;
        if (v43 <= *(v45 + 40))
        {
          v46 = a1 + v44 + 72;
          goto LABEL_41;
        }
      }

      v46 = a1;
LABEL_41:
      *v46 = v58;
      *(v46 + 16) = v43;
      if (++v42 == 8)
      {
        return v40 + 24 == a2;
      }
    }

    v13 = v40;
    v41 += 24;
    v40 += 24;
    if (v40 == a2)
    {
      return 1;
    }
  }
}

void *sub_10169D6F8(void *result, void *a2)
{
  result[1] = 0;
  result[2] = 0;
  *result = result + 1;
  v2 = *a2;
  if (*a2 != a2 + 1)
  {
    do
    {
      v3 = result[1];
      v4 = result + 1;
      if (*result == result + 1)
      {
        goto LABEL_8;
      }

      v5 = result[1];
      v6 = result + 1;
      if (v3)
      {
        do
        {
          v4 = v5;
          v5 = v5[1];
        }

        while (v5);
      }

      else
      {
        do
        {
          v4 = v6[2];
          v7 = *v4 == v6;
          v6 = v4;
        }

        while (v7);
      }

      v8 = v2[4];
      if (v4[4] < v8)
      {
LABEL_8:
        if (v3)
        {
          v9 = v4 + 1;
        }

        else
        {
          v9 = result + 1;
        }

        if (!*v9)
        {
LABEL_19:
          operator new();
        }
      }

      else
      {
        if (!v3)
        {
          goto LABEL_19;
        }

        while (1)
        {
          while (1)
          {
            v10 = v3;
            v11 = v3[4];
            if (v11 <= v8)
            {
              break;
            }

            v3 = *v10;
            if (!*v10)
            {
              goto LABEL_19;
            }
          }

          if (v11 >= v8)
          {
            break;
          }

          v3 = v10[1];
          if (!v3)
          {
            goto LABEL_19;
          }
        }
      }

      v12 = v2[1];
      if (v12)
      {
        do
        {
          v13 = v12;
          v12 = *v12;
        }

        while (v12);
      }

      else
      {
        do
        {
          v13 = v2[2];
          v7 = *v13 == v2;
          v2 = v13;
        }

        while (!v7);
      }

      v2 = v13;
    }

    while (v13 != a2 + 1);
  }

  return result;
}

uint64_t sub_10169D880(uint64_t result, uint64_t a2)
{
  v2 = *(result + 8);
  if (!v2)
  {
LABEL_7:
    operator new();
  }

  while (1)
  {
    while (1)
    {
      v3 = v2;
      v4 = v2[4];
      if (v4 <= a2)
      {
        break;
      }

      v2 = *v3;
      if (!*v3)
      {
        goto LABEL_7;
      }
    }

    if (v4 >= a2)
    {
      return result;
    }

    v2 = v3[1];
    if (!v2)
    {
      goto LABEL_7;
    }
  }
}

void sub_10169D940(void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 48;
        sub_100034450(*(v4 - 5));
        v4 = v6;
      }

      while (v6 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void sub_10169D9C8(uint64_t **a1, uint64_t a2)
{
  v2 = a1[1];
  if (v2)
  {
    v3 = (a1 + 1);
    do
    {
      if (v2[4] >= a2)
      {
        v3 = v2;
      }

      v2 = v2[v2[4] < a2];
    }

    while (v2);
    if (v3 != (a1 + 1) && v3[4] <= a2)
    {
      sub_100D7A2B0(a1, v3);

      operator delete(v3);
    }
  }
}

uint64_t sub_10169DA48(double *a1, uint64_t a2)
{
  v2 = *a2;
  v3 = *(a2 + 8);
  if (v3 - *a2 < 0x40)
  {
    return 0xFFFFFFFFLL;
  }

  v13 = 0;
  v14 = 0;
  v15 = 0;
  if (v2 + 2 == v3)
  {
    return 0xFFFFFFFFLL;
  }

  do
  {
    if (!sub_10169DBD8(a1, v2, v2 + 2, &v13))
    {
      break;
    }

    v6 = v2 + 4;
    v2 += 2;
  }

  while (v6 != v3);
  if (v15)
  {
    return 0;
  }

  if (v14 && HIDWORD(v14))
  {
    if (v14 < 1)
    {
      if (!v13)
      {
        return 0xFFFFFFFFLL;
      }
    }

    else if (!(v13 + HIDWORD(v13)))
    {
      return 0xFFFFFFFFLL;
    }
  }

  else if (!v13)
  {
    return 0xFFFFFFFFLL;
  }

  v9 = *(a2 + 24);
  v8 = *(a2 + 32);
  while (v9 != v8)
  {
    v10 = *v9;
    v11 = v9[1];
    if ((v11 - *v9) >= 0x40)
    {
      v13 = 0;
      v14 = 0;
      v15 = 0;
      if (v10 + 2 != v11)
      {
        do
        {
          if (!sub_10169DBD8(a1, v10, v10 + 2, &v13))
          {
            break;
          }

          v12 = v10 + 4;
          v10 += 2;
        }

        while (v12 != v11);
        if (v15)
        {
          return 0;
        }

        if (v14 && HIDWORD(v14))
        {
          if (v14 < 1)
          {
            if (v13)
            {
              return 0xFFFFFFFFLL;
            }
          }

          else if (v13 + HIDWORD(v13))
          {
            return 0xFFFFFFFFLL;
          }
        }

        else if (v13)
        {
          return 0xFFFFFFFFLL;
        }
      }

      v8 = *(a2 + 32);
    }

    v9 += 3;
  }

  return 1;
}

uint64_t sub_10169DBD8(double *a1, double *a2, double *a3, uint64_t a4)
{
  v6 = *a1;
  v8 = *a2;
  v7 = a2[1];
  v9 = *a3;
  v225 = a3[1];
  v226 = a1[1];
  v10 = *a1 - *a2;
  v11 = vabdd_f64(*a1, *a2);
  v12 = 180.0;
  if (v11 == 180.0)
  {
    goto LABEL_2;
  }

  if (COERCE_UNSIGNED_INT64(fabs(v6 - v8)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v15 = fabs(v11 + -180.0);
    v12 = 180.0;
    if (v11 >= 180.0)
    {
      v16 = v11;
    }

    else
    {
      v16 = 180.0;
    }

    if (v16 < 1.0)
    {
      v16 = 1.0;
    }

    if (v15 <= v16 * 2.22044605e-16)
    {
      goto LABEL_2;
    }
  }

  v12 = 180.0;
  if (v10 <= 180.0)
  {
    v13 = v6 - v8;
    if (v10 >= -180.0)
    {
      goto LABEL_3;
    }

    v58 = a4;
    v59 = a2[1];
    v60 = fmod(v10 + -180.0, 360.0);
    v10 = v6 - v8;
    v7 = v59;
    a4 = v58;
    v12 = v60 + 180.0;
LABEL_2:
    v13 = v12;
    goto LABEL_3;
  }

  v17 = a4;
  v18 = a2[1];
  v19 = fmod(v10 + 180.0, 360.0);
  v10 = v6 - v8;
  v7 = v18;
  a4 = v17;
  v13 = v19 + -180.0;
  if (v13 == -180.0)
  {
    goto LABEL_2;
  }

  if ((*&v13 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v20 = fabs(v13);
    v12 = 180.0;
    v21 = fabs(v13 + 180.0);
    if (v20 < 180.0)
    {
      v20 = 180.0;
    }

    if (v20 < 1.0)
    {
      v20 = 1.0;
    }

    if (v21 <= v20 * 2.22044605e-16)
    {
      goto LABEL_2;
    }
  }

LABEL_3:
  if (v13 == 0.0)
  {
    v14 = 1;
  }

  else if ((*&v13 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v22 = fabs(v13);
    v23 = 1.0;
    if (v22 >= 1.0)
    {
      v23 = v22;
    }

    v14 = v22 <= v23 * 2.22044605e-16;
  }

  else
  {
    v14 = 0;
  }

  v24 = vabdd_f64(v6, v9);
  v25 = 180.0;
  if (v24 != 180.0)
  {
    v26 = v6 - v9;
    if (COERCE__INT64(fabs(v6 - v9)) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_36;
    }

    v28 = fabs(v24 + -180.0);
    v25 = 180.0;
    if (v24 < 180.0)
    {
      v24 = 180.0;
    }

    if (v24 < 1.0)
    {
      v24 = 1.0;
    }

    if (v28 > v24 * 2.22044605e-16)
    {
LABEL_36:
      v25 = 180.0;
      if (v26 <= 180.0)
      {
        if (v26 >= -180.0)
        {
          goto LABEL_28;
        }

        v61 = a4;
        v62 = v7;
        v63 = v10;
        v64 = fmod(v26 + -180.0, 360.0);
        v10 = v63;
        v7 = v62;
        a4 = v61;
        v25 = v64 + 180.0;
      }

      else
      {
        v29 = a4;
        v30 = v7;
        v31 = v10;
        v32 = fmod(v26 + 180.0, 360.0);
        v10 = v31;
        v7 = v30;
        a4 = v29;
        v26 = v32 + -180.0;
        if (v26 != -180.0)
        {
          if ((*&v26 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_28;
          }

          v33 = fabs(v26);
          v25 = 180.0;
          v34 = fabs(v26 + 180.0);
          if (v33 < 180.0)
          {
            v33 = 180.0;
          }

          if (v33 < 1.0)
          {
            v33 = 1.0;
          }

          if (v34 > v33 * 2.22044605e-16)
          {
            goto LABEL_28;
          }
        }
      }
    }
  }

  v26 = v25;
LABEL_28:
  if (v26 == 0.0)
  {
    v27 = 1;
  }

  else if ((*&v26 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v35 = fabs(v26);
    v36 = 1.0;
    if (v35 >= 1.0)
    {
      v36 = v35;
    }

    v27 = v35 <= v36 * 2.22044605e-16;
  }

  else
  {
    v27 = 0;
  }

  v37 = v6 + dbl_1019ADED0[v6 <= 0.0];
  if (v14)
  {
LABEL_51:
    v38 = 1;
    goto LABEL_56;
  }

  v39 = vabdd_f64(v37, v8);
  v40 = 180.0;
  if (v39 == 180.0)
  {
    goto LABEL_53;
  }

  v41 = v37 - v8;
  if (COERCE__INT64(fabs(v37 - v8)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v44 = fabs(v39 + -180.0);
    v40 = 180.0;
    if (v39 < 180.0)
    {
      v39 = 180.0;
    }

    if (v39 < 1.0)
    {
      v39 = 1.0;
    }

    if (v44 <= v39 * 2.22044605e-16)
    {
      goto LABEL_53;
    }
  }

  v40 = 180.0;
  if (v41 <= 180.0)
  {
    if (v41 >= -180.0)
    {
      goto LABEL_54;
    }

    v65 = a4;
    v66 = v7;
    v67 = v6;
    v68 = v8;
    v69 = v9;
    v70 = v11;
    v71 = v10;
    v72 = fmod(v41 + -180.0, 360.0);
    v10 = v71;
    v11 = v70;
    v9 = v69;
    v8 = v68;
    v6 = v67;
    v7 = v66;
    a4 = v65;
    v40 = v72 + 180.0;
    goto LABEL_53;
  }

  v45 = a4;
  v46 = v7;
  v47 = v6;
  v48 = v8;
  v49 = v9;
  v50 = v11;
  v51 = v10;
  v52 = fmod(v41 + 180.0, 360.0);
  v10 = v51;
  v11 = v50;
  v9 = v49;
  v8 = v48;
  v6 = v47;
  v7 = v46;
  a4 = v45;
  v41 = v52 + -180.0;
  if (v41 == -180.0)
  {
    goto LABEL_53;
  }

  if ((*&v41 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v53 = fabs(v41);
    v40 = 180.0;
    v54 = fabs(v41 + 180.0);
    if (v53 < 180.0)
    {
      v53 = 180.0;
    }

    if (v53 < 1.0)
    {
      v53 = 1.0;
    }

    if (v54 <= v53 * 2.22044605e-16)
    {
LABEL_53:
      v41 = v40;
    }
  }

LABEL_54:
  if (v41 != 0.0)
  {
    if ((*&v41 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_77;
    }

    v55 = fabs(v41);
    v56 = 1.0;
    if (v55 >= 1.0)
    {
      v56 = v55;
    }

    if (v55 > v56 * 2.22044605e-16)
    {
LABEL_77:
      v57 = fabs(v7);
      if (v57 != 90.0)
      {
        if ((*&v7 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v73 = fabs(v57 + -90.0);
          if (v57 < 90.0)
          {
            v57 = 90.0;
          }

          if (v57 < 1.0)
          {
            v57 = 1.0;
          }

          v42 = v73 <= v57 * 2.22044605e-16;
        }

        else
        {
          v42 = 0;
        }

        v38 = 1;
        if (v27)
        {
          goto LABEL_57;
        }

        goto LABEL_92;
      }

      goto LABEL_51;
    }
  }

  v38 = 0;
LABEL_56:
  v42 = 1;
  if (v27)
  {
    goto LABEL_57;
  }

LABEL_92:
  v74 = vabdd_f64(v37, v9);
  v75 = 180.0;
  if (v74 == 180.0)
  {
    goto LABEL_93;
  }

  v76 = v37 - v9;
  if (COERCE__INT64(fabs(v37 - v9)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v128 = fabs(v74 + -180.0);
    v75 = 180.0;
    if (v74 < 180.0)
    {
      v74 = 180.0;
    }

    if (v74 < 1.0)
    {
      v74 = 1.0;
    }

    if (v128 <= v74 * 2.22044605e-16)
    {
      goto LABEL_93;
    }
  }

  v75 = 180.0;
  if (v76 > 180.0)
  {
    v129 = a4;
    v130 = v7;
    v131 = v10;
    v132 = fmod(v76 + 180.0, 360.0);
    v10 = v131;
    v7 = v130;
    a4 = v129;
    v76 = v132 + -180.0;
    if (v76 != -180.0)
    {
      if ((*&v76 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_94;
      }

      v133 = fabs(v76);
      v75 = 180.0;
      v134 = fabs(v76 + 180.0);
      if (v133 < 180.0)
      {
        v133 = 180.0;
      }

      if (v133 < 1.0)
      {
        v133 = 1.0;
      }

      if (v134 > v133 * 2.22044605e-16)
      {
        goto LABEL_94;
      }
    }

    goto LABEL_93;
  }

  if (v76 < -180.0)
  {
    v168 = a4;
    v169 = v7;
    v170 = v10;
    v171 = fmod(v76 + -180.0, 360.0);
    v10 = v170;
    v7 = v169;
    a4 = v168;
    v75 = v171 + 180.0;
LABEL_93:
    v76 = v75;
  }

LABEL_94:
  if (v76 == 0.0)
  {
    goto LABEL_95;
  }

  if ((*&v76 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v135 = fabs(v76);
    v136 = 1.0;
    if (v135 >= 1.0)
    {
      v136 = v135;
    }

    if (v135 <= v136 * 2.22044605e-16)
    {
LABEL_95:
      v43 = 0;
      goto LABEL_96;
    }
  }

  v137 = fabs(v225);
  if (v137 != 90.0)
  {
    if ((*&v225 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v198 = fabs(v137 + -90.0);
      if (v137 < 90.0)
      {
        v137 = 90.0;
      }

      if (v137 < 1.0)
      {
        v137 = 1.0;
      }

      v77 = v198 <= v137 * 2.22044605e-16;
    }

    else
    {
      v77 = 0;
    }

    v43 = 1;
    goto LABEL_97;
  }

LABEL_57:
  v43 = 1;
LABEL_96:
  v77 = 1;
LABEL_97:
  v78 = v9 - v8;
  v79 = vabdd_f64(v9, v8);
  v80 = 180.0;
  if (v79 == 180.0)
  {
    goto LABEL_98;
  }

  if (COERCE_UNSIGNED_INT64(fabs(v9 - v8)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v86 = fabs(v79 + -180.0);
    v80 = 180.0;
    if (v79 >= 180.0)
    {
      v87 = v79;
    }

    else
    {
      v87 = 180.0;
    }

    if (v87 < 1.0)
    {
      v87 = 1.0;
    }

    if (v86 <= v87 * 2.22044605e-16)
    {
      goto LABEL_98;
    }
  }

  v80 = 180.0;
  if (v78 <= 180.0)
  {
    v81 = v9 - v8;
    if (v78 >= -180.0)
    {
      goto LABEL_99;
    }

    v146 = v78 + -180.0;
    v147 = a4;
    v223 = v9 - v8;
    v148 = v6;
    v149 = v8;
    v150 = v9;
    v151 = v11;
    v152 = v7;
    v153 = v10;
    v154 = fmod(v146, 360.0);
    v10 = v153;
    v7 = v152;
    v11 = v151;
    v9 = v150;
    v8 = v149;
    v6 = v148;
    v78 = v223;
    a4 = v147;
    v80 = v154 + 180.0;
    goto LABEL_98;
  }

  v88 = v78 + 180.0;
  v89 = a4;
  v222 = v9 - v8;
  v90 = v6;
  v91 = v8;
  v92 = v9;
  v93 = v11;
  v94 = v7;
  v95 = v10;
  v96 = fmod(v88, 360.0);
  v10 = v95;
  v7 = v94;
  v11 = v93;
  v9 = v92;
  v8 = v91;
  v6 = v90;
  v78 = v222;
  a4 = v89;
  v81 = v96 + -180.0;
  if (v81 == -180.0)
  {
    goto LABEL_98;
  }

  if ((*&v81 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v97 = fabs(v81);
    v80 = 180.0;
    v98 = fabs(v81 + 180.0);
    if (v97 < 180.0)
    {
      v97 = 180.0;
    }

    if (v97 < 1.0)
    {
      v97 = 1.0;
    }

    if (v98 <= v97 * 2.22044605e-16)
    {
LABEL_98:
      v81 = v80;
    }
  }

LABEL_99:
  v82 = 180.0;
  if (v81 == 180.0)
  {
    goto LABEL_100;
  }

  if ((*&v81 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    goto LABEL_131;
  }

  v99 = fabs(v81);
  v100 = fabs(v81 + -180.0);
  if (v99 < 180.0)
  {
    v99 = 180.0;
  }

  if (v99 < 1.0)
  {
    v99 = 1.0;
  }

  if (v100 <= v99 * 2.22044605e-16)
  {
LABEL_100:
    v83 = fabs(v226);
    if (v83 == 90.0)
    {
      goto LABEL_134;
    }

    v77 |= v42;
    if ((*&v226 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v84 = fabs(v83 + -90.0);
      if (v83 < 90.0)
      {
        v83 = 90.0;
      }

      if (v83 < 1.0)
      {
        v83 = 1.0;
      }

      if (v84 <= v83 * 2.22044605e-16)
      {
        goto LABEL_134;
      }
    }

    v85 = 1;
    v42 = v77;
    if (!v77)
    {
      goto LABEL_178;
    }
  }

  else
  {
LABEL_131:
    v85 = 0;
    if (!v42)
    {
LABEL_178:
      if (v11 != 180.0)
      {
        if ((*&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_259;
        }

        v157 = fabs(v11 + -180.0);
        v82 = 180.0;
        if (v11 >= 180.0)
        {
          v158 = v11;
        }

        else
        {
          v158 = 180.0;
        }

        if (v158 < 1.0)
        {
          v158 = 1.0;
        }

        if (v157 > v158 * 2.22044605e-16)
        {
LABEL_259:
          v82 = 180.0;
          if (v10 <= 180.0)
          {
            if (v10 >= -180.0)
            {
              goto LABEL_180;
            }

            v189 = a4;
            v190 = v7;
            v191 = fmod(v10 + -180.0, 360.0);
            v7 = v190;
            a4 = v189;
            v82 = v191 + 180.0;
          }

          else
          {
            v159 = a4;
            v160 = v7;
            v161 = fmod(v10 + 180.0, 360.0);
            v7 = v160;
            a4 = v159;
            v10 = v161 + -180.0;
            if (v161 + -180.0 != -180.0)
            {
              if (COERCE_UNSIGNED_INT64(fabs(v161 + -180.0)) > 0x7FEFFFFFFFFFFFFFLL)
              {
                goto LABEL_180;
              }

              v162 = fabs(v10);
              v82 = 180.0;
              v163 = fabs(v10 + 180.0);
              if (v162 < 180.0)
              {
                v162 = 180.0;
              }

              if (v162 < 1.0)
              {
                v162 = 1.0;
              }

              if (v163 > v162 * 2.22044605e-16)
              {
LABEL_180:
                if (v85)
                {
                  v113 = v10 < 0.0;
                  goto LABEL_182;
                }

                v138 = 180.0;
                if (v79 != 180.0)
                {
                  if ((*&v78 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    goto LABEL_298;
                  }

                  v174 = fabs(v79 + -180.0);
                  v138 = 180.0;
                  if (v79 >= 180.0)
                  {
                    v175 = v79;
                  }

                  else
                  {
                    v175 = 180.0;
                  }

                  if (v175 < 1.0)
                  {
                    v175 = 1.0;
                  }

                  if (v174 > v175 * 2.22044605e-16)
                  {
LABEL_298:
                    v138 = 180.0;
                    if (v78 <= 180.0)
                    {
                      if (v78 >= -180.0)
                      {
                        goto LABEL_227;
                      }

                      v199 = v78 + -180.0;
                      v200 = a4;
                      v201 = v7;
                      v202 = v10;
                      v203 = fmod(v199, 360.0);
                      v10 = v202;
                      v7 = v201;
                      a4 = v200;
                      v138 = v203 + 180.0;
                    }

                    else
                    {
                      v176 = v78 + 180.0;
                      v177 = a4;
                      v178 = v7;
                      v179 = v10;
                      v180 = fmod(v176, 360.0);
                      v10 = v179;
                      v7 = v178;
                      a4 = v177;
                      v78 = v180 + -180.0;
                      if (v180 + -180.0 != -180.0)
                      {
                        if (COERCE_UNSIGNED_INT64(fabs(v180 + -180.0)) > 0x7FEFFFFFFFFFFFFFLL)
                        {
                          goto LABEL_227;
                        }

                        v181 = fabs(v78);
                        v138 = 180.0;
                        v182 = fabs(v78 + 180.0);
                        if (v181 < 180.0)
                        {
                          v181 = 180.0;
                        }

                        if (v181 < 1.0)
                        {
                          v181 = 1.0;
                        }

                        if (v182 > v181 * 2.22044605e-16)
                        {
LABEL_227:
                          if ((v42 | v77) == 1)
                          {
                            if (v78 >= 0.0)
                            {
                              v114 = 1;
                            }

                            else
                            {
                              v114 = -1;
                            }

                            v139 = 180.0;
                            v140 = v6 + 180.0;
                            if (v42)
                            {
                              v141 = v8;
                            }

                            else
                            {
                              v141 = v9;
                            }

                            v142 = vabdd_f64(v141, v140);
                            if (v142 != 180.0)
                            {
                              v143 = v141 - v140;
                              if ((*&v143 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                              {
                                goto LABEL_334;
                              }

                              v192 = fabs(v142 + -180.0);
                              v139 = 180.0;
                              if (v142 < 180.0)
                              {
                                v142 = 180.0;
                              }

                              if (v142 < 1.0)
                              {
                                v142 = 1.0;
                              }

                              if (v192 > v142 * 2.22044605e-16)
                              {
LABEL_334:
                                v139 = 180.0;
                                if (v143 <= 180.0)
                                {
                                  if (v143 >= -180.0)
                                  {
                                    goto LABEL_236;
                                  }

                                  v215 = a4;
                                  v216 = v7;
                                  v217 = fmod(v143 + -180.0, 360.0);
                                  v7 = v216;
                                  a4 = v215;
                                  v139 = v217 + 180.0;
                                }

                                else
                                {
                                  v193 = a4;
                                  v194 = v7;
                                  v195 = fmod(v143 + 180.0, 360.0);
                                  v7 = v194;
                                  a4 = v193;
                                  v143 = v195 + -180.0;
                                  if (v143 != -180.0)
                                  {
                                    if ((*&v143 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                                    {
                                      goto LABEL_236;
                                    }

                                    v196 = fabs(v143);
                                    v139 = 180.0;
                                    v197 = fabs(v143 + 180.0);
                                    if (v196 < 180.0)
                                    {
                                      v196 = 180.0;
                                    }

                                    if (v196 < 1.0)
                                    {
                                      v196 = 1.0;
                                    }

                                    if (v197 > v196 * 2.22044605e-16)
                                    {
LABEL_236:
                                      if (v143 != 0.0)
                                      {
                                        if ((*&v143 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                                        {
                                          goto LABEL_185;
                                        }

                                        v144 = fabs(v143);
                                        v145 = 1.0;
                                        if (v144 >= 1.0)
                                        {
                                          v145 = v144;
                                        }

                                        if (v144 > v145 * 2.22044605e-16)
                                        {
LABEL_185:
                                          if (v114 != 1 && v114 != -1)
                                          {
                                            if (v85)
                                            {
                                              if (v114 < 1)
                                              {
                                                v172 = -1;
                                              }

                                              else
                                              {
                                                v172 = 1;
                                              }

                                              if (180.0 - v7 - v225 > 180.0)
                                              {
                                                v173 = v172;
                                              }

                                              else
                                              {
                                                v173 = -v172;
                                              }

LABEL_324:
                                              if (v173 * v114 >= 1)
                                              {
                                                *a4 += v114;
                                              }

                                              *(a4 + 8) += v114;
                                              goto LABEL_250;
                                            }

                                            v125 = a4;
                                            v126 = a2;
                                            v127 = a3;
                                            goto LABEL_323;
                                          }

                                          if (v42)
                                          {
                                            v115 = a2;
                                          }

                                          else
                                          {
                                            v115 = a3;
                                          }

                                          v116 = v115[1];
                                          if (v226 == v116)
                                          {
                                            goto LABEL_327;
                                          }

                                          v117 = *v115;
                                          if ((*&v226 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v116 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                                          {
                                            v118 = fabs(v226);
                                            v119 = fabs(v116);
                                            v120 = vabdd_f64(v226, v116);
                                            if (v118 < v119)
                                            {
                                              v118 = v119;
                                            }

                                            if (v118 < 1.0)
                                            {
                                              v118 = 1.0;
                                            }

                                            if (v120 <= v118 * 2.22044605e-16)
                                            {
                                              goto LABEL_327;
                                            }
                                          }

                                          *v228 = *v115;
                                          *&v228[1] = v116;
                                          *&v227[1] = v116;
                                          v121 = -1.0;
                                          if (v114 > 0)
                                          {
                                            v121 = 1.0;
                                          }

                                          v122 = v121 + v117;
                                          v123 = fabs(v122);
                                          v124 = 180.0;
                                          if (v123 != 180.0)
                                          {
                                            if ((*&v122 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                                            {
                                              goto LABEL_372;
                                            }

                                            v209 = fabs(v123 + -180.0);
                                            v124 = 180.0;
                                            if (v123 < 180.0)
                                            {
                                              v123 = 180.0;
                                            }

                                            if (v123 < 1.0)
                                            {
                                              v123 = 1.0;
                                            }

                                            if (v209 > v123 * 2.22044605e-16)
                                            {
LABEL_372:
                                              v124 = 180.0;
                                              if (v122 <= 180.0)
                                              {
                                                if (v122 >= -180.0)
                                                {
                                                  goto LABEL_202;
                                                }

                                                v220 = a4;
                                                v221 = fmod(v122 + -180.0, 360.0);
                                                a4 = v220;
                                                v124 = v221 + 180.0;
                                              }

                                              else
                                              {
                                                v210 = a4;
                                                v211 = fmod(v122 + 180.0, 360.0);
                                                a4 = v210;
                                                v122 = v211 + -180.0;
                                                if (v122 != -180.0)
                                                {
                                                  if ((*&v122 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                                                  {
                                                    goto LABEL_202;
                                                  }

                                                  v212 = fabs(v122);
                                                  v124 = 180.0;
                                                  v213 = fabs(v122 + 180.0);
                                                  if (v212 < 180.0)
                                                  {
                                                    v212 = 180.0;
                                                  }

                                                  if (v212 < 1.0)
                                                  {
                                                    v212 = 1.0;
                                                  }

                                                  if (v213 > v212 * 2.22044605e-16)
                                                  {
                                                    goto LABEL_202;
                                                  }
                                                }
                                              }
                                            }
                                          }

                                          v122 = v124;
LABEL_202:
                                          v125 = a4;
                                          *v227 = v122;
                                          v126 = v228;
                                          v127 = v227;
LABEL_323:
                                          v173 = sub_10169A37C(v126, v127, a1);
                                          a4 = v125;
                                          if (v173)
                                          {
                                            goto LABEL_324;
                                          }

LABEL_327:
                                          v155 = 0;
                                          *(a4 + 16) = 1;
                                          *a4 = 0;
                                          return v155 & 1;
                                        }
                                      }

                                      goto LABEL_319;
                                    }
                                  }
                                }
                              }
                            }

                            v143 = v139;
                            goto LABEL_236;
                          }

                          if (v10 >= 0.0)
                          {
                            v164 = 0;
                          }

                          else
                          {
                            v164 = -1;
                          }

                          if (v78 >= 0.0)
                          {
                            v165 = 0;
                          }

                          else
                          {
                            v165 = -1;
                          }

                          if (v78 > 0.0)
                          {
                            v166 = 1;
                          }

                          else
                          {
                            v166 = v165;
                          }

                          v167 = v166 == v164;
                          if (v10 > 0.0)
                          {
                            v167 = v78 > 0.0;
                          }

                          if (v167 && fabs(v10) < fabs(v78))
                          {
                            v113 = v78 < 0.0;
LABEL_182:
                            if (v113)
                            {
                              v114 = -2;
                            }

                            else
                            {
                              v114 = 2;
                            }

                            goto LABEL_185;
                          }

                          v183 = 180.0;
                          v184 = vabdd_f64(v6 + 180.0, v8);
                          if (v184 != 180.0)
                          {
                            v185 = v6 + 180.0 - v8;
                            if (COERCE_UNSIGNED_INT64(fabs(v185)) > 0x7FEFFFFFFFFFFFFFLL)
                            {
                              goto LABEL_357;
                            }

                            v204 = fabs(v184 + -180.0);
                            v183 = 180.0;
                            if (v184 < 180.0)
                            {
                              v184 = 180.0;
                            }

                            if (v184 < 1.0)
                            {
                              v184 = 1.0;
                            }

                            if (v204 > v184 * 2.22044605e-16)
                            {
LABEL_357:
                              v183 = 180.0;
                              if (v185 <= 180.0)
                              {
                                if (v185 >= -180.0)
                                {
                                  goto LABEL_309;
                                }

                                v218 = a4;
                                v219 = fmod(v185 + -180.0, 360.0);
                                a4 = v218;
                                v183 = v219 + 180.0;
                              }

                              else
                              {
                                v205 = a4;
                                v206 = fmod(v185 + 180.0, 360.0);
                                a4 = v205;
                                v185 = v206 + -180.0;
                                if (v185 != -180.0)
                                {
                                  if ((*&v185 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                                  {
                                    goto LABEL_309;
                                  }

                                  v207 = fabs(v185);
                                  v183 = 180.0;
                                  v208 = fabs(v185 + 180.0);
                                  if (v207 < 180.0)
                                  {
                                    v207 = 180.0;
                                  }

                                  if (v207 < 1.0)
                                  {
                                    v207 = 1.0;
                                  }

                                  if (v208 > v207 * 2.22044605e-16)
                                  {
                                    goto LABEL_309;
                                  }
                                }
                              }
                            }
                          }

                          v185 = v183;
LABEL_309:
                          v186 = v78 > 0.0;
                          if (v185 >= 0.0)
                          {
                            v187 = 0;
                          }

                          else
                          {
                            v187 = -1;
                          }

                          v188 = v166 == v187;
                          if (v185 <= 0.0)
                          {
                            v186 = v188;
                          }

                          if (!v186 || fabs(v185) >= fabs(v78))
                          {
                            goto LABEL_250;
                          }

                          if (v78 >= 0.0)
                          {
                            v114 = 2;
                          }

                          else
                          {
                            v114 = -2;
                          }

LABEL_319:
                          *(a4 + 4) -= v114;
                          *(a4 + 12) -= v114;
                          goto LABEL_250;
                        }
                      }
                    }
                  }
                }

                v78 = v138;
                goto LABEL_227;
              }
            }
          }
        }
      }

      v10 = v82;
      goto LABEL_180;
    }
  }

  if (!v77)
  {
    goto LABEL_178;
  }

  if ((v85 & 1) == 0)
  {
    if ((v7 > v226 || v225 < v226) && (v225 > v226 || v7 < v226) || ((v38 | v43) & 1) == 0)
    {
      goto LABEL_250;
    }

    goto LABEL_249;
  }

LABEL_134:
  if (180.0 - v7 - v225 <= 180.0)
  {
    if ((v7 > v226 || !v14) && (v225 > v226 || !v27))
    {
      v109 = 90.0;
      if (v226 != 90.0)
      {
        v110 = fabs(v226);
        if ((*&v226 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_386;
        }

        v111 = fabs(v226 + -90.0);
        if (v110 >= 90.0)
        {
          v112 = v110;
        }

        else
        {
          v112 = 90.0;
        }

        if (v112 < 1.0)
        {
          v112 = 1.0;
        }

        if (v111 > v112 * 2.22044605e-16)
        {
LABEL_386:
          if (v14 || v27)
          {
            goto LABEL_250;
          }

          if (v226 != -90.0)
          {
            if ((*&v226 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_250;
            }

            v214 = fabs(v226 + 90.0);
            if (v110 >= 90.0)
            {
              v109 = v110;
            }

            if (v109 < 1.0)
            {
              v109 = 1.0;
            }

            if (v214 > v109 * 2.22044605e-16)
            {
              goto LABEL_250;
            }
          }

LABEL_177:
          v42 = 1;
          v85 = 1;
          v77 = 1;
          goto LABEL_178;
        }
      }
    }
  }

  else if (v7 < v226 || !v14)
  {
    v102 = v225 >= v226 && v27;
    if (!v102 && v226 != -90.0)
    {
      v103 = fabs(v226);
      if ((*&v226 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_157;
      }

      v104 = 90.0;
      v105 = fabs(v226 + 90.0);
      if (v103 >= 90.0)
      {
        v104 = v103;
      }

      if (v104 < 1.0)
      {
        v104 = 1.0;
      }

      if (v105 > v104 * 2.22044605e-16)
      {
LABEL_157:
        if (v14 || v27)
        {
          goto LABEL_250;
        }

        if (v226 != 90.0)
        {
          if ((*&v226 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_250;
          }

          v106 = fabs(v226 + -90.0);
          if (v103 < 90.0)
          {
            v103 = 90.0;
          }

          if (v103 < 1.0)
          {
            v103 = 1.0;
          }

          if (v106 > v103 * 2.22044605e-16)
          {
            goto LABEL_250;
          }
        }

        goto LABEL_177;
      }
    }
  }

LABEL_249:
  *(a4 + 16) = 1;
LABEL_250:
  v155 = *(a4 + 16) ^ 1;
  return v155 & 1;
}

void sub_10169F0D0(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, char a5)
{
  while (2)
  {
    v9 = a2 - 40;
    v306 = a2 - 80;
    v307 = a2;
    v10 = a2 - 120;
    v11 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v11;
          v12 = a2 - v11;
          v13 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - v11) >> 3);
          if (v13 > 2)
          {
            switch(v13)
            {
              case 3:
                v214 = sub_1016A01F0(a3, v11 + 5, v11);
                v215 = sub_1016A01F0(a3, v9, v11 + 5);
                if (v214)
                {
                  if (v215)
                  {
                    goto LABEL_109;
                  }

                  v300 = *v11;
                  v301 = *(v11 + 1);
                  v315 = *(v11 + 4);
                  v313 = v300;
                  v314 = v301;
                  v302 = *(v11 + 56);
                  *v11 = *(v11 + 40);
                  *(v11 + 1) = v302;
                  *(v11 + 4) = *(v11 + 9);
                  v303 = v314;
                  *(v11 + 40) = v313;
                  *(v11 + 56) = v303;
                  *(v11 + 9) = v315;
                  if (!sub_1016A01F0(a3, v9, v11 + 5))
                  {
                    return;
                  }

                  v220 = *(v11 + 40);
                  v221 = *(v11 + 56);
                  v313 = v220;
                  v314 = v221;
                  v222 = *(v11 + 9);
                  v315 = v222;
                  v305 = *v9;
                  v304 = *(v9 + 1);
                  *(v11 + 9) = *(v9 + 4);
                  *(v11 + 40) = v305;
                  *(v11 + 56) = v304;
LABEL_110:
                  *(v9 + 4) = v222;
                  *v9 = v220;
                  *(v9 + 1) = v221;
                  return;
                }

                if (!v215)
                {
                  return;
                }

                v283 = *(v11 + 56);
                v313 = *(v11 + 40);
                v282 = v313;
                v314 = v283;
                v315 = *(v11 + 9);
                v284 = v315;
                v286 = *v9;
                v285 = *(v9 + 1);
                *(v11 + 9) = *(v9 + 4);
                *(v11 + 40) = v286;
                *(v11 + 56) = v285;
                *(v9 + 4) = v284;
                *v9 = v282;
                *(v9 + 1) = v283;
LABEL_166:
                if (sub_1016A01F0(a3, v11 + 5, v11))
                {
                  v287 = *v11;
                  v288 = *(v11 + 1);
                  v315 = *(v11 + 4);
                  v313 = v287;
                  v314 = v288;
                  v289 = *(v11 + 56);
                  *v11 = *(v11 + 40);
                  *(v11 + 1) = v289;
                  *(v11 + 4) = *(v11 + 9);
                  v290 = v314;
                  *(v11 + 40) = v313;
                  *(v11 + 56) = v290;
                  *(v11 + 9) = v315;
                }

                return;
              case 4:

                sub_1016A04BC(v11, (v11 + 40), v11 + 5, v9, a3);
                return;
              case 5:
                sub_1016A04BC(v11, (v11 + 40), v11 + 5, (v11 + 120), a3);
                if (!sub_1016A01F0(a3, v9, v11 + 15))
                {
                  return;
                }

                v201 = *(v11 + 136);
                v313 = *(v11 + 120);
                v200 = v313;
                v314 = v201;
                v315 = *(v11 + 19);
                v202 = v315;
                v204 = *v9;
                v203 = *(v9 + 1);
                *(v11 + 19) = *(v9 + 4);
                *(v11 + 120) = v204;
                *(v11 + 136) = v203;
                *(v9 + 4) = v202;
                *v9 = v200;
                *(v9 + 1) = v201;
                if (!sub_1016A01F0(a3, v11 + 15, v11 + 10))
                {
                  return;
                }

                v205 = *(v11 + 14);
                v207 = *(v11 + 5);
                v206 = *(v11 + 6);
                v208 = *(v11 + 136);
                *(v11 + 5) = *(v11 + 120);
                *(v11 + 6) = v208;
                *(v11 + 14) = *(v11 + 19);
                *(v11 + 120) = v207;
                *(v11 + 136) = v206;
                *(v11 + 19) = v205;
                if (!sub_1016A01F0(a3, v11 + 10, v11 + 5))
                {
                  return;
                }

                v209 = *(v11 + 9);
                v210 = *(v11 + 56);
                v211 = *(v11 + 40);
                v212 = *(v11 + 6);
                *(v11 + 40) = *(v11 + 5);
                *(v11 + 56) = v212;
                *(v11 + 9) = *(v11 + 14);
                *(v11 + 5) = v211;
                *(v11 + 6) = v210;
                *(v11 + 14) = v209;
                goto LABEL_166;
            }
          }

          else
          {
            if (v13 < 2)
            {
              return;
            }

            if (v13 == 2)
            {
              if (!sub_1016A01F0(a3, v9, v11))
              {
                return;
              }

LABEL_109:
              v216 = *v11;
              v217 = *(v11 + 1);
              v315 = *(v11 + 4);
              v313 = v216;
              v314 = v217;
              v218 = *v9;
              v219 = *(v9 + 1);
              *(v11 + 4) = *(v9 + 4);
              *v11 = v218;
              *(v11 + 1) = v219;
              v220 = v313;
              v221 = v314;
              v222 = v315;
              goto LABEL_110;
            }
          }

          if (v12 <= 959)
          {
            v223 = v11 + 40;
            v224 = v11 == a2 || v223 == a2;
            v225 = v224;
            if (a5)
            {
              if ((v225 & 1) == 0)
              {
                v226 = 0;
                v227 = v11;
                do
                {
                  v228 = v227;
                  v227 = v223;
                  if (sub_1016A01F0(a3, v223, v228))
                  {
                    v229 = *v227;
                    v230 = *(v227 + 1);
                    v315 = *(v227 + 4);
                    v313 = v229;
                    v314 = v230;
                    v231 = v226;
                    while (1)
                    {
                      v232 = &v11[v231];
                      v233 = *&v11[v231 + 16];
                      *(v232 + 40) = *&v11[v231];
                      *(v232 + 56) = v233;
                      *(v232 + 9) = *&v11[v231 + 32];
                      if (!v231)
                      {
                        break;
                      }

                      v231 -= 40;
                      if ((sub_1016A01F0(a3, &v313, &v11[v231]) & 1) == 0)
                      {
                        v234 = &v11[v231 + 40];
                        goto LABEL_129;
                      }
                    }

                    v234 = v11;
LABEL_129:
                    v235 = v313;
                    v236 = v314;
                    *(v234 + 32) = v315;
                    *v234 = v235;
                    *(v234 + 16) = v236;
                  }

                  v223 = v227 + 40;
                  v226 += 40;
                }

                while (v227 + 40 != a2);
              }
            }

            else if ((v225 & 1) == 0)
            {
              v291 = v11 - 40;
              do
              {
                v292 = a1;
                a1 = v223;
                if (sub_1016A01F0(a3, v223, v292))
                {
                  v293 = *a1;
                  v294 = *(a1 + 16);
                  v315 = *(a1 + 32);
                  v313 = v293;
                  v314 = v294;
                  v295 = v291;
                  do
                  {
                    v296 = *(v295 + 56);
                    *(v295 + 5) = *(v295 + 40);
                    *(v295 + 6) = v296;
                    *(v295 + 14) = *(v295 + 9);
                    v297 = sub_1016A01F0(a3, &v313, v295);
                    v295 -= 40;
                  }

                  while ((v297 & 1) != 0);
                  v298 = v313;
                  v299 = v314;
                  *(v295 + 14) = v315;
                  *(v295 + 5) = v298;
                  *(v295 + 6) = v299;
                }

                v223 = (a1 + 40);
                v291 += 40;
              }

              while ((a1 + 40) != a2);
            }

            return;
          }

          if (!a4)
          {
            if (v11 != a2)
            {
              v237 = (v13 - 2) >> 1;
              v309 = v237;
              do
              {
                v238 = v237;
                if (v309 >= v237)
                {
                  v239 = (2 * v237) | 1;
                  v240 = a1 + 40 * v239;
                  if (2 * v237 + 2 < v13 && sub_1016A01F0(a3, (a1 + 40 * v239), (v240 + 40)))
                  {
                    v240 += 40;
                    v239 = 2 * v238 + 2;
                  }

                  v241 = a1 + 40 * v238;
                  if ((sub_1016A01F0(a3, v240, v241) & 1) == 0)
                  {
                    v242 = *v241;
                    v243 = *(v241 + 16);
                    v315 = *(v241 + 32);
                    v313 = v242;
                    v314 = v243;
                    do
                    {
                      v244 = v240;
                      v245 = *v240;
                      v246 = *(v240 + 16);
                      *(v241 + 32) = *(v240 + 32);
                      *v241 = v245;
                      *(v241 + 16) = v246;
                      if (v309 < v239)
                      {
                        break;
                      }

                      v247 = (2 * v239) | 1;
                      v240 = a1 + 40 * v247;
                      v248 = 2 * v239 + 2;
                      if (v248 < v13 && sub_1016A01F0(a3, (a1 + 40 * v247), (v240 + 40)))
                      {
                        v240 += 40;
                        v247 = v248;
                      }

                      v241 = v244;
                      v239 = v247;
                    }

                    while (!sub_1016A01F0(a3, v240, &v313));
                    v249 = v313;
                    v250 = v314;
                    *(v244 + 32) = v315;
                    *v244 = v249;
                    *(v244 + 16) = v250;
                    a2 = v307;
                  }
                }

                v237 = v238 - 1;
              }

              while (v238);
              v251 = 0xCCCCCCCCCCCCCCCDLL * (v12 >> 3);
              do
              {
                v252 = 0;
                v253 = *a1;
                v254 = *(a1 + 16);
                v312 = *(a1 + 32);
                v310 = v253;
                v311 = v254;
                v255 = a1;
                do
                {
                  v256 = v255 + 40 * v252;
                  v257 = v256 + 40;
                  v258 = (2 * v252) | 1;
                  v259 = 2 * v252 + 2;
                  if (v259 < v251)
                  {
                    v260 = v256 + 80;
                    if (sub_1016A01F0(a3, (v256 + 40), (v256 + 80)))
                    {
                      v257 = v260;
                      v258 = v259;
                    }
                  }

                  v261 = *v257;
                  v262 = *(v257 + 16);
                  *(v255 + 32) = *(v257 + 32);
                  *v255 = v261;
                  *(v255 + 16) = v262;
                  v255 = v257;
                  v252 = v258;
                }

                while (v258 <= (v251 - 2) / 2);
                v263 = a2 - 40;
                if (v257 == a2 - 40)
                {
                  v268 = a2 - 40;
                  v279 = v310;
                  v280 = v311;
                  *(v257 + 32) = v312;
                  *v257 = v279;
                  *(v257 + 16) = v280;
                }

                else
                {
                  v264 = *v263;
                  v265 = *(a2 - 24);
                  *(v257 + 32) = *(a2 - 1);
                  *v257 = v264;
                  *(v257 + 16) = v265;
                  v266 = v310;
                  v267 = v311;
                  *(a2 - 1) = v312;
                  *v263 = v266;
                  *(a2 - 24) = v267;
                  v268 = a2 - 40;
                  v269 = v257 - a1 + 40;
                  if (v269 >= 41)
                  {
                    v270 = (-2 - 0x3333333333333333 * (v269 >> 3)) >> 1;
                    v271 = a1 + 40 * v270;
                    if (sub_1016A01F0(a3, v271, v257))
                    {
                      v272 = *v257;
                      v273 = *(v257 + 16);
                      v315 = *(v257 + 32);
                      v313 = v272;
                      v314 = v273;
                      do
                      {
                        v274 = v271;
                        v275 = *v271;
                        v276 = *(v271 + 16);
                        *(v257 + 32) = *(v271 + 32);
                        *v257 = v275;
                        *(v257 + 16) = v276;
                        if (!v270)
                        {
                          break;
                        }

                        v270 = (v270 - 1) >> 1;
                        v271 = a1 + 40 * v270;
                        v257 = v274;
                      }

                      while ((sub_1016A01F0(a3, v271, &v313) & 1) != 0);
                      v277 = v313;
                      v278 = v314;
                      *(v274 + 32) = v315;
                      *v274 = v277;
                      *(v274 + 16) = v278;
                    }
                  }
                }

                v281 = v251-- <= 2;
                a2 = v268;
              }

              while (!v281);
            }

            return;
          }

          v14 = v13 >> 1;
          v15 = &v11[40 * v14];
          if (v12 >= 0x1401)
          {
            v16 = sub_1016A01F0(a3, (a1 + 40 * v14), a1);
            v17 = sub_1016A01F0(a3, v9, (a1 + 40 * v14));
            if (v16)
            {
              if (v17)
              {
                v18 = *a1;
                v19 = *(a1 + 16);
                v315 = *(a1 + 32);
                v313 = v18;
                v314 = v19;
                v20 = *v9;
                v21 = *(v9 + 1);
                *(a1 + 32) = *(v9 + 4);
                *a1 = v20;
                *(a1 + 16) = v21;
              }

              else
              {
                v52 = *a1;
                v53 = *(a1 + 16);
                v315 = *(a1 + 32);
                v313 = v52;
                v314 = v53;
                v54 = *v15;
                v55 = *(v15 + 1);
                *(a1 + 32) = *(v15 + 4);
                *a1 = v54;
                *(a1 + 16) = v55;
                v56 = v313;
                v57 = v314;
                *(v15 + 4) = v315;
                *v15 = v56;
                *(v15 + 1) = v57;
                if (!sub_1016A01F0(a3, v9, (a1 + 40 * v14)))
                {
                  goto LABEL_27;
                }

                v58 = *v15;
                v59 = *(v15 + 1);
                v315 = *(v15 + 4);
                v313 = v58;
                v314 = v59;
                v60 = *v9;
                v61 = *(v9 + 1);
                *(v15 + 4) = *(v9 + 4);
                *v15 = v60;
                *(v15 + 1) = v61;
              }

              v62 = v313;
              v63 = v314;
              *(v9 + 4) = v315;
              *v9 = v62;
              *(v9 + 1) = v63;
            }

            else if (v17)
            {
              v28 = *v15;
              v29 = *(v15 + 1);
              v315 = *(v15 + 4);
              v313 = v28;
              v314 = v29;
              v30 = *v9;
              v31 = *(v9 + 1);
              *(v15 + 4) = *(v9 + 4);
              *v15 = v30;
              *(v15 + 1) = v31;
              v32 = v313;
              v33 = v314;
              *(v9 + 4) = v315;
              *v9 = v32;
              *(v9 + 1) = v33;
              if (sub_1016A01F0(a3, (a1 + 40 * v14), a1))
              {
                v34 = *a1;
                v35 = *(a1 + 16);
                v315 = *(a1 + 32);
                v313 = v34;
                v314 = v35;
                v36 = *v15;
                v37 = *(v15 + 1);
                *(a1 + 32) = *(v15 + 4);
                *a1 = v36;
                *(a1 + 16) = v37;
                v38 = v313;
                v39 = v314;
                *(v15 + 4) = v315;
                *v15 = v38;
                *(v15 + 1) = v39;
              }
            }

LABEL_27:
            v64 = a1 + 40 * v14 - 40;
            v65 = sub_1016A01F0(a3, v64, (a1 + 40));
            v66 = sub_1016A01F0(a3, v306, v64);
            if (v65)
            {
              if (v66)
              {
                v68 = *(a1 + 56);
                v313 = *(a1 + 40);
                v67 = v313;
                v314 = v68;
                v315 = *(a1 + 72);
                v69 = v315;
                v71 = *v306;
                v70 = *(v306 + 1);
                *(a1 + 72) = *(v306 + 4);
                *(a1 + 40) = v71;
                *(a1 + 56) = v70;
                *(v306 + 4) = v69;
                *v306 = v67;
                *(v306 + 1) = v68;
              }

              else
              {
                v96 = *(a1 + 56);
                v313 = *(a1 + 40);
                v95 = v313;
                v314 = v96;
                v315 = *(a1 + 72);
                v97 = v315;
                v99 = *v64;
                v98 = *(a1 + 40 * v14 - 24);
                *(a1 + 72) = *(a1 + 40 * v14 - 8);
                *(a1 + 40) = v99;
                *(a1 + 56) = v98;
                *(a1 + 40 * v14 - 8) = v97;
                *v64 = v95;
                *(a1 + 40 * v14 - 24) = v96;
                if (sub_1016A01F0(a3, v306, v64))
                {
                  v100 = *v64;
                  v101 = *(a1 + 40 * v14 - 24);
                  v315 = *(a1 + 40 * v14 - 8);
                  v313 = v100;
                  v314 = v101;
                  v102 = *v306;
                  v103 = *(v306 + 1);
                  *(a1 + 40 * v14 - 8) = *(v306 + 4);
                  *v64 = v102;
                  *(a1 + 40 * v14 - 24) = v103;
                  v104 = v313;
                  v105 = v314;
                  *(v306 + 4) = v315;
                  *v306 = v104;
                  *(v306 + 1) = v105;
                }
              }
            }

            else if (v66)
            {
              v72 = *v64;
              v73 = *(a1 + 40 * v14 - 24);
              v315 = *(a1 + 40 * v14 - 8);
              v313 = v72;
              v314 = v73;
              v74 = *v306;
              v75 = *(v306 + 1);
              *(a1 + 40 * v14 - 8) = *(v306 + 4);
              *v64 = v74;
              *(a1 + 40 * v14 - 24) = v75;
              v76 = v313;
              v77 = v314;
              *(v306 + 4) = v315;
              *v306 = v76;
              *(v306 + 1) = v77;
              if (sub_1016A01F0(a3, v64, (a1 + 40)))
              {
                v79 = *(a1 + 56);
                v313 = *(a1 + 40);
                v78 = v313;
                v314 = v79;
                v315 = *(a1 + 72);
                v80 = v315;
                v82 = *v64;
                v81 = *(a1 + 40 * v14 - 24);
                *(a1 + 72) = *(a1 + 40 * v14 - 8);
                *(a1 + 40) = v82;
                *(a1 + 56) = v81;
                *(a1 + 40 * v14 - 8) = v80;
                *v64 = v78;
                *(a1 + 40 * v14 - 24) = v79;
              }
            }

            v106 = a1 + 40 * v14;
            v107 = sub_1016A01F0(a3, (v106 + 40), (a1 + 80));
            v108 = sub_1016A01F0(a3, v10, (v106 + 40));
            if (v107)
            {
              if (v108)
              {
                v109 = *(a1 + 80);
                v110 = *(a1 + 96);
                v313 = v109;
                v314 = v110;
                v111 = *(a1 + 112);
                v315 = v111;
                v113 = *v10;
                v112 = *(v10 + 1);
                *(a1 + 112) = *(v10 + 4);
                *(a1 + 80) = v113;
                *(a1 + 96) = v112;
              }

              else
              {
                v126 = *(a1 + 96);
                v313 = *(a1 + 80);
                v125 = v313;
                v314 = v126;
                v315 = *(a1 + 112);
                v127 = v315;
                v128 = *(v106 + 56);
                v129 = *(v106 + 40);
                *(a1 + 112) = *(v106 + 72);
                *(a1 + 80) = v129;
                *(a1 + 96) = v128;
                *(v106 + 56) = v126;
                *(v106 + 72) = v127;
                *(v106 + 40) = v125;
                if (!sub_1016A01F0(a3, v10, (v106 + 40)))
                {
                  goto LABEL_47;
                }

                v130 = *(v106 + 40);
                v131 = *(v106 + 56);
                v315 = *(v106 + 72);
                v313 = v130;
                v314 = v131;
                v132 = *v10;
                v133 = *(v10 + 1);
                *(v106 + 72) = *(v10 + 4);
                *(v106 + 56) = v133;
                *(v106 + 40) = v132;
                v109 = v313;
                v110 = v314;
                v111 = v315;
              }

              *(v10 + 4) = v111;
              *v10 = v109;
              *(v10 + 1) = v110;
            }

            else if (v108)
            {
              v114 = *(v106 + 40);
              v115 = *(v106 + 56);
              v315 = *(v106 + 72);
              v313 = v114;
              v314 = v115;
              v116 = *v10;
              v117 = *(v10 + 1);
              *(v106 + 72) = *(v10 + 4);
              *(v106 + 56) = v117;
              *(v106 + 40) = v116;
              v118 = v313;
              v119 = v314;
              *(v10 + 4) = v315;
              *v10 = v118;
              *(v10 + 1) = v119;
              if (sub_1016A01F0(a3, (v106 + 40), (a1 + 80)))
              {
                v121 = *(a1 + 96);
                v313 = *(a1 + 80);
                v120 = v313;
                v314 = v121;
                v315 = *(a1 + 112);
                v122 = v315;
                v123 = *(v106 + 56);
                v124 = *(v106 + 40);
                *(a1 + 112) = *(v106 + 72);
                *(a1 + 80) = v124;
                *(a1 + 96) = v123;
                *(v106 + 56) = v121;
                *(v106 + 72) = v122;
                *(v106 + 40) = v120;
              }
            }

LABEL_47:
            v134 = sub_1016A01F0(a3, v15, v64);
            v135 = sub_1016A01F0(a3, (v106 + 40), v15);
            if ((v134 & 1) == 0)
            {
              if (v135)
              {
                v139 = *v15;
                v140 = *(v15 + 1);
                v315 = *(v15 + 4);
                v313 = v139;
                v314 = v140;
                v141 = *(v106 + 56);
                *v15 = *(v106 + 40);
                *(v15 + 1) = v141;
                *(v15 + 4) = *(v106 + 72);
                v142 = v315;
                v143 = v313;
                *(v106 + 56) = v314;
                *(v106 + 72) = v142;
                *(v106 + 40) = v143;
                if (sub_1016A01F0(a3, v15, v64))
                {
                  v144 = *v64;
                  v145 = *(v64 + 16);
                  v315 = *(v64 + 32);
                  v313 = v144;
                  v314 = v145;
                  v146 = *(v15 + 1);
                  *v64 = *v15;
                  *(v64 + 16) = v146;
                  *(v64 + 32) = *(v15 + 4);
                  v147 = v313;
                  v148 = v314;
                  *(v15 + 4) = v315;
                  *v15 = v147;
                  *(v15 + 1) = v148;
                }
              }

              goto LABEL_56;
            }

            if (v135)
            {
              v136 = *v64;
              v137 = *(v64 + 16);
              v315 = *(v64 + 32);
              v313 = v136;
              v314 = v137;
              v138 = *(v106 + 56);
              *v64 = *(v106 + 40);
              *(v64 + 16) = v138;
              *(v64 + 32) = *(v106 + 72);
            }

            else
            {
              v149 = *v64;
              v150 = *(v64 + 16);
              v315 = *(v64 + 32);
              v313 = v149;
              v314 = v150;
              v151 = *(v15 + 1);
              *v64 = *v15;
              *(v64 + 16) = v151;
              *(v64 + 32) = *(v15 + 4);
              v152 = v313;
              v153 = v314;
              *(v15 + 4) = v315;
              *v15 = v152;
              *(v15 + 1) = v153;
              if (!sub_1016A01F0(a3, (v106 + 40), v15))
              {
LABEL_56:
                v159 = *a1;
                v160 = *(a1 + 16);
                v315 = *(a1 + 32);
                v313 = v159;
                v314 = v160;
                v161 = *v15;
                v162 = *(v15 + 1);
                *(a1 + 32) = *(v15 + 4);
                *a1 = v161;
                *(a1 + 16) = v162;
                v163 = v313;
                v164 = v314;
                *(v15 + 4) = v315;
                *v15 = v163;
                *(v15 + 1) = v164;
                goto LABEL_57;
              }

              v154 = *v15;
              v155 = *(v15 + 1);
              v315 = *(v15 + 4);
              v313 = v154;
              v314 = v155;
              v156 = *(v106 + 56);
              *v15 = *(v106 + 40);
              *(v15 + 1) = v156;
              *(v15 + 4) = *(v106 + 72);
            }

            v157 = v315;
            v158 = v313;
            *(v106 + 56) = v314;
            *(v106 + 72) = v157;
            *(v106 + 40) = v158;
            goto LABEL_56;
          }

          v22 = sub_1016A01F0(a3, a1, (a1 + 40 * v14));
          v23 = sub_1016A01F0(a3, v9, a1);
          if (v22)
          {
            if (v23)
            {
              v24 = *v15;
              v25 = *(v15 + 1);
              v315 = *(v15 + 4);
              v313 = v24;
              v314 = v25;
              v26 = *v9;
              v27 = *(v9 + 1);
              *(v15 + 4) = *(v9 + 4);
              *v15 = v26;
              *(v15 + 1) = v27;
LABEL_35:
              v93 = v313;
              v94 = v314;
              *(v9 + 4) = v315;
              *v9 = v93;
              *(v9 + 1) = v94;
              goto LABEL_57;
            }

            v83 = *v15;
            v84 = *(v15 + 1);
            v315 = *(v15 + 4);
            v313 = v83;
            v314 = v84;
            v85 = *a1;
            v86 = *(a1 + 16);
            *(v15 + 4) = *(a1 + 32);
            *v15 = v85;
            *(v15 + 1) = v86;
            v87 = v313;
            v88 = v314;
            *(a1 + 32) = v315;
            *a1 = v87;
            *(a1 + 16) = v88;
            if (sub_1016A01F0(a3, v9, a1))
            {
              v89 = *a1;
              v90 = *(a1 + 16);
              v315 = *(a1 + 32);
              v313 = v89;
              v314 = v90;
              v91 = *v9;
              v92 = *(v9 + 1);
              *(a1 + 32) = *(v9 + 4);
              *a1 = v91;
              *(a1 + 16) = v92;
              goto LABEL_35;
            }
          }

          else if (v23)
          {
            v40 = *a1;
            v41 = *(a1 + 16);
            v315 = *(a1 + 32);
            v313 = v40;
            v314 = v41;
            v42 = *v9;
            v43 = *(v9 + 1);
            *(a1 + 32) = *(v9 + 4);
            *a1 = v42;
            *(a1 + 16) = v43;
            v44 = v313;
            v45 = v314;
            *(v9 + 4) = v315;
            *v9 = v44;
            *(v9 + 1) = v45;
            if (sub_1016A01F0(a3, a1, (a1 + 40 * v14)))
            {
              v46 = *v15;
              v47 = *(v15 + 1);
              v315 = *(v15 + 4);
              v313 = v46;
              v314 = v47;
              v48 = *a1;
              v49 = *(a1 + 16);
              *(v15 + 4) = *(a1 + 32);
              *v15 = v48;
              *(v15 + 1) = v49;
              v50 = v313;
              v51 = v314;
              *(a1 + 32) = v315;
              *a1 = v50;
              *(a1 + 16) = v51;
            }
          }

LABEL_57:
          --a4;
          if (a5 & 1) != 0 || (sub_1016A01F0(a3, (a1 - 40), a1))
          {
            break;
          }

          v184 = *a1;
          v185 = *(a1 + 16);
          v312 = *(a1 + 32);
          v310 = v184;
          v311 = v185;
          if (sub_1016A01F0(a3, &v310, v9))
          {
            v11 = a1;
            a2 = v307;
            do
            {
              v11 += 40;
            }

            while ((sub_1016A01F0(a3, &v310, v11) & 1) == 0);
          }

          else
          {
            v186 = (a1 + 40);
            a2 = v307;
            do
            {
              v11 = v186;
              if (v186 >= v307)
              {
                break;
              }

              v187 = sub_1016A01F0(a3, &v310, v186);
              v186 = v11 + 40;
            }

            while (!v187);
          }

          v188 = a2;
          if (v11 < a2)
          {
            v188 = a2;
            do
            {
              v188 -= 40;
            }

            while ((sub_1016A01F0(a3, &v310, v188) & 1) != 0);
          }

          while (v11 < v188)
          {
            v189 = *v11;
            v190 = *(v11 + 1);
            v315 = *(v11 + 4);
            v313 = v189;
            v314 = v190;
            v191 = *v188;
            v192 = *(v188 + 1);
            *(v11 + 4) = *(v188 + 4);
            *v11 = v191;
            *(v11 + 1) = v192;
            v193 = v313;
            v194 = v314;
            *(v188 + 4) = v315;
            *v188 = v193;
            *(v188 + 1) = v194;
            do
            {
              v11 += 40;
            }

            while (!sub_1016A01F0(a3, &v310, v11));
            do
            {
              v188 -= 40;
            }

            while ((sub_1016A01F0(a3, &v310, v188) & 1) != 0);
          }

          v195 = v11 - 40;
          if (v11 - 40 != a1)
          {
            v196 = *v195;
            v197 = *(v11 - 24);
            *(a1 + 32) = *(v11 - 1);
            *a1 = v196;
            *(a1 + 16) = v197;
          }

          a5 = 0;
          v198 = v310;
          v199 = v311;
          *(v11 - 1) = v312;
          *v195 = v198;
          *(v11 - 24) = v199;
        }

        v165 = 0;
        v166 = *a1;
        v167 = *(a1 + 16);
        v312 = *(a1 + 32);
        v310 = v166;
        v311 = v167;
        do
        {
          v165 += 40;
        }

        while ((sub_1016A01F0(a3, (v165 + a1), &v310) & 1) != 0);
        v168 = a1 + v165;
        v169 = v307;
        v224 = v165 == 40;
        a2 = v307;
        if (v224)
        {
          v169 = v307;
          do
          {
            if (v168 >= v169)
            {
              break;
            }

            v169 -= 5;
          }

          while ((sub_1016A01F0(a3, v169, &v310) & 1) == 0);
        }

        else
        {
          do
          {
            v169 -= 5;
          }

          while (!sub_1016A01F0(a3, v169, &v310));
        }

        if (v168 >= v169)
        {
          v178 = v168 - 40;
        }

        else
        {
          v170 = v168;
          v171 = v169;
          do
          {
            v172 = *v170;
            v173 = *(v170 + 16);
            v315 = *(v170 + 32);
            v313 = v172;
            v314 = v173;
            v174 = *v171;
            v175 = *(v171 + 1);
            *(v170 + 32) = v171[4];
            *v170 = v174;
            *(v170 + 16) = v175;
            v176 = v313;
            v177 = v314;
            v171[4] = v315;
            *v171 = v176;
            *(v171 + 1) = v177;
            do
            {
              v170 += 40;
            }

            while ((sub_1016A01F0(a3, v170, &v310) & 1) != 0);
            do
            {
              v171 -= 5;
            }

            while (!sub_1016A01F0(a3, v171, &v310));
          }

          while (v170 < v171);
          v178 = v170 - 40;
        }

        if (v178 != a1)
        {
          v179 = *v178;
          v180 = *(v178 + 16);
          *(a1 + 32) = *(v178 + 32);
          *a1 = v179;
          *(a1 + 16) = v180;
        }

        v181 = v310;
        v182 = v311;
        *(v178 + 32) = v312;
        *v178 = v181;
        *(v178 + 16) = v182;
        if (v168 >= v169)
        {
          break;
        }

LABEL_80:
        sub_10169F0D0(a1, v178, a3, a4, a5 & 1);
        a5 = 0;
        v11 = (v178 + 40);
      }

      v183 = sub_1016A069C(a1, v178, a3);
      v11 = (v178 + 40);
      if (sub_1016A069C(v178 + 40, v307, a3))
      {
        break;
      }

      if (!v183)
      {
        goto LABEL_80;
      }
    }

    a2 = v178;
    if (!v183)
    {
      continue;
    }

    break;
  }
}

uint64_t sub_1016A01F0(uint64_t a1, void *a2, void *a3)
{
  v3 = a2[4];
  v4 = a3[4];
  v5 = *(v3 + 8);
  v6 = *(v4 + 8);
  v7 = v5 < v6;
  if (v5 != v6)
  {
    return v7;
  }

  v8 = *(v3 + 32);
  v9 = *(v4 + 32);
  if (v8 != v9 || *(v3 + 24) != *(v4 + 24) || *(v3 + 40) != *(v4 + 40) || *(v3 + 16) != *(v4 + 16))
  {
    v21 = *(v3 + 16);
    v22 = *(v4 + 16);
    v7 = v21 < v22;
    if (v21 == v22)
    {
      v23 = *(v3 + 24);
      v24 = *(v4 + 24);
      v7 = v23 < v24;
      if (v23 == v24)
      {
        v25 = *(v3 + 40);
        v26 = *(v4 + 40);
        v27 = v8 < v9;
        v18 = v25 == v26;
        v28 = v25 < v26;
        if (v18)
        {
          return v27;
        }

        else
        {
          return v28;
        }
      }
    }

    return v7;
  }

  v10 = *(v3 + 64);
  v11 = *(v4 + 64);
  if (vabdd_f64(v10, v11) >= 50.0)
  {
    return v10 < v11;
  }

  v12 = *(v3 + 56);
  if (v12 == 0.0)
  {
    __assert_rtn("apply", "segment_ratio.hpp", 89, "lhs.denominator() != Type(0)");
  }

  v13 = *(v4 + 56);
  if (v13 == 0.0)
  {
    __assert_rtn("apply", "segment_ratio.hpp", 90, "rhs.denominator() != Type(0)");
  }

  v10 = *(v3 + 48) / v12;
  v11 = *(v4 + 48) / v13;
  if (v10 != v11)
  {
    if ((*&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      return v10 < v11;
    }

    v34 = fabs(v10);
    v35 = fabs(v11);
    v36 = vabdd_f64(v10, v11);
    if (v34 < v35)
    {
      v34 = v35;
    }

    if (v34 < 1.0)
    {
      v34 = 1.0;
    }

    if (v36 > v34 * 2.22044605e-16)
    {
      return v10 < v11;
    }
  }

  v14 = *(*a1 + 32);
  v15 = *(*a1 + 8);
  v16 = (*(v15 + (((v14 + *a2) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((v14 + *a2) & 0xF));
  v17 = (*(v15 + (((*a3 + v14) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*a3 + v14) & 0xF));
  v18 = v16[4] == 2 && v17[4] == 2;
  if (v18)
  {

    return sub_1016A0B40(a1, a2, a3);
  }

  else
  {
    v19 = v16[10];
    v20 = v19 == 3 && v16[52] == 3;
    v31 = v17[10];
    v32 = v31 == 3 && v17[52] == 3;
    if (v20 && !v32)
    {
      return 1;
    }

    if (v20 || !v32)
    {
      v33 = v19 == 1 && v16[52] == 1;
      v37 = v31 == 1 && v17[52] == 1;
      if (v33 && !v37)
      {
        return 1;
      }

      return *a2 < *a3 && (v33 || !v37);
    }

    else
    {
      return 0;
    }
  }
}

__n128 sub_1016A04BC(__int128 *a1, __int128 *a2, __int128 *a3, __int128 *a4, uint64_t a5)
{
  v10 = sub_1016A01F0(a5, a2, a1);
  v11 = sub_1016A01F0(a5, a3, a2);
  if (v10)
  {
    if (v11)
    {
      v12 = *a1;
      v13 = a1[1];
      v14 = *(a1 + 4);
      v15 = *(a3 + 4);
      v16 = a3[1];
      *a1 = *a3;
      a1[1] = v16;
      *(a1 + 4) = v15;
LABEL_9:
      *(a3 + 4) = v14;
      *a3 = v12;
      a3[1] = v13;
      goto LABEL_10;
    }

    v27 = *a1;
    v28 = a1[1];
    v29 = *(a1 + 4);
    v30 = *(a2 + 4);
    v31 = a2[1];
    *a1 = *a2;
    a1[1] = v31;
    *(a1 + 4) = v30;
    *(a2 + 4) = v29;
    *a2 = v27;
    a2[1] = v28;
    if (sub_1016A01F0(a5, a3, a2))
    {
      v12 = *a2;
      v13 = a2[1];
      v14 = *(a2 + 4);
      v32 = *(a3 + 4);
      v33 = a3[1];
      *a2 = *a3;
      a2[1] = v33;
      *(a2 + 4) = v32;
      goto LABEL_9;
    }
  }

  else if (v11)
  {
    v17 = *a2;
    v18 = a2[1];
    v19 = *(a2 + 4);
    v20 = *(a3 + 4);
    v21 = a3[1];
    *a2 = *a3;
    a2[1] = v21;
    *(a2 + 4) = v20;
    *(a3 + 4) = v19;
    *a3 = v17;
    a3[1] = v18;
    if (sub_1016A01F0(a5, a2, a1))
    {
      v22 = *a1;
      v23 = a1[1];
      v24 = *(a1 + 4);
      v25 = *(a2 + 4);
      v26 = a2[1];
      *a1 = *a2;
      a1[1] = v26;
      *(a1 + 4) = v25;
      *(a2 + 4) = v24;
      *a2 = v22;
      a2[1] = v23;
    }
  }

LABEL_10:
  if (sub_1016A01F0(a5, a4, a3))
  {
    v35 = *a3;
    v36 = a3[1];
    v37 = *(a3 + 4);
    v38 = *(a4 + 4);
    v39 = a4[1];
    *a3 = *a4;
    a3[1] = v39;
    *(a3 + 4) = v38;
    *(a4 + 4) = v37;
    *a4 = v35;
    a4[1] = v36;
    if (sub_1016A01F0(a5, a3, a2))
    {
      v40 = *a2;
      v41 = a2[1];
      v42 = *(a2 + 4);
      v43 = *(a3 + 4);
      v44 = a3[1];
      *a2 = *a3;
      a2[1] = v44;
      *(a2 + 4) = v43;
      *(a3 + 4) = v42;
      *a3 = v40;
      a3[1] = v41;
      if (sub_1016A01F0(a5, a2, a1))
      {
        result = *a1;
        v45 = a1[1];
        v46 = *(a1 + 4);
        v47 = *(a2 + 4);
        v48 = a2[1];
        *a1 = *a2;
        a1[1] = v48;
        *(a1 + 4) = v47;
        *(a2 + 4) = v46;
        *a2 = result;
        a2[1] = v45;
      }
    }
  }

  return result;
}

BOOL sub_1016A069C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 3);
  if (v6 > 2)
  {
    switch(v6)
    {
      case 3:
        v7 = a2 - 40;
        v22 = sub_1016A01F0(a3, (a1 + 40), a1);
        v23 = sub_1016A01F0(a3, v7, (a1 + 40));
        if (v22)
        {
          if (v23)
          {
LABEL_15:
            v24 = *a1;
            v25 = *(a1 + 16);
            v26 = *(a1 + 32);
            v27 = *(v7 + 32);
            v28 = *(v7 + 16);
            *a1 = *v7;
            *(a1 + 16) = v28;
            *(a1 + 32) = v27;
LABEL_16:
            *(v7 + 32) = v26;
            result = 1;
            *v7 = v24;
            *(v7 + 16) = v25;
            return result;
          }

          v54 = *(a1 + 32);
          v56 = *a1;
          v55 = *(a1 + 16);
          v57 = *(a1 + 56);
          *a1 = *(a1 + 40);
          *(a1 + 16) = v57;
          *(a1 + 32) = *(a1 + 72);
          *(a1 + 40) = v56;
          *(a1 + 56) = v55;
          *(a1 + 72) = v54;
          if (sub_1016A01F0(a3, v7, (a1 + 40)))
          {
            v24 = *(a1 + 40);
            v25 = *(a1 + 56);
            v26 = *(a1 + 72);
            v58 = *(v7 + 32);
            v59 = *(v7 + 16);
            *(a1 + 40) = *v7;
            *(a1 + 56) = v59;
            *(a1 + 72) = v58;
            goto LABEL_16;
          }

          return 1;
        }

        if (!v23)
        {
          return 1;
        }

        v37 = *(a1 + 40);
        v38 = *(a1 + 56);
        v39 = *(a1 + 72);
        v40 = *(v7 + 32);
        v41 = *(v7 + 16);
        *(a1 + 40) = *v7;
        *(a1 + 56) = v41;
        *(a1 + 72) = v40;
        *(v7 + 32) = v39;
        *v7 = v37;
        *(v7 + 16) = v38;
        break;
      case 4:
        sub_1016A04BC(a1, (a1 + 40), (a1 + 80), (a2 - 40), a3);
        return 1;
      case 5:
        v8 = a2 - 40;
        sub_1016A04BC(a1, (a1 + 40), (a1 + 80), (a1 + 120), a3);
        if (!sub_1016A01F0(a3, v8, (a1 + 120)))
        {
          return 1;
        }

        v9 = *(a1 + 120);
        v10 = *(a1 + 136);
        v11 = *(a1 + 152);
        v12 = *(v8 + 32);
        v13 = *(v8 + 16);
        *(a1 + 120) = *v8;
        *(a1 + 136) = v13;
        *(a1 + 152) = v12;
        *(v8 + 32) = v11;
        *v8 = v9;
        *(v8 + 16) = v10;
        if (!sub_1016A01F0(a3, (a1 + 120), (a1 + 80)))
        {
          return 1;
        }

        v14 = *(a1 + 112);
        v16 = *(a1 + 80);
        v15 = *(a1 + 96);
        v17 = *(a1 + 136);
        *(a1 + 80) = *(a1 + 120);
        *(a1 + 96) = v17;
        *(a1 + 112) = *(a1 + 152);
        *(a1 + 120) = v16;
        *(a1 + 136) = v15;
        *(a1 + 152) = v14;
        if (!sub_1016A01F0(a3, (a1 + 80), (a1 + 40)))
        {
          return 1;
        }

        v18 = *(a1 + 72);
        v19 = *(a1 + 56);
        v20 = *(a1 + 40);
        v21 = *(a1 + 96);
        *(a1 + 40) = *(a1 + 80);
        *(a1 + 56) = v21;
        *(a1 + 72) = *(a1 + 112);
        *(a1 + 80) = v20;
        *(a1 + 96) = v19;
        *(a1 + 112) = v18;
        break;
      default:
        goto LABEL_17;
    }

    if (sub_1016A01F0(a3, (a1 + 40), a1))
    {
      v42 = *(a1 + 32);
      v44 = *a1;
      v43 = *(a1 + 16);
      v45 = *(a1 + 56);
      *a1 = *(a1 + 40);
      *(a1 + 16) = v45;
      *(a1 + 32) = *(a1 + 72);
      *(a1 + 40) = v44;
      *(a1 + 56) = v43;
      result = 1;
      *(a1 + 72) = v42;
      return result;
    }

    return 1;
  }

  if (v6 < 2)
  {
    return 1;
  }

  if (v6 == 2)
  {
    v7 = a2 - 40;
    if (!sub_1016A01F0(a3, (a2 - 40), a1))
    {
      return 1;
    }

    goto LABEL_15;
  }

LABEL_17:
  v30 = (a1 + 80);
  v31 = sub_1016A01F0(a3, (a1 + 40), a1);
  v32 = sub_1016A01F0(a3, (a1 + 80), (a1 + 40));
  if (v31)
  {
    if (v32)
    {
      v33 = *(a1 + 32);
      v35 = *a1;
      v34 = *(a1 + 16);
      v36 = *(a1 + 96);
      *a1 = *v30;
      *(a1 + 16) = v36;
      *(a1 + 32) = *(a1 + 112);
    }

    else
    {
      v60 = *(a1 + 32);
      v62 = *a1;
      v61 = *(a1 + 16);
      v63 = *(a1 + 56);
      *a1 = *(a1 + 40);
      *(a1 + 16) = v63;
      *(a1 + 32) = *(a1 + 72);
      *(a1 + 40) = v62;
      *(a1 + 56) = v61;
      *(a1 + 72) = v60;
      if (!sub_1016A01F0(a3, (a1 + 80), (a1 + 40)))
      {
        goto LABEL_33;
      }

      v33 = *(a1 + 72);
      v34 = *(a1 + 56);
      v35 = *(a1 + 40);
      v64 = *(a1 + 96);
      *(a1 + 40) = *v30;
      *(a1 + 56) = v64;
      *(a1 + 72) = *(a1 + 112);
    }

    *v30 = v35;
    *(a1 + 96) = v34;
    *(a1 + 112) = v33;
  }

  else if (v32)
  {
    v46 = *(a1 + 72);
    v47 = *(a1 + 56);
    v48 = *(a1 + 40);
    v49 = *(a1 + 96);
    *(a1 + 40) = *v30;
    *(a1 + 56) = v49;
    *(a1 + 72) = *(a1 + 112);
    *v30 = v48;
    *(a1 + 96) = v47;
    *(a1 + 112) = v46;
    if (sub_1016A01F0(a3, (a1 + 40), a1))
    {
      v50 = *(a1 + 32);
      v52 = *a1;
      v51 = *(a1 + 16);
      v53 = *(a1 + 56);
      *a1 = *(a1 + 40);
      *(a1 + 16) = v53;
      *(a1 + 32) = *(a1 + 72);
      *(a1 + 40) = v52;
      *(a1 + 56) = v51;
      *(a1 + 72) = v50;
    }
  }

LABEL_33:
  v65 = a1 + 120;
  if (a1 + 120 == a2)
  {
    return 1;
  }

  v66 = 0;
  v67 = 0;
  while (1)
  {
    if (sub_1016A01F0(a3, v65, v30))
    {
      v68 = *(v65 + 16);
      v74 = *v65;
      v75 = v68;
      v76 = *(v65 + 32);
      v69 = v66;
      while (1)
      {
        v70 = a1 + v69;
        v71 = *(a1 + v69 + 96);
        *(v70 + 120) = *(a1 + v69 + 80);
        *(v70 + 136) = v71;
        *(v70 + 152) = *(a1 + v69 + 112);
        if (v69 == -80)
        {
          break;
        }

        v69 -= 40;
        if ((sub_1016A01F0(a3, &v74, (v70 + 40)) & 1) == 0)
        {
          v72 = a1 + v69 + 120;
          goto LABEL_41;
        }
      }

      v72 = a1;
LABEL_41:
      v73 = v75;
      *v72 = v74;
      *(v72 + 16) = v73;
      *(v72 + 32) = v76;
      if (++v67 == 8)
      {
        return v65 + 40 == a2;
      }
    }

    v30 = v65;
    v66 += 40;
    v65 += 40;
    if (v65 == a2)
    {
      return 1;
    }
  }
}

BOOL sub_1016A0B40(uint64_t a1, void *a2, void *a3)
{
  v25 = 0uLL;
  v24 = 0uLL;
  v23 = 0uLL;
  v22 = 0uLL;
  v21 = 0uLL;
  v20 = 0uLL;
  v6 = *(a1 + 8);
  v7 = *(a1 + 16);
  v8 = a2[4];
  sub_1016A0CB0(v6, v7, (v8 + 8), 0, &v25);
  sub_1016A0CB0(v6, v7, (v8 + 8), 1, &v24);
  v9 = *(a1 + 8);
  v10 = *(a1 + 16);
  v11 = a2[3];
  sub_1016A0CB0(v9, v10, v11, 0, &v23);
  sub_1016A0CB0(v9, v10, v11, 1, &v22);
  v13 = *(a1 + 8);
  v12 = *(a1 + 16);
  v14 = a3[3];
  sub_1016A0CB0(v13, v12, v14, 0, &v21);
  sub_1016A0CB0(v13, v12, v14, 1, &v20);
  LODWORD(v12) = sub_10169A37C(v25.n128_f64, v24.n128_f64, v22.n128_f64);
  v15 = sub_10169A37C(v25.n128_f64, v24.n128_f64, v20.n128_f64);
  v16 = v12 < v15;
  if (v12 == v15)
  {
    v17 = sub_10169A37C(v23.n128_f64, v22.n128_f64, v20.n128_f64);
    v18 = sub_10169A37C(v21.n128_f64, v20.n128_f64, v22.n128_f64);
    v16 = v18 < v17;
    if (v18 == v17)
    {
      return *a2 < *a3;
    }
  }

  return v16;
}

__n128 sub_1016A0CB0(uint64_t *a1, uint64_t *a2, void *a3, uint64_t a4, __n128 *a5)
{
  if (*a3 >= 2uLL)
  {
    __assert_rtn("copy_segment_point", "copy_segment_point.hpp", 317, "seg_id.source_index == 0 || seg_id.source_index == 1");
  }

  v5 = a3[2];
  if ((*a3 & 1) == 0)
  {
    if ((v5 & 0x8000000000000000) == 0)
    {
      v9 = a1[3];
      if (0xAAAAAAAAAAAAAAABLL * ((a1[4] - v9) >> 3) < v5)
      {
        goto LABEL_16;
      }

      a1 = (v9 + 24 * v5);
    }

    v7 = *a1;
    v8 = a1[1];
    goto LABEL_11;
  }

  if ((v5 & 0x8000000000000000) == 0)
  {
    v6 = a2[3];
    if (0xAAAAAAAAAAAAAAABLL * ((a2[4] - v6) >> 3) >= v5)
    {
      a2 = (v6 + 24 * v5);
      goto LABEL_6;
    }

LABEL_16:
    __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
  }

LABEL_6:
  v7 = *a2;
  v8 = a2[1];
LABEL_11:
  v10 = (v8 - v7) >> 4;
  v11 = (a3[3] + a4) % (v10 - 1);
  v12 = ((v10 - 1) & (v11 >> 63)) + v11;
  if (v12 < 0 || v12 >= v10)
  {
    __assert_rtn("apply", "copy_segment_point.hpp", 74, "target >= 0 && std::size_t(target) < boost::size(view)");
  }

  result = *(v7 + 16 * v12);
  *a5 = result;
  return result;
}

void sub_1016A0DD4(uint64_t a1, double *a2)
{
  v4 = *a1;
  v5 = *(a1 + 8);
  v6 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * ((v5 - v4) >> 4));
  v7 = (a1 + 24);
  *&v33 = a1 + 24;
  *(&v33 + 1) = a2;
  v34 = a1 + 56;
  if (v5 == v4)
  {
    v8 = 0;
  }

  else
  {
    v8 = v6;
  }

  sub_1016A15A8(v4, v5, &v33, v8, 1);
  v9 = *a1;
  v10 = *(a1 + 8);
  if (v10 != *a1)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0.0;
    while (!v12)
    {
LABEL_22:
      v9[v11 + 2] = v13;
      ++v12;
      v11 += 14;
      if (v12 >= 0x6DB6DB6DB6DB6DB7 * ((v10 - v9) >> 4))
      {
        return;
      }
    }

    v14 = &v9[v11];
    v15 = &v9[v11 - 14];
    v16 = sub_10169A37C((a1 + 24), a2, v15);
    v17 = sub_10169A37C((a1 + 24), a2, v14);
    if (!(v16 | v17))
    {
      v18 = *(v14 - 7);
      v33 = *v7;
      v19 = *a2;
      v35 = v18;
      v36 = v19;
      v20 = sub_1016A3B70(&v33, &v36, &v35);
      v21 = *v14;
      v33 = *v7;
      v22 = *a2;
      v35 = v21;
      v36 = v22;
      v23 = v20 < sub_1016A3B70(&v33, &v36, &v35);
      goto LABEL_18;
    }

    v24 = v17;
    if (!v16 && (v25 = *v15, v33 = *v7, v26 = *a2, v35 = v25, v36 = v26, sub_1016A3B70(&v33, &v36, &v35) == -1))
    {
      v32 = 1;
    }

    else
    {
      if (v24 || (v27 = *v14, v33 = *v7, v28 = *a2, v35 = v27, v36 = v28, sub_1016A3B70(&v33, &v36, &v35) != -1))
      {
        v23 = v16 < v24;
        if (v16 != v24)
        {
LABEL_18:
          v32 = v23;
          goto LABEL_21;
        }

        v29 = sub_10169A37C(a2, v15, v14);
        if (v29)
        {
          v30 = v29;
          v31 = sub_10169A37C(a2, v14, v15);
          if (v30 + v31)
          {
            v23 = 0;
          }

          else
          {
            v23 = v31 < v30;
          }

          goto LABEL_18;
        }
      }

      v32 = 0;
    }

LABEL_21:
    *&v13 += v32;
    v9 = *a1;
    v10 = *(a1 + 8);
    goto LABEL_22;
  }
}

double sub_1016A1008(uint64_t a1, double *a2, int *a3, uint64_t a4, int a5, uint64_t *a6, uint64_t *a7, int a8)
{
  v48 = 0uLL;
  v47 = 0uLL;
  v46 = 0uLL;
  sub_1016A0CB0(a6, a7, a3 + 1, 0, &v48);
  sub_1016A0CB0(a6, a7, a3 + 1, 1, &v47);
  sub_1016A0CB0(a6, a7, a3 + 1, 2, &v46);
  v16 = *(a3 + 6);
  v17 = *(a3 + 7);
  if (v16 == v17)
  {
    goto LABEL_2;
  }

  if ((*&v16 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v17 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    goto LABEL_11;
  }

  v19 = fabs(v16);
  v20 = fabs(v17);
  v21 = vabdd_f64(v16, v17);
  if (v19 >= v20)
  {
    v22 = v19;
  }

  else
  {
    v22 = v20;
  }

  if (v22 < 1.0)
  {
    v22 = 1.0;
  }

  if (v21 <= v22 * 2.22044605e-16)
  {
LABEL_2:
    v18 = &v46;
  }

  else
  {
LABEL_11:
    v18 = &v47;
  }

  v23 = v18->n128_f64[0];
  v24 = v18->n128_f64[1];
  v25 = -1;
  v27 = v48.n128_f64[1];
  v26 = v48.n128_f64[0];
  while (1)
  {
    v29 = *a2;
    v28 = a2[1];
    v30 = fabs(v26);
    v31 = fabs(*a2);
    v32 = fabs(v27);
    v33 = fabs(v28);
    if (v30 < v31)
    {
      v30 = v31;
    }

    if (v30 < v32)
    {
      v30 = v32;
    }

    if (v30 < v33)
    {
      v30 = v33;
    }

    if (v30 < 1.0)
    {
      v30 = 1.0;
    }

    v34 = v30 * 1000000000.0;
    if (v26 != v29 && ((*&v26 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v29 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || vabdd_f64(v26, v29) > v34 * 2.22044605e-16))
    {
      break;
    }

    if (v27 == v28)
    {
      v35 = 1;
    }

    else
    {
      if ((*&v27 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v28 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
      {
        break;
      }

      v35 = vabdd_f64(v27, v28) <= v34 * 2.22044605e-16;
    }

    if (v25 + 1 < -9 || !v35)
    {
      break;
    }

    v49 = 0uLL;
    sub_1016A0CB0(a6, a7, a3 + 1, v25, &v49);
    v27 = v49.n128_f64[1];
    v26 = v49.n128_f64[0];
    --v25;
  }

  v48.n128_f64[0] = v26;
  v48.n128_f64[1] = v27;
  for (i = 1; ; ++i)
  {
    v37 = fabs(v23);
    v38 = fabs(v29);
    v39 = fabs(v24);
    v40 = fabs(v28);
    if (v37 < v38)
    {
      v37 = v38;
    }

    if (v37 < v39)
    {
      v37 = v39;
    }

    if (v37 < v40)
    {
      v37 = v40;
    }

    if (v37 < 1.0)
    {
      v37 = 1.0;
    }

    v41 = v37 * 1000000000.0;
    if (v23 != v29 && ((*&v23 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v29 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || vabdd_f64(v23, v29) > v41 * 2.22044605e-16))
    {
      break;
    }

    if (v24 == v28)
    {
      v42 = 1;
    }

    else
    {
      if ((*&v24 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v28 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
      {
        break;
      }

      v42 = vabdd_f64(v24, v28) <= v41 * 2.22044605e-16;
    }

    if ((i - 1) > 9 || !v42)
    {
      break;
    }

    v49 = 0uLL;
    sub_1016A0CB0(a6, a7, a3 + 1, i, &v49);
    v24 = v49.n128_f64[1];
    v23 = v49.n128_f64[0];
    v29 = *a2;
    v28 = a2[1];
  }

  v43 = *a3;
  v49 = v48;
  v50 = xmmword_1018FE260;
  v51 = a4;
  v52 = a5;
  memset(v53, 0, sizeof(v53));
  v54 = v43;
  v55 = *(a3 + 2);
  v56 = *(a3 + 6);
  v57 = *(a3 + 5);
  sub_1016A143C(a1, &v49);
  if (a8)
  {
    *(a1 + 24) = v48;
    ++*(a1 + 40);
  }

  v44 = *a3;
  v49.n128_f64[0] = v23;
  v49.n128_f64[1] = v24;
  v50 = xmmword_1018FE260;
  v51 = a4;
  v52 = a5;
  v53[0] = 1;
  *&v53[1] = 0uLL;
  v54 = v44;
  v55 = *(a3 + 2);
  v56 = *(a3 + 6);
  v57 = *(a3 + 5);
  sub_1016A143C(a1, &v49);
  return v26;
}

void sub_1016A143C(uint64_t a1, _OWORD *a2)
{
  v3 = *(a1 + 8);
  v4 = *(a1 + 16);
  if (v3 >= v4)
  {
    v11 = *a1;
    v12 = v3 - *a1;
    v13 = 0x6DB6DB6DB6DB6DB7 * (v12 >> 4) + 1;
    if (v13 > 0x249249249249249)
    {
      sub_1000CE3D4();
    }

    v14 = 0x6DB6DB6DB6DB6DB7 * ((v4 - v11) >> 4);
    if (2 * v14 > v13)
    {
      v13 = 2 * v14;
    }

    if (v14 >= 0x124924924924924)
    {
      v15 = 0x249249249249249;
    }

    else
    {
      v15 = v13;
    }

    if (v15)
    {
      if (v15 <= 0x249249249249249)
      {
        operator new();
      }

      sub_100013D10();
    }

    v16 = a2[5];
    v17 = (16 * (v12 >> 4));
    v17[4] = a2[4];
    v17[5] = v16;
    v17[6] = a2[6];
    v18 = a2[1];
    *v17 = *a2;
    v17[1] = v18;
    v19 = a2[3];
    v17[2] = a2[2];
    v17[3] = v19;
    v10 = v17 + 7;
    v20 = v17 - v12;
    memcpy(v17 - v12, v11, v12);
    *a1 = v20;
    *(a1 + 8) = v10;
    *(a1 + 16) = 0;
    if (v11)
    {
      operator delete(v11);
    }
  }

  else
  {
    v5 = *a2;
    v6 = a2[2];
    v3[1] = a2[1];
    v3[2] = v6;
    *v3 = v5;
    v7 = a2[3];
    v8 = a2[4];
    v9 = a2[6];
    v3[5] = a2[5];
    v3[6] = v9;
    v3[3] = v7;
    v3[4] = v8;
    v10 = v3 + 7;
  }

  *(a1 + 8) = v10;
}

void sub_1016A15A8(double *a1, __int128 *a2, double **a3, uint64_t a4, char a5)
{
  while (2)
  {
    v8 = a2 - 7;
    v9 = a2 - 14;
    v10 = a2 - 21;
    v11 = a1;
    v666 = a2;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v11;
          v12 = a2 - v11;
          v13 = 0x6DB6DB6DB6DB6DB7 * ((a2 - v11) >> 4);
          if (v13 > 2)
          {
            switch(v13)
            {
              case 3:
                v484 = sub_1016A2E60(a3, v11 + 14, v11);
                v485 = sub_1016A2E60(a3, v8, v11 + 14);
                if (v484)
                {
                  if (v485)
                  {
                    goto LABEL_110;
                  }

                  v644 = *v11;
                  v645 = *(v11 + 2);
                  v677 = *(v11 + 1);
                  v678 = v645;
                  v676 = v644;
                  v646 = *(v11 + 3);
                  v647 = *(v11 + 4);
                  v648 = *(v11 + 6);
                  v681 = *(v11 + 5);
                  v682 = v648;
                  v679 = v646;
                  v680 = v647;
                  v649 = *(v11 + 12);
                  *(v11 + 4) = *(v11 + 11);
                  *(v11 + 5) = v649;
                  *(v11 + 6) = *(v11 + 13);
                  v650 = *(v11 + 8);
                  *v11 = *(v11 + 7);
                  *(v11 + 1) = v650;
                  v651 = *(v11 + 10);
                  *(v11 + 2) = *(v11 + 9);
                  *(v11 + 3) = v651;
                  v652 = v677;
                  *(v11 + 7) = v676;
                  *(v11 + 8) = v652;
                  v653 = v678;
                  v654 = v679;
                  v655 = v682;
                  *(v11 + 12) = v681;
                  *(v11 + 13) = v655;
                  v656 = v680;
                  *(v11 + 10) = v654;
                  *(v11 + 11) = v656;
                  *(v11 + 9) = v653;
                  if (!sub_1016A2E60(a3, v8, v11 + 14))
                  {
                    return;
                  }

                  v657 = *(v11 + 12);
                  v680 = *(v11 + 11);
                  v681 = v657;
                  v682 = *(v11 + 13);
                  v658 = *(v11 + 8);
                  v676 = *(v11 + 7);
                  v677 = v658;
                  v659 = *(v11 + 10);
                  v678 = *(v11 + 9);
                  v679 = v659;
                  v661 = v8[3];
                  v660 = v8[4];
                  v662 = v8[6];
                  *(v11 + 12) = v8[5];
                  *(v11 + 13) = v662;
                  *(v11 + 10) = v661;
                  *(v11 + 11) = v660;
                  v664 = v8[1];
                  v663 = v8[2];
                  *(v11 + 7) = *v8;
                  *(v11 + 8) = v664;
                  *(v11 + 9) = v663;
LABEL_111:
                  v496 = v676;
                  v497 = v678;
                  v8[1] = v677;
                  v8[2] = v497;
                  *v8 = v496;
                  v498 = v679;
                  v499 = v680;
                  v500 = v682;
                  v8[5] = v681;
                  v8[6] = v500;
                  v8[3] = v498;
                  v8[4] = v499;
                  return;
                }

                if (!v485)
                {
                  return;
                }

                v601 = *(v11 + 12);
                v680 = *(v11 + 11);
                v681 = v601;
                v682 = *(v11 + 13);
                v602 = *(v11 + 8);
                v676 = *(v11 + 7);
                v677 = v602;
                v603 = *(v11 + 10);
                v678 = *(v11 + 9);
                v679 = v603;
                v605 = v8[3];
                v604 = v8[4];
                v606 = v8[6];
                *(v11 + 12) = v8[5];
                *(v11 + 13) = v606;
                *(v11 + 10) = v605;
                *(v11 + 11) = v604;
                v608 = v8[1];
                v607 = v8[2];
                *(v11 + 7) = *v8;
                *(v11 + 8) = v608;
                *(v11 + 9) = v607;
                v609 = v676;
                v610 = v678;
                v8[1] = v677;
                v8[2] = v610;
                *v8 = v609;
                v611 = v679;
                v612 = v680;
                v613 = v682;
                v8[5] = v681;
                v8[6] = v613;
                v8[3] = v611;
                v8[4] = v612;
LABEL_167:
                if (sub_1016A2E60(a3, v11 + 14, v11))
                {
                  v614 = *v11;
                  v615 = *(v11 + 2);
                  v677 = *(v11 + 1);
                  v678 = v615;
                  v676 = v614;
                  v616 = *(v11 + 3);
                  v617 = *(v11 + 4);
                  v618 = *(v11 + 6);
                  v681 = *(v11 + 5);
                  v682 = v618;
                  v679 = v616;
                  v680 = v617;
                  v619 = *(v11 + 12);
                  *(v11 + 4) = *(v11 + 11);
                  *(v11 + 5) = v619;
                  *(v11 + 6) = *(v11 + 13);
                  v620 = *(v11 + 8);
                  *v11 = *(v11 + 7);
                  *(v11 + 1) = v620;
                  v621 = *(v11 + 10);
                  *(v11 + 2) = *(v11 + 9);
                  *(v11 + 3) = v621;
                  v622 = v677;
                  *(v11 + 7) = v676;
                  *(v11 + 8) = v622;
                  v623 = v678;
                  v624 = v679;
                  v625 = v682;
                  *(v11 + 12) = v681;
                  *(v11 + 13) = v625;
                  v626 = v680;
                  *(v11 + 10) = v624;
                  *(v11 + 11) = v626;
                  *(v11 + 9) = v623;
                }

                return;
              case 4:

                sub_1016A3054(v11, v11 + 14, v11 + 28, v8, a3);
                return;
              case 5:
                sub_1016A3054(v11, v11 + 14, v11 + 28, v11 + 42, a3);
                if (!sub_1016A2E60(a3, v8, v11 + 42))
                {
                  return;
                }

                v442 = *(v11 + 26);
                v680 = *(v11 + 25);
                v681 = v442;
                v682 = *(v11 + 27);
                v443 = *(v11 + 22);
                v676 = *(v11 + 21);
                v677 = v443;
                v444 = *(v11 + 24);
                v678 = *(v11 + 23);
                v679 = v444;
                v446 = v8[3];
                v445 = v8[4];
                v447 = v8[6];
                *(v11 + 26) = v8[5];
                *(v11 + 27) = v447;
                *(v11 + 24) = v446;
                *(v11 + 25) = v445;
                v449 = v8[1];
                v448 = v8[2];
                *(v11 + 21) = *v8;
                *(v11 + 22) = v449;
                *(v11 + 23) = v448;
                v450 = v676;
                v451 = v678;
                v8[1] = v677;
                v8[2] = v451;
                *v8 = v450;
                v452 = v679;
                v453 = v680;
                v454 = v682;
                v8[5] = v681;
                v8[6] = v454;
                v8[3] = v452;
                v8[4] = v453;
                if (!sub_1016A2E60(a3, v11 + 42, v11 + 28))
                {
                  return;
                }

                v455 = *(v11 + 19);
                v680 = *(v11 + 18);
                v681 = v455;
                v456 = *(v11 + 21);
                v682 = *(v11 + 20);
                v457 = *(v11 + 15);
                v676 = *(v11 + 14);
                v677 = v457;
                v458 = *(v11 + 17);
                v678 = *(v11 + 16);
                v679 = v458;
                v459 = *(v11 + 22);
                v460 = *(v11 + 23);
                *(v11 + 14) = v456;
                *(v11 + 15) = v459;
                v462 = *(v11 + 26);
                v461 = *(v11 + 27);
                v463 = *(v11 + 24);
                *(v11 + 18) = *(v11 + 25);
                *(v11 + 19) = v462;
                *(v11 + 16) = v460;
                *(v11 + 17) = v463;
                v464 = v676;
                v465 = v678;
                v466 = v679;
                *(v11 + 22) = v677;
                *(v11 + 23) = v465;
                *(v11 + 20) = v461;
                *(v11 + 21) = v464;
                v467 = v680;
                v468 = v682;
                *(v11 + 26) = v681;
                *(v11 + 27) = v468;
                *(v11 + 24) = v466;
                *(v11 + 25) = v467;
                if (!sub_1016A2E60(a3, v11 + 28, v11 + 14))
                {
                  return;
                }

                v469 = *(v11 + 12);
                v680 = *(v11 + 11);
                v681 = v469;
                v470 = *(v11 + 14);
                v682 = *(v11 + 13);
                v471 = *(v11 + 8);
                v676 = *(v11 + 7);
                v677 = v471;
                v472 = *(v11 + 10);
                v678 = *(v11 + 9);
                v679 = v472;
                v473 = *(v11 + 15);
                v474 = *(v11 + 16);
                *(v11 + 7) = v470;
                *(v11 + 8) = v473;
                v476 = *(v11 + 19);
                v475 = *(v11 + 20);
                v477 = *(v11 + 17);
                *(v11 + 11) = *(v11 + 18);
                *(v11 + 12) = v476;
                *(v11 + 9) = v474;
                *(v11 + 10) = v477;
                v478 = v676;
                v479 = v678;
                v480 = v679;
                *(v11 + 15) = v677;
                *(v11 + 16) = v479;
                *(v11 + 13) = v475;
                *(v11 + 14) = v478;
                v481 = v680;
                v482 = v682;
                *(v11 + 19) = v681;
                *(v11 + 20) = v482;
                *(v11 + 17) = v480;
                *(v11 + 18) = v481;
                goto LABEL_167;
            }
          }

          else
          {
            if (v13 < 2)
            {
              return;
            }

            if (v13 == 2)
            {
              if (!sub_1016A2E60(a3, v8, v11))
              {
                return;
              }

LABEL_110:
              v486 = *v11;
              v487 = *(v11 + 2);
              v677 = *(v11 + 1);
              v678 = v487;
              v676 = v486;
              v488 = *(v11 + 3);
              v489 = *(v11 + 4);
              v490 = *(v11 + 6);
              v681 = *(v11 + 5);
              v682 = v490;
              v679 = v488;
              v680 = v489;
              v491 = v8[6];
              v493 = v8[3];
              v492 = v8[4];
              *(v11 + 5) = v8[5];
              *(v11 + 6) = v491;
              *(v11 + 3) = v493;
              *(v11 + 4) = v492;
              v494 = *v8;
              v495 = v8[2];
              *(v11 + 1) = v8[1];
              *(v11 + 2) = v495;
              *v11 = v494;
              goto LABEL_111;
            }
          }

          if (v12 <= 2687)
          {
            v501 = v11 + 14;
            v502 = v11 == a2 || v501 == a2;
            v503 = v502;
            if (a5)
            {
              if ((v503 & 1) == 0)
              {
                v504 = 0;
                v505 = v11;
                do
                {
                  v506 = v505;
                  v505 = v501;
                  if (sub_1016A2E60(a3, v501, v506))
                  {
                    v507 = *v505;
                    v508 = *(v505 + 2);
                    v677 = *(v505 + 1);
                    v678 = v508;
                    v676 = v507;
                    v509 = *(v505 + 3);
                    v510 = *(v505 + 4);
                    v511 = *(v505 + 6);
                    v681 = *(v505 + 5);
                    v682 = v511;
                    v679 = v509;
                    v680 = v510;
                    v512 = v504;
                    while (1)
                    {
                      v513 = (v11 + v512);
                      v514 = *(v11 + v512 + 80);
                      v513[11] = *(v11 + v512 + 64);
                      v513[12] = v514;
                      v513[13] = *(v11 + v512 + 96);
                      v515 = *(v11 + v512 + 16);
                      v513[7] = *(v11 + v512);
                      v513[8] = v515;
                      v516 = *(v11 + v512 + 48);
                      v513[9] = *(v11 + v512 + 32);
                      v513[10] = v516;
                      if (!v512)
                      {
                        break;
                      }

                      v512 -= 112;
                      if ((sub_1016A2E60(a3, &v676, (v11 + v512)) & 1) == 0)
                      {
                        v517 = (v11 + v512 + 112);
                        goto LABEL_130;
                      }
                    }

                    v517 = v11;
LABEL_130:
                    v518 = v676;
                    v519 = v678;
                    *(v517 + 1) = v677;
                    *(v517 + 2) = v519;
                    *v517 = v518;
                    v520 = v679;
                    v521 = v680;
                    v522 = v682;
                    *(v517 + 5) = v681;
                    *(v517 + 6) = v522;
                    *(v517 + 3) = v520;
                    *(v517 + 4) = v521;
                    a2 = v666;
                  }

                  v501 = v505 + 14;
                  v504 += 112;
                }

                while (v505 + 14 != a2);
              }
            }

            else if ((v503 & 1) == 0)
            {
              v627 = v11 - 14;
              do
              {
                v628 = a1;
                a1 = v501;
                if (sub_1016A2E60(a3, v501, v628))
                {
                  v629 = *a1;
                  v630 = *(a1 + 2);
                  v677 = *(a1 + 1);
                  v678 = v630;
                  v676 = v629;
                  v631 = *(a1 + 3);
                  v632 = *(a1 + 4);
                  v633 = *(a1 + 6);
                  v681 = *(a1 + 5);
                  v682 = v633;
                  v679 = v631;
                  v680 = v632;
                  v634 = v627;
                  do
                  {
                    v635 = *(v634 + 12);
                    *(v634 + 18) = *(v634 + 11);
                    *(v634 + 19) = v635;
                    *(v634 + 20) = *(v634 + 13);
                    v636 = *(v634 + 8);
                    *(v634 + 14) = *(v634 + 7);
                    *(v634 + 15) = v636;
                    v637 = *(v634 + 10);
                    *(v634 + 16) = *(v634 + 9);
                    *(v634 + 17) = v637;
                    v638 = sub_1016A2E60(a3, &v676, v634);
                    v634 -= 14;
                  }

                  while ((v638 & 1) != 0);
                  v639 = v676;
                  v640 = v678;
                  *(v634 + 15) = v677;
                  *(v634 + 16) = v640;
                  *(v634 + 14) = v639;
                  v641 = v679;
                  v642 = v680;
                  v643 = v682;
                  *(v634 + 19) = v681;
                  *(v634 + 20) = v643;
                  *(v634 + 17) = v641;
                  *(v634 + 18) = v642;
                }

                v501 = a1 + 14;
                v627 += 14;
              }

              while (a1 + 14 != a2);
            }

            return;
          }

          if (!a4)
          {
            if (v11 != a2)
            {
              v523 = (v13 - 2) >> 1;
              v668 = v523;
              do
              {
                v524 = v523;
                if (v668 >= v523)
                {
                  v525 = (2 * v523) | 1;
                  v526 = &a1[14 * v525];
                  if (2 * v523 + 2 < v13 && sub_1016A2E60(a3, &a1[14 * v525], v526 + 14))
                  {
                    v526 += 14;
                    v525 = 2 * v524 + 2;
                  }

                  v527 = &a1[14 * v524];
                  if ((sub_1016A2E60(a3, v526, v527) & 1) == 0)
                  {
                    v528 = *v527;
                    v529 = *(v527 + 2);
                    v677 = *(v527 + 1);
                    v678 = v529;
                    v676 = v528;
                    v530 = *(v527 + 3);
                    v531 = *(v527 + 4);
                    v532 = *(v527 + 6);
                    v681 = *(v527 + 5);
                    v682 = v532;
                    v679 = v530;
                    v680 = v531;
                    do
                    {
                      v533 = v526;
                      v534 = *v526;
                      v535 = *(v526 + 2);
                      *(v527 + 1) = *(v526 + 1);
                      *(v527 + 2) = v535;
                      *v527 = v534;
                      v536 = *(v526 + 3);
                      v537 = *(v526 + 4);
                      v538 = *(v526 + 6);
                      *(v527 + 5) = *(v526 + 5);
                      *(v527 + 6) = v538;
                      *(v527 + 3) = v536;
                      *(v527 + 4) = v537;
                      if (v668 < v525)
                      {
                        break;
                      }

                      v539 = (2 * v525) | 1;
                      v526 = &a1[14 * v539];
                      v540 = 2 * v525 + 2;
                      if (v540 < v13 && sub_1016A2E60(a3, &a1[14 * v539], v526 + 14))
                      {
                        v526 += 14;
                        v539 = v540;
                      }

                      v527 = v533;
                      v525 = v539;
                    }

                    while (!sub_1016A2E60(a3, v526, &v676));
                    v541 = v676;
                    v542 = v678;
                    *(v533 + 1) = v677;
                    *(v533 + 2) = v542;
                    *v533 = v541;
                    v543 = v679;
                    v544 = v680;
                    v545 = v682;
                    *(v533 + 5) = v681;
                    *(v533 + 6) = v545;
                    *(v533 + 3) = v543;
                    *(v533 + 4) = v544;
                    a2 = v666;
                  }
                }

                v523 = v524 - 1;
              }

              while (v524);
              v546 = 0x6DB6DB6DB6DB6DB7 * (v12 >> 4);
              do
              {
                v547 = 0;
                v548 = *a1;
                v549 = *(a1 + 2);
                v670 = *(a1 + 1);
                v671 = v549;
                v669 = v548;
                v550 = *(a1 + 3);
                v551 = *(a1 + 4);
                v552 = *(a1 + 6);
                v674 = *(a1 + 5);
                v675 = v552;
                v672 = v550;
                v673 = v551;
                v553 = a1;
                do
                {
                  v554 = &v553[14 * v547];
                  v555 = (v554 + 14);
                  v556 = (2 * v547) | 1;
                  v557 = 2 * v547 + 2;
                  if (v557 < v546)
                  {
                    v558 = (v554 + 28);
                    if (sub_1016A2E60(a3, v554 + 14, v554 + 28))
                    {
                      v555 = v558;
                      v556 = v557;
                    }
                  }

                  v559 = *v555;
                  v560 = v555[2];
                  *(v553 + 1) = v555[1];
                  *(v553 + 2) = v560;
                  *v553 = v559;
                  v561 = v555[3];
                  v562 = v555[4];
                  v563 = v555[6];
                  *(v553 + 5) = v555[5];
                  *(v553 + 6) = v563;
                  *(v553 + 3) = v561;
                  *(v553 + 4) = v562;
                  v553 = v555;
                  v547 = v556;
                }

                while (v556 <= (v546 - 2) / 2);
                v564 = a2 - 7;
                if (v555 == a2 - 7)
                {
                  v575 = a2 - 7;
                  v595 = v669;
                  v596 = v671;
                  v555[1] = v670;
                  v555[2] = v596;
                  *v555 = v595;
                  v597 = v672;
                  v598 = v673;
                  v599 = v675;
                  v555[5] = v674;
                  v555[6] = v599;
                  v555[3] = v597;
                  v555[4] = v598;
                }

                else
                {
                  v565 = *v564;
                  v566 = *(a2 - 5);
                  v555[1] = *(a2 - 6);
                  v555[2] = v566;
                  *v555 = v565;
                  v567 = *(a2 - 4);
                  v568 = *(a2 - 3);
                  v569 = *(a2 - 1);
                  v555[5] = *(a2 - 2);
                  v555[6] = v569;
                  v555[3] = v567;
                  v555[4] = v568;
                  v570 = v675;
                  v572 = v672;
                  v571 = v673;
                  *(a2 - 2) = v674;
                  *(a2 - 1) = v570;
                  *(a2 - 4) = v572;
                  *(a2 - 3) = v571;
                  v573 = v669;
                  v574 = v671;
                  *(a2 - 6) = v670;
                  *(a2 - 5) = v574;
                  v575 = a2 - 7;
                  *v564 = v573;
                  v576 = v555 - a1 + 112;
                  if (v576 >= 113)
                  {
                    v577 = (0x6DB6DB6DB6DB6DB7 * (v576 >> 4) - 2) >> 1;
                    v578 = &a1[14 * v577];
                    if (sub_1016A2E60(a3, v578, v555))
                    {
                      v579 = *v555;
                      v580 = v555[2];
                      v677 = v555[1];
                      v678 = v580;
                      v676 = v579;
                      v581 = v555[3];
                      v582 = v555[4];
                      v583 = v555[6];
                      v681 = v555[5];
                      v682 = v583;
                      v679 = v581;
                      v680 = v582;
                      do
                      {
                        v584 = v578;
                        v585 = *v578;
                        v586 = *(v578 + 2);
                        v555[1] = *(v578 + 1);
                        v555[2] = v586;
                        *v555 = v585;
                        v587 = *(v578 + 3);
                        v588 = *(v578 + 4);
                        v589 = *(v578 + 6);
                        v555[5] = *(v578 + 5);
                        v555[6] = v589;
                        v555[3] = v587;
                        v555[4] = v588;
                        if (!v577)
                        {
                          break;
                        }

                        v577 = (v577 - 1) >> 1;
                        v578 = &a1[14 * v577];
                        v555 = v584;
                      }

                      while ((sub_1016A2E60(a3, v578, &v676) & 1) != 0);
                      v590 = v676;
                      v591 = v678;
                      v584[1] = v677;
                      v584[2] = v591;
                      *v584 = v590;
                      v592 = v679;
                      v593 = v680;
                      v594 = v682;
                      v584[5] = v681;
                      v584[6] = v594;
                      v584[3] = v592;
                      v584[4] = v593;
                    }
                  }
                }

                v600 = v546-- <= 2;
                a2 = v575;
              }

              while (!v600);
            }

            return;
          }

          v14 = v13 >> 1;
          v15 = &v11[14 * v14];
          if (v12 >= 0x3801)
          {
            v16 = sub_1016A2E60(a3, &a1[14 * v14], a1);
            v17 = sub_1016A2E60(a3, v8, &a1[14 * v14]);
            if (v16)
            {
              if (v17)
              {
                v18 = *a1;
                v19 = *(a1 + 2);
                v677 = *(a1 + 1);
                v678 = v19;
                v676 = v18;
                v20 = *(a1 + 3);
                v21 = *(a1 + 4);
                v22 = *(a1 + 6);
                v681 = *(a1 + 5);
                v682 = v22;
                v679 = v20;
                v680 = v21;
                v23 = v8[6];
                v25 = v8[3];
                v24 = v8[4];
                *(a1 + 5) = v8[5];
                *(a1 + 6) = v23;
                *(a1 + 3) = v25;
                *(a1 + 4) = v24;
                v26 = *v8;
                v27 = v8[2];
                *(a1 + 1) = v8[1];
                *(a1 + 2) = v27;
                *a1 = v26;
              }

              else
              {
                v100 = *a1;
                v101 = *(a1 + 2);
                v677 = *(a1 + 1);
                v678 = v101;
                v676 = v100;
                v102 = *(a1 + 3);
                v103 = *(a1 + 4);
                v104 = *(a1 + 6);
                v681 = *(a1 + 5);
                v682 = v104;
                v679 = v102;
                v680 = v103;
                v105 = *(v15 + 6);
                v107 = *(v15 + 3);
                v106 = *(v15 + 4);
                *(a1 + 5) = *(v15 + 5);
                *(a1 + 6) = v105;
                *(a1 + 3) = v107;
                *(a1 + 4) = v106;
                v108 = *v15;
                v109 = *(v15 + 2);
                *(a1 + 1) = *(v15 + 1);
                *(a1 + 2) = v109;
                *a1 = v108;
                v110 = v676;
                v111 = v678;
                *(v15 + 1) = v677;
                *(v15 + 2) = v111;
                *v15 = v110;
                v112 = v679;
                v113 = v680;
                v114 = v682;
                *(v15 + 5) = v681;
                *(v15 + 6) = v114;
                *(v15 + 3) = v112;
                *(v15 + 4) = v113;
                if (!sub_1016A2E60(a3, v8, &a1[14 * v14]))
                {
                  goto LABEL_27;
                }

                v115 = *v15;
                v116 = *(v15 + 2);
                v677 = *(v15 + 1);
                v678 = v116;
                v676 = v115;
                v117 = *(v15 + 3);
                v118 = *(v15 + 4);
                v119 = *(v15 + 6);
                v681 = *(v15 + 5);
                v682 = v119;
                v679 = v117;
                v680 = v118;
                v120 = v8[6];
                v122 = v8[3];
                v121 = v8[4];
                *(v15 + 5) = v8[5];
                *(v15 + 6) = v120;
                *(v15 + 3) = v122;
                *(v15 + 4) = v121;
                v123 = *v8;
                v124 = v8[2];
                *(v15 + 1) = v8[1];
                *(v15 + 2) = v124;
                *v15 = v123;
              }

              v125 = v676;
              v126 = v678;
              v8[1] = v677;
              v8[2] = v126;
              *v8 = v125;
              v127 = v679;
              v128 = v680;
              v129 = v682;
              v8[5] = v681;
              v8[6] = v129;
              v8[3] = v127;
              v8[4] = v128;
            }

            else if (v17)
            {
              v40 = *v15;
              v41 = *(v15 + 2);
              v677 = *(v15 + 1);
              v678 = v41;
              v676 = v40;
              v42 = *(v15 + 3);
              v43 = *(v15 + 4);
              v44 = *(v15 + 6);
              v681 = *(v15 + 5);
              v682 = v44;
              v679 = v42;
              v680 = v43;
              v45 = v8[6];
              v47 = v8[3];
              v46 = v8[4];
              *(v15 + 5) = v8[5];
              *(v15 + 6) = v45;
              *(v15 + 3) = v47;
              *(v15 + 4) = v46;
              v48 = *v8;
              v49 = v8[2];
              *(v15 + 1) = v8[1];
              *(v15 + 2) = v49;
              *v15 = v48;
              v50 = v676;
              v51 = v678;
              v8[1] = v677;
              v8[2] = v51;
              *v8 = v50;
              v52 = v679;
              v53 = v680;
              v54 = v682;
              v8[5] = v681;
              v8[6] = v54;
              v8[3] = v52;
              v8[4] = v53;
              if (sub_1016A2E60(a3, &a1[14 * v14], a1))
              {
                v55 = *a1;
                v56 = *(a1 + 2);
                v677 = *(a1 + 1);
                v678 = v56;
                v676 = v55;
                v57 = *(a1 + 3);
                v58 = *(a1 + 4);
                v59 = *(a1 + 6);
                v681 = *(a1 + 5);
                v682 = v59;
                v679 = v57;
                v680 = v58;
                v60 = *(v15 + 6);
                v62 = *(v15 + 3);
                v61 = *(v15 + 4);
                *(a1 + 5) = *(v15 + 5);
                *(a1 + 6) = v60;
                *(a1 + 3) = v62;
                *(a1 + 4) = v61;
                v63 = *v15;
                v64 = *(v15 + 2);
                *(a1 + 1) = *(v15 + 1);
                *(a1 + 2) = v64;
                *a1 = v63;
                v65 = v676;
                v66 = v678;
                *(v15 + 1) = v677;
                *(v15 + 2) = v66;
                *v15 = v65;
                v67 = v679;
                v68 = v680;
                v69 = v682;
                *(v15 + 5) = v681;
                *(v15 + 6) = v69;
                *(v15 + 3) = v67;
                *(v15 + 4) = v68;
              }
            }

LABEL_27:
            v130 = &a1[14 * v14 - 14];
            v131 = sub_1016A2E60(a3, v130, a1 + 14);
            v132 = sub_1016A2E60(a3, v9, v130);
            if (v131)
            {
              if (v132)
              {
                v133 = *(a1 + 12);
                v680 = *(a1 + 11);
                v681 = v133;
                v682 = *(a1 + 13);
                v134 = *(a1 + 8);
                v676 = *(a1 + 7);
                v677 = v134;
                v135 = *(a1 + 10);
                v678 = *(a1 + 9);
                v679 = v135;
                v137 = v9[3];
                v136 = v9[4];
                v138 = v9[6];
                *(a1 + 12) = v9[5];
                *(a1 + 13) = v138;
                *(a1 + 10) = v137;
                *(a1 + 11) = v136;
                v140 = v9[1];
                v139 = v9[2];
                *(a1 + 7) = *v9;
                *(a1 + 8) = v140;
                *(a1 + 9) = v139;
              }

              else
              {
                v199 = *(a1 + 12);
                v680 = *(a1 + 11);
                v681 = v199;
                v682 = *(a1 + 13);
                v200 = *(a1 + 8);
                v676 = *(a1 + 7);
                v677 = v200;
                v201 = *(a1 + 10);
                v678 = *(a1 + 9);
                v679 = v201;
                v203 = *&a1[14 * v14 - 8];
                v202 = *&a1[14 * v14 - 6];
                v204 = *&a1[14 * v14 - 2];
                *(a1 + 12) = *&a1[14 * v14 - 4];
                *(a1 + 13) = v204;
                *(a1 + 10) = v203;
                *(a1 + 11) = v202;
                v206 = *&a1[14 * v14 - 12];
                v205 = *&a1[14 * v14 - 10];
                *(a1 + 7) = *v130;
                *(a1 + 8) = v206;
                *(a1 + 9) = v205;
                v207 = v676;
                v208 = v678;
                *&a1[14 * v14 - 12] = v677;
                *&a1[14 * v14 - 10] = v208;
                *v130 = v207;
                v209 = v679;
                v210 = v680;
                v211 = v682;
                *&a1[14 * v14 - 4] = v681;
                *&a1[14 * v14 - 2] = v211;
                *&a1[14 * v14 - 8] = v209;
                *&a1[14 * v14 - 6] = v210;
                if (!sub_1016A2E60(a3, v9, v130))
                {
                  goto LABEL_39;
                }

                v212 = *v130;
                v213 = *&a1[14 * v14 - 10];
                v677 = *&a1[14 * v14 - 12];
                v678 = v213;
                v676 = v212;
                v214 = *&a1[14 * v14 - 8];
                v215 = *&a1[14 * v14 - 6];
                v216 = *&a1[14 * v14 - 2];
                v681 = *&a1[14 * v14 - 4];
                v682 = v216;
                v679 = v214;
                v680 = v215;
                v217 = v9[6];
                v219 = v9[3];
                v218 = v9[4];
                *&a1[14 * v14 - 4] = v9[5];
                *&a1[14 * v14 - 2] = v217;
                *&a1[14 * v14 - 8] = v219;
                *&a1[14 * v14 - 6] = v218;
                v220 = *v9;
                v221 = v9[2];
                *&a1[14 * v14 - 12] = v9[1];
                *&a1[14 * v14 - 10] = v221;
                *v130 = v220;
              }

              v222 = v676;
              v223 = v678;
              v9[1] = v677;
              v9[2] = v223;
              *v9 = v222;
              v224 = v679;
              v225 = v680;
              v226 = v682;
              v9[5] = v681;
              v9[6] = v226;
              v9[3] = v224;
              v9[4] = v225;
            }

            else if (v132)
            {
              v141 = *v130;
              v142 = *&a1[14 * v14 - 10];
              v677 = *&a1[14 * v14 - 12];
              v678 = v142;
              v676 = v141;
              v143 = *&a1[14 * v14 - 8];
              v144 = *&a1[14 * v14 - 6];
              v145 = *&a1[14 * v14 - 2];
              v681 = *&a1[14 * v14 - 4];
              v682 = v145;
              v679 = v143;
              v680 = v144;
              v146 = v9[6];
              v148 = v9[3];
              v147 = v9[4];
              *&a1[14 * v14 - 4] = v9[5];
              *&a1[14 * v14 - 2] = v146;
              *&a1[14 * v14 - 8] = v148;
              *&a1[14 * v14 - 6] = v147;
              v149 = *v9;
              v150 = v9[2];
              *&a1[14 * v14 - 12] = v9[1];
              *&a1[14 * v14 - 10] = v150;
              *v130 = v149;
              v151 = v676;
              v152 = v678;
              v9[1] = v677;
              v9[2] = v152;
              *v9 = v151;
              v153 = v679;
              v154 = v680;
              v155 = v682;
              v9[5] = v681;
              v9[6] = v155;
              v9[3] = v153;
              v9[4] = v154;
              if (sub_1016A2E60(a3, v130, a1 + 14))
              {
                v156 = *(a1 + 12);
                v680 = *(a1 + 11);
                v681 = v156;
                v682 = *(a1 + 13);
                v157 = *(a1 + 8);
                v676 = *(a1 + 7);
                v677 = v157;
                v158 = *(a1 + 10);
                v678 = *(a1 + 9);
                v679 = v158;
                v160 = *&a1[14 * v14 - 8];
                v159 = *&a1[14 * v14 - 6];
                v161 = *&a1[14 * v14 - 2];
                *(a1 + 12) = *&a1[14 * v14 - 4];
                *(a1 + 13) = v161;
                *(a1 + 10) = v160;
                *(a1 + 11) = v159;
                v163 = *&a1[14 * v14 - 12];
                v162 = *&a1[14 * v14 - 10];
                *(a1 + 7) = *v130;
                *(a1 + 8) = v163;
                *(a1 + 9) = v162;
                v164 = v676;
                v165 = v678;
                *&a1[14 * v14 - 12] = v677;
                *&a1[14 * v14 - 10] = v165;
                *v130 = v164;
                v166 = v679;
                v167 = v680;
                v168 = v682;
                *&a1[14 * v14 - 4] = v681;
                *&a1[14 * v14 - 2] = v168;
                *&a1[14 * v14 - 8] = v166;
                *&a1[14 * v14 - 6] = v167;
              }
            }

LABEL_39:
            v227 = &a1[14 * v14];
            v228 = sub_1016A2E60(a3, v227 + 14, a1 + 28);
            v229 = sub_1016A2E60(a3, v10, v227 + 14);
            if (v228)
            {
              if (v229)
              {
                v230 = *(a1 + 19);
                v680 = *(a1 + 18);
                v681 = v230;
                v682 = *(a1 + 20);
                v231 = *(a1 + 15);
                v676 = *(a1 + 14);
                v677 = v231;
                v232 = *(a1 + 17);
                v678 = *(a1 + 16);
                v679 = v232;
                v234 = v10[3];
                v233 = v10[4];
                v235 = v10[6];
                *(a1 + 19) = v10[5];
                *(a1 + 20) = v235;
                *(a1 + 17) = v234;
                *(a1 + 18) = v233;
                v237 = v10[1];
                v236 = v10[2];
                *(a1 + 14) = *v10;
                *(a1 + 15) = v237;
                *(a1 + 16) = v236;
              }

              else
              {
                v266 = *(a1 + 19);
                v680 = *(a1 + 18);
                v681 = v266;
                v682 = *(a1 + 20);
                v267 = *(a1 + 15);
                v676 = *(a1 + 14);
                v677 = v267;
                v268 = *(a1 + 17);
                v678 = *(a1 + 16);
                v679 = v268;
                v270 = *(v227 + 10);
                v269 = *(v227 + 11);
                v271 = *(v227 + 13);
                *(a1 + 19) = *(v227 + 12);
                *(a1 + 20) = v271;
                *(a1 + 17) = v270;
                *(a1 + 18) = v269;
                v273 = *(v227 + 8);
                v272 = *(v227 + 9);
                *(a1 + 14) = *(v227 + 7);
                *(a1 + 15) = v273;
                *(a1 + 16) = v272;
                v274 = v676;
                v275 = v678;
                *(v227 + 8) = v677;
                *(v227 + 9) = v275;
                *(v227 + 7) = v274;
                v276 = v679;
                v277 = v680;
                v278 = v682;
                *(v227 + 12) = v681;
                *(v227 + 13) = v278;
                *(v227 + 10) = v276;
                *(v227 + 11) = v277;
                if (!sub_1016A2E60(a3, v10, v227 + 14))
                {
                  goto LABEL_48;
                }

                v279 = *(v227 + 7);
                v280 = *(v227 + 9);
                v677 = *(v227 + 8);
                v678 = v280;
                v676 = v279;
                v281 = *(v227 + 10);
                v282 = *(v227 + 11);
                v283 = *(v227 + 13);
                v681 = *(v227 + 12);
                v682 = v283;
                v679 = v281;
                v680 = v282;
                v284 = v10[6];
                v286 = v10[3];
                v285 = v10[4];
                *(v227 + 12) = v10[5];
                *(v227 + 13) = v284;
                *(v227 + 10) = v286;
                *(v227 + 11) = v285;
                v287 = *v10;
                v288 = v10[2];
                *(v227 + 8) = v10[1];
                *(v227 + 9) = v288;
                *(v227 + 7) = v287;
              }

              v289 = v676;
              v290 = v678;
              v10[1] = v677;
              v10[2] = v290;
              *v10 = v289;
              v291 = v679;
              v292 = v680;
              v293 = v682;
              v10[5] = v681;
              v10[6] = v293;
              v10[3] = v291;
              v10[4] = v292;
            }

            else if (v229)
            {
              v238 = *(v227 + 7);
              v239 = *(v227 + 9);
              v677 = *(v227 + 8);
              v678 = v239;
              v676 = v238;
              v240 = *(v227 + 10);
              v241 = *(v227 + 11);
              v242 = *(v227 + 13);
              v681 = *(v227 + 12);
              v682 = v242;
              v679 = v240;
              v680 = v241;
              v243 = v10[6];
              v245 = v10[3];
              v244 = v10[4];
              *(v227 + 12) = v10[5];
              *(v227 + 13) = v243;
              *(v227 + 10) = v245;
              *(v227 + 11) = v244;
              v246 = *v10;
              v247 = v10[2];
              *(v227 + 8) = v10[1];
              *(v227 + 9) = v247;
              *(v227 + 7) = v246;
              v248 = v676;
              v249 = v678;
              v10[1] = v677;
              v10[2] = v249;
              *v10 = v248;
              v250 = v679;
              v251 = v680;
              v252 = v682;
              v10[5] = v681;
              v10[6] = v252;
              v10[3] = v250;
              v10[4] = v251;
              if (sub_1016A2E60(a3, v227 + 14, a1 + 28))
              {
                v253 = *(a1 + 19);
                v680 = *(a1 + 18);
                v681 = v253;
                v682 = *(a1 + 20);
                v254 = *(a1 + 15);
                v676 = *(a1 + 14);
                v677 = v254;
                v255 = *(a1 + 17);
                v678 = *(a1 + 16);
                v679 = v255;
                v257 = *(v227 + 10);
                v256 = *(v227 + 11);
                v258 = *(v227 + 13);
                *(a1 + 19) = *(v227 + 12);
                *(a1 + 20) = v258;
                *(a1 + 17) = v257;
                *(a1 + 18) = v256;
                v260 = *(v227 + 8);
                v259 = *(v227 + 9);
                *(a1 + 14) = *(v227 + 7);
                *(a1 + 15) = v260;
                *(a1 + 16) = v259;
                v261 = v676;
                v262 = v678;
                *(v227 + 8) = v677;
                *(v227 + 9) = v262;
                *(v227 + 7) = v261;
                v263 = v679;
                v264 = v680;
                v265 = v682;
                *(v227 + 12) = v681;
                *(v227 + 13) = v265;
                *(v227 + 10) = v263;
                *(v227 + 11) = v264;
              }
            }

LABEL_48:
            v294 = sub_1016A2E60(a3, v15, v130);
            v295 = sub_1016A2E60(a3, v227 + 14, v15);
            if ((v294 & 1) == 0)
            {
              if (v295)
              {
                v304 = *v15;
                v305 = *(v15 + 2);
                v677 = *(v15 + 1);
                v678 = v305;
                v676 = v304;
                v306 = *(v15 + 3);
                v307 = *(v15 + 4);
                v308 = *(v15 + 6);
                v681 = *(v15 + 5);
                v682 = v308;
                v679 = v306;
                v680 = v307;
                v309 = *(v227 + 12);
                *(v15 + 4) = *(v227 + 11);
                *(v15 + 5) = v309;
                *(v15 + 6) = *(v227 + 13);
                v310 = *(v227 + 8);
                *v15 = *(v227 + 7);
                *(v15 + 1) = v310;
                v311 = *(v227 + 10);
                *(v15 + 2) = *(v227 + 9);
                *(v15 + 3) = v311;
                v312 = v676;
                v313 = v678;
                *(v227 + 8) = v677;
                *(v227 + 9) = v313;
                *(v227 + 7) = v312;
                v314 = v679;
                v315 = v680;
                v316 = v682;
                *(v227 + 12) = v681;
                *(v227 + 13) = v316;
                *(v227 + 10) = v314;
                *(v227 + 11) = v315;
                if (sub_1016A2E60(a3, v15, v130))
                {
                  v317 = *v130;
                  v318 = *(v130 + 32);
                  v677 = *(v130 + 16);
                  v678 = v318;
                  v676 = v317;
                  v319 = *(v130 + 48);
                  v320 = *(v130 + 64);
                  v321 = *(v130 + 96);
                  v681 = *(v130 + 80);
                  v682 = v321;
                  v679 = v319;
                  v680 = v320;
                  v322 = *(v15 + 5);
                  *(v130 + 64) = *(v15 + 4);
                  *(v130 + 80) = v322;
                  *(v130 + 96) = *(v15 + 6);
                  v323 = *(v15 + 1);
                  *v130 = *v15;
                  *(v130 + 16) = v323;
                  v324 = *(v15 + 3);
                  *(v130 + 32) = *(v15 + 2);
                  *(v130 + 48) = v324;
                  v325 = v676;
                  v326 = v678;
                  *(v15 + 1) = v677;
                  *(v15 + 2) = v326;
                  *v15 = v325;
                  v327 = v679;
                  v328 = v680;
                  v329 = v682;
                  *(v15 + 5) = v681;
                  *(v15 + 6) = v329;
                  *(v15 + 3) = v327;
                  *(v15 + 4) = v328;
                }
              }

              goto LABEL_57;
            }

            if (v295)
            {
              v296 = *v130;
              v297 = *(v130 + 32);
              v677 = *(v130 + 16);
              v678 = v297;
              v676 = v296;
              v298 = *(v130 + 48);
              v299 = *(v130 + 64);
              v300 = *(v130 + 96);
              v681 = *(v130 + 80);
              v682 = v300;
              v679 = v298;
              v680 = v299;
              v301 = *(v227 + 12);
              *(v130 + 64) = *(v227 + 11);
              *(v130 + 80) = v301;
              *(v130 + 96) = *(v227 + 13);
              v302 = *(v227 + 8);
              *v130 = *(v227 + 7);
              *(v130 + 16) = v302;
              v303 = *(v227 + 10);
              *(v130 + 32) = *(v227 + 9);
              *(v130 + 48) = v303;
            }

            else
            {
              v330 = *v130;
              v331 = *(v130 + 32);
              v677 = *(v130 + 16);
              v678 = v331;
              v676 = v330;
              v332 = *(v130 + 48);
              v333 = *(v130 + 64);
              v334 = *(v130 + 96);
              v681 = *(v130 + 80);
              v682 = v334;
              v679 = v332;
              v680 = v333;
              v335 = *(v15 + 5);
              *(v130 + 64) = *(v15 + 4);
              *(v130 + 80) = v335;
              *(v130 + 96) = *(v15 + 6);
              v336 = *(v15 + 1);
              *v130 = *v15;
              *(v130 + 16) = v336;
              v337 = *(v15 + 3);
              *(v130 + 32) = *(v15 + 2);
              *(v130 + 48) = v337;
              v338 = v676;
              v339 = v678;
              *(v15 + 1) = v677;
              *(v15 + 2) = v339;
              *v15 = v338;
              v340 = v679;
              v341 = v680;
              v342 = v682;
              *(v15 + 5) = v681;
              *(v15 + 6) = v342;
              *(v15 + 3) = v340;
              *(v15 + 4) = v341;
              if (!sub_1016A2E60(a3, v227 + 14, v15))
              {
LABEL_57:
                v356 = *a1;
                v357 = *(a1 + 2);
                v677 = *(a1 + 1);
                v678 = v357;
                v676 = v356;
                v358 = *(a1 + 3);
                v359 = *(a1 + 4);
                v360 = *(a1 + 6);
                v681 = *(a1 + 5);
                v682 = v360;
                v679 = v358;
                v680 = v359;
                v361 = *(v15 + 6);
                v363 = *(v15 + 3);
                v362 = *(v15 + 4);
                *(a1 + 5) = *(v15 + 5);
                *(a1 + 6) = v361;
                *(a1 + 3) = v363;
                *(a1 + 4) = v362;
                v364 = *v15;
                v365 = *(v15 + 2);
                *(a1 + 1) = *(v15 + 1);
                *(a1 + 2) = v365;
                *a1 = v364;
                v366 = v676;
                v367 = v678;
                *(v15 + 1) = v677;
                *(v15 + 2) = v367;
                *v15 = v366;
                v368 = v679;
                v369 = v680;
                v370 = v682;
                *(v15 + 5) = v681;
                *(v15 + 6) = v370;
                *(v15 + 3) = v368;
                *(v15 + 4) = v369;
                goto LABEL_58;
              }

              v343 = *v15;
              v344 = *(v15 + 2);
              v677 = *(v15 + 1);
              v678 = v344;
              v676 = v343;
              v345 = *(v15 + 3);
              v346 = *(v15 + 4);
              v347 = *(v15 + 6);
              v681 = *(v15 + 5);
              v682 = v347;
              v679 = v345;
              v680 = v346;
              v348 = *(v227 + 12);
              *(v15 + 4) = *(v227 + 11);
              *(v15 + 5) = v348;
              *(v15 + 6) = *(v227 + 13);
              v349 = *(v227 + 8);
              *v15 = *(v227 + 7);
              *(v15 + 1) = v349;
              v350 = *(v227 + 10);
              *(v15 + 2) = *(v227 + 9);
              *(v15 + 3) = v350;
            }

            v351 = v676;
            v352 = v678;
            *(v227 + 8) = v677;
            *(v227 + 9) = v352;
            *(v227 + 7) = v351;
            v353 = v679;
            v354 = v680;
            v355 = v682;
            *(v227 + 12) = v681;
            *(v227 + 13) = v355;
            *(v227 + 10) = v353;
            *(v227 + 11) = v354;
            goto LABEL_57;
          }

          v28 = sub_1016A2E60(a3, a1, &a1[14 * v14]);
          v29 = sub_1016A2E60(a3, v8, a1);
          if (v28)
          {
            if (v29)
            {
              v30 = *v15;
              v31 = *(v15 + 2);
              v677 = *(v15 + 1);
              v678 = v31;
              v676 = v30;
              v32 = *(v15 + 3);
              v33 = *(v15 + 4);
              v34 = *(v15 + 6);
              v681 = *(v15 + 5);
              v682 = v34;
              v679 = v32;
              v680 = v33;
              v35 = v8[6];
              v37 = v8[3];
              v36 = v8[4];
              *(v15 + 5) = v8[5];
              *(v15 + 6) = v35;
              *(v15 + 3) = v37;
              *(v15 + 4) = v36;
              v38 = *v8;
              v39 = v8[2];
              *(v15 + 1) = v8[1];
              *(v15 + 2) = v39;
              *v15 = v38;
LABEL_35:
              v194 = v676;
              v195 = v678;
              v8[1] = v677;
              v8[2] = v195;
              *v8 = v194;
              v196 = v679;
              v197 = v680;
              v198 = v682;
              v8[5] = v681;
              v8[6] = v198;
              v8[3] = v196;
              v8[4] = v197;
              goto LABEL_58;
            }

            v169 = *v15;
            v170 = *(v15 + 2);
            v677 = *(v15 + 1);
            v678 = v170;
            v676 = v169;
            v171 = *(v15 + 3);
            v172 = *(v15 + 4);
            v173 = *(v15 + 6);
            v681 = *(v15 + 5);
            v682 = v173;
            v679 = v171;
            v680 = v172;
            v174 = *(a1 + 6);
            v176 = *(a1 + 3);
            v175 = *(a1 + 4);
            *(v15 + 5) = *(a1 + 5);
            *(v15 + 6) = v174;
            *(v15 + 3) = v176;
            *(v15 + 4) = v175;
            v177 = *a1;
            v178 = *(a1 + 2);
            *(v15 + 1) = *(a1 + 1);
            *(v15 + 2) = v178;
            *v15 = v177;
            v179 = v676;
            v180 = v678;
            *(a1 + 1) = v677;
            *(a1 + 2) = v180;
            *a1 = v179;
            v181 = v679;
            v182 = v680;
            v183 = v682;
            *(a1 + 5) = v681;
            *(a1 + 6) = v183;
            *(a1 + 3) = v181;
            *(a1 + 4) = v182;
            if (sub_1016A2E60(a3, v8, a1))
            {
              v184 = *a1;
              v185 = *(a1 + 2);
              v677 = *(a1 + 1);
              v678 = v185;
              v676 = v184;
              v186 = *(a1 + 3);
              v187 = *(a1 + 4);
              v188 = *(a1 + 6);
              v681 = *(a1 + 5);
              v682 = v188;
              v679 = v186;
              v680 = v187;
              v189 = v8[6];
              v191 = v8[3];
              v190 = v8[4];
              *(a1 + 5) = v8[5];
              *(a1 + 6) = v189;
              *(a1 + 3) = v191;
              *(a1 + 4) = v190;
              v192 = *v8;
              v193 = v8[2];
              *(a1 + 1) = v8[1];
              *(a1 + 2) = v193;
              *a1 = v192;
              goto LABEL_35;
            }
          }

          else if (v29)
          {
            v70 = *a1;
            v71 = *(a1 + 2);
            v677 = *(a1 + 1);
            v678 = v71;
            v676 = v70;
            v72 = *(a1 + 3);
            v73 = *(a1 + 4);
            v74 = *(a1 + 6);
            v681 = *(a1 + 5);
            v682 = v74;
            v679 = v72;
            v680 = v73;
            v75 = v8[6];
            v77 = v8[3];
            v76 = v8[4];
            *(a1 + 5) = v8[5];
            *(a1 + 6) = v75;
            *(a1 + 3) = v77;
            *(a1 + 4) = v76;
            v78 = *v8;
            v79 = v8[2];
            *(a1 + 1) = v8[1];
            *(a1 + 2) = v79;
            *a1 = v78;
            v80 = v676;
            v81 = v678;
            v8[1] = v677;
            v8[2] = v81;
            *v8 = v80;
            v82 = v679;
            v83 = v680;
            v84 = v682;
            v8[5] = v681;
            v8[6] = v84;
            v8[3] = v82;
            v8[4] = v83;
            if (sub_1016A2E60(a3, a1, &a1[14 * v14]))
            {
              v85 = *v15;
              v86 = *(v15 + 2);
              v677 = *(v15 + 1);
              v678 = v86;
              v676 = v85;
              v87 = *(v15 + 3);
              v88 = *(v15 + 4);
              v89 = *(v15 + 6);
              v681 = *(v15 + 5);
              v682 = v89;
              v679 = v87;
              v680 = v88;
              v90 = *(a1 + 6);
              v92 = *(a1 + 3);
              v91 = *(a1 + 4);
              *(v15 + 5) = *(a1 + 5);
              *(v15 + 6) = v90;
              *(v15 + 3) = v92;
              *(v15 + 4) = v91;
              v93 = *a1;
              v94 = *(a1 + 2);
              *(v15 + 1) = *(a1 + 1);
              *(v15 + 2) = v94;
              *v15 = v93;
              v95 = v676;
              v96 = v678;
              *(a1 + 1) = v677;
              *(a1 + 2) = v96;
              *a1 = v95;
              v97 = v679;
              v98 = v680;
              v99 = v682;
              *(a1 + 5) = v681;
              *(a1 + 6) = v99;
              *(a1 + 3) = v97;
              *(a1 + 4) = v98;
            }
          }

LABEL_58:
          --a4;
          if (a5 & 1) != 0 || (sub_1016A2E60(a3, a1 - 14, a1))
          {
            break;
          }

          v408 = *a1;
          v409 = *(a1 + 2);
          v670 = *(a1 + 1);
          v671 = v409;
          v669 = v408;
          v410 = *(a1 + 3);
          v411 = *(a1 + 4);
          v412 = *(a1 + 6);
          v674 = *(a1 + 5);
          v675 = v412;
          v672 = v410;
          v673 = v411;
          if (sub_1016A2E60(a3, &v669, v8))
          {
            v11 = a1;
            a2 = v666;
            do
            {
              v11 += 14;
            }

            while ((sub_1016A2E60(a3, &v669, v11) & 1) == 0);
          }

          else
          {
            v413 = a1 + 14;
            a2 = v666;
            do
            {
              v11 = v413;
              if (v413 >= v666)
              {
                break;
              }

              v414 = sub_1016A2E60(a3, &v669, v413);
              v413 = v11 + 14;
            }

            while (!v414);
          }

          v415 = a2;
          if (v11 < a2)
          {
            v415 = a2;
            do
            {
              v415 -= 7;
            }

            while ((sub_1016A2E60(a3, &v669, v415) & 1) != 0);
          }

          while (v11 < v415)
          {
            v416 = *v11;
            v417 = *(v11 + 2);
            v677 = *(v11 + 1);
            v678 = v417;
            v676 = v416;
            v418 = *(v11 + 3);
            v419 = *(v11 + 4);
            v420 = *(v11 + 6);
            v681 = *(v11 + 5);
            v682 = v420;
            v679 = v418;
            v680 = v419;
            v421 = v415[6];
            v423 = v415[3];
            v422 = v415[4];
            *(v11 + 5) = v415[5];
            *(v11 + 6) = v421;
            *(v11 + 3) = v423;
            *(v11 + 4) = v422;
            v424 = *v415;
            v425 = v415[2];
            *(v11 + 1) = v415[1];
            *(v11 + 2) = v425;
            *v11 = v424;
            v426 = v676;
            v427 = v678;
            v415[1] = v677;
            v415[2] = v427;
            *v415 = v426;
            v428 = v679;
            v429 = v680;
            v430 = v682;
            v415[5] = v681;
            v415[6] = v430;
            v415[3] = v428;
            v415[4] = v429;
            do
            {
              v11 += 14;
            }

            while (!sub_1016A2E60(a3, &v669, v11));
            do
            {
              v415 -= 7;
            }

            while ((sub_1016A2E60(a3, &v669, v415) & 1) != 0);
          }

          v431 = v11 - 14;
          if (v11 - 14 != a1)
          {
            v432 = *v431;
            v433 = *(v11 - 5);
            *(a1 + 1) = *(v11 - 6);
            *(a1 + 2) = v433;
            *a1 = v432;
            v434 = *(v11 - 4);
            v435 = *(v11 - 3);
            v436 = *(v11 - 1);
            *(a1 + 5) = *(v11 - 2);
            *(a1 + 6) = v436;
            *(a1 + 3) = v434;
            *(a1 + 4) = v435;
          }

          a5 = 0;
          v437 = v669;
          v438 = v671;
          *(v11 - 6) = v670;
          *(v11 - 5) = v438;
          *v431 = v437;
          v439 = v672;
          v440 = v673;
          v441 = v675;
          *(v11 - 2) = v674;
          *(v11 - 1) = v441;
          *(v11 - 4) = v439;
          *(v11 - 3) = v440;
        }

        v371 = 0;
        v372 = *a1;
        v373 = *(a1 + 2);
        v670 = *(a1 + 1);
        v671 = v373;
        v669 = v372;
        v374 = *(a1 + 3);
        v375 = *(a1 + 4);
        v376 = *(a1 + 6);
        v674 = *(a1 + 5);
        v675 = v376;
        v672 = v374;
        v673 = v375;
        do
        {
          v371 += 14;
        }

        while ((sub_1016A2E60(a3, &a1[v371], &v669) & 1) != 0);
        v377 = &a1[v371];
        v378 = v666;
        v502 = v371 == 14;
        a2 = v666;
        if (v502)
        {
          v378 = v666;
          do
          {
            if (v377 >= v378)
            {
              break;
            }

            v378 -= 14;
          }

          while ((sub_1016A2E60(a3, v378, &v669) & 1) == 0);
        }

        else
        {
          do
          {
            v378 -= 14;
          }

          while (!sub_1016A2E60(a3, v378, &v669));
        }

        if (v377 >= v378)
        {
          v396 = v377 - 112;
        }

        else
        {
          v379 = v377;
          v380 = v378;
          do
          {
            v381 = *v379;
            v382 = *(v379 + 32);
            v677 = *(v379 + 16);
            v678 = v382;
            v676 = v381;
            v383 = *(v379 + 48);
            v384 = *(v379 + 64);
            v385 = *(v379 + 96);
            v681 = *(v379 + 80);
            v682 = v385;
            v679 = v383;
            v680 = v384;
            v386 = *(v380 + 6);
            v388 = *(v380 + 3);
            v387 = *(v380 + 4);
            *(v379 + 80) = *(v380 + 5);
            *(v379 + 96) = v386;
            *(v379 + 48) = v388;
            *(v379 + 64) = v387;
            v389 = *v380;
            v390 = *(v380 + 2);
            *(v379 + 16) = *(v380 + 1);
            *(v379 + 32) = v390;
            *v379 = v389;
            v391 = v676;
            v392 = v678;
            *(v380 + 1) = v677;
            *(v380 + 2) = v392;
            *v380 = v391;
            v393 = v679;
            v394 = v680;
            v395 = v682;
            *(v380 + 5) = v681;
            *(v380 + 6) = v395;
            *(v380 + 3) = v393;
            *(v380 + 4) = v394;
            do
            {
              v379 += 112;
            }

            while ((sub_1016A2E60(a3, v379, &v669) & 1) != 0);
            do
            {
              v380 -= 14;
            }

            while (!sub_1016A2E60(a3, v380, &v669));
          }

          while (v379 < v380);
          v396 = v379 - 112;
        }

        if (v396 != a1)
        {
          v397 = *v396;
          v398 = *(v396 + 32);
          *(a1 + 1) = *(v396 + 16);
          *(a1 + 2) = v398;
          *a1 = v397;
          v399 = *(v396 + 48);
          v400 = *(v396 + 64);
          v401 = *(v396 + 96);
          *(a1 + 5) = *(v396 + 80);
          *(a1 + 6) = v401;
          *(a1 + 3) = v399;
          *(a1 + 4) = v400;
        }

        v402 = v669;
        v403 = v671;
        *(v396 + 16) = v670;
        *(v396 + 32) = v403;
        *v396 = v402;
        v404 = v672;
        v405 = v673;
        v406 = v675;
        *(v396 + 80) = v674;
        *(v396 + 96) = v406;
        *(v396 + 48) = v404;
        *(v396 + 64) = v405;
        if (v377 >= v378)
        {
          break;
        }

LABEL_81:
        sub_1016A15A8(a1, v396, a3, a4, a5 & 1);
        a5 = 0;
        v11 = (v396 + 112);
      }

      v407 = sub_1016A3414(a1, v396, a3);
      v11 = (v396 + 112);
      if (sub_1016A3414((v396 + 112), v666, a3))
      {
        break;
      }

      if (!v407)
      {
        goto LABEL_81;
      }
    }

    a2 = v396;
    if (!v407)
    {
      continue;
    }

    break;
  }
}

uint64_t sub_1016A2E60(double **a1, double *a2, double *a3)
{
  v6 = sub_10169A37C(*a1, a1[1], a2);
  v7 = sub_10169A37C(*a1, a1[1], a3);
  if (!(v6 | v7))
  {
    v8 = **a1;
    v31 = *a1[1];
    v32 = v8;
    v30 = *a2;
    v9 = sub_1016A3B70(&v32, &v31, &v30);
    v10 = **a1;
    v31 = *a1[1];
    v32 = v10;
    v30 = *a3;
    v11 = sub_1016A3B70(&v32, &v31, &v30);
    v12 = v9 < v11;
    if (v9 != v11)
    {
      return v12;
    }

LABEL_12:
    v19 = *(a2 + 11);
    v20 = *(a3 + 11);
    v12 = v19 < v20;
    if (v19 == v20)
    {
      v21 = *(a2 + 4);
      v22 = *(a3 + 4);
      v12 = v21 < v22;
      if (v21 == v22)
      {
        v23 = *(a2 + 9);
        v24 = *(a3 + 9);
        v12 = v23 < v24;
        if (v23 == v24)
        {
          v25 = *(a2 + 10);
          v26 = *(a3 + 10);
          v12 = v25 < v26;
          if (v25 == v26)
          {
            v27 = *(a2 + 11);
            v28 = *(a3 + 11);
            v12 = v27 < v28;
            if (v27 == v28)
            {
              return *(a2 + 6) < *(a3 + 6);
            }
          }
        }
      }
    }

    return v12;
  }

  v13 = v7;
  if (!v6)
  {
    v14 = **a1;
    v31 = *a1[1];
    v32 = v14;
    v30 = *a2;
    if (sub_1016A3B70(&v32, &v31, &v30) == -1)
    {
      return 1;
    }
  }

  if (!v13)
  {
    v15 = **a1;
    v31 = *a1[1];
    v32 = v15;
    v30 = *a3;
    if (sub_1016A3B70(&v32, &v31, &v30) == -1)
    {
      return 0;
    }
  }

  v12 = v6 < v13;
  if (v6 == v13)
  {
    v16 = sub_10169A37C(a1[1], a2, a3);
    if (v16)
    {
      v17 = v16;
      v18 = sub_10169A37C(a1[1], a3, a2);
      if (!(v17 + v18))
      {
        return v18 < v17;
      }
    }

    goto LABEL_12;
  }

  return v12;
}

__n128 sub_1016A3054(double *a1, double *a2, double *a3, double *a4, double **a5)
{
  v10 = sub_1016A2E60(a5, a2, a1);
  v11 = sub_1016A2E60(a5, a3, a2);
  if (v10)
  {
    if (v11)
    {
      v81 = *(a1 + 4);
      v88 = *(a1 + 5);
      v95 = *(a1 + 6);
      v53 = *a1;
      v60 = *(a1 + 1);
      v67 = *(a1 + 2);
      v74 = *(a1 + 3);
      v13 = *(a3 + 1);
      v12 = *(a3 + 2);
      *a1 = *a3;
      *(a1 + 1) = v13;
      *(a1 + 2) = v12;
      v14 = *(a3 + 6);
      v16 = *(a3 + 3);
      v15 = *(a3 + 4);
      *(a1 + 5) = *(a3 + 5);
      *(a1 + 6) = v14;
      *(a1 + 3) = v16;
      *(a1 + 4) = v15;
LABEL_9:
      *a3 = v53;
      *(a3 + 1) = v60;
      *(a3 + 5) = v88;
      *(a3 + 6) = v95;
      *(a3 + 3) = v74;
      *(a3 + 4) = v81;
      *(a3 + 2) = v67;
      goto LABEL_10;
    }

    v84 = *(a1 + 4);
    v91 = *(a1 + 5);
    v98 = *(a1 + 6);
    v56 = *a1;
    v63 = *(a1 + 1);
    v70 = *(a1 + 2);
    v77 = *(a1 + 3);
    v28 = *(a2 + 1);
    v27 = *(a2 + 2);
    *a1 = *a2;
    *(a1 + 1) = v28;
    *(a1 + 2) = v27;
    v29 = *(a2 + 6);
    v31 = *(a2 + 3);
    v30 = *(a2 + 4);
    *(a1 + 5) = *(a2 + 5);
    *(a1 + 6) = v29;
    *(a1 + 3) = v31;
    *(a1 + 4) = v30;
    *a2 = v56;
    *(a2 + 1) = v63;
    *(a2 + 5) = v91;
    *(a2 + 6) = v98;
    *(a2 + 3) = v77;
    *(a2 + 4) = v84;
    *(a2 + 2) = v70;
    if (sub_1016A2E60(a5, a3, a2))
    {
      v81 = *(a2 + 4);
      v88 = *(a2 + 5);
      v95 = *(a2 + 6);
      v53 = *a2;
      v60 = *(a2 + 1);
      v67 = *(a2 + 2);
      v74 = *(a2 + 3);
      v33 = *(a3 + 1);
      v32 = *(a3 + 2);
      *a2 = *a3;
      *(a2 + 1) = v33;
      *(a2 + 2) = v32;
      v34 = *(a3 + 6);
      v36 = *(a3 + 3);
      v35 = *(a3 + 4);
      *(a2 + 5) = *(a3 + 5);
      *(a2 + 6) = v34;
      *(a2 + 3) = v36;
      *(a2 + 4) = v35;
      goto LABEL_9;
    }
  }

  else if (v11)
  {
    v82 = *(a2 + 4);
    v89 = *(a2 + 5);
    v96 = *(a2 + 6);
    v54 = *a2;
    v61 = *(a2 + 1);
    v68 = *(a2 + 2);
    v75 = *(a2 + 3);
    v18 = *(a3 + 1);
    v17 = *(a3 + 2);
    *a2 = *a3;
    *(a2 + 1) = v18;
    *(a2 + 2) = v17;
    v19 = *(a3 + 6);
    v21 = *(a3 + 3);
    v20 = *(a3 + 4);
    *(a2 + 5) = *(a3 + 5);
    *(a2 + 6) = v19;
    *(a2 + 3) = v21;
    *(a2 + 4) = v20;
    *a3 = v54;
    *(a3 + 1) = v61;
    *(a3 + 5) = v89;
    *(a3 + 6) = v96;
    *(a3 + 3) = v75;
    *(a3 + 4) = v82;
    *(a3 + 2) = v68;
    if (sub_1016A2E60(a5, a2, a1))
    {
      v83 = *(a1 + 4);
      v90 = *(a1 + 5);
      v97 = *(a1 + 6);
      v55 = *a1;
      v62 = *(a1 + 1);
      v69 = *(a1 + 2);
      v76 = *(a1 + 3);
      v23 = *(a2 + 1);
      v22 = *(a2 + 2);
      *a1 = *a2;
      *(a1 + 1) = v23;
      *(a1 + 2) = v22;
      v24 = *(a2 + 6);
      v26 = *(a2 + 3);
      v25 = *(a2 + 4);
      *(a1 + 5) = *(a2 + 5);
      *(a1 + 6) = v24;
      *(a1 + 3) = v26;
      *(a1 + 4) = v25;
      *a2 = v55;
      *(a2 + 1) = v62;
      *(a2 + 5) = v90;
      *(a2 + 6) = v97;
      *(a2 + 3) = v76;
      *(a2 + 4) = v83;
      *(a2 + 2) = v69;
    }
  }

LABEL_10:
  if (sub_1016A2E60(a5, a4, a3))
  {
    v85 = *(a3 + 4);
    v92 = *(a3 + 5);
    v99 = *(a3 + 6);
    v57 = *a3;
    v64 = *(a3 + 1);
    v71 = *(a3 + 2);
    v78 = *(a3 + 3);
    v39 = *(a4 + 1);
    v38 = *(a4 + 2);
    *a3 = *a4;
    *(a3 + 1) = v39;
    *(a3 + 2) = v38;
    v40 = *(a4 + 6);
    v42 = *(a4 + 3);
    v41 = *(a4 + 4);
    *(a3 + 5) = *(a4 + 5);
    *(a3 + 6) = v40;
    *(a3 + 3) = v42;
    *(a3 + 4) = v41;
    *a4 = v57;
    *(a4 + 1) = v64;
    *(a4 + 5) = v92;
    *(a4 + 6) = v99;
    *(a4 + 3) = v78;
    *(a4 + 4) = v85;
    *(a4 + 2) = v71;
    if (sub_1016A2E60(a5, a3, a2))
    {
      v86 = *(a2 + 4);
      v93 = *(a2 + 5);
      v100 = *(a2 + 6);
      v58 = *a2;
      v65 = *(a2 + 1);
      v72 = *(a2 + 2);
      v79 = *(a2 + 3);
      v44 = *(a3 + 1);
      v43 = *(a3 + 2);
      *a2 = *a3;
      *(a2 + 1) = v44;
      *(a2 + 2) = v43;
      v45 = *(a3 + 6);
      v47 = *(a3 + 3);
      v46 = *(a3 + 4);
      *(a2 + 5) = *(a3 + 5);
      *(a2 + 6) = v45;
      *(a2 + 3) = v47;
      *(a2 + 4) = v46;
      *a3 = v58;
      *(a3 + 1) = v65;
      *(a3 + 5) = v93;
      *(a3 + 6) = v100;
      *(a3 + 3) = v79;
      *(a3 + 4) = v86;
      *(a3 + 2) = v72;
      if (sub_1016A2E60(a5, a2, a1))
      {
        v87 = *(a1 + 4);
        v94 = *(a1 + 5);
        v101 = *(a1 + 6);
        v59 = *a1;
        v66 = *(a1 + 1);
        v73 = *(a1 + 4);
        v80 = *(a1 + 3);
        v49 = *(a2 + 1);
        v48 = *(a2 + 2);
        *a1 = *a2;
        *(a1 + 1) = v49;
        *(a1 + 2) = v48;
        v50 = *(a2 + 6);
        v52 = *(a2 + 3);
        v51 = *(a2 + 4);
        *(a1 + 5) = *(a2 + 5);
        *(a1 + 6) = v50;
        *(a1 + 3) = v52;
        *(a1 + 4) = v51;
        *a2 = v59;
        *(a2 + 1) = v66;
        *(a2 + 5) = v94;
        *(a2 + 6) = v101;
        *(a2 + 3) = v80;
        *(a2 + 4) = v87;
        result = v73;
        *(a2 + 2) = v73;
      }
    }
  }

  return result;
}

BOOL sub_1016A3414(double *a1, __int128 *a2, double **a3)
{
  v6 = 0x6DB6DB6DB6DB6DB7 * ((a2 - a1) >> 4);
  if (v6 > 2)
  {
    switch(v6)
    {
      case 3:
        v7 = (a2 - 7);
        v48 = sub_1016A2E60(a3, a1 + 14, a1);
        v49 = sub_1016A2E60(a3, v7, a1 + 14);
        if (v48)
        {
          if (v49)
          {
LABEL_15:
            v50 = *(a1 + 5);
            v187 = *(a1 + 4);
            v188 = v50;
            v189 = *(a1 + 6);
            v51 = *(a1 + 1);
            v183 = *a1;
            v184 = v51;
            v52 = *(a1 + 3);
            v185 = *(a1 + 2);
            v186 = v52;
            v54 = *(v7 + 1);
            v53 = *(v7 + 2);
            *a1 = *v7;
            *(a1 + 1) = v54;
            *(a1 + 2) = v53;
            v55 = *(v7 + 6);
            v57 = *(v7 + 3);
            v56 = *(v7 + 4);
            *(a1 + 5) = *(v7 + 5);
            *(a1 + 6) = v55;
            *(a1 + 3) = v57;
            *(a1 + 4) = v56;
LABEL_16:
            v58 = v184;
            *v7 = v183;
            *(v7 + 1) = v58;
            v59 = v189;
            *(v7 + 5) = v188;
            *(v7 + 6) = v59;
            v60 = v187;
            *(v7 + 3) = v186;
            *(v7 + 4) = v60;
            result = 1;
            *(v7 + 2) = v185;
            return result;
          }

          v121 = *(a1 + 5);
          v187 = *(a1 + 4);
          v188 = v121;
          v122 = *(a1 + 7);
          v189 = *(a1 + 6);
          v123 = *(a1 + 1);
          v183 = *a1;
          v184 = v123;
          v124 = *(a1 + 3);
          v185 = *(a1 + 2);
          v186 = v124;
          v125 = *(a1 + 8);
          v126 = *(a1 + 9);
          *a1 = v122;
          *(a1 + 1) = v125;
          v128 = *(a1 + 12);
          v127 = *(a1 + 13);
          v129 = *(a1 + 10);
          *(a1 + 4) = *(a1 + 11);
          *(a1 + 5) = v128;
          *(a1 + 2) = v126;
          *(a1 + 3) = v129;
          v130 = v183;
          v131 = v185;
          v132 = v186;
          *(a1 + 8) = v184;
          *(a1 + 9) = v131;
          *(a1 + 6) = v127;
          *(a1 + 7) = v130;
          v133 = v187;
          v134 = v189;
          *(a1 + 12) = v188;
          *(a1 + 13) = v134;
          *(a1 + 10) = v132;
          *(a1 + 11) = v133;
          if (sub_1016A2E60(a3, v7, a1 + 14))
          {
            v135 = *(a1 + 12);
            v187 = *(a1 + 11);
            v188 = v135;
            v189 = *(a1 + 13);
            v136 = *(a1 + 8);
            v183 = *(a1 + 7);
            v184 = v136;
            v137 = *(a1 + 10);
            v185 = *(a1 + 9);
            v186 = v137;
            v139 = *(v7 + 1);
            v138 = *(v7 + 2);
            *(a1 + 7) = *v7;
            *(a1 + 8) = v139;
            *(a1 + 9) = v138;
            v140 = *(v7 + 6);
            v142 = *(v7 + 3);
            v141 = *(v7 + 4);
            *(a1 + 12) = *(v7 + 5);
            *(a1 + 13) = v140;
            *(a1 + 10) = v142;
            *(a1 + 11) = v141;
            goto LABEL_16;
          }

          return 1;
        }

        if (!v49)
        {
          return 1;
        }

        v71 = *(a1 + 12);
        v187 = *(a1 + 11);
        v188 = v71;
        v189 = *(a1 + 13);
        v72 = *(a1 + 8);
        v183 = *(a1 + 7);
        v184 = v72;
        v73 = *(a1 + 10);
        v185 = *(a1 + 9);
        v186 = v73;
        v75 = *(v7 + 1);
        v74 = *(v7 + 2);
        *(a1 + 7) = *v7;
        *(a1 + 8) = v75;
        *(a1 + 9) = v74;
        v76 = *(v7 + 6);
        v78 = *(v7 + 3);
        v77 = *(v7 + 4);
        *(a1 + 12) = *(v7 + 5);
        *(a1 + 13) = v76;
        *(a1 + 10) = v78;
        *(a1 + 11) = v77;
        v79 = v184;
        *v7 = v183;
        *(v7 + 1) = v79;
        v80 = v189;
        *(v7 + 5) = v188;
        *(v7 + 6) = v80;
        v81 = v187;
        *(v7 + 3) = v186;
        *(v7 + 4) = v81;
        *(v7 + 2) = v185;
        break;
      case 4:
        sub_1016A3054(a1, a1 + 14, a1 + 28, a2 - 14, a3);
        return 1;
      case 5:
        v8 = a2 - 7;
        sub_1016A3054(a1, a1 + 14, a1 + 28, a1 + 42, a3);
        if (!sub_1016A2E60(a3, v8, a1 + 42))
        {
          return 1;
        }

        v9 = *(a1 + 26);
        v187 = *(a1 + 25);
        v188 = v9;
        v189 = *(a1 + 27);
        v10 = *(a1 + 22);
        v183 = *(a1 + 21);
        v184 = v10;
        v11 = *(a1 + 24);
        v185 = *(a1 + 23);
        v186 = v11;
        v13 = v8[1];
        v12 = v8[2];
        *(a1 + 21) = *v8;
        *(a1 + 22) = v13;
        *(a1 + 23) = v12;
        v14 = v8[6];
        v16 = v8[3];
        v15 = v8[4];
        *(a1 + 26) = v8[5];
        *(a1 + 27) = v14;
        *(a1 + 24) = v16;
        *(a1 + 25) = v15;
        v17 = v184;
        *v8 = v183;
        v8[1] = v17;
        v18 = v189;
        v8[5] = v188;
        v8[6] = v18;
        v19 = v187;
        v8[3] = v186;
        v8[4] = v19;
        v8[2] = v185;
        if (!sub_1016A2E60(a3, a1 + 42, a1 + 28))
        {
          return 1;
        }

        v20 = *(a1 + 19);
        v187 = *(a1 + 18);
        v188 = v20;
        v21 = *(a1 + 21);
        v189 = *(a1 + 20);
        v22 = *(a1 + 15);
        v183 = *(a1 + 14);
        v184 = v22;
        v23 = *(a1 + 17);
        v185 = *(a1 + 16);
        v186 = v23;
        v24 = *(a1 + 22);
        v25 = *(a1 + 23);
        *(a1 + 14) = v21;
        *(a1 + 15) = v24;
        v27 = *(a1 + 26);
        v26 = *(a1 + 27);
        v28 = *(a1 + 24);
        *(a1 + 18) = *(a1 + 25);
        *(a1 + 19) = v27;
        *(a1 + 16) = v25;
        *(a1 + 17) = v28;
        v29 = v183;
        v30 = v185;
        v31 = v186;
        *(a1 + 22) = v184;
        *(a1 + 23) = v30;
        *(a1 + 20) = v26;
        *(a1 + 21) = v29;
        v32 = v187;
        v33 = v189;
        *(a1 + 26) = v188;
        *(a1 + 27) = v33;
        *(a1 + 24) = v31;
        *(a1 + 25) = v32;
        if (!sub_1016A2E60(a3, a1 + 28, a1 + 14))
        {
          return 1;
        }

        v34 = *(a1 + 12);
        v187 = *(a1 + 11);
        v188 = v34;
        v35 = *(a1 + 14);
        v189 = *(a1 + 13);
        v36 = *(a1 + 8);
        v183 = *(a1 + 7);
        v184 = v36;
        v37 = *(a1 + 10);
        v185 = *(a1 + 9);
        v186 = v37;
        v38 = *(a1 + 15);
        v39 = *(a1 + 16);
        *(a1 + 7) = v35;
        *(a1 + 8) = v38;
        v41 = *(a1 + 19);
        v40 = *(a1 + 20);
        v42 = *(a1 + 17);
        *(a1 + 11) = *(a1 + 18);
        *(a1 + 12) = v41;
        *(a1 + 9) = v39;
        *(a1 + 10) = v42;
        v43 = v183;
        v44 = v185;
        v45 = v186;
        *(a1 + 15) = v184;
        *(a1 + 16) = v44;
        *(a1 + 13) = v40;
        *(a1 + 14) = v43;
        v46 = v187;
        v47 = v189;
        *(a1 + 19) = v188;
        *(a1 + 20) = v47;
        *(a1 + 17) = v45;
        *(a1 + 18) = v46;
        break;
      default:
        goto LABEL_17;
    }

    if (sub_1016A2E60(a3, a1 + 14, a1))
    {
      v82 = *(a1 + 5);
      v187 = *(a1 + 4);
      v188 = v82;
      v83 = *(a1 + 7);
      v189 = *(a1 + 6);
      v84 = *(a1 + 1);
      v183 = *a1;
      v184 = v84;
      v85 = *(a1 + 3);
      v185 = *(a1 + 2);
      v186 = v85;
      v86 = *(a1 + 8);
      v87 = *(a1 + 9);
      *a1 = v83;
      *(a1 + 1) = v86;
      v89 = *(a1 + 12);
      v88 = *(a1 + 13);
      v90 = *(a1 + 10);
      *(a1 + 4) = *(a1 + 11);
      *(a1 + 5) = v89;
      *(a1 + 2) = v87;
      *(a1 + 3) = v90;
      v91 = v183;
      v92 = v185;
      v93 = v186;
      *(a1 + 8) = v184;
      *(a1 + 9) = v92;
      *(a1 + 6) = v88;
      *(a1 + 7) = v91;
      v94 = v187;
      v95 = v189;
      *(a1 + 12) = v188;
      *(a1 + 13) = v95;
      *(a1 + 10) = v93;
      *(a1 + 11) = v94;
    }

    return 1;
  }

  if (v6 < 2)
  {
    return 1;
  }

  if (v6 == 2)
  {
    v7 = (a2 - 7);
    if (!sub_1016A2E60(a3, a2 - 14, a1))
    {
      return 1;
    }

    goto LABEL_15;
  }

LABEL_17:
  v62 = a1 + 28;
  v63 = sub_1016A2E60(a3, a1 + 14, a1);
  v64 = sub_1016A2E60(a3, a1 + 28, a1 + 14);
  if (v63)
  {
    if (v64)
    {
      v65 = *(a1 + 5);
      v187 = *(a1 + 4);
      v188 = v65;
      v189 = *(a1 + 6);
      v66 = *(a1 + 1);
      v183 = *a1;
      v184 = v66;
      v67 = *(a1 + 3);
      v185 = *(a1 + 2);
      v186 = v67;
      v68 = *(a1 + 15);
      *a1 = *v62;
      *(a1 + 1) = v68;
      v69 = *(a1 + 20);
      *(a1 + 5) = *(a1 + 19);
      *(a1 + 6) = v69;
      v70 = *(a1 + 18);
      *(a1 + 3) = *(a1 + 17);
      *(a1 + 4) = v70;
      *(a1 + 2) = *(a1 + 16);
    }

    else
    {
      v143 = *(a1 + 5);
      v187 = *(a1 + 4);
      v188 = v143;
      v144 = *(a1 + 7);
      v189 = *(a1 + 6);
      v145 = *(a1 + 1);
      v183 = *a1;
      v184 = v145;
      v146 = *(a1 + 3);
      v185 = *(a1 + 2);
      v186 = v146;
      v147 = *(a1 + 8);
      v148 = *(a1 + 9);
      *a1 = v144;
      *(a1 + 1) = v147;
      v150 = *(a1 + 12);
      v149 = *(a1 + 13);
      v151 = *(a1 + 10);
      *(a1 + 4) = *(a1 + 11);
      *(a1 + 5) = v150;
      *(a1 + 2) = v148;
      *(a1 + 3) = v151;
      v152 = v183;
      v153 = v185;
      v154 = v186;
      *(a1 + 8) = v184;
      *(a1 + 9) = v153;
      *(a1 + 6) = v149;
      *(a1 + 7) = v152;
      v155 = v187;
      v156 = v189;
      *(a1 + 12) = v188;
      *(a1 + 13) = v156;
      *(a1 + 10) = v154;
      *(a1 + 11) = v155;
      if (!sub_1016A2E60(a3, a1 + 28, a1 + 14))
      {
        goto LABEL_33;
      }

      v157 = *(a1 + 12);
      v187 = *(a1 + 11);
      v188 = v157;
      v189 = *(a1 + 13);
      v158 = *(a1 + 8);
      v183 = *(a1 + 7);
      v184 = v158;
      v159 = *(a1 + 10);
      v185 = *(a1 + 9);
      v186 = v159;
      v160 = *(a1 + 15);
      *(a1 + 7) = *v62;
      *(a1 + 8) = v160;
      v161 = *(a1 + 20);
      *(a1 + 12) = *(a1 + 19);
      *(a1 + 13) = v161;
      v162 = *(a1 + 18);
      *(a1 + 10) = *(a1 + 17);
      *(a1 + 11) = v162;
      *(a1 + 9) = *(a1 + 16);
    }

    v163 = v184;
    *v62 = v183;
    *(a1 + 15) = v163;
    v164 = v185;
    v165 = v186;
    v166 = v189;
    *(a1 + 19) = v188;
    *(a1 + 20) = v166;
    v167 = v187;
    *(a1 + 17) = v165;
    *(a1 + 18) = v167;
    *(a1 + 16) = v164;
  }

  else if (v64)
  {
    v96 = *(a1 + 12);
    v187 = *(a1 + 11);
    v188 = v96;
    v189 = *(a1 + 13);
    v97 = *(a1 + 8);
    v183 = *(a1 + 7);
    v184 = v97;
    v98 = *(a1 + 10);
    v185 = *(a1 + 9);
    v186 = v98;
    v99 = *(a1 + 15);
    *(a1 + 7) = *v62;
    *(a1 + 8) = v99;
    v100 = *(a1 + 20);
    *(a1 + 12) = *(a1 + 19);
    *(a1 + 13) = v100;
    v101 = *(a1 + 18);
    *(a1 + 10) = *(a1 + 17);
    *(a1 + 11) = v101;
    *(a1 + 9) = *(a1 + 16);
    v102 = v184;
    *v62 = v183;
    *(a1 + 15) = v102;
    v103 = v185;
    v104 = v186;
    v105 = v189;
    *(a1 + 19) = v188;
    *(a1 + 20) = v105;
    v106 = v187;
    *(a1 + 17) = v104;
    *(a1 + 18) = v106;
    *(a1 + 16) = v103;
    if (sub_1016A2E60(a3, a1 + 14, a1))
    {
      v107 = *(a1 + 5);
      v187 = *(a1 + 4);
      v188 = v107;
      v108 = *(a1 + 7);
      v189 = *(a1 + 6);
      v109 = *(a1 + 1);
      v183 = *a1;
      v184 = v109;
      v110 = *(a1 + 3);
      v185 = *(a1 + 2);
      v186 = v110;
      v111 = *(a1 + 8);
      v112 = *(a1 + 9);
      *a1 = v108;
      *(a1 + 1) = v111;
      v114 = *(a1 + 12);
      v113 = *(a1 + 13);
      v115 = *(a1 + 10);
      *(a1 + 4) = *(a1 + 11);
      *(a1 + 5) = v114;
      *(a1 + 2) = v112;
      *(a1 + 3) = v115;
      v116 = v183;
      v117 = v185;
      v118 = v186;
      *(a1 + 8) = v184;
      *(a1 + 9) = v117;
      *(a1 + 6) = v113;
      *(a1 + 7) = v116;
      v119 = v187;
      v120 = v189;
      *(a1 + 12) = v188;
      *(a1 + 13) = v120;
      *(a1 + 10) = v118;
      *(a1 + 11) = v119;
    }
  }

LABEL_33:
  v168 = a1 + 42;
  if (a1 + 42 == a2)
  {
    return 1;
  }

  v169 = 0;
  v170 = 0;
  while (1)
  {
    if (sub_1016A2E60(a3, v168, v62))
    {
      v171 = *(v168 + 5);
      v187 = *(v168 + 4);
      v188 = v171;
      v189 = *(v168 + 6);
      v172 = *(v168 + 1);
      v183 = *v168;
      v184 = v172;
      v173 = *(v168 + 3);
      v174 = v169;
      v185 = *(v168 + 2);
      v186 = v173;
      while (1)
      {
        v175 = a1 + v174;
        v176 = *(a1 + v174 + 304);
        *(v175 + 400) = *(a1 + v174 + 288);
        *(v175 + 416) = v176;
        *(v175 + 432) = *(a1 + v174 + 320);
        v177 = *(a1 + v174 + 240);
        *(v175 + 336) = *(a1 + v174 + 224);
        *(v175 + 352) = v177;
        v178 = *(a1 + v174 + 272);
        *(v175 + 368) = *(a1 + v174 + 256);
        *(v175 + 384) = v178;
        if (v174 == -224)
        {
          break;
        }

        v174 -= 112;
        if ((sub_1016A2E60(a3, &v183, (v175 + 112)) & 1) == 0)
        {
          v179 = (a1 + v174 + 336);
          goto LABEL_41;
        }
      }

      v179 = a1;
LABEL_41:
      v180 = v188;
      *(v179 + 4) = v187;
      *(v179 + 5) = v180;
      *(v179 + 6) = v189;
      v181 = v184;
      *v179 = v183;
      *(v179 + 1) = v181;
      v182 = v186;
      ++v170;
      *(v179 + 2) = v185;
      *(v179 + 3) = v182;
      if (v170 == 8)
      {
        return v168 + 14 == a2;
      }
    }

    v62 = v168;
    v169 += 112;
    v168 += 14;
    if (v168 == a2)
    {
      return 1;
    }
  }
}

uint64_t sub_1016A3B70(double *a1, double *a2, double *a3)
{
  if ((atomic_load_explicit(&qword_101FCB088, memory_order_acquire) & 1) == 0)
  {
    v68 = a1;
    v69 = a3;
    v70 = a2;
    v71 = __cxa_guard_acquire(&qword_101FCB088);
    a2 = v70;
    a3 = v69;
    v72 = v71;
    a1 = v68;
    if (v72)
    {
      qword_101FCB080 = 0x4056800000000000;
      __cxa_guard_release(&qword_101FCB088);
      a1 = v68;
      a2 = v70;
      a3 = v69;
    }
  }

  if ((atomic_load_explicit(&qword_101FCB098, memory_order_acquire) & 1) == 0)
  {
    v73 = a1;
    v74 = a3;
    v75 = a2;
    v76 = __cxa_guard_acquire(&qword_101FCB098);
    a2 = v75;
    a3 = v74;
    v77 = v76;
    a1 = v73;
    if (v77)
    {
      qword_101FCB090 = 0x4056800000000000;
      __cxa_guard_release(&qword_101FCB098);
      a1 = v73;
      a2 = v75;
      a3 = v74;
    }
  }

  v3 = *a1;
  v4 = a1[1];
  v6 = *a2;
  v5 = a2[1];
  v8 = *a3;
  v7 = a3[1];
  if (*a2 == *a1)
  {
    goto LABEL_14;
  }

  if ((*&v6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v3 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v46 = fabs(v6);
    v47 = fabs(v3);
    v48 = vabdd_f64(v6, v3);
    if (v46 < v47)
    {
      v46 = v47;
    }

    if (v46 < 1.0)
    {
      v46 = 1.0;
    }

    if (v48 <= v46 * 2.22044605e-16)
    {
LABEL_14:
      if (v5 == v4)
      {
        return 0;
      }

      if ((*&v5 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v4 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v10 = fabs(v5);
        v11 = fabs(v4);
        v12 = vabdd_f64(v5, v4);
        if (v10 < v11)
        {
          v10 = v11;
        }

        if (v10 < 1.0)
        {
          v10 = 1.0;
        }

        if (v12 <= v10 * 2.22044605e-16)
        {
          return 0;
        }
      }
    }
  }

  if (v6 == v8)
  {
    goto LABEL_37;
  }

  if ((*&v6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v8 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v15 = fabs(v6);
    v16 = fabs(v8);
    v17 = vabdd_f64(v6, v8);
    if (v15 < v16)
    {
      v15 = v16;
    }

    if (v15 < 1.0)
    {
      v15 = 1.0;
    }

    if (v17 <= v15 * 2.22044605e-16)
    {
LABEL_37:
      if (v5 == v7)
      {
        return 0;
      }

      if ((*&v5 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v7 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v18 = fabs(v5);
        v19 = fabs(v7);
        v20 = vabdd_f64(v5, v7);
        if (v18 < v19)
        {
          v18 = v19;
        }

        if (v18 < 1.0)
        {
          v18 = 1.0;
        }

        if (v20 <= v18 * 2.22044605e-16)
        {
          return 0;
        }
      }
    }
  }

  v21 = fabs(v4);
  if (*&qword_101FCB080 == v21)
  {
    v22 = 1;
  }

  else
  {
    v22 = 0;
    if ((*&v4 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (qword_101FCB080 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v23 = fabs(*&qword_101FCB080);
      v24 = vabdd_f64(*&qword_101FCB080, v21);
      if (v23 >= v21)
      {
        v21 = v23;
      }

      if (v21 < 1.0)
      {
        v21 = 1.0;
      }

      v22 = v24 <= v21 * 2.22044605e-16;
    }
  }

  v25 = fabs(v5);
  if (*&qword_101FCB080 == v25)
  {
    v26 = 1;
  }

  else
  {
    v26 = 0;
    if ((*&v5 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (qword_101FCB080 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v27 = fabs(*&qword_101FCB080);
      v28 = vabdd_f64(*&qword_101FCB080, v25);
      if (v27 >= v25)
      {
        v25 = v27;
      }

      if (v25 < 1.0)
      {
        v25 = 1.0;
      }

      v26 = v28 <= v25 * 2.22044605e-16;
    }
  }

  v29 = fabs(v7);
  if (*&qword_101FCB090 == v29)
  {
    v30 = 1;
  }

  else
  {
    v30 = 0;
    if ((*&v7 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (qword_101FCB090 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v31 = fabs(*&qword_101FCB090);
      v32 = vabdd_f64(*&qword_101FCB090, v29);
      if (v31 >= v29)
      {
        v29 = v31;
      }

      if (v29 < 1.0)
      {
        v29 = 1.0;
      }

      v30 = v32 <= v29 * 2.22044605e-16;
    }
  }

  if (v26)
  {
    if (v22)
    {
      v33 = (v4 < 0.0) ^ (v5 >= 0.0);
      if (v4 > 0.0)
      {
        v33 = 0;
      }

      if (v5 > 0.0)
      {
        v33 = v4 > 0.0;
      }

      if (v33)
      {
        return 0;
      }
    }

    if (v30)
    {
      v34 = (v5 >= 0.0) ^ (v7 < 0.0);
      if (v7 > 0.0)
      {
        v34 = 0;
      }

      if (v5 > 0.0)
      {
        v34 = v7 > 0.0;
      }

      if (v34)
      {
        return 0;
      }
    }
  }

  v35 = vabdd_f64(v3, v6);
  v36 = 180.0;
  if (v35 == 180.0)
  {
    goto LABEL_79;
  }

  v37 = v3 - v6;
  if (COERCE__INT64(fabs(v3 - v6)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v49 = fabs(v35 + -180.0);
    v36 = 180.0;
    if (v35 < 180.0)
    {
      v35 = 180.0;
    }

    if (v35 < 1.0)
    {
      v35 = 1.0;
    }

    if (v49 <= v35 * 2.22044605e-16)
    {
      goto LABEL_79;
    }
  }

  v36 = 180.0;
  if (v37 <= 180.0)
  {
    if (v37 >= -180.0)
    {
      goto LABEL_80;
    }

    v36 = fmod(v37 + -180.0, 360.0) + 180.0;
    goto LABEL_79;
  }

  v50 = fmod(v37 + 180.0, 360.0);
  v37 = v50 + -180.0;
  if (v50 + -180.0 == -180.0)
  {
    goto LABEL_79;
  }

  if (COERCE_UNSIGNED_INT64(fabs(v50 + -180.0)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v51 = fabs(v37);
    v36 = 180.0;
    v52 = fabs(v37 + 180.0);
    if (v51 < 180.0)
    {
      v51 = 180.0;
    }

    if (v51 < 1.0)
    {
      v51 = 1.0;
    }

    if (v52 <= v51 * 2.22044605e-16)
    {
LABEL_79:
      v37 = v36;
    }
  }

LABEL_80:
  v38 = vabdd_f64(v8, v6);
  v39 = 180.0;
  if (v38 == 180.0)
  {
    goto LABEL_81;
  }

  v40 = v8 - v6;
  if ((*&v40 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v53 = fabs(v38 + -180.0);
    v39 = 180.0;
    if (v38 < 180.0)
    {
      v38 = 180.0;
    }

    if (v38 < 1.0)
    {
      v38 = 1.0;
    }

    if (v53 <= v38 * 2.22044605e-16)
    {
      goto LABEL_81;
    }
  }

  v39 = 180.0;
  if (v40 > 180.0)
  {
    v54 = fmod(v40 + 180.0, 360.0);
    v40 = v54 + -180.0;
    if (v54 + -180.0 != -180.0)
    {
      if (COERCE_UNSIGNED_INT64(fabs(v54 + -180.0)) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_82;
      }

      v55 = fabs(v40);
      v39 = 180.0;
      v56 = fabs(v40 + 180.0);
      if (v55 < 180.0)
      {
        v55 = 180.0;
      }

      if (v55 < 1.0)
      {
        v55 = 1.0;
      }

      if (v56 > v55 * 2.22044605e-16)
      {
        goto LABEL_82;
      }
    }

    goto LABEL_81;
  }

  if (v40 < -180.0)
  {
    v39 = fmod(v40 + -180.0, 360.0) + 180.0;
LABEL_81:
    v40 = v39;
  }

LABEL_82:
  if ((atomic_load_explicit(&qword_101FCB0A8, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_101FCB0A8))
  {
    qword_101FCB0A0 = 0x4066800000000000;
    __cxa_guard_release(&qword_101FCB0A8);
  }

  v41 = fabs(v37);
  v42 = &unk_101FCB000;
  v43 = *&qword_101FCB0A0;
  if (v41 == *&qword_101FCB0A0)
  {
    goto LABEL_84;
  }

  v44 = v4 - v5;
  if ((*&v37 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (qword_101FCB0A0 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    goto LABEL_130;
  }

  v57 = fabs(*&qword_101FCB0A0);
  v58 = vabdd_f64(v41, *&qword_101FCB0A0);
  if (v41 >= v57)
  {
    v57 = v41;
  }

  if (v57 < 1.0)
  {
    v57 = 1.0;
  }

  if (v58 <= v57 * 2.22044605e-16)
  {
LABEL_84:
    if (v4 + v5 < 0.0)
    {
      v43 = -*&qword_101FCB0A0;
    }

    v44 = v43 - (v4 + v5);
    v45 = 1;
  }

  else
  {
LABEL_130:
    v45 = 0;
  }

  if ((atomic_load_explicit(&qword_101FCB0A8, memory_order_acquire) & 1) == 0)
  {
    v78 = v44;
    v79 = __cxa_guard_acquire(&qword_101FCB0A8);
    v42 = &unk_101FCB000;
    v44 = v78;
    if (v79)
    {
      qword_101FCB0A0 = 0x4066800000000000;
      __cxa_guard_release(&qword_101FCB0A8);
      v42 = &unk_101FCB000;
      v44 = v78;
    }
  }

  v59 = fabs(v40);
  v60 = v42[20];
  if (v59 == v60)
  {
    goto LABEL_133;
  }

  v62 = v7 - v5;
  if ((*&v40 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v60 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v63 = fabs(v60);
    v64 = vabdd_f64(v59, v60);
    if (v59 >= v63)
    {
      v63 = v59;
    }

    if (v63 < 1.0)
    {
      v63 = 1.0;
    }

    if (v64 <= v63 * 2.22044605e-16)
    {
LABEL_133:
      v61 = v5 + v7;
      if (v5 + v7 >= 0.0)
      {
        v62 = v60 - v61;
      }

      else
      {
        v62 = -v60 - v61;
      }

      v59 = 0.0;
    }
  }

  if (v45)
  {
    v65 = 0.0;
  }

  else
  {
    v65 = v41;
  }

  if (v59 >= v65)
  {
    v59 = v65;
  }

  if (v22 || v26 || v30)
  {
    v59 = 0.0;
  }

  v66 = fabs(v44);
  v67 = fabs(v62);
  if (v67 < v66)
  {
    v66 = v67;
  }

  if (v59 >= v66)
  {
    v44 = v37;
    v62 = v40;
  }

  if (v62 > 0.0 != v44 <= 0.0)
  {
    return 0xFFFFFFFFLL;
  }

  else
  {
    return 1;
  }
}

uint64_t sub_1016A4404(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a2 != result)
  {
    v5 = 0x6DB6DB6DB6DB6DB7 * ((a2 - result) >> 4);
    if (v5 <= 1)
    {
      v5 = 1;
    }

    v6 = 56;
    if (a5 == 1)
    {
      v6 = 48;
    }

    do
    {
      v7 = *(result + 16);
      if (a4 >= a3)
      {
        if (v7 < a3 || v7 > a4)
        {
          goto LABEL_13;
        }
      }

      else if (v7 < a3 && v7 > a4)
      {
        goto LABEL_13;
      }

      ++*(result + v6);
LABEL_13:
      result += 112;
      --v5;
    }

    while (v5);
  }

  return result;
}

void sub_1016A4484(void *a1)
{
  if (a1)
  {
    sub_1016A4484(*a1);
    sub_1016A4484(a1[1]);
    v2 = a1[7];
    if (v2)
    {
      a1[8] = v2;
      operator delete(v2);
    }

    operator delete(a1);
  }
}

uint64_t sub_1016A44E0(uint64_t result, void *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  if (*a4 <= 0)
  {
    v41[13] = v5;
    v41[14] = v6;
    v7 = a5;
    v10 = result;
    if (a5 == -1)
    {
      v7 = (*a2)++;
    }

    *a4 = v7;
    v11 = a4[1];
    v12 = a4 + 2;
    if (v11 != a4 + 2)
    {
      v13 = (result + 40);
      do
      {
        v14 = *(v10 + 16);
        v15 = *(v14 + 32) + v11[4];
        v16 = *(*(v14 + 8) + ((v15 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * (v15 & 0xF);
        if ((*(v16 + 32) & 1) == 0)
        {
          v17 = *(v16 + 40);
          v18 = *(v16 + 208);
          v19 = v17 == 3 && v18 == 3;
          if (!v19)
          {
            if (*(v16 + 24) <= 0)
            {
              if (v17 == 1)
              {
                if (v18 != 1)
                {
                  goto LABEL_26;
                }
              }

              else if (v17 != 2 || v18 != 2)
              {
LABEL_26:
                v21 = *a3;
                for (i = 40; i != 376; i += 168)
                {
                  v24 = *(v16 + i + 8);
                  v23 = *(v16 + i + 16);
                  v25 = *(v16 + i + 24);
                  v41[0] = v24;
                  v41[1] = v23;
                  v41[2] = v25;
                  if (v24 != v21 || v25 != a3[2] || v23 != a3[1])
                  {
                    v28 = *v13;
                    if (*v13)
                    {
                      v29 = (v10 + 40);
                      do
                      {
                        v30 = v28[4];
                        v31 = v30 < v24;
                        if (v30 == v24)
                        {
                          v32 = v28[5];
                          v31 = v32 < v23;
                          if (v32 == v23)
                          {
                            v31 = v28[6] < v25;
                          }
                        }

                        v33 = v31;
                        v34 = v33 == 0;
                        if (v33)
                        {
                          v35 = 1;
                        }

                        else
                        {
                          v35 = 0;
                        }

                        if (v34)
                        {
                          v29 = v28;
                        }

                        v28 = v28[v35];
                      }

                      while (v28);
                      if (v13 != v29)
                      {
                        v36 = v29[4];
                        v37 = v24 < v36;
                        if (v24 == v36)
                        {
                          v38 = v29[5];
                          v37 = v23 < v38;
                          if (v23 == v38)
                          {
                            v37 = v25 < v29[6];
                          }
                        }

                        if (!v37)
                        {
                          result = sub_1016A44E0(v10, a2, v41, v29 + 7, v7);
                          v21 = *a3;
                        }
                      }
                    }
                  }
                }
              }
            }

            else if (v17 == 1)
            {
              if (v18 != 2)
              {
                goto LABEL_26;
              }
            }

            else if (v17 != 2 || (v18 - 1) >= 2)
            {
              goto LABEL_26;
            }
          }
        }

        v39 = v11[1];
        if (v39)
        {
          do
          {
            v40 = v39;
            v39 = *v39;
          }

          while (v39);
        }

        else
        {
          do
          {
            v40 = v11[2];
            v19 = *v40 == v11;
            v11 = v40;
          }

          while (!v19);
        }

        v11 = v40;
      }

      while (v40 != v12);
    }
  }

  return result;
}

void sub_1016A4718(void *a1)
{
  if (a1)
  {
    sub_1016A4718(*a1);
    sub_1016A4718(a1[1]);
    sub_100034450(a1[9]);

    operator delete(a1);
  }
}

void sub_1016A476C(void *a1)
{
  if (a1)
  {
    sub_1016A476C(*a1);
    sub_1016A476C(a1[1]);
    sub_1016A47C8(a1[11]);
    sub_100034450(a1[8]);

    operator delete(a1);
  }
}

void sub_1016A47C8(void *a1)
{
  if (a1)
  {
    sub_1016A47C8(*a1);
    sub_1016A47C8(a1[1]);
    sub_100034450(a1[7]);

    operator delete(a1);
  }
}

void *sub_1016A481C(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 8);
  if (!v2)
  {
LABEL_8:
    operator new();
  }

  while (1)
  {
    while (1)
    {
      v3 = v2;
      v4 = v2[4];
      if (v4 <= a2)
      {
        break;
      }

      v2 = *v3;
      if (!*v3)
      {
        goto LABEL_8;
      }
    }

    if (v4 >= a2)
    {
      return v3;
    }

    v2 = v3[1];
    if (!v2)
    {
      goto LABEL_8;
    }
  }
}

void *sub_1016A4924(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 8);
  if (!v2)
  {
LABEL_8:
    operator new();
  }

  while (1)
  {
    while (1)
    {
      v3 = v2;
      v4 = v2[4];
      if (v4 <= a2)
      {
        break;
      }

      v2 = *v3;
      if (!*v3)
      {
        goto LABEL_8;
      }
    }

    if (v4 >= a2)
    {
      return v3;
    }

    v2 = v3[1];
    if (!v2)
    {
      goto LABEL_8;
    }
  }
}

void sub_1016A4A18(void *a1, uint64_t a2, uint64_t a3, unsigned int a4, void *a5, unint64_t *a6, _BYTE *a7)
{
  v7 = a2 + 168 * a4;
  if (*(v7 + 200) || *(v7 + 144) != 1 || (*(v7 + 204) & 1) != 0)
  {
    return;
  }

  v8 = *(v7 + 40);
  if (v8 != 4 && v8 != 2)
  {
    return;
  }

  __p = 0;
  v99 = 0;
  v100 = 0;
  v16 = *(*(a1[9] + 8) + (((*(a1[9] + 32) + a3) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(a1[9] + 32) + a3) & 0xF);
  sub_1016A59F4(&__p, v16);
  v102 = a3;
  LODWORD(v101) = a4;
  v17 = a4;
  if (sub_1016A5CE8(a1, a3, a4, &v102, &v101, &__p, 1))
  {
    goto LABEL_10;
  }

  v42 = v16 + 168 * a4 + 40;
  if (v102 == a3)
  {
LABEL_35:
    v43 = v42;
LABEL_36:
    *(v43 + 160) = 3;
    v44 = __p;
    if ((v99 - __p) >= 0x31)
    {
      sub_1016A547C(&__p);
      sub_1016A5648(a5, &__p);
      sub_1016A5840(a1, a1[10]);
      ++*a6;
      v44 = __p;
    }

    goto LABEL_38;
  }

  v50 = *(v16 + 24);
  if (v50 <= 0)
  {
    v51 = a1[9];
  }

  else
  {
    if (v101 >= 2)
    {
      __assert_rtn("operator[]", "array.hpp", 117, "(i < N)&&(out of range)");
    }

    v51 = a1[9];
    v52 = *(v51[1] + (((v102 + v51[4]) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v51 + 8) + v102) & 0xF);
    if (*(v52 + 24) == v50)
    {
      v43 = v52 + 168 * v101 + 40;
      v53 = *(v52 + 168 * v101 + 136);
      if (v53 == -1)
      {
        v53 = *(v52 + 168 * v101 + 128);
      }

      if (v53 == a3)
      {
        goto LABEL_36;
      }
    }
  }

  v55 = 2 * v51[5] + 3;
  while (!sub_1016A5CE8(a1, a3, a4, &v102, &v101, &__p, 0))
  {
    if (v102 == a3 && v101 == a4)
    {
      goto LABEL_35;
    }

    if (!--v55)
    {
      break;
    }
  }

LABEL_10:
  v18 = *a6;
  v19 = a1[8];
  v20 = a1[9];
  v96 = v20[4] + a3;
  v97 = *(v20[1] + ((v96 >> 1) & 0x7FFFFFFFFFFFFFF8));
  v21 = a1[7];
  v23 = a1[12];
  v22 = a1[13];
  *a7 = 0;
  if ((a7[1] & 1) == 0)
  {
    a7[1] = 1;
    sub_1016A7790(v21, v23, v22);
    sub_1016A7790(v19, v23, v22);
  }

  v24 = a5[5];
  v25 = v18 - v24;
  v94 = v20;
  v95 = v17;
  if (v18 <= v24)
  {
    if (v18 < v24)
    {
      v45 = a5[4];
      v47 = a5[1];
      v46 = a5[2];
      v48 = (v47 + 8 * (v45 / 0xAA));
      v49 = v46 == v47 ? 0 : *v48 + 24 * (v45 % 0xAA);
      v102 = (v47 + 8 * (v45 / 0xAA));
      v103 = v49;
      sub_10164FCF4(&v102, v18);
      v57 = (v47 + 8 * ((v45 + v24) / 0xAA));
      v58 = v46 == v47 ? 0 : *v57 + 24 * ((v45 + v24) % 0xAA);
      if (v58 != v103)
      {
        v59 = 170 * (v57 - v102) - 0x5555555555555555 * ((v58 - *v57) >> 3);
        v60 = (v103 - *v102) >> 3;
        v61 = v59 + 0x5555555555555555 * v60;
        if (v61 >= 1)
        {
          if (v46 == v47)
          {
            v62 = 0;
          }

          else
          {
            v62 = *v48 + 24 * (v45 % 0xAA);
          }

          if (v103 == v62)
          {
            v63 = 0;
          }

          else
          {
            v63 = 170 * (v102 - v48) - 0x5555555555555555 * v60 + 0x5555555555555555 * ((v62 - *v48) >> 3);
          }

          v102 = (v47 + 8 * (v45 / 0xAA));
          v103 = v62;
          sub_10164FCF4(&v102, v63);
          v64 = v103;
          if (v103 != v58)
          {
            v65 = v102;
            do
            {
              v66 = *v64;
              if (*v64)
              {
                *(v64 + 8) = v66;
                operator delete(v66);
              }

              v64 += 24;
              if (v64 - *v65 == 4080)
              {
                v67 = v65[1];
                ++v65;
                v64 = v67;
              }
            }

            while (v64 != v58);
            v47 = a5[1];
            v46 = a5[2];
            v45 = a5[4];
            v24 = a5[5];
          }

          v68 = 170 * ((v46 - v47) >> 3) - 1;
          if (v46 == v47)
          {
            v68 = 0;
          }

          a5[5] = v24 - v61;
          if (v68 - (v24 - v61 + v45) >= 0x154)
          {
            do
            {
              operator delete(*(v46 - 8));
              v69 = a5[1];
              v46 = a5[2] - 8;
              v70 = 170 * ((v46 - v69) >> 3) - 1;
              a5[2] = v46;
              if (v46 == v69)
              {
                v70 = 0;
              }
            }

            while ((v70 - (a5[5] + a5[4])) > 0x153);
          }
        }
      }
    }
  }

  else
  {
    v26 = a5[1];
    v27 = a5[2];
    v28 = (v27 - v26) >> 3;
    if (v27 == v26)
    {
      v29 = 0;
    }

    else
    {
      v29 = 170 * v28 - 1;
    }

    v30 = a5[4];
    v31 = v30 + v24;
    v32 = v29 - (v30 + v24);
    v33 = v25 >= v32;
    v34 = v25 - v32;
    if (v34 != 0 && v33)
    {
      if (v27 == v26)
      {
        v35 = v34 + 1;
      }

      else
      {
        v35 = v34;
      }

      if (v35 % 0xAA)
      {
        v36 = v35 / 0xAA + 1;
      }

      else
      {
        v36 = v35 / 0xAA;
      }

      if (v36 >= v30 / 0xAA)
      {
        v37 = v30 / 0xAA;
      }

      else
      {
        v37 = v36;
      }

      if (v36 <= v30 / 0xAA)
      {
        for (a5[4] = v30 - 170 * v37; v37; --v37)
        {
          v54 = a5[1];
          v102 = *v54;
          a5[1] = v54 + 1;
          sub_1010F098C(a5, &v102);
        }
      }

      else
      {
        v38 = v36 - v37;
        v39 = a5[3] - *a5;
        if (v36 - v37 > (v39 >> 3) - v28)
        {
          v40 = v39 >> 2;
          if (v40 <= v38 + v28)
          {
            v41 = v38 + v28;
          }

          else
          {
            v41 = v40;
          }

          v105 = a5;
          if (v41)
          {
            sub_100EF4E80(v41);
          }

          v102 = 0;
          v103 = 8 * (v28 - v37);
          v104 = v103;
          operator new();
        }

        if (v38)
        {
          if (a5[3] != a5[2])
          {
            operator new();
          }

          operator new();
        }

        for (a5[4] = v30 - 170 * v37; v37; --v37)
        {
          v71 = a5[1];
          v102 = *v71;
          a5[1] = v71 + 1;
          sub_1010F098C(a5, &v102);
        }
      }

      v24 = a5[5];
      v26 = a5[1];
      v27 = a5[2];
      v31 = a5[4] + v24;
    }

    v72 = (v26 + 8 * (v31 / 0xAA));
    if (v27 == v26)
    {
      v73 = 0;
      v74 = 0;
    }

    else
    {
      v73 = (*v72 + 24 * (v31 % 0xAA));
      v74 = v73;
    }

    v102 = v72;
    v103 = v74;
    sub_10164FCF4(&v102, v25);
    v75 = v103;
    if (v73 != v103)
    {
      v76 = v102;
      do
      {
        if (v72 == v76)
        {
          v77 = v75;
        }

        else
        {
          v77 = *v72 + 4080;
        }

        if (v73 == v77)
        {
          v79 = v73;
        }

        else
        {
          v78 = 24 * ((v77 - v73 - 24) / 0x18uLL) + 24;
          bzero(v73, v78);
          v79 = &v73[v78];
          v24 = a5[5];
        }

        v24 -= 0x5555555555555555 * ((v79 - v73) >> 3);
        a5[5] = v24;
        if (v72 == v76)
        {
          break;
        }

        v80 = v72[1];
        ++v72;
        v73 = v80;
      }

      while (v80 != v75);
    }
  }

  v81 = v97 + 376 * (v96 & 0xF) + 168 * v95;
  v44 = __p;
  v99 = __p;
  *(v81 + 200) = 4;
  *(v81 + 204) = 1;
  v82 = v94[4];
  v83 = v94[1];
  v84 = v94[2];
  v85 = (v83 + 8 * (v82 >> 4));
  if (v84 == v83)
  {
    v86 = 0;
  }

  else
  {
    v86 = *v85 + 376 * (v94[4] & 0xFLL);
  }

  v87 = v94[5] + v82;
  v88 = v87 >> 4;
  v89 = v87 & 0xF;
  while (1)
  {
    v90 = v84 == v83 ? 0 : *(v83 + 8 * v88) + 376 * v89;
    if (v86 == v90)
    {
      break;
    }

    for (i = 0; i != 336; i += 168)
    {
      v92 = v86 + i;
      if ((*(v86 + i + 204) & 1) == 0 && (*(v92 + 205) & 1) == 0)
      {
        *(v92 + 200) = 0;
      }
    }

    v86 += 376;
    if (v86 - *v85 == 6016)
    {
      v93 = v85[1];
      ++v85;
      v86 = v93;
    }
  }

LABEL_38:
  if (v44)
  {
    operator delete(v44);
  }
}

void sub_1016A547C(uint64_t *a1)
{
  v1 = *a1;
  v2 = a1[1];
  if ((v2 - *a1) >= 0x41)
  {
    do
    {
      if (sub_10169A37C((v2 - 32), v1, v1 + 2))
      {
        break;
      }

      v4 = *a1;
      v5 = a1[1];
      if (*a1 == v5)
      {
        __assert_rtn("erase", "range.hpp", 264, "!boost::empty(rng)");
      }

      if (v5 == v1)
      {
        __assert_rtn("erase", "range.hpp", 265, "it != boost::end(rng)");
      }

      if (v5 != v1 + 2)
      {
        memmove(v1, v1 + 2, v5 - (v1 + 2));
        v4 = *a1;
        v5 = a1[1];
      }

      sub_1016A6CB0(a1, ((v5 - v4) >> 4) - 1);
      sub_1016A6CB0(a1, ((a1[1] - *a1) >> 4) - 1);
      v7 = *a1;
      v6 = a1[1];
      if (*a1 == v6)
      {
        __assert_rtn("front", "range.hpp", 121, "!boost::empty(rng)");
      }

      v8 = a1[2];
      if (v6 >= v8)
      {
        v9 = v6 - v7;
        v10 = v9 + 1;
        if ((v9 + 1) >> 60)
        {
          sub_1000CE3D4();
        }

        v11 = v8 - v7;
        if (v11 >> 3 > v10)
        {
          v10 = v11 >> 3;
        }

        v12 = v11 >= 0x7FFFFFFFFFFFFFF0 ? 0xFFFFFFFFFFFFFFFLL : v10;
        if (v12)
        {
          sub_100F7E530(v12);
        }

        v13 = (16 * v9);
        *v13 = *v7;
        v2 = 16 * v9 + 16;
        v14 = a1[1] - *a1;
        v15 = v13 - v14;
        memcpy(v13 - v14, *a1, v14);
        v16 = *a1;
        *a1 = v15;
        a1[1] = v2;
        a1[2] = 0;
        if (v16)
        {
          operator delete(v16);
        }
      }

      else
      {
        *v6 = *v7;
        v2 = (v6 + 1);
      }

      a1[1] = v2;
      v1 = *a1;
    }

    while ((v2 - *a1) > 0x40);
  }
}

uint64_t sub_1016A5648(void *a1, uint64_t *a2)
{
  v4 = a1[1];
  v5 = a1[2];
  v6 = v5 - v4;
  if (v5 == v4)
  {
    v7 = 0;
  }

  else
  {
    v7 = 170 * ((v5 - v4) >> 3) - 1;
  }

  v8 = a1[4];
  v9 = a1[5] + v8;
  if (v7 == v9)
  {
    if (v8 < 0xAA)
    {
      v10 = a1[3];
      v11 = &v10[-*a1];
      if (v6 < v11)
      {
        if (v10 != v5)
        {
          operator new();
        }

        operator new();
      }

      if (v10 == *a1)
      {
        v12 = 1;
      }

      else
      {
        v12 = v11 >> 2;
      }

      v16 = a1;
      sub_100EF4E80(v12);
    }

    a1[4] = v8 - 170;
    *&v15 = *v4;
    a1[1] = v4 + 8;
    sub_1010F098C(a1, &v15);
    v4 = a1[1];
    v9 = a1[5] + a1[4];
  }

  v13 = (*&v4[8 * (v9 / 0xAA)] + 24 * (v9 % 0xAA));
  *v13 = 0;
  v13[1] = 0;
  v13[2] = 0;
  result = sub_1016A7594(v13, *a2, a2[1], (a2[1] - *a2) >> 4);
  ++a1[5];
  return result;
}

void sub_1016A5814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p)
{
  operator delete(v11);
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void *sub_1016A5840(void *result, uint64_t a2)
{
  v18 = result;
  v3 = result[2];
  v4 = v3[1];
  v5 = v3[2];
  v6 = (v4 + 8 * (v3[4] >> 4));
  if (v5 == v4)
  {
    v7 = 0;
  }

  else
  {
    v7 = *v6 + 376 * (v3[4] & 0xFLL);
  }

  while (1)
  {
    if (v5 == v4)
    {
      v9 = 0;
    }

    else
    {
      v8 = v3[5] + v3[4];
      v9 = *(v4 + ((v8 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * (v8 & 0xF);
    }

    if (v7 == v9)
    {
      break;
    }

    v19 = v6;
    v10 = 0;
    v11 = v7 + 40;
    v12 = 1;
    do
    {
      v13 = v12;
      v14 = v11 + 168 * v10;
      if ((*(v14 + 160) - 1) <= 2)
      {
        v23 = 0;
        v22 = 0uLL;
        v15 = *(v14 + 24);
        v22 = *(v14 + 8);
        v23 = v15;
        *&v20 = &v22;
        result = sub_1016A7650(a2, &v22);
        *(result + 56) = 1;
        if (*v14 == 4)
        {
          v21 = 0;
          v20 = 0uLL;
          v16 = v11 + 168 * (v10 ^ 1);
          v17 = *(v16 + 24);
          v20 = *(v16 + 8);
          v21 = v17;
          v24 = &v20;
          result = sub_1016A7650(a2, &v20);
          *(result + 56) = 1;
        }

        if ((*(v14 + 160) - 1) <= 2)
        {
          *(v14 + 165) = 1;
        }
      }

      v12 = 0;
      v10 = 1;
    }

    while ((v13 & 1) != 0);
    v7 += 376;
    v6 = v19;
    if (v7 - *v19 == 6016)
    {
      v6 = v19 + 1;
      v7 = v19[1];
    }

    v3 = v18[2];
    v4 = v3[1];
    v5 = v3[2];
  }

  return result;
}

void sub_1016A59F4(uint64_t a1, double *a2)
{
  v4 = *a1;
  if (*(a1 + 8) - *a1 != 16)
  {
    goto LABEL_22;
  }

  v5 = *v4;
  v6 = v4[1];
  v38 = v6;
  v39 = v5;
  sub_101690AC8(&v39, &v38, 1);
  v7 = v39;
  v8 = *a2;
  v9 = a2[1];
  v38 = v9;
  v39 = v8;
  sub_101690AC8(&v39, &v38, 1);
  if (v7 != v39)
  {
    if ((*&v7 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v39 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_22;
    }

    v14 = fabs(v7);
    v15 = fabs(v39);
    v16 = vabdd_f64(v7, v39);
    if (v14 < v15)
    {
      v14 = v15;
    }

    if (v14 < 1.0)
    {
      v14 = 1.0;
    }

    if (v16 > v14 * 2.22044605e-16)
    {
      goto LABEL_22;
    }
  }

  if (v6 != v9)
  {
    if ((*&v6 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_22;
    }

    v11 = fabs(v6);
    v12 = fabs(v9);
    v13 = vabdd_f64(v6, v9);
    if (v11 < v12)
    {
      v11 = v12;
    }

    if (v11 < 1.0)
    {
      v11 = 1.0;
    }

    if (v13 > v11 * 2.22044605e-16)
    {
LABEL_22:
      v18 = *(a1 + 8);
      v17 = *(a1 + 16);
      if (v18 >= v17)
      {
        v20 = (v18 - *a1) >> 4;
        v21 = v20 + 1;
        if ((v20 + 1) >> 60)
        {
LABEL_50:
          sub_1000CE3D4();
        }

        v22 = v17 - *a1;
        if (v22 >> 3 > v21)
        {
          v21 = v22 >> 3;
        }

        if (v22 >= 0x7FFFFFFFFFFFFFF0)
        {
          v23 = 0xFFFFFFFFFFFFFFFLL;
        }

        else
        {
          v23 = v21;
        }

        if (v23)
        {
          sub_100F7E530(v23);
        }

        v24 = (16 * v20);
        *v24 = *a2;
        v19 = 16 * v20 + 16;
        v25 = *(a1 + 8) - *a1;
        v26 = 16 * v20 - v25;
        memcpy(v24 - v25, *a1, v25);
        v27 = *a1;
        *a1 = v26;
        *(a1 + 8) = v19;
        *(a1 + 16) = 0;
        if (v27)
        {
          operator delete(v27);
        }
      }

      else
      {
        *v18 = *a2;
        v19 = (v18 + 1);
      }

      *(a1 + 8) = v19;
      if ((v19 - *a1) >= 0x21)
      {
        do
        {
          if (sub_10169A37C((v19 - 48), (v19 - 32), a2))
          {
            break;
          }

          sub_1016A6CB0(a1, ((*(a1 + 8) - *a1) >> 4) - 2);
          v29 = *(a1 + 8);
          v28 = *(a1 + 16);
          if (v29 >= v28)
          {
            v30 = (v29 - *a1) >> 4;
            v31 = v30 + 1;
            if ((v30 + 1) >> 60)
            {
              goto LABEL_50;
            }

            v32 = v28 - *a1;
            if (v32 >> 3 > v31)
            {
              v31 = v32 >> 3;
            }

            v33 = v32 >= 0x7FFFFFFFFFFFFFF0 ? 0xFFFFFFFFFFFFFFFLL : v31;
            if (v33)
            {
              sub_100F7E530(v33);
            }

            v34 = (16 * v30);
            *v34 = *a2;
            v19 = 16 * v30 + 16;
            v35 = *(a1 + 8) - *a1;
            v36 = 16 * v30 - v35;
            memcpy(v34 - v35, *a1, v35);
            v37 = *a1;
            *a1 = v36;
            *(a1 + 8) = v19;
            *(a1 + 16) = 0;
            if (v37)
            {
              operator delete(v37);
            }
          }

          else
          {
            *v29 = *a2;
            v19 = (v29 + 1);
          }

          *(a1 + 8) = v19;
        }

        while ((v19 - *a1) > 0x20);
      }
    }
  }
}

uint64_t sub_1016A5CE8(uint64_t a1, uint64_t a2, int a3, uint64_t *a4, int *a5, void *a6, int a7)
{
  v7 = *a5;
  if (*a5 >= 2)
  {
    __assert_rtn("operator[]", "array.hpp", 117, "(i < N)&&(out of range)");
  }

  v8 = a4;
  v10 = *a4;
  v11 = *(*(*(a1 + 72) + 8) + (((*(*(a1 + 72) + 32) + *a4) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(*(a1 + 72) + 32) + *a4) & 0xF) + 168 * v7;
  v12 = *(v11 + 136);
  if ((v12 & 0x8000000000000000) == 0)
  {
    v200 = a3;
    v13 = a2;
    v198 = *a5;
    v199 = *a4;
    v14 = a6;
    v15 = a7;
    v202 = a5;
    *a4 = v12;
    v16 = *(v11 + 64);
    v204 = *(v11 + 48);
    v205 = v16;
    v206 = *(v11 + 80);
    goto LABEL_4;
  }

  v30 = *(v11 + 120);
  if (v30 < 0 || (v31 = *(v11 + 128), v31 < 0))
  {
    v18 = a7 == 0;
    goto LABEL_291;
  }

  *a4 = v31;
  v32 = *(v11 + 64);
  v204 = *(v11 + 48);
  v205 = v32;
  v206 = *(v11 + 80);
  v33 = *(v11 + 64);
  v202 = a5;
  v198 = v7;
  v199 = v10;
  v200 = a3;
  if (*(v11 + 48))
  {
    v34 = *(a1 + 64);
    if ((v33 & 0x8000000000000000) != 0)
    {
      v13 = a2;
      v15 = a7;
LABEL_101:
      v94 = *v34;
      v95 = v34[1];
      v96 = *(v11 + 72);
      v97 = v96 + 1;
      v98 = (v95 - v94) >> 4;
      v99 = v98 <= v96 + 1;
      v100 = v98 - (v96 + 1);
      if (!v99)
      {
        if (v96 < v30)
        {
          v101 = ~v96;
        }

        else
        {
          v101 = v100;
        }

        v14 = a6;
        if (v101 + v30 >= 0)
        {
          v102 = &v94[2 * v97];
          v103 = v101 + v30 + 1;
          do
          {
            sub_1016A6DB0(v14, v102);
            if (v102 + 2 == v95)
            {
              v102 = v94;
            }

            else
            {
              v102 += 2;
            }

            --v103;
          }

          while (v103);
        }

        goto LABEL_4;
      }

LABEL_298:
      __assert_rtn("apply", "copy_segments.hpp", 95, "from_index < static_cast<signed_size_type>(boost::size(view))");
    }

    v36 = v34 + 3;
    v35 = v34[3];
    if (0xAAAAAAAAAAAAAAABLL * ((v36[1] - v35) >> 3) >= v33)
    {
      v13 = a2;
      v15 = a7;
      v34 = &v35[3 * v33];
      goto LABEL_101;
    }

LABEL_299:
    __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
  }

  v91 = *(a1 + 56);
  if ((v33 & 0x8000000000000000) != 0)
  {
    v15 = a7;
  }

  else
  {
    v93 = v91 + 3;
    v92 = v91[3];
    if (0xAAAAAAAAAAAAAAABLL * ((v93[1] - v92) >> 3) < v33)
    {
      goto LABEL_299;
    }

    v15 = a7;
    v91 = &v92[3 * v33];
  }

  v104 = *v91;
  v105 = v91[1];
  v106 = *(v11 + 72);
  v107 = v106 + 1;
  v108 = (v105 - v104) >> 4;
  v99 = v108 <= v106 + 1;
  v109 = v108 - (v106 + 1);
  if (v99)
  {
    goto LABEL_298;
  }

  v13 = a2;
  if (v106 < v30)
  {
    v110 = ~v106;
  }

  else
  {
    v110 = v109;
  }

  v14 = a6;
  if (v110 + v30 >= 0)
  {
    v111 = &v104[2 * v107];
    v112 = v110 + v30 + 1;
    do
    {
      sub_1016A6DB0(v14, v111);
      if (v111 + 2 == v105)
      {
        v111 = v104;
      }

      else
      {
        v111 += 2;
      }

      --v112;
    }

    while (v112);
  }

LABEL_4:
  v203 = v14;
  v17 = *v8;
  if (*(*(*(*(a1 + 72) + 8) + (((*(*(a1 + 72) + 32) + *v8) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(*(a1 + 72) + 32) + *v8) & 0xF) + 32) == 1)
  {
    v18 = v15 == 0;
    v19 = 3;
    goto LABEL_292;
  }

  v20 = v15;
  if (v15)
  {
    *(v11 + 200) = 1;
  }

  v21 = v14;
  v22 = *(a1 + 16);
  v23 = *(v22 + 32);
  v24 = *(v22 + 8);
  v25 = *(v24 + (((v23 + v17) >> 1) & 0x7FFFFFFFFFFFFFF8));
  v26 = (v23 + v17) & 0xF;
  v27 = v25 + 376 * v26;
  v28 = *(v27 + 24);
  if (v14[1] - *v14 >= 0x11uLL)
  {
    v29 = v28 >= 1 && *(*(v24 + (((v23 + v13) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((v23 + v13) & 0xF) + 24) == v28;
    if (v17 == v13 || v29)
    {
      *v8 = v13;
      v44 = v202;
      v49 = v200;
      goto LABEL_38;
    }
  }

  if (v28 > 0)
  {
    goto LABEL_22;
  }

  v43 = v27 + 40;
  v44 = v202;
  if (*(v27 + 40) != 2 || *(v27 + 208) != 2)
  {
    goto LABEL_134;
  }

  v45 = 0;
  v218 = 0u;
  v219 = 0u;
  v216 = 0u;
  v217 = 0u;
  v46 = 1;
  do
  {
    v47 = v46;
    sub_1016A70E0(&v216, v27, v43 + 168 * v45, *v8, v45, &v204, *a1, *(a1 + 8), 1);
    v46 = 0;
    v45 = 1;
  }

  while ((v47 & 1) != 0);
  if (*(&v218 + 1))
  {
    sub_1016A0DD4(&v216, v27);
    v48 = sub_1016A71B0(a1, v8, v202, v216, *(&v216 + 1));
  }

  else
  {
    v48 = 0;
  }

  if (v216)
  {
    *(&v216 + 1) = v216;
    operator delete(v216);
  }

  v21 = v203;
  if (v48)
  {
    goto LABEL_141;
  }

  v20 = v15;
  if (*(v27 + 24) < 1)
  {
LABEL_134:
    if (*(v27 + 368) == 1)
    {
      v116 = 1;
    }

    else
    {
      v116 = -1;
    }

    if (*(v27 + 200) == 1)
    {
      v117 = 0;
    }

    else
    {
      v117 = v116;
    }

    *v202 = v117;
    if (v117 != -1)
    {
      goto LABEL_141;
    }

    if (*(v27 + 200) == 3 && *(v27 + 368) == 3)
    {
      goto LABEL_290;
    }

    *v202 = -1;
    if (*(v27 + 40) == 4 && *(v27 + 208) == 4)
    {
      v127 = 0;
      LOBYTE(v216) = 0;
      LOBYTE(v208) = 0;
      v128 = &v216;
      v129 = &v213;
      LOBYTE(v213) = 0;
      v130 = 1;
      v207 = 0;
      v21 = v203;
      while (1)
      {
        v131 = v130;
        v132 = v43 + 168 * v127;
        v133 = *(v132 + 96);
        if (v133 == -1)
        {
          v133 = *(v132 + 88);
          if (v133 == -1)
          {
            v136 = 0;
            *v128 = 0;
            goto LABEL_162;
          }
        }

        v134 = *(*(*(a1 + 16) + 8) + (((*(*(a1 + 16) + 32) + v133) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(*(a1 + 16) + 32) + v133) & 0xF);
        if (*(v134 + 24) > 0 || (v135 = *(v134 + 40), v135 == 2))
        {
          *v128 = 1;
        }

        else
        {
          v137 = *(v134 + 208);
          v138 = v135 == 4;
          if (v137 == 2 || v137 == 4)
          {
            v138 = 1;
          }

          *v128 = v138;
          if (v135 != 4 && v137 != 4 && v137 != 2)
          {
            v136 = 0;
            goto LABEL_162;
          }
        }

        v136 = v133 == v13;
LABEL_162:
        v130 = 0;
        *v129 = v136;
        v128 = &v208;
        v129 = &v207;
        v127 = 1;
        if ((v131 & 1) == 0)
        {
          if (v213 == v207)
          {
            v175 = 0;
            v176 = 0;
            v177 = 0.0;
            v178 = &v216;
            v179 = 1;
            v168 = -1;
            do
            {
              v180 = v179;
              if (*v178 == 1)
              {
                v181 = *(v43 + 168 * v175 + 72);
                if ((v176 & (v181 >= v177)) != 0)
                {
                  v176 = 1;
                }

                else
                {
                  *v202 = v175;
                  v176 = 1;
                  v168 = v175;
                  v177 = v181;
                }
              }

              v179 = 0;
              v178 = &v208;
              v175 = 1;
            }

            while ((v180 & 1) != 0);
            if ((v176 & 1) == 0)
            {
              goto LABEL_290;
            }

LABEL_237:
            v21 = v203;
            if (v168 >= 2)
            {
              __assert_rtn("operator[]", "array.hpp", 122, "(i < N)&&(out of range)");
            }

LABEL_141:
            if (*v44 >= 2)
            {
              __assert_rtn("operator[]", "array.hpp", 122, "(i < N)&&(out of range)");
            }

            v118 = *(*(*(a1 + 72) + 8) + (((*(*(a1 + 72) + 32) + *v8) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(*(a1 + 72) + 32) + *v8) & 0xF);
            v119 = v118 + 40 + 168 * *v44;
            if ((*(v119 + 165) & 1) != 0 || *(v119 + 160) == 2)
            {
              return 5;
            }

            sub_1016A59F4(v21, (*(*(*(a1 + 72) + 8) + (((*(*(a1 + 72) + 32) + *v8) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(*(a1 + 72) + 32) + *v8) & 0xF)));
            if (*v119 == 4)
            {
              v121 = 0;
              v122 = 1;
              do
              {
                v123 = v122;
                v124 = v118 + 40 + 168 * v121;
                v126 = *(v124 + 160);
                v125 = (v124 + 160);
                if (!v126)
                {
                  *v125 = 2;
                }

                v122 = 0;
                v121 = 1;
              }

              while ((v123 & 1) != 0);
            }

            else
            {
              *(v119 + 160) = 2;
            }

            v142 = *(v118 + 24);
            if (v142 < 1)
            {
              return 0;
            }

            v143 = *(a1 + 24);
            v146 = *(v143 + 8);
            v144 = (v143 + 8);
            v145 = v146;
            if (!v146)
            {
              goto LABEL_188;
            }

            v147 = *(v119 + 128);
            v148 = v144;
            do
            {
              if (v145[4] >= v142)
              {
                v148 = v145;
              }

              v145 = v145[v145[4] < v142];
            }

            while (v145);
            if (v148 == v144 || v148[4] > v142)
            {
LABEL_188:
              __assert_rtn("set_visited_in_cluster", "traversal.hpp", 162, "mit != m_clusters.end()");
            }

            v149 = v148[5];
            v150 = v148 + 6;
            if (v149 == v148 + 6)
            {
              return 0;
            }

            v151 = *(a1 + 16);
            v152 = *(v151 + 32);
            v153 = *(v151 + 8);
            do
            {
              v154 = 0;
              v155 = *(v153 + (((v149[4] + v152) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v149 + 8) + v152) & 0xF) + 40;
              v156 = 1;
              do
              {
                v157 = v156;
                v158 = v155 + 168 * v154;
                if (*(v158 + 160))
                {
                  v159 = 0;
                }

                else
                {
                  v159 = *(v158 + 128) == v147;
                }

                if (v159)
                {
                  *(v158 + 160) = 2;
                }

                v156 = 0;
                v154 = 1;
              }

              while ((v157 & 1) != 0);
              v160 = v149[1];
              if (v160)
              {
                do
                {
                  v161 = v160;
                  v160 = *v160;
                }

                while (v160);
              }

              else
              {
                do
                {
                  v161 = v149[2];
                  v18 = *v161 == v149;
                  v149 = v161;
                }

                while (!v18);
              }

              result = 0;
              v149 = v161;
            }

            while (v161 != v150);
            return result;
          }

          v49 = v213 ^ 1;
LABEL_38:
          *v44 = v49;
          goto LABEL_141;
        }
      }
    }

    v162 = 0;
    v163 = 0;
    v164 = *(v27 + 48);
    v165 = *(v27 + 216);
    v166 = *(v27 + 184);
    v167 = 1;
    v168 = -1;
    v169 = v204;
    while (1)
    {
      v170 = v167;
      v171 = v43 + 168 * v162;
      if (*v171 != 2 || (*(v171 + 160) & 0xFFFFFFFE) == 2)
      {
        goto LABEL_226;
      }

      if ((v163 & 1) == 0)
      {
LABEL_225:
        *v202 = v162;
        v163 = 1;
        v168 = v162;
        goto LABEL_226;
      }

      v173 = v166 != -1 && v166 == *(v27 + 352);
      if (v164 == v165)
      {
        v174 = *(v171 + 16) == *(&v169 + 1);
        if (v173)
        {
          goto LABEL_219;
        }
      }

      else
      {
        v174 = *(v171 + 8) == v169;
        if (v173)
        {
LABEL_219:
          if (!v174)
          {
            goto LABEL_225;
          }

          goto LABEL_221;
        }
      }

      if (v174)
      {
        goto LABEL_225;
      }

LABEL_221:
      v163 = 1;
LABEL_226:
      v167 = 0;
      v162 = 1;
      if ((v170 & 1) == 0)
      {
        if ((v163 & 1) == 0)
        {
          goto LABEL_290;
        }

        goto LABEL_237;
      }
    }
  }

  v113 = *(a1 + 16);
  v17 = *v8;
  v114 = *(v113 + 8);
  v115 = *(v113 + 32) + *v8;
  v26 = v115 & 0xF;
  v25 = *(v114 + ((v115 >> 1) & 0x7FFFFFFFFFFFFFF8));
LABEL_22:
  v37 = *(v25 + 376 * v26 + 24);
  if (v37 <= 0)
  {
    __assert_rtn("select_turn_from_cluster", "traversal.hpp", 790, "turn.is_clustered()");
  }

  v38 = *(a1 + 24);
  v41 = *(v38 + 8);
  v39 = v38 + 8;
  v40 = v41;
  if (!v41)
  {
    goto LABEL_30;
  }

  v42 = v39;
  do
  {
    if (*(v40 + 32) >= v37)
    {
      v42 = v40;
    }

    v40 = *(v40 + 8 * (*(v40 + 32) < v37));
  }

  while (v40);
  if (v42 == v39 || v37 < *(v42 + 32))
  {
LABEL_30:
    __assert_rtn("select_turn_from_cluster", "traversal.hpp", 793, "mit != m_clusters.end()");
  }

  v218 = 0u;
  v219 = 0u;
  v52 = *(v42 + 40);
  v51 = (v42 + 40);
  v50 = v52;
  v216 = 0u;
  v217 = 0u;
  v53 = v51 + 1;
  if (v52 == v51 + 1)
  {
    goto LABEL_290;
  }

  v201 = v20;
  v197 = v8;
  do
  {
    v54 = v50[4];
    v55 = *(*(*(a1 + 16) + 8) + (((*(*(a1 + 16) + 32) + v54) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(*(a1 + 16) + 32) + v54) & 0xF);
    if ((*(v55 + 32) & 1) == 0)
    {
      v56 = 0;
      v57 = 1;
      do
      {
        v58 = v57;
        sub_1016A70E0(&v216, v55, v55 + 40 + 168 * v56, v54, v56, &v204, *a1, *(a1 + 8), v54 == v17);
        v57 = 0;
        v56 = 1;
      }

      while ((v58 & 1) != 0);
    }

    v59 = v50[1];
    if (v59)
    {
      do
      {
        v60 = v59;
        v59 = *v59;
      }

      while (v59);
    }

    else
    {
      do
      {
        v60 = v50[2];
        v18 = *v60 == v50;
        v50 = v60;
      }

      while (!v18);
    }

    v50 = v60;
  }

  while (v60 != v53);
  if (!*(&v218 + 1))
  {
    if (v216)
    {
      *(&v216 + 1) = v216;
      operator delete(v216);
    }

    v20 = v201;
    goto LABEL_290;
  }

  sub_1016A0DD4(&v216, (*(*(*(a1 + 16) + 8) + (((*(*(a1 + 16) + 32) + v17) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(*(a1 + 16) + 32) + v17) & 0xF)));
  v212 = 0;
  v61 = *(a1 + 16);
  v208 = v51;
  v211 = 0u;
  *v209 = 0u;
  *__p = 0u;
  v62 = *v51;
  if (v62 == v53)
  {
    LOBYTE(v212) = 1;
    v63 = v203;
    goto LABEL_278;
  }

  v63 = v203;
  do
  {
    v64 = v62[4];
    v65 = *(*(v61 + 8) + (((*(v61 + 32) + v64) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v61 + 32) + v64) & 0xF);
    if ((*(v65 + 32) & 1) == 0)
    {
      v66 = v65 + 40;
      if (*(v65 + 40) == 2 && *(v65 + 208) == 2)
      {
        goto LABEL_277;
      }

      v67 = 0;
      v68 = 1;
      while (1)
      {
        v69 = v68;
        v70 = v66 + 168 * v67;
        v71 = *(v70 + 96);
        if (v71 == -1)
        {
          v71 = *(v70 + 88);
        }

        v72 = *v70;
        if (v72 == 4)
        {
          break;
        }

        if (v72 == 3)
        {
          v73 = v66 + 168 * (v67 ^ 1);
          v74 = *(v73 + 96);
          if (v74 == -1)
          {
            v74 = *(v73 + 88);
          }

          if (v71 != v74)
          {
            for (i = v208[1]; i; i = *i)
            {
              v76 = i[4];
              if (v71 >= v76)
              {
                if (v76 >= v71)
                {
                  goto LABEL_73;
                }

                ++i;
              }
            }

            *&v213 = v64;
            DWORD2(v213) = v67;
            v214 = v71;
            v215 = -1;
            sub_1016A7384(&__p[1], &v213);
          }
        }

        else if (v72 == 2)
        {
          break;
        }

LABEL_73:
        v68 = 0;
        v67 = 1;
        if ((v69 & 1) == 0)
        {
          goto LABEL_74;
        }
      }

      if (v71 == v64)
      {
        goto LABEL_277;
      }

      *&v213 = v64;
      DWORD2(v213) = v67;
      v214 = v71;
      v215 = -1;
      sub_1016A7384(v209, &v213);
      goto LABEL_73;
    }

LABEL_74:
    v77 = v62[1];
    if (v77)
    {
      do
      {
        v78 = v77;
        v77 = *v77;
      }

      while (v77);
    }

    else
    {
      do
      {
        v78 = v62[2];
        v18 = *v78 == v62;
        v62 = v78;
      }

      while (!v18);
    }

    v79 = v208 + 1;
    v62 = v78;
  }

  while (v78 != v208 + 1);
  v80 = __p[1];
  v81 = v211;
  v82 = v209[0];
  v44 = v202;
  if (__p[1] == v211)
  {
    v84 = v209[1];
    v8 = v197;
LABEL_263:
    LOBYTE(v212) = 1;
    if (v82 != v84)
    {
      v189 = *v79;
      v190 = -1;
      v191 = -1;
      v192 = -1;
      while (1)
      {
        v193 = *(v82 + 2);
        if (v189)
        {
          v194 = v189;
          do
          {
            v195 = v194[4];
            if (v193 >= v195)
            {
              if (v195 >= v193)
              {
                goto LABEL_274;
              }

              ++v194;
            }

            v194 = *v194;
          }

          while (v194);
        }

        if ((v191 & 0x8000000000000000) == 0 && v192 != v193)
        {
          break;
        }

        v191 = *v82;
        v190 = *(v82 + 2);
        v192 = *(v82 + 2);
LABEL_274:
        v82 += 32;
        if (v82 == v84)
        {
          if (v191 < 0)
          {
            goto LABEL_279;
          }

          *v8 = v191;
          *v44 = v190;
          v196 = 1;
          goto LABEL_280;
        }
      }
    }

    goto LABEL_279;
  }

  v83 = v216;
  v84 = v209[1];
  v8 = v197;
  v85 = 0x6DB6DB6DB6DB6DB7 * ((*(&v216 + 1) - v216) >> 4);
  if (v209[0] == v209[1])
  {
    if (v85 <= 1)
    {
      v85 = 1;
    }
  }

  else
  {
    if (v85 <= 1)
    {
      v85 = 1;
    }

    v86 = v209[0];
    do
    {
      if (*(&v83 + 1) == v83)
      {
LABEL_93:
        v90 = -1;
      }

      else
      {
        v87 = (v83 + 44);
        v88 = v85;
        while (*(v87 - 3) != *v86 || *(v87 - 1) != *(v86 + 2) || *v87 != 1)
        {
          v87 += 28;
          if (!--v88)
          {
            goto LABEL_93;
          }
        }

        v90 = *(v87 - 7);
      }

      *(v86 + 3) = v90;
      v86 += 32;
    }

    while (v86 != v84);
  }

  v182 = v80;
  do
  {
    if (*(&v83 + 1) == v83)
    {
LABEL_252:
      v186 = -1;
    }

    else
    {
      v183 = (v83 + 44);
      v184 = v85;
      while (*(v183 - 3) != *v182 || *(v183 - 1) != v182[2] || *v183 != 1)
      {
        v183 += 28;
        if (!--v184)
        {
          goto LABEL_252;
        }
      }

      v186 = *(v183 - 7);
    }

    *(v182 + 3) = v186;
    v182 += 8;
  }

  while (v182 != v81);
  if (v82 == v84)
  {
    goto LABEL_263;
  }

  v187 = v82;
LABEL_257:
  v188 = v80;
  while (v188[2] != *(v187 + 2) || v188[3] != *(v187 + 3))
  {
    v188 += 4;
    if (v188 == v81)
    {
      v187 += 32;
      if (v187 != v84)
      {
        goto LABEL_257;
      }

      v8 = v197;
      v44 = v202;
      goto LABEL_263;
    }
  }

LABEL_277:
  LOBYTE(v212) = 0;
LABEL_278:
  v8 = v197;
  v44 = v202;
LABEL_279:
  v196 = sub_1016A71B0(a1, v8, v44, v216, *(&v216 + 1));
  v80 = __p[1];
LABEL_280:
  if (v80)
  {
    operator delete(v80);
  }

  if (v209[0])
  {
    operator delete(v209[0]);
  }

  if (!v216)
  {
    v20 = v201;
    if (!v196)
    {
      goto LABEL_290;
    }

LABEL_286:
    v21 = v63;
    if (v20 && *v8 == v199)
    {
      *v44 = v198;
    }

    goto LABEL_141;
  }

  *(&v216 + 1) = v216;
  operator delete(v216);
  v20 = v201;
  if (v196)
  {
    goto LABEL_286;
  }

LABEL_290:
  v18 = v20 == 0;
LABEL_291:
  v19 = 1;
LABEL_292:
  if (v18)
  {
    return v19 + 1;
  }

  else
  {
    return v19;
  }
}

void sub_1016A6C54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, void *a24, uint64_t a25, uint64_t a26, void *__p)
{
  v29 = *(v27 - 160);
  if (v29)
  {
    *(v27 - 152) = v29;
    operator delete(v29);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016A6CB0(uint64_t *a1, unint64_t a2)
{
  v3 = *a1;
  v4 = a1[1];
  v5 = (v4 - *a1) >> 4;
  if (a2 <= v5)
  {
    if (a2 >= v5)
    {
      return;
    }

    v11 = v3 + 16 * a2;
  }

  else
  {
    v6 = a2 - v5;
    v7 = a1[2];
    if (v6 > (v7 - v4) >> 4)
    {
      if (!(a2 >> 60))
      {
        v8 = v7 - v3;
        v9 = v8 >> 3;
        if (v8 >> 3 <= a2)
        {
          v9 = a2;
        }

        if (v8 >= 0x7FFFFFFFFFFFFFF0)
        {
          v10 = 0xFFFFFFFFFFFFFFFLL;
        }

        else
        {
          v10 = v9;
        }

        sub_100F7E530(v10);
      }

      sub_1000CE3D4();
    }

    bzero(a1[1], 16 * v6);
    v11 = v4 + 16 * v6;
  }

  a1[1] = v11;
}

void sub_1016A6DB0(uint64_t a1, double *a2)
{
  v4 = *a1;
  if (*(a1 + 8) - *a1 != 16)
  {
    goto LABEL_22;
  }

  v5 = v4[1];
  *&v39 = *v4;
  *&v38 = v5;
  sub_101690AC8(&v39, &v38, 1);
  v6 = *&v39;
  v7 = a2[1];
  *&v39 = *a2;
  *&v38 = v7;
  sub_101690AC8(&v39, &v38, 1);
  if (v6 != *&v39)
  {
    if ((*&v6 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (v39 & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_22;
    }

    v12 = fabs(v6);
    v13 = fabs(*&v39);
    v14 = vabdd_f64(v6, *&v39);
    if (v12 < v13)
    {
      v12 = v13;
    }

    if (v12 < 1.0)
    {
      v12 = 1.0;
    }

    if (v14 > v12 * 2.22044605e-16)
    {
      goto LABEL_22;
    }
  }

  if (v5 != v7)
  {
    if ((*&v5 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v7 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_22;
    }

    v9 = fabs(v5);
    v10 = fabs(v7);
    v11 = vabdd_f64(v5, v7);
    if (v9 < v10)
    {
      v9 = v10;
    }

    if (v9 < 1.0)
    {
      v9 = 1.0;
    }

    if (v11 > v9 * 2.22044605e-16)
    {
LABEL_22:
      v16 = *(a1 + 8);
      v15 = *(a1 + 16);
      if (v16 >= v15)
      {
        v18 = (v16 - *a1) >> 4;
        v19 = v18 + 1;
        if ((v18 + 1) >> 60)
        {
LABEL_51:
          sub_1000CE3D4();
        }

        v20 = v15 - *a1;
        if (v20 >> 3 > v19)
        {
          v19 = v20 >> 3;
        }

        if (v20 >= 0x7FFFFFFFFFFFFFF0)
        {
          v21 = 0xFFFFFFFFFFFFFFFLL;
        }

        else
        {
          v21 = v19;
        }

        if (v21)
        {
          sub_100F7E530(v21);
        }

        v22 = (16 * v18);
        *v22 = *a2;
        v17 = 16 * v18 + 16;
        v23 = *(a1 + 8) - *a1;
        v24 = 16 * v18 - v23;
        memcpy(v22 - v23, *a1, v23);
        v25 = *a1;
        *a1 = v24;
        *(a1 + 8) = v17;
        *(a1 + 16) = 0;
        if (v25)
        {
          operator delete(v25);
        }
      }

      else
      {
        *v16 = *a2;
        v17 = (v16 + 1);
      }

      *(a1 + 8) = v17;
      if ((v17 - *a1) >= 0x21)
      {
        do
        {
          if (sub_10169A37C((v17 - 48), (v17 - 32), a2))
          {
            break;
          }

          v26 = *(v17 - 48);
          v38 = *(v17 - 32);
          v39 = v26;
          v37 = *a2;
          if (sub_1016A3B70(&v39, &v38, &v37) > 0)
          {
            break;
          }

          sub_1016A6CB0(a1, ((*(a1 + 8) - *a1) >> 4) - 2);
          v28 = *(a1 + 8);
          v27 = *(a1 + 16);
          if (v28 >= v27)
          {
            v29 = (v28 - *a1) >> 4;
            v30 = v29 + 1;
            if ((v29 + 1) >> 60)
            {
              goto LABEL_51;
            }

            v31 = v27 - *a1;
            if (v31 >> 3 > v30)
            {
              v30 = v31 >> 3;
            }

            v32 = v31 >= 0x7FFFFFFFFFFFFFF0 ? 0xFFFFFFFFFFFFFFFLL : v30;
            if (v32)
            {
              sub_100F7E530(v32);
            }

            v33 = (16 * v29);
            *v33 = *a2;
            v17 = 16 * v29 + 16;
            v34 = *(a1 + 8) - *a1;
            v35 = 16 * v29 - v34;
            memcpy(v33 - v34, *a1, v34);
            v36 = *a1;
            *a1 = v35;
            *(a1 + 8) = v17;
            *(a1 + 16) = 0;
            if (v36)
            {
              operator delete(v36);
            }
          }

          else
          {
            *v28 = *a2;
            v17 = (v28 + 1);
          }

          *(a1 + 8) = v17;
        }

        while ((v17 - *a1) > 0x20);
      }
    }
  }
}

void sub_1016A70E0(double *a1, double *a2, uint64_t a3, uint64_t a4, int a5, void *a6, uint64_t *a7, uint64_t *a8, char a9)
{
  v14 = sub_1016A1008(a1, a2, a3, a4, a5, a7, a8, 0);
  if (a9)
  {
    v16 = *(a3 + 8);
    if (v16 == *a6 && *(a3 + 24) == a6[2] && *(a3 + 16) == a6[1])
    {
      v17 = v14;
      v18 = v15;
      if (v16)
      {
        v19 = a8;
      }

      else
      {
        v19 = a7;
      }

      v20 = sub_10169BE80(v19, a6, (a3 + 8));
      v21 = *(a1 + 5);
      if (!v21 || v20 < *(a1 + 6))
      {
        a1[3] = v17;
        *(a1 + 4) = v18;
        *(a1 + 6) = v20;
      }

      *(a1 + 5) = v21 + 1;
    }
  }
}

uint64_t sub_1016A71B0(uint64_t a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  v5 = *(a4 + 40);
  if (v5 >= 2)
  {
LABEL_36:
    __assert_rtn("operator[]", "array.hpp", 117, "(i < N)&&(out of range)");
  }

  if (a5 == a4)
  {
    return 0;
  }

  v6 = *(a1 + 16);
  v7 = *(v6 + 32);
  v8 = *(v6 + 8);
  v9 = 0x6DB6DB6DB6DB6DB7 * ((a5 - a4) >> 4);
  v10 = *(v8 + (((*(a4 + 32) + v7) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(a4 + 32) + v7) & 0xF) + 168 * v5;
  v11 = v9 <= 1 ? 1 : 0x6DB6DB6DB6DB6DB7 * ((a5 - a4) >> 4);
  v12 = (a4 + 44);
  v13 = v11;
  while (1)
  {
    v14 = *(v12 - 7);
    if (v14 && *v12 != 0)
    {
      v16 = *(v12 - 1);
      if (v16 >= 2)
      {
        goto LABEL_36;
      }

      v17 = *(v8 + (((*(v12 - 3) + v7) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*(v12 - 3) + v7) & 0xF) + 168 * v16;
      v20 = *(v17 + 40);
      v18 = v17 + 40;
      v19 = v20;
      v21 = v20 == 4 || v19 == 2;
      if (v21 && (*(v10 + 184) == *(v18 + 144) || *(v18 + 152) != 1))
      {
        break;
      }
    }

    v12 += 28;
    if (!--v13)
    {
      return 0;
    }
  }

  if (v14 < 1)
  {
    return 0;
  }

  v22 = 0;
  v23 = a4 + 32;
  v24 = 0.0;
  v25 = v9;
  do
  {
    v26 = *(v23 - 16);
    if (v26 > v14)
    {
      break;
    }

    if (v26 == v14)
    {
      v27 = *(v23 + 8);
      if (v27 >= 2)
      {
        goto LABEL_36;
      }

      v28 = *(v8 + (((*v23 + v7) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * ((*v23 + v7) & 0xF) + 168 * v27;
      if ((*(v28 + 205) & 1) == 0 && (*(v28 + 112) < v24 || v25 == v9))
      {
        v24 = *(v28 + 112);
        v25 = v22;
      }
    }

    ++v22;
    v23 += 112;
  }

  while (v11 != v22);
  if (v25 == v9)
  {
    return 0;
  }

  v31 = a4 + 112 * v25;
  *a2 = *(v31 + 32);
  *a3 = *(v31 + 40);
  return 1;
}

void sub_1016A7384(uint64_t a1, _OWORD *a2)
{
  v3 = *(a1 + 8);
  v4 = *(a1 + 16);
  if (v3 >= v4)
  {
    v7 = *a1;
    v8 = v3 - *a1;
    v9 = v8 >> 5;
    v10 = (v8 >> 5) + 1;
    if (v10 >> 59)
    {
      sub_1000CE3D4();
    }

    v11 = v4 - v7;
    if (v11 >> 4 > v10)
    {
      v10 = v11 >> 4;
    }

    if (v11 >= 0x7FFFFFFFFFFFFFE0)
    {
      v12 = 0x7FFFFFFFFFFFFFFLL;
    }

    else
    {
      v12 = v10;
    }

    if (v12)
    {
      if (!(v12 >> 59))
      {
        operator new();
      }

      sub_100013D10();
    }

    v13 = (32 * v9);
    v14 = a2[1];
    *v13 = *a2;
    v13[1] = v14;
    v6 = 32 * v9 + 32;
    v15 = &v13[-2 * (v8 >> 5)];
    memcpy(v15, v7, v8);
    *a1 = v15;
    *(a1 + 8) = v6;
    *(a1 + 16) = 0;
    if (v7)
    {
      operator delete(v7);
    }
  }

  else
  {
    v5 = a2[1];
    *v3 = *a2;
    v3[1] = v5;
    v6 = (v3 + 2);
  }

  *(a1 + 8) = v6;
}

const void **sub_1016A748C(const void **result, void *a2)
{
  v3 = result;
  v4 = result[1];
  if (v4 == *result)
  {
    v6 = result[2];
    v7 = result[3];
    if (v6 >= v7)
    {
      if (v7 == v4)
      {
        v9 = 1;
      }

      else
      {
        v9 = (v7 - v4) >> 2;
      }

      sub_100EF4E80(v9);
    }

    v8 = (((v7 - v6) >> 3) + 1) / 2;
    v5 = &v4[8 * v8];
    if (v6 != v4)
    {
      result = memmove(&v4[8 * v8], v4, v6 - v4);
      v6 = v3[2];
    }

    v3[1] = v5;
    v3[2] = &v6[8 * v8];
  }

  else
  {
    v5 = result[1];
  }

  *(v5 - 1) = *a2;
  v3[1] = v3[1] - 8;
  return result;
}

uint64_t sub_1016A7594(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    sub_1016A7610(result, a4);
  }

  return result;
}

void sub_1016A75F4(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016A7610(uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 60))
  {
    sub_100F7E530(a2);
  }

  sub_1000CE3D4();
}

void *sub_1016A7650(uint64_t a1, uint64_t *a2)
{
  v2 = *(a1 + 8);
  if (!v2)
  {
LABEL_16:
    operator new();
  }

  v3 = *a2;
  v4 = a2[1];
  v5 = a2[2];
  while (1)
  {
    while (1)
    {
      v6 = v2;
      v7 = v2[4];
      if (v3 != v7)
      {
        if (v3 >= v7)
        {
          if (v7 >= v3)
          {
            return v6;
          }

          goto LABEL_15;
        }

        goto LABEL_12;
      }

      v8 = v6[5];
      if (v4 != v8)
      {
        break;
      }

      v9 = v6[6];
      if (v5 >= v9)
      {
        if (v9 >= v5)
        {
          return v6;
        }

        goto LABEL_15;
      }

LABEL_12:
      v2 = *v6;
      if (!*v6)
      {
        goto LABEL_16;
      }
    }

    if (v4 < v8)
    {
      goto LABEL_12;
    }

    if (v8 >= v4)
    {
      return v6;
    }

LABEL_15:
    v2 = v6[1];
    if (!v2)
    {
      goto LABEL_16;
    }
  }
}

uint64_t sub_1016A7790(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  v17 = 0;
  __p = 0;
  v27 = 0;
  v28 = 0;
  sub_101690224(a1, &__p, 0);
  v21.i64[0] = a1;
  v21.i64[1] = a2;
  v22 = a3;
  v23 = &v18;
  v24 = &v17;
  v25 = 0;
  v6 = __p;
  v7 = v27;
  if (0xEEEEEEEEEEEEEEEFLL * ((v27 - __p) >> 3) < 0x11)
  {
LABEL_5:
    while (v6 != v7)
    {
      v8 = v6;
      v6 = (v6 + 120);
      v9 = v6;
      if (v6 != v7)
      {
        while ((sub_1016A7E84(&v21, v8, v9) & 1) != 0)
        {
          v9 += 120;
          v7 = v27;
          if (v9 == v27)
          {
            goto LABEL_5;
          }
        }

        break;
      }
    }
  }

  else
  {
    memset(v30, 0, sizeof(v30));
    v29[0] = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    v29[1] = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    while (1)
    {
      v31 = v6;
      if (v6 == v7)
      {
        break;
      }

      sub_1016932F4(v29, v6 + 2);
      sub_1016931F4(v30, &v31);
      v6 = (v6 + 120);
    }

    sub_1016A7AA4(v29[0].i64, v30, 0, &v21);
    if (v30[0])
    {
      operator delete(v30[0]);
    }
  }

  if (__p)
  {
    operator delete(__p);
  }

  v10 = (*(&v18 + 1) + 8 * (v20 / 0x14));
  if (v19 == *(&v18 + 1))
  {
    v11 = 0;
  }

  else
  {
    v11 = (*v10 + 200 * (v20 % 0x14));
  }

LABEL_17:
  v12 = v11 - 1000;
  while (1)
  {
    v13 = v19 == *(&v18 + 1) ? 0 : *(*(&v18 + 1) + 8 * ((*(&v20 + 1) + v20) / 0x14uLL)) + 200 * ((*(&v20 + 1) + v20) % 0x14uLL);
    if (v11 == v13)
    {
      return sub_1016AB5C0(&v18);
    }

    v14 = v11[10];
    if (v14 == 1)
    {
      if (v11[30] != 1)
      {
        goto LABEL_31;
      }
    }

    else if (v14 != 2 || v11[30] != 2)
    {
LABEL_31:
      v29[0].i64[0] = &off_101F604C8;
      v21.i64[0] = "/AppleInternal/Library/BuildRoots/4~CAqBugAHn1rV1l8PF4OmQNFaHaYcMVvKXNqVEms/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/has_self_intersections.hpp";
      v21.i64[1] = "BOOL boost::geometry::detail::overlay::has_self_intersections(const Geometry &, const Strategy &, const RobustPolicy &, BOOL) [Geometry = boost::geometry::model::polygon<boost::geometry::model::point<double, 2, boost::geometry::cs::spherical_equatorial<boost::geometry::degree>>>, Strategy = boost::geometry::strategies::relate::spherical<>, RobustPolicy = boost::geometry::detail::no_rescale_policy]";
      v22 = 129;
      sub_1016A7A60(&v21);
    }

    if ((v11[4] - 3) >= 2)
    {
      goto LABEL_31;
    }

    v12 += 50;
    v11 += 50;
    if (*v10 == v12)
    {
      v15 = v10[1];
      ++v10;
      v11 = v15;
      goto LABEL_17;
    }
  }
}

void sub_1016A7A14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *__p)
{
  v26 = *(v24 + 32);
  if (v26)
  {
    operator delete(v26);
  }

  if (__p)
  {
    operator delete(__p);
  }

  sub_1016AB5C0(&a11);
  _Unwind_Resume(a1);
}

void sub_1016A7A60(int8x16_t *a1)
{
  exception = __cxa_allocate_exception(0x38uLL);
  sub_1016AAEDC(exception, a1);
}

uint64_t sub_1016A7AA4(double *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  v6 = (*a1 + a1[2]) * 0.5;
  v7 = *(a1 + 1);
  v45 = *a1;
  v47 = *(&v7 + 1);
  v43[1] = *(&v45 + 1);
  v44 = v7;
  v46 = v6;
  v43[0] = v6;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  __p = 0;
  v38 = 0;
  v39 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  sub_101693508(&v45, v43, a2, &v40, &__p, &v34);
  v8 = v34;
  v9 = v35;
  if (v34 == v35)
  {
    goto LABEL_34;
  }

  v48 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  v49 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  v10 = v34;
  do
  {
    sub_1016932F4(&v48, *v10++ + 2);
  }

  while (v10 != v9);
  v33[0] = v48;
  v33[1] = v49;
  v11 = v9 - v8;
  v12 = v8;
  if (a3 > 0x63 || (v12 = v8, v11 < 0x79))
  {
LABEL_19:
    v18 = v12 + 1;
    v17 = v12 + 1;
    if (v12 + 1 != v9)
    {
      while ((sub_1016A7E84(a4, *v12, *v17) & 1) != 0)
      {
        if (++v17 == v9)
        {
          ++v12;
          if (v18 == v9)
          {
            goto LABEL_7;
          }

          goto LABEL_19;
        }
      }

      goto LABEL_37;
    }
  }

  else if (!sub_1016A973C(v33, &v34, a3 + 1, a4))
  {
    goto LABEL_37;
  }

LABEL_7:
  if (v11 >= 0x80 && a3 <= 0x63 && (v41 - v40) >= 0x79)
  {
    if (sub_1016AA164(v33, &v34, &v40, a3 + 1, a4))
    {
      goto LABEL_24;
    }

LABEL_37:
    v25 = 0;
    goto LABEL_38;
  }

  v13 = v40;
  v14 = v41;
  if (v40 != v41)
  {
    v15 = v8;
LABEL_10:
    v16 = v13;
    while ((sub_1016A7E84(a4, *v15, *v16) & 1) != 0)
    {
      if (++v16 == v14)
      {
        if (++v15 != v9)
        {
          goto LABEL_10;
        }

        goto LABEL_14;
      }
    }

    goto LABEL_37;
  }

LABEL_14:
  if (v11 < 0x80)
  {
LABEL_28:
    v19 = __p;
    v20 = v38;
    if (__p != v38)
    {
      v21 = v8;
LABEL_30:
      v22 = v19;
      while ((sub_1016A7E84(a4, *v21, *v22) & 1) != 0)
      {
        if (++v22 == v20)
        {
          if (++v21 != v9)
          {
            goto LABEL_30;
          }

          goto LABEL_34;
        }
      }

      goto LABEL_37;
    }

    goto LABEL_34;
  }

LABEL_24:
  if (a3 > 0x63 || (v38 - __p) < 0x79)
  {
    goto LABEL_28;
  }

  if ((sub_1016AA164(v33, &v34, &__p, a3 + 1, a4) & 1) == 0)
  {
    goto LABEL_37;
  }

LABEL_34:
  v24 = v40;
  v23 = v41;
  if (a3 > 0x63 || (v41 - v40) < 0x79)
  {
    if (v40 != v41)
    {
LABEL_46:
      v27 = v24 + 1;
      v28 = v24 + 1;
      if (v24 + 1 != v23)
      {
        while ((sub_1016A7E84(a4, *v24, *v28) & 1) != 0)
        {
          if (++v28 == v23)
          {
            ++v24;
            if (v27 != v23)
            {
              goto LABEL_46;
            }

            goto LABEL_50;
          }
        }

        goto LABEL_37;
      }
    }
  }

  else if (!sub_1016A973C(&v45, &v40, a3 + 1, a4))
  {
    goto LABEL_37;
  }

LABEL_50:
  v30 = __p;
  v29 = v38;
  if (a3 > 0x63 || (v38 - __p) < 0x79)
  {
    if (__p != v38)
    {
LABEL_54:
      v31 = v30 + 1;
      v32 = v30 + 1;
      if (v30 + 1 != v29)
      {
        while ((sub_1016A7E84(a4, *v30, *v32) & 1) != 0)
        {
          if (++v32 == v29)
          {
            v25 = 1;
            ++v30;
            if (v31 != v29)
            {
              goto LABEL_54;
            }

            goto LABEL_38;
          }
        }

        goto LABEL_37;
      }
    }

    v25 = 1;
  }

  else
  {
    v25 = sub_1016A973C(v43, &__p, a3 + 1, a4);
  }

LABEL_38:
  if (v8)
  {
    operator delete(v8);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (v40)
  {
    operator delete(v40);
  }

  return v25;
}

void sub_1016A7E30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20)
{
  if (v20)
  {
    operator delete(v20);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a20)
  {
    operator delete(a20);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016A7E84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = a3;
  v4 = a2;
  v6 = *(a2 + 32);
  v7 = *(a2 + 48);
  v8 = *(a3 + 32);
  v9 = *(a3 + 48);
  if (v7 - v6 >= 360.0 || v9 - v8 >= 360.0)
  {
    goto LABEL_11;
  }

  v10 = vabdd_f64(v8, v6);
  v11 = 180.0;
  if (v10 == 180.0)
  {
    goto LABEL_4;
  }

  v12 = v8 - v6;
  if (COERCE__INT64(fabs(v8 - v6)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v239 = fabs(v10 + -180.0);
    v11 = 180.0;
    if (v10 < 180.0)
    {
      v10 = 180.0;
    }

    if (v10 < 1.0)
    {
      v10 = 1.0;
    }

    if (v239 <= v10 * 2.22044605e-16)
    {
      goto LABEL_4;
    }
  }

  v11 = 180.0;
  if (v12 <= 180.0)
  {
    if (v12 >= -180.0)
    {
      goto LABEL_5;
    }

    v11 = fmod(v12 + -180.0, 360.0) + 180.0;
LABEL_4:
    v12 = v11;
    goto LABEL_5;
  }

  v12 = fmod(v12 + 180.0, 360.0) + -180.0;
  if (v12 == -180.0)
  {
    goto LABEL_4;
  }

  if ((*&v12 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v240 = fabs(v12);
    v11 = 180.0;
    v241 = fabs(v12 + 180.0);
    if (v240 < 180.0)
    {
      v240 = 180.0;
    }

    if (v240 < 1.0)
    {
      v240 = 1.0;
    }

    if (v241 <= v240 * 2.22044605e-16)
    {
      goto LABEL_4;
    }
  }

LABEL_5:
  if (v12 < 0.0)
  {
    v12 = v12 + 360.0;
  }

  v13 = v6 + v12;
  v14 = v9 - v8 + v6 + v12 + -360.0;
  if (vabdd_f64(v14, v9) < 180.0)
  {
    v14 = v9;
  }

  if (v13 > v7 && v14 < v6)
  {
    return 1;
  }

LABEL_11:
  if (*(v4 + 56) < *(v3 + 40) || *(v4 + 40) > *(v3 + 56) || (*(v4 + 96) & 1) != 0 || (*(v3 + 96) & 1) != 0)
  {
    return 1;
  }

  v263 = *(a1 + 40);
  v15 = *a1;
  v258 = *(a1 + 44);
  v262 = *(a1 + 8);
  v16 = *(a1 + 32);
  v17 = *(v4 + 24);
  v18 = *a1;
  if ((v17 & 0x8000000000000000) == 0)
  {
    v19 = v15[3];
    if (0xAAAAAAAAAAAAAAABLL * (v15[4] - v19) < v17)
    {
      goto LABEL_350;
    }

    v18 = &v19[3 * v17];
  }

  v20 = *v18;
  v21 = v18[1];
  v22 = *(v3 + 24);
  v266 = *(a1 + 24);
  if ((v22 & 0x8000000000000000) == 0)
  {
    v24 = v15 + 3;
    v23 = v15[3];
    if (0xAAAAAAAAAAAAAAABLL * ((v24[1] - v23) >> 3) >= v22)
    {
      v15 = &v23[3 * v22];
      goto LABEL_21;
    }

LABEL_350:
    __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
  }

LABEL_21:
  v264 = *v15;
  v269 = v15[1];
  v25 = *v4;
  v247 = *v3;
  v27 = *(v4 + 64);
  v26 = *(v4 + 72);
  v259 = *(v4 + 104);
  v28 = &v20[2 * v27];
  v29 = &v20[2 * v26 + 2];
  v242 = v16;
  if (16 * v27 != 16 * v26 && sub_101695318(v25, v28[2], v6, v7, v8, v9))
  {
    v30 = v27 + 1;
    v31 = v259 + 1;
    v32 = v28 + 4;
    do
    {
      v27 = v30;
      v33 = v31;
      v34 = v32;
      if (v32 == v29)
      {
        break;
      }

      v32 += 2;
      v35 = sub_101695318(v25, *v34, v6, v7, v8, v9);
      v30 = v27 + 1;
      v31 = v33 + 1;
    }

    while (v35);
    v259 = v33;
    v28 = v34 - 2;
  }

  if (v28 + 2 != v29)
  {
    v244 = v29;
    v36 = &v20[2 * (v28 != v20)];
    v257 = v28 + 2;
    if (v28 + 2 != v21)
    {
      v36 = v28 + 2;
    }

    v37 = v36 != v20;
    v38 = v36 + 2;
    v39 = &v20[2 * v37];
    if (v38 == v21)
    {
      v38 = v39;
    }

    v256 = v38;
    v249 = -v25;
    v40 = v264;
    __asm { FMOV            V0.2D, #1.0 }

    v267 = _Q0;
    v45 = v266;
    v245 = v21;
    v246 = v20;
    v260 = v4;
    v261 = v3;
    while (1)
    {
      v46 = *(v4 + 32);
      v47 = *(v4 + 48);
      v48 = *(v3 + 32);
      v49 = *(v3 + 48);
      if (sub_101695318(v249, *v28, v46, v47, v48, v49))
      {
        return 1;
      }

      v299 = 0u;
      v298 = 0u;
      v292[0] = v4;
      v265 = v27;
      v292[1] = v27;
      v250 = v28;
      v293 = v28;
      v294 = v257;
      v295 = v256;
      v296 = v20;
      v297 = v21;
      LOBYTE(v298) = 1;
      v50 = *(v3 + 104);
      v51 = *(v3 + 64);
      v52 = &v40[2 * v51];
      v268 = &v264[2 * *(v3 + 72) + 2];
      if (v52 + 2 != v268 && sub_101695318(v247, v52[2], v48, v49, v46, v47))
      {
        v53 = v51 + 1;
        v54 = v50 + 1;
        v55 = v52 + 4;
        do
        {
          v51 = v53;
          v50 = v54;
          v56 = v55;
          if (v55 == v268)
          {
            break;
          }

          v55 += 2;
          v57 = sub_101695318(v247, *v56, v48, v49, v46, v47);
          v53 = v51 + 1;
          v54 = v50 + 1;
        }

        while (v57);
        v52 = v56 - 2;
        v45 = v266;
        v40 = v264;
      }

      v58 = v52 + 2;
      if (v52 + 2 != v268)
      {
        break;
      }

      ++v259;
LABEL_325:
      v28 = v250 + 2;
      v236 = v257 + 2;
      v27 = v265 + 1;
      v21 = v245;
      v20 = v246;
      v237 = &v246[2 * (v256 != v246)];
      if (v256 + 2 != v245)
      {
        v237 = v256 + 2;
      }

      v256 = v237;
      v257 += 2;
      result = 1;
      if (v236 == v244)
      {
        return result;
      }
    }

    v59 = &v40[2 * (v52 != v40)];
    if (v58 != v269)
    {
      v59 = v52 + 2;
    }

    v60 = v59 != v40;
    v61 = v59 + 2;
    v62 = &v40[2 * v60];
    if (v61 == v269)
    {
      v61 = v62;
    }

    v271 = v61;
    ++v259;
    while (1)
    {
      if (sub_101695318(-v247, *v52, *(v3 + 32), *(v3 + 48), *(v4 + 32), *(v4 + 48)))
      {
        goto LABEL_325;
      }

      v63 = *(v4 + 16);
      v64 = *(v3 + 16);
      if (v63 != v64)
      {
        break;
      }

      _ZF = *(v4 + 24) != *(v3 + 24) || v258 == 0;
      if (_ZF || v50 != v259 && (v265 || *(v4 + 88) - 2 > v51))
      {
        break;
      }

LABEL_307:
      v52 += 2;
      v58 += 2;
      ++v51;
      v232 = &v40[2 * (v271 != v40)];
      if (v271 + 2 != v269)
      {
        v232 = v271 + 2;
      }

      v271 = v232;
      ++v50;
      if (v58 == v268)
      {
        goto LABEL_325;
      }
    }

    v66 = 0;
    v291 = 0u;
    v290 = 0u;
    v285[0] = v3;
    v285[1] = v51;
    v285[2] = v52;
    v286 = v58;
    v287 = v271;
    v288 = v40;
    v289 = v269;
    v284 = 0.0;
    v282 = 0u;
    v283 = 0u;
    v280 = 0u;
    v281 = 0u;
    v278 = 0u;
    v279 = 0u;
    v276 = 0u;
    v277 = 0u;
    v274 = 0u;
    v275 = 0u;
    v272 = 0u;
    *&v273 = 0;
    *(&v273 + 1) = -1;
    *&v67 = -1;
    *(&v67 + 1) = -1;
    do
    {
      v68 = &v272 + v66;
      *(v68 + 10) = 0;
      *(v68 + 3) = v67;
      *(v68 + 4) = v67;
      *(v68 + 10) = -1;
      *(v68 + 88) = xmmword_1019ADEB0;
      v66 += 80;
      *(v68 + 13) = 0;
      *(v68 + 14) = 0;
    }

    while (v66 != 160);
    v69 = *(v4 + 24);
    *&v275 = v263;
    *(&v275 + 1) = v63;
    *&v276 = v69;
    *(&v276 + 1) = v265;
    v70 = *(v3 + 24);
    *&v277 = -1;
    *&v280 = v263;
    *(&v280 + 1) = v64;
    *&v281 = v70;
    *(&v281 + 1) = v51;
    *&v282 = -1;
    v270 = v45[5];
    memset(v334, 0, sizeof(v334));
    v332 = 0u;
    v333 = 0u;
    memset(v331, 0, sizeof(v331));
    v329 = 0u;
    v330 = 0u;
    v328 = 0u;
    memset(v327, 0, sizeof(v327));
    v322 = 0;
    v324 = 0u;
    v320 = v292;
    v321 = v285;
    v323 = v292;
    *&v324 = v285;
    v325 = v285;
    v326 = v292;
    sub_101695BC8(v327, v293, v294, v52, v58);
    *&v334[3] = v262;
    v45 = v266;
    v71 = v270;
    if (BYTE8(v332) == 100)
    {
      goto LABEL_293;
    }

    *v307 = v282;
    *&v307[16] = v283;
    v308 = v284;
    *&v303[16] = v278;
    v304 = v279;
    v305 = v280;
    v306 = v281;
    v302[0] = v274;
    v302[1] = v275;
    v302[2] = v276;
    *v303 = v277;
    v300 = v272;
    v301 = v273;
    if (BYTE8(v332) > 0x68u)
    {
      if (BYTE8(v332) == 105)
      {
        LODWORD(v301) = 2;
        if (!v327[0])
        {
          __assert_rtn("assign_point", "get_turn_info.hpp", 164, "index < info.count");
        }

        v300 = *&v327[1];
        *&v303[8] = *&v327[5];
        *&v303[24] = v327[7];
        *&v307[8] = v328;
        *&v307[24] = v329;
        v86 = HIDWORD(v334[0]) == 1;
        DWORD2(v302[5 * (HIDWORD(v334[0]) != 1)]) = 1;
        DWORD2(v302[5 * v86]) = 2;
        sub_1016AAA04(v266, &v300);
        goto LABEL_292;
      }

      if (BYTE8(v332) != 116)
      {
        if (BYTE8(v332) != 109)
        {
          goto LABEL_293;
        }

        LODWORD(v301) = 4;
        v300 = *&v327[1];
        v72 = 0;
        v73 = 1;
        v74 = 5;
        if (LODWORD(v334[2]) == 1)
        {
          do
          {
            v75 = v73;
            v76 = *(&v334[1] + v72 + 1);
            if (v76 == -1)
            {
              v78 = &v302[5 * v72] + 8;
              *(v78 + 3) = xmmword_1019ADEB0;
              *(v78 + 8) = 0;
            }

            else if (v76 == 1)
            {
              v77 = &v302[5 * v72] + 8;
              *(v77 + 3) = v267;
              *(v77 + 8) = 0x412E848000000000;
            }

            else
            {
              v79 = &v327[v74];
              v80 = &v302[5 * v72] + 8;
              *(v80 + 3) = *v79;
              *(v80 + 8) = v79[2];
            }

            v73 = 0;
            v74 = 8;
            v72 = 1;
          }

          while ((v75 & 1) != 0);
          v251 = HIDWORD(v334[0]);
          v81 = v323[2];
          v82 = v323[3];
          v83 = sub_1016989B0(v324);
          v84 = sub_10169A37C(v81, v82, v83);
          v85 = v84;
          if (v251 + v84)
          {
            v146 = *(v324 + 16);
            v147 = *(v324 + 24);
            v148 = sub_1016989B0(v324);
            v149 = sub_10169A37C(v146, v147, v148);
            v150 = *(v324 + 24);
            v151 = sub_1016989B0(v324);
            v152 = sub_10169A37C(v150, v151, v323[3]);
            if ((v85 & v251) == 0xFFFFFFFF && v149 == 1)
            {
              DWORD2(v302[0]) = 2;
              DWORD2(v304) = 2;
              BYTE4(v301) = 1;
            }

            else
            {
              v154 = v152;
              if (v251 == 1 && v85 == 1 && v149 == -1)
              {
                if (v152 == -1)
                {
                  v155 = 1;
                }

                else
                {
                  v155 = 3;
                }

                DWORD2(v302[0]) = 1;
                DWORD2(v304) = v155;
              }

              else
              {
                if (v251 != v85 || v251 != v149)
                {
                  if (!v85)
                  {
                    v178 = v266;
                    if (v251 == v149)
                    {
                      v233 = 4;
                      DWORD2(v302[0]) = 4;
                    }

                    else
                    {
                      if (v149 == 1)
                      {
                        v234 = 2;
                      }

                      else
                      {
                        v234 = 1;
                      }

                      DWORD2(v302[0]) = v234;
                      v233 = 3;
                    }

                    DWORD2(v304) = v233;
                    goto LABEL_237;
                  }

                  LODWORD(v301) = 8;
                  goto LABEL_236;
                }

                v188 = (v149 == 1) ^ (v152 == 0);
                if (v152 * v251 == -1)
                {
                  v254 = sub_10169A37C(v323[2], v323[3], *(v324 + 24));
                  v189 = v323[3];
                  v190 = sub_1016989B0(v323);
                  if (sub_10169A37C(v189, v190, *(v324 + 24)) * v254 == 1 && sub_10169A37C(*(v324 + 16), *(v324 + 24), v323[3]) * v154 == -1)
                  {
                    v188 ^= 1u;
                  }
                }

                DWORD2(v302[5 * v188]) = 1;
                DWORD2(v302[5 * (v188 ^ 1)]) = 2;
              }

              BYTE4(v301) = 1;
            }
          }

          else
          {
            DWORD2(v302[5 * (v84 != -1)]) = 1;
            DWORD2(v302[5 * (v84 == -1)]) = 2;
          }

LABEL_236:
          v178 = v266;
          goto LABEL_237;
        }

        do
        {
          v129 = v73;
          v130 = *(&v334[1] + v72 + 1);
          if (v130 == -1)
          {
            v132 = &v302[5 * v72] + 8;
            *(v132 + 3) = xmmword_1019ADEB0;
            *(v132 + 8) = 0;
          }

          else if (v130 == 1)
          {
            v131 = &v302[5 * v72] + 8;
            *(v131 + 3) = v267;
            *(v131 + 8) = 0x412E848000000000;
          }

          else
          {
            v133 = &v327[v74];
            v134 = &v302[5 * v72] + 8;
            *(v134 + 3) = *v133;
            *(v134 + 8) = v133[2];
          }

          v73 = 0;
          v74 = 8;
          v72 = 1;
        }

        while ((v129 & 1) != 0);
        v253 = HIDWORD(v333);
        v135 = v325[2];
        v136 = v325[3];
        v137 = sub_1016989B0(v326);
        v138 = sub_10169A37C(v135, v136, v137);
        v139 = v138;
        if (v253 + v138)
        {
          v156 = v326[2];
          v157 = v326[3];
          v158 = sub_1016989B0(v326);
          v159 = sub_10169A37C(v156, v157, v158);
          v160 = v326[3];
          v161 = sub_1016989B0(v326);
          v162 = sub_10169A37C(v160, v161, v325[3]);
          if ((v139 & v253) == 0xFFFFFFFF && v159 == 1)
          {
            DWORD2(v302[0]) = 2;
            DWORD2(v304) = 2;
          }

          else
          {
            v164 = v162;
            if (v253 != 1 || v139 != 1 || v159 != -1)
            {
              if (v253 == v139 && v253 == v159)
              {
                v191 = (v159 == 1) ^ (v162 != 0);
                if (v162 * v253 == -1)
                {
                  v255 = sub_10169A37C(v325[2], v325[3], v326[3]);
                  v192 = v325[3];
                  v193 = sub_1016989B0(v325);
                  if (sub_10169A37C(v192, v193, v326[3]) * v255 == 1 && sub_10169A37C(v326[2], v326[3], v325[3]) * v164 == -1)
                  {
                    v191 ^= 1u;
                  }
                }

                DWORD2(v302[5 * v191]) = 1;
                DWORD2(v302[5 * (v191 ^ 1)]) = 2;
                BYTE4(v301) = 1;
              }

              else
              {
                if (!v139)
                {
                  v178 = v266;
                  if (v253 == v159)
                  {
                    DWORD2(v302[0]) = 4;
                    DWORD2(v304) = 4;
                  }

                  else
                  {
                    if (v159 == 1)
                    {
                      v235 = 2;
                    }

                    else
                    {
                      v235 = 1;
                    }

                    DWORD2(v304) = v235;
                    DWORD2(v302[0]) = 3;
                  }

                  goto LABEL_237;
                }

                LODWORD(v301) = 8;
              }

              goto LABEL_196;
            }

            if (v162 == -1)
            {
              v165 = 1;
            }

            else
            {
              v165 = 3;
            }

            DWORD2(v302[0]) = v165;
            DWORD2(v304) = 1;
          }

          BYTE4(v301) = 1;
        }

        else
        {
          DWORD2(v302[5 * (v138 == -1)]) = 1;
          DWORD2(v302[5 * (v138 != -1)]) = 2;
        }

LABEL_196:
        v178 = v266;
LABEL_237:
        sub_1016AAA04(v178, &v300);
        goto LABEL_292;
      }

      v87 = 0;
      LODWORD(v301) = 3;
      v300 = *&v327[1];
      v88 = 1;
      v89 = 5;
      do
      {
        v90 = v88;
        v91 = *(&v334[1] + v87 + 1);
        if (v91 == -1)
        {
          v93 = &v302[5 * v87] + 8;
          *(v93 + 3) = xmmword_1019ADEB0;
          *(v93 + 8) = 0;
        }

        else if (v91 == 1)
        {
          v92 = &v302[5 * v87] + 8;
          *(v92 + 3) = v267;
          *(v92 + 8) = 0x412E848000000000;
        }

        else
        {
          v94 = &v327[v89];
          v95 = &v302[5 * v87] + 8;
          *(v95 + 3) = *v94;
          *(v95 + 8) = v94[2];
        }

        v88 = 0;
        v89 = 8;
        v87 = 1;
      }

      while ((v90 & 1) != 0);
      v96 = *(v324 + 16);
      v97 = *(v324 + 24);
      v98 = sub_1016989B0(v323);
      v243 = sub_10169A37C(v96, v97, v98);
      v252 = HIDWORD(v334[0]);
      v99 = v323[2];
      v100 = v323[3];
      v101 = sub_1016989B0(v324);
      v248 = sub_10169A37C(v99, v100, v101);
      if (v248 * v252 != -1)
      {
        v102 = *(v324 + 24);
        v103 = sub_1016989B0(v324);
        v104 = sub_1016989B0(v323);
        v105 = sub_10169A37C(v102, v103, v104);
        v106 = v323[2];
        v107 = v323[3];
        v108 = sub_1016989B0(v323);
        v109 = sub_10169A37C(v106, v107, v108);
        v111 = *(v324 + 16);
        v110 = *(v324 + 24);
        v112 = sub_1016989B0(v324);
        v113 = sub_10169A37C(v111, v110, v112);
        if (v248)
        {
          v114 = 1;
        }

        else
        {
          v114 = v113 * v252 == 1;
        }

        v115 = !v114;
        if (v109 != v252 && v109 != v248 && (v248 | v252 || v109 == -1))
        {
          if (v113 == 1)
          {
            v175 = 2;
          }

          else
          {
            v175 = 1;
          }

          if (v248 == 1 || v252 == 1)
          {
            v177 = 1;
          }

          else
          {
            v177 = 2;
          }

          if (v115)
          {
            v177 = 3;
          }

          DWORD2(v302[0]) = v175;
          DWORD2(v304) = v177;
          v116 = v266;
          if ((v115 & 1) == 0)
          {
            BYTE4(v301) = 1;
          }

          goto LABEL_251;
        }

        v116 = v266;
        if ((v105 != 0) | v115 & 1)
        {
          if (!v243)
          {
            if (v113 == 1)
            {
              v179 = 2;
            }

            else
            {
              v179 = 1;
            }

            if (v115)
            {
              v119 = 3;
            }

            else
            {
              v119 = v179;
            }

            DWORD2(v302[0]) = 3;
            goto LABEL_204;
          }

          if (v243 == v105 && v113 * v243 != -1)
          {
            if (v113 == 1)
            {
              v117 = 1;
            }

            else
            {
              v117 = 2;
            }

            if (v113 == 1)
            {
              v118 = 2;
            }

            else
            {
              v118 = 1;
            }

            if (v115)
            {
              v119 = 3;
            }

            else
            {
              v119 = v118;
            }

            DWORD2(v302[0]) = v117;
            goto LABEL_204;
          }

          if (!(v105 + v113))
          {
            if (v113 == 1)
            {
              v185 = 2;
            }

            else
            {
              v185 = 1;
            }

            if (v113 == 1)
            {
              v186 = 1;
            }

            else
            {
              v186 = 2;
            }

            DWORD2(v302[0]) = v185;
            DWORD2(v304) = v186;
LABEL_223:
            BYTE4(v301) = 1;
            goto LABEL_251;
          }

          if (v243 != -v113)
          {
            goto LABEL_251;
          }

          if (v113 == 1)
          {
            v194 = 2;
          }

          else
          {
            v194 = 1;
          }

          DWORD2(v302[0]) = v194;
          DWORD2(v304) = v194;
          if (!v115)
          {
            goto LABEL_223;
          }

          v119 = 3;
        }

        else
        {
          v119 = 4;
          DWORD2(v302[0]) = 4;
        }

LABEL_204:
        DWORD2(v304) = v119;
LABEL_251:
        sub_1016AAA04(v116, &v300);
        goto LABEL_292;
      }

      v140 = v323[2];
      v141 = v323[3];
      v142 = sub_1016989B0(v323);
      v143 = sub_10169A37C(v140, v141, v142);
      v144 = v248;
      if (v143 == v252)
      {
        if (!v243)
        {
          if (v248 == 1)
          {
            v187 = 1;
          }

          else
          {
            v187 = 2;
          }

          DWORD2(v302[0]) = 3;
          goto LABEL_249;
        }

        if (v243 == v248)
        {
          if (v248 == 1)
          {
            v145 = 1;
          }

          else
          {
            v145 = 2;
          }

          DWORD2(v302[0]) = v145;
          DWORD2(v304) = v145;
          BYTE4(v301) = 1;
          goto LABEL_250;
        }
      }

      if (v143 != v248)
      {
        goto LABEL_172;
      }

      v166 = *(v324 + 24);
      v167 = sub_1016989B0(v324);
      v168 = sub_1016989B0(v323);
      v169 = sub_10169A37C(v166, v167, v168);
      if (v169)
      {
        v144 = v248;
        if (v169 == v248)
        {
          if (v248 == 1)
          {
            v170 = 1;
          }

          else
          {
            v170 = 2;
          }

          if (v248 == 1)
          {
            v171 = 2;
          }

          else
          {
            v171 = 1;
          }

          DWORD2(v302[0]) = v170;
          DWORD2(v304) = v171;
          BYTE4(v301) = 1;
          goto LABEL_250;
        }

LABEL_172:
        v172 = v144 == 1;
        if (v144 == 1)
        {
          v173 = 2;
        }

        else
        {
          v173 = 1;
        }

        if (v172)
        {
          v174 = 1;
        }

        else
        {
          v174 = 2;
        }

        DWORD2(v302[0]) = v173;
        DWORD2(v304) = v174;
        goto LABEL_250;
      }

      v187 = 4;
      DWORD2(v302[0]) = 4;
LABEL_249:
      DWORD2(v304) = v187;
LABEL_250:
      v116 = v266;
      goto LABEL_251;
    }

    if (BYTE8(v332) != 99)
    {
      if (BYTE8(v332) == 101 && (BYTE9(v332) & 1) == 0)
      {
        sub_1016AA7B0(&v300, v327, &v322);
LABEL_171:
        sub_1016AAA04(v266, &v300);
        goto LABEL_292;
      }

LABEL_293:
      v221 = v45[5];
      if (v221 < v71)
      {
        __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
      }

      v222 = v45[4];
      v223 = v45[1];
      v224 = v45[2];
      v225 = (v223 + 8 * (v222 / 0x14));
      if (v224 == v223)
      {
        v226 = 0;
      }

      else
      {
        v226 = *v225 + 200 * (v222 % 0x14);
      }

      v4 = v260;
      v3 = v261;
      v40 = v264;
      if (v270)
      {
        v227 = v270 - 0x70A3D70A3D70A3D7 * ((v226 - *v225) >> 3);
        if (v227 < 1)
        {
          v228 = 19 - v227;
          v225 -= v228 / 0x14;
          v226 = *v225 + 200 * (20 * (v228 / 0x14) - v228) + 3800;
        }

        else
        {
          v225 += v227 / 0x14uLL;
          v226 = *v225 + 200 * (v227 % 0x14uLL);
        }
      }

      v229 = v222 + v221;
      v230 = (v223 + 8 * (v229 / 0x14));
      if (v224 == v223)
      {
        v231 = 0;
      }

      else
      {
        v231 = *v230 + 200 * (v229 % 0x14);
      }

      if (v231 != v226 && 20 * (v230 - v225) - 0x70A3D70A3D70A3D7 * ((v231 - *v230) >> 3) != 0x8F5C28F5C28F5C29 * ((v226 - *v225) >> 3))
      {
        result = 0;
        *v242 = 1;
        return result;
      }

      goto LABEL_307;
    }

    if ((BYTE9(v332) & 1) == 0)
    {
      if (HIDWORD(v334[1]))
      {
        if (vabdd_f64(*&v329, *&v331[3]) >= 50.0)
        {
          v128 = *&v329 < *&v331[3];
        }

        else
        {
          if (*(&v328 + 1) == 0.0)
          {
            __assert_rtn("apply", "segment_ratio.hpp", 56, "lhs.denominator() != Type(0)");
          }

          if (*&v331[2] == 0.0)
          {
            __assert_rtn("apply", "segment_ratio.hpp", 57, "rhs.denominator() != Type(0)");
          }

          v126 = *&v328 / *(&v328 + 1);
          v127 = *&v331[1] / *&v331[2];
          if (*&v328 / *(&v328 + 1) == *&v331[1] / *&v331[2])
          {
            v128 = 0;
          }

          else if (COERCE_UNSIGNED_INT64(fabs(*&v328 / *(&v328 + 1))) <= 0x7FEFFFFFFFFFFFFFLL && COERCE_UNSIGNED_INT64(fabs(*&v331[1] / *&v331[2])) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            v195 = fabs(v126);
            v196 = fabs(v127);
            v197 = vabdd_f64(v126, v127);
            if (v195 < v196)
            {
              v195 = v196;
            }

            if (v195 < 1.0)
            {
              v195 = 1.0;
            }

            v128 = v197 > v195 * 2.22044605e-16;
          }

          else
          {
            v128 = 1;
          }

          if (v126 >= v127)
          {
            v128 = 0;
          }
        }

        LODWORD(v301) = 5;
        if (v327[0] <= v128)
        {
          __assert_rtn("assign_point", "get_turn_info.hpp", 164, "index < info.count");
        }

        v198 = HIDWORD(v334[1]);
        v300 = *&v327[2 * v128 + 1];
        v199 = &v327[7 * v128 + 5];
        *&v303[8] = *v199;
        *&v303[24] = v199[2];
        *&v307[8] = *(v199 + 3);
        *&v307[24] = v199[5];
        v200 = v323[2];
        v201 = v323[3];
        v202 = sub_1016989B0(v323);
        v203 = sub_10169A37C(v200, v201, v202);
        v204 = *(v324 + 16);
        v205 = *(v324 + 24);
        v206 = sub_1016989B0(v324);
        v207 = sub_10169A37C(v204, v205, v206);
        v208 = v207;
        if (v198 == 1)
        {
          v209 = v203;
        }

        else
        {
          v209 = v207;
        }

        if (v209 * v198 == 1)
        {
          v210 = 1;
        }

        else
        {
          v210 = 2;
        }

        if (v209 * v198 == 1)
        {
          v211 = 2;
        }

        else
        {
          v211 = 1;
        }

        v212 = v209 == 0;
        if (v209)
        {
          v213 = v210;
        }

        else
        {
          v213 = 4;
        }

        if (v212)
        {
          v214 = 4;
        }

        else
        {
          v214 = v211;
        }

        DWORD2(v302[0]) = v213;
        DWORD2(v304) = v214;
        if (v203)
        {
          v215 = v294;
        }

        else
        {
          v215 = sub_1016989B0(v292);
        }

        v217 = *(&v300 + 1);
        v216 = *&v300;
        *&v304 = (*(&v300 + 1) - v215[1]) * (*(&v300 + 1) - v215[1]) + (*&v300 - *v215) * (*&v300 - *v215);
        if (v208)
        {
          v218 = *v286;
          v219 = v286[1];
        }

        else
        {
          v220 = sub_1016989B0(v285);
          v217 = *(&v300 + 1);
          v216 = *&v300;
          v218 = *v220;
          v219 = v220[1];
        }

        v308 = (v217 - v219) * (v217 - v219) + (v216 - v218) * (v216 - v218);
        sub_1016AAA04(v266, &v300);
        goto LABEL_292;
      }

      sub_1016AA7B0(&v300, v327, &v322);
      LODWORD(v301) = 5;
      goto LABEL_171;
    }

    *v318 = v282;
    *&v318[16] = v283;
    v319 = v284;
    *&v314[16] = v278;
    v315 = v279;
    v317 = v281;
    v316 = v280;
    v311 = v274;
    v312 = v275;
    v313 = v276;
    *v314 = v277;
    v309 = v272;
    v310 = v273;
    v120 = v334[2];
    if (HIDWORD(v334[1]) == 1)
    {
      v121 = v323[2];
      v122 = v323[3];
      v123 = sub_1016989B0(v323);
      v124 = sub_10169A37C(v121, v122, v123);
      if (v124 == 1)
      {
        v125 = 2;
      }

      else
      {
        if (!v124)
        {
          goto LABEL_208;
        }

        v125 = 1;
      }

      DWORD2(v315) = 3;
      DWORD2(v311) = v125;
      LODWORD(v310) = 5;
      if (v327[0] <= 1uLL)
      {
        __assert_rtn("assign_point", "get_turn_info.hpp", 164, "index < info.count");
      }

      v309 = *&v327[3];
      *&v314[8] = v330;
      *&v314[24] = v331[0];
      *&v318[8] = *&v331[1];
      *&v318[24] = v331[3];
      sub_1016AAA04(v266, &v309);
    }

LABEL_208:
    if (v120 == 1)
    {
      v180 = *(v324 + 16);
      v181 = *(v324 + 24);
      v182 = sub_1016989B0(v324);
      v183 = sub_10169A37C(v180, v181, v182);
      if (v183 == 1)
      {
        v184 = 2;
      }

      else
      {
        if (!v183)
        {
          goto LABEL_292;
        }

        v184 = 1;
      }

      DWORD2(v315) = v184;
      DWORD2(v311) = 3;
      LODWORD(v310) = 5;
      if (!v327[0])
      {
        __assert_rtn("assign_point", "get_turn_info.hpp", 164, "index < info.count");
      }

      v309 = *&v327[1];
      *&v314[8] = *&v327[5];
      *&v314[24] = v327[7];
      *&v318[8] = v328;
      *&v318[24] = v329;
      sub_1016AAA04(v266, &v309);
    }

LABEL_292:
    v45 = v266;
    v71 = v270;
    goto LABEL_293;
  }

  return 1;
}

uint64_t sub_1016A973C(double *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  v6 = (a1[1] + a1[3]) * 0.5;
  v47 = *(a1 + 2);
  v7 = *a1;
  v8 = *(a1 + 1);
  v44[0] = *a1;
  v45 = v8;
  v46 = v7;
  v48 = v6;
  v44[1] = v6;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  __p = 0;
  v39 = 0;
  v40 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_101693508(&v46, v44, a2, &v41, &__p, &v35);
  v9 = v35;
  v10 = v36;
  if (v35 == v36)
  {
    goto LABEL_34;
  }

  v49 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  v50 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  v11 = v35;
  do
  {
    sub_1016932F4(&v49, *v11++ + 2);
  }

  while (v11 != v10);
  v34[0] = v49;
  v34[1] = v50;
  v12 = v10 - v9;
  v13 = v9;
  if (a3 > 0x63 || (v13 = v9, v12 < 0x79))
  {
LABEL_19:
    v19 = v13 + 1;
    v18 = v13 + 1;
    if (v13 + 1 != v10)
    {
      while ((sub_1016A7E84(a4, *v13, *v18) & 1) != 0)
      {
        if (++v18 == v10)
        {
          ++v13;
          if (v19 == v10)
          {
            goto LABEL_7;
          }

          goto LABEL_19;
        }
      }

      goto LABEL_37;
    }
  }

  else if (!sub_1016A7AA4(v34, &v35, a3 + 1, a4))
  {
    goto LABEL_37;
  }

LABEL_7:
  if (v12 >= 0x80 && a3 <= 0x63 && (v42 - v41) >= 0x79)
  {
    if (sub_1016A9B24(v34, &v35, &v41, a3 + 1, a4))
    {
      goto LABEL_24;
    }

LABEL_37:
    v26 = 0;
    goto LABEL_38;
  }

  v14 = v41;
  v15 = v42;
  if (v41 != v42)
  {
    v16 = v9;
LABEL_10:
    v17 = v14;
    while ((sub_1016A7E84(a4, *v16, *v17) & 1) != 0)
    {
      if (++v17 == v15)
      {
        if (++v16 != v10)
        {
          goto LABEL_10;
        }

        goto LABEL_14;
      }
    }

    goto LABEL_37;
  }

LABEL_14:
  if (v12 < 0x80)
  {
LABEL_28:
    v20 = __p;
    v21 = v39;
    if (__p != v39)
    {
      v22 = v9;
LABEL_30:
      v23 = v20;
      while ((sub_1016A7E84(a4, *v22, *v23) & 1) != 0)
      {
        if (++v23 == v21)
        {
          if (++v22 != v10)
          {
            goto LABEL_30;
          }

          goto LABEL_34;
        }
      }

      goto LABEL_37;
    }

    goto LABEL_34;
  }

LABEL_24:
  if (a3 > 0x63 || (v39 - __p) < 0x79)
  {
    goto LABEL_28;
  }

  if ((sub_1016A9B24(v34, &v35, &__p, a3 + 1, a4) & 1) == 0)
  {
    goto LABEL_37;
  }

LABEL_34:
  v25 = v41;
  v24 = v42;
  if (a3 > 0x63 || (v42 - v41) < 0x79)
  {
    if (v41 != v42)
    {
LABEL_46:
      v28 = v25 + 1;
      v29 = v25 + 1;
      if (v25 + 1 != v24)
      {
        while ((sub_1016A7E84(a4, *v25, *v29) & 1) != 0)
        {
          if (++v29 == v24)
          {
            ++v25;
            if (v28 != v24)
            {
              goto LABEL_46;
            }

            goto LABEL_50;
          }
        }

        goto LABEL_37;
      }
    }
  }

  else if (!sub_1016A7AA4(&v46, &v41, a3 + 1, a4))
  {
    goto LABEL_37;
  }

LABEL_50:
  v31 = __p;
  v30 = v39;
  if (a3 > 0x63 || (v39 - __p) < 0x79)
  {
    if (__p != v39)
    {
LABEL_54:
      v32 = v31 + 1;
      v33 = v31 + 1;
      if (v31 + 1 != v30)
      {
        while ((sub_1016A7E84(a4, *v31, *v33) & 1) != 0)
        {
          if (++v33 == v30)
          {
            v26 = 1;
            ++v31;
            if (v32 != v30)
            {
              goto LABEL_54;
            }

            goto LABEL_38;
          }
        }

        goto LABEL_37;
      }
    }

    v26 = 1;
  }

  else
  {
    v26 = sub_1016A7AA4(v44, &__p, a3 + 1, a4);
  }

LABEL_38:
  if (v9)
  {
    operator delete(v9);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (v41)
  {
    operator delete(v41);
  }

  return v26;
}

void sub_1016A9AD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20)
{
  if (v20)
  {
    operator delete(v20);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a20)
  {
    operator delete(a20);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016A9B24(double *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  v8 = (*a1 + a1[2]) * 0.5;
  v9 = *(a1 + 1);
  v72 = *a1;
  v74 = *(&v9 + 1);
  v70[1] = *(&v72 + 1);
  v71 = v9;
  v73 = v8;
  v70[0] = v8;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v61 = 0;
  v62 = 0;
  v63 = 0;
  v58 = 0;
  v59 = 0;
  v60 = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  __p = 0;
  v53 = 0;
  v54 = 0;
  sub_101693508(&v72, v70, a2, &v67, &v64, &v61);
  sub_101693508(&v72, v70, a3, &v58, &v55, &__p);
  v10 = v61;
  v11 = v62;
  v12 = __p;
  if (v61 == v62)
  {
    v49 = a4;
    v14 = v53;
  }

  else
  {
    v13 = v62 - v61;
    v14 = v53;
    if ((v62 - v61) < 0x80 || a4 > 0x63 || (v53 - __p) < 0x79)
    {
      if (__p != v53)
      {
        v15 = v61;
LABEL_5:
        v16 = v12;
        while ((sub_1016A7E84(a5, *v15, *v16) & 1) != 0)
        {
          if (++v16 == v14)
          {
            if (++v15 != v11)
            {
              goto LABEL_5;
            }

            goto LABEL_35;
          }
        }

        goto LABEL_87;
      }
    }

    else
    {
      v75 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v76 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v25 = v61;
      do
      {
        sub_1016932F4(&v75, *v25++ + 2);
      }

      while (v25 != v11);
      v26 = v75;
      v27 = v76;
      if (v12 != v14)
      {
        v28 = v12;
        do
        {
          sub_1016932F4(&v75, *v28++ + 2);
        }

        while (v28 != v14);
        v26 = v75;
        v27 = v76;
      }

      v50 = v26;
      v51 = v27;
      if ((sub_1016AA164(v50.f64, &v61, &__p, a4 + 1, a5) & 1) == 0)
      {
        goto LABEL_87;
      }
    }

LABEL_35:
    v30 = v58;
    v29 = v59;
    v49 = a4;
    if ((v59 - v58) < 0x80 || (v56 - v55) < 0x80 || a4 > 0x63 || v13 < 0x79)
    {
      if (v58 != v59)
      {
        v31 = v10;
LABEL_39:
        v32 = v30;
        while ((sub_1016A7E84(a5, *v31, *v32) & 1) != 0)
        {
          if (++v32 == v29)
          {
            if (++v31 != v11)
            {
              goto LABEL_39;
            }

            goto LABEL_43;
          }
        }

        goto LABEL_87;
      }

LABEL_43:
      v33 = v55;
      v34 = v56;
      if (v55 != v56)
      {
        v35 = v10;
LABEL_45:
        v36 = v33;
        while ((sub_1016A7E84(a5, *v35, *v36) & 1) != 0)
        {
          if (++v36 == v34)
          {
            if (++v35 != v11)
            {
              goto LABEL_45;
            }

            goto LABEL_11;
          }
        }

        goto LABEL_87;
      }
    }

    else
    {
      v75 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v76 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v37 = v10;
      do
      {
        sub_1016932F4(&v75, *v37++ + 2);
      }

      while (v37 != v11);
      v50 = v75;
      v51 = v76;
      if (!sub_1016AA164(v50.f64, &v61, &v58, a4 + 1, a5) || (sub_1016AA164(v50.f64, &v61, &v55, a4 + 1, a5) & 1) == 0)
      {
        goto LABEL_87;
      }
    }
  }

LABEL_11:
  v18 = v67;
  v17 = v68;
  v19 = v68 - v67;
  if (v12 != v14)
  {
    if (v19 < 0x80 || (v65 - v64) < 0x80 || v49 > 0x63 || (v14 - v12) < 0x79)
    {
      if (v67 != v68)
      {
        v20 = v67;
LABEL_16:
        v21 = v12;
        while ((sub_1016A7E84(a5, *v20, *v21) & 1) != 0)
        {
          if (++v21 == v14)
          {
            if (++v20 != v17)
            {
              goto LABEL_16;
            }

            goto LABEL_20;
          }
        }

        goto LABEL_87;
      }

LABEL_20:
      v22 = v64;
      v23 = v65;
LABEL_21:
      if (v22 != v23)
      {
        v24 = v12;
        while ((sub_1016A7E84(a5, *v22, *v24) & 1) != 0)
        {
          if (++v24 == v14)
          {
            ++v22;
            goto LABEL_21;
          }
        }

        goto LABEL_87;
      }
    }

    else
    {
      v75 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v76 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v38 = v12;
      do
      {
        sub_1016932F4(&v75, *v38++ + 2);
      }

      while (v38 != v14);
      v50 = v75;
      v51 = v76;
      if (!sub_1016AA164(v50.f64, &v67, &__p, v49 + 1, a5) || (sub_1016AA164(v50.f64, &v64, &__p, v49 + 1, a5) & 1) == 0)
      {
        goto LABEL_87;
      }
    }
  }

  if (v19 < 0x80 || v49 > 0x63 || (v59 - v58) < 0x79)
  {
    if (v18 != v17)
    {
      v39 = v58;
      v40 = v59;
      if (v58 != v59)
      {
LABEL_66:
        v41 = v39;
        while ((sub_1016A7E84(a5, *v18, *v41) & 1) != 0)
        {
          if (++v41 == v40)
          {
            if (++v18 != v17)
            {
              goto LABEL_66;
            }

            goto LABEL_74;
          }
        }

        goto LABEL_87;
      }
    }
  }

  else if ((sub_1016AA164(&v72, &v67, &v58, v49 + 1, a5) & 1) == 0)
  {
    goto LABEL_87;
  }

LABEL_74:
  v43 = v64;
  v42 = v65;
  if ((v65 - v64) < 0x80 || v49 > 0x63 || (v56 - v55) < 0x79)
  {
    if (v64 == v65)
    {
      goto LABEL_85;
    }

    v44 = v55;
    v45 = v56;
    if (v55 == v56)
    {
      goto LABEL_85;
    }

LABEL_77:
    v46 = v44;
    while ((sub_1016A7E84(a5, *v43, *v46) & 1) != 0)
    {
      if (++v46 == v45)
      {
        if (++v43 != v42)
        {
          goto LABEL_77;
        }

        goto LABEL_85;
      }
    }

LABEL_87:
    v47 = 0;
    if (!v12)
    {
      goto LABEL_89;
    }

    goto LABEL_88;
  }

  if ((sub_1016AA164(v70, &v64, &v55, v49 + 1, a5) & 1) == 0)
  {
    goto LABEL_87;
  }

LABEL_85:
  v47 = 1;
  if (v12)
  {
LABEL_88:
    operator delete(v12);
  }

LABEL_89:
  if (v55)
  {
    operator delete(v55);
  }

  if (v58)
  {
    operator delete(v58);
  }

  if (v10)
  {
    operator delete(v10);
  }

  if (v64)
  {
    operator delete(v64);
  }

  if (v67)
  {
    operator delete(v67);
  }

  return v47;
}

void sub_1016AA0D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, void *a30)
{
  if (v30)
  {
    operator delete(v30);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a21)
  {
    operator delete(a21);
  }

  if (a24)
  {
    operator delete(a24);
  }

  if (a27)
  {
    operator delete(a27);
  }

  if (a30)
  {
    operator delete(a30);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016AA164(double *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  v8 = a1[1] + a1[3];
  v72 = *a1;
  v73 = *(a1 + 2);
  v9 = *(a1 + 1);
  *&v70[0] = v72;
  v71 = v9;
  v74 = v8 * 0.5;
  v70[1] = v8 * 0.5;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v61 = 0;
  v62 = 0;
  v63 = 0;
  v58 = 0;
  v59 = 0;
  v60 = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  __p = 0;
  v53 = 0;
  v54 = 0;
  sub_101693508(&v72, v70, a2, &v67, &v64, &v61);
  sub_101693508(&v72, v70, a3, &v58, &v55, &__p);
  v10 = v61;
  v11 = v62;
  v12 = __p;
  if (v61 == v62)
  {
    v49 = a4;
    v14 = v53;
  }

  else
  {
    v13 = v62 - v61;
    v14 = v53;
    if ((v62 - v61) < 0x80 || a4 > 0x63 || (v53 - __p) < 0x79)
    {
      if (__p != v53)
      {
        v15 = v61;
LABEL_5:
        v16 = v12;
        while ((sub_1016A7E84(a5, *v15, *v16) & 1) != 0)
        {
          if (++v16 == v14)
          {
            if (++v15 != v11)
            {
              goto LABEL_5;
            }

            goto LABEL_35;
          }
        }

        goto LABEL_87;
      }
    }

    else
    {
      v75 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v76 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v25 = v61;
      do
      {
        sub_1016932F4(&v75, *v25++ + 2);
      }

      while (v25 != v11);
      v26 = v75;
      v27 = v76;
      if (v12 != v14)
      {
        v28 = v12;
        do
        {
          sub_1016932F4(&v75, *v28++ + 2);
        }

        while (v28 != v14);
        v26 = v75;
        v27 = v76;
      }

      v50 = v26;
      v51 = v27;
      if ((sub_1016A9B24(&v50, &v61, &__p, a4 + 1, a5) & 1) == 0)
      {
        goto LABEL_87;
      }
    }

LABEL_35:
    v30 = v58;
    v29 = v59;
    v49 = a4;
    if ((v59 - v58) < 0x80 || (v56 - v55) < 0x80 || a4 > 0x63 || v13 < 0x79)
    {
      if (v58 != v59)
      {
        v31 = v10;
LABEL_39:
        v32 = v30;
        while ((sub_1016A7E84(a5, *v31, *v32) & 1) != 0)
        {
          if (++v32 == v29)
          {
            if (++v31 != v11)
            {
              goto LABEL_39;
            }

            goto LABEL_43;
          }
        }

        goto LABEL_87;
      }

LABEL_43:
      v33 = v55;
      v34 = v56;
      if (v55 != v56)
      {
        v35 = v10;
LABEL_45:
        v36 = v33;
        while ((sub_1016A7E84(a5, *v35, *v36) & 1) != 0)
        {
          if (++v36 == v34)
          {
            if (++v35 != v11)
            {
              goto LABEL_45;
            }

            goto LABEL_11;
          }
        }

        goto LABEL_87;
      }
    }

    else
    {
      v75 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v76 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v37 = v10;
      do
      {
        sub_1016932F4(&v75, *v37++ + 2);
      }

      while (v37 != v11);
      v50 = v75;
      v51 = v76;
      if (!sub_1016A9B24(&v50, &v61, &v58, a4 + 1, a5) || (sub_1016A9B24(&v50, &v61, &v55, a4 + 1, a5) & 1) == 0)
      {
        goto LABEL_87;
      }
    }
  }

LABEL_11:
  v18 = v67;
  v17 = v68;
  v19 = v68 - v67;
  if (v12 != v14)
  {
    if (v19 < 0x80 || (v65 - v64) < 0x80 || v49 > 0x63 || (v14 - v12) < 0x79)
    {
      if (v67 != v68)
      {
        v20 = v67;
LABEL_16:
        v21 = v12;
        while ((sub_1016A7E84(a5, *v20, *v21) & 1) != 0)
        {
          if (++v21 == v14)
          {
            if (++v20 != v17)
            {
              goto LABEL_16;
            }

            goto LABEL_20;
          }
        }

        goto LABEL_87;
      }

LABEL_20:
      v22 = v64;
      v23 = v65;
LABEL_21:
      if (v22 != v23)
      {
        v24 = v12;
        while ((sub_1016A7E84(a5, *v22, *v24) & 1) != 0)
        {
          if (++v24 == v14)
          {
            ++v22;
            goto LABEL_21;
          }
        }

        goto LABEL_87;
      }
    }

    else
    {
      v75 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v76 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v38 = v12;
      do
      {
        sub_1016932F4(&v75, *v38++ + 2);
      }

      while (v38 != v14);
      v50 = v75;
      v51 = v76;
      if (!sub_1016A9B24(&v50, &v67, &__p, v49 + 1, a5) || (sub_1016A9B24(&v50, &v64, &__p, v49 + 1, a5) & 1) == 0)
      {
        goto LABEL_87;
      }
    }
  }

  if (v19 < 0x80 || v49 > 0x63 || (v59 - v58) < 0x79)
  {
    if (v18 != v17)
    {
      v39 = v58;
      v40 = v59;
      if (v58 != v59)
      {
LABEL_66:
        v41 = v39;
        while ((sub_1016A7E84(a5, *v18, *v41) & 1) != 0)
        {
          if (++v41 == v40)
          {
            if (++v18 != v17)
            {
              goto LABEL_66;
            }

            goto LABEL_74;
          }
        }

        goto LABEL_87;
      }
    }
  }

  else if ((sub_1016A9B24(&v72, &v67, &v58, v49 + 1, a5) & 1) == 0)
  {
    goto LABEL_87;
  }

LABEL_74:
  v43 = v64;
  v42 = v65;
  if ((v65 - v64) < 0x80 || v49 > 0x63 || (v56 - v55) < 0x79)
  {
    if (v64 == v65)
    {
      goto LABEL_85;
    }

    v44 = v55;
    v45 = v56;
    if (v55 == v56)
    {
      goto LABEL_85;
    }

LABEL_77:
    v46 = v44;
    while ((sub_1016A7E84(a5, *v43, *v46) & 1) != 0)
    {
      if (++v46 == v45)
      {
        if (++v43 != v42)
        {
          goto LABEL_77;
        }

        goto LABEL_85;
      }
    }

LABEL_87:
    v47 = 0;
    if (!v12)
    {
      goto LABEL_89;
    }

    goto LABEL_88;
  }

  if ((sub_1016A9B24(v70, &v64, &v55, v49 + 1, a5) & 1) == 0)
  {
    goto LABEL_87;
  }

LABEL_85:
  v47 = 1;
  if (v12)
  {
LABEL_88:
    operator delete(v12);
  }

LABEL_89:
  if (v55)
  {
    operator delete(v55);
  }

  if (v58)
  {
    operator delete(v58);
  }

  if (v10)
  {
    operator delete(v10);
  }

  if (v64)
  {
    operator delete(v64);
  }

  if (v67)
  {
    operator delete(v67);
  }

  return v47;
}

void sub_1016AA71C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, void *a30)
{
  if (v30)
  {
    operator delete(v30);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a21)
  {
    operator delete(a21);
  }

  if (a24)
  {
    operator delete(a24);
  }

  if (a27)
  {
    operator delete(a27);
  }

  if (a30)
  {
    operator delete(a30);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016AA7B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(a2 + 80);
  v6 = *(a2 + 136);
  if (vabdd_f64(v5, v6) >= 50.0)
  {
    v11 = v5 < v6;
  }

  else
  {
    v7 = *(a2 + 72);
    if (v7 == 0.0)
    {
      __assert_rtn("apply", "segment_ratio.hpp", 56, "lhs.denominator() != Type(0)");
    }

    v8 = *(a2 + 128);
    if (v8 == 0.0)
    {
      __assert_rtn("apply", "segment_ratio.hpp", 57, "rhs.denominator() != Type(0)");
    }

    v9 = *(a2 + 64) / v7;
    v10 = *(a2 + 120) / v8;
    if (v9 == v10)
    {
      v11 = 0;
    }

    else if ((*&v9 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && (*&v10 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v12 = fabs(v9);
      v13 = fabs(v10);
      v14 = vabdd_f64(v9, v10);
      if (v12 < v13)
      {
        v12 = v13;
      }

      if (v12 < 1.0)
      {
        v12 = 1.0;
      }

      v11 = v14 > v12 * 2.22044605e-16;
    }

    else
    {
      v11 = 1;
    }

    if (v9 >= v10)
    {
      v11 = 0;
    }
  }

  *(a1 + 16) = 6;
  if (*a2 <= v11)
  {
    __assert_rtn("assign_point", "get_turn_info.hpp", 164, "index < info.count");
  }

  *a1 = *(a2 + 16 * v11 + 8);
  v15 = a2 + 56 * v11;
  v16 = *(v15 + 40);
  *(a1 + 104) = *(v15 + 56);
  *(a1 + 88) = v16;
  v17 = *(v15 + 64);
  *(a1 + 184) = *(v15 + 80);
  *(a1 + 168) = v17;
  v18 = *(a3 + 16);
  v19 = *(v18 + 24);
  v20 = sub_1016989B0(v18);
  v21 = sub_1016989B0(*(a3 + 8));
  v22 = sub_10169A37C(v19, v20, v21);
  v23 = *(a3 + 8);
  v24 = *(v23 + 16);
  v25 = *(v23 + 24);
  v26 = sub_1016989B0(v23);
  v27 = sub_10169A37C(v24, v25, v26);
  v29 = *(a3 + 8);
  v28 = *(a3 + 16);
  v30 = *(v29 + 16);
  v31 = *(v29 + 24);
  v32 = sub_1016989B0(v28);
  result = sub_10169A37C(v30, v31, v32);
  if (v22 || v27 != result)
  {
    if (result * v27 == -1)
    {
      v35 = v27 == -1;
    }

    else
    {
      v35 = v22 == -1;
    }

    if (v35)
    {
      v36 = 2;
    }

    else
    {
      v36 = 1;
    }

    *(a1 + 40) = v36;
    if (v35)
    {
      v34 = 1;
    }

    else
    {
      v34 = 2;
    }
  }

  else
  {
    v34 = 4;
    *(a1 + 40) = 4;
  }

  *(a1 + 120) = v34;
  return result;
}

__n128 sub_1016AAA04(void *a1, uint64_t a2)
{
  v4 = a1[1];
  v5 = a1[2];
  if (v5 == v4)
  {
    v6 = 0;
  }

  else
  {
    v6 = 20 * ((v5 - v4) >> 3) - 1;
  }

  v7 = a1[4];
  v8 = a1[5] + v7;
  if (v6 == v8)
  {
    if (v7 < 0x14)
    {
      v9 = a1[3];
      v10 = v9 - *a1;
      if (v5 - v4 < v10)
      {
        operator new();
      }

      v11 = v10 >> 2;
      if (v9 == *a1)
      {
        v12 = 1;
      }

      else
      {
        v12 = v11;
      }

      sub_100EF4E80(v12);
    }

    a1[4] = v7 - 20;
    v23 = *v4;
    a1[1] = v4 + 8;
    sub_1010F098C(a1, &v23);
    v4 = a1[1];
    v8 = a1[5] + a1[4];
  }

  v13 = *&v4[8 * (v8 / 0x14)] + 200 * (v8 % 0x14);
  *v13 = *a2;
  v14 = *(a2 + 16);
  v15 = *(a2 + 32);
  v16 = *(a2 + 64);
  *(v13 + 48) = *(a2 + 48);
  *(v13 + 64) = v16;
  *(v13 + 16) = v14;
  *(v13 + 32) = v15;
  v17 = *(a2 + 80);
  v18 = *(a2 + 96);
  v19 = *(a2 + 128);
  *(v13 + 112) = *(a2 + 112);
  *(v13 + 128) = v19;
  *(v13 + 80) = v17;
  *(v13 + 96) = v18;
  result = *(a2 + 144);
  v21 = *(a2 + 160);
  v22 = *(a2 + 176);
  *(v13 + 192) = *(a2 + 192);
  *(v13 + 160) = v21;
  *(v13 + 176) = v22;
  *(v13 + 144) = result;
  ++a1[5];
  return result;
}

void sub_1016AAEB0(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v1)
  {
    operator delete(v1);
  }

  _Unwind_Resume(a1);
}

int8x16_t sub_1016AAEDC(uint64_t a1, int8x16_t *a2)
{
  *(a1 + 24) = 0;
  *(a1 + 32) = 0;
  *(a1 + 40) = 0;
  *a1 = &off_101F60450;
  *(a1 + 8) = off_101F60480;
  *(a1 + 16) = off_101F604A8;
  *(a1 + 48) = a2[1].i32[0];
  result = vextq_s8(*a2, *a2, 8uLL);
  *(a1 + 32) = result;
  return result;
}

uint64_t sub_1016AAF58(uint64_t a1)
{
  *(a1 + 16) = &off_101E25ED0;
  sub_100102904((a1 + 24));
  std::exception::~exception((a1 + 8));
  return a1;
}

void sub_1016AB170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100102904(&a9);
  sub_100102904(&a10);
  (*(*v10 + 24))(v10);
  _Unwind_Resume(a1);
}

void sub_1016AB1DC(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x38uLL);
  sub_1016AB490(exception, a1);
}

void sub_1016AB238(uint64_t a1)
{
  *(a1 + 16) = &off_101E25ED0;
  sub_100102904((a1 + 24));
  std::exception::~exception((a1 + 8));

  operator delete();
}

void sub_1016AB2AC(uint64_t a1)
{
  *(a1 + 8) = &off_101E25ED0;
  sub_100102904((a1 + 16));

  std::exception::~exception(a1);
}

void sub_1016AB308(uint64_t a1)
{
  *(a1 + 8) = &off_101E25ED0;
  sub_100102904((a1 + 16));
  std::exception::~exception(a1);

  operator delete();
}

void sub_1016AB38C(void *a1)
{
  *a1 = &off_101E25ED0;
  v1 = (a1 - 1);
  sub_100102904(a1 + 1);

  std::exception::~exception(v1);
}

void sub_1016AB3E4(void *a1)
{
  *a1 = &off_101E25ED0;
  v1 = (a1 - 1);
  sub_100102904(a1 + 1);
  std::exception::~exception(v1);

  operator delete();
}

void sub_1016AB458(std::exception *a1)
{
  std::exception::~exception(a1);

  operator delete();
}

uint64_t sub_1016AB490(uint64_t a1, uint64_t a2)
{
  *a1 = &off_101E25E78;
  *(a1 + 8) = &off_101F604C8;
  v4 = *(a2 + 24);
  *(a1 + 16) = &off_101E25ED0;
  *(a1 + 24) = v4;
  if (v4)
  {
    (*(*v4 + 24))(v4);
  }

  v5 = *(a2 + 32);
  *(a1 + 48) = *(a2 + 48);
  *(a1 + 32) = v5;
  *a1 = &off_101F60450;
  *(a1 + 8) = off_101F60480;
  *(a1 + 16) = off_101F604A8;
  return a1;
}

uint64_t sub_1016AB5C0(uint64_t a1)
{
  v2 = *(a1 + 8);
  v3 = *(a1 + 16);
  *(a1 + 40) = 0;
  v4 = v3 - v2;
  if (v4 >= 3)
  {
    do
    {
      operator delete(*v2);
      v3 = *(a1 + 16);
      v2 = (*(a1 + 8) + 8);
      *(a1 + 8) = v2;
      v4 = v3 - v2;
    }

    while (v4 > 2);
  }

  if (v4 == 1)
  {
    v5 = 10;
    goto LABEL_7;
  }

  if (v4 == 2)
  {
    v5 = 20;
LABEL_7:
    *(a1 + 32) = v5;
  }

  if (v2 != v3)
  {
    do
    {
      v6 = *v2++;
      operator delete(v6);
    }

    while (v2 != v3);
    v8 = *(a1 + 8);
    v7 = *(a1 + 16);
    if (v7 != v8)
    {
      *(a1 + 16) = v7 + ((v8 - v7 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void sub_1016AB68C(double **a1, uint64_t *a2, uint64_t a3)
{
  v9 = *a1;
  v10 = a1[1];
  if (v10 != *a1)
  {
    memset(&v57[6], 255, 24);
    v11 = 0.0;
    if ((v10 - *a1) >= 0x40)
    {
      v12 = v9 + 2;
      if (v9 + 2 != v10)
      {
        v13 = 0;
        v4 = 1.0;
        do
        {
          v14 = *(v12 - 2);
          v15 = *v12;
          if (v14 != *v12)
          {
            if ((*&v14 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_10;
            }

            v17 = fabs(v14);
            v18 = fabs(v15);
            v19 = vabdd_f64(v14, v15);
            if (v17 >= v18)
            {
              v20 = v17;
            }

            else
            {
              v20 = v18;
            }

            if (v20 < 1.0)
            {
              v20 = 1.0;
            }

            if (v19 > v20 * 2.22044605e-16)
            {
LABEL_10:
              v3 = sub_101686964(v12 - 2, v12);
              v11 = v11 + v3;
              v13 += sub_101686BB8(v12 - 2, v12);
            }
          }

          v12 += 2;
        }

        while (v12 != v10);
        if (v13)
        {
          v21 = ((v13 >> 1) + 1);
          v22 = fabs(v11);
          v23 = -v22;
          v24 = -(v22 - v21 * 6.28318531);
          v25 = -(v23 + v21 * 6.28318531);
          if (v11 <= 0.0)
          {
            v11 = v24;
          }

          else
          {
            v11 = v25;
          }
        }
      }
    }

    v26 = *a1;
    v27 = a1[1];
    if (*a1 != v27)
    {
      v4 = *v26;
      v3 = v26[1];
    }

    v28 = v26 != v27;
    v29 = sub_1016ABCD4(a3, a2);
    v31 = v29 + 16;
    v30 = v29[16];
    *(v29 + 56) = v28;
    *(v29 + 8) = v4;
    *(v29 + 9) = v3;
    *(v29 + 10) = v11;
    *(v29 + 44) = 0;
    *(v29 + 90) = *v57;
    *(v29 + 13) = *&v57[14];
    v29[15] = 0xBFF0000000000000;
    if (v30)
    {
      v29[17] = v30;
      operator delete(v30);
    }

    *v31 = 0;
    v31[1] = 0;
    v31[2] = 0;
  }

  v33 = a1[3];
  for (i = a1[4]; v33 != i; v33 += 3)
  {
    ++a2[2];
    v34 = *v33;
    v35 = v33[1];
    if (v35 != *v33)
    {
      v36 = 0.0;
      memset(&v57[6], 255, 24);
      if ((v35 - *v33) >= 0x40)
      {
        v37 = v34 + 2;
        if (v34 + 2 != v35)
        {
          v38 = 0;
          do
          {
            v39 = *(v37 - 2);
            v40 = *v37;
            if (v39 != *v37)
            {
              if ((*&v39 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (*&v40 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                goto LABEL_39;
              }

              v42 = fabs(v39);
              v43 = fabs(v40);
              v44 = vabdd_f64(v39, v40);
              if (v42 >= v43)
              {
                v45 = v42;
              }

              else
              {
                v45 = v43;
              }

              if (v45 < 1.0)
              {
                v45 = 1.0;
              }

              if (v44 > v45 * 2.22044605e-16)
              {
LABEL_39:
                v36 = v36 + sub_101686964(v37 - 2, v37);
                v38 += sub_101686BB8(v37 - 2, v37);
              }
            }

            v37 += 2;
          }

          while (v37 != v35);
          if (v38)
          {
            v46 = (v38 >> 1) + 1;
            v47 = fabs(v36);
            v48 = -v47;
            v49 = -(v47 - v46 * 6.28318531);
            if (v36 <= 0.0)
            {
              v36 = v49;
            }

            else
            {
              v36 = -(v48 + v46 * 6.28318531);
            }
          }
        }
      }

      v50 = *v33;
      v51 = v33[1];
      if (*v33 != v51)
      {
        v5 = *v50;
        v6 = *(v50 + 1);
      }

      v52 = v50 != v51;
      v53 = sub_1016ABCD4(a3, a2);
      v55 = v53 + 16;
      v54 = v53[16];
      *(v53 + 56) = v52;
      v53[8] = v5;
      v53[9] = v6;
      *(v53 + 10) = v36;
      *(v53 + 44) = 0;
      *(v53 + 90) = *v57;
      *(v53 + 13) = *&v57[14];
      v53[15] = 0xBFF0000000000000;
      if (v54)
      {
        v53[17] = v54;
        operator delete(v54);
      }

      *v55 = 0;
      v55[1] = 0;
      v55[2] = 0;
      i = a1[4];
    }
  }
}

uint64_t sub_1016ABA48(double *a1, double **a2, uint64_t a3)
{
  result = sub_10169DA48(a1, a3);
  if (!result)
  {
    v6 = a2[1];
    v7 = a2[3];
    v8 = a2[4];
    if (v7 == v8)
    {
      v18 = 0;
      v13 = *a2;
    }

    else
    {
      v9 = a2[3];
      do
      {
        v10 = *v9;
        v11 = *(v9 + 1);
        v9 += 3;
      }

      while (v10 == v11 && v9 != v8);
      v13 = *a2;
      v14 = v7;
      do
      {
        v15 = *v14;
        v16 = *(v14 + 1);
        v14 += 3;
      }

      while (v15 == v16 && v14 != v8);
      while (1)
      {
        v18 = *v7;
        if (*v7 != *(v7 + 1))
        {
          break;
        }

        v7 += 3;
        if (v7 == v8)
        {
          v18 = 0;
          break;
        }
      }
    }

    if (v13 != v6 || v7 != v8)
    {
      while (1)
      {
        if (v13 == v6)
        {
          if (v7 == v8)
          {
            __assert_rtn("increment", "flatten_iterator.hpp", 192, "m_outer_it != m_outer_end");
          }

          v20 = *(v7 + 1);
          if (v18 == v20)
          {
            __assert_rtn("increment", "flatten_iterator.hpp", 193, "m_inner_it != AccessInnerEnd::apply(*m_outer_it)");
          }

          v18 += 2;
          if (v18 == v20)
          {
            while (1)
            {
              v7 += 3;
              if (v7 == v8)
              {
                break;
              }

              if (*v7 != *(v7 + 1))
              {
                v18 = *v7;
                break;
              }
            }
          }
        }

        else
        {
          v13 += 2;
        }

        if (v13 == v6 && v7 == v8)
        {
          break;
        }

        v19 = v13;
        if (v13 == v6)
        {
          if (v7 == v8)
          {
            __assert_rtn("dereference", "flatten_iterator.hpp", 152, "m_outer_it != m_outer_end");
          }

          v19 = v18;
          if (v18 == *(v7 + 1))
          {
            __assert_rtn("dereference", "flatten_iterator.hpp", 153, "m_inner_it != AccessInnerEnd::apply(*m_outer_it)");
          }
        }

        result = sub_10169DA48(v19, a3);
        if (result)
        {
          return result;
        }
      }
    }

    return 0;
  }

  return result;
}

void sub_1016ABC20(void *a1)
{
  if (a1)
  {
    sub_1016ABC20(*a1);
    sub_1016ABC20(a1[1]);
    v2 = a1[16];
    if (v2)
    {
      a1[17] = v2;
      operator delete(v2);
    }

    operator delete(a1);
  }
}

void sub_1016ABC7C(unint64_t a1)
{
  if (a1 < 0xAAAAAAAAAAAAAABLL)
  {
    operator new();
  }

  sub_100013D10();
}

void *sub_1016ABCD4(uint64_t a1, uint64_t *a2)
{
  v2 = *(a1 + 8);
  if (!v2)
  {
LABEL_16:
    operator new();
  }

  v3 = *a2;
  v4 = a2[1];
  v5 = a2[2];
  while (1)
  {
    while (1)
    {
      v6 = v2;
      v7 = v2[4];
      if (v3 != v7)
      {
        if (v3 >= v7)
        {
          if (v7 >= v3)
          {
            return v6;
          }

          goto LABEL_15;
        }

        goto LABEL_12;
      }

      v8 = v6[5];
      if (v4 != v8)
      {
        break;
      }

      v9 = v6[6];
      if (v5 >= v9)
      {
        if (v9 >= v5)
        {
          return v6;
        }

        goto LABEL_15;
      }

LABEL_12:
      v2 = *v6;
      if (!*v6)
      {
        goto LABEL_16;
      }
    }

    if (v4 < v8)
    {
      goto LABEL_12;
    }

    if (v8 >= v4)
    {
      return v6;
    }

LABEL_15:
    v2 = v6[1];
    if (!v2)
    {
      goto LABEL_16;
    }
  }
}

void sub_1016ABE24(uint64_t a1, __int128 *a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (v4 >= v3)
  {
    v7 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
    v8 = v7 + 1;
    if (v7 + 1 > 0xAAAAAAAAAAAAAAALL)
    {
      sub_1000CE3D4();
    }

    v9 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
    if (2 * v9 > v8)
    {
      v8 = 2 * v9;
    }

    if (v9 >= 0x555555555555555)
    {
      v10 = 0xAAAAAAAAAAAAAAALL;
    }

    else
    {
      v10 = v8;
    }

    if (v10)
    {
      sub_1016ABC7C(v10);
    }

    v11 = 24 * v7;
    v12 = *a2;
    *(v11 + 16) = *(a2 + 2);
    *v11 = v12;
    v6 = 24 * v7 + 24;
    v13 = *(a1 + 8) - *a1;
    v14 = v11 - v13;
    memcpy((v11 - v13), *a1, v13);
    v15 = *a1;
    *a1 = v14;
    *(a1 + 8) = v6;
    *(a1 + 16) = 0;
    if (v15)
    {
      operator delete(v15);
    }
  }

  else
  {
    v5 = *a2;
    *(v4 + 16) = *(a2 + 2);
    *v4 = v5;
    v6 = v4 + 24;
  }

  *(a1 + 8) = v6;
}

void sub_1016ABF28(double *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  v6 = (*a1 + a1[2]) * 0.5;
  v7 = *(a1 + 1);
  v45 = *a1;
  v47 = *(&v7 + 1);
  v43[1] = *(&v45 + 1);
  v44 = v7;
  v46 = v6;
  v43[0] = v6;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  sub_1016AC840(&v45, v43, a2, &v40, &v37, &v34);
  v8 = v34;
  v9 = v35;
  if (v34 == v35)
  {
    goto LABEL_30;
  }

  v48 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  v49 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  v10 = v34;
  do
  {
    sub_1016932F4(&v48, (*v10++ + 5));
  }

  while (v10 != v9);
  v33[0] = v48;
  v33[1] = v49;
  v11 = v9 - v8;
  v12 = v8;
  if (a3 > 0x63 || (v12 = v8, v11 < 0x79))
  {
    do
    {
      v14 = v12 + 1;
      if (v12 + 1 == v9)
      {
        break;
      }

      v13 = v12 + 1;
      do
      {
        sub_1016AC300(a4, *v12, *v13++);
      }

      while (v13 != v9);
      ++v12;
    }

    while (v14 != v9);
  }

  else
  {
    sub_1016ACC0C(v33, &v34, a3 + 1, a4);
  }

  if (v11 >= 0x80 && a3 <= 0x63 && (v41 - v40) >= 0x79)
  {
    sub_1016AD608(v33, &v34, &v40, a3 + 1, a4);
    goto LABEL_22;
  }

  v15 = v40;
  v16 = v41;
  if (v40 != v41)
  {
    v17 = v8;
    do
    {
      v18 = v15;
      do
      {
        sub_1016AC300(a4, *v17, *v18++);
      }

      while (v18 != v16);
      ++v17;
    }

    while (v17 != v9);
  }

  if (v11 >= 0x80)
  {
LABEL_22:
    if (a3 <= 0x63 && (v38 - v37) >= 0x79)
    {
      sub_1016AD608(v33, &v34, &v37, a3 + 1, a4);
      goto LABEL_30;
    }
  }

  v19 = v37;
  v20 = v38;
  if (v37 != v38)
  {
    v21 = v8;
    do
    {
      v22 = v19;
      do
      {
        sub_1016AC300(a4, *v21, *v22++);
      }

      while (v22 != v20);
      ++v21;
    }

    while (v21 != v9);
  }

LABEL_30:
  v23 = v40;
  v24 = v41;
  if (a3 > 0x63 || (v41 - v40) < 0x79)
  {
    if (v40 != v41)
    {
      v25 = v40;
      do
      {
        v26 = v25 + 1;
        if (v25 + 1 == v24)
        {
          break;
        }

        v27 = v25 + 1;
        do
        {
          sub_1016AC300(a4, *v25, *v27++);
        }

        while (v27 != v24);
        ++v25;
      }

      while (v26 != v24);
    }
  }

  else
  {
    sub_1016ACC0C(&v45, &v40, a3 + 1, a4);
  }

  v28 = v37;
  v29 = v38;
  if (a3 > 0x63 || (v38 - v37) < 0x79)
  {
    if (v37 != v38)
    {
      v30 = v37;
      do
      {
        v31 = v30 + 1;
        if (v30 + 1 == v29)
        {
          break;
        }

        v32 = v30 + 1;
        do
        {
          sub_1016AC300(a4, *v30, *v32++);
        }

        while (v32 != v29);
        ++v30;
      }

      while (v31 != v29);
    }
  }

  else
  {
    sub_1016ACC0C(v43, &v37, a3 + 1, a4);
  }

  if (v8)
  {
    operator delete(v8);
  }

  if (v28)
  {
    operator delete(v28);
  }

  if (v23)
  {

    operator delete(v23);
  }
}

void sub_1016AC2AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20)
{
  if (v20)
  {
    operator delete(v20);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a20)
  {
    operator delete(a20);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016AC300(uint64_t a1, double *a2, double *a3)
{
  v6 = a2 + 4;
  v7 = a3 + 4;
  if (a2[4] < a3[4])
  {
    if ((*(a1 + 40) & 1) == 0)
    {
      v29 = a3[3];
      if (v29 <= 0.0)
      {
        return;
      }

      if (v29 != INFINITY)
      {
        v30 = 1.0;
        if (v29 >= 1.0)
        {
          v30 = a3[3];
        }

        if (v29 <= v30 * 2.22044605e-16)
        {
          return;
        }
      }

      v31 = a2[3];
      if (v31 >= 0.0)
      {
        return;
      }

      if ((*&v31 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v32 = fabs(v31);
        v33 = vabdd_f64(0.0, v31);
        if (v32 < 1.0)
        {
          v32 = 1.0;
        }

        if (v33 <= v32 * 2.22044605e-16)
        {
          return;
        }
      }
    }

    v8 = sub_1016ABCD4(*(a1 + 24), a2);
    v9 = v8[8];
    v10 = a3[5];
    v11 = a3[7];
    v12 = v9 > v11 || v9 < v10;
    if (!v12 || v11 - v10 >= 360.0)
    {
      goto LABEL_14;
    }

    v13 = vabdd_f64(v9, v10);
    v14 = 180.0;
    if (v13 != 180.0)
    {
      v15 = v9 - v10;
      if ((*&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_67;
      }

      v37 = fabs(v13 + -180.0);
      v14 = 180.0;
      if (v13 < 180.0)
      {
        v13 = 180.0;
      }

      if (v13 < 1.0)
      {
        v13 = 1.0;
      }

      if (v37 > v13 * 2.22044605e-16)
      {
LABEL_67:
        v14 = 180.0;
        if (v15 <= 180.0)
        {
          if (v15 >= -180.0)
          {
            goto LABEL_11;
          }

          v14 = fmod(v15 + -180.0, 360.0) + 180.0;
        }

        else
        {
          v15 = fmod(v15 + 180.0, 360.0) + -180.0;
          if (v15 != -180.0)
          {
            if ((*&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_11;
            }

            v38 = fabs(v15);
            v14 = 180.0;
            v39 = fabs(v15 + 180.0);
            if (v38 < 180.0)
            {
              v38 = 180.0;
            }

            if (v38 < 1.0)
            {
              v38 = 1.0;
            }

            if (v39 > v38 * 2.22044605e-16)
            {
LABEL_11:
              if (v15 < 0.0)
              {
                v15 = v15 + 360.0;
              }

              if (v10 + v15 > v11)
              {
                return;
              }

LABEL_14:
              v16 = v8[9];
              v17 = v16 < a3[6] || v16 > a3[8];
              if (v17 || !sub_1016ADC30((v8 + 7), a2, a3, *a1, *(a1 + 8), *(a1 + 16)) || *(v8 + 12) != -1 && *v7 >= v8[15])
              {
                return;
              }

              v18 = *a3;
              v8[14] = a3[2];
              *(v8 + 6) = v18;
              goto LABEL_42;
            }
          }
        }
      }
    }

    v15 = v14;
    goto LABEL_11;
  }

  if (*(a1 + 40))
  {
    goto LABEL_23;
  }

  v34 = a2[3];
  if (v34 > 0.0)
  {
    if (v34 == INFINITY)
    {
      goto LABEL_94;
    }

    v35 = 1.0;
    if (v34 >= 1.0)
    {
      v35 = a2[3];
    }

    if (v34 > v35 * 2.22044605e-16)
    {
LABEL_94:
      v36 = a3[3];
      if (v36 < 0.0)
      {
        if ((*&v36 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_23;
        }

        v43 = fabs(v36);
        v44 = vabdd_f64(0.0, v36);
        if (v43 < 1.0)
        {
          v43 = 1.0;
        }

        if (v44 > v43 * 2.22044605e-16)
        {
LABEL_23:
          v8 = sub_1016ABCD4(*(a1 + 24), a3);
          v19 = v8[8];
          v20 = a2[5];
          v21 = a2[7];
          v22 = v19 > v21 || v19 < v20;
          if (!v22 || v21 - v20 >= 360.0)
          {
            goto LABEL_34;
          }

          v23 = vabdd_f64(v19, v20);
          v24 = 180.0;
          if (v23 != 180.0)
          {
            v25 = v19 - v20;
            if ((*&v25 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_82;
            }

            v40 = fabs(v23 + -180.0);
            v24 = 180.0;
            if (v23 < 180.0)
            {
              v23 = 180.0;
            }

            if (v23 < 1.0)
            {
              v23 = 1.0;
            }

            if (v40 > v23 * 2.22044605e-16)
            {
LABEL_82:
              v24 = 180.0;
              if (v25 <= 180.0)
              {
                if (v25 >= -180.0)
                {
                  goto LABEL_31;
                }

                v24 = fmod(v25 + -180.0, 360.0) + 180.0;
              }

              else
              {
                v25 = fmod(v25 + 180.0, 360.0) + -180.0;
                if (v25 != -180.0)
                {
                  if ((*&v25 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    goto LABEL_31;
                  }

                  v41 = fabs(v25);
                  v24 = 180.0;
                  v42 = fabs(v25 + 180.0);
                  if (v41 < 180.0)
                  {
                    v41 = 180.0;
                  }

                  if (v41 < 1.0)
                  {
                    v41 = 1.0;
                  }

                  if (v42 > v41 * 2.22044605e-16)
                  {
LABEL_31:
                    if (v25 < 0.0)
                    {
                      v25 = v25 + 360.0;
                    }

                    if (v20 + v25 > v21)
                    {
                      return;
                    }

LABEL_34:
                    v26 = v8[9];
                    v27 = v26 < a2[6] || v26 > a2[8];
                    if (v27 || !sub_1016ADC30((v8 + 7), a3, a2, *a1, *(a1 + 8), *(a1 + 16)) || *(v8 + 12) != -1 && *v6 >= v8[15])
                    {
                      return;
                    }

                    v28 = *a2;
                    v8[14] = a2[2];
                    *(v8 + 6) = v28;
                    v7 = v6;
LABEL_42:
                    v8[15] = *v7;
                    return;
                  }
                }
              }
            }
          }

          v25 = v24;
          goto LABEL_31;
        }
      }
    }
  }
}

void sub_1016AC840(double *a1, double *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v6 = *a3;
  v7 = *(a3 + 8);
  if (*a3 != v7)
  {
    while (1)
    {
      v13 = *v6;
      v14 = *a1;
      v15 = a1[2];
      v16 = *(*v6 + 40);
      v17 = *(*v6 + 56);
      v18 = v17 - v16;
      if (v15 - *a1 < 360.0 && v18 < 360.0)
      {
        break;
      }

LABEL_12:
      if (a1[3] >= *(v13 + 48))
      {
        v24 = a1[1] <= *(v13 + 64);
        goto LABEL_15;
      }

LABEL_13:
      v24 = 0;
LABEL_15:
      v25 = *a2;
      v26 = a2[2];
      if (v26 - *a2 >= 360.0 || v18 >= 360.0)
      {
        goto LABEL_25;
      }

      v27 = vabdd_f64(v16, v25);
      v28 = 180.0;
      if (v27 == 180.0)
      {
        goto LABEL_18;
      }

      v29 = v16 - v25;
      if (COERCE__INT64(fabs(v16 - v25)) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v37 = fabs(v27 + -180.0);
        v28 = 180.0;
        if (v27 < 180.0)
        {
          v27 = 180.0;
        }

        if (v27 < 1.0)
        {
          v27 = 1.0;
        }

        if (v37 <= v27 * 2.22044605e-16)
        {
          goto LABEL_18;
        }
      }

      if (v29 <= 180.0)
      {
        if (v29 < -180.0)
        {
          v28 = fmod(v29 + -180.0, 360.0) + 180.0;
LABEL_18:
          v29 = v28;
        }
      }

      else
      {
        v29 = fmod(v29 + 180.0, 360.0) + -180.0;
        v28 = 180.0;
        if (v29 == -180.0)
        {
          goto LABEL_18;
        }

        if ((*&v29 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v38 = fabs(v29);
          v39 = fabs(v29 + 180.0);
          if (v38 < 180.0)
          {
            v38 = 180.0;
          }

          if (v38 < 1.0)
          {
            v38 = 1.0;
          }

          v34 = v39 > v38 * 2.22044605e-16;
          v28 = 180.0;
          if (!v34)
          {
            goto LABEL_18;
          }
        }
      }

      if (v29 < 0.0)
      {
        v29 = v29 + 360.0;
      }

      v30 = v25 + v29;
      v31 = v18 + v25 + v29 + -360.0;
      if (vabdd_f64(v31, v17) < 180.0)
      {
        v31 = v17;
      }

      if (v30 > v26 && v31 < v25)
      {
LABEL_27:
        v32 = a4;
        if (!v24)
        {
          goto LABEL_33;
        }

        goto LABEL_32;
      }

LABEL_25:
      if (a2[3] < *(v13 + 48) || a2[1] > *(v13 + 64))
      {
        goto LABEL_27;
      }

      if (v24)
      {
        v32 = a6;
      }

      else
      {
        v32 = a5;
      }

LABEL_32:
      sub_1016931F4(v32, v6);
      v7 = *(a3 + 8);
LABEL_33:
      if (++v6 == v7)
      {
        return;
      }
    }

    v19 = vabdd_f64(v16, v14);
    v20 = 180.0;
    if (v19 == 180.0)
    {
      goto LABEL_5;
    }

    v21 = v16 - v14;
    if (COERCE__INT64(fabs(v16 - v14)) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      v33 = fabs(v19 + -180.0);
      if (v19 < 180.0)
      {
        v19 = 180.0;
      }

      if (v19 < 1.0)
      {
        v19 = 1.0;
      }

      v34 = v33 > v19 * 2.22044605e-16;
      v20 = 180.0;
      if (!v34)
      {
        goto LABEL_5;
      }
    }

    if (v21 <= 180.0)
    {
      if (v21 < -180.0)
      {
        v20 = fmod(v21 + -180.0, 360.0) + 180.0;
LABEL_5:
        v21 = v20;
      }
    }

    else
    {
      v21 = fmod(v21 + 180.0, 360.0) + -180.0;
      v20 = 180.0;
      if (v21 == -180.0)
      {
        goto LABEL_5;
      }

      if ((*&v21 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v35 = fabs(v21);
        v36 = fabs(v21 + 180.0);
        if (v35 < 180.0)
        {
          v35 = 180.0;
        }

        if (v35 < 1.0)
        {
          v35 = 1.0;
        }

        v34 = v36 > v35 * 2.22044605e-16;
        v20 = 180.0;
        if (!v34)
        {
          goto LABEL_5;
        }
      }
    }

    if (v21 < 0.0)
    {
      v21 = v21 + 360.0;
    }

    v22 = v14 + v21;
    v23 = v18 + v14 + v21 + -360.0;
    if (vabdd_f64(v23, v17) < 180.0)
    {
      v23 = v17;
    }

    if (v22 > v15 && v23 < v14)
    {
      goto LABEL_13;
    }

    goto LABEL_12;
  }
}

void sub_1016ACC0C(double *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  v6 = (a1[1] + a1[3]) * 0.5;
  v47 = *(a1 + 2);
  v7 = *a1;
  v8 = *(a1 + 1);
  v44[0] = *a1;
  v45 = v8;
  v46 = v7;
  v48 = v6;
  v44[1] = v6;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_1016AC840(&v46, v44, a2, &v41, &v38, &v35);
  v9 = v35;
  v10 = v36;
  if (v35 == v36)
  {
    goto LABEL_30;
  }

  v49 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  v50 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  v11 = v35;
  do
  {
    sub_1016932F4(&v49, (*v11++ + 5));
  }

  while (v11 != v10);
  v34[0] = v49;
  v34[1] = v50;
  v12 = v10 - v9;
  v13 = v9;
  if (a3 > 0x63 || (v13 = v9, v12 < 0x79))
  {
    do
    {
      v15 = v13 + 1;
      if (v13 + 1 == v10)
      {
        break;
      }

      v14 = v13 + 1;
      do
      {
        sub_1016AC300(a4, *v13, *v14++);
      }

      while (v14 != v10);
      ++v13;
    }

    while (v15 != v10);
  }

  else
  {
    sub_1016ABF28(v34, &v35, a3 + 1, a4);
  }

  if (v12 >= 0x80 && a3 <= 0x63 && (v42 - v41) >= 0x79)
  {
    sub_1016ACFEC(v34, &v35, &v41, a3 + 1, a4);
    goto LABEL_22;
  }

  v16 = v41;
  v17 = v42;
  if (v41 != v42)
  {
    v18 = v9;
    do
    {
      v19 = v16;
      do
      {
        sub_1016AC300(a4, *v18, *v19++);
      }

      while (v19 != v17);
      ++v18;
    }

    while (v18 != v10);
  }

  if (v12 >= 0x80)
  {
LABEL_22:
    if (a3 <= 0x63 && (v39 - v38) >= 0x79)
    {
      sub_1016ACFEC(v34, &v35, &v38, a3 + 1, a4);
      goto LABEL_30;
    }
  }

  v20 = v38;
  v21 = v39;
  if (v38 != v39)
  {
    v22 = v9;
    do
    {
      v23 = v20;
      do
      {
        sub_1016AC300(a4, *v22, *v23++);
      }

      while (v23 != v21);
      ++v22;
    }

    while (v22 != v10);
  }

LABEL_30:
  v24 = v41;
  v25 = v42;
  if (a3 > 0x63 || (v42 - v41) < 0x79)
  {
    if (v41 != v42)
    {
      v26 = v41;
      do
      {
        v27 = v26 + 1;
        if (v26 + 1 == v25)
        {
          break;
        }

        v28 = v26 + 1;
        do
        {
          sub_1016AC300(a4, *v26, *v28++);
        }

        while (v28 != v25);
        ++v26;
      }

      while (v27 != v25);
    }
  }

  else
  {
    sub_1016ABF28(&v46, &v41, a3 + 1, a4);
  }

  v29 = v38;
  v30 = v39;
  if (a3 > 0x63 || (v39 - v38) < 0x79)
  {
    if (v38 != v39)
    {
      v31 = v38;
      do
      {
        v32 = v31 + 1;
        if (v31 + 1 == v30)
        {
          break;
        }

        v33 = v31 + 1;
        do
        {
          sub_1016AC300(a4, *v31, *v33++);
        }

        while (v33 != v30);
        ++v31;
      }

      while (v32 != v30);
    }
  }

  else
  {
    sub_1016ABF28(v44, &v38, a3 + 1, a4);
  }

  if (v9)
  {
    operator delete(v9);
  }

  if (v29)
  {
    operator delete(v29);
  }

  if (v24)
  {

    operator delete(v24);
  }
}

void sub_1016ACF98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20)
{
  if (v20)
  {
    operator delete(v20);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a20)
  {
    operator delete(a20);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016ACFEC(double *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  v8 = (*a1 + a1[2]) * 0.5;
  v9 = *(a1 + 1);
  v71 = *a1;
  v73 = *(&v9 + 1);
  v69[1] = *(&v71 + 1);
  v70 = v9;
  v72 = v8;
  v69[0] = v8;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  __p = 0;
  v52 = 0;
  v53 = 0;
  sub_1016AC840(&v71, v69, a2, &v66, &v63, &v60);
  sub_1016AC840(&v71, v69, a3, &v57, &v54, &__p);
  v10 = v60;
  v11 = v61;
  v12 = __p;
  v48 = v60;
  if (v60 == v61)
  {
    v14 = v52;
  }

  else
  {
    v13 = v61 - v60;
    v14 = v52;
    if ((v61 - v60) < 0x80 || a4 > 0x63 || (v52 - __p) < 0x79)
    {
      if (__p != v52)
      {
        v15 = v60;
        do
        {
          v16 = v12;
          do
          {
            sub_1016AC300(a5, *v15, *v16++);
          }

          while (v16 != v14);
          ++v15;
        }

        while (v15 != v11);
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v17 = v60;
      do
      {
        sub_1016932F4(&v74, (*v10++ + 5));
      }

      while (v10 != v11);
      v18 = v74;
      v19 = v75;
      if (v12 != v14)
      {
        v20 = v12;
        do
        {
          sub_1016932F4(&v74, (*v20++ + 5));
        }

        while (v20 != v14);
        v18 = v74;
        v19 = v75;
      }

      v49 = v18;
      v50 = v19;
      sub_1016AD608(v49.f64, &v60, &__p, a4 + 1, a5);
      v10 = v17;
    }

    v22 = v57;
    v21 = v58;
    if ((v58 - v57) < 0x80 || (v55 - v54) < 0x80 || a4 > 0x63 || v13 < 0x79)
    {
      if (v57 != v58)
      {
        v23 = v10;
        do
        {
          v24 = v22;
          do
          {
            sub_1016AC300(a5, *v23, *v24++);
          }

          while (v24 != v21);
          ++v23;
        }

        while (v23 != v11);
      }

      v25 = v54;
      v26 = v55;
      if (v54 != v55)
      {
        v27 = v10;
        do
        {
          v28 = v25;
          do
          {
            sub_1016AC300(a5, *v27, *v28++);
          }

          while (v28 != v26);
          ++v27;
        }

        while (v27 != v11);
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      do
      {
        sub_1016932F4(&v74, (*v10++ + 5));
      }

      while (v10 != v11);
      v49 = v74;
      v50 = v75;
      sub_1016AD608(v49.f64, &v60, &v57, a4 + 1, a5);
      sub_1016AD608(v49.f64, &v60, &v54, a4 + 1, a5);
    }
  }

  v29 = v66;
  v30 = v67;
  v31 = v67 - v66;
  if (v12 != v14)
  {
    if (v31 < 0x80 || (v64 - v63) < 0x80 || a4 > 0x63 || (v14 - v12) < 0x79)
    {
      if (v66 != v67)
      {
        v32 = v66;
        do
        {
          v33 = v12;
          do
          {
            sub_1016AC300(a5, *v32, *v33++);
          }

          while (v33 != v14);
          ++v32;
        }

        while (v32 != v30);
      }

      v34 = v63;
      v35 = v64;
      while (v34 != v35)
      {
        v36 = v12;
        do
        {
          sub_1016AC300(a5, *v34, *v36++);
        }

        while (v36 != v14);
        ++v34;
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v37 = v12;
      do
      {
        sub_1016932F4(&v74, (*v37++ + 5));
      }

      while (v37 != v14);
      v49 = v74;
      v50 = v75;
      sub_1016AD608(v49.f64, &v66, &__p, a4 + 1, a5);
      sub_1016AD608(v49.f64, &v63, &__p, a4 + 1, a5);
    }
  }

  if (v31 < 0x80 || a4 > 0x63 || (v58 - v57) < 0x79)
  {
    if (v29 != v30)
    {
      v38 = v57;
      v39 = v58;
      if (v57 != v58)
      {
        v40 = v29;
        do
        {
          v41 = v38;
          do
          {
            sub_1016AC300(a5, *v40, *v41++);
          }

          while (v41 != v39);
          ++v40;
        }

        while (v40 != v30);
      }
    }
  }

  else
  {
    sub_1016AD608(&v71, &v66, &v57, a4 + 1, a5);
  }

  v42 = v63;
  v43 = v64;
  if ((v64 - v63) < 0x80 || a4 > 0x63 || (v55 - v54) < 0x79)
  {
    if (v63 != v64)
    {
      v44 = v54;
      v45 = v55;
      if (v54 != v55)
      {
        v46 = v63;
        do
        {
          v47 = v44;
          do
          {
            sub_1016AC300(a5, *v46, *v47++);
          }

          while (v47 != v45);
          ++v46;
        }

        while (v46 != v43);
      }
    }
  }

  else
  {
    sub_1016AD608(v69, &v63, &v54, a4 + 1, a5);
  }

  if (v12)
  {
    operator delete(v12);
  }

  if (v54)
  {
    operator delete(v54);
  }

  if (v57)
  {
    operator delete(v57);
  }

  if (v48)
  {
    operator delete(v48);
  }

  if (v42)
  {
    operator delete(v42);
  }

  if (v29)
  {

    operator delete(v29);
  }
}

void sub_1016AD574(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, void *a30)
{
  if (v30)
  {
    operator delete(v30);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a21)
  {
    operator delete(a21);
  }

  if (a24)
  {
    operator delete(a24);
  }

  if (a27)
  {
    operator delete(a27);
  }

  if (a30)
  {
    operator delete(a30);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016AD608(double *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  v8 = a1[1] + a1[3];
  v71 = *a1;
  v72 = *(a1 + 2);
  v9 = *(a1 + 1);
  *&v69[0] = v71;
  v70 = v9;
  v73 = v8 * 0.5;
  v69[1] = v8 * 0.5;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  __p = 0;
  v52 = 0;
  v53 = 0;
  sub_1016AC840(&v71, v69, a2, &v66, &v63, &v60);
  sub_1016AC840(&v71, v69, a3, &v57, &v54, &__p);
  v10 = v60;
  v11 = v61;
  v12 = __p;
  v48 = v60;
  if (v60 == v61)
  {
    v14 = v52;
  }

  else
  {
    v13 = v61 - v60;
    v14 = v52;
    if ((v61 - v60) < 0x80 || a4 > 0x63 || (v52 - __p) < 0x79)
    {
      if (__p != v52)
      {
        v15 = v60;
        do
        {
          v16 = v12;
          do
          {
            sub_1016AC300(a5, *v15, *v16++);
          }

          while (v16 != v14);
          ++v15;
        }

        while (v15 != v11);
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v17 = v60;
      do
      {
        sub_1016932F4(&v74, (*v10++ + 5));
      }

      while (v10 != v11);
      v18 = v74;
      v19 = v75;
      if (v12 != v14)
      {
        v20 = v12;
        do
        {
          sub_1016932F4(&v74, (*v20++ + 5));
        }

        while (v20 != v14);
        v18 = v74;
        v19 = v75;
      }

      v49 = v18;
      v50 = v19;
      sub_1016ACFEC(&v49, &v60, &__p, a4 + 1, a5);
      v10 = v17;
    }

    v22 = v57;
    v21 = v58;
    if ((v58 - v57) < 0x80 || (v55 - v54) < 0x80 || a4 > 0x63 || v13 < 0x79)
    {
      if (v57 != v58)
      {
        v23 = v10;
        do
        {
          v24 = v22;
          do
          {
            sub_1016AC300(a5, *v23, *v24++);
          }

          while (v24 != v21);
          ++v23;
        }

        while (v23 != v11);
      }

      v25 = v54;
      v26 = v55;
      if (v54 != v55)
      {
        v27 = v10;
        do
        {
          v28 = v25;
          do
          {
            sub_1016AC300(a5, *v27, *v28++);
          }

          while (v28 != v26);
          ++v27;
        }

        while (v27 != v11);
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      do
      {
        sub_1016932F4(&v74, (*v10++ + 5));
      }

      while (v10 != v11);
      v49 = v74;
      v50 = v75;
      sub_1016ACFEC(&v49, &v60, &v57, a4 + 1, a5);
      sub_1016ACFEC(&v49, &v60, &v54, a4 + 1, a5);
    }
  }

  v29 = v66;
  v30 = v67;
  v31 = v67 - v66;
  if (v12 != v14)
  {
    if (v31 < 0x80 || (v64 - v63) < 0x80 || a4 > 0x63 || (v14 - v12) < 0x79)
    {
      if (v66 != v67)
      {
        v32 = v66;
        do
        {
          v33 = v12;
          do
          {
            sub_1016AC300(a5, *v32, *v33++);
          }

          while (v33 != v14);
          ++v32;
        }

        while (v32 != v30);
      }

      v34 = v63;
      v35 = v64;
      while (v34 != v35)
      {
        v36 = v12;
        do
        {
          sub_1016AC300(a5, *v34, *v36++);
        }

        while (v36 != v14);
        ++v34;
      }
    }

    else
    {
      v74 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v75 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v37 = v12;
      do
      {
        sub_1016932F4(&v74, (*v37++ + 5));
      }

      while (v37 != v14);
      v49 = v74;
      v50 = v75;
      sub_1016ACFEC(&v49, &v66, &__p, a4 + 1, a5);
      sub_1016ACFEC(&v49, &v63, &__p, a4 + 1, a5);
    }
  }

  if (v31 < 0x80 || a4 > 0x63 || (v58 - v57) < 0x79)
  {
    if (v29 != v30)
    {
      v38 = v57;
      v39 = v58;
      if (v57 != v58)
      {
        v40 = v29;
        do
        {
          v41 = v38;
          do
          {
            sub_1016AC300(a5, *v40, *v41++);
          }

          while (v41 != v39);
          ++v40;
        }

        while (v40 != v30);
      }
    }
  }

  else
  {
    sub_1016ACFEC(&v71, &v66, &v57, a4 + 1, a5);
  }

  v42 = v63;
  v43 = v64;
  if ((v64 - v63) < 0x80 || a4 > 0x63 || (v55 - v54) < 0x79)
  {
    if (v63 != v64)
    {
      v44 = v54;
      v45 = v55;
      if (v54 != v55)
      {
        v46 = v63;
        do
        {
          v47 = v44;
          do
          {
            sub_1016AC300(a5, *v46, *v47++);
          }

          while (v47 != v45);
          ++v46;
        }

        while (v46 != v43);
      }
    }
  }

  else
  {
    sub_1016ACFEC(v69, &v63, &v54, a4 + 1, a5);
  }

  if (v12)
  {
    operator delete(v12);
  }

  if (v54)
  {
    operator delete(v54);
  }

  if (v57)
  {
    operator delete(v57);
  }

  if (v48)
  {
    operator delete(v48);
  }

  if (v42)
  {
    operator delete(v42);
  }

  if (v29)
  {

    operator delete(v29);
  }
}

void sub_1016ADB9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, void *a30)
{
  if (v30)
  {
    operator delete(v30);
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (a21)
  {
    operator delete(a21);
  }

  if (a24)
  {
    operator delete(a24);
  }

  if (a27)
  {
    operator delete(a27);
  }

  if (a30)
  {
    operator delete(a30);
  }

  _Unwind_Resume(exception_object);
}

BOOL sub_1016ADC30(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, void *a6)
{
  v6 = a5;
  v7 = a4;
  v10 = *a2;
  if (*a2 == 2)
  {
    v26 = a2[1];
    v27 = a6[5];
    if (v27 < v26)
    {
      goto LABEL_77;
    }

    v28 = a6[4];
    v30 = a6[1];
    v29 = a6[2];
    v31 = (v30 + 8 * (v28 / 0xAA));
    if (v29 == v30)
    {
      v32 = 0;
    }

    else
    {
      v32 = *v31 + 24 * (v28 % 0xAA);
    }

    v54 = (v30 + 8 * (v28 / 0xAA));
    v55 = v32;
    sub_10164FCF4(&v54, v26);
    v38 = *a3;
    if (*a3 == 2)
    {
      v47 = a3[1];
      if (v27 >= v47)
      {
        v48 = v55;
        if (v29 == v30)
        {
          v49 = 0;
        }

        else
        {
          v49 = *v31 + 24 * (v28 % 0xAA);
        }

        v54 = (v30 + 8 * (v28 / 0xAA));
        v55 = v49;
        sub_10164FCF4(&v54, v47);
        v42 = v55;
        v24 = (a1 + 8);
        v25 = v48;
        return sub_1016AE070(v24, v25, v42) >= 0;
      }

      goto LABEL_77;
    }

    if (v38 == 1)
    {
      v44 = a3[2];
      if (v44 >= -1)
      {
        v45 = *(v6 + 24);
        v46 = 0xAAAAAAAAAAAAAAABLL * ((*(v6 + 32) - v45) >> 3);
        if (v44 < v46)
        {
          if ((v44 & 0x8000000000000000) == 0)
          {
            if (v46 < v44)
            {
              goto LABEL_77;
            }

            v6 = v45 + 24 * v44;
          }

          v24 = (a1 + 8);
          v25 = v55;
LABEL_69:
          v42 = v6;
          return sub_1016AE070(v24, v25, v42) >= 0;
        }
      }
    }

    else
    {
      if (v38)
      {
        return 0;
      }

      v39 = a3[2];
      if (v39 >= -1)
      {
        v40 = *(v7 + 24);
        v41 = 0xAAAAAAAAAAAAAAABLL * ((*(v7 + 32) - v40) >> 3);
        if (v39 < v41)
        {
          if ((v39 & 0x8000000000000000) == 0)
          {
            if (v41 < v39)
            {
              goto LABEL_77;
            }

            v7 = v40 + 24 * v39;
          }

          v24 = (a1 + 8);
          v25 = v55;
          goto LABEL_47;
        }
      }
    }

    goto LABEL_76;
  }

  if (v10 == 1)
  {
    v17 = a2[2];
    if (v17 < -1)
    {
      goto LABEL_76;
    }

    v18 = *(a5 + 24);
    v19 = 0xAAAAAAAAAAAAAAABLL * ((*(a5 + 32) - v18) >> 3);
    if (v17 >= v19)
    {
      goto LABEL_76;
    }

    v14 = a5;
    if ((v17 & 0x8000000000000000) == 0)
    {
      if (v19 < v17)
      {
        goto LABEL_77;
      }

      v14 = (v18 + 24 * v17);
    }

    v20 = *a3;
    if (*a3 != 2)
    {
      if (v20 == 1)
      {
        v50 = a3[2];
        if (v50 >= -1 && v50 < v19)
        {
          if ((v50 & 0x8000000000000000) == 0)
          {
            if (v19 < v50)
            {
              goto LABEL_77;
            }

            v6 = v18 + 24 * v50;
          }

LABEL_68:
          v24 = (a1 + 8);
          v25 = v14;
          goto LABEL_69;
        }
      }

      else
      {
        if (v20)
        {
          return 0;
        }

        v21 = a3[2];
        if (v21 >= -1)
        {
          v22 = *(a4 + 24);
          v23 = 0xAAAAAAAAAAAAAAABLL * ((*(a4 + 32) - v22) >> 3);
          if (v21 < v23)
          {
            if (v21 < 0)
            {
              goto LABEL_30;
            }

            if (v23 >= v21)
            {
              v7 = v22 + 24 * v21;
              goto LABEL_30;
            }

            goto LABEL_77;
          }
        }
      }

LABEL_76:
      __assert_rtn("apply", "get_ring.hpp", 94, "id.ring_index >= -1 && id.ring_index < int(boost::size(interior_rings(polygon)))");
    }

LABEL_34:
    v33 = a3[1];
    if (a6[5] >= v33)
    {
      v34 = a6[4];
      v35 = a6[1];
      v36 = (v35 + 8 * (v34 / 0xAA));
      if (a6[2] == v35)
      {
        v37 = 0;
      }

      else
      {
        v37 = *v36 + 24 * (v34 % 0xAA);
      }

      v54 = v36;
      v55 = v37;
      sub_10164FCF4(&v54, v33);
      v42 = v55;
      v24 = (a1 + 8);
      v25 = v14;
      return sub_1016AE070(v24, v25, v42) >= 0;
    }

    goto LABEL_77;
  }

  if (v10)
  {
    return 0;
  }

  v11 = a2[2];
  if (v11 < -1)
  {
    goto LABEL_76;
  }

  v12 = *(a4 + 24);
  v13 = 0xAAAAAAAAAAAAAAABLL * ((*(a4 + 32) - v12) >> 3);
  if (v11 >= v13)
  {
    goto LABEL_76;
  }

  v14 = a4;
  if ((v11 & 0x8000000000000000) == 0)
  {
    if (v13 < v11)
    {
      goto LABEL_77;
    }

    v14 = (v12 + 24 * v11);
  }

  v15 = *a3;
  if (*a3 == 2)
  {
    goto LABEL_34;
  }

  if (v15 == 1)
  {
    v51 = a3[2];
    if (v51 >= -1)
    {
      v52 = *(a5 + 24);
      v53 = 0xAAAAAAAAAAAAAAABLL * ((*(a5 + 32) - v52) >> 3);
      if (v51 < v53)
      {
        if ((v51 & 0x8000000000000000) == 0)
        {
          if (v53 < v51)
          {
            goto LABEL_77;
          }

          v6 = v52 + 24 * v51;
        }

        goto LABEL_68;
      }
    }

    goto LABEL_76;
  }

  if (v15)
  {
    return 0;
  }

  v16 = a3[2];
  if (v16 < -1 || v16 >= v13)
  {
    goto LABEL_76;
  }

  if ((v16 & 0x8000000000000000) == 0)
  {
    if (v13 >= v16)
    {
      v7 = v12 + 24 * v16;
      goto LABEL_30;
    }

LABEL_77:
    __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
  }

LABEL_30:
  v24 = (a1 + 8);
  v25 = v14;
LABEL_47:
  v42 = v7;
  return sub_1016AE070(v24, v25, v42) >= 0;
}

uint64_t sub_1016AE070(double *a1, double **a2, double **a3)
{
  v3 = *a3;
  v4 = a3[1];
  if ((v4 - *a3) < 0x40)
  {
    return 0xFFFFFFFFLL;
  }

  v17 = 0;
  v18 = 0;
  v19 = 0;
  if (v3 + 2 == v4)
  {
    return 0xFFFFFFFFLL;
  }

  do
  {
    if (!sub_10169DBD8(a1, v3, v3 + 2, &v17))
    {
      break;
    }

    v8 = v3 + 4;
    v3 += 2;
  }

  while (v8 != v4);
  if (v19)
  {
    v9 = *a2;
    v10 = a2[1];
    if (*a2 == v10)
    {
      return 0;
    }

    v11 = v9 + 2;
    if (v9 + 2 == v10)
    {
      return 0;
    }

    while (1)
    {
      v12 = *a3;
      v13 = a3[1];
      if ((v13 - *a3) < 0x40)
      {
        return 0xFFFFFFFFLL;
      }

      v17 = 0;
      v18 = 0;
      v19 = 0;
      if (v12 + 2 == v13)
      {
        return 0xFFFFFFFFLL;
      }

      do
      {
        if (!sub_10169DBD8(v11, v12, v12 + 2, &v17))
        {
          break;
        }

        v14 = v12 + 4;
        v12 += 2;
      }

      while (v14 != v13);
      if ((v19 & 1) == 0)
      {
        break;
      }

      result = 0;
      v11 += 2;
      if (v11 == v10)
      {
        return result;
      }
    }
  }

  if (!v18 || !HIDWORD(v18))
  {
    if (v17)
    {
      return 1;
    }

    return 0xFFFFFFFFLL;
  }

  if (v18 < 1)
  {
    v16 = v17 == 0;
  }

  else
  {
    v16 = v17 + HIDWORD(v17) == 0;
  }

  if (v16)
  {
    return 0xFFFFFFFFLL;
  }

  else
  {
    return 1;
  }
}

double sub_1016AE1DC(char **a1, uint64_t a2, uint64_t a3, void *a4, uint64_t *a5, int a6, char a7)
{
  v10 = *a5;
  if (*a5 != 2)
  {
    if (v10 == 1)
    {
      v14 = a5[2];
      if (v14 >= -1)
      {
        v15 = *(a3 + 24);
        v16 = 0xAAAAAAAAAAAAAAABLL * ((*(a3 + 32) - v15) >> 3);
        if (v14 < v16)
        {
          if ((v14 & 0x8000000000000000) == 0)
          {
            if (v16 < v14)
            {
              goto LABEL_26;
            }

            a3 = v15 + 24 * v14;
          }

          a2 = a3;
          goto LABEL_16;
        }
      }
    }

    else
    {
      if (v10)
      {
        return result;
      }

      v11 = a5[2];
      if (v11 >= -1)
      {
        v12 = *(a2 + 24);
        v13 = 0xAAAAAAAAAAAAAAABLL * ((*(a2 + 32) - v12) >> 3);
        if (v11 < v13)
        {
          if ((v11 & 0x8000000000000000) == 0)
          {
            if (v13 >= v11)
            {
              a2 = v12 + 24 * v11;
              goto LABEL_16;
            }

LABEL_26:
            __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
          }

LABEL_16:

          *&result = sub_1016AE398(a1, a2, a7, a6).n128_u64[0];
          return result;
        }
      }
    }

    __assert_rtn("apply", "get_ring.hpp", 94, "id.ring_index >= -1 && id.ring_index < int(boost::size(interior_rings(polygon)))");
  }

  v18 = a5[1];
  if (a4[5] < v18)
  {
    goto LABEL_26;
  }

  v19 = a4[4];
  v20 = a4[1];
  v21 = (v20 + 8 * (v19 / 0xAA));
  if (a4[2] == v20)
  {
    v22 = 0;
  }

  else
  {
    v22 = (*v21 + 24 * (v19 % 0xAA));
  }

  v23 = v21;
  v24 = v22;
  sub_10164FCF4(&v23, v18);
  *&result = sub_1016AE398(a1, v24, a7, a6).n128_u64[0];
  return result;
}

__n128 sub_1016AE398(char **a1, char **a2, char a3, int a4)
{
  if (a3)
  {
    if ((a2[1] - *a2) >= 0x31)
    {
      v8 = a1[3];
      v7 = a1[4];
      v9 = 0xAAAAAAAAAAAAAAABLL * ((v7 - v8) >> 3) + 1;
      if (v7 - v8 == -24)
      {
        v10 = &v8[24 * v9];
        if (v7 != v10)
        {
          v11 = a1[4];
          do
          {
            v13 = *(v11 - 3);
            v11 -= 24;
            v12 = v13;
            if (v13)
            {
              *(v7 - 2) = v12;
              operator delete(v12);
            }

            v7 = v11;
          }

          while (v11 != v10);
        }
      }

      else
      {
        v21 = a1[5];
        if (v21 == v7)
        {
          if (v9 <= 0xAAAAAAAAAAAAAAALL)
          {
            v28 = 0xAAAAAAAAAAAAAAABLL * ((v21 - v8) >> 3);
            if (2 * v28 > v9)
            {
              v9 = 2 * v28;
            }

            if (v28 >= 0x555555555555555)
            {
              v29 = 0xAAAAAAAAAAAAAAALL;
            }

            else
            {
              v29 = v9;
            }

            sub_1016AE790(v29);
          }

          sub_1000CE3D4();
        }

        *v7 = 0;
        *(v7 + 1) = 0;
        *(v7 + 2) = 0;
        v10 = v7 + 24;
      }

      a1[4] = v10;
      if (v10 - 24 != a2)
      {
        sub_1016AE664(v10 - 3, *a2, a2[1], (a2[1] - *a2) >> 4);
      }

      if (a4)
      {
        v22 = a1[4];
        v23 = *(v22 - 3);
        v24 = *(v22 - 2);
        v25 = (v24 - 16);
        if (v23 != v24 && v25 > v23)
        {
          v27 = v23 + 16;
          do
          {
            result = *(v27 - 16);
            *(v27 - 16) = *v25;
            *v25-- = result;
            v20 = v27 >= v25;
            v27 += 16;
          }

          while (!v20);
        }
      }
    }
  }

  else
  {
    if (a1 != a2)
    {
      sub_1016AE664(a1, *a2, a2[1], (a2[1] - *a2) >> 4);
    }

    if (a4)
    {
      v15 = *a1;
      v16 = a1[1];
      v17 = v16 - 16;
      if (*a1 != v16 && v17 > v15)
      {
        v19 = v15 + 16;
        do
        {
          result = *(v19 - 16);
          *(v19 - 16) = *v17;
          *v17 = result;
          v17 -= 16;
          v20 = v19 >= v17;
          v19 += 16;
        }

        while (!v20);
      }
    }
  }

  return result;
}

void *sub_1016AE664(void *result, char *__src, char *a3, unint64_t a4)
{
  v6 = result;
  v7 = result[2];
  v8 = *result;
  if (a4 > (v7 - *result) >> 4)
  {
    if (v8)
    {
      result[1] = v8;
      operator delete(v8);
      v7 = 0;
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
    }

    if (!(a4 >> 60))
    {
      v9 = v7 >> 3;
      if (v7 >> 3 <= a4)
      {
        v9 = a4;
      }

      if (v7 >= 0x7FFFFFFFFFFFFFF0)
      {
        v10 = 0xFFFFFFFFFFFFFFFLL;
      }

      else
      {
        v10 = v9;
      }

      sub_1016A7610(v6, v10);
    }

    sub_1000CE3D4();
  }

  v11 = result[1];
  v12 = v11 - v8;
  if (a4 <= (v11 - v8) >> 4)
  {
    v15 = a3 - __src;
    if (v15)
    {
      result = memmove(*result, __src, v15);
    }

    v14 = &v8[v15];
  }

  else
  {
    v13 = &__src[v12];
    if (v11 != v8)
    {
      result = memmove(*result, __src, v12);
      v11 = v6[1];
    }

    if (a3 != v13)
    {
      result = memmove(v11, v13, a3 - v13);
    }

    v14 = &v11[a3 - v13];
  }

  v6[1] = v14;
  return result;
}

void sub_1016AE790(unint64_t a1)
{
  if (a1 < 0xAAAAAAAAAAAAAABLL)
  {
    operator new();
  }

  sub_100013D10();
}

void *sub_1016AE7E8(void *a1, uint64_t *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_1016A7594(a1, *a2, a2[1], (a2[1] - *a2) >> 4);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  v4 = a2[3];
  v5 = a2[4];
  if (v5 != v4)
  {
    v6 = 0xAAAAAAAAAAAAAAABLL * ((v5 - v4) >> 3);
    if (v6 < 0xAAAAAAAAAAAAAABLL)
    {
      sub_1016AE790(v6);
    }

    sub_1000CE3D4();
  }

  return a1;
}

void sub_1016AE908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_101686E34(&a9);
  v11 = *v9;
  if (*v9)
  {
    *(v9 + 8) = v11;
    operator delete(v11);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1016AE940(uint64_t a1)
{
  v3 = *(a1 + 8);
  v2 = *(a1 + 16);
  if (v2 == v3)
  {
    v4 = (a1 + 40);
    v12 = *(a1 + 8);
  }

  else
  {
    v4 = (a1 + 40);
    v5 = *(a1 + 32);
    v6 = &v3[v5 / 0xAA];
    v7 = *v6;
    v8 = *v6 + 24 * (v5 % 0xAA);
    v9 = v3[(*(a1 + 40) + v5) / 0xAA] + 24 * ((*(a1 + 40) + v5) % 0xAA);
    if (v8 != v9)
    {
      do
      {
        v10 = *v8;
        if (*v8)
        {
          *(v8 + 8) = v10;
          operator delete(v10);
          v7 = *v6;
        }

        v8 += 24;
        if (v8 - v7 == 4080)
        {
          v11 = v6[1];
          ++v6;
          v7 = v11;
          v8 = v11;
        }
      }

      while (v8 != v9);
      v3 = *(a1 + 8);
      v2 = *(a1 + 16);
    }

    v12 = v2;
  }

  *v4 = 0;
  v13 = v12 - v3;
  if (v13 >= 3)
  {
    do
    {
      operator delete(*v3);
      v2 = *(a1 + 16);
      v3 = (*(a1 + 8) + 8);
      *(a1 + 8) = v3;
      v13 = v2 - v3;
    }

    while (v13 > 2);
    v12 = v2;
  }

  if (v13 == 1)
  {
    v14 = 85;
  }

  else
  {
    if (v13 != 2)
    {
      goto LABEL_19;
    }

    v14 = 170;
  }

  *(a1 + 32) = v14;
LABEL_19:
  if (v3 != v12)
  {
    do
    {
      v15 = *v3++;
      operator delete(v15);
    }

    while (v3 != v12);
    v12 = *(a1 + 8);
    v2 = *(a1 + 16);
  }

  if (v2 != v12)
  {
    *(a1 + 16) = v2 + ((v12 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void sub_1016AEABC(void *a1)
{
  if (a1)
  {
    sub_1016AEABC(*a1);
    sub_1016AEABC(a1[1]);
    sub_100034450(a1[6]);

    operator delete(a1);
  }
}

uint64_t sub_1016AEB10(uint64_t a1)
{
  v2 = *(a1 + 8);
  v3 = *(a1 + 16);
  *(a1 + 40) = 0;
  v4 = v3 - v2;
  if (v4 >= 3)
  {
    do
    {
      operator delete(*v2);
      v3 = *(a1 + 16);
      v2 = (*(a1 + 8) + 8);
      *(a1 + 8) = v2;
      v4 = v3 - v2;
    }

    while (v4 > 2);
  }

  if (v4 == 1)
  {
    v5 = 8;
    goto LABEL_7;
  }

  if (v4 == 2)
  {
    v5 = 16;
LABEL_7:
    *(a1 + 32) = v5;
  }

  if (v2 != v3)
  {
    do
    {
      v6 = *v2++;
      operator delete(v6);
    }

    while (v2 != v3);
    v8 = *(a1 + 8);
    v7 = *(a1 + 16);
    if (v7 != v8)
    {
      *(a1 + 16) = v7 + ((v8 - v7 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void sub_1016AEBDC(uint64_t *a1)
{
  if (a1[2])
  {
    v2 = a1[1];
    v3 = *(*a1 + 8);
    v4 = *v2;
    *(v4 + 8) = v3;
    *v3 = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        v5 = v2[1];
        sub_101687F08((v2 + 2));
        operator delete(v2);
        v2 = v5;
      }

      while (v5 != a1);
    }
  }
}

uint64_t sub_1016AEC50(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    sub_1000D0358(result, a4);
  }

  return result;
}

void sub_1016AECB0(_Unwind_Exception *exception_object)
{
  v3 = *v1;
  if (*v1)
  {
    *(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void SimDeactivationTracker::create(Registry **a1@<X0>, void *a2@<X8>)
{
  ServiceMap = Registry::getServiceMap(*a1);
  v5 = ServiceMap;
  v7 = v6;
  if (v6 < 0)
  {
    v8 = (v6 & 0x7FFFFFFFFFFFFFFFLL);
    v9 = 5381;
    do
    {
      v7 = v9;
      v10 = *v8++;
      v9 = (33 * v9) ^ v10;
    }

    while (v10);
  }

  std::mutex::lock(ServiceMap);
  __p = v7;
  v11 = sub_100009510(&v5[1].__m_.__sig, &__p);
  if (v11)
  {
    v13 = v11[3];
    v12 = v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v12);
      v14 = 0;
      goto LABEL_9;
    }
  }

  else
  {
    v13 = 0;
  }

  std::mutex::unlock(v5);
  v12 = 0;
  v14 = 1;
LABEL_9:
  if (GestaltUtilityInterface::isIPhone(v13))
  {
    v15 = 0;
    goto LABEL_21;
  }

  v16 = Registry::getServiceMap(*a1);
  v17 = v16;
  if (v6 < 0)
  {
    v18 = (v6 & 0x7FFFFFFFFFFFFFFFLL);
    v19 = 5381;
    do
    {
      v6 = v19;
      v20 = *v18++;
      v19 = (33 * v19) ^ v20;
    }

    while (v20);
  }

  std::mutex::lock(v16);
  __p = v6;
  v21 = sub_100009510(&v17[1].__m_.__sig, &__p);
  if (v21)
  {
    v23 = v21[3];
    v22 = v21[4];
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v22);
      goto LABEL_19;
    }
  }

  else
  {
    v23 = 0;
  }

  std::mutex::unlock(v17);
  v22 = 0;
LABEL_19:
  v15 = GestaltUtilityInterface::isIPad(v23) ^ 1;
  if (v22)
  {
    sub_100004A34(v22);
  }

LABEL_21:
  if ((v14 & 1) == 0)
  {
    sub_100004A34(v12);
  }

  if (!v15)
  {
    operator new();
  }

  *a2 = 0;
  a2[1] = 0;
}

void sub_1016AF294(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, dispatch_object_t a13, void *__p, std::__shared_weak_count *a15, int a16, __int16 a17, char a18, char a19)
{
  if (a10)
  {
    (*(*a10 + 8))(a10);
  }

  if (a15)
  {
    sub_100004A34(a15);
  }

  sub_100004A34(v19);
  _Unwind_Resume(a1);
}

void sub_1016AF540(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }

  v4 = *(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_1016AF640(uint64_t a1)
{
  v1 = *(a1 + 184);
  for (i = *(a1 + 192); v1 != i; v1 += 42)
  {
    if ((subscriber::isSimAbsent() & 1) != 0 || subscriber::isSimUnreadable())
    {
      sub_1016B33F8((a1 + 280), *v1);
    }
  }
}

void sub_1016AF6A4(uint64_t a1)
{
  v1 = *(a1 + 160);
  v2 = (a1 + 168);
  if (v1 != (a1 + 168))
  {
    do
    {
      v4 = *(*(**(a1 + 48) + 16))(*(a1 + 48), *(v1 + 7));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v5 = *(v1 + 32);
        v6 = *(v1 + 33);
        v7 = asString();
        *buf = 67109634;
        v12 = v5;
        v13 = 1024;
        v14 = v6;
        v15 = 2080;
        v16 = v7;
        _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I NetworkRejectCauseCodePS: %d, NetworkRejectCauseCodeCS: %d, Rat: %s", buf, 0x18u);
      }

      if (*(v1 + 33))
      {
        sub_1016B01C8(a1, *(v1 + 7));
      }

      v8 = v1[1];
      if (v8)
      {
        do
        {
          v9 = v8;
          v8 = *v8;
        }

        while (v8);
      }

      else
      {
        do
        {
          v9 = v1[2];
          v10 = *v9 == v1;
          v1 = v9;
        }

        while (!v10);
      }

      v1 = v9;
    }

    while (v9 != v2);
  }
}

void sub_1016AF820(uint64_t a1)
{
  v1 = *(a1 + 232);
  v2 = (a1 + 240);
  if (v1 != (a1 + 240))
  {
    do
    {
      v4 = *(*(**(a1 + 48) + 16))(*(a1 + 48), *(v1 + 7));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v5 = asString();
        *buf = 136315138;
        *&buf[4] = v5;
        _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Registration Status %s", buf, 0xCu);
      }

      v6 = *(v1 + 8);
      if (v6 > 6)
      {
        goto LABEL_54;
      }

      v7 = 1 << v6;
      if ((v7 & 0x4A) != 0)
      {
        sub_1016B01C8(a1, *(v1 + 7));
      }

      else if ((v7 & 0x30) != 0)
      {
        v8 = *(v1 + 7);
        v9 = (*(**(a1 + 48) + 16))(*(a1 + 48), v8);
        v11 = *(a1 + 184);
        v10 = *(a1 + 192);
        if (v11 != v10)
        {
          while (*v11 != v8)
          {
            v11 += 168;
            if (v11 == v10)
            {
              goto LABEL_53;
            }
          }
        }

        if (v11 != v10)
        {
          ServiceMap = Registry::getServiceMap(*(a1 + 56));
          v13 = ServiceMap;
          if (v14 < 0)
          {
            v15 = (v14 & 0x7FFFFFFFFFFFFFFFLL);
            v16 = 5381;
            do
            {
              v14 = v16;
              v17 = *v15++;
              v16 = (33 * v16) ^ v17;
            }

            while (v17);
          }

          std::mutex::lock(ServiceMap);
          *buf = v14;
          v18 = sub_100009510(&v13[1].__m_.__sig, buf);
          if (v18)
          {
            v19 = v18[4];
            v31 = v18[3];
            if (v19)
            {
              atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v13);
              atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_100004A34(v19);
              v20 = 0;
              goto LABEL_21;
            }
          }

          else
          {
            v31 = 0;
          }

          std::mutex::unlock(v13);
          v19 = 0;
          v20 = 1;
LABEL_21:
          __dst[0] = 0;
          __dst[1] = 0;
          v38 = 0;
          if (*(v11 + 95) < 0)
          {
            sub_100005F2C(__dst, *(v11 + 72), *(v11 + 80));
          }

          else
          {
            *__dst = *(v11 + 72);
            v38 = *(v11 + 88);
          }

          v35[0] = 0;
          v35[1] = 0;
          v36 = 0;
          sub_1016B15E8(v35, a1, v8);
          if (SHIBYTE(v36) < 0)
          {
            sub_100005F2C(v32, v35[0], v35[1]);
          }

          else
          {
            *v32 = *v35;
            v33 = v36;
          }

          if (SHIBYTE(v33) < 0)
          {
            sub_100005F2C(__p, v32[0], v32[1]);
          }

          else
          {
            *__p = *v32;
            v41 = v33;
          }

          v39 = 0;
          if (SHIBYTE(v41) < 0)
          {
            sub_100005F2C(buf, __p[0], __p[1]);
          }

          else
          {
            *buf = *__p;
            v45 = v41;
          }

          v42 = 0;
          if (ctu::cf::convert_copy())
          {
            v21 = v39;
            v39 = v42;
            v43 = v21;
            sub_100005978(&v43);
          }

          v22 = v20;
          if (SHIBYTE(v45) < 0)
          {
            operator delete(*buf);
          }

          v23 = v39;
          v34 = v39;
          v39 = 0;
          sub_100005978(&v39);
          if (SHIBYTE(v41) < 0)
          {
            operator delete(__p[0]);
          }

          if (SHIBYTE(v33) < 0)
          {
            operator delete(v32[0]);
          }

          v24 = (*(*v31 + 16))(v31, __dst, @"LastRegisteredNetworkPlmn", v23, @"SimDeactivationInfo", 0, 1, 0);
          v25 = *v9;
          v26 = *v9;
          if (v24)
          {
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              *buf = 67109120;
              *&buf[4] = v24;
              _os_log_error_impl(&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Failed to store NetworkPlmn store in personality wallet %d", buf, 8u);
            }
          }

          else if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            v27 = v35;
            if (v36 < 0)
            {
              v27 = v35[0];
            }

            *buf = 136315138;
            *&buf[4] = v27;
            _os_log_impl(&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I NetworkPlmn %s stored successfully in personality wallet", buf, 0xCu);
          }

          sub_100005978(&v34);
          if (SHIBYTE(v36) < 0)
          {
            operator delete(v35[0]);
          }

          if (SHIBYTE(v38) < 0)
          {
            operator delete(__dst[0]);
            if ((v22 & 1) == 0)
            {
LABEL_52:
              sub_100004A34(v19);
            }
          }

          else if ((v22 & 1) == 0)
          {
            goto LABEL_52;
          }
        }

LABEL_53:
        sub_1016B33F8((a1 + 280), *(v1 + 7));
      }

LABEL_54:
      v28 = v1[1];
      if (v28)
      {
        do
        {
          v29 = v28;
          v28 = *v28;
        }

        while (v28);
      }

      else
      {
        do
        {
          v29 = v1[2];
          v30 = *v29 == v1;
          v1 = v29;
        }

        while (!v30);
      }

      v1 = v29;
    }

    while (v29 != v2);
  }
}

void sub_1016AFD3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, void *a29, uint64_t a30, int a31, __int16 a32, char a33, char a34, const void *a35, void *__p, uint64_t a37, int a38, __int16 a39, char a40, char a41)
{
  sub_100005978(&a35);
  if (a41 < 0)
  {
    operator delete(__p);
  }

  if (a20 < 0)
  {
    operator delete(a15);
  }

  if (a28 < 0)
  {
    operator delete(a23);
  }

  if (a34 < 0)
  {
    operator delete(a29);
  }

  if ((v41 & 1) == 0)
  {
    sub_100004A34(v42);
  }

  _Unwind_Resume(a1);
}

void sub_1016AFE14(uint64_t a1)
{
  v1 = *(a1 + 280);
  v20 = (a1 + 288);
  if (v1 != (a1 + 288))
  {
    do
    {
      v2 = (*(**(a1 + 48) + 16))(*(a1 + 48), *(v1 + 8));
      v3 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        v4 = v1 + 5;
        if (*(v1 + 63) < 0)
        {
          v4 = *v4;
        }

        *buf = 136315138;
        v23 = v4;
        _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I homePlmn: %s", buf, 0xCu);
      }

      v5 = v1[8];
      v6 = v1[9];
      while (v5 != v6)
      {
        v7 = *v2;
        if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
        {
          v8 = v5;
          if (*(v5 + 23) < 0)
          {
            v8 = *v5;
          }

          *buf = 136315138;
          v23 = v8;
          _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I networkPlmn: %s", buf, 0xCu);
          v7 = *v2;
        }

        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v9 = *(v5 + 24);
          *buf = 67109120;
          LODWORD(v23) = v9;
          _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I isRoaming: %d", buf, 8u);
          v7 = *v2;
        }

        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v10 = (v5 + 40);
          if (*(v5 + 63) < 0)
          {
            v10 = *v10;
          }

          *buf = 136315138;
          v23 = v10;
          _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I reasonCode: %s", buf, 0xCu);
          v7 = *v2;
        }

        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v11 = *(v5 + 32);
          v12 = "kUnknown";
          if (v11 == 1)
          {
            v12 = "kCellular";
          }

          v13 = v11 == 2;
          v14 = "kCarrierEntitlement";
          if (!v13)
          {
            v14 = v12;
          }

          *buf = 136315138;
          v23 = v14;
          _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I sourceType: %s", buf, 0xCu);
          v7 = *v2;
        }

        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v15 = *(v5 + 25);
          *buf = 67109120;
          LODWORD(v23) = v15;
          _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I isNetworkInitiated: %d", buf, 8u);
          v7 = *v2;
        }

        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v16 = asString();
          *buf = 136315138;
          v23 = v16;
          _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I rat: %s", buf, 0xCu);
          v7 = *v2;
        }

        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v17 = *(v5 + 64);
          *buf = 134217984;
          v23 = v17;
          _os_log_impl(&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I timeOfEvent: %ld", buf, 0xCu);
        }

        v5 += 72;
      }

      v18 = v1[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = *v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          v19 = v1[2];
          v13 = *v19 == v1;
          v1 = v19;
        }

        while (!v13);
      }

      v1 = v19;
    }

    while (v19 != v20);
  }
}

void sub_1016B01C8(uint64_t a1, uint64_t a2)
{
  v2 = a2;
  v113 = a2;
  v4 = (*(**(a1 + 48) + 16))(*(a1 + 48));
  *__p = 0u;
  v112 = 0u;
  sub_1016B19B4(__p, *(a1 + 184), *(a1 + 192), v2);
  if (BYTE8(v112) != 1)
  {
    goto LABEL_44;
  }

  *v128 = __p;
  v5 = sub_1016B34D8(a1 + 304, __p);
  v2 = v113;
  if (*(v5 + 80))
  {
    goto LABEL_44;
  }

  memset(&v132, 0, sizeof(v132));
  v6 = (*(**(a1 + 48) + 16))(*(a1 + 48), v113);
  v108 = v4;
  buf.__r_.__value_.__r.__words[0] = @"PhoneAccountTransfer";
  buf.__r_.__value_.__l.__size_ = @"RejectCauseCodesForSimDeactivation";
  memset(v128, 0, 24);
  sub_10005B328(v128, &buf, &buf.__r_.__value_.__r.__words[2], 2uLL);
  ServiceMap = Registry::getServiceMap(*(a1 + 56));
  v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    v10 = (v9 & 0x7FFFFFFFFFFFFFFFLL);
    v11 = 5381;
    do
    {
      v9 = v11;
      v12 = *v10++;
      v11 = (33 * v11) ^ v12;
    }

    while (v12);
  }

  std::mutex::lock(ServiceMap);
  buf.__r_.__value_.__r.__words[0] = v9;
  v13 = sub_100009510(&v8[1].__m_.__sig, &buf);
  if (v13)
  {
    v15 = v13[3];
    v14 = v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v14);
      v16 = 0;
      goto LABEL_11;
    }
  }

  else
  {
    v15 = 0;
  }

  std::mutex::unlock(v8);
  v14 = 0;
  v16 = 1;
LABEL_11:
  v4 = v108;
  if (v15)
  {
    buf.__r_.__value_.__r.__words[0] = 0;
    (*(*v15 + 104))(&v125, v15, v2, 1, v128, 0, 0);
    sub_10006DD00(&buf, &v125);
    sub_10000A1EC(&v125);
    if (!buf.__r_.__value_.__r.__words[0] || !CFArrayGetCount(buf.__r_.__value_.__l.__data_))
    {
      sub_100010250(&buf.__r_.__value_.__l.__data_);
      if (v16)
      {
        goto LABEL_39;
      }

      goto LABEL_38;
    }

    v107 = v16;
    Count = CFArrayGetCount(buf.__r_.__value_.__l.__data_);
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(buf.__r_.__value_.__l.__data_, i);
        v21 = ValueAtIndex;
        if (ValueAtIndex)
        {
          v22 = CFGetTypeID(ValueAtIndex);
          if (v22 == CFNumberGetTypeID())
          {
            v23 = v21;
          }

          else
          {
            v23 = 0;
          }
        }

        else
        {
          v23 = 0;
        }

        LODWORD(v125) = 0;
        ctu::cf::assign(&v125, v23, v20);
        size = v132.__r_.__value_.__l.__size_;
        if (v132.__r_.__value_.__l.__size_ >= v132.__r_.__value_.__r.__words[2])
        {
          v26 = v132.__r_.__value_.__r.__words[0];
          v27 = v132.__r_.__value_.__l.__size_ - v132.__r_.__value_.__r.__words[0];
          v28 = (v132.__r_.__value_.__l.__size_ - v132.__r_.__value_.__r.__words[0]) >> 2;
          v29 = v28 + 1;
          if ((v28 + 1) >> 62)
          {
            sub_1000CE3D4();
          }

          v30 = v132.__r_.__value_.__r.__words[2] - v132.__r_.__value_.__r.__words[0];
          if ((v132.__r_.__value_.__r.__words[2] - v132.__r_.__value_.__r.__words[0]) >> 1 > v29)
          {
            v29 = v30 >> 1;
          }

          if (v30 >= 0x7FFFFFFFFFFFFFFCLL)
          {
            v31 = 0x3FFFFFFFFFFFFFFFLL;
          }

          else
          {
            v31 = v29;
          }

          if (v31)
          {
            sub_100016740(&v132, v31);
          }

          *(4 * v28) = v125;
          v25 = 4 * v28 + 4;
          memcpy(0, v26, v27);
          v32 = v132.__r_.__value_.__r.__words[0];
          v132.__r_.__value_.__r.__words[0] = 0;
          *&v132.__r_.__value_.__r.__words[1] = v25;
          if (v32)
          {
            operator delete(v32);
          }
        }

        else
        {
          *v132.__r_.__value_.__l.__size_ = v125;
          v25 = size + 4;
        }

        v132.__r_.__value_.__l.__size_ = v25;
      }
    }

    sub_100010250(&buf.__r_.__value_.__l.__data_);
    v4 = v108;
    v16 = v107;
  }

  v33 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(buf.__r_.__value_.__r.__words + 4) = (v132.__r_.__value_.__l.__size_ - v132.__r_.__value_.__r.__words[0]) >> 2;
    _os_log_impl(&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I [%lu] more reject cause codes are defined in CB", &buf, 0xCu);
  }

  if (v16)
  {
    goto LABEL_39;
  }

LABEL_38:
  sub_100004A34(v14);
LABEL_39:
  if (*v128)
  {
    *&v128[8] = *v128;
    operator delete(*v128);
  }

  *v128 = __p;
  v34 = sub_1016B34D8(a1 + 304, __p);
  sub_1001E9734(v34 + 56, &v132);
  if (v132.__r_.__value_.__r.__words[0])
  {
    v132.__r_.__value_.__l.__size_ = v132.__r_.__value_.__r.__words[0];
    operator delete(v132.__r_.__value_.__l.__data_);
  }

  v2 = v113;
LABEL_44:
  v35 = (*(**(a1 + 48) + 16))(*(a1 + 48), v2);
  v37 = *(a1 + 184);
  v36 = *(a1 + 192);
  if (v37 != v36)
  {
    while (*v37 != v2)
    {
      v37 += 168;
      if (v37 == v36)
      {
        goto LABEL_75;
      }
    }
  }

  if (v37 == v36 || (subscriber::isSimReady() & 1) == 0)
  {
LABEL_75:
    v48 = *v35;
    if (os_log_type_enabled(*v35, OS_LOG_TYPE_ERROR))
    {
      *v128 = 0;
      _os_log_error_impl(&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Could not find sim info", v128, 2u);
    }

LABEL_77:
    v49 = *v4;
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      v50 = subscriber::asString();
      *v128 = 136315138;
      *&v128[4] = v50;
      _os_log_impl(&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I SIM on slot %s is still active", v128, 0xCu);
    }

    goto LABEL_79;
  }

  v38 = *(a1 + 240);
  if (!v38)
  {
    goto LABEL_57;
  }

  v39 = a1 + 240;
  do
  {
    if (*(v38 + 28) >= v2)
    {
      v39 = v38;
    }

    v38 = *(v38 + 8 * (*(v38 + 28) < v2));
  }

  while (v38);
  if (v39 != a1 + 240 && *(v39 + 28) <= v2)
  {
    v40 = *(v39 + 32);
  }

  else
  {
LABEL_57:
    v40 = 0;
  }

  memset(&v132, 0, sizeof(v132));
  sub_1016B18FC(&v132, a1, v2, 1);
  memset(&buf, 0, sizeof(buf));
  sub_1016B18FC(&buf, a1, v2, 2);
  v125 = 0;
  v126 = 0;
  v127 = 0;
  sub_1016B17B0(&v125, a1, v2);
  v109 = v4;
  v122 = 0;
  v123 = 0;
  v124 = 0;
  sub_1016B15E8(&v122, a1, v2);
  v41 = *v35;
  if (os_log_type_enabled(*v35, OS_LOG_TYPE_DEFAULT))
  {
    v42 = &v132;
    if ((v132.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    {
      v42 = v132.__r_.__value_.__r.__words[0];
    }

    p_buf = &buf;
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    {
      p_buf = buf.__r_.__value_.__r.__words[0];
    }

    v44 = &v125;
    if (v127 < 0)
    {
      v44 = v125;
    }

    v45 = &v122;
    if (v124 < 0)
    {
      v45 = v122;
    }

    *v128 = 136315906;
    *&v128[4] = v42;
    *&v128[12] = 2080;
    *&v128[14] = p_buf;
    *&v128[22] = 2080;
    *&v128[24] = v44;
    *&v128[32] = 2080;
    *&v128[34] = v45;
    _os_log_impl(&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I CSReasonCode: %s PSReasonCode: %s homePlmn: %s campedPlmn: %s", v128, 0x2Au);
  }

  if (v40 > 6 || ((1 << v40) & 0x4A) == 0)
  {
    goto LABEL_159;
  }

  v46 = *(a1 + 40);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    v47 = asString();
    *v128 = 136315138;
    *&v128[4] = v47;
    _os_log_impl(&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Registration Status %s", v128, 0xCu);
  }

  if (((1 << v40) & 0x4A) == 0)
  {
    goto LABEL_159;
  }

  if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0)
  {
    sub_100005F2C(&__str, v132.__r_.__value_.__l.__data_, v132.__r_.__value_.__l.__size_);
  }

  else
  {
    __str = v132;
  }

  v51 = std::stoi(&__str, 0, 10) - 2;
  if (v51 < 7u && ((0x73u >> v51) & 1) != 0)
  {
    v52 = 1;
  }

  else
  {
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      sub_100005F2C(&__dst, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    }

    else
    {
      __dst = buf;
    }

    v53 = std::stoi(&__dst, 0, 10) - 2;
    v52 = v53 < 7u && ((0x73u >> v53) & 1) != 0 || sub_1016B1C8C(a1, v2, &v132, &buf);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }

  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
    if (!v52)
    {
      goto LABEL_159;
    }
  }

  else if (!v52)
  {
    goto LABEL_159;
  }

  v54 = Registry::getServiceMap(*(a1 + 56));
  v55 = v54;
  if (v56 < 0)
  {
    v57 = (v56 & 0x7FFFFFFFFFFFFFFFLL);
    v58 = 5381;
    do
    {
      v56 = v58;
      v59 = *v57++;
      v58 = (33 * v58) ^ v59;
    }

    while (v59);
  }

  std::mutex::lock(v54);
  *v128 = v56;
  v60 = sub_100009510(&v55[1].__m_.__sig, v128);
  if (v60)
  {
    v62 = v60[3];
    v61 = v60[4];
    if (v61)
    {
      atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v55);
      atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v61);
      v63 = 0;
      goto LABEL_111;
    }
  }

  else
  {
    v62 = 0;
  }

  std::mutex::unlock(v55);
  v61 = 0;
  v63 = 1;
LABEL_111:
  v118[0] = 0;
  v118[1] = 0;
  v119 = 0;
  if (*(v37 + 95) < 0)
  {
    sub_100005F2C(v118, *(v37 + 72), *(v37 + 80));
  }

  else
  {
    *v118 = *(v37 + 72);
    v119 = *(v37 + 88);
  }

  v117 = 0;
  (*(*v62 + 24))(&cf, v62, v118, @"LastRegisteredNetworkPlmn", @"SimDeactivationInfo", 0, 1);
  v114[0] = cf;
  if (cf)
  {
    CFRetain(cf);
  }

  *v130 = 0;
  *v128 = 0;
  sub_100060DE8(v128, v114);
  if (*v128)
  {
    sub_100222570(v130, v128);
  }

  sub_100005978(v128);
  v117 = *v130;
  *v130 = 0;
  sub_100005978(v130);
  sub_10000A1EC(v114);
  sub_10000A1EC(&cf);
  v64 = *v35;
  if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
  {
    memset(v128, 0, 24);
    ctu::cf::assign();
    *v114 = *v128;
    v115 = *&v128[16];
    v65 = *v128;
    if (v128[23] >= 0)
    {
      v65 = v114;
    }

    *v130 = 136315138;
    *&v130[4] = v65;
    _os_log_impl(&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I lastRegisteredPlmn: %s", v130, 0xCu);
    if (SHIBYTE(v115) < 0)
    {
      operator delete(v114[0]);
    }
  }

  if (v124 >= 0)
  {
    v66 = HIBYTE(v124);
  }

  else
  {
    v66 = v123;
  }

  v67 = HIBYTE(v127);
  if (v127 < 0)
  {
    v67 = v126;
  }

  if (v66 == v67 && (v124 >= 0 ? (v68 = &v122) : (v68 = v122), v127 >= 0 ? (v69 = &v125) : (v69 = v125), !memcmp(v68, v69, v66)))
  {
    v75 = 1;
  }

  else
  {
    memset(v128, 0, 24);
    ctu::cf::assign();
    v115 = *&v128[16];
    *v114 = *v128;
    if (v124 >= 0)
    {
      v70 = HIBYTE(v124);
    }

    else
    {
      v70 = v123;
    }

    v71 = HIBYTE(v115);
    v72 = SHIBYTE(v115);
    if (v115 < 0)
    {
      v71 = v114[1];
    }

    if (v70 == v71)
    {
      if (v124 >= 0)
      {
        v73 = &v122;
      }

      else
      {
        v73 = v122;
      }

      if (v115 >= 0)
      {
        v74 = v114;
      }

      else
      {
        v74 = v114[0];
      }

      v75 = memcmp(v73, v74, v70) == 0;
    }

    else
    {
      v75 = 0;
    }

    if (v72 < 0)
    {
      operator delete(v114[0]);
    }
  }

  sub_100005978(&v117);
  if ((SHIBYTE(v119) & 0x80000000) == 0)
  {
    if (v63)
    {
      goto LABEL_155;
    }

LABEL_158:
    sub_100004A34(v61);
    if (v75)
    {
      goto LABEL_156;
    }

    goto LABEL_159;
  }

  operator delete(v118[0]);
  if ((v63 & 1) == 0)
  {
    goto LABEL_158;
  }

LABEL_155:
  if (v75)
  {
LABEL_156:
    v76 = 1;
    goto LABEL_160;
  }

LABEL_159:
  v76 = 0;
LABEL_160:
  v4 = v109;
  if (SHIBYTE(v124) < 0)
  {
    operator delete(v122);
  }

  if (SHIBYTE(v127) < 0)
  {
    operator delete(v125);
  }

  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v132.__r_.__value_.__l.__data_);
  }

  if ((v76 & 1) == 0)
  {
    goto LABEL_77;
  }

  v77 = v113;
  memset(v128, 0, sizeof(v128));
  *&v128[28] = 11;
  v129 = 0u;
  sub_1016B15E8(&v132, a1, v113);
  *v128 = v132;
  v128[24] = sub_1016B1898(a1, v77);
  sub_1016B18FC(&v132, a1, v77, 1);
  v78 = *(a1 + 168);
  *&v128[40] = *&v132.__r_.__value_.__l.__data_;
  *&v129 = *(&v132.__r_.__value_.__l + 2);
  if (!v78)
  {
    goto LABEL_176;
  }

  v79 = a1 + 168;
  do
  {
    if (*(v78 + 28) >= v77)
    {
      v79 = v78;
    }

    v78 = *(v78 + 8 * (*(v78 + 28) < v77));
  }

  while (v78);
  if (v79 != a1 + 168 && *(v79 + 28) <= v77)
  {
    v80 = *(v79 + 36);
  }

  else
  {
LABEL_176:
    v80 = 11;
  }

  *&v128[28] = v80;
  *&v128[32] = 0;
  *(&v129 + 1) = (kCFAbsoluteTimeIntervalSince1970 + CFAbsoluteTimeGetCurrent());
  v128[25] = 0;
  v81 = *(a1 + 288);
  if (v81)
  {
    v82 = a1 + 288;
    do
    {
      if (*(v81 + 32) >= v113)
      {
        v82 = v81;
      }

      v81 = *(v81 + 8 * (*(v81 + 32) < v113));
    }

    while (v81);
    if (v82 != a1 + 288 && *(v82 + 32) <= v113)
    {
      v83 = *(v82 + 64);
      v84 = *(v82 + 72);
      if (v83 != v84)
      {
        if (v128[23] >= 0)
        {
          v85 = v128[23];
        }

        else
        {
          v85 = *&v128[8];
        }

        if (v128[23] >= 0)
        {
          v86 = v128;
        }

        else
        {
          v86 = *v128;
        }

        if ((SBYTE7(v129) & 0x80u) == 0)
        {
          v87 = BYTE7(v129);
        }

        else
        {
          v87 = *&v128[48];
        }

        if ((SBYTE7(v129) & 0x80u) == 0)
        {
          v88 = &v128[40];
        }

        else
        {
          v88 = *&v128[40];
        }

        v89 = *&v128[28];
        v90 = v83 + 40;
        do
        {
          v91 = *(v90 - 17);
          v92 = v91;
          if ((v91 & 0x80u) != 0)
          {
            v91 = *(v90 - 32);
          }

          if (v85 == v91)
          {
            v93 = v92 >= 0 ? (v90 - 40) : *(v90 - 40);
            if (!memcmp(v86, v93, v85))
            {
              v94 = *(v90 + 23);
              v95 = v94;
              if ((v94 & 0x80u) != 0)
              {
                v94 = *(v90 + 8);
              }

              if (v87 == v94)
              {
                v96 = v95 >= 0 ? v90 : *v90;
                if (!memcmp(v88, v96, v87) && v89 == *(v90 - 12))
                {
                  goto LABEL_229;
                }
              }
            }
          }

          v97 = v90 + 32;
          v90 += 72;
        }

        while (v97 != v84);
      }
    }
  }

  if (SBYTE7(v129) < 0)
  {
    sub_100005F2C(&v110, *&v128[40], *&v128[48]);
  }

  else
  {
    *&v110.__r_.__value_.__l.__data_ = *&v128[40];
    v110.__r_.__value_.__r.__words[2] = v129;
  }

  v98 = std::stoi(&v110, 0, 10);
  v99 = (v98 < 9u) & (0x1CCu >> v98);
  if ((SHIBYTE(v110.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v99)
    {
      goto LABEL_229;
    }

LABEL_221:
    v132.__r_.__value_.__r.__words[0] = &v113;
    v100 = sub_1016B3610(a1 + 280, v113);
    sub_1016B17B0(&v132, a1, v113);
    if (*(v100 + 63) < 0)
    {
      operator delete(v100[5]);
    }

    *(v100 + 5) = v132;
    *&v128[32] = 1;
    v101 = v100[9];
    if (v101 >= v100[10])
    {
      v103 = sub_1016B1FEC(v100 + 8, v128);
      v102 = v109;
    }

    else
    {
      sub_1016B219C(v100[9], v128);
      v102 = v109;
      v103 = v101 + 72;
      v100[9] = v101 + 72;
    }

    v100[9] = v103;
    v104 = *v102;
    if (os_log_type_enabled(*v102, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v132.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "#I Sending notification for Cellular failure", &v132, 2u);
    }

    (*(**(a1 + 96) + 96))(*(a1 + 96), v113, v100 + 5);
    goto LABEL_229;
  }

  operator delete(v110.__r_.__value_.__l.__data_);
  if (v99)
  {
    goto LABEL_221;
  }

LABEL_229:
  if (BYTE8(v112))
  {
    sub_1016B13D8(a1, __p);
  }

  else
  {
    v105 = *v109;
    if (os_log_type_enabled(*v109, OS_LOG_TYPE_ERROR))
    {
      v106 = subscriber::asString();
      LODWORD(v132.__r_.__value_.__l.__data_) = 136315138;
      *(v132.__r_.__value_.__r.__words + 4) = v106;
      _os_log_error_impl(&_mh_execute_header, v105, OS_LOG_TYPE_ERROR, "Fail to find iccid for slot %s", &v132, 0xCu);
    }
  }

  if (SBYTE7(v129) < 0)
  {
    operator delete(*&v128[40]);
  }

  if ((v128[23] & 0x80000000) != 0)
  {
    operator delete(*v128);
  }

LABEL_79:
  if (BYTE8(v112) == 1 && SBYTE7(v112) < 0)
  {
    operator delete(__p[0]);
  }
}

void sub_1016B11B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, void *a32, uint64_t a33, uint64_t a34, uint64_t a35, void *a36, uint64_t a37, uint64_t a38, uint64_t a39, void *a40, uint64_t a41, uint64_t a42, uint64_t a43, void *__p, uint64_t a45, int a46, __int16 a47, char a48, char a49, void *a50, uint64_t a51, int a52, __int16 a53, char a54, char a55)
{
  if ((v56 & 1) == 0)
  {
    sub_100004A34(v55);
  }

  if (a49 < 0)
  {
    operator delete(__p);
  }

  if (a55 < 0)
  {
    operator delete(a50);
  }

  if (*(v57 - 137) < 0)
  {
    operator delete(*(v57 - 160));
  }

  if (*(v57 - 105) < 0)
  {
    operator delete(*(v57 - 128));
  }

  if (a23 == 1 && a22 < 0)
  {
    operator delete(a17);
  }

  _Unwind_Resume(a1);
}

void sub_1016B13D8(uint64_t a1, uint64_t *a2)
{
  ServiceMap = Registry::getServiceMap(*(a1 + 56));
  v5 = ServiceMap;
  v6 = "22CellularPlanController";
  if (("22CellularPlanController" & 0x8000000000000000) != 0)
  {
    v7 = ("22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    v8 = 5381;
    do
    {
      v6 = v8;
      v9 = *v7++;
      v8 = (33 * v8) ^ v9;
    }

    while (v9);
  }

  std::mutex::lock(ServiceMap);
  *v16 = v6;
  v10 = sub_100009510(&v5[1].__m_.__sig, v16);
  if (v10)
  {
    v12 = v10[3];
    v11 = v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v11);
      v13 = 0;
      goto LABEL_9;
    }
  }

  else
  {
    v12 = 0;
  }

  std::mutex::unlock(v5);
  v11 = 0;
  v13 = 1;
LABEL_9:
  v14 = *(a1 + 40);
  if (v12)
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      if (*(a2 + 23) >= 0)
      {
        v15 = a2;
      }

      else
      {
        v15 = *a2;
      }

      *v16 = 136315138;
      *&v16[4] = v15;
      _os_log_impl(&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Set iccid %s as deactivated", v16, 0xCu);
    }

    (*(*v12 + 968))(v12, a2);
LABEL_17:
    if (v13)
    {
      return;
    }

    goto LABEL_18;
  }

  if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    goto LABEL_17;
  }

  *v16 = 0;
  _os_log_error_impl(&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", v16, 2u);
  if (v13)
  {
    return;
  }

LABEL_18:
  sub_100004A34(v11);
}

void sub_1016B15BC(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0)
  {
    sub_100004A34(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016B15E8(uint64_t *a1, uint64_t a2, int a3)
{
  v6 = *(a2 + 216);
  v4 = (a2 + 216);
  v5 = v6;
  if (!v6)
  {
    goto LABEL_8;
  }

  v7 = v4;
  do
  {
    if (v5[8] >= a3)
    {
      v7 = v5;
    }

    v5 = *&v5[2 * (v5[8] < a3)];
  }

  while (v5);
  if (v7 == v4 || v7[8] > a3)
  {
LABEL_8:

    sub_10000501C(a1, "");
    return;
  }

  *v15 = 0u;
  v16 = 0u;
  *v13 = 0u;
  v14 = 0u;
  MCC::MCC(v13, (v7 + 10));
  MCC::MCC(v15, (v7 + 18));
  MCCAndMNC::getMcc(v11, (v7 + 10));
  if (MCC::valid(v11))
  {
    MCCAndMNC::getMnc(v9, (v7 + 10));
    v8 = MCC::valid(v9);
    if (v10 < 0)
    {
      operator delete(v9[1]);
    }
  }

  else
  {
    v8 = 0;
  }

  if ((v12 & 0x80000000) == 0)
  {
    if (!v8)
    {
      goto LABEL_20;
    }

    goto LABEL_19;
  }

  operator delete(v11[1]);
  if (v8)
  {
LABEL_19:
    MCCAndMNC::getStringValue(a1, v13);
  }

LABEL_20:
  if (SHIBYTE(v16) < 0)
  {
    operator delete(v15[1]);
  }

  if (SHIBYTE(v14) < 0)
  {
    operator delete(v13[1]);
  }

  if ((v8 & 1) == 0)
  {
    sub_10000501C(a1, "");
  }
}

void sub_1016B1798(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a23 < 0)
  {
    operator delete(__p);
  }

  JUMPOUT(0x1016B1790);
}

void sub_1016B17B0(uint64_t *a1, uint64_t a2, int a3)
{
  v6 = *(a2 + 120);
  v4 = a2 + 120;
  v5 = v6;
  if (!v6)
  {
    goto LABEL_8;
  }

  v7 = v4;
  do
  {
    if (*(v5 + 32) >= a3)
    {
      v7 = v5;
    }

    v5 = *(v5 + 8 * (*(v5 + 32) < a3));
  }

  while (v5);
  if (v7 != v4 && *(v7 + 32) <= a3)
  {
    *__p = 0u;
    v11 = 0u;
    *v8 = 0u;
    v9 = 0u;
    MCCAndMNC::MCCAndMNC();
    MCCAndMNC::getStringValue(a1, v8);
    if (SHIBYTE(v11) < 0)
    {
      operator delete(__p[1]);
    }

    if (SHIBYTE(v9) < 0)
    {
      operator delete(v8[1]);
    }
  }

  else
  {
LABEL_8:

    sub_10000501C(a1, "");
  }
}

BOOL sub_1016B1898(uint64_t a1, int a2)
{
  v5 = a2;
  for (i = *(a1 + 144); i; i = *i)
  {
    v3 = *(i + 7);
    if (v3 <= a2)
    {
      if (v3 >= a2)
      {
        return *sub_1000A8C4C(a1 + 136, &v5) == 4;
      }

      ++i;
    }
  }

  return 0;
}

double sub_1016B18FC(std::string *a1, uint64_t a2, int a3, int a4)
{
  v7 = *(a2 + 168);
  v5 = a2 + 168;
  v6 = v7;
  if (!v7)
  {
    goto LABEL_8;
  }

  v8 = v5;
  do
  {
    if (*(v6 + 28) >= a3)
    {
      v8 = v6;
    }

    v6 = *(v6 + 8 * (*(v6 + 28) < a3));
  }

  while (v6);
  if (v8 != v5 && *(v8 + 28) <= a3)
  {
    if (a4 == 2)
    {
      v10 = *(v8 + 32);
    }

    else
    {
      v10 = *(v8 + 33);
    }

    std::to_string(&v11, v10);
    result = *&v11.__r_.__value_.__l.__data_;
    *a1 = v11;
  }

  else
  {
LABEL_8:

    sub_10000501C(a1, "");
  }

  return result;
}

_BYTE *sub_1016B19B4(_BYTE *__dst, uint64_t a2, uint64_t a3, int a4)
{
  v4 = __dst;
  if (a2 != a3)
  {
    while (*a2 != a4)
    {
      a2 += 168;
      if (a2 == a3)
      {
        goto LABEL_8;
      }
    }
  }

  if (a2 == a3)
  {
LABEL_8:
    v6 = 0;
    *__dst = 0;
  }

  else
  {
    if (*(a2 + 95) < 0)
    {
      __dst = sub_100005F2C(__dst, *(a2 + 72), *(a2 + 80));
    }

    else
    {
      v5 = *(a2 + 72);
      *(__dst + 2) = *(a2 + 88);
      *__dst = v5;
    }

    v6 = 1;
  }

  v4[24] = v6;
  return __dst;
}

void sub_1016B1A40(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 8);
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  v3 = *(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_1016B1B50(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  v5 = a1;
  v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_1016B3F48;
  v7[3] = &unk_101F608B8;
  v7[4] = a1 + 8;
  v7[5] = &v5;
  v8 = v7;
  v4 = a1 + 24;
  v3 = *(a1 + 24);
  if (*(v4 + 8))
  {
    *(a3 + 48) = 0;
    *(a3 + 16) = 0u;
    *(a3 + 32) = 0u;
    *a3 = 0u;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_1016B43B8;
    v12 = &unk_101F608F8;
    v13 = a3;
    v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }

  else
  {
    *(a3 + 48) = 0;
    *(a3 + 16) = 0u;
    *(a3 + 32) = 0u;
    *a3 = 0u;
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_1016B4244;
    v12 = &unk_101F608D8;
    v13 = a3;
    v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

BOOL sub_1016B1C8C(void *a1, int a2, const std::string *a3, const std::string *a4)
{
  *__dst = 0u;
  v31 = 0u;
  sub_1016B19B4(__dst, a1[23], a1[24], a2);
  if (BYTE8(v31) == 1)
  {
    __p = __dst;
    if (*(sub_1016B34D8((a1 + 38), __dst) + 80) == 1)
    {
      *buf = __dst;
      v7 = sub_1016B34D8((a1 + 38), __dst);
      v28 = 0;
      v29 = 0;
      __p = 0;
      sub_10024064C(&__p, *(v7 + 56), *(v7 + 64), (*(v7 + 64) - *(v7 + 56)) >> 2);
      v8 = __p;
      v9 = v28;
      v10 = std::stoi(a3, 0, 10);
      if (v8 != v9)
      {
        while (*v8 != v10)
        {
          if (++v8 == v9)
          {
            v8 = v9;
            break;
          }
        }
      }

      if (v8 != v28)
      {
        v11 = a1[5];
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          goto LABEL_25;
        }

        v12 = SHIBYTE(a3->__r_.__value_.__r.__words[2]);
        v13 = a3->__r_.__value_.__r.__words[0];
        v14 = subscriber::asString();
        if (v12 >= 0)
        {
          v15 = a3;
        }

        else
        {
          v15 = v13;
        }

        *buf = 136315394;
        *&buf[4] = v15;
        v33 = 2080;
        v34 = v14;
        v16 = "#I CS reject cause code [%s] is a valid code for slot [%s]";
        v17 = v11;
        goto LABEL_24;
      }

      v18 = __p;
      v19 = std::stoi(a4, 0, 10);
      while (v18 != v8)
      {
        if (*v18 == v19)
        {
          v8 = v18;
          break;
        }

        ++v18;
      }

      if (v8 != v28)
      {
        v20 = a1[5];
        if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          goto LABEL_25;
        }

        v21 = SHIBYTE(a4->__r_.__value_.__r.__words[2]);
        v22 = a4->__r_.__value_.__r.__words[0];
        v23 = subscriber::asString();
        if (v21 >= 0)
        {
          v24 = a4;
        }

        else
        {
          v24 = v22;
        }

        *buf = 136315394;
        *&buf[4] = v24;
        v33 = 2080;
        v34 = v23;
        v16 = "#I PS reject cause code [%s] is a valid code for slot [%s]";
        v17 = v20;
LABEL_24:
        _os_log_impl(&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, buf, 0x16u);
LABEL_25:
        if (__p)
        {
          v28 = __p;
          operator delete(__p);
        }

        goto LABEL_30;
      }

      if (__p)
      {
        v28 = __p;
        operator delete(__p);
      }
    }
  }

  if (std::stoi(a3, 0, 10) != 11)
  {
    v25 = std::stoi(a4, 0, 10) == 11;
    goto LABEL_32;
  }

LABEL_30:
  v25 = 1;
LABEL_32:
  if (BYTE8(v31) == 1 && SBYTE7(v31) < 0)
  {
    operator delete(__dst[0]);
  }

  return v25;
}

void sub_1016B1F58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a19 == 1 && a18 < 0)
  {
    operator delete(a13);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016B1FB4(uint64_t a1)
{
  sub_1016B22F0(a1);

  operator delete();
}

uint64_t sub_1016B1FEC(uint64_t *a1, __int128 *a2)
{
  v2 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  v3 = v2 + 1;
  if (v2 + 1 > 0x38E38E38E38E38ELL)
  {
    sub_1000CE3D4();
  }

  if (0x1C71C71C71C71C72 * ((a1[2] - *a1) >> 3) > v3)
  {
    v3 = 0x1C71C71C71C71C72 * ((a1[2] - *a1) >> 3);
  }

  if (0x8E38E38E38E38E39 * ((a1[2] - *a1) >> 3) >= 0x1C71C71C71C71C7)
  {
    v5 = 0x38E38E38E38E38ELL;
  }

  else
  {
    v5 = v3;
  }

  v22 = a1;
  if (v5)
  {
    sub_1016B2244(v5);
  }

  v18 = 0;
  v20 = 72 * v2;
  v21 = 0;
  sub_1016B219C((72 * v2), a2);
  v6 = 72 * v2;
  v19 = v6;
  v7 = *a1;
  v8 = a1[1];
  v9 = v6 + *a1 - v8;
  if (v8 != *a1)
  {
    v10 = *a1;
    v11 = v19 + *a1 - v8;
    do
    {
      v12 = *v10;
      *(v11 + 16) = *(v10 + 16);
      *v11 = v12;
      *(v10 + 8) = 0;
      *(v10 + 16) = 0;
      *v10 = 0;
      v13 = *(v10 + 24);
      *(v11 + 32) = *(v10 + 32);
      *(v11 + 24) = v13;
      v14 = *(v10 + 40);
      *(v11 + 56) = *(v10 + 56);
      *(v11 + 40) = v14;
      *(v10 + 48) = 0;
      *(v10 + 56) = 0;
      *(v10 + 40) = 0;
      *(v11 + 64) = *(v10 + 64);
      v10 += 72;
      v11 += 72;
    }

    while (v10 != v8);
    do
    {
      sub_10143F40C(v7);
      v7 += 72;
    }

    while (v7 != v8);
    v7 = *a1;
  }

  v15 = v6 + 72;
  *a1 = v9;
  a1[1] = v15;
  v16 = a1[2];
  a1[2] = v21;
  v20 = v7;
  v21 = v16;
  v18 = v7;
  v19 = v7;
  sub_1016B22A0(&v18);
  return v15;
}

void sub_1016B2188(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1016B22A0(va);
  _Unwind_Resume(a1);
}

char *sub_1016B219C(char *__dst, __int128 *a2)
{
  v3 = __dst;
  if (*(a2 + 23) < 0)
  {
    __dst = sub_100005F2C(__dst, *a2, *(a2 + 1));
  }

  else
  {
    v4 = *a2;
    *(__dst + 2) = *(a2 + 2);
    *__dst = v4;
  }

  v5 = *(a2 + 3);
  *(v3 + 8) = *(a2 + 8);
  *(v3 + 3) = v5;
  if (*(a2 + 63) < 0)
  {
    __dst = sub_100005F2C(v3 + 40, *(a2 + 5), *(a2 + 6));
  }

  else
  {
    v6 = *(a2 + 40);
    *(v3 + 7) = *(a2 + 7);
    *(v3 + 40) = v6;
  }

  *(v3 + 8) = *(a2 + 8);
  return __dst;
}

void sub_1016B2228(_Unwind_Exception *exception_object)
{
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016B2244(unint64_t a1)
{
  if (a1 < 0x38E38E38E38E38FLL)
  {
    operator new();
  }

  sub_100013D10();
}

uint64_t sub_1016B22A0(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 72;
    sub_10143F40C(i - 72);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void sub_1016B22F0(uint64_t a1)
{
  *a1 = off_101F604F0;
  sub_1016B2438(*(a1 + 312));
  sub_1016B24B0(*(a1 + 288));
  sub_10006DCAC(a1 + 256, *(a1 + 264));
  sub_10006DCAC(a1 + 232, *(a1 + 240));
  sub_10004C4EC(a1 + 208, *(a1 + 216));
  v7 = (a1 + 184);
  sub_1000B2AF8(&v7);
  sub_10006DCAC(a1 + 160, *(a1 + 168));
  sub_10006DCAC(a1 + 136, *(a1 + 144));
  sub_1001A8E08(a1 + 112, *(a1 + 120));
  v2 = *(a1 + 104);
  if (v2)
  {
    sub_100004A34(v2);
  }

  v3 = *(a1 + 88);
  *(a1 + 88) = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  v4 = *(a1 + 80);
  if (v4)
  {
    sub_100004A34(v4);
  }

  v5 = *(a1 + 64);
  if (v5)
  {
    sub_100004A34(v5);
  }

  v6 = *(a1 + 48);
  *(a1 + 48) = 0;
  if (v6)
  {
    (*(*v6 + 8))(v6);
  }

  ctu::OsLogLogger::~OsLogLogger((a1 + 40));
  sub_1000C0544((a1 + 8));
  SimDeactivationTrackerInterface::~SimDeactivationTrackerInterface(a1);
}

void sub_1016B2438(char *a1)
{
  if (a1)
  {
    sub_1016B2438(*a1);
    sub_1016B2438(*(a1 + 1));
    if (a1[80] == 1)
    {
      v2 = *(a1 + 7);
      if (v2)
      {
        *(a1 + 8) = v2;
        operator delete(v2);
      }
    }

    if (a1[55] < 0)
    {
      operator delete(*(a1 + 4));
    }

    operator delete(a1);
  }
}

void sub_1016B24B0(void *a1)
{
  if (a1)
  {
    sub_1016B24B0(*a1);
    sub_1016B24B0(a1[1]);
    sub_1016B2504((a1 + 4));

    operator delete(a1);
  }
}

void sub_1016B2504(uint64_t a1)
{
  v2 = (a1 + 32);
  sub_10143F388(&v2);
  if (*(a1 + 31) < 0)
  {
    operator delete(*(a1 + 8));
  }
}

void sub_1016B2550(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1016B25A4(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1016B25E4(uint64_t result)
{
  if (result)
  {
    return (*(*result + 24))();
  }

  return result;
}

void sub_1016B2610(ServiceManager::Service *this)
{
  *this = off_101F60648;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1016B266C(ServiceManager::Service *this)
{
  *this = off_101F60648;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_1016B26EC@<X0>(void *a1@<X8>)
{
  v2 = 2;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  return sub_1000FF040(a1, &v2, &vars0, 1);
}

void sub_1016B2730(uint64_t a1, dispatch_object_t *a2)
{
  v2 = *(a1 + 8);
  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1016AF540(v2, v3);
  }

  v4 = *(a1 + 8);

  sub_1016AF540(v4, 0);
}

void sub_1016B27D0(uint64_t a1)
{
  v1 = *(*(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_1016B28B0(uint64_t a1, int a2, ServiceStage *this)
{
  v3 = *(a1 + 8);
  ServiceStage::holdOffStage(&group[1], this);
  v4 = *(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t *sub_1016B29C4(uint64_t *a1)
{
  v1 = *a1;
  v5 = a1;
  v6 = v1;
  v2 = *v1;
  v3 = *(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }

  ctu::RestModule::disconnect((v2 + 72));
  sub_1000FF844(&v6);
  return sub_1000049E0(&v5);
}

void sub_1016B2A48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_1016B2A64(uint64_t **a1)
{
  v1 = **a1;
  Registry::createRestModuleOneTimeUseConnection(&v2, *(v1 + 56));
  ctu::RestModule::connect();
  if (v3)
  {
    sub_100004A34(v3);
  }

  sub_100B547F8(v1 + 112);
  sub_1001EC378(v1 + 136);
  sub_101409B44(v1 + 208);
  sub_10000501C(&__p, "/cc/props/sims_in_use");
  operator new();
}

void sub_1016B2D40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  sub_1000062D4(&a19);
  if (a18 < 0)
  {
    operator delete(__p);
  }

  sub_1000FF844(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

void sub_1016B2DB0(uint64_t a1)
{
  v2 = a1;
  v1 = *(**a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Starting SimDeactivationTracker", buf, 2u);
  }

  operator delete();
}

__n128 sub_1016B2EB8(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F606C8;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_1016B2EF0(uint64_t a1, xpc_object_t *a2)
{
  sub_10010A62C(*(a1 + 8), a2);
  v3 = *(a1 + 24);
  v4 = *(a1 + 32);
  v5 = (*(a1 + 16) + (v4 >> 1));
  if (v4)
  {
    v3 = *(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1016B2F6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1016B3034(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F60748;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_1016B306C(uint64_t *a1, xpc_object_t *a2)
{
  sub_1002FF8E0(a1[1], a2);
  v3 = a1[3];
  v4 = a1[4];
  v5 = (a1[2] + (v4 >> 1));
  if (v4)
  {
    v3 = *(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1016B30E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1016B31B0(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F607C8;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_1016B31E8(uint64_t *a1, xpc_object_t *a2)
{
  sub_100109E38(a1[1], a2);
  v3 = a1[3];
  v4 = a1[4];
  v5 = (a1[2] + (v4 >> 1));
  if (v4)
  {
    v3 = *(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1016B3264(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

__n128 sub_1016B332C(uint64_t a1, uint64_t a2)
{
  *a2 = off_101F60848;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t sub_1016B3364(void *a1)
{
  v1 = a1[2];
  v2 = a1[3];
  v3 = (a1[1] + (v2 >> 1));
  if (v2)
  {
    return (*(*v3 + v1))();
  }

  else
  {
    return v1(v3);
  }
}

uint64_t sub_1016B33AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

void sub_1016B33F8(uint64_t **a1, int a2)
{
  v4 = (a1 + 1);
  v3 = a1[1];
  if (v3)
  {
    v5 = v4;
    v6 = v3;
    do
    {
      if (*(v6 + 8) >= a2)
      {
        v5 = v6;
      }

      v6 = v6[*(v6 + 8) < a2];
    }

    while (v6);
    if (v5 != v4 && *(v5 + 8) <= a2)
    {
      v7 = v5[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *v7;
        }

        while (v7);
      }

      else
      {
        v9 = v5;
        do
        {
          v8 = v9[2];
          v10 = *v8 == v9;
          v9 = v8;
        }

        while (!v10);
      }

      if (*a1 == v5)
      {
        *a1 = v8;
      }

      a1[2] = (a1[2] - 1);
      sub_100018288(v3, v5);
      sub_1016B2504((v5 + 4));

      operator delete(v5);
    }
  }
}

uint64_t sub_1016B34D8(uint64_t a1, void **a2)
{
  v3 = (a1 + 8);
  v2 = *(a1 + 8);
  if (!v2)
  {
    goto LABEL_7;
  }

  while (1)
  {
    while (1)
    {
      v5 = v2;
      if ((sub_1000068BC(a2, (v2 + 32)) & 0x80) == 0)
      {
        break;
      }

      v2 = *v5;
      v3 = v5;
      if (!*v5)
      {
        goto LABEL_7;
      }
    }

    if ((sub_1000068BC(v5 + 4, a2) & 0x80) == 0)
    {
      break;
    }

    v3 = v5 + 1;
    v2 = v5[1];
    if (!v2)
    {
      goto LABEL_7;
    }
  }

  if (!*v3)
  {
LABEL_7:
    operator new();
  }

  return *v3;
}

uint64_t *sub_1016B3610(uint64_t a1, int a2)
{
  v2 = *(a1 + 8);
  if (!v2)
  {
LABEL_8:
    operator new();
  }

  while (1)
  {
    while (1)
    {
      v3 = v2;
      v4 = *(v2 + 32);
      if (v4 <= a2)
      {
        break;
      }

      v2 = *v3;
      if (!*v3)
      {
        goto LABEL_8;
      }
    }

    if (v4 >= a2)
    {
      return v3;
    }

    v2 = v3[1];
    if (!v2)
    {
      goto LABEL_8;
    }
  }
}

uint64_t *sub_1016B3700(_DWORD **a1)
{
  v1 = *a1;
  v38 = a1;
  v39 = v1;
  v2 = v1[6];
  v3 = *v1;
  v4 = (*(**(*v1 + 48) + 16))(*(*v1 + 48), *(*(v1 + 1) + 52));
  v5 = *(v1 + 1);
  v6 = *(v5 + 52);
  __dst[0] = 0;
  __dst[1] = 0;
  v43 = 0;
  if (*(v5 + 47) < 0)
  {
    sub_100005F2C(__dst, *(v5 + 24), *(v5 + 32));
  }

  else
  {
    *__dst = *(v5 + 24);
    v43 = *(v5 + 40);
  }

  ServiceMap = Registry::getServiceMap(*(v3 + 56));
  v8 = ServiceMap;
  if (v9 < 0)
  {
    v10 = (v9 & 0x7FFFFFFFFFFFFFFFLL);
    v11 = 5381;
    do
    {
      v9 = v11;
      v12 = *v10++;
      v11 = (33 * v11) ^ v12;
    }

    while (v12);
  }

  std::mutex::lock(ServiceMap);
  *buf = v9;
  v13 = sub_100009510(&v8[1].__m_.__sig, buf);
  if (v13)
  {
    v15 = v13[3];
    v14 = v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v14);
      v16 = 0;
      goto LABEL_12;
    }
  }

  else
  {
    v15 = 0;
  }

  std::mutex::unlock(v8);
  v14 = 0;
  v16 = 1;
LABEL_12:
  if (v2 == 6000)
  {
    v22 = (*(*v15 + 16))(v15, __dst, @"EntitlementAuthSuccessStatus", kCFBooleanTrue, @"SimDeactivationInfo", 0, 1, 0);
    v23 = *v4;
    v24 = *v4;
    if (v22)
    {
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *buf = 67109120;
        *&buf[4] = v22;
        _os_log_error_impl(&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Failed to store entitlement auth status, error (%d)", buf, 8u);
      }
    }

    else if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v25 = sub_100531604(6000);
      *buf = 136315138;
      *&buf[4] = v25;
      _os_log_impl(&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Stored entitlement auth status (%s) successfully", buf, 0xCu);
    }
  }

  else if (v2 == 6004)
  {
    v41 = 0;
    (*(*v15 + 24))(&cf, v15, __dst, @"EntitlementAuthSuccessStatus", @"SimDeactivationInfo", 0, 1);
    v45.__r_.__value_.__r.__words[0] = cf;
    if (cf)
    {
      CFRetain(cf);
    }

    v44 = 0;
    *buf = 0;
    sub_10002FE1C(buf, &v45.__r_.__value_.__l.__data_);
    if (*buf)
    {
      sub_1005DDAA8(&v44, buf);
    }

    sub_100045C8C(buf);
    v17 = v44;
    v41 = v44;
    v44 = 0;
    sub_100045C8C(&v44);
    sub_10000A1EC(&v45.__r_.__value_.__l.__data_);
    sub_10000A1EC(&cf);
    if (v17)
    {
      buf[0] = 0;
      ctu::cf::assign(buf, v17, v18);
      if (buf[0] == 1)
      {
        v19 = (*(*v15 + 16))(v15, __dst, @"EntitlementAuthSuccessStatus", kCFBooleanFalse, @"SimDeactivationInfo", 0, 1, 0);
        v20 = *v4;
        v21 = *v4;
        if (v19)
        {
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *buf = 67109120;
            *&buf[4] = v19;
            _os_log_error_impl(&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to store entitlement auth status, error (%d)", buf, 8u);
          }
        }

        else if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          v26 = sub_100531604(6004);
          *buf = 136315138;
          *&buf[4] = v26;
          _os_log_impl(&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Stored entitlement auth status (%s) successfully", buf, 0xCu);
        }

        LODWORD(v44) = v6;
        v27 = *(v3 + 184);
        v28 = *(v3 + 192);
        if (v27 != v28)
        {
          while (*v27 != v6)
          {
            v27 += 42;
            if (v27 == v28)
            {
              goto LABEL_45;
            }
          }
        }

        if (v27 != v28 && subscriber::isSimReady())
        {
          v29 = (*(**(v3 + 48) + 16))(*(v3 + 48), v6);
          *buf = &v44;
          v30 = sub_1016B3610(v3 + 280, v6);
          sub_1016B17B0(buf, v3, v44);
          if (*(v30 + 63) < 0)
          {
            operator delete(v30[5]);
          }

          *(v30 + 5) = *buf;
          v30[7] = *v47;
          v48 = 0;
          *buf = 0u;
          *v47 = 0u;
          __p = 0u;
          v50 = 0u;
          *&v47[12] = 0x20000000BLL;
          std::to_string(&v45, 6004);
          __p = *&v45.__r_.__value_.__l.__data_;
          *&v50 = *(&v45.__r_.__value_.__l + 2);
          *(&v50 + 1) = (kCFAbsoluteTimeIntervalSince1970 + CFAbsoluteTimeGetCurrent());
          *&v47[8] = sub_1016B1898(v3, v44);
          v31 = v30[9];
          if (v31 >= v30[10])
          {
            v32 = sub_1016B1FEC(v30 + 8, buf);
          }

          else
          {
            sub_1016B219C(v30[9], buf);
            v32 = v31 + 72;
            v30[9] = v31 + 72;
          }

          v30[9] = v32;
          v33 = *v29;
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v45.__r_.__value_.__l.__data_) = 0;
            _os_log_impl(&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Sending notification for entitlement auth failure", &v45, 2u);
          }

          (*(**(v3 + 96) + 96))(*(v3 + 96), v44, v30 + 5);
          if (SBYTE7(v50) < 0)
          {
            operator delete(__p);
          }
        }

LABEL_45:
        (*(*v15 + 32))(v15, __dst, @"EntitlementAuthSuccessStatus", @"SimDeactivationInfo", 0, 1);
        v34 = HIBYTE(v43);
        if (v43 < 0)
        {
          v34 = __dst[1];
        }

        if (v34 && isReal())
        {
          v35 = *v4;
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            v36 = __dst;
            if (v43 < 0)
            {
              v36 = __dst[0];
            }

            *buf = 136315138;
            *&buf[4] = v36;
            _os_log_impl(&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Notify iccid %s as deactivated", buf, 0xCu);
          }

          sub_1016B13D8(v3, __dst);
        }
      }
    }

    sub_100045C8C(&v41);
  }

  if ((v16 & 1) == 0)
  {
    sub_100004A34(v14);
  }

  if (SHIBYTE(v43) < 0)
  {
    operator delete(__dst[0]);
  }

  sub_1016B3EF4(&v39);
  return sub_1000049E0(&v38);
}

void sub_1016B3E30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 a11, char a12, char a13, int a14, const void *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, char a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30)
{
  *(v31 + 72) = v32;
  sub_10015E2C8(&a30);
  sub_100045C8C(&a15);
  if ((v33 & 1) == 0)
  {
    sub_100004A34(v30);
  }

  if (a21 < 0)
  {
    operator delete(__p);
  }

  sub_1016B3EF4(&a10);
  sub_1000049E0(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1016B3EF4(uint64_t *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    v2 = *(v1 + 16);
    if (v2)
    {
      sub_100004A34(v2);
    }

    operator delete();
  }

  return result;
}

void sub_1016B3F48(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v3 = *(a1 + 40);
  v4 = *v3;
  v5 = (*(**(*v3 + 48) + 16))(*(*v3 + 48), v3[2]);
  *a2 = 0u;
  *(a2 + 16) = 0u;
  *(a2 + 32) = 0u;
  *(a2 + 48) = 0;
  v6 = *(v4 + 288);
  if (!v6)
  {
    goto LABEL_8;
  }

  v7 = v4 + 288;
  v8 = v3[2];
  v9 = v4 + 288;
  do
  {
    if (*(v6 + 32) >= v8)
    {
      v9 = v6;
    }

    v6 = *(v6 + 8 * (*(v6 + 32) < v8));
  }

  while (v6);
  if (v9 != v7 && v8 >= *(v9 + 32))
  {
    if (*(v9 + 63) < 0)
    {
      sub_100005F2C(a2, *(v9 + 40), *(v9 + 48));
    }

    else
    {
      v11 = *(v9 + 40);
      *(a2 + 16) = *(v9 + 56);
      *a2 = v11;
    }

    *(a2 + 24) = 0;
    *(a2 + 32) = 0;
    *(a2 + 40) = 0;
    v12 = *(v9 + 64);
    v13 = *(v9 + 72);
    v14[0] = a2 + 24;
    if (v13 != v12)
    {
      v14[1] = 0;
      sub_1016B4168(a2 + 24, 0x8E38E38E38E38E39 * ((v13 - v12) >> 3));
    }

    *(a2 + 48) = 1;
  }

  else
  {
LABEL_8:
    v10 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v14[0]) = 0;
      _os_log_error_impl(&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find SimDeactivation info", v14, 2u);
    }
  }
}

void sub_1016B4100(void **a1)
{
  v1 = *a1;
  if (*a1)
  {
    v3 = a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 72;
        sub_10143F40C(v3);
      }

      while (v3 != v1);
      v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1016B4168(uint64_t a1, unint64_t a2)
{
  if (a2 < 0x38E38E38E38E38FLL)
  {
    sub_1016B2244(a2);
  }

  sub_1000CE3D4();
}

char *sub_1016B41BC(__int128 *a1, __int128 *a2, char *__dst)
{
  if (a1 != a2)
  {
    v5 = a1;
    v6 = 0;
    do
    {
      sub_1016B219C(__dst, v5);
      v5 = (v5 + 72);
      __dst += 72;
      v6 -= 72;
    }

    while (v5 != a2);
  }

  return __dst;
}

void sub_1016B421C(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    v4 = v1 - 72;
    do
    {
      sub_10143F40C(v4);
      v4 -= 72;
      v2 += 72;
    }

    while (v2);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016B4244(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(__p);
  sub_1016B42C0(*(a1 + 32), __p);
  if (v4[24] == 1)
  {
    v5 = v4;
    sub_10143F388(&v5);
    if (v3 < 0)
    {
      operator delete(__p[0]);
    }
  }
}

__n128 sub_1016B42C0(uint64_t a1, __int128 *a2)
{
  if (*(a1 + 48) == *(a2 + 48))
  {
    if (*(a1 + 48))
    {
      if (*(a1 + 23) < 0)
      {
        operator delete(*a1);
      }

      v4 = *a2;
      *(a1 + 16) = *(a2 + 2);
      *a1 = v4;
      *(a2 + 23) = 0;
      *a2 = 0;
      sub_1016B4100((a1 + 24));
      result = *(a2 + 24);
      *(a1 + 24) = result;
      *(a1 + 40) = *(a2 + 5);
      *(a2 + 3) = 0;
      *(a2 + 4) = 0;
      *(a2 + 5) = 0;
    }
  }

  else if (*(a1 + 48))
  {
    v7 = (a1 + 24);
    sub_10143F388(&v7);
    if (*(a1 + 23) < 0)
    {
      operator delete(*a1);
    }

    *(a1 + 48) = 0;
  }

  else
  {
    v6 = *a2;
    *(a1 + 16) = *(a2 + 2);
    *a1 = v6;
    *(a2 + 1) = 0;
    *(a2 + 2) = 0;
    *a2 = 0;
    *(a1 + 24) = 0;
    *(a1 + 32) = 0;
    *(a1 + 40) = 0;
    result = *(a2 + 24);
    *(a1 + 24) = result;
    *(a1 + 40) = *(a2 + 5);
    *(a2 + 3) = 0;
    *(a2 + 4) = 0;
    *(a2 + 5) = 0;
    *(a1 + 48) = 1;
  }

  return result;
}

void sub_1016B43B8(uint64_t a1)
{
  (*(**(a1 + 40) + 16))(__p);
  sub_1016B42C0(*(a1 + 32), __p);
  if (v4[24] == 1)
  {
    v5 = v4;
    sub_10143F388(&v5);
    if (v3 < 0)
    {
      operator delete(__p[0]);
    }
  }
}

void sub_1016B4544(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
  {
    (*(*a10 + 8))(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016B4580(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2)
  {
    dispatch_retain(*a2);
  }

  sub_1015D7E84();
}

void sub_1016B4634(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11)
  {
    (*(*a11 + 8))(a11);
  }

  if (v11)
  {
    dispatch_release(v11);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016B4680(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2)
  {
    dispatch_retain(*a2);
  }

  sub_10161A684();
}

void sub_1016B46F0(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_release(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016B4708(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2)
  {
    dispatch_retain(*a2);
  }

  sub_1010F4280();
}

void sub_1016B4778(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_release(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016B4804(void *a1@<X8>)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = a1 + 1;
  sub_1016B4434();
}

void sub_1016B4990(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14)
  {
    sub_100004A34(a14);
  }

  if (v15)
  {
    dispatch_release(v15);
  }

  if (a10)
  {
    (*(*a10 + 8))(a10);
  }

  sub_10006EC28(v14, *(v14 + 8));
  _Unwind_Resume(a1);
}

void sub_1016B4A34(uint64_t a1, dispatch_object_t *a2, uint64_t a3)
{
  if (*a2)
  {
    dispatch_retain(*a2);
  }

  v4 = *(a3 + 8);
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 8), 1uLL, memory_order_relaxed);
  }

  RegistrationEventHandler::create(&v5);
}

void sub_1016B4AD0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    sub_100004A34(v2);
  }

  if (v1)
  {
    dispatch_release(v1);
  }

  _Unwind_Resume(exception_object);
}

double sub_1016B4B6C@<D0>(CCPreferences *a1@<X0>, _OWORD *a2@<X8>)
{
  CCPreferences::create(&v4, a1);
  result = *&v4;
  *a2 = v4;
  return result;
}

void sub_1016B4BA4(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2)
  {
    dispatch_retain(*a2);
  }

  sub_10159BCDC();
}

void sub_1016B4C1C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_release(v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016B4C4C(RegistrationFactoryInterface *this)
{
  *this = off_101F60928;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  RegistrationFactoryInterface::~RegistrationFactoryInterface(this);
}

void sub_1016B4CA8(RegistrationFactoryInterface *this)
{
  *this = off_101F60928;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  RegistrationFactoryInterface::~RegistrationFactoryInterface(this);

  operator delete();
}

void sub_1016B4D94(uint64_t a1)
{
  ctu::OsLogContext::OsLogContext(&v9, kCtLoggingSystemName, "main");
  initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  v3 = dispatch_queue_create_with_target_V2("CCDaemon", initially_inactive, 0);
  dispatch_set_qos_class_floor(v3, QOS_CLASS_UTILITY, 0);
  dispatch_activate(v3);
  *a1 = 0;
  *(a1 + 8) = 0;
  *(a1 + 16) = v3;
  if (v3)
  {
    dispatch_retain(v3);
    *(a1 + 24) = 0;
    dispatch_release(v3);
  }

  else
  {
    *(a1 + 24) = 0;
  }

  ctu::OsLogLogger::OsLogLogger(v8, &v9);
  ctu::OsLogLogger::OsLogLogger((a1 + 32), v8);
  ctu::OsLogLogger::~OsLogLogger(v8);
  ctu::OsLogContext::~OsLogContext(&v9);
  sub_10000501C(&__p, "CCDaemon");
  v4 = *(a1 + 16);
  v5 = v4;
  if (v4)
  {
    dispatch_retain(v4);
  }

  ctu::RestModule::RestModule();
  if (v5)
  {
    dispatch_release(v5);
  }

  if (v7 < 0)
  {
    operator delete(__p);
  }

  *(a1 + 80) = 0;
  *(a1 + 88) = 0;
  operator new();
}

void sub_1016B5028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t object, dispatch_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  ctu::OsLogContext::~OsLogContext((v19 - 48));
  v21 = v18[16];
  if (v21)
  {
    sub_100004A34(v21);
  }

  v22 = v18[14];
  if (v22)
  {
    sub_100004A34(v22);
  }

  v23 = v18[12];
  v18[12] = 0;
  if (v23)
  {
    sub_1016B5D6C(v23);
  }

  sub_1016B5AB0((v18 + 7));
  v24 = v18[6];
  if (v24)
  {
    sub_100004A34(v24);
  }

  ctu::OsLogLogger::~OsLogLogger((v18 + 4));
  sub_1000C0544(v18);
  _Unwind_Resume(a1);
}

void sub_1016B510C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  ctu::OsLogLogger::~OsLogLogger(va);
  sub_1000C0544(v7);
  ctu::OsLogContext::~OsLogContext((v8 - 48));
  JUMPOUT(0x1016B5104);
}

void sub_1016B5134(uint64_t a1)
{
  v2 = *(a1 + 112);
  v3 = (a1 + 104);
  v4 = v2;
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  Registry::set();
  if (v4)
  {
    sub_100004A34(v4);
  }

  sub_1010A31E4(*(a1 + 96), v3);
}

void sub_1016B52C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016B52F4(uint64_t a1, int a2)
{
  if (a2)
  {
    v3 = *(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v13) = 0;
      _os_log_impl(&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N CommCenter is shutting down. Clear all features (0)", &v13, 2u);
    }

    v4 = 0;
  }

  else
  {
    v5 = 4;
    if (!*(a1 + 140))
    {
      v5 = 0;
    }

    if (*(a1 + 141))
    {
      v4 = v5 | 8;
    }

    else
    {
      v4 = v5;
    }
  }

  if (byte_101FCB0B0)
  {
    v6 = qword_101FCB0B8;
    if (qword_101FCB0B8 == v4)
    {
      goto LABEL_17;
    }

    v7 = *(a1 + 32);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_17;
    }

    v13 = 134218240;
    v14 = v6;
    v15 = 2048;
    v16 = v4;
    v8 = "#N CommCenter features changed from %llu -> %llu";
    v9 = v7;
    v10 = 22;
  }

  else
  {
    byte_101FCB0B0 = 1;
    v11 = *(a1 + 32);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_17;
    }

    v13 = 134217984;
    v14 = v4;
    v8 = "#N CommCenter features initialized to %llu";
    v9 = v11;
    v10 = 12;
  }

  _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, &v13, v10);
LABEL_17:
  qword_101FCB0B8 = v4;
  result = notify_is_valid_token(*(a1 + 136));
  if (result)
  {
    notify_set_state(*(a1 + 136), v4);
    return notify_post("com.apple.CoreTelephony.FeatureChanged");
  }

  return result;
}

void sub_1016B54A8(uint64_t a1)
{
  v2 = *(a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *v3 = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N CommCenter Init: creating basic services", v3, 2u);
  }

  Registry::markInitializationComplete(*(a1 + 104));
  sub_1010A3EEC(*(a1 + 96), a1 + 104);
}

void sub_1016B5520(void *a1)
{
  v2 = a1[16];
  a1[15] = 0;
  a1[16] = 0;
  if (v2)
  {
    sub_100004A34(v2);
  }

  v5 = a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1016B65F8;
  block[3] = &unk_101F60B40;
  block[4] = a1;
  block[5] = &v5;
  v3 = a1[2];
  if (a1[3])
  {
    dispatch_async_and_wait(v3, block);
  }

  else
  {
    dispatch_sync(v3, block);
  }

  v4 = a1[4];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(block[0]) = 0;
    _os_log_impl(&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N CommCenter Init: complete", block, 2u);
  }
}

uint64_t sub_1016B55F8(uint64_t a1)
{
  v2 = *(a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *v5 = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N CommCenter Shutdown: stopping services", v5, 2u);
  }

  *(a1 + 88) = 2;
  v3 = *(a1 + 80);
  if (v3)
  {
    (*(*v3 + 48))(v3);
  }

  return sub_1016B52F4(a1, 1);
}

void sub_1016B56A0(uint64_t a1)
{
  v1 = *(a1 + 32);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *v2 = 0;
    _os_log_impl(&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#N CommCenter Shutdown: complete", v2, 2u);
  }
}

void sub_1016B5700(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }

  v4 = *(a1 + 8);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

uint64_t sub_1016B5800(void *a1, uint64_t a2)
{
  v3 = a1[6];
  if (v3)
  {
    v5 = a1[4];
    v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      v7 = v6;
      v8 = a1[5];
      if (v8 && *(a2 + 16) == 3)
      {
        v20 = "sysdiagnose state capture";
        v18 = 0;
        v19 = 0;
        sub_10000501C(&__p, "sysdiagnose state capture");
        Registry::createXpcJetsamAssertion();
        if (v17 < 0)
        {
          operator delete(__p);
        }

        v9 = *(v5 + 32);
        oslog = v9;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 136315138;
          *(&buf + 4) = "sysdiagnose state capture";
          _os_log_impl(&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Dumping state in response to: %s", &buf, 0xCu);
        }

        v14[0] = &oslog;
        v14[1] = v5;
        v14[2] = &v20;
        *&buf = _NSConcreteStackBlock;
        *(&buf + 1) = 0x40000000;
        v22 = sub_1016B9A04;
        v23 = &unk_101F61080;
        v24 = v8;
        v25 = v14;
        v10 = *(v8 + 16);
        if (*(v8 + 24))
        {
          dispatch_async_and_wait(v10, &buf);
        }

        else
        {
          dispatch_sync(v10, &buf);
        }

        sleep(1u);
        v11 = oslog;
        if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "State dump complete", &buf, 2u);
          v11 = oslog;
        }

        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buf) = 0;
          _os_log_debug_impl(&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Releasing jetsam assertion", &buf, 2u);
        }

        v12 = v19;
        v18 = 0;
        v19 = 0;
        if (v12)
        {
          sub_100004A34(v12);
          if (v19)
          {
            sub_100004A34(v19);
          }
        }
      }

      sub_100004A34(v7);
    }
  }

  return 0;
}

void sub_1016B5A44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20, std::__shared_weak_count *a21)
{
  if (a21)
  {
    sub_100004A34(a21);
  }

  sub_100004A34(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_1016B5A84(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 48);
  *(result + 40) = *(a2 + 40);
  *(result + 48) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 16), 1uLL, memory_order_relaxed);
  }

  return result;
}

void sub_1016B5AA0(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_1016B5AB0(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void sub_1016B5BFC(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, sub_1016B5CD0);
  __cxa_rethrow();
}

void sub_1016B5C3C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1016B5C90(uint64_t a1, uint64_t a2)
{
  {
    return a1;
  }

  else
  {
    return 0;
  }
}

void *sub_1016B5CD0(void *result)
{
  if (result)
  {
    v1 = result;
    ctu::OsLogLogger::~OsLogLogger((result + 18));
    v2 = v1[16];
    if (v2)
    {
      sub_100004A34(v2);
    }

    v3 = v1[14];
    if (v3)
    {
      sub_100004A34(v3);
    }

    v4 = v1[12];
    v1[12] = 0;
    if (v4)
    {
      sub_1016B5D6C(v4);
    }

    sub_1016B5AB0((v1 + 7));
    v5 = v1[6];
    if (v5)
    {
      sub_100004A34(v5);
    }

    ctu::OsLogLogger::~OsLogLogger((v1 + 4));
    sub_1000C0544(v1);

    operator delete();
  }

  return result;
}

void sub_1016B5D6C(uint64_t a1)
{
  v1 = *(a1 + 8);
  if (v1)
  {
    sub_100004A34(v1);
  }

  operator delete();
}

void sub_1016B5DDC(std::__shared_weak_count *a1)
{
  a1->__vftable = off_101F60A60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1016B5E30(uint64_t a1)
{
  sub_1010A779C(a1 + 408);
  sub_1010A6FC0(a1 + 376);
  sub_1010A6DC4(a1 + 344);
  v2 = *(a1 + 320);
  if (v2)
  {
    v3 = *(a1 + 328);
    v4 = *(a1 + 320);
    if (v3 != v2)
    {
      do
      {
        v5 = *(v3 - 8);
        if (v5)
        {
          sub_100004A34(v5);
        }

        v3 -= 16;
      }

      while (v3 != v2);
      v4 = *(a1 + 320);
    }

    *(a1 + 328) = v2;
    operator delete(v4);
  }

  v6 = *(a1 + 296);
  if (v6)
  {
    do
    {
      v7 = *v6;
      v8 = v6[4];
      if (v8)
      {
        sub_100004A34(v8);
      }

      operator delete(v6);
      v6 = v7;
    }

    while (v7);
  }

  v9 = *(a1 + 280);
  *(a1 + 280) = 0;
  if (v9)
  {
    operator delete(v9);
  }

  std::mutex::~mutex((a1 + 216));
  v10 = *(a1 + 208);
  if (v10)
  {
    sub_100004A34(v10);
  }

  v11 = *(a1 + 192);
  if (v11)
  {
    sub_100004A34(v11);
  }

  v12 = *(a1 + 176);
  if (v12)
  {
    sub_100004A34(v12);
  }

  v13 = *(a1 + 160);
  if (v13)
  {
    sub_100004A34(v13);
  }

  v14 = *(a1 + 144);
  if (v14)
  {
    sub_100004A34(v14);
  }

  v15 = *(a1 + 128);
  if (v15)
  {
    sub_100004A34(v15);
  }

  v16 = *(a1 + 112);
  if (v16)
  {
    sub_100004A34(v16);
  }

  v17 = *(a1 + 96);
  if (v17)
  {
    sub_100004A34(v17);
  }

  v18 = *(a1 + 80);
  if (v18)
  {
    sub_100004A34(v18);
  }

  v19 = *(a1 + 64);
  if (v19)
  {
    sub_100004A34(v19);
  }

  v20 = *(a1 + 48);
  if (v20)
  {
    sub_100004A34(v20);
  }

  v21 = *(a1 + 32);
  if (v21)
  {

    sub_100004A34(v21);
  }
}

void sub_1016B5F9C(uint64_t a1)
{
  v1 = **(a1 + 40);
  if (os_log_type_enabled(&_os_log_default, OS_LOG_TYPE_INFO))
  {
    CTGetRootVersionString();
    v2 = v5 >= 0 ? __p : __p[0];
    *buf = 136446210;
    *&buf[4] = v2;
    _os_log_impl(&_mh_execute_header, &_os_log_default, OS_LOG_TYPE_INFO, "Version: %{public}s", buf, 0xCu);
    if (v5 < 0)
    {
      operator delete(__p[0]);
    }
  }

  if (os_log_type_enabled(&_os_log_default, OS_LOG_TYPE_INFO))
  {
    LODWORD(__p[0]) = 136315138;
    *(__p + 4) = kCTProjectBuildRevision;
    _os_log_impl(&_mh_execute_header, &_os_log_default, OS_LOG_TYPE_INFO, "Build revision: %s", __p, 0xCu);
  }

  if (os_log_type_enabled(&_os_log_default, OS_LOG_TYPE_INFO))
  {
    LODWORD(__p[0]) = 136315138;
    *(__p + 4) = kCTProjectBuildReason;
    _os_log_impl(&_mh_execute_header, &_os_log_default, OS_LOG_TYPE_INFO, "Build reason: %s", __p, 0xCu);
  }

  *__p = 0uLL;
  Registry::getServiceManager(__p, *(v1 + 104));
  if (__p[0])
  {
    v3 = *(v1 + 8);
    if (v3)
    {
      if (std::__shared_weak_count::lock(v3))
      {
        operator new();
      }
    }

    sub_100013CC4();
  }

  if (__p[1])
  {
    sub_100004A34(__p[1]);
  }
}

void sub_1016B61DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
  {
    (*(*a13 + 8))(a13);
  }

  if (a10)
  {
    sub_100004A34(a10);
  }

  _Unwind_Resume(exception_object);
}

void sub_1016B6244(ServiceManager::Service *this)
{
  *this = off_101F60AD0;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1016B62A0(ServiceManager::Service *this)
{
  *this = off_101F60AD0;
  v2 = *(this + 2);
  if (v2)
  {
    sub_100004A34(v2);
  }

  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_1016B6320@<X0>(void *a1@<X8>)
{
  v2 = 2;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  return sub_1000FF040(a1, &v2, &vars0, 1);
}

void sub_1016B6364(uint64_t a1, dispatch_object_t *a2)
{
  v2 = *(a1 + 8);
  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1016B5700(v2, v3);
  }

  v4 = *(a1 + 8);

  sub_1016B5700(v4, 0);
}

void sub_1016B6404(uint64_t a1)
{
  v1 = *(*(a1 + 8) + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_1016B64E4(uint64_t a1, int a2, ServiceStage *this)
{
  v3 = *(a1 + 8);
  ServiceStage::holdOffStage(&group[1], this);
  v4 = *(v3 + 8);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4))
    {
      operator new();
    }
  }

  sub_100013CC4();
}

void sub_1016B6608(uint64_t ***a1)
{
  v1 = **a1;
  v2 = (v1 + 7);
  *&buf = off_101F60B70;
  *(&buf + 1) = v1 + 5;
  p_buf = &buf;
  if (&buf != (v1 + 7))
  {
    v3 = v1[10];
    if (v3 == v2)
    {
      __p[1] = v1 + 5;
      v15 = 0;
      __p[0] = off_101F60B70;
      p_buf = 0;
      (*(*v3 + 24))(v3, &buf);
      (*(*v1[10] + 32))(v1[10]);
      v1[10] = 0;
      p_buf = &buf;
      (*(__p[0] + 3))(__p, v2);
      (*(__p[0] + 4))(__p);
    }

    else
    {
      v1[7] = off_101F60B70;
      v1[8] = (v1 + 5);
      p_buf = v3;
    }

    v1[10] = v2;
  }

  sub_1016B5AB0(&buf);
  v4 = v1[10];
  if (v4)
  {
    (*(*v4 + 48))(v4, v1 + 11);
  }

  v5 = v1[1];
  if (v5)
  {
    v6 = *v1;
    v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      v8 = v7;
      p_shared_weak_owners = &v7->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_100004A34(v7);
      dispatch_get_global_queue(0, 0);
      *&buf = _NSConcreteStackBlock;
      *(&buf + 1) = 1174405120;
      v17 = sub_1016B5800;
      p_buf = &unk_101F609C0;
      v19 = v1;
      v20 = v6;
      v21 = v8;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      v1[19] = os_state_add_handler();
      if (v21)
      {
        std::__shared_weak_count::__release_weak(v21);
      }

      std::__shared_weak_count::__release_weak(v8);
      sub_10000501C(__p, "/cc/events/dump_state");
      *&buf = off_101F60C00;
      *(&buf + 1) = v1;
      p_buf = &buf;
      ctu::RestModule::observeEvent();
      sub_1000062D4(&buf);
      if (SHIBYTE(v15) < 0)
      {
        operator delete(__p[0]);
      }

      if (notify_register_check("com.apple.CoreTelephony.FeatureChanged", v1 + 34))
      {
        v10 = v1[4];
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 136315138;
          *(&buf + 4) = "com.apple.CoreTelephony.FeatureChanged";
          _os_log_error_impl(&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to create notify register check for notification '%s'", &buf, 0xCu);
        }
      }

      v11 = v1[1];
      if (v11)
      {
        v12 = std::__shared_weak_count::lock(v11);
        if (v12)
        {
          v13 = &v12->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_100004A34(v12);
          atomic_fetch_add_explicit(v13, 1uLL, memory_order_relaxed);
          sub_10000501C(__p, "/cc/props/baseband_asserted");
          operator new();
        }
      }
    }
  }

  sub_100013CC4();
}

void sub_1016B6AFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19)
{
  if (a2)
  {
    sub_10004F058(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1016B6C24(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F60B70;
  a2[1] = v2;
  return result;
}

void sub_1016B6C50(uint64_t a1, unsigned int *a2)
{
  v2 = xpc_int64_create(*a2);
  v3 = v2;
  if (!v2)
  {
    v2 = xpc_null_create();
    v3 = v2;
  }

  base_path = rest_service_state::get_base_path(v2);
  sub_10000501C(&__p, base_path);
  object = v3;
  if (v3)
  {
    xpc_retain(v3);
  }

  else
  {
    object = xpc_null_create();
  }

  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v7 < 0)
  {
    operator delete(__p);
  }

  xpc_release(v3);
}

void sub_1016B6D00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0)
  {
    operator delete(__p);
  }

  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_1016B6D48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t sub_1016B6E04(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = off_101F60C00;
  a2[1] = v2;
  return result;
}

void sub_1016B6E30(uint64_t a1)
{
  v1 = *(a1 + 8);
  v2 = *(v1 + 144);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *buf = 0;
    _os_log_impl(&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Dumping REST", buf, 2u);
  }

  sub_10000501C(&v11, "/connections");
  *buf = off_101F60C70;
  v14 = v1;
  v15 = buf;
  ctu::RestModule::getPropertyOnce();
  sub_1000062D4(buf);
  if (v12 < 0)
  {
    operator delete(v11);
  }