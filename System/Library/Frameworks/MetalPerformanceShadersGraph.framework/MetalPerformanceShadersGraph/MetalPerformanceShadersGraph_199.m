uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "There's no operation that defines operand 1 of castedOp0";
  v13 = 56;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.deconvolution' to have attribute 'stride' of type '::mlir::DenseIntElementsAttr'";
  v13 = 98;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.deconvolution' to have attribute 'dilation' of type '::mlir::DenseIntElementsAttr'";
  v13 = 100;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.deconvolution' to have attribute 'padding' of type '::mlir::DenseIntElementsAttr'";
  v13 = 99;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'out' failed to satisfy constraint: 'is FP16 value'";
  v13 = 60;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'w, w_out' failed to satisfy constraint: ''";
  v13 = 52;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'out, w_scale' failed to satisfy constraint: ''";
  v13 = 56;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'w, out' failed to satisfy constraint: ''";
  v13 = 50;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'kernel_scale' failed to satisfy constraint: 'is nullptr'";
  v13 = 66;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'kernel_zp' failed to satisfy constraint: 'is nullptr'";
  v13 = 63;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'kernel_palettized_LUT, kernel_mutable_palettized_LUT_offset' failed to satisfy constraint: 'is nullptr'";
  v13 = 113;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

void mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::~ANEC_DeconvInputGOC(mlir::anec::_anonymous_namespace_::ANEC_DeconvInputGOC *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_DeconvInputGOC *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v65[4] = *MEMORY[0x1E69E9840];
  v63 = v65;
  v65[0] = a2;
  v64 = 0x400000001;
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id)
  {
    v5 = a2;
  }

  else
  {
    v5 = 0;
  }

  ElementTypeOrSelf = *(*(v5 + 9) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&ElementTypeOrSelf);
  if (!DefiningOp)
  {
    v27 = *(a3 + 2);
    if (!v27 || !mlir::RewriterBase::Listener::classof(*(a3 + 2)))
    {
      goto LABEL_68;
    }

    v28 = *(v5 + 3);
LABEL_60:
    (*(*v27 + 88))(v27, v28, v29, &ElementTypeOrSelf);
LABEL_68:
    v34 = 0;
    goto LABEL_69;
  }

  if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
  {
    v7 = DefiningOp;
  }

  else
  {
    v7 = 0;
  }

  if (!v7)
  {
    v27 = *(a3 + 2);
    if (!v27)
    {
      goto LABEL_68;
    }

    v33 = DefiningOp;
    if (!mlir::RewriterBase::Listener::classof(v27))
    {
      goto LABEL_68;
    }

    v28 = *(v33 + 24);
    goto LABEL_60;
  }

  if ((*(v7 + 46) & 0x80) != 0)
  {
    v8 = *(v7 + 72);
    v9 = v8 + 32;
  }

  else
  {
    v8 = 0;
    v9 = 32;
  }

  v10 = v64;
  if (v64 >= HIDWORD(v64))
  {
    v54 = DefiningOp;
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v63, v65, v64 + 1, 8);
    DefiningOp = v54;
    v10 = v64;
  }

  v63[v10] = DefiningOp;
  LODWORD(v64) = v64 + 1;
  if ((*(v5 + 46) & 0x80) != 0)
  {
    if (!*(a2 + 47))
    {
LABEL_16:
      v67.var0 = "stride";
      v67.var1 = 6;
      InherentAttr = mlir::DictionaryAttr::get((a2 + 56), v67);
      goto LABEL_17;
    }
  }

  else if (!*(a2 + 47))
  {
    goto LABEL_16;
  }

  v66.var0 = "stride";
  v66.var1 = 6;
  InherentAttr = mlir::Operation::getInherentAttr(a2, v66);
  if ((v12 & 1) == 0)
  {
    goto LABEL_16;
  }

LABEL_17:
  if (!InherentAttr || !mlir::DenseIntElementsAttr::classof(InherentAttr))
  {
    v30 = *(a3 + 2);
    if (!v30 || !mlir::RewriterBase::Listener::classof(v30))
    {
      goto LABEL_68;
    }

    v31 = *(a2 + 3);
LABEL_67:
    (*(*v30 + 88))(v30, v31, v32, &ElementTypeOrSelf);
    goto LABEL_68;
  }

  if (!*(a2 + 47) || (v68.var0 = "dilation", v68.var1 = 8, v13 = mlir::Operation::getInherentAttr(a2, v68), (v14 & 1) == 0))
  {
    v69.var0 = "dilation";
    v69.var1 = 8;
    v13 = mlir::DictionaryAttr::get((a2 + 56), v69);
  }

  if (!v13 || !mlir::DenseIntElementsAttr::classof(v13))
  {
    v30 = *(a3 + 2);
    if (!v30 || !mlir::RewriterBase::Listener::classof(v30))
    {
      goto LABEL_68;
    }

    v31 = *(a2 + 3);
    goto LABEL_67;
  }

  if (!*(a2 + 47) || (v70.var0 = "padding", v70.var1 = 7, v15 = mlir::Operation::getInherentAttr(a2, v70), (v16 & 1) == 0))
  {
    v71.var0 = "padding";
    v71.var1 = 7;
    v15 = mlir::DictionaryAttr::get((a2 + 56), v71);
  }

  if (!v15 || !mlir::DenseIntElementsAttr::classof(v15))
  {
    v30 = *(a3 + 2);
    if (!v30 || !mlir::RewriterBase::Listener::classof(v30))
    {
      goto LABEL_68;
    }

    v31 = *(a2 + 3);
    goto LABEL_67;
  }

  if (!*(a2 + 47) || (v72.var0 = "padding_mode", v72.var1 = 12, v17 = mlir::Operation::getInherentAttr(a2, v72), (v18 & 1) == 0))
  {
    v73.var0 = "padding_mode";
    v73.var1 = 12;
    v17 = mlir::DictionaryAttr::get((a2 + 56), v73);
  }

  if (!v17 || (mlir::anec::PaddingModeAttr::classof(v17) & 1) == 0)
  {
    mlir::arith::AtomicRMWKindAttr::get(*(a3 + 1), 0);
  }

  if (!*(a2 + 47) || (v74.var0 = "groups", v74.var1 = 6, v19 = mlir::Operation::getInherentAttr(a2, v74), (v20 & 1) == 0))
  {
    v75.var0 = "groups";
    v75.var1 = 6;
    v19 = mlir::DictionaryAttr::get((a2 + 56), v75);
  }

  if (!v19 || *(*v19 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    IntegerType = mlir::Builder::getIntegerType(a3 + 1, 64, 0);
    mlir::Builder::getIntegerAttr(a3 + 8, IntegerType, 1);
  }

  if (!*(a2 + 47) || (v76.var0 = "channel_wise", v76.var1 = 12, mlir::Operation::getInherentAttr(a2, v76), (v22 & 1) == 0))
  {
    v77.var0 = "channel_wise";
    v77.var1 = 12;
    mlir::DictionaryAttr::get((a2 + 56), v77);
  }

  if (!*(a2 + 47) || (v78.var0 = "kernel_scale", v78.var1 = 12, v23 = mlir::Operation::getInherentAttr(a2, v78), (v24 & 1) == 0))
  {
    v79.var0 = "kernel_scale";
    v79.var1 = 12;
    v23 = mlir::DictionaryAttr::get((a2 + 56), v79);
  }

  if (v23)
  {
    v25 = v23;
    if (mlir::DenseFPElementsAttr::classof(v23))
    {
      v26 = v25;
    }

    else
    {
      v26 = 0;
    }
  }

  else
  {
    v26 = 0;
  }

  v57 = v26;
  if (!*(a2 + 47) || (v80.var0 = "kernel_zero_point", v80.var1 = 17, v36 = mlir::Operation::getInherentAttr(a2, v80), (v37 & 1) == 0))
  {
    v81.var0 = "kernel_zero_point";
    v81.var1 = 17;
    v36 = mlir::DictionaryAttr::get((a2 + 56), v81);
  }

  if (v36)
  {
    v38 = v36;
    if (mlir::DenseIntElementsAttr::classof(v36))
    {
      v39 = v38;
    }

    else
    {
      v39 = 0;
    }
  }

  else
  {
    v39 = 0;
  }

  v58 = v39;
  if (!*(a2 + 47) || (v82.var0 = "kernel_palettized_LUT", v82.var1 = 21, v40 = mlir::Operation::getInherentAttr(a2, v82), (v41 & 1) == 0))
  {
    v83.var0 = "kernel_palettized_LUT";
    v83.var1 = 21;
    v40 = mlir::DictionaryAttr::get((a2 + 56), v83);
  }

  if (v40)
  {
    v42 = v40;
    if (mlir::DenseElementsAttr::classof(v40))
    {
      v43 = v42;
    }

    else
    {
      v43 = 0;
    }
  }

  else
  {
    v43 = 0;
  }

  v56 = v43;
  if (!*(a2 + 47) || (v84.var0 = "kernel_mutable_palettized_LUT", v84.var1 = 29, mlir::Operation::getInherentAttr(a2, v84), (v44 & 1) == 0))
  {
    v85.var0 = "kernel_mutable_palettized_LUT";
    v85.var1 = 29;
    mlir::DictionaryAttr::get((a2 + 56), v85);
  }

  if (*(v5 + 9))
  {
    v45 = v5 - 16;
  }

  else
  {
    v45 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v45, 0);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf((*(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
  if (!mlir::Type::isF16(&ElementTypeOrSelf))
  {
    v30 = *(a3 + 2);
    if (!v30 || !mlir::RewriterBase::Listener::classof(v30))
    {
      goto LABEL_68;
    }

    v31 = *(a2 + 3);
    goto LABEL_67;
  }

  ElementTypeOrSelf = mlir::getElementTypeOrSelf((*(*(v8 + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
  if (mlir::Type::isF16(&ElementTypeOrSelf) && (*(v7 + 36) ? (v47 = v7 - 16) : (v47 = 0), v48 = mlir::detail::OpResultImpl::getNextResultAtOffset(v47, 0), *(*mlir::getElementTypeOrSelf((*(v48 + 8) & 0xFFFFFFFFFFFFFFF8)) + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id))
  {
  }

  else
  {
    v49 = *(v9 + 24);
    ElementTypeOrSelf = 0;
    v60 = 0;
    p_ElementTypeOrSelf = &ElementTypeOrSelf;
    v62 = v49;
    v50 = mlir::Value::getDefiningOp(&v62);
    if (v50 && (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&p_ElementTypeOrSelf, v50) & 1) != 0 && (mlir::ElementsAttr::isSplat(&ElementTypeOrSelf) & 1) != 0)
    {
      {
        if (*(*mlir::getElementTypeOrSelf((*(*(v8 + 24) + 8) & 0xFFFFFFFFFFFFFFF8)) + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
        {
LABEL_112:
          if (v57)
          {
          }

          else if (v58)
          {
          }

          else
          {
            if (!v56)
            {
              v55 = *(v63[1] + 24);
              ElementTypeOrSelf = *(*v63 + 24);
              v60 = v55;
              mlir::Builder::getFusedLoc(a3 + 1, &ElementTypeOrSelf, 2, 0);
            }
          }
        }

        else
        {
          if (*(v5 + 9))
          {
            v51 = v5 - 16;
          }

          else
          {
            v51 = 0;
          }

          v52 = mlir::detail::OpResultImpl::getNextResultAtOffset(v51, 0);
          while (1)
          {
            v52 = *v52;
            if (!v52)
            {
              break;
            }

            if (*(*(v52[2] + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
            {
              goto LABEL_112;
            }
          }
        }
      }

      else
      {
      }
    }

    else
    {
    }
  }

  v34 = v53;
LABEL_69:
  if (v63 != v65)
  {
    free(v63);
  }

  return v34;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#12}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "There's no operation that defines operand 0 of castedOp0";
  v13 = 56;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.deconvolution' to have attribute 'stride' of type '::mlir::DenseIntElementsAttr'";
  v13 = 98;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.deconvolution' to have attribute 'dilation' of type '::mlir::DenseIntElementsAttr'";
  v13 = 100;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.deconvolution' to have attribute 'padding' of type '::mlir::DenseIntElementsAttr'";
  v13 = 99;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'out' failed to satisfy constraint: 'is FP16 value'";
  v13 = 60;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'x, x_out' failed to satisfy constraint: ''";
  v13 = 52;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'x_scale' failed to satisfy constraint: 'splat constant value'";
  v13 = 71;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'x_bias' failed to satisfy constraint: 'is constant 0'";
  v13 = 63;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'x, out' failed to satisfy constraint: ''";
  v13 = 50;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'kernel_scale' failed to satisfy constraint: 'is nullptr'";
  v13 = 66;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'kernel_zp' failed to satisfy constraint: 'is nullptr'";
  v13 = 63;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#12}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'kernel_palettized_LUT, kernel_mutable_palettized_LUT_offset' failed to satisfy constraint: 'is nullptr'";
  v13 = 113;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

void mlir::anec::anonymous namespace::ANEC_GOCDiv::~ANEC_GOCDiv(mlir::anec::_anonymous_namespace_::ANEC_GOCDiv *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::anec::anonymous namespace::ANEC_GOCDiv::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_GOCDiv *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v57[4] = *MEMORY[0x1E69E9840];
  v55 = v57;
  v57[0] = a2;
  v56 = 0x400000001;
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id)
  {
    v5 = a2;
  }

  else
  {
    v5 = 0;
  }

  ElementTypeOrSelf = *(*(v5 + 9) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&ElementTypeOrSelf);
  if (!DefiningOp)
  {
    v7 = *(a3 + 2);
    if (!v7 || !mlir::RewriterBase::Listener::classof(*(a3 + 2)))
    {
      goto LABEL_13;
    }

    v9 = *(v5 + 3);
LABEL_12:
    (*(*v7 + 88))(v7, v9, v10, &ElementTypeOrSelf);
LABEL_13:
    v11 = 0;
    goto LABEL_14;
  }

  if (*(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
  {
    v7 = *(a3 + 2);
    if (!v7)
    {
      goto LABEL_13;
    }

    v8 = DefiningOp;
    if (!mlir::RewriterBase::Listener::classof(v7))
    {
      goto LABEL_13;
    }

    v9 = *(v8 + 24);
    goto LABEL_12;
  }

  v13 = v56;
  if (v56 >= HIDWORD(v56))
  {
    v47 = DefiningOp;
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v55, v57, v56 + 1, 8);
    DefiningOp = v47;
    v13 = v56;
  }

  v14 = DefiningOp;
  *(v55 + v13) = DefiningOp;
  LODWORD(v56) = v56 + 1;
  ElementTypeOrSelf = *(*(v5 + 9) + 56);
  v15 = mlir::Value::getDefiningOp(&ElementTypeOrSelf);
  if (!v15)
  {
    v7 = *(a3 + 2);
    if (!v7 || !mlir::RewriterBase::Listener::classof(*(a3 + 2)))
    {
      goto LABEL_13;
    }

    v9 = *(v5 + 3);
    goto LABEL_12;
  }

  v16 = v15;
  if (*(*(v15 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::Invert,void>::id)
  {
    v7 = *(a3 + 2);
    if (!v7 || !mlir::RewriterBase::Listener::classof(*(a3 + 2)))
    {
      goto LABEL_13;
    }

    v9 = *(v16 + 24);
    goto LABEL_12;
  }

  if ((*(v15 + 46) & 0x80) != 0)
  {
    v17 = *(v15 + 72);
    if (!*(v15 + 47))
    {
LABEL_30:
      v59.var0 = "epsilon";
      v59.var1 = 7;
      InherentAttr = mlir::DictionaryAttr::get((v16 + 56), v59);
      goto LABEL_31;
    }
  }

  else
  {
    v17 = 0;
    if (!*(v15 + 47))
    {
      goto LABEL_30;
    }
  }

  v58.var0 = "epsilon";
  v58.var1 = 7;
  InherentAttr = mlir::Operation::getInherentAttr(v15, v58);
  if ((v19 & 1) == 0)
  {
    goto LABEL_30;
  }

LABEL_31:
  if (!InherentAttr || *(*InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    v7 = *(a3 + 2);
    if (!v7 || !mlir::RewriterBase::Listener::classof(*(a3 + 2)))
    {
      goto LABEL_13;
    }

    v9 = *(v16 + 24);
    goto LABEL_12;
  }

  v20 = v56;
  if (v56 >= HIDWORD(v56))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v55, v57, v56 + 1, 8);
    v20 = v56;
  }

  *(v55 + v20) = v16;
  LODWORD(v56) = v56 + 1;
  if (*(v5 + 9))
  {
    v21 = v5 - 16;
  }

  else
  {
    v21 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v21, 0);
  v22 = mlir::Value::getDefiningOp(&NextResultAtOffset);
  v23 = (*(v22 - 8) & 0xFFFFFFFFFFFFFFF8);
  v49 = v17;
  if (v23)
  {
    v24 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v23 + 8);
  }

  else
  {
    v24 = 0;
  }

  ElementTypeOrSelf = v23;
  v52 = v24;
  v25 = *(v22 + 72);
  v26 = (*(*(v25 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v26)
  {
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v26 + 8);
    v25 = *(v22 + 72);
  }

  v27 = (*(*(v25 + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v27)
  {
    v28 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v27 + 8);
  }

  else
  {
    v28 = 0;
  }

  v50[0] = v27;
  v50[1] = v28;
  if (v23 != v26 || (ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v50), NumElements = mlir::ShapedType::getNumElements(ArgAttrsAttr, v30), NumElements != 1) && ((v38 = NumElements, mlir::CallableOpInterface::getArgAttrsAttr(&ElementTypeOrSelf), IndexFromDim = mlir::anec::getIndexFromDim(1, v39), (v41 & 1) == 0) || (v42 = IndexFromDim, mlir::CallableOpInterface::getArgAttrsAttr(v50), v43 <= v42) || *(mlir::CallableOpInterface::getArgAttrsAttr(v50) + 8 * v42) != v38))
  {
    v44 = *(a3 + 2);
    if (!v44 || !mlir::RewriterBase::Listener::classof(v44))
    {
      goto LABEL_13;
    }

    v45 = *(a2 + 3);
LABEL_71:
    (*(*v44 + 88))(v44, v45, v46, &ElementTypeOrSelf);
    goto LABEL_13;
  }

  if (*(v14 + 36))
  {
    v32 = v14 - 16;
  }

  else
  {
    v32 = 0;
  }

  v33 = mlir::detail::OpResultImpl::getNextResultAtOffset(v32, 0);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf((*(v33 + 8) & 0xFFFFFFFFFFFFFFF8));
  if (!mlir::Type::isF16(&ElementTypeOrSelf))
  {
    v44 = *(a3 + 2);
    if (!v44 || !mlir::RewriterBase::Listener::classof(v44))
    {
      goto LABEL_13;
    }

    v45 = *(a2 + 3);
    goto LABEL_71;
  }

  if (*(v16 + 36))
  {
    v34 = v16 - 16;
  }

  else
  {
    v34 = 0;
  }

  v35 = mlir::detail::OpResultImpl::getNextResultAtOffset(v34, 0);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf((*(v35 + 8) & 0xFFFFFFFFFFFFFFF8));
  if (!mlir::Type::isF16(&ElementTypeOrSelf))
  {
    v44 = *(a3 + 2);
    if (!v44 || !mlir::RewriterBase::Listener::classof(v44))
    {
      goto LABEL_13;
    }

    v45 = *(a2 + 3);
    goto LABEL_71;
  }

  ElementTypeOrSelf = *(v49 + 24);
  v36 = mlir::Value::getDefiningOp(&ElementTypeOrSelf);
  if (!v36)
  {
    goto LABEL_78;
  }

  {
    v48 = v36;
    v36 = v48;
  }

  if ((*(**(v36 + 48) + 32))(*(v36 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id))
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf((*(*(v49 + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
    if (mlir::Type::isF16(&ElementTypeOrSelf))
    {
      v37 = *(*(v55 + 1) + 24);
      ElementTypeOrSelf = *(*v55 + 24);
      v52 = v37;
      v53 = *(*(v55 + 2) + 24);
      mlir::Builder::getFusedLoc(a3 + 1, &ElementTypeOrSelf, 3, 0);
    }
  }

  else
  {
LABEL_78:
  }

LABEL_14:
  if (v55 != v57)
  {
    free(v55);
  }

  return v11;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::anec::anonymous namespace::fuseGOCs(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, int a8, uint64_t a9)
{
  v103 = *MEMORY[0x1E69E9840];
  v83 = a3;
  v84 = a2;
  v82 = a9;
  v15 = (*(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v15)
  {
    v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8);
  }

  else
  {
    v16 = 0;
  }

  v81[0] = v15;
  v81[1] = v16;
  v66 = *(mlir::Value::getDefiningOp(&v83) + 24);
  v79 = 0;
  v80 = 0;
  v77 = 0;
  v78 = 0;
  v75 = 0;
  v76 = 0;
  v73 = 0;
  v74 = 0;
  if (a4)
  {
    v71[0] = &v79;
    v85 = a4;
    DefiningOp = mlir::Value::getDefiningOp(&v85);
    if (DefiningOp)
    {
      mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(v71, DefiningOp);
    }
  }

  if (a5)
  {
    v71[0] = &v77;
    v85 = a5;
    v18 = mlir::Value::getDefiningOp(&v85);
    if (v18)
    {
      mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(v71, v18);
    }
  }

  if (a6)
  {
    v71[0] = &v75;
    v85 = a6;
    v19 = mlir::Value::getDefiningOp(&v85);
    if (v19)
    {
      mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(v71, v19);
    }
  }

  if (a7)
  {
    v71[0] = &v73;
    v85 = a7;
    v20 = mlir::Value::getDefiningOp(&v85);
    if (v20)
    {
      mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(v71, v20);
    }
  }

  if (v82)
  {
    mlir::FloatAttr::getValue(&v82, &v85);
    v21 = llvm::APFloat::convertToFloat(&v85);
    v22 = v86[0];
    if (llvm::APFloatBase::PPCDoubleDouble(v23) == v22)
    {
      llvm::detail::DoubleAPFloat::~DoubleAPFloat(v86);
    }

    else
    {
      llvm::detail::IEEEFloat::~IEEEFloat(v86);
    }
  }

  else
  {
    v21 = 0.0;
  }

  mlir::CallableOpInterface::getArgAttrsAttr(v81);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v24);
  v26 = *(mlir::CallableOpInterface::getArgAttrsAttr(v81) + 8 * IndexFromDim);
  v100 = v102;
  v101 = 0xC00000000;
  if (v79)
  {
    mlir::getFloatValues<float>(v79, v80, &v100, 0);
  }

  else
  {
    v102[0] = 1065353216;
    LODWORD(v101) = 1;
  }

  v97 = v99;
  v98 = 0xC00000000;
  if (v77)
  {
    mlir::getFloatValues<float>(v77, v78, &v97, 0);
  }

  else
  {
    v99[0] = 0;
    LODWORD(v98) = 1;
  }

  v94 = v96;
  v95 = 0xC00000000;
  if (v75)
  {
    mlir::getFloatValues<float>(v75, v76, &v94, 0);
  }

  else
  {
    v96[0] = 1065353216;
    LODWORD(v95) = 1;
  }

  v91 = v93;
  v92 = 0xC00000000;
  if (v73)
  {
    mlir::getFloatValues<float>(v73, v74, &v91, 0);
    v27 = v92 == 1;
  }

  else
  {
    v27 = 1;
    v93[0] = 0;
    LODWORD(v92) = 1;
  }

  v30 = v101 == 1 && v98 == 1 && v95 == 1;
  if (v30 && v27)
  {
    v26 = 1;
  }

  mlir::CallableOpInterface::getArgAttrsAttr(v81);
  v32 = v31;
  __b = v90;
  v89 = 6;
  if (v31 < 7)
  {
    if (v31)
    {
      memset_pattern16(v90, &unk_1E096FAE0, 8 * v31);
    }

    v33 = v90;
  }

  else
  {
    v88 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod(&__b, v90, v31, 8);
    v33 = __b;
    memset_pattern16(__b, &unk_1E096FAE0, 8 * v32);
  }

  v88 = v32;
  v33[IndexFromDim] = v26;
  F32Type = mlir::Builder::getF32Type((a1 + 8), v31);
  v35 = mlir::RankedTensorType::get(v33, v32, F32Type, 0);
  v36 = __b;
  v37 = v88;
  F16Type = mlir::Builder::getF16Type((a1 + 8), v38);
  v72 = mlir::MemRefType::get(v36, v37, F16Type, 0, 0, 0);
  if (v35)
  {
    v40 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v35 + 8);
    mlir::mps::CPUNDArray::CPUNDArray(&v85, v35, v40, 0);
    v41 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v35 + 8);
  }

  else
  {
    mlir::mps::CPUNDArray::CPUNDArray(&v85, 0, 0, 0);
    v41 = 0;
  }

  mlir::mps::CPUNDArray::CPUNDArray(v71, v35, v41, 0);
  if (v26)
  {
    v42 = 0;
    v43 = v86[4];
    v44 = v71[5];
    v45 = v101;
    v46 = v100;
    v47 = v98;
    v48 = v97;
    v49 = v95;
    v50 = v94;
    v51 = v92;
    v52 = v91;
    do
    {
      if (v45 == 1)
      {
        v56 = 0;
      }

      else
      {
        v56 = v42;
      }

      v57 = v46[v56];
      if (v47 == 1)
      {
        v58 = 0;
      }

      else
      {
        v58 = v42;
      }

      if (v49 == 1)
      {
        v59 = 0;
      }

      else
      {
        v59 = v42;
      }

      v60 = v50[v59];
      if (v51 == 1)
      {
        v61 = 0;
      }

      else
      {
        v61 = v42;
      }

      if (a8)
      {
        v53 = v57 / (v21 + v60);
      }

      else
      {
        v53 = v57 * v60;
      }

      v54 = v48[v58];
      v55 = v52[v61];
      *(v43 + 4 * v42) = v53;
      v44[v42++] = v54 + (v55 / v57);
    }

    while (v26 != v42);
  }

  ElementsAttr = mlir::mps::CPUNDArray::getElementsAttr(&v85, 0, 1);
  v69 = v62;
  v70 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::ElementsAttr &>((a1 + 8), v66, &v72, &ElementsAttr);
  ElementsAttr = mlir::mps::CPUNDArray::getElementsAttr(v71, 0, 1);
  v69 = v63;
  v67 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::ElementsAttr &>((a1 + 8), v66, &v72, &ElementsAttr);
  v64 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>((a1 + 8), v66, v81, &v84, &v70, &v67);
  mlir::mps::CPUNDArray::~CPUNDArray(v71);
  mlir::mps::CPUNDArray::~CPUNDArray(&v85);
  if (__b != v90)
  {
    free(__b);
  }

  if (v91 != v93)
  {
    free(v91);
  }

  if (v94 != v96)
  {
    free(v94);
  }

  if (v97 != v99)
  {
    free(v97);
  }

  if (v100 != v102)
  {
    free(v100);
  }

  return v64 - 16;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "There's no operation that defines operand 0 of castedOp0";
  v13 = 56;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "castedOp1 is not ::mlir::anec::GOC type";
  v13 = 39;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "There's no operation that defines operand 1 of castedOp0";
  v13 = 56;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "castedOp1 is not ::mlir::anec::Invert type";
  v13 = 42;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.invert' to have attribute 'epsilon' of type '::mlir::FloatAttr'";
  v13 = 81;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'mult' failed to satisfy constraint: 'splat constant value'";
  v13 = 68;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'goc' failed to satisfy constraint: 'is FP16 value'";
  v13 = 60;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'inv' failed to satisfy constraint: 'is FP16 value'";
  v13 = 60;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'quotient' failed to satisfy constraint: 'constant value'";
  v13 = 66;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'quotient' failed to satisfy constraint: 'is FP16 value'";
  v13 = 65;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

uint64_t mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, void *a5, void *a6)
{
  v21[38] = *MEMORY[0x1E69E9840];
  v18 = a2;
  Context = mlir::Attribute::getContext(&v18);
  v13 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id, Context);
  if ((v14 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::anec::GOC,mlir::MemRefType,mlir::Value &,mlir::Value &,mlir::Value &>(v21, v20, v19);
  }

  mlir::OperationState::OperationState(v21, a2, v13);
  mlir::anec::GOC::build(a1, v21, *a3, *a4, *a5 - 16, *a6 - 16);
  v15 = mlir::OpBuilder::create(a1, v21);
  if (*(*(v15 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
  {
    v16 = v15;
  }

  else
  {
    v16 = 0;
  }

  mlir::OperationState::~OperationState(v21);
  return v16;
}

void mlir::anec::anonymous namespace::ANEC_GOCGOC::~ANEC_GOCGOC(mlir::anec::_anonymous_namespace_::ANEC_GOCGOC *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::anec::anonymous namespace::ANEC_GOCGOC::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_GOCGOC *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v54[4] = *MEMORY[0x1E69E9840];
  v52 = v54;
  v54[0] = a2;
  v53 = 0x400000001;
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
  {
    v5 = a2;
  }

  else
  {
    v5 = 0;
  }

  v50 = *(*(v5 + 9) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v50);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    {
      v7 = *(a3 + 2);
      if (v7)
      {
        v8 = DefiningOp;
        if (mlir::RewriterBase::Listener::classof(v7))
        {
          v9 = *(v8 + 24);
LABEL_12:
          (*(*v7 + 88))(v7, v9, v10, &v50);
          goto LABEL_13;
        }
      }

      goto LABEL_13;
    }

    v12 = v53;
    if (v53 >= HIDWORD(v53))
    {
      v43 = DefiningOp;
      llvm::SmallVectorBase<unsigned int>::grow_pod(&v52, v54, v53 + 1, 8);
      DefiningOp = v43;
      v12 = v53;
    }

    v52[v12] = DefiningOp;
    LODWORD(v53) = v53 + 1;
    if ((*(v5 + 46) & 0x80) != 0)
    {
      v13 = *(v5 + 9);
      v14 = v13 + 32;
    }

    else
    {
      v13 = 0;
      v14 = 32;
    }

    if (*(DefiningOp + 36))
    {
      v15 = DefiningOp - 16;
    }

    else
    {
      v15 = 0;
    }

    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0);
    if (*(v5 + 9))
    {
      v17 = v5 - 16;
    }

    else
    {
      v17 = 0;
    }

    v18 = mlir::detail::OpResultImpl::getNextResultAtOffset(v17, 0);
    v19 = *(v14 + 24);
    v20 = *(v13 + 88);
    v48 = NextResultAtOffset;
    v21 = *(mlir::Value::getDefiningOp(&v48) + 72);
    v22 = *(v21 + 56);
    v23 = *(v21 + 88);
    v49[0] = 0;
    v49[1] = 0;
    v47[0] = 0;
    v47[1] = 0;
    v46[0] = 0;
    v46[1] = 0;
    v45[0] = 0;
    v45[1] = 0;
    v44 = v49;
    v50 = v22;
    v24 = mlir::Value::getDefiningOp(&v50);
    if (v24)
    {
      mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v44, v24);
    }

    v44 = v47;
    v50 = v23;
    v25 = mlir::Value::getDefiningOp(&v50);
    if (v25)
    {
      mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v44, v25);
    }

    v44 = v46;
    v50 = v19;
    v26 = mlir::Value::getDefiningOp(&v50);
    if (v26)
    {
      mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v44, v26);
    }

    v44 = v45;
    v50 = v20;
    v27 = mlir::Value::getDefiningOp(&v50);
    if (v27)
    {
      mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v44, v27);
    }

    v28 = v48;
    v29 = *v48;
    if (*v48)
    {
      while (v29[2] - 16 == v18)
      {
        v29 = *v29;
        if (!v29)
        {
          goto LABEL_45;
        }
      }

      if (mlir::ElementsAttr::isSplat(v49))
      {
        isSplat = mlir::ElementsAttr::isSplat(v47);
      }

      else
      {
        isSplat = 0;
      }

      v31 = mlir::ElementsAttr::isSplat(v46);
      if (v31)
      {
        v31 = mlir::ElementsAttr::isSplat(v45);
      }

      if (isSplat != v31)
      {
        goto LABEL_64;
      }

      v28 = v48;
    }

LABEL_45:
    v32 = (v28[1] & 0xFFFFFFFFFFFFFFF8);
    if (v32)
    {
      v33 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v32 + 8);
    }

    else
    {
      v33 = 0;
    }

    v50 = v32;
    v51[0] = v33;
    if (*(*mlir::ElementsAttr::isSplat(&v50) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    {
      goto LABEL_49;
    }

    v35 = (*(v18 + 8) & 0xFFFFFFFFFFFFFFF8);
    v36 = v35 ? mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v35 + 8) : 0;
    v50 = v35;
    v51[0] = v36;
    if (*(*mlir::ElementsAttr::isSplat(&v50) + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id && mlir::ElementsAttr::isSplat(v46) && (mlir::ElementsAttr::isSplat(v45) & 1) != 0)
    {
      mlir::ElementsAttr::getSplatValue<llvm::APFloat>(v46, &v50);
      v37 = llvm::APFloat::convertToFloat(&v50);
      v38 = v51[0];
      v40 = llvm::APFloatBase::PPCDoubleDouble(v39);
      if (v40 == v38)
      {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v51);
      }

      else
      {
        llvm::detail::IEEEFloat::~IEEEFloat(v51);
      }

      mlir::ElementsAttr::getSplatValue<llvm::APFloat>(v45, &v50);
      v41 = llvm::APFloat::convertToFloat(&v50);
      if (v40 == v51[0])
      {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v51);
      }

      else
      {
        llvm::detail::IEEEFloat::~IEEEFloat(v51);
      }

      if (v37 == 1.0 && v41 == v41)
      {
LABEL_49:
        v34 = *(v52[1] + 24);
        v50 = *(*v52 + 24);
        v51[0] = v34;
        mlir::Builder::getFusedLoc(a3 + 1, &v50, 2, 0);
      }
    }

LABEL_64:
    v42 = *(a3 + 2);
    if (v42 && mlir::RewriterBase::Listener::classof(v42))
    {
    }

    goto LABEL_13;
  }

  v7 = *(a3 + 2);
  if (v7 && mlir::RewriterBase::Listener::classof(*(a3 + 2)))
  {
    v9 = *(v5 + 3);
    goto LABEL_12;
  }

LABEL_13:
  if (v52 != v54)
  {
    free(v52);
  }

  return 0;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "There's no operation that defines operand 0 of castedOp0";
  v13 = 56;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "castedOp1 is not ::mlir::anec::GOC type";
  v13 = 39;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'goc1, goc2, scale2, bias2' failed to satisfy constraint: ''";
  v13 = 69;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

void mlir::anec::anonymous namespace::ANEC_GOCRelu::~ANEC_GOCRelu(mlir::anec::_anonymous_namespace_::ANEC_GOCRelu *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::anec::anonymous namespace::ANEC_GOCRelu::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_GOCRelu *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v78[4] = *MEMORY[0x1E69E9840];
  v76 = v78;
  v78[0] = a2;
  v77 = 0x400000001;
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
  {
    v5 = a2;
  }

  else
  {
    v5 = 0;
  }

  ArgOperands = *(*(v5 + 9) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&ArgOperands);
  if (DefiningOp)
  {
    v7 = *(*(DefiningOp + 48) + 16);
    if (v7 == &mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id)
    {
      v8 = DefiningOp;
    }

    else
    {
      v8 = 0;
    }

    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id)
    {
      v9 = *(a3 + 2);
      if (v9)
      {
        v10 = DefiningOp;
        if (mlir::RewriterBase::Listener::classof(v9))
        {
          v11 = *(v10 + 24);
LABEL_15:
          (*(*v9 + 88))(v9, v11, v12, &ArgOperands);
          goto LABEL_154;
        }
      }

      goto LABEL_154;
    }

    if ((*(DefiningOp + 46) & 0x80) != 0)
    {
      v13 = *(DefiningOp + 72);
    }

    else
    {
      v13 = 0;
    }

    v14 = v77;
    if (v77 >= HIDWORD(v77))
    {
      v62 = DefiningOp;
      llvm::SmallVectorBase<unsigned int>::grow_pod(&v76, v78, v77 + 1, 8);
      DefiningOp = v62;
      v14 = v77;
    }

    v76[v14] = DefiningOp;
    LODWORD(v77) = v77 + 1;
    if ((*(v5 + 46) & 0x80) != 0)
    {
      v15 = *(v5 + 9);
      v16 = v15 + 32;
    }

    else
    {
      v15 = 0;
      v16 = 32;
    }

    ArgOperands = *(v13 + 24);
    v17 = mlir::Value::getDefiningOp(&ArgOperands);
    if (!v17 || *(*(v17 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    {
      v18 = *(a3 + 2);
      if (!v18 || !mlir::RewriterBase::Listener::classof(v18))
      {
        goto LABEL_154;
      }

      v19 = *(a2 + 3);
      goto LABEL_153;
    }

    v21 = *(v16 + 24);
    v74 = 0;
    v75 = 0;
    v73 = &v74;
    ArgOperands = v21;
    v22 = mlir::Value::getDefiningOp(&ArgOperands);
    if (!v22 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v73, v22))
    {
      goto LABEL_150;
    }

    ArgOperands = mlir::CallOpInterface::getArgOperands(&v74);
    v71 = v23;
    v24 = *(*mlir::ElementsAttr::isSplat(&ArgOperands) + 136);
    if (v24 == &mlir::detail::TypeIDResolver<mlir::Float4E2M1FNType,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float6E2M3FNType,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float6E3M2FNType,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3Type,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float8E3M4Type,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id || v24 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
    {
      ArgOperands = v72;
      v71 = 0xC00000000;
      mlir::getFloatValues<float>(v74, v75, &ArgOperands, 0);
      if (v71)
      {
        v31 = 4 * v71 - 4;
        v32 = ArgOperands;
        do
        {
          v33 = *v32++;
          v34 = v33 >= 0.0;
          v35 = v33 < 0.0 || v31 == 0;
          v31 -= 4;
        }

        while (!v35);
      }

      else
      {
        v34 = 1;
      }

      if (ArgOperands != v72)
      {
        free(ArgOperands);
      }

      if (!v34)
      {
        goto LABEL_150;
      }
    }

    else
    {
      ArgOperands = mlir::CallOpInterface::getArgOperands(&v74);
      v71 = v25;
      if (*(*mlir::ElementsAttr::isSplat(&ArgOperands) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      {
        goto LABEL_150;
      }

      ArgOperands = v72;
      v71 = 0xC00000000;
      mlir::getFloatValues<float>(v74, v75, &ArgOperands, 0);
      if (v71)
      {
        v26 = 4 * v71 - 4;
        v27 = ArgOperands;
        do
        {
          v28 = *v27++;
          v29 = v28 >= 0.0;
          v30 = v28 < 0.0 || v26 == 0;
          v26 -= 4;
        }

        while (!v30);
      }

      else
      {
        v29 = 1;
      }

      if (ArgOperands != v72)
      {
        free(ArgOperands);
      }

      if (!v29)
      {
LABEL_150:
        v18 = *(a3 + 2);
        if (!v18 || !mlir::RewriterBase::Listener::classof(v18))
        {
          goto LABEL_154;
        }

        v19 = *(a2 + 3);
        goto LABEL_153;
      }
    }

    v36 = *(v15 + 88);
    v74 = 0;
    v75 = 0;
    v73 = &v74;
    ArgOperands = v36;
    v37 = mlir::Value::getDefiningOp(&ArgOperands);
    if (!v37 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v73, v37))
    {
      goto LABEL_161;
    }

    ArgOperands = mlir::CallOpInterface::getArgOperands(&v74);
    v71 = v38;
    v39 = *(*mlir::ElementsAttr::isSplat(&ArgOperands) + 136);
    v53 = v39 == &mlir::detail::TypeIDResolver<mlir::Float4E2M1FNType,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::Float6E2M3FNType,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::Float6E3M2FNType,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3Type,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::Float8E3M4Type,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id;
    if (v53 || v39 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id || v39 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
    {
      ArgOperands = v72;
      v71 = 0xC00000000;
      mlir::getFloatValues<float>(v74, v75, &ArgOperands, 0);
      if (v71)
      {
        v54 = 4 * v71 - 4;
        v55 = ArgOperands;
        do
        {
          v56 = *v55++;
          v57 = v56 == 0.0;
          v58 = v56 != 0.0 || v54 == 0;
          v54 -= 4;
        }

        while (!v58);
      }

      else
      {
        v57 = 1;
      }

      if (ArgOperands != v72)
      {
        free(ArgOperands);
      }

      if (!v57)
      {
        goto LABEL_161;
      }
    }

    else
    {
      ArgOperands = mlir::CallOpInterface::getArgOperands(&v74);
      v71 = v63;
      if (*(*mlir::ElementsAttr::isSplat(&ArgOperands) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      {
        goto LABEL_161;
      }

      ArgOperands = v72;
      v71 = 0xC00000000;
      mlir::getFloatValues<float>(v74, v75, &ArgOperands, 0);
      if (v71)
      {
        v64 = 4 * v71 - 4;
        v65 = ArgOperands;
        do
        {
          v66 = *v65++;
          v67 = v66 == 0.0;
          v68 = v66 != 0.0 || v64 == 0;
          v64 -= 4;
        }

        while (!v68);
      }

      else
      {
        v67 = 1;
      }

      if (ArgOperands != v72)
      {
        free(ArgOperands);
      }

      if (!v67)
      {
LABEL_161:
        v18 = *(a3 + 2);
        if (!v18 || !mlir::RewriterBase::Listener::classof(v18))
        {
          goto LABEL_154;
        }

        v19 = *(a2 + 3);
        goto LABEL_153;
      }
    }

    if (*(v8 + 36))
    {
      v59 = v8 - 16;
    }

    else
    {
      v59 = 0;
    }

    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v59, 0);
    ArgOperands = mlir::getElementTypeOrSelf((*(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
    if (mlir::Type::isF16(&ArgOperands))
    {
      v61 = *(v76[1] + 24);
      ArgOperands = *(*v76 + 24);
      v71 = v61;
      mlir::Builder::getFusedLoc(a3 + 1, &ArgOperands, 2, 0);
    }

    v18 = *(a3 + 2);
    if (!v18 || !mlir::RewriterBase::Listener::classof(v18))
    {
      goto LABEL_154;
    }

    v19 = *(a2 + 3);
LABEL_153:
    (*(*v18 + 88))(v18, v19, v20, &ArgOperands);
    goto LABEL_154;
  }

  v9 = *(a3 + 2);
  if (v9 && mlir::RewriterBase::Listener::classof(*(a3 + 2)))
  {
    v11 = *(v5 + 3);
    goto LABEL_15;
  }

LABEL_154:
  if (v76 != v78)
  {
    free(v76);
  }

  return 0;
}

uint64_t mlir::OpBuilder::create<mlir::anec::GOC,mlir::Value &,mlir::Value &,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v19[38] = *MEMORY[0x1E69E9840];
  v16 = a2;
  Context = mlir::Attribute::getContext(&v16);
  v11 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id, Context);
  if ((v12 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::anec::GOC,mlir::MemRefType,mlir::Value &,mlir::Value &,mlir::Value &>(v19, v18, v17);
  }

  mlir::OperationState::OperationState(v19, a2, v11);
  mlir::anec::GOC::build(a1, v19, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, v19);
  if (*(*(v13 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
  {
    v14 = v13;
  }

  else
  {
    v14 = 0;
  }

  mlir::OperationState::~OperationState(v19);
  return v14;
}

uint64_t mlir::OpBuilder::create<mlir::anec::Relu,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v19[5] = *MEMORY[0x1E69E9840];
  v16 = a2;
  Context = mlir::Attribute::getContext(&v16);
  v11 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id, Context);
  if ((v12 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::anec::Relu,mlir::ValueRange,mlir::NamedAttrList &>(v17, v19, v18);
  }

  mlir::OperationState::OperationState(v17, a2, v11);
  mlir::ValueRange::ValueRange(v19, *a3, *(a3 + 8));
  mlir::ValueRange::ValueRange(v18, *a4, *(a4 + 8));
  mlir::arith::ExtSIOp::build(a1, v17, v19[0], v19[1], v18[0], v18[1], *a5, *(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, v17);
  if (*(*(v13 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id)
  {
    v14 = v13;
  }

  else
  {
    v14 = 0;
  }

  mlir::OperationState::~OperationState(v17);
  return v14;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCRelu::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "There's no operation that defines operand 0 of castedOp0";
  v13 = 56;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCRelu::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "castedOp1 is not ::mlir::anec::Relu type";
  v13 = 40;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCRelu::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'x' failed to satisfy constraint: 'is GOC input'";
  v13 = 57;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCRelu::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'scale' failed to satisfy constraint: 'is constant >= 0'";
  v13 = 65;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCRelu::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'bias' failed to satisfy constraint: 'is constant 0'";
  v13 = 61;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCRelu::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'relu_out' failed to satisfy constraint: 'is FP16 value'";
  v13 = 65;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

void mlir::anec::anonymous namespace::CanonicalizeConcat::~CanonicalizeConcat(mlir::anec::_anonymous_namespace_::CanonicalizeConcat *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpBuilder::create<mlir::anec::Concat,llvm::SmallVector<mlir::Value,6u> &,unsigned long long,BOOL>(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned __int8 *a5)
{
  v19[5] = *MEMORY[0x1E69E9840];
  v16 = a2;
  Context = mlir::Attribute::getContext(&v16);
  v11 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::anec::Concat,void>::id, Context);
  if ((v12 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::anec::Concat,mlir::ValueRange,unsigned long long &,BOOL>(v18, v19, v17);
  }

  mlir::OperationState::OperationState(v18, a2, v11);
  mlir::ValueRange::ValueRange(v19, *a3, *(a3 + 8));
  mlir::anec::Concat::build(a1, v18, v19[0], v19[1], *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, v18);
  if (*(*(v13 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Concat,void>::id)
  {
    v14 = v13;
  }

  else
  {
    v14 = 0;
  }

  mlir::OperationState::~OperationState(v18);
  return v14;
}

uint64_t mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::anec::Concat &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, void *a4, void *a5, void *a6)
{
  v21[38] = *MEMORY[0x1E69E9840];
  v18 = a2;
  Context = mlir::Attribute::getContext(&v18);
  v13 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id, Context);
  if ((v14 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::anec::GOC,mlir::MemRefType,mlir::Value &,mlir::Value &,mlir::Value &>(v21, v20, v19);
  }

  mlir::OperationState::OperationState(v21, a2, v13);
  mlir::anec::GOC::build(a1, v21, *a3, *a4 - 16, *a5 - 16, *a6 - 16);
  v15 = mlir::OpBuilder::create(a1, v21);
  if (*(*(v15 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
  {
    v16 = v15;
  }

  else
  {
    v16 = 0;
  }

  mlir::OperationState::~OperationState(v21);
  return v16;
}

void mlir::anec::anonymous namespace::ANECLegacyQuantizationCanonicalizationPass::~ANECLegacyQuantizationCanonicalizationPass(mlir::anec::_anonymous_namespace_::ANECLegacyQuantizationCanonicalizationPass *this)
{
  *this = &unk_1F5B01A70;
  v2 = *(this + 39);
  if (v2)
  {
    *(this + 40) = v2;
    operator delete(v2);
  }

  if (*(this + 73))
  {
    v3 = *(this + 72);
    if (v3)
    {
      v4 = 0;
      do
      {
        v5 = *(*(this + 35) + v4);
        if (v5 != -8 && v5 != 0)
        {
          llvm::deallocate_buffer(v5, (*v5 + 17));
        }

        v4 += 8;
      }

      while (8 * v3 != v4);
    }
  }

  free(*(this + 35));
  v7 = *(this + 29);
  if (v7 != this + 248)
  {
    free(v7);
  }

  v8 = *(this + 23);
  if (v8 != this + 200)
  {
    free(v8);
  }

  v9 = *(this + 16);
  if (v9)
  {
    *(this + 17) = v9;
    operator delete(v9);
  }

  if (*(this + 120) == 1)
  {
    v10 = *(this + 8);
    if (v10 != *(this + 7))
    {
      free(v10);
    }
  }
}

{

  operator delete(v1);
}

void mlir::anec::anonymous namespace::ANECLegacyQuantizationCanonicalizationPass::runOnOperation(mlir::anec::_anonymous_namespace_::ANECLegacyQuantizationCanonicalizationPass *this)
{
  v37 = *MEMORY[0x1E69E9840];
  Context = mlir::Attribute::getContext(((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 24));
  *__p = 0u;
  *v24 = 0u;
  v25 = &v27;
  v26 = 0x600000000;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0x2800000000;
  v34 = 0;
  v35 = 0;
  v36 = 0x2800000000;
  mlir::anec::getANECCanonicalizeQuantPatterns(&Context);
  v2 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(v15, &Context, 0, 0, 0, 0);
  v3 = *(v2 + 44);
  if ((v3 & 0x7FFFFF) != 0)
  {
    v4 = (((v2 + 16 * ((v3 >> 23) & 1) + ((v3 >> 21) & 0x7F8) + 64) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v2 + 40));
    v21 = 0;
    v16 = 0x200000000;
    v17 = xmmword_1E097BBC0;
    v19 = 0;
    v20 = 0;
    v18 = 0;
    mlir::applyPatternsAndFoldGreedily(v4, v15, &v16, &v21);
  }

  std::shared_ptr<MPSKernelDAG>::~shared_ptr[abi:ne200100](v15);
  if (HIDWORD(v35) && v35)
  {
    v5 = 0;
    do
    {
      v6 = *(v34 + v5);
      if (v6 != -8 && v6 != 0)
      {
        v8 = *v6;
        v9 = *(v6 + 4);
        if (v9 == (v6 + 8))
        {
          (*(*v9 + 32))(v9);
        }

        else if (v9)
        {
          (*(*v9 + 40))(v9);
        }

        llvm::deallocate_buffer(v6, (v8 + 41));
      }

      v5 += 8;
    }

    while (8 * v35 != v5);
  }

  free(v34);
  if (HIDWORD(v32) && v32)
  {
    v10 = 0;
    do
    {
      v11 = *(v31 + v10);
      if (v11 != -8 && v11 != 0)
      {
        v13 = *v11;
        v14 = *(v11 + 4);
        if (v14 == (v11 + 8))
        {
          (*(*v14 + 32))(v14);
        }

        else if (v14)
        {
          (*(*v14 + 40))(v14);
        }

        llvm::deallocate_buffer(v11, (v13 + 41));
      }

      v10 += 8;
    }

    while (8 * v32 != v10);
  }

  free(v31);
  llvm::deallocate_buffer(v28, (16 * v30));
}

double mlir::anec::ANECLegacyQuantizationCanonicalizationBase<mlir::anec::anonymous namespace::ANECLegacyQuantizationCanonicalizationPass>::clonePass@<D0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v4 = operator new(0x158uLL);
  v5 = *(a1 + 8);
  v4[1] = *(a1 + 16);
  *(v4 + 4) = *(a1 + 32);
  *(v4 + 1) = v5;
  *(v4 + 40) = 0;
  *(v4 + 120) = 0;
  result = 0.0;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  *(v4 + 22) = 0;
  *(v4 + 23) = v4 + 200;
  *(v4 + 24) = 0x400000000;
  *(v4 + 29) = v4 + 248;
  *(v4 + 30) = 0x400000000;
  *(v4 + 35) = 0;
  *(v4 + 36) = 0;
  *(v4 + 74) = 0;
  *(v4 + 75) = 16;
  v4[19] = 0u;
  v4[20] = 0u;
  *(v4 + 42) = 0;
  *v4 = &unk_1F5B34AE0;
  *a2 = v4;
  return result;
}

uint64_t OUTLINED_FUNCTION_1_28(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, void *a51, uint64_t a52)
{
  a51 = a1;
  a52 = a2;

  return mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::ElementsAttr &>((v52 + 8), v53, &a39, &a51);
}

__n128 OUTLINED_FUNCTION_4_16@<Q0>(_OWORD *a1@<X0>, uint64_t a2@<X8>)
{
  result = *a2;
  v3 = *(a2 + 16);
  *a1 = *a2;
  a1[1] = v3;
  return result;
}

void mlir::anec::getANECConvCanonicalizationPatterns(uint64_t *a1)
{
  v2 = *a1;
  v3 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v65, 3);
  mlir::Pattern::Pattern((v3 + 1), "anec.input_view", 15, v65, v2, 0, 0);
  *v3 = &unk_1F5B34B50;
  if (!v3[9])
  {
    v65 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_PadDeconvCrop1Folding]";
    v66 = 111;
    v4 = llvm::StringRef::find(&v65, "DesiredTypeName = ", 0x12uLL, 0);
    if (v66 >= v4)
    {
      v5 = v4;
    }

    else
    {
      v5 = v66;
    }

    v6 = &v65[v5];
    v7 = v66 - v5;
    if (v66 - v5 >= 0x12)
    {
      v8 = 18;
    }

    else
    {
      v8 = v66 - v5;
    }

    v9 = &v6[v8];
    v10 = v7 - v8;
    if (v10 >= v10 - 1)
    {
      --v10;
    }

    v3[8] = v9;
    v3[9] = v10;
  }

  v11 = *(v3 + 22);
  if (v11 > *(v3 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((v3 + 10), (v3 + 12), v11, 16);
    LODWORD(v11) = *(v3 + 22);
  }

  *(v3 + 22) = v11;
  v13 = a1[2];
  v12 = a1[3];
  if (v13 >= v12)
  {
    v15 = a1[1];
    v16 = v13 - v15;
    v17 = (v13 - v15) >> 3;
    v18 = v17 + 1;
    if ((v17 + 1) >> 61)
    {
      goto LABEL_80;
    }

    v19 = v12 - v15;
    if (v19 >> 2 > v18)
    {
      v18 = v19 >> 2;
    }

    if (v19 >= 0x7FFFFFFFFFFFFFF8)
    {
      v20 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v20 = v18;
    }

    if (v20)
    {
      if (v20 >> 61)
      {
        goto LABEL_81;
      }

      v21 = operator new(8 * v20);
    }

    else
    {
      v21 = 0;
    }

    v22 = &v21[8 * v17];
    *v22 = v3;
    v14 = v22 + 8;
    memcpy(v21, v15, v16);
    a1[1] = v21;
    a1[2] = v14;
    a1[3] = &v21[8 * v20];
    if (v15)
    {
      operator delete(v15);
    }
  }

  else
  {
    *v13 = v3;
    v14 = v13 + 8;
  }

  a1[2] = v14;
  v23 = *a1;
  v24 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v65, 4);
  mlir::Pattern::Pattern((v24 + 1), "anec.input_view", 15, v65, v23, 0, 0);
  *v24 = &unk_1F5B34B90;
  if (!v24[9])
  {
    v65 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_PadDeconvCrop2Folding]";
    v66 = 111;
    v25 = llvm::StringRef::find(&v65, "DesiredTypeName = ", 0x12uLL, 0);
    if (v66 >= v25)
    {
      v26 = v25;
    }

    else
    {
      v26 = v66;
    }

    v27 = &v65[v26];
    v28 = v66 - v26;
    if (v66 - v26 >= 0x12)
    {
      v29 = 18;
    }

    else
    {
      v29 = v66 - v26;
    }

    v30 = &v27[v29];
    v31 = v28 - v29;
    if (v31 >= v31 - 1)
    {
      --v31;
    }

    v24[8] = v30;
    v24[9] = v31;
  }

  v32 = *(v24 + 22);
  if (v32 > *(v24 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((v24 + 10), (v24 + 12), v32, 16);
    LODWORD(v32) = *(v24 + 22);
  }

  *(v24 + 22) = v32;
  v34 = a1[2];
  v33 = a1[3];
  if (v34 >= v33)
  {
    v36 = a1[1];
    v37 = v34 - v36;
    v38 = (v34 - v36) >> 3;
    v39 = v38 + 1;
    if ((v38 + 1) >> 61)
    {
      goto LABEL_80;
    }

    v40 = v33 - v36;
    if (v40 >> 2 > v39)
    {
      v39 = v40 >> 2;
    }

    if (v40 >= 0x7FFFFFFFFFFFFFF8)
    {
      v41 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v41 = v39;
    }

    if (v41)
    {
      if (v41 >> 61)
      {
        goto LABEL_81;
      }

      v42 = operator new(8 * v41);
    }

    else
    {
      v42 = 0;
    }

    v43 = &v42[8 * v38];
    *v43 = v24;
    v35 = v43 + 8;
    memcpy(v42, v36, v37);
    a1[1] = v42;
    a1[2] = v35;
    a1[3] = &v42[8 * v41];
    if (v36)
    {
      operator delete(v36);
    }
  }

  else
  {
    *v34 = v24;
    v35 = v34 + 8;
  }

  a1[2] = v35;
  v44 = *a1;
  v45 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v65, 2);
  mlir::Pattern::Pattern((v45 + 1), "anec.deconvolution", 18, v65, v44, 0, 0);
  *v45 = &unk_1F5B34BD0;
  if (!v45[9])
  {
    v65 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_PadDeconvFolding]";
    v66 = 106;
    v46 = llvm::StringRef::find(&v65, "DesiredTypeName = ", 0x12uLL, 0);
    if (v66 >= v46)
    {
      v47 = v46;
    }

    else
    {
      v47 = v66;
    }

    v48 = &v65[v47];
    v49 = v66 - v47;
    if (v66 - v47 >= 0x12)
    {
      v50 = 18;
    }

    else
    {
      v50 = v66 - v47;
    }

    v51 = &v48[v50];
    v52 = v49 - v50;
    if (v52 >= v52 - 1)
    {
      --v52;
    }

    v45[8] = v51;
    v45[9] = v52;
  }

  v53 = *(v45 + 22);
  if (v53 > *(v45 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((v45 + 10), (v45 + 12), v53, 16);
    LODWORD(v53) = *(v45 + 22);
  }

  *(v45 + 22) = v53;
  v55 = a1[2];
  v54 = a1[3];
  if (v55 < v54)
  {
    *v55 = v45;
    v56 = v55 + 8;
    goto LABEL_79;
  }

  v57 = a1[1];
  v58 = v55 - v57;
  v59 = (v55 - v57) >> 3;
  v60 = v59 + 1;
  if ((v59 + 1) >> 61)
  {
LABEL_80:
    std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
  }

  v61 = v54 - v57;
  if (v61 >> 2 > v60)
  {
    v60 = v61 >> 2;
  }

  if (v61 >= 0x7FFFFFFFFFFFFFF8)
  {
    v62 = 0x1FFFFFFFFFFFFFFFLL;
  }

  else
  {
    v62 = v60;
  }

  if (v62)
  {
    if (!(v62 >> 61))
    {
      v63 = operator new(8 * v62);
      goto LABEL_77;
    }

LABEL_81:
    std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
  }

  v63 = 0;
LABEL_77:
  v64 = &v63[8 * v59];
  *v64 = v45;
  v56 = v64 + 8;
  memcpy(v63, v57, v58);
  a1[1] = v63;
  a1[2] = v56;
  a1[3] = &v63[8 * v62];
  if (v57)
  {
    operator delete(v57);
  }

LABEL_79:
  a1[2] = v56;
}

void mlir::anec::anonymous namespace::ANEC_PadDeconvCrop1Folding::~ANEC_PadDeconvCrop1Folding(mlir::anec::_anonymous_namespace_::ANEC_PadDeconvCrop1Folding *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::anec::anonymous namespace::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_PadDeconvCrop1Folding *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v63[4] = *MEMORY[0x1E69E9840];
  v54 = 0;
  v55 = 0;
  v52 = 0;
  v53 = 0;
  v50 = 0;
  v51 = 0;
  v48 = 0;
  v49 = 0;
  v46 = 0;
  v47 = 0;
  v45 = 0;
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 17);
    v43 = *(a2 + 9);
    v44 = v5;
    v41 = 0;
    v42 = 0;
    v39 = 0;
    v40 = 0;
    v6 = *(a2 + 9);
    v7 = *(a2 + 17);
  }

  else
  {
    v6 = 0;
    v7 = 0;
    v43 = 0;
    v44 = 0;
    v41 = 0;
    v42 = 0;
    v39 = 0;
    v40 = 0;
  }

  v38[0] = v6;
  v38[1] = v7;
  v37 = 0;
  v61 = v63;
  v63[0] = a2;
  v62 = 0x400000001;
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  NextResultAtOffset = *(*(v8 + 9) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&NextResultAtOffset);
  if (!DefiningOp)
  {
    v17 = *(a3 + 2);
    if (v17 && mlir::RewriterBase::Listener::classof(*(a3 + 2)))
    {
    }

    goto LABEL_22;
  }

  v10 = DefiningOp;
  {
LABEL_22:
    v18 = 0;
    goto LABEL_23;
  }

  v11 = v62;
  if (v62 >= HIDWORD(v62))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v61, v63, v62 + 1, 8);
    v11 = v62;
  }

  v61[v11] = v10;
  LODWORD(v62) = v62 + 1;
  if (!*(a2 + 47) || (v64.var0 = "dimension", v64.var1 = 9, InherentAttr = mlir::Operation::getInherentAttr(a2, v64), (v13 & 1) == 0))
  {
    v65.var0 = "dimension";
    v65.var1 = 9;
    InherentAttr = mlir::DictionaryAttr::get((a2 + 56), v65);
  }

  if (!InherentAttr || *(*InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v14 = *(a3 + 2);
    if (!v14 || !mlir::RewriterBase::Listener::classof(v14))
    {
      goto LABEL_22;
    }

    v15 = *(a2 + 3);
    goto LABEL_18;
  }

  if (!*(a2 + 47) || (v66.var0 = "offset", v66.var1 = 6, v20 = mlir::Operation::getInherentAttr(a2, v66), (v21 & 1) == 0))
  {
    v67.var0 = "offset";
    v67.var1 = 6;
    v20 = mlir::DictionaryAttr::get((a2 + 56), v67);
  }

  if (!v20 || *(*v20 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v14 = *(a3 + 2);
    if (!v14 || !mlir::RewriterBase::Listener::classof(v14))
    {
      goto LABEL_22;
    }

    v15 = *(a2 + 3);
    goto LABEL_18;
  }

  if (!*(a2 + 47) || (v68.var0 = "size", v68.var1 = 4, v22 = mlir::Operation::getInherentAttr(a2, v68), (v23 & 1) == 0))
  {
    v69.var0 = "size";
    v69.var1 = 4;
    v22 = mlir::DictionaryAttr::get((a2 + 56), v69);
  }

  if (!v22 || *(*v22 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v14 = *(a3 + 2);
    if (!v14 || !mlir::RewriterBase::Listener::classof(v14))
    {
      goto LABEL_22;
    }

    v15 = *(a2 + 3);
    goto LABEL_18;
  }

  if (!*(a2 + 47) || (v70.var0 = "step", v70.var1 = 4, v24 = mlir::Operation::getInherentAttr(a2, v70), (v25 & 1) == 0))
  {
    v71.var0 = "step";
    v71.var1 = 4;
    v24 = mlir::DictionaryAttr::get((a2 + 56), v71);
  }

  if (!v24 || *(*v24 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v14 = *(a3 + 2);
    if (!v14 || !mlir::RewriterBase::Listener::classof(v14))
    {
      goto LABEL_22;
    }

    v15 = *(a2 + 3);
LABEL_18:
    (*(*v14 + 88))(v14, v15, v16, &NextResultAtOffset);
    goto LABEL_22;
  }

  v51 = v24;
  if (*(v42 + 36))
  {
    v26 = v42 - 16;
  }

  else
  {
    v26 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v26, 0);
  v27 = mlir::Value::getDefiningOp(&NextResultAtOffset);
  if (*(v37 + 9))
  {
    v28 = v37 - 16;
  }

  else
  {
    v28 = 0;
  }

  v56 = mlir::detail::OpResultImpl::getNextResultAtOffset(v28, 0);
  v29 = mlir::Value::getDefiningOp(&v56);
  if (*(v8 + 9))
  {
    v30 = v8 - 16;
  }

  else
  {
    v30 = 0;
  }

  v36 = mlir::detail::OpResultImpl::getNextResultAtOffset(v30, 0);
  v60 = mlir::Value::getDefiningOp(&v36);
  if (*(v8 + 9))
  {
    v31 = v8 - 16;
  }

  else
  {
    v31 = 0;
  }

  v32 = mlir::detail::OpResultImpl::getNextResultAtOffset(v31, 0);
  {
    goto LABEL_23;
  }

  mlir::IntegerAttr::getValue(&v51, &NextResultAtOffset);
  v33 = v58;
  if (v58 < 0x41)
  {
    if (NextResultAtOffset != 1)
    {
      goto LABEL_73;
    }

LABEL_70:
    v35 = *(v61[1] + 24);
    NextResultAtOffset = *(*v61 + 24);
    v58 = v35;
    v59 = *(v61[2] + 24);
    mlir::Builder::getFusedLoc(a3 + 1, &NextResultAtOffset, 3, 0);
  }

  if (v33 - llvm::APInt::countLeadingZerosSlowCase(&NextResultAtOffset) >= 0x41)
  {
    if (NextResultAtOffset)
    {
      operator delete[](NextResultAtOffset);
    }

    goto LABEL_73;
  }

  v34 = *NextResultAtOffset;
  operator delete[](NextResultAtOffset);
  if (v34 == 1)
  {
    goto LABEL_70;
  }

LABEL_73:
LABEL_23:
  if (v61 != v63)
  {
    free(v61);
  }

  return v18;
}

uint64_t mlir::anec::anonymous namespace::static_dag_matcher_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, void *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12, uint64_t *a13, uint64_t *a14, uint64_t *a15, uint64_t *a16, uint64_t *a17, void *a18, void *a19, mlir::Operation **a20)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id)
  {
    v22 = a2;
  }

  else
  {
    v22 = 0;
  }

  if (!v22)
  {
    v55 = *(a1 + 16);
    if (v55 && mlir::RewriterBase::Listener::classof(v55))
    {
    }

    return 0;
  }

  *a7 = v22;
  v76 = *(*(v22 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v76);
  if (!DefiningOp)
  {
    v56 = *(a1 + 16);
    if (v56 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
    {
    }

    return 0;
  }

  v29 = DefiningOp;
  {
    return 0;
  }

  v30 = *(a3 + 8);
  if (v30 >= *(a3 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, a3 + 16, v30 + 1, 8);
    LODWORD(v30) = *(a3 + 8);
  }

  *(*a3 + 8 * v30) = v29;
  ++*(a3 + 8);
  if ((*(v22 + 46) & 0x80) != 0)
  {
    v31 = *(v22 + 72);
  }

  else
  {
    v31 = 0;
  }

  *a19 = v31 + 32;
  a19[1] = 1;
  if (!*(a2 + 47) || (v78.var0 = "stride", v78.var1 = 6, InherentAttr = mlir::Operation::getInherentAttr(a2, v78), (v33 & 1) == 0))
  {
    v79.var0 = "stride";
    v79.var1 = 6;
    InherentAttr = mlir::DictionaryAttr::get((a2 + 56), v79);
  }

  v34 = InherentAttr;
  if (!InherentAttr || !mlir::DenseIntElementsAttr::classof(InherentAttr))
  {
    v57 = *(a1 + 16);
    if (v57 && mlir::RewriterBase::Listener::classof(v57))
    {
    }

    return 0;
  }

  *a12 = v34;
  if (!*(a2 + 47) || (v80.var0 = "dilation", v80.var1 = 8, v35 = mlir::Operation::getInherentAttr(a2, v80), (v36 & 1) == 0))
  {
    v81.var0 = "dilation";
    v81.var1 = 8;
    v35 = mlir::DictionaryAttr::get((a2 + 56), v81);
  }

  v37 = v35;
  if (!v35 || !mlir::DenseIntElementsAttr::classof(v35))
  {
    v58 = *(a1 + 16);
    if (v58 && mlir::RewriterBase::Listener::classof(v58))
    {
    }

    return 0;
  }

  *a11 = v37;
  if (!*(a2 + 47) || (v82.var0 = "padding", v82.var1 = 7, v38 = mlir::Operation::getInherentAttr(a2, v82), (v39 & 1) == 0))
  {
    v83.var0 = "padding";
    v83.var1 = 7;
    v38 = mlir::DictionaryAttr::get((a2 + 56), v83);
  }

  v40 = v38;
  if (!v38 || !mlir::DenseIntElementsAttr::classof(v38))
  {
    v59 = *(a1 + 16);
    if (v59 && mlir::RewriterBase::Listener::classof(v59))
    {
    }

    return 0;
  }

  *a14 = v40;
  if (!*(a2 + 47) || (v84.var0 = "padding_mode", v84.var1 = 12, v41 = mlir::Operation::getInherentAttr(a2, v84), (v42 & 1) == 0))
  {
    v85.var0 = "padding_mode";
    v85.var1 = 12;
    v41 = mlir::DictionaryAttr::get((a2 + 56), v85);
  }

  if (!v41 || (v43 = v41, v44 = mlir::anec::PaddingModeAttr::classof(v41), v45 = v43, (v44 & 1) == 0))
  {
    v45 = mlir::arith::AtomicRMWKindAttr::get(*(a1 + 8), 0);
  }

  *a9 = v45;
  if (!*(a2 + 47) || (v86.var0 = "groups", v86.var1 = 6, IntegerAttr = mlir::Operation::getInherentAttr(a2, v86), (v47 & 1) == 0))
  {
    v87.var0 = "groups";
    v87.var1 = 6;
    IntegerAttr = mlir::DictionaryAttr::get((a2 + 56), v87);
  }

  if (!IntegerAttr || *(*IntegerAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    IntegerType = mlir::Builder::getIntegerType((a1 + 8), 64, 0);
    IntegerAttr = mlir::Builder::getIntegerAttr(a1 + 8, IntegerType, 1);
  }

  *a10 = IntegerAttr;
  if (!*(a2 + 47) || (v88.var0 = "channel_wise", v88.var1 = 12, v49 = mlir::Operation::getInherentAttr(a2, v88), (v50 & 1) == 0))
  {
    v89.var0 = "channel_wise";
    v89.var1 = 12;
    v49 = mlir::DictionaryAttr::get((a2 + 56), v89);
  }

  if (!v49 || *(*v49 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    v49 = 0;
  }

  *a6 = v49;
  if (!*(a2 + 47) || (v90.var0 = "kernel_scale", v90.var1 = 12, v51 = mlir::Operation::getInherentAttr(a2, v90), (v52 & 1) == 0))
  {
    v91.var0 = "kernel_scale";
    v91.var1 = 12;
    v51 = mlir::DictionaryAttr::get((a2 + 56), v91);
  }

  if (v51)
  {
    v53 = v51;
    if (mlir::DenseFPElementsAttr::classof(v51))
    {
      v54 = v53;
    }

    else
    {
      v54 = 0;
    }
  }

  else
  {
    v54 = 0;
  }

  *a5 = v54;
  if (!*(a2 + 47) || (v92.var0 = "kernel_zero_point", v92.var1 = 17, v61 = mlir::Operation::getInherentAttr(a2, v92), (v62 & 1) == 0))
  {
    v93.var0 = "kernel_zero_point";
    v93.var1 = 17;
    v61 = mlir::DictionaryAttr::get((a2 + 56), v93);
  }

  if (v61)
  {
    v63 = v61;
    if (mlir::DenseIntElementsAttr::classof(v61))
    {
      v64 = v63;
    }

    else
    {
      v64 = 0;
    }
  }

  else
  {
    v64 = 0;
  }

  *a17 = v64;
  if (!*(a2 + 47) || (v94.var0 = "kernel_palettized_LUT", v94.var1 = 21, v65 = mlir::Operation::getInherentAttr(a2, v94), (v66 & 1) == 0))
  {
    v95.var0 = "kernel_palettized_LUT";
    v95.var1 = 21;
    v65 = mlir::DictionaryAttr::get((a2 + 56), v95);
  }

  if (v65)
  {
    v67 = v65;
    if (mlir::DenseElementsAttr::classof(v65))
    {
      v68 = v67;
    }

    else
    {
      v68 = 0;
    }
  }

  else
  {
    v68 = 0;
  }

  *a13 = v68;
  if (!*(a2 + 47) || (v96.var0 = "kernel_mutable_palettized_LUT", v96.var1 = 29, v69 = mlir::Operation::getInherentAttr(a2, v96), (v70 & 1) == 0))
  {
    v97.var0 = "kernel_mutable_palettized_LUT";
    v97.var1 = 29;
    v69 = mlir::DictionaryAttr::get((a2 + 56), v97);
  }

  if (v69)
  {
    if (*(*v69 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    {
      v71 = v69;
    }

    else
    {
      v71 = 0;
    }
  }

  else
  {
    v71 = 0;
  }

  *a4 = v71;
  return 1;
}

uint64_t mlir::Operation::getAttrOfType<mlir::IntegerAttr>(mlir::Operation *this, StringRef a2)
{
  if (!*(this + 47) || (var0 = a2.var0, var1 = a2.var1, result = mlir::Operation::getInherentAttr(this, a2), a2.var1 = var1, v7 = v6, a2.var0 = var0, (v7 & 1) == 0))
  {
    result = mlir::DictionaryAttr::get((this + 56), a2);
  }

  if (result)
  {
    if (*(*result + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      return 0;
    }
  }

  return result;
}

uint64_t mlir::anec::anonymous namespace::tryCanonDeconvPaddings(mlir::Operation *a1, mlir::Operation *a2, mlir::Operation **a3, uint64_t a4, void *a5, uint64_t *a6, uint64_t *a7)
{
  v158 = *MEMORY[0x1E69E9840];
  v133 = a2;
  v134 = a1;
  v8 = *a5;
  if (!*a5)
  {
LABEL_4:
    v12 = *(*(*(a1 + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
    if (v12)
    {
      v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v12 + 8);
    }

    else
    {
      v13 = 0;
    }

    v148 = v12;
    v149[0] = v13;
    mlir::CallableOpInterface::getArgAttrsAttr(&v148);
    if (v22 != 4)
    {
      v144 = "Conv2D input must be 4D";
      v147 = 259;
      mlir::Operation::emitOpError(v134, &v144, &v148);
      v12 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v148);
      if (v148)
      {
        mlir::InFlightDiagnostic::report(&v148);
      }

      if (v157 != 1)
      {
        return v12;
      }

      if (v156 != &v157)
      {
        free(v156);
      }

      v42 = __p;
      if (__p)
      {
        v43 = v155;
        v44 = __p;
        if (v155 != __p)
        {
          do
          {
            v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v43 - 1);
          }

          while (v43 != v42);
          v44 = __p;
        }

        v155 = v42;
        operator delete(v44);
      }

      v45 = v152;
      if (v152)
      {
        v46 = v153;
        v47 = v152;
        if (v153 != v152)
        {
          do
          {
            v49 = *--v46;
            v48 = v49;
            *v46 = 0;
            if (v49)
            {
              operator delete[](v48);
            }
          }

          while (v46 != v45);
          v47 = v152;
        }

        v153 = v45;
        operator delete(v47);
      }

      v75 = v150;
      if (v150 == v151)
      {
        return v12;
      }

LABEL_146:
      free(v75);
      return v12;
    }

    v144 = v146;
    v145 = 0xA00000000;
    Stride = mlir::anec::MaxPool::getStride(&v133);
    mlir::getValues<unsigned long>(Stride, &v144);
    v24 = v144;
    v25 = v145 - 4;
    if (v145 != 4)
    {
      v26 = v144;
      while (!*v26++)
      {
        if (!--v25)
        {
          goto LABEL_28;
        }
      }

      v141 = "Padding on Batch / Depth / Channel dimension not supported";
      v143[8] = 259;
      mlir::Operation::emitOpError(v134, &v141, &v148);
      v12 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v148);
      if (v148)
      {
        mlir::InFlightDiagnostic::report(&v148);
      }

      if ((v157 & 1) == 0)
      {
        goto LABEL_145;
      }

      if (v156 != &v157)
      {
        free(v156);
      }

      v50 = __p;
      if (__p)
      {
        v51 = v155;
        v52 = __p;
        if (v155 != __p)
        {
          do
          {
            v51 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v51 - 1);
          }

          while (v51 != v50);
          v52 = __p;
        }

        v155 = v50;
        operator delete(v52);
      }

      v53 = v152;
      if (v152)
      {
        v54 = v153;
        v55 = v152;
        if (v153 != v152)
        {
          do
          {
            v57 = *--v54;
            v56 = v57;
            *v54 = 0;
            if (v57)
            {
              operator delete[](v56);
            }
          }

          while (v54 != v53);
          v55 = v152;
        }

        v153 = v53;
        operator delete(v55);
      }

      v98 = v150;
      if (v150 == v151)
      {
LABEL_145:
        v75 = v144;
        if (v144 == v146)
        {
          return v12;
        }

        goto LABEL_146;
      }

LABEL_144:
      free(v98);
      goto LABEL_145;
    }

LABEL_28:
    v28 = v144 + 8 * v145;
    v29 = *(v28 - 3);
    v30 = *(v28 - 1);
    *(v144 + 1) = *(v28 - 2);
    *(v24 + 2) = v30;
    *v24 = v29;
    v31 = v144;
    v32 = v24 - v144 + 48;
    LODWORD(v145) = v32 >> 3;
    if (!v145)
    {
LABEL_32:
      v34 = 0;
      v35 = 1;
      goto LABEL_33;
    }

    v33 = 8 * (v32 >> 3);
    while (!*v31)
    {
      ++v31;
      v33 -= 8;
      if (!v33)
      {
        goto LABEL_32;
      }
    }

    v141 = v143;
    v142 = 0x500000000;
    Padding = mlir::anec::MaxPool::getPadding(&v133);
    mlir::getValues<unsigned long>(Padding, &v141);
    v59 = v141;
    v60 = v141 + 8 * v142;
    v61 = *(v60 - 24);
    *(v141 + 2) = *(v60 - 1);
    *v59 = v61;
    v62 = v141;
    LODWORD(v142) = (v59 - v141 + 24) >> 3;
    if (*(v144 + 2) || *(v144 + 3))
    {
      if (*(v144 + 4) || *(v144 + 5))
      {
        v63 = v141 + 8;
        if (*(v141 + 1) != *(v141 + 2))
        {
          v135 = "Padding mode must be the same on all axes";
          v138 = 259;
          mlir::Operation::emitOpError(v134, &v135, &v148);
          v12 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v148);
          if (v148)
          {
            mlir::InFlightDiagnostic::report(&v148);
          }

          if (v157 == 1)
          {
            mlir::Diagnostic::~Diagnostic(v149);
          }

          v34 = 0;
          v64 = 0;
          v62 = v141;
          goto LABEL_172;
        }
      }

      else
      {
        v63 = v141 + 8;
      }
    }

    else
    {
      v63 = v141 + 16;
    }

    v34 = *v63;
    v64 = 1;
LABEL_172:
    if (v62 != v143)
    {
      free(v62);
    }

    if (!v64)
    {
      goto LABEL_145;
    }

    if (v34 == 6)
    {
      mlir::anec::Padding::getBackgroundValue(&v133, &v148);
      v111 = llvm::APFloat::convertToDouble(&v148);
      v112 = v149[0];
      if (llvm::APFloatBase::PPCDoubleDouble(v113) == v112)
      {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v149);
      }

      else
      {
        llvm::detail::IEEEFloat::~IEEEFloat(v149);
      }

      v35 = 0;
      if (v111 == 0.0)
      {
        v34 = 0;
      }

      else
      {
        v34 = 6;
      }
    }

    else
    {
      v35 = 0;
    }

LABEL_33:
    v141 = v143;
    v142 = 0x600000000;
    v36 = mlir::anec::Convolution::getPadding(&v134);
    mlir::getValues<unsigned long>(v36, &v141);
    if (v142)
    {
      v37 = v141;
      v38 = 8 * v142 - 8;
      do
      {
        v39 = *v37++;
        v40 = v39 == 0;
        if (v39)
        {
          v41 = 1;
        }

        else
        {
          v41 = v38 == 0;
        }

        v38 -= 8;
      }

      while (!v41);
    }

    else
    {
      v40 = 1;
    }

    PaddingMode = mlir::anec::Convolution::getPaddingMode(&v134);
    if (((v35 | v40) & 1) == 0 && v34 != PaddingMode)
    {
      v135 = "Padding mode of Deconv and Pad ops must be the same";
      v138 = 259;
      mlir::Operation::emitOpError(v134, &v135, &v148);
      v12 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v148);
      if (v148)
      {
        mlir::InFlightDiagnostic::report(&v148);
      }

      if (v157 == 1)
      {
        if (v156 != &v157)
        {
          free(v156);
        }

        v66 = __p;
        if (__p)
        {
          v67 = v155;
          v68 = __p;
          if (v155 != __p)
          {
            do
            {
              v67 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v67 - 1);
            }

            while (v67 != v66);
            v68 = __p;
          }

          v155 = v66;
          operator delete(v68);
        }

        v69 = v152;
        if (v152)
        {
          v70 = v153;
          v71 = v152;
          if (v153 != v152)
          {
            do
            {
              v73 = *--v70;
              v72 = v73;
              *v70 = 0;
              if (v73)
              {
                operator delete[](v72);
              }
            }

            while (v70 != v69);
            v71 = v152;
          }

          v153 = v69;
          operator delete(v71);
        }

        v99 = v150;
        if (v150 != v151)
        {
          goto LABEL_142;
        }
      }

      goto LABEL_143;
    }

    if (v40)
    {
      v74 = 0;
    }

    else
    {
      v74 = PaddingMode;
    }

    if (!v35)
    {
      v74 = v34;
    }

    if ((v74 & 0xFFFFFFFFFFFFFFFDLL) != 0)
    {
      v135 = "Unsupported padding mode";
      v138 = 259;
      mlir::Operation::emitOpError(v134, &v135, &v148);
      v12 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v148);
      if (v148)
      {
        mlir::InFlightDiagnostic::report(&v148);
      }

      if (v157 == 1)
      {
        mlir::Diagnostic::~Diagnostic(v149);
      }

      goto LABEL_143;
    }

    v125 = v74;
    v139[0] = v140;
    v139[1] = 0x300000000;
    v76 = mlir::anec::Convolution::getStride(&v134);
    mlir::getValues<long long>(v76, v139);
    v77 = *(v144 + 3);
    v78 = *(v141 + 3);
    v80 = *(v139[0] + 8);
    v79 = *(v139[0] + 16);
    v81 = *(v141 + 2) + v80 * *(v144 + 2);
    v129 = 0;
    v130 = 0;
    *&v131 = v81;
    *(&v131 + 1) = v78 + v80 * v77;
    v82 = *(v141 + 5) + v79 * *(v144 + 5);
    *&v132 = *(v141 + 4) + v79 * *(v144 + 4);
    *(&v132 + 1) = v82;
    if (a4)
    {
      v83 = 8 * a4;
      while (1)
      {
        v128 = *a3;
        v84 = (*(*(*(v128 + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
        v85 = v84 ? mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v84 + 8) : 0;
        v126[0] = v84;
        v126[1] = v85;
        Height = mlir::anec::Resize::getHeight(&v128);
        mlir::CallableOpInterface::getArgAttrsAttr(v126);
        DimFromIndex = mlir::anec::getDimFromIndex(Height, v87);
        if ((DimFromIndex & 0x100000000) == 0 || (DimFromIndex - 3) >= 2)
        {
          break;
        }

        Offset = mlir::anec::InputView::getOffset(&v128);
        v90 = mlir::anec::Resize::getHeight(&v128);
        v91 = *(mlir::CallableOpInterface::getArgAttrsAttr(v126) + 8 * v90);
        Size = mlir::anec::InputView::getSize(&v128);
        mlir::CallableOpInterface::getArgAttrsAttr(v126);
        v94 = (&v129 + 2 * (mlir::anec::Resize::getHeight(&v128) - v93));
        v95 = Offset + Size - v91 + v94[7];
        v94[6] -= Offset;
        v94[7] = v95;
        ++a3;
        v83 -= 8;
        if (!v83)
        {
          goto LABEL_128;
        }
      }

      v135 = "Cropping on batch / depth / channel dimension not supported";
      v138 = 259;
      mlir::Operation::emitOpError(v134, &v135, &v148);
      v12 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v148);
      if (v148)
      {
        mlir::InFlightDiagnostic::report(&v148);
      }

      if ((v157 & 1) == 0)
      {
        goto LABEL_199;
      }

      if (v156 != &v157)
      {
        free(v156);
      }

      v101 = __p;
      if (__p)
      {
        v102 = v155;
        v103 = __p;
        if (v155 != __p)
        {
          do
          {
            v102 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v102 - 1);
          }

          while (v102 != v101);
          v103 = __p;
        }

        v155 = v101;
        operator delete(v103);
      }

      v104 = v152;
      if (v152)
      {
        v105 = v153;
        v106 = v152;
        if (v153 != v152)
        {
          do
          {
            v108 = *--v105;
            v107 = v108;
            *v105 = 0;
            if (v108)
            {
              operator delete[](v107);
            }
          }

          while (v105 != v104);
          v106 = v152;
        }

        v153 = v104;
        operator delete(v106);
      }

      v122 = v150;
      if (v150 == v151)
      {
        goto LABEL_199;
      }
    }

    else
    {
LABEL_128:
      if ((v129 & 0x8000000000000000) != 0)
      {
        v97 = v129 >> 63;
      }

      else
      {
        v96 = v130;
        if ((v130 & 0x8000000000000000) == 0)
        {
          v96 = v131;
          if ((v131 & 0x8000000000000000) == 0)
          {
            v96 = *(&v131 + 1);
            if ((*(&v131 + 1) & 0x8000000000000000) == 0)
            {
              v96 = v132;
              if ((v132 & 0x8000000000000000) == 0)
              {
                v96 = *(&v132 + 1);
              }
            }
          }
        }

        v97 = v96 >> 63;
      }

      if (v97)
      {
        v135 = "Cropping output required";
        v138 = 259;
        mlir::Operation::emitOpError(v134, &v135, &v148);
        v12 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v148);
        mlir::InFlightDiagnostic::~InFlightDiagnostic(&v148);
        goto LABEL_199;
      }

      v109 = (*(*(*(v134 + 9) + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (v109)
      {
        v110 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v109 + 8);
      }

      else
      {
        v110 = 0;
      }

      v148 = v109;
      v149[0] = v110;
      ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v148);
      llvm::SmallVector<long long,5u>::SmallVector<long long,void>(&v135, ArgAttrsAttr, v115);
      if (v136 <= 4)
      {
        v148 = 1;
        llvm::SmallVectorImpl<long long>::insert_one_impl<long long>(&v135, v135 + 16, &v148);
      }

      v116 = *(v135 + 3);
      if (v131 >= v116)
      {
        goto LABEL_196;
      }

      if (*(&v131 + 1) >= v116)
      {
        goto LABEL_196;
      }

      v117 = *(v135 + 4);
      if (v132 >= v117 || *(&v132 + 1) >= v117)
      {
        goto LABEL_196;
      }

      v118 = 2 * v116;
      v119 = v116 < -1;
      v120 = (v116 + 1) & 1;
      if (v119)
      {
        v120 = -v120;
      }

      if (*(&v131 + 1) + v131 > v118 - *(v139[0] + 8) - v120)
      {
        goto LABEL_196;
      }

      v121 = (v117 + 1) & 1;
      if (v117 < -1)
      {
        v121 = -v121;
      }

      if (*(&v132 + 1) + v132 <= 2 * v117 - *(v139[0] + 16) - v121)
      {
        if (a6)
        {
          *a6 = v125;
        }

        if (a7)
        {
          llvm::SmallVectorImpl<unsigned long long>::resizeImpl<false>(a7, 6uLL);
          v123 = *a7;
          *v123 = 0;
          *(v123 + 8) = 0;
          v124 = v132;
          *(v123 + 16) = v131;
          *(v123 + 32) = v124;
        }

        v12 = 1;
      }

      else
      {
LABEL_196:
        v126[0] = "Padding value not supported by ANEC";
        v127 = 259;
        mlir::Operation::emitOpError(v134, v126, &v148);
        v12 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v148);
        mlir::InFlightDiagnostic::~InFlightDiagnostic(&v148);
      }

      v122 = v135;
      if (v135 == &v137)
      {
LABEL_199:
        v99 = v139[0];
        if (v139[0] != v140)
        {
LABEL_142:
          free(v99);
        }

LABEL_143:
        v98 = v141;
        if (v141 == v143)
        {
          goto LABEL_145;
        }

        goto LABEL_144;
      }
    }

    free(v122);
    goto LABEL_199;
  }

  while (*(*(v8[2] + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id)
  {
    v8 = *v8;
    if (!v8)
    {
      goto LABEL_4;
    }
  }

  v144 = "Pattern can be further extended";
  v147 = 259;
  mlir::Operation::emitOpError(a1, &v144, &v148);
  v12 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v148);
  if (v148)
  {
    mlir::InFlightDiagnostic::report(&v148);
  }

  if (v157)
  {
    if (v156 != &v157)
    {
      free(v156);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v155;
      v16 = __p;
      if (v155 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v155 = v14;
      operator delete(v16);
    }

    v17 = v152;
    if (v152)
    {
      v18 = v153;
      v19 = v152;
      if (v153 != v152)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v152;
      }

      v153 = v17;
      operator delete(v19);
    }

    v75 = v150;
    if (v150 != v151)
    {
      goto LABEL_146;
    }
  }

  return v12;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::anec::anonymous namespace::canonDeconvPaddings(uint64_t a1, uint64_t a2, mlir::Operation *a3, mlir::Operation *a4, mlir::Operation **a5, uint64_t a6, void *a7)
{
  v38[1] = *MEMORY[0x1E69E9840];
  v33 = 0;
  v34 = a3;
  v35 = v37;
  v36 = 0xA00000000;
  v38[0] = 6;
  IntegerType = mlir::Builder::getIntegerType((a1 + 8), 64, 0);
  v12 = mlir::RankedTensorType::get(v38, 1, IntegerType, 0);
  if (v12)
  {
    v13 = v12;
    v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v12 + 8);
    v12 = v13;
  }

  else
  {
    v14 = 0;
  }

  v15 = mlir::DenseElementsAttr::getFromRawBuffer(v12, v14, v35, 8 * v36, 8, 1, 0);
  v31 = *(*(a4 + 9) + 24);
  v32 = v15;
  v30 = *(*(a3 + 9) + 56);
  Stride = mlir::anec::Convolution::getStride(&v34);
  Dilation = mlir::anec::Convolution::getDilation(&v34);
  Groups = mlir::anec::Convolution::getGroups(&v34);
  IncPad = mlir::anec::AveragePool::getIncPad(&v34);
  KernelScaleAttr = mlir::anec::Convolution::getKernelScaleAttr(&v34);
  KernelZeroPointAttr = mlir::anec::Convolution::getKernelZeroPointAttr(&v34);
  KernelPalettized_LUTAttr = mlir::anec::Convolution::getKernelPalettized_LUTAttr(&v34);
  v38[0] = mlir::Operation::getAttrDictionary(v34);
  Value = mlir::ArrayAttr::getValue(v38);
  v38[0] = mlir::Operation::getAttrDictionary(v34);
  v17 = mlir::ArrayAttr::getValue(v38);
  v19 = mlir::impl::getAttrFromSortedRange<mlir::NamedAttribute const*,mlir::StringAttr>((Value + 16), (v17 + 16 * v18 - 32), *(*(*(v34 + 6) + 96) + 24));
  if (v19)
  {
    if (*(*v19 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    {
      v20 = v19;
    }

    else
    {
      v20 = 0;
    }
  }

  else
  {
    v20 = 0;
  }

  v38[0] = v20;
  v21 = mlir::OpBuilder::create<mlir::anec::Deconvolution,mlir::detail::TypedValue<mlir::MemRefType>,mlir::detail::TypedValue<mlir::MemRefType>,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::anec::PaddingMode &,unsigned long long,BOOL,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseElementsAttr,mlir::DictionaryAttr>((a1 + 8), a2, &v31, &v30, &Stride, &Dilation, &v32, &v33, &Groups, &IncPad, &KernelScaleAttr, &KernelZeroPointAttr, &KernelPalettized_LUTAttr, v38);
  if (v35 != v37)
  {
    free(v35);
  }

  return v21 - 16;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "There's no operation that defines operand 0 of castedOp0";
  v13 = 56;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

uint64_t mlir::anec::anonymous namespace::static_dag_matcher_0(uint64_t a1, mlir::Operation *this, void *a3, uint64_t *a4, uint64_t *a5, mlir::Operation **a6, uint64_t *a7)
{
  if (*(*(this + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Padding,void>::id)
  {
    v9 = this;
  }

  else
  {
    v9 = 0;
  }

  if (!v9)
  {
    v24 = *(a1 + 16);
    if (v24 && mlir::RewriterBase::Listener::classof(v24))
    {
    }

    return 0;
  }

  *a6 = v9;
  if ((*(v9 + 46) & 0x80) != 0)
  {
    v13 = *(v9 + 9);
  }

  else
  {
    v13 = 0;
  }

  *a3 = v13;
  a3[1] = 1;
  if (!*(this + 47) || (v31.var0 = "padding_modes", v31.var1 = 13, InherentAttr = mlir::Operation::getInherentAttr(this, v31), (v15 & 1) == 0))
  {
    v32.var0 = "padding_modes";
    v32.var1 = 13;
    InherentAttr = mlir::DictionaryAttr::get((this + 56), v32);
  }

  v16 = InherentAttr;
  if (!InherentAttr || !mlir::DenseIntElementsAttr::classof(InherentAttr))
  {
    v23 = *(a1 + 16);
    if (v23 && mlir::RewriterBase::Listener::classof(v23))
    {
    }

    return 0;
  }

  *a7 = v16;
  if (!*(this + 47) || (v33.var0 = "padding_sizes", v33.var1 = 13, v17 = mlir::Operation::getInherentAttr(this, v33), (v18 & 1) == 0))
  {
    v34.var0 = "padding_sizes";
    v34.var1 = 13;
    v17 = mlir::DictionaryAttr::get((this + 56), v34);
  }

  v19 = v17;
  if (!v17 || !mlir::DenseIntElementsAttr::classof(v17))
  {
    v25 = *(a1 + 16);
    if (v25 && mlir::RewriterBase::Listener::classof(v25))
    {
    }

    return 0;
  }

  *a4 = v19;
  if (!*(this + 47) || (v35.var0 = "background_value", v35.var1 = 16, v20 = mlir::Operation::getInherentAttr(this, v35), (v21 & 1) == 0))
  {
    v36.var0 = "background_value";
    v36.var1 = 16;
    v20 = mlir::DictionaryAttr::get((this + 56), v36);
  }

  if (!v20 || *(*v20 + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    v22 = *(a1 + 16);
    if (v22)
    {
      if (mlir::RewriterBase::Listener::classof(v22))
      {
      }
    }

    return 0;
  }

  *a5 = v20;
  return 1;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::static_dag_matcher_1(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DictionaryAttr &,mlir::DenseFPElementsAttr &,mlir::UnitAttr &,mlir::anec::Deconvolution &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingModeAttr &,mlir::IntegerAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::anec::Padding &)::$_0>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "castedOp1 is not ::mlir::anec::Deconvolution type";
  v13 = 49;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::static_dag_matcher_1(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DictionaryAttr &,mlir::DenseFPElementsAttr &,mlir::UnitAttr &,mlir::anec::Deconvolution &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingModeAttr &,mlir::IntegerAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::anec::Padding &)::$_1>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "There's no operation that defines operand 0 of castedOp1";
  v13 = 56;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::anec::Padding &,mlir::DenseIntElementsAttr &)::$_0>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "castedOp1 is not ::mlir::anec::Padding type";
  v13 = 43;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::anec::Padding &,mlir::DenseIntElementsAttr &)::$_1>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.padding' to have attribute 'padding_modes' of type '::mlir::DenseIntElementsAttr'";
  v13 = 99;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::anec::Padding &,mlir::DenseIntElementsAttr &)::$_2>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.padding' to have attribute 'padding_sizes' of type '::mlir::DenseIntElementsAttr'";
  v13 = 99;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::anec::Padding &,mlir::DenseIntElementsAttr &)::$_3>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.padding' to have attribute 'background_value' of type '::mlir::FloatAttr'";
  v13 = 91;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::static_dag_matcher_1(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DictionaryAttr &,mlir::DenseFPElementsAttr &,mlir::UnitAttr &,mlir::anec::Deconvolution &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingModeAttr &,mlir::IntegerAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::anec::Padding &)::$_2>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.deconvolution' to have attribute 'stride' of type '::mlir::DenseIntElementsAttr'";
  v13 = 98;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::static_dag_matcher_1(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DictionaryAttr &,mlir::DenseFPElementsAttr &,mlir::UnitAttr &,mlir::anec::Deconvolution &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingModeAttr &,mlir::IntegerAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::anec::Padding &)::$_3>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.deconvolution' to have attribute 'dilation' of type '::mlir::DenseIntElementsAttr'";
  v13 = 100;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::static_dag_matcher_1(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DictionaryAttr &,mlir::DenseFPElementsAttr &,mlir::UnitAttr &,mlir::anec::Deconvolution &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingModeAttr &,mlir::IntegerAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::anec::Padding &)::$_4>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.deconvolution' to have attribute 'padding' of type '::mlir::DenseIntElementsAttr'";
  v13 = 99;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.input_view' to have attribute 'dimension' of type '::mlir::IntegerAttr'";
  v13 = 89;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.input_view' to have attribute 'offset' of type '::mlir::IntegerAttr'";
  v13 = 86;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.input_view' to have attribute 'size' of type '::mlir::IntegerAttr'";
  v13 = 84;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.input_view' to have attribute 'step' of type '::mlir::IntegerAttr'";
  v13 = 84;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

uint64_t llvm::SmallVectorImpl<unsigned long long>::resizeImpl<false>(uint64_t result, unint64_t a2)
{
  v2 = *(result + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      if (*(result + 12) < a2)
      {
        v4 = result;
        llvm::SmallVectorBase<unsigned int>::grow_pod(result, result + 16, a2, 8);
        result = v4;
        v2 = *(v4 + 8);
      }

      if (v2 != a2)
      {
        v5 = result;
        bzero((*result + 8 * v2), 8 * a2 - 8 * v2);
        result = v5;
      }
    }

    *(result + 8) = a2;
  }

  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'conv_op, pad_op, out' failed to satisfy constraint: ''";
  v13 = 64;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'iv1_step' failed to satisfy constraint: ''";
  v13 = 52;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

uint64_t mlir::OpBuilder::create<mlir::anec::Deconvolution,mlir::detail::TypedValue<mlir::MemRefType>,mlir::detail::TypedValue<mlir::MemRefType>,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::anec::PaddingMode &,unsigned long long,BOOL,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseElementsAttr,mlir::DictionaryAttr>(uint64_t **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, char *a10, uint64_t *a11, uint64_t *a12, uint64_t *a13, uint64_t *a14)
{
  v31[38] = *MEMORY[0x1E69E9840];
  v28 = a2;
  Context = mlir::Attribute::getContext(&v28);
  v23 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id, Context);
  if ((v24 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::anec::Deconvolution,mlir::detail::TypedValue<mlir::MemRefType>,mlir::detail::TypedValue<mlir::MemRefType>,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::anec::PaddingMode &,unsigned long long,BOOL,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseElementsAttr,mlir::DictionaryAttr>(v31, v30, v29);
  }

  mlir::OperationState::OperationState(v31, a2, v23);
  mlir::anec::Deconvolution::build(a1, v31, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12, *a13, *a14);
  v25 = mlir::OpBuilder::create(a1, v31);
  if (*(*(v25 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id)
  {
    v26 = v25;
  }

  else
  {
    v26 = 0;
  }

  mlir::OperationState::~OperationState(v31);
  return v26;
}

void mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::~ANEC_PadDeconvCrop2Folding(mlir::anec::_anonymous_namespace_::ANEC_PadDeconvCrop2Folding *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_PadDeconvCrop2Folding *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v79[4] = *MEMORY[0x1E69E9840];
  v70 = 0;
  v68 = 0;
  v69 = 0;
  v66 = 0;
  v67 = 0;
  v64 = 0;
  v65 = 0;
  v62 = 0;
  v63 = 0;
  v60 = 0;
  v61 = 0;
  v59 = 0;
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
    v6 = *(a2 + 17);
  }

  else
  {
    v5 = 0;
    v6 = 0;
  }

  v58[0] = v5;
  v58[1] = v6;
  v56 = 0;
  v57 = 0;
  v55[0] = v5;
  v55[1] = v6;
  v53 = 0;
  v54 = 0;
  v52 = 0;
  v77 = v79;
  v79[0] = a2;
  v78 = 0x400000001;
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id)
  {
    v7 = a2;
  }

  else
  {
    v7 = 0;
  }

  v72 = *(*(v7 + 9) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v72);
  if (!DefiningOp)
  {
    v10 = *(a3 + 2);
    if (!v10 || !mlir::RewriterBase::Listener::classof(*(a3 + 2)))
    {
      goto LABEL_80;
    }

    v11 = *(v7 + 3);
LABEL_14:
    (*(*v10 + 88))(v10, v11, v12, &v72);
LABEL_80:
    v22 = 0;
    goto LABEL_81;
  }

  v9 = DefiningOp;
  if (*(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id)
  {
    v10 = *(a3 + 2);
    if (!v10 || !mlir::RewriterBase::Listener::classof(*(a3 + 2)))
    {
      goto LABEL_80;
    }

    v11 = *(v9 + 24);
    goto LABEL_14;
  }

  v72 = *(*(DefiningOp + 72) + 24);
  v13 = mlir::Value::getDefiningOp(&v72);
  if (!v13)
  {
    v10 = *(a3 + 2);
    if (!v10 || !mlir::RewriterBase::Listener::classof(*(a3 + 2)))
    {
      goto LABEL_80;
    }

    v11 = *(v9 + 24);
    goto LABEL_14;
  }

  v14 = v13;
  {
    goto LABEL_80;
  }

  v15 = v78;
  if (v78 >= HIDWORD(v78))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v77, v79, v78 + 1, 8);
    v15 = v78;
  }

  v77[v15] = v14;
  LODWORD(v78) = v78 + 1;
  if (!*(v9 + 47) || (v80.var0 = "dimension", v80.var1 = 9, InherentAttr = mlir::Operation::getInherentAttr(v9, v80), (v17 & 1) == 0))
  {
    v81.var0 = "dimension";
    v81.var1 = 9;
    InherentAttr = mlir::DictionaryAttr::get((v9 + 56), v81);
  }

  if (!InherentAttr || *(*InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v10 = *(a3 + 2);
    if (!v10 || !mlir::RewriterBase::Listener::classof(*(a3 + 2)))
    {
      goto LABEL_80;
    }

    v11 = *(v9 + 24);
    goto LABEL_14;
  }

  if (!*(v9 + 47) || (v82.var0 = "offset", v82.var1 = 6, v18 = mlir::Operation::getInherentAttr(v9, v82), (v19 & 1) == 0))
  {
    v83.var0 = "offset";
    v83.var1 = 6;
    v18 = mlir::DictionaryAttr::get((v9 + 56), v83);
  }

  if (!v18 || *(*v18 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v10 = *(a3 + 2);
    if (!v10 || !mlir::RewriterBase::Listener::classof(*(a3 + 2)))
    {
      goto LABEL_80;
    }

    v11 = *(v9 + 24);
    goto LABEL_14;
  }

  if (!*(v9 + 47) || (v84.var0 = "size", v84.var1 = 4, v20 = mlir::Operation::getInherentAttr(v9, v84), (v21 & 1) == 0))
  {
    v85.var0 = "size";
    v85.var1 = 4;
    v20 = mlir::DictionaryAttr::get((v9 + 56), v85);
  }

  if (!v20 || *(*v20 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    goto LABEL_81;
  }

  v86.var0 = "step";
  v86.var1 = 4;
  v23 = mlir::Operation::getAttrOfType<mlir::IntegerAttr>(v9, v86);
  if (!v23)
  {
    goto LABEL_81;
  }

  v70 = v23;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(&v77, v9);
  if (!*(a2 + 47) || (v87.var0 = "dimension", v87.var1 = 9, v24 = mlir::Operation::getInherentAttr(a2, v87), (v25 & 1) == 0))
  {
    v88.var0 = "dimension";
    v88.var1 = 9;
    v24 = mlir::DictionaryAttr::get((a2 + 56), v88);
  }

  if (!v24 || *(*v24 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v26 = *(a3 + 2);
    if (!v26 || !mlir::RewriterBase::Listener::classof(v26))
    {
      goto LABEL_80;
    }

    v27 = *(a2 + 3);
    goto LABEL_53;
  }

  if (!*(a2 + 47) || (v89.var0 = "offset", v89.var1 = 6, v29 = mlir::Operation::getInherentAttr(a2, v89), (v30 & 1) == 0))
  {
    v90.var0 = "offset";
    v90.var1 = 6;
    v29 = mlir::DictionaryAttr::get((a2 + 56), v90);
  }

  if (!v29 || *(*v29 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v26 = *(a3 + 2);
    if (!v26 || !mlir::RewriterBase::Listener::classof(v26))
    {
      goto LABEL_80;
    }

    v27 = *(a2 + 3);
    goto LABEL_53;
  }

  if (!*(a2 + 47) || (v91.var0 = "size", v91.var1 = 4, v31 = mlir::Operation::getInherentAttr(a2, v91), (v32 & 1) == 0))
  {
    v92.var0 = "size";
    v92.var1 = 4;
    v31 = mlir::DictionaryAttr::get((a2 + 56), v92);
  }

  if (!v31 || *(*v31 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v26 = *(a3 + 2);
    if (!v26 || !mlir::RewriterBase::Listener::classof(v26))
    {
      goto LABEL_80;
    }

    v27 = *(a2 + 3);
    goto LABEL_53;
  }

  if (!*(a2 + 47) || (v93.var0 = "step", v93.var1 = 4, v33 = mlir::Operation::getInherentAttr(a2, v93), (v34 & 1) == 0))
  {
    v94.var0 = "step";
    v94.var1 = 4;
    v33 = mlir::DictionaryAttr::get((a2 + 56), v94);
  }

  if (!v33 || *(*v33 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v26 = *(a3 + 2);
    if (!v26 || !mlir::RewriterBase::Listener::classof(v26))
    {
      goto LABEL_80;
    }

    v27 = *(a2 + 3);
LABEL_53:
    (*(*v26 + 88))(v26, v27, v28, &v72);
    goto LABEL_80;
  }

  v66 = v33;
  if (*(v56 + 36))
  {
    v36 = v56 - 16;
  }

  else
  {
    v36 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v36, 0);
  v37 = mlir::Value::getDefiningOp(&NextResultAtOffset);
  if (*(v54 + 9))
  {
    v38 = v54 - 16;
  }

  else
  {
    v38 = 0;
  }

  v76 = mlir::detail::OpResultImpl::getNextResultAtOffset(v38, 0);
  v39 = mlir::Value::getDefiningOp(&v76);
  if (*(v9 + 36))
  {
    v40 = v9 - 16;
  }

  else
  {
    v40 = 0;
  }

  v51 = mlir::detail::OpResultImpl::getNextResultAtOffset(v40, 0);
  v72 = mlir::Value::getDefiningOp(&v51);
  if (*(v7 + 9))
  {
    v41 = v7 - 16;
  }

  else
  {
    v41 = 0;
  }

  v50 = mlir::detail::OpResultImpl::getNextResultAtOffset(v41, 0);
  v73 = mlir::Value::getDefiningOp(&v50);
  if (*(v7 + 9))
  {
    v42 = v7 - 16;
  }

  else
  {
    v42 = 0;
  }

  v43 = mlir::detail::OpResultImpl::getNextResultAtOffset(v42, 0);
  {
    goto LABEL_81;
  }

  mlir::IntegerAttr::getValue(&v70, &v72);
  v44 = v73;
  if (v73 >= 0x41)
  {
    if (v44 - llvm::APInt::countLeadingZerosSlowCase(&v72) >= 0x41)
    {
      if (v72)
      {
        operator delete[](v72);
      }

      goto LABEL_111;
    }

    v45 = *v72;
    operator delete[](v72);
    if (v45 != 1)
    {
LABEL_111:
      goto LABEL_81;
    }
  }

  else if (v72 != 1)
  {
    goto LABEL_111;
  }

  mlir::IntegerAttr::getValue(&v66, &v72);
  v46 = v73;
  if (v73 < 0x41)
  {
    if (v72 != 1)
    {
      goto LABEL_117;
    }

LABEL_114:
    v48 = *(v77[1] + 24);
    v72 = *(*v77 + 24);
    v73 = v48;
    v49 = *(v77[3] + 24);
    v74 = *(v77[2] + 24);
    v75 = v49;
    mlir::Builder::getFusedLoc(a3 + 1, &v72, 4, 0);
  }

  if (v46 - llvm::APInt::countLeadingZerosSlowCase(&v72) >= 0x41)
  {
    if (v72)
    {
      operator delete[](v72);
    }

    goto LABEL_117;
  }

  v47 = *v72;
  operator delete[](v72);
  if (v47 == 1)
  {
    goto LABEL_114;
  }

LABEL_117:
LABEL_81:
  if (v77 != v79)
  {
    free(v77);
  }

  return v22;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#12}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#13}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#14}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(a1 + 16)))
  {
  }

  return 0;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "There's no operation that defines operand 0 of castedOp0";
  v13 = 56;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "castedOp1 is not ::mlir::anec::InputView type";
  v13 = 45;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "There's no operation that defines operand 0 of castedOp1";
  v13 = 56;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.input_view' to have attribute 'dimension' of type '::mlir::IntegerAttr'";
  v13 = 89;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.input_view' to have attribute 'offset' of type '::mlir::IntegerAttr'";
  v13 = 86;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.input_view' to have attribute 'size' of type '::mlir::IntegerAttr'";
  v13 = 84;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.input_view' to have attribute 'step' of type '::mlir::IntegerAttr'";
  v13 = 84;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.input_view' to have attribute 'dimension' of type '::mlir::IntegerAttr'";
  v13 = 89;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.input_view' to have attribute 'offset' of type '::mlir::IntegerAttr'";
  v13 = 86;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.input_view' to have attribute 'size' of type '::mlir::IntegerAttr'";
  v13 = 84;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.input_view' to have attribute 'step' of type '::mlir::IntegerAttr'";
  v13 = 84;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#12}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'conv_op, pad_op, crop_op, out' failed to satisfy constraint: ''";
  v13 = 73;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#13}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'iv1_step' failed to satisfy constraint: ''";
  v13 = 52;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#14}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'iv2_step' failed to satisfy constraint: ''";
  v13 = 52;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

void mlir::anec::anonymous namespace::ANEC_PadDeconvFolding::~ANEC_PadDeconvFolding(mlir::anec::_anonymous_namespace_::ANEC_PadDeconvFolding *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "There's no operation that defines operand 0 of castedOp0";
  v13 = 56;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.deconvolution' to have attribute 'stride' of type '::mlir::DenseIntElementsAttr'";
  v13 = 98;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.deconvolution' to have attribute 'dilation' of type '::mlir::DenseIntElementsAttr'";
  v13 = 100;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.deconvolution' to have attribute 'padding' of type '::mlir::DenseIntElementsAttr'";
  v13 = 99;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_PadDeconvFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'out, pad_op' failed to satisfy constraint: ''";
  v13 = 55;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

uint64_t OUTLINED_FUNCTION_0_21()
{
  if (*(v0 + 36))
  {
    v3 = v1;
  }

  else
  {
    v3 = 0;
  }

  return mlir::detail::OpResultImpl::getNextResultAtOffset(v3, 0);
}

void mlir::anec::getANECLateCanonicalizationPatterns(mlir::ANEPropertiesRegistry *a1)
{
  Instance = mlir::ANEPropertiesRegistry::getInstance(a1);
  Properties = mlir::ANEPropertiesRegistry::getProperties(Instance, *a1);
  if (Properties)
  {
    v4 = *(Properties + 2);
  }

  else
  {
    v4 = 1;
  }

  v5 = *a1;
  v6 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v168, 1);
  mlir::Pattern::Pattern((v6 + 1), "anec.gain_offset_control", 24, v168, v5, 0, 0);
  *v6 = &unk_1F5B34C10;
  if (!v6[9])
  {
    v168 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_GOCFolding]";
    v169 = 100;
    v7 = llvm::StringRef::find(&v168, "DesiredTypeName = ", 0x12uLL, 0);
    if (v169 >= v7)
    {
      v8 = v7;
    }

    else
    {
      v8 = v169;
    }

    v9 = &v168[v8];
    v10 = v169 - v8;
    if (v169 - v8 >= 0x12)
    {
      v11 = 18;
    }

    else
    {
      v11 = v169 - v8;
    }

    v12 = &v9[v11];
    v13 = v10 - v11;
    if (v13 >= v13 - 1)
    {
      --v13;
    }

    v6[8] = v12;
    v6[9] = v13;
  }

  v14 = *(v6 + 22);
  if (v14 > *(v6 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((v6 + 10), (v6 + 12), v14, 16);
    LODWORD(v14) = *(v6 + 22);
  }

  *(v6 + 22) = v14;
  v16 = *(a1 + 2);
  v15 = *(a1 + 3);
  if (v16 >= v15)
  {
    v18 = *(a1 + 1);
    v19 = v16 - v18;
    v20 = (v16 - v18) >> 3;
    v21 = v20 + 1;
    if ((v20 + 1) >> 61)
    {
      goto LABEL_206;
    }

    v22 = v15 - v18;
    if (v22 >> 2 > v21)
    {
      v21 = v22 >> 2;
    }

    if (v22 >= 0x7FFFFFFFFFFFFFF8)
    {
      v23 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v23 = v21;
    }

    if (v23)
    {
      if (v23 >> 61)
      {
        goto LABEL_207;
      }

      v24 = operator new(8 * v23);
    }

    else
    {
      v24 = 0;
    }

    v25 = &v24[8 * v20];
    *v25 = v6;
    v17 = v25 + 8;
    memcpy(v24, v18, v19);
    *(a1 + 1) = v24;
    *(a1 + 2) = v17;
    *(a1 + 3) = &v24[8 * v23];
    if (v18)
    {
      operator delete(v18);
    }
  }

  else
  {
    *v16 = v6;
    v17 = v16 + 8;
  }

  *(a1 + 2) = v17;
  v26 = *a1;
  v27 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v168, 1);
  mlir::Pattern::Pattern((v27 + 1), "anec.invert", 11, v168, v26, 0, 0);
  *v27 = &unk_1F5B34C50;
  if (!v27[9])
  {
    v168 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_InvertFolding]";
    v169 = 103;
    v28 = llvm::StringRef::find(&v168, "DesiredTypeName = ", 0x12uLL, 0);
    if (v169 >= v28)
    {
      v29 = v28;
    }

    else
    {
      v29 = v169;
    }

    v30 = &v168[v29];
    v31 = v169 - v29;
    if (v169 - v29 >= 0x12)
    {
      v32 = 18;
    }

    else
    {
      v32 = v169 - v29;
    }

    v33 = &v30[v32];
    v34 = v31 - v32;
    if (v34 >= v34 - 1)
    {
      --v34;
    }

    v27[8] = v33;
    v27[9] = v34;
  }

  v35 = *(v27 + 22);
  if (v35 > *(v27 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((v27 + 10), (v27 + 12), v35, 16);
    LODWORD(v35) = *(v27 + 22);
  }

  *(v27 + 22) = v35;
  v37 = *(a1 + 2);
  v36 = *(a1 + 3);
  if (v37 >= v36)
  {
    v39 = *(a1 + 1);
    v40 = v37 - v39;
    v41 = (v37 - v39) >> 3;
    v42 = v41 + 1;
    if ((v41 + 1) >> 61)
    {
      goto LABEL_206;
    }

    v43 = v36 - v39;
    if (v43 >> 2 > v42)
    {
      v42 = v43 >> 2;
    }

    if (v43 >= 0x7FFFFFFFFFFFFFF8)
    {
      v44 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v44 = v42;
    }

    if (v44)
    {
      if (v44 >> 61)
      {
        goto LABEL_207;
      }

      v45 = operator new(8 * v44);
    }

    else
    {
      v45 = 0;
    }

    v46 = &v45[8 * v41];
    *v46 = v27;
    v38 = v46 + 8;
    memcpy(v45, v39, v40);
    *(a1 + 1) = v45;
    *(a1 + 2) = v38;
    *(a1 + 3) = &v45[8 * v44];
    if (v39)
    {
      operator delete(v39);
    }
  }

  else
  {
    *v37 = v27;
    v38 = v37 + 8;
  }

  *(a1 + 2) = v38;
  v47 = *a1;
  v48 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v168, 1);
  mlir::Pattern::Pattern((v48 + 1), "anec.mult", 9, v168, v47, 0, 0);
  *v48 = &unk_1F5B34C90;
  if (!v48[9])
  {
    v168 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_MulFolding]";
    v169 = 100;
    v49 = llvm::StringRef::find(&v168, "DesiredTypeName = ", 0x12uLL, 0);
    if (v169 >= v49)
    {
      v50 = v49;
    }

    else
    {
      v50 = v169;
    }

    v51 = &v168[v50];
    v52 = v169 - v50;
    if (v169 - v50 >= 0x12)
    {
      v53 = 18;
    }

    else
    {
      v53 = v169 - v50;
    }

    v54 = &v51[v53];
    v55 = v52 - v53;
    if (v55 >= v55 - 1)
    {
      --v55;
    }

    v48[8] = v54;
    v48[9] = v55;
  }

  v56 = *(v48 + 22);
  if (v56 > *(v48 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((v48 + 10), (v48 + 12), v56, 16);
    LODWORD(v56) = *(v48 + 22);
  }

  *(v48 + 22) = v56;
  v58 = *(a1 + 2);
  v57 = *(a1 + 3);
  if (v58 >= v57)
  {
    v60 = *(a1 + 1);
    v61 = v58 - v60;
    v62 = (v58 - v60) >> 3;
    v63 = v62 + 1;
    if ((v62 + 1) >> 61)
    {
      goto LABEL_206;
    }

    v64 = v57 - v60;
    if (v64 >> 2 > v63)
    {
      v63 = v64 >> 2;
    }

    if (v64 >= 0x7FFFFFFFFFFFFFF8)
    {
      v65 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v65 = v63;
    }

    if (v65)
    {
      if (v65 >> 61)
      {
        goto LABEL_207;
      }

      v66 = operator new(8 * v65);
    }

    else
    {
      v66 = 0;
    }

    v67 = &v66[8 * v62];
    *v67 = v48;
    v59 = v67 + 8;
    memcpy(v66, v60, v61);
    *(a1 + 1) = v66;
    *(a1 + 2) = v59;
    *(a1 + 3) = &v66[8 * v65];
    if (v60)
    {
      operator delete(v60);
    }
  }

  else
  {
    *v58 = v48;
    v59 = v58 + 8;
  }

  *(a1 + 2) = v59;
  v68 = *a1;
  v69 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v168, 1);
  mlir::Pattern::Pattern((v69 + 1), "anec.cast", 9, v168, v68, 0, 0);
  *v69 = &unk_1F5B34CD0;
  if (!v69[9])
  {
    v168 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::CanonicalizeCast]";
    v169 = 101;
    v70 = llvm::StringRef::find(&v168, "DesiredTypeName = ", 0x12uLL, 0);
    if (v169 >= v70)
    {
      v71 = v70;
    }

    else
    {
      v71 = v169;
    }

    v72 = &v168[v71];
    v73 = v169 - v71;
    if (v169 - v71 >= 0x12)
    {
      v74 = 18;
    }

    else
    {
      v74 = v169 - v71;
    }

    v75 = &v72[v74];
    v76 = v73 - v74;
    if (v76 >= v76 - 1)
    {
      --v76;
    }

    v69[8] = v75;
    v69[9] = v76;
  }

  v77 = *(v69 + 22);
  if (v77 > *(v69 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((v69 + 10), (v69 + 12), v77, 16);
    LODWORD(v77) = *(v69 + 22);
  }

  *(v69 + 22) = v77;
  v79 = *(a1 + 2);
  v78 = *(a1 + 3);
  if (v79 >= v78)
  {
    v81 = *(a1 + 1);
    v82 = v79 - v81;
    v83 = (v79 - v81) >> 3;
    v84 = v83 + 1;
    if ((v83 + 1) >> 61)
    {
      goto LABEL_206;
    }

    v85 = v78 - v81;
    if (v85 >> 2 > v84)
    {
      v84 = v85 >> 2;
    }

    if (v85 >= 0x7FFFFFFFFFFFFFF8)
    {
      v86 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v86 = v84;
    }

    if (v86)
    {
      if (v86 >> 61)
      {
        goto LABEL_207;
      }

      v87 = operator new(8 * v86);
    }

    else
    {
      v87 = 0;
    }

    v88 = &v87[8 * v83];
    *v88 = v69;
    v80 = v88 + 8;
    memcpy(v87, v81, v82);
    *(a1 + 1) = v87;
    *(a1 + 2) = v80;
    *(a1 + 3) = &v87[8 * v86];
    if (v81)
    {
      operator delete(v81);
    }
  }

  else
  {
    *v79 = v69;
    v80 = v79 + 8;
  }

  *(a1 + 2) = v80;
  v89 = *a1;
  v90 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v168, 1);
  mlir::Pattern::Pattern((v90 + 1), "anec.scaled_elementwise", 23, v168, v89, 0, 0);
  *v90 = &unk_1F5B34D28;
  if (!v90[9])
  {
    v168 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ConvertScaledEWToGOCForBias]";
    v169 = 112;
    v91 = llvm::StringRef::find(&v168, "DesiredTypeName = ", 0x12uLL, 0);
    if (v169 >= v91)
    {
      v92 = v91;
    }

    else
    {
      v92 = v169;
    }

    v93 = &v168[v92];
    v94 = v169 - v92;
    if (v169 - v92 >= 0x12)
    {
      v95 = 18;
    }

    else
    {
      v95 = v169 - v92;
    }

    v96 = &v93[v95];
    v97 = v94 - v95;
    if (v97 >= v97 - 1)
    {
      --v97;
    }

    v90[8] = v96;
    v90[9] = v97;
  }

  v98 = *(v90 + 22);
  if (v98 > *(v90 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((v90 + 10), (v90 + 12), v98, 16);
    LODWORD(v98) = *(v90 + 22);
  }

  *(v90 + 22) = v98;
  v100 = *(a1 + 2);
  v99 = *(a1 + 3);
  if (v100 >= v99)
  {
    v102 = *(a1 + 1);
    v103 = v100 - v102;
    v104 = (v100 - v102) >> 3;
    v105 = v104 + 1;
    if ((v104 + 1) >> 61)
    {
      goto LABEL_206;
    }

    v106 = v99 - v102;
    if (v106 >> 2 > v105)
    {
      v105 = v106 >> 2;
    }

    if (v106 >= 0x7FFFFFFFFFFFFFF8)
    {
      v107 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v107 = v105;
    }

    if (v107)
    {
      if (v107 >> 61)
      {
        goto LABEL_207;
      }

      v108 = operator new(8 * v107);
    }

    else
    {
      v108 = 0;
    }

    v109 = &v108[8 * v104];
    *v109 = v90;
    v101 = v109 + 8;
    memcpy(v108, v102, v103);
    *(a1 + 1) = v108;
    *(a1 + 2) = v101;
    *(a1 + 3) = &v108[8 * v107];
    if (v102)
    {
      operator delete(v102);
    }
  }

  else
  {
    *v100 = v90;
    v101 = v100 + 8;
  }

  *(a1 + 2) = v101;
  v110 = *a1;
  v111 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v168, 1);
  mlir::Pattern::Pattern((v111 + 1), "anec.scaled_elementwise", 23, v168, v110, 0, 0);
  *v111 = &unk_1F5B34D80;
  if (!v111[9])
  {
    v168 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ConvertScaledEWToGOCForScalarConst]";
    v169 = 119;
    v112 = llvm::StringRef::find(&v168, "DesiredTypeName = ", 0x12uLL, 0);
    if (v169 >= v112)
    {
      v113 = v112;
    }

    else
    {
      v113 = v169;
    }

    v114 = &v168[v113];
    v115 = v169 - v113;
    if (v169 - v113 >= 0x12)
    {
      v116 = 18;
    }

    else
    {
      v116 = v169 - v113;
    }

    v117 = &v114[v116];
    v118 = v115 - v116;
    if (v118 >= v118 - 1)
    {
      --v118;
    }

    v111[8] = v117;
    v111[9] = v118;
  }

  v119 = *(v111 + 22);
  if (v119 > *(v111 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((v111 + 10), (v111 + 12), v119, 16);
    LODWORD(v119) = *(v111 + 22);
  }

  *(v111 + 22) = v119;
  v121 = *(a1 + 2);
  v120 = *(a1 + 3);
  if (v121 >= v120)
  {
    v123 = *(a1 + 1);
    v124 = v121 - v123;
    v125 = (v121 - v123) >> 3;
    v126 = v125 + 1;
    if ((v125 + 1) >> 61)
    {
      goto LABEL_206;
    }

    v127 = v120 - v123;
    if (v127 >> 2 > v126)
    {
      v126 = v127 >> 2;
    }

    if (v127 >= 0x7FFFFFFFFFFFFFF8)
    {
      v128 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v128 = v126;
    }

    if (v128)
    {
      if (v128 >> 61)
      {
        goto LABEL_207;
      }

      v129 = operator new(8 * v128);
    }

    else
    {
      v129 = 0;
    }

    v130 = &v129[8 * v125];
    *v130 = v111;
    v122 = v130 + 8;
    memcpy(v129, v123, v124);
    *(a1 + 1) = v129;
    *(a1 + 2) = v122;
    *(a1 + 3) = &v129[8 * v128];
    if (v123)
    {
      operator delete(v123);
    }
  }

  else
  {
    *v121 = v111;
    v122 = v121 + 8;
  }

  *(a1 + 2) = v122;
  if (v4)
  {
    v131 = *a1;
    v132 = operator new(0x60uLL);
    mlir::PatternBenefit::PatternBenefit(&v168, 1);
    mlir::Pattern::Pattern((v132 + 1), "anec.scaled_elementwise", 23, v168, v131, 0, 0);
    *v132 = &unk_1F5B34DD8;
    if (!v132[9])
    {
      v168 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::InsertDummyMulForScaledEWSquare]";
      v169 = 116;
      v133 = llvm::StringRef::find(&v168, "DesiredTypeName = ", 0x12uLL, 0);
      if (v169 >= v133)
      {
        v134 = v133;
      }

      else
      {
        v134 = v169;
      }

      v135 = &v168[v134];
      v136 = v169 - v134;
      if (v169 - v134 >= 0x12)
      {
        v137 = 18;
      }

      else
      {
        v137 = v169 - v134;
      }

      v138 = &v135[v137];
      v139 = v136 - v137;
      if (v139 >= v139 - 1)
      {
        --v139;
      }

      v132[8] = v138;
      v132[9] = v139;
    }

    v140 = *(v132 + 22);
    if (v140 > *(v132 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((v132 + 10), (v132 + 12), v140, 16);
      LODWORD(v140) = *(v132 + 22);
    }

    *(v132 + 22) = v140;
    v142 = *(a1 + 2);
    v141 = *(a1 + 3);
    if (v142 >= v141)
    {
      v144 = *(a1 + 1);
      v145 = v142 - v144;
      v146 = (v142 - v144) >> 3;
      v147 = v146 + 1;
      if ((v146 + 1) >> 61)
      {
        goto LABEL_206;
      }

      v148 = v141 - v144;
      if (v148 >> 2 > v147)
      {
        v147 = v148 >> 2;
      }

      if (v148 >= 0x7FFFFFFFFFFFFFF8)
      {
        v149 = 0x1FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v149 = v147;
      }

      if (v149)
      {
        if (v149 >> 61)
        {
          goto LABEL_207;
        }

        v150 = operator new(8 * v149);
      }

      else
      {
        v150 = 0;
      }

      v151 = &v150[8 * v146];
      *v151 = v132;
      v143 = v151 + 8;
      memcpy(v150, v144, v145);
      *(a1 + 1) = v150;
      *(a1 + 2) = v143;
      *(a1 + 3) = &v150[8 * v149];
      if (v144)
      {
        operator delete(v144);
      }
    }

    else
    {
      *v142 = v132;
      v143 = v142 + 8;
    }

    *(a1 + 2) = v143;
  }

  v167 = *a1;
  mlir::RewritePattern::create<mlir::anec::ConvertPow2ToMul,mlir::MLIRContext *&>(&v167, &v168);
  v152 = v168;
  v153 = *(v168 + 22);
  if (v153 > *(v168 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((v168 + 80), (v168 + 96), v153, 16);
    LODWORD(v153) = *(v152 + 88);
  }

  *(v152 + 88) = v153;
  v155 = *(a1 + 2);
  v154 = *(a1 + 3);
  if (v155 < v154)
  {
    *v155 = v168;
    *(a1 + 2) = v155 + 8;
    return;
  }

  v156 = *(a1 + 1);
  v157 = v155 - v156;
  v158 = (v155 - v156) >> 3;
  v159 = v158 + 1;
  if ((v158 + 1) >> 61)
  {
LABEL_206:
    std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
  }

  v160 = v154 - v156;
  if (v160 >> 2 > v159)
  {
    v159 = v160 >> 2;
  }

  if (v160 >= 0x7FFFFFFFFFFFFFF8)
  {
    v161 = 0x1FFFFFFFFFFFFFFFLL;
  }

  else
  {
    v161 = v159;
  }

  if (v161)
  {
    if (!(v161 >> 61))
    {
      v162 = operator new(8 * v161);
      goto LABEL_202;
    }

LABEL_207:
    std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
  }

  v162 = 0;
LABEL_202:
  v163 = &v162[8 * v158];
  v164 = v168;
  v168 = 0;
  *v163 = v164;
  v165 = v163 + 1;
  memcpy(v162, v156, v157);
  *(a1 + 1) = v162;
  *(a1 + 2) = v165;
  *(a1 + 3) = &v162[8 * v161];
  if (v156)
  {
    operator delete(v156);
    v166 = v168;
    *(a1 + 2) = v165;
    v168 = 0;
    if (v166)
    {
      (*(*v166 + 8))(v166);
    }
  }
}

void mlir::anec::anonymous namespace::ANEC_GOCFolding::~ANEC_GOCFolding(mlir::anec::_anonymous_namespace_::ANEC_GOCFolding *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::anec::anonymous namespace::foldGOCLike(uint64_t a1, uint64_t a2, void *a3, mlir::AffineMap *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v103[6] = *MEMORY[0x1E69E9840];
  v91 = a5;
  v101 = v103;
  v102 = 0xC00000000;
  v98 = v100;
  v99 = 0xC00000000;
  v95 = v97;
  v96 = 0xC00000000;
  v12 = *(*mlir::getElementTypeOrSelf((*(a7 + 8) & 0xFFFFFFFFFFFFFFF8)) + 136);
  if (v12 == &mlir::detail::TypeIDResolver<mlir::Float4E2M1FNType,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float6E2M3FNType,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float6E3M2FNType,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3Type,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float8E3M4Type,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::matchConstantWithFloatVector<float>(a7, &v101);
  }

  else
  {
    mlir::matchConstantWithIntVector<float>(a7, &v101);
  }

  v29 = *(*mlir::getElementTypeOrSelf((*(a8 + 8) & 0xFFFFFFFFFFFFFFF8)) + 136);
  if (v29 == &mlir::detail::TypeIDResolver<mlir::Float4E2M1FNType,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float6E2M3FNType,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float6E3M2FNType,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3Type,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float8E3M4Type,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id || v29 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::matchConstantWithFloatVector<float>(a8, &v98);
  }

  else
  {
    mlir::matchConstantWithIntVector<float>(a8, &v98);
  }

  if (a9)
  {
    v30 = *(*mlir::getElementTypeOrSelf((*(a9 + 8) & 0xFFFFFFFFFFFFFFF8)) + 136);
    if (v30 == &mlir::detail::TypeIDResolver<mlir::Float4E2M1FNType,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float6E2M3FNType,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float6E3M2FNType,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3Type,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float8E3M4Type,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id || v30 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
    {
      mlir::matchConstantWithFloatVector<float>(a9, &v95);
    }

    else
    {
      mlir::matchConstantWithIntVector<float>(a9, &v95);
    }
  }

  if (a6 < 1)
  {
    v34 = 1;
    v31 = a3;
    v32 = a4;
    goto LABEL_100;
  }

  v31 = a3;
  v32 = a4;
  if (a6 == 1)
  {
    v33 = 0;
    v34 = 1;
LABEL_98:
    v39 = a6 - v33;
    v40 = &a3[v33];
    do
    {
      v41 = *v40++;
      v34 *= v41;
      --v39;
    }

    while (v39);
    goto LABEL_100;
  }

  v33 = a6 & 0x7FFFFFFFFFFFFFFELL;
  v35 = a3 + 1;
  v36 = 1;
  v37 = a6 & 0x7FFFFFFFFFFFFFFELL;
  v38 = 1;
  do
  {
    v36 *= *(v35 - 1);
    v38 *= *v35;
    v35 += 2;
    v37 -= 2;
  }

  while (v37);
  v34 = v38 * v36;
  if (v33 != a6)
  {
    goto LABEL_98;
  }

LABEL_100:
  v42 = a6 + 1;
  if (a6 + 1 >= v32)
  {
    v44 = 1;
    goto LABEL_109;
  }

  v43 = v32 + ~a6;
  if (v43 <= 1)
  {
    v44 = 1;
LABEL_107:
    v49 = v32 - v42;
    v50 = &v31[v42];
    do
    {
      v51 = *v50++;
      v44 *= v51;
      --v49;
    }

    while (v49);
    goto LABEL_109;
  }

  v42 += v43 & 0xFFFFFFFFFFFFFFFELL;
  v45 = &v31[a6 + 2];
  v46 = 1;
  v47 = v43 & 0xFFFFFFFFFFFFFFFELL;
  v48 = 1;
  do
  {
    v46 *= *(v45 - 1);
    v48 *= *v45;
    v45 += 2;
    v47 -= 2;
  }

  while (v47);
  v44 = v48 * v46;
  if (v43 != (v43 & 0xFFFFFFFFFFFFFFFELL))
  {
    goto LABEL_107;
  }

LABEL_109:
  v52 = v31[a6];
  v92 = v94;
  v93 = 0xC00000000;
  if (v34 >= 1)
  {
    v53 = 0;
    v54 = 0;
    for (i = 0; i != v34; ++i)
    {
      if (v52 >= 1)
      {
        v56 = 0;
        v57 = v53;
        do
        {
          v58 = v44;
          v59 = v57;
          if (v44 >= 1)
          {
            do
            {
              if (v102 == 1)
              {
                v60 = 0;
              }

              else
              {
                v60 = v59;
              }

              v61 = v101[v60];
              if (v96)
              {
                if (v96 == 1)
                {
                  v62 = 0;
                }

                else
                {
                  v62 = v56;
                }

                v61 = v61 + *(v95 + v62);
              }

              if (v99 == 1)
              {
                v63 = 0;
              }

              else
              {
                v63 = v56;
              }

              v64 = v98[v63];
              if (v54 >= HIDWORD(v93))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod(&v92, v94, v54 + 1, 4);
                v54 = v93;
              }

              *(v92 + v54) = v61 * v64;
              v54 = v93 + 1;
              LODWORD(v93) = v93 + 1;
              ++v59;
              --v58;
            }

            while (v58);
          }

          ++v56;
          v57 += v44;
        }

        while (v56 != v52);
      }

      v53 += v44 * v52;
    }
  }

  if (mlir::Type::isF16(&v91))
  {
    v89 = mlir::MemRefType::get(a3, a4, v91, 0, 0, 0);
    F32Type = mlir::Builder::getF32Type((a1 + 8), v65);
    v67 = mlir::RankedTensorType::get(a3, a4, F32Type, 0);
    v87[0] = mlir::createRawElementsAttr(v67, v92, 4 * v93);
    v87[1] = v68;
    v69 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::ElementsAttr &>((a1 + 8), a2, &v89, v87);
  }

  else
  {
    v89 = 0;
    v90 = 0;
    v70 = mlir::RankedTensorType::get(a3, a4, v91, 0);
    if (v70)
    {
      v71 = v70;
      v72 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v70 + 8);
      v70 = v71;
    }

    else
    {
      v72 = 0;
    }

    mlir::mps::CPUNDArray::tryMakeAliasedArray(v70, v72, &v89, v87);
    if (mlir::Type::isSignedInteger(&v91, 8))
    {
      if (v93)
      {
        v73 = 0;
        v74 = v88;
        do
        {
          v75 = llroundf(*(v92 + v73));
          if (v75 >= 127)
          {
            v75 = 127;
          }

          if (v75 <= -128)
          {
            LOBYTE(v75) = 0x80;
          }

          *(v74 + v73++) = v75;
        }

        while (v73 < v93);
      }
    }

    else
    {
      mlir::Type::isUnsignedInteger(&v91, 8);
      if (v93)
      {
        v76 = 0;
        v77 = v88;
        do
        {
          v78 = llroundf(*(v92 + v76));
          if (v78 >= 255)
          {
            v78 = 255;
          }

          *(v77 + v76++) = v78 & ~(v78 >> 63);
        }

        while (v76 < v93);
      }
    }

    ElementsAttr = v89;
    if (v89)
    {
      v80 = v90;
    }

    else
    {
      ElementsAttr = mlir::mps::CPUNDArray::getElementsAttr(v87, 0, 0);
    }

    v89 = ElementsAttr;
    v90 = v80;
    v86 = mlir::MemRefType::get(a3, a4, v91, 0, 0, 0);
    v69 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::ElementsAttr &>((a1 + 8), a2, &v86, &v89);
    mlir::mps::CPUNDArray::~CPUNDArray(v87);
  }

  if (v92 != v94)
  {
    free(v92);
  }

  if (v95 != v97)
  {
    free(v95);
  }

  if (v98 != v100)
  {
    free(v98);
  }

  if (v101 != v103)
  {
    free(v101);
  }

  return v69 - 16;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'x' failed to satisfy constraint: 'constant value'";
  v13 = 59;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'scale' failed to satisfy constraint: 'constant value'";
  v13 = 63;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_GOCFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'bias' failed to satisfy constraint: 'constant value'";
  v13 = 62;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

uint64_t mlir::matchConstantWithIntVector<float>(uint64_t a1, uint64_t a2)
{
  v8 = 0;
  v9 = 0;
  if (!a1)
  {
    return 0;
  }

  v7 = &v8;
  v10 = a1;
  DefiningOp = mlir::Value::getDefiningOp(&v10);
  if (!DefiningOp)
  {
    return 0;
  }

  if (!mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v7, DefiningOp))
  {
    return 0;
  }

  v6[0] = mlir::CallOpInterface::getArgOperands(&v8);
  v6[1] = v4;
  if (*(*mlir::ElementsAttr::isSplat(v6) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    return 0;
  }

  mlir::getFloatValues<float>(v8, v9, a2, 1);
  return 1;
}

void mlir::anec::anonymous namespace::ANEC_InvertFolding::~ANEC_InvertFolding(mlir::anec::_anonymous_namespace_::ANEC_InvertFolding *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_InvertFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "expected op 'anec.invert' to have attribute 'epsilon' of type '::mlir::FloatAttr'";
  v13 = 81;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_InvertFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'attr' failed to satisfy constraint: ''";
  v13 = 48;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_InvertFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'x' failed to satisfy constraint: ''";
  v13 = 45;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_InvertFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'x' failed to satisfy constraint: 'constant value'";
  v13 = 59;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

void mlir::anec::anonymous namespace::ANEC_MulFolding::~ANEC_MulFolding(mlir::anec::_anonymous_namespace_::ANEC_MulFolding *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_MulFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'out' failed to satisfy constraint: ''";
  v13 = 47;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_MulFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'x' failed to satisfy constraint: 'constant value'";
  v13 = 59;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

__n128 llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::anonymous namespace::ANEC_MulFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(uint64_t a1, uint64_t a2)
{
  v2 = a2 + 16;
  v3 = *(a2 + 16);
  v11 = 3;
  v12 = "entities 'scale' failed to satisfy constraint: 'constant value'";
  v13 = 63;
  v4 = *(a2 + 24);
  v5 = &v11;
  if (v4 >= *(a2 + 28))
  {
    if (v3 <= &v11 && v3 + 24 * v4 > &v11)
    {
      v9 = &v11 - v3;
      v10 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v10;
      v3 = *(v10 + 16);
      v5 = &v9[v3];
    }

    else
    {
      v8 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2, a2 + 32, v4 + 1, 24);
      a2 = v8;
      v3 = *(v8 + 16);
      v5 = &v11;
    }
  }

  v6 = (v3 + 24 * *(a2 + 24));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a2 + 24);
  return result;
}

void mlir::anec::anonymous namespace::CanonicalizeCast::~CanonicalizeCast(mlir::anec::_anonymous_namespace_::CanonicalizeCast *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::anec::anonymous namespace::CanonicalizeCast::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float16Type **a3)
{
  v24 = *MEMORY[0x1E69E9840];
  v21 = *(*(a2 + 72) + 24);
  if (*(a2 + 36))
  {
    v5 = a2 - 16;
  }

  else
  {
    v5 = 0;
  }

  v20 = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v22 = xmmword_1E0999A78;
  v23 = unk_1E0999A88;
  F16Type = mlir::Builder::getF16Type(a3 + 1, v6);
  v8 = mlir::RankedTensorType::get(&v22, 4, F16Type, 0);
  v22 = xmmword_1E0999A78;
  v23 = unk_1E0999A88;
  v10 = mlir::Builder::getF16Type(a3 + 1, v9);
  v19 = mlir::MemRefType::get(&v22, 4, v10, 0, 0, 0);
  v11 = *(a2 + 24);
  *&v22 = mlir::createSplatF16ElementsAttr(v8, 1.0);
  *(&v22 + 1) = v12;
  v18 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::ElementsAttr &>((a3 + 1), v11, &v19, &v22);
  v13 = *(a2 + 24);
  *&v22 = mlir::createSplatF16ElementsAttr(v8, 0.0);
  *(&v22 + 1) = v14;
  v17 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::ElementsAttr &>((a3 + 1), v13, &v19, &v22);
  v15 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>((a3 + 1), *(a2 + 24), &v20, &v21, &v18, &v17);
  (*(*a3 + 1))(a3, a2, v15);
  return 1;
}

void mlir::anec::anonymous namespace::ConvertScaledEWToGOCForBias::~ConvertScaledEWToGOCForBias(mlir::anec::_anonymous_namespace_::ConvertScaledEWToGOCForBias *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::anec::anonymous namespace::ConvertScaledEWToGOCForBias::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  v145 = *MEMORY[0x1E69E9840];
  v113 = a2;
  Mode = mlir::anec::ScaledElementWise::getMode(&v113);
  if (!v5)
  {
    return 0;
  }

  if (v5 >= 3)
  {
    v6 = 3;
  }

  else
  {
    v6 = v5;
  }

  v7 = v5;
  v8 = memcmp(Mode, "add", v6);
  result = 0;
  if (v7 != 3 || v8)
  {
    return result;
  }

  v10 = v113;
  v131 = 0;
  v132 = 0;
  v127 = 0;
  v128 = &v131;
  LOBYTE(v129) = 0;
  v130 = 0;
  v126 = &v128;
  v123[0] = &v126;
  v123[1] = &v132;
  v124 = 0;
  v125 = 0;
  v11 = v113 - 16;
  if (*(v113 + 9))
  {
    v12 = v113 - 16;
  }

  else
  {
    v12 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v12, 0);
  DefiningOp = mlir::Value::getDefiningOp(&NextResultAtOffset);
  if (DefiningOp && mlir::detail::RecursivePatternMatcherBinaryCommutative<mlir::anec::ScaledElementWise,mlir::detail::RecursivePatternMatcherBinder<mlir::anec::Transpose,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::anec::Transpose,0,mlir::detail::op_matcher_with_bind<mlir::anec::Linear>>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(v123, DefiningOp))
  {
    v14 = v132;
    v122 = v132;
    if (*(v132 + 36))
    {
      v15 = v132 - 16;
    }

    else
    {
      v15 = 0;
    }

    v16 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v16)
    {
      v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v16 + 8);
    }

    else
    {
      v17 = 0;
    }

    v120 = v16;
    v121 = v17;
    if (v130)
    {
      v18 = v129;
    }

    else
    {
      v18 = v127;
    }

    v118 = v127;
    v119 = v18;
    NextResultAtOffset = v144;
    p_Axes = 0x300000000;
    v139 = v141;
    v140 = 0x300000000;
    Axes = mlir::anec::Softmax::getAxes(&v119);
    mlir::getListOfPairs<long long>(&Axes, &NextResultAtOffset);
    Axes = mlir::anec::Softmax::getAxes(&v118);
    mlir::getListOfPairs<long long>(&Axes, &v139);
    mlir::CallableOpInterface::getArgAttrsAttr(&v120);
    v20 = v19;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v19);
    v23 = v22;
    v24 = mlir::anec::getIndexFromDim(3, v20);
    v26 = 0;
    if ((v23 & 1) != 0 && (v25 & 1) != 0 && p_Axes == 2)
    {
      v26 = 0;
      if (*NextResultAtOffset == IndexFromDim && NextResultAtOffset[1] == v24 || *NextResultAtOffset == v24 && NextResultAtOffset[1] == IndexFromDim)
      {
        if ((v27 = NextResultAtOffset[2], v27 == IndexFromDim) && NextResultAtOffset[3] == v24 || v27 == v24 && NextResultAtOffset[3] == IndexFromDim)
        {
          v26 = 1;
        }
      }
    }

    mlir::CallableOpInterface::getArgAttrsAttr(&v120);
    v29 = v28;
    v30 = mlir::anec::getIndexFromDim(1, v28);
    v32 = v31;
    v33 = mlir::anec::getIndexFromDim(4, v29);
    if ((v32 & 1) != 0 && (v34 & 1) != 0 && p_Axes == 2 && (*NextResultAtOffset == v30 && NextResultAtOffset[1] == v33 || *NextResultAtOffset == v33 && NextResultAtOffset[1] == v30))
    {
      v35 = NextResultAtOffset[2];
      if (v35 == v30 && NextResultAtOffset[3] == v33)
      {
        goto LABEL_50;
      }

      if (v35 == v33)
      {
        v36 = NextResultAtOffset[3] == v30 || v26;
        if ((v36 & 1) == 0)
        {
          goto LABEL_78;
        }

LABEL_50:
        mlir::CallableOpInterface::getArgAttrsAttr(&v120);
        v38 = v37;
        v39 = mlir::anec::getIndexFromDim(1, v37);
        v41 = v40;
        v42 = mlir::anec::getIndexFromDim(3, v38);
        if ((v41 & 1) == 0 || (v43 & 1) == 0 || v140 != 2 || (*v139 != v39 || v139[1] != v42) && (*v139 != v42 || v139[1] != v39) || ((v44 = v139[2], v44 != v39) || v139[3] != v42) && (v44 != v42 || v139[3] != v39))
        {
          mlir::CallableOpInterface::getArgAttrsAttr(&v120);
          v46 = v45;
          v47 = mlir::anec::getIndexFromDim(1, v45);
          v49 = v48;
          v50 = mlir::anec::getIndexFromDim(4, v46);
          v52 = 0;
          if ((v49 & 1) == 0 || (v51 & 1) == 0 || v140 != 2)
          {
            goto LABEL_79;
          }

          if ((*v139 != v47 || v139[1] != v50) && (*v139 != v50 || v139[1] != v47))
          {
            goto LABEL_78;
          }

          v53 = v139[2];
          if ((v53 != v47 || v139[3] != v50) && (v53 != v50 || v139[3] != v47))
          {
            goto LABEL_78;
          }
        }

        if (v26)
        {
          v54 = 3;
        }

        else
        {
          v54 = 4;
        }

        {
          mlir::CallableOpInterface::getArgAttrsAttr(&v120);
          v56 = v55;
          Axes = v138;
          v137 = 6;
          if (v55 < 7)
          {
            if (!v55)
            {
LABEL_112:
              v136 = v56;
              mlir::CallableOpInterface::getArgAttrsAttr(&v120);
              v72 = mlir::anec::getIndexFromDim(1, v71);
              v52 = v73;
              if (v73)
              {
                v74 = v72;
                ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v120);
                NumElements = mlir::ShapedType::getNumElements(ArgAttrsAttr, v76);
                v78 = Axes;
                *(Axes + v74) = NumElements;
                v79 = v136;
                isSplat = mlir::ElementsAttr::isSplat(&v120);
                v81 = mlir::MemRefType::get(v78, v79, isSplat, 0, 0, 0);
                v116 = v81;
                AsAttribute = mlir::mps::ConstantOp::getAsAttribute(&v122);
                if (v81)
                {
                  v84 = AsAttribute;
                  v85 = v83;
                  v86 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v81 + 8);
                  v83 = v85;
                  v87 = v86;
                  AsAttribute = v84;
                }

                else
                {
                  v87 = 0;
                }

                v115[0] = mlir::rewriteElementsAttr(AsAttribute, v83, v81, v87, 0);
                v115[1] = v88;
                v89 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::ElementsAttr &>((a3 + 8), *(v122 + 24), &v116, v115);
                v90 = v131;
                v111 = *(a3 + 24);
                v91 = *(v131 + 16);
                v93 = *(MPSGraphDelegateCompiler.precompilationDescriptor.modify(v131, v92) + 8);
                v112 = (a3 + 24);
                *(a3 + 24) = v91;
                *(a3 + 32) = v93;
                v94 = *(v90 + 24);
                if (*(v90 + 36))
                {
                  v95 = v90 - 16;
                }

                else
                {
                  v95 = 0;
                }

                v134 = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v95, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
                if (*(v90 + 36))
                {
                  v96 = v90 - 16;
                }

                else
                {
                  v96 = 0;
                }

                v133 = mlir::detail::OpResultImpl::getNextResultAtOffset(v96, 0);
                if (*(v89 + 36))
                {
                  v97 = v89 - 16;
                }

                else
                {
                  v97 = 0;
                }

                v114 = mlir::detail::OpResultImpl::getNextResultAtOffset(v97, 0);
                v98 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType,mlir::Value &,mlir::mps::ConstantOp &,mlir::Value &>((a3 + 8), v94, &v134, &v133, &ScalarConst, &v114);
                if (*(v90 + 36))
                {
                  v99 = v90 - 16;
                }

                else
                {
                  v99 = 0;
                }

                v100 = mlir::detail::OpResultImpl::getNextResultAtOffset(v99, 0);
                if (*(v98 + 36))
                {
                  v101 = v98 - 16;
                }

                else
                {
                  v101 = 0;
                }

                v102 = mlir::detail::OpResultImpl::getNextResultAtOffset(v101, 0);
                v133 = &v134;
                v134 = v98;
                mlir::RewriterBase::replaceUsesWithIf(a3, v100, v102, llvm::function_ref<BOOL ()(mlir::OpOperand &)>::callback_fn<mlir::RewriterBase::replaceAllUsesExcept(mlir::Value,mlir::Value,mlir::Operation *)::{lambda(mlir::OpOperand &)#1}>, &v133, 0);
                if (*(v10 + 9))
                {
                  v103 = v11;
                }

                else
                {
                  v103 = 0;
                }

                v104 = *mlir::detail::OpResultImpl::getNextResultAtOffset(v103, 0);
                if (v104)
                {
                  v105 = *(*(v10 + 9) + 24);
                  do
                  {
                    v106 = *v104;
                    v107 = v104[2];
                    (*(*a3 + 40))(a3, v107);
                    v108 = v104[1];
                    if (v108)
                    {
                      v109 = *v104;
                      *v108 = *v104;
                      if (v109)
                      {
                        v109[1] = v104[1];
                      }
                    }

                    v104[3] = v105;
                    v104[1] = v105;
                    v110 = *v105;
                    *v104 = *v105;
                    if (v110)
                    {
                      *(v110 + 8) = v104;
                    }

                    *v105 = v104;
                    (*(*a3 + 48))(a3, v107);
                    v104 = v106;
                  }

                  while (v106);
                }

                if (v111)
                {
                  *v112 = v111;
                }

                else
                {
                  *v112 = 0;
                  *(a3 + 32) = 0;
                }
              }

              if (Axes != v138)
              {
                free(Axes);
              }

LABEL_79:
              if (v139 != v141)
              {
                free(v139);
              }

              if (NextResultAtOffset != v144)
              {
                free(NextResultAtOffset);
              }

              if (v52)
              {
                return 1;
              }

              goto LABEL_84;
            }

            v58 = 8 * v55;
            v57 = v138;
          }

          else
          {
            v136 = 0;
            llvm::SmallVectorBase<unsigned int>::grow_pod(&Axes, v138, v55, 8);
            v57 = Axes;
            v58 = 8 * v56;
          }

          memset_pattern16(v57, &unk_1E096FAE0, v58);
          goto LABEL_112;
        }

LABEL_78:
        v52 = 0;
        goto LABEL_79;
      }
    }

    if (!v26)
    {
      goto LABEL_78;
    }

    goto LABEL_50;
  }

LABEL_84:
  v59 = v113;
  Axes = 0;
  v123[0] = 0;
  NextResultAtOffset = v123;
  p_Axes = &Axes;
  v144[0] = 0;
  v144[8] = 0;
  if (*(v113 + 9))
  {
    v60 = v113 - 16;
  }

  else
  {
    v60 = 0;
  }

  v139 = mlir::detail::OpResultImpl::getNextResultAtOffset(v60, 0);
  result = mlir::Value::getDefiningOp(&v139);
  if (result)
  {
    result = mlir::detail::RecursivePatternMatcherBinaryCommutative<mlir::anec::ScaledElementWise,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(&NextResultAtOffset, result);
    if (result)
    {
      v139 = v123[0];
      result = mlir::Value::getDefiningOp(&v139);
      if (result)
      {
        v61 = *(*(result + 48) + 16);
        if (v61 != &mlir::detail::TypeIDResolver<mlir::anec::Linear,void>::id && v61 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
        {
          return 0;
        }

        v62 = result;
        v63 = Axes;
        if (result)
        {
          v64 = *(v59 + 3);
          if (v63[9])
          {
            v65 = (v63 - 4);
          }

          else
          {
            v65 = 0;
          }

          v66 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v65, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (v66)
          {
            v67 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v66 + 8);
          }

          else
          {
            v67 = 0;
          }

          if (*(v59 + 9))
          {
            v68 = v59 - 16;
          }

          else
          {
            v68 = 0;
          }

          v128 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v68, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          v126 = (v62 - 16);
          if (v63[9])
          {
            v69 = (v63 - 4);
          }

          else
          {
            v69 = 0;
          }

          v120 = mlir::detail::OpResultImpl::getNextResultAtOffset(v69, 0);
          v70 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType,mlir::Value &,mlir::mps::ConstantOp &,mlir::Value &>((a3 + 8), *(v59 + 3), &v128, &v126, &v139, &v120);
          (*(*a3 + 8))(a3, v59, v70);
          return 1;
        }
      }
    }
  }

  return result;
}