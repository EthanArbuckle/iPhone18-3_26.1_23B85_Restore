CC_SHA256_CTX ***_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZZ42__MPSGraphExecutable_aneRegionOpsHashSet__ENK4__30clENS1_4func6FuncOpEENKUlNS1_9placement10RegionCallEE_clESF_EUlNS1_3mps10ConstantOpEE_SI_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_(CC_SHA256_CTX ***result, uint64_t a2)
{
  if (a2)
  {
    if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
    {
      v9[5] = v2;
      v9[6] = v3;
      v4 = *result;
      v9[0] = a2;
      AsAttribute = mlir::mps::ConstantOp::getAsAttribute(v9);
      ElementsAttrRawData = mlir::getElementsAttrRawData(AsAttribute);
      v8 = v7;
      CC_SHA256_Update(*v4, ElementsAttrRawData, v7);
      return CC_SHA256_Update(v4[1], ElementsAttrRawData, v8);
    }
  }

  return result;
}

void sub_1E08E57C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, char a17)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  llvm::SmallVector<std::string,2u>::~SmallVector(&a17);
  _Unwind_Resume(a1);
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorERZ32getConstantResourcesUsedInModuleINS1_3mps13serialization8ModuleOpEEP7NSArrayIP8NSStringET_EUlNSC_10ConstantOpEE_SL_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESV_E4typeES3_OT1_EUlS3_E_EEvlS3_(void ****a1, uint64_t a2)
{
  if (a2 && *(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
  {
    v2 = *a1;
    v16 = a2;
    AsAttribute = mlir::mps::ConstantOp::getAsAttribute(&v16);
    v4 = *(*AsAttribute + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id ? AsAttribute : 0;
    v15 = v4;
    if (v4)
    {
      v5 = **v2;
      v6 = MEMORY[0x1E696AEC0];
      *&v7 = mlir::mps::MPSBufferTensorAttr::getHandle(&v15, &v12).n128_u64[0];
      v8 = *v12.n128_u64[0];
      if (*v12.n128_u64[0])
      {
        v9 = *(v12.n128_u64[0] + 8);
        if (v9 >= 0x7FFFFFFFFFFFFFF8)
        {
          std::string::__throw_length_error[abi:ne200100]();
        }

        if (v9 >= 0x17)
        {
          operator new();
        }

        HIBYTE(v14) = *(v12.n128_u64[0] + 8);
        if (v9)
        {
          memmove(__dst, v8, v9);
        }

        *(__dst + v9) = 0;
        if (v14 >= 0)
        {
          v10 = __dst;
        }

        else
        {
          v10 = __dst[0];
        }
      }

      else
      {
        __dst[0] = 0;
        __dst[1] = 0;
        v10 = __dst;
        v14 = 0;
      }

      v11 = [v6 stringWithUTF8String:{v10, v7}];
      [v5 addObject:v11];

      if (SHIBYTE(v14) < 0)
      {
        operator delete(__dst[0]);
      }
    }
  }
}

void sub_1E08E5A04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t llvm::SmallVector<std::string,2u>::~SmallVector(uint64_t a1)
{
  v2 = *a1;
  v3 = *(a1 + 8);
  if (v3)
  {
    v4 = v2 + 24 * v3 - 1;
    v5 = -24 * v3;
    v6 = v4;
    do
    {
      v7 = *v6;
      v6 -= 24;
      if (v7 < 0)
      {
        operator delete(*(v4 - 23));
      }

      v4 = v6;
      v5 += 24;
    }

    while (v5);
    v2 = *a1;
  }

  if (v2 != (a1 + 16))
  {
    free(v2);
  }

  return a1;
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorERZ32getConstantResourcesUsedInModuleINS1_8ModuleOpEEP7NSArrayIP8NSStringET_EUlNS1_3mps10ConstantOpEE_SK_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESU_E4typeES3_OT1_EUlS3_E_EEvlS3_(void ****a1, uint64_t a2)
{
  if (a2 && *(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
  {
    v2 = *a1;
    v16 = a2;
    AsAttribute = mlir::mps::ConstantOp::getAsAttribute(&v16);
    v4 = *(*AsAttribute + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id ? AsAttribute : 0;
    v15 = v4;
    if (v4)
    {
      v5 = **v2;
      v6 = MEMORY[0x1E696AEC0];
      *&v7 = mlir::mps::MPSBufferTensorAttr::getHandle(&v15, &v12).n128_u64[0];
      v8 = *v12.n128_u64[0];
      if (*v12.n128_u64[0])
      {
        v9 = *(v12.n128_u64[0] + 8);
        if (v9 >= 0x7FFFFFFFFFFFFFF8)
        {
          std::string::__throw_length_error[abi:ne200100]();
        }

        if (v9 >= 0x17)
        {
          operator new();
        }

        HIBYTE(v14) = *(v12.n128_u64[0] + 8);
        if (v9)
        {
          memmove(__dst, v8, v9);
        }

        *(__dst + v9) = 0;
        if (v14 >= 0)
        {
          v10 = __dst;
        }

        else
        {
          v10 = __dst[0];
        }
      }

      else
      {
        __dst[0] = 0;
        __dst[1] = 0;
        v10 = __dst;
        v14 = 0;
      }

      v11 = [v6 stringWithUTF8String:{v10, v7}];
      [v5 addObject:v11];

      if (SHIBYTE(v14) < 0)
      {
        operator delete(__dst[0]);
      }
    }
  }
}

void sub_1E08E5C40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZ35__MPSGraphExecutable_functionNames_E4__34NS1_4func6FuncOpEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESL_E4typeES3_OT1_EUlS3_E_EEvlS3_(void ****a1, uint64_t a2)
{
  if (a2 && *(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    v2 = *a1;
    v13 = a2;
    SymName = mlir::func::FuncOp::getSymName(&v13);
    if (SymName)
    {
      v5 = v4;
      if (v4 >= 0x7FFFFFFFFFFFFFF8)
      {
        std::string::__throw_length_error[abi:ne200100]();
      }

      if (v4 >= 0x17)
      {
        operator new();
      }

      HIBYTE(v12) = v4;
      if (v4)
      {
        memmove(&__p, SymName, v4);
      }

      *(&__p + v5) = 0;
    }

    else
    {
      __p = 0;
      v11 = 0;
      v12 = 0;
    }

    v6 = **v2;
    v7 = objc_alloc(MEMORY[0x1E696AEC0]);
    if (v12 >= 0)
    {
      p_p = &__p;
    }

    else
    {
      p_p = __p;
    }

    v9 = [v7 initWithUTF8String:{p_p, __p, v11, v12}];
    [v6 addObject:v9];

    if (SHIBYTE(v12) < 0)
    {
      operator delete(__p);
    }
  }
}

void sub_1E08E5DBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void *std::unique_ptr<RuntimeCacheEntry>::~unique_ptr[abi:ne200100](void *result)
{
  v1 = *result;
  *result = 0;
  if (v1)
  {
    v2 = result;
    v3 = *(v1 + 120);
    *(v1 + 120) = 0;
    if (v3)
    {
      (*(*v3 + 64))(v3);
    }

    std::condition_variable::~condition_variable((v1 + 64));
    std::mutex::~mutex(v1);
    MEMORY[0x1E12E5B90]();
    return v2;
  }

  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<MPSGraphExecutableSpecializedModule const*,std::unique_ptr<RuntimeCacheEntry>,llvm::DenseMapInfo<MPSGraphExecutableSpecializedModule const*,void>,llvm::detail::DenseMapPair<MPSGraphExecutableSpecializedModule const*,std::unique_ptr<RuntimeCacheEntry>>>,MPSGraphExecutableSpecializedModule const*,std::unique_ptr<RuntimeCacheEntry>,llvm::DenseMapInfo<MPSGraphExecutableSpecializedModule const*,void>,llvm::detail::DenseMapPair<MPSGraphExecutableSpecializedModule const*,std::unique_ptr<RuntimeCacheEntry>>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer(16 * v8, 8uLL);
  v10 = result;
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v11 = *(a1 + 16);
    if (v11)
    {
      if (((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
      {
        goto LABEL_10;
      }

      v12 = ((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      v10 = &result[2 * (v12 & 0x1FFFFFFFFFFFFFFELL)];
      v13 = result + 2;
      v14 = v12 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(v13 - 2) = -4096;
        *v13 = -4096;
        v13 += 4;
        v14 -= 2;
      }

      while (v14);
      if (v12 != (v12 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_10:
        v15 = &result[2 * v11];
        do
        {
          *v10 = -4096;
          v10 += 2;
        }

        while (v10 != v15);
      }
    }

    if (v3)
    {
      v16 = v4;
      do
      {
        v17 = *v16;
        if ((*v16 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v18 = *(a1 + 16) - 1;
          v19 = v18 & ((v17 >> 4) ^ (v17 >> 9));
          v20 = (*a1 + 16 * v19);
          v21 = *v20;
          if (v17 != *v20)
          {
            v25 = 0;
            v26 = 1;
            while (v21 != -4096)
            {
              if (v25)
              {
                v27 = 0;
              }

              else
              {
                v27 = v21 == -8192;
              }

              if (v27)
              {
                v25 = v20;
              }

              v28 = v19 + v26++;
              v19 = v28 & v18;
              v20 = (*a1 + 16 * (v28 & v18));
              v21 = *v20;
              if (v17 == *v20)
              {
                goto LABEL_18;
              }
            }

            if (v25)
            {
              v20 = v25;
            }
          }

LABEL_18:
          v22 = *(v16 + 1);
          *(v16 + 1) = 0;
          *v20 = v17;
          v20[1] = v22;
          ++*(a1 + 8);
          v23 = *(v16 + 1);
          *(v16 + 1) = 0;
          if (v23)
          {
            v24 = *(v23 + 120);
            *(v23 + 120) = 0;
            if (v24)
            {
              (*(*v24 + 64))(v24);
            }

            std::condition_variable::~condition_variable((v23 + 64));
            std::mutex::~mutex(v23);
            MEMORY[0x1E12E5B90]();
          }
        }

        v16 = (v16 + 16);
      }

      while (v16 != (v4 + 16 * v3));
    }

    llvm::deallocate_buffer(v4, (16 * v3));
  }

  *(a1 + 8) = 0;
  v29 = *(a1 + 16);
  if (v29)
  {
    if (((v29 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
    {
      goto LABEL_41;
    }

    v30 = ((v29 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    v10 = &result[2 * (v30 & 0x1FFFFFFFFFFFFFFELL)];
    v31 = result + 2;
    v32 = v30 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v31 - 2) = -4096;
      *v31 = -4096;
      v31 += 4;
      v32 -= 2;
    }

    while (v32);
    if (v30 != (v30 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_41:
      v33 = &result[2 * v29];
      do
      {
        *v10 = -4096;
        v10 += 2;
      }

      while (v10 != v33);
    }
  }

  return result;
}

void sub_1E08E6774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  std::unordered_map<mlir::Operation *,std::unique_ptr<CPU::BaseOpHandler>>::~unordered_map[abi:ne200100](v18);
  BaseRuntime::~BaseRuntime(v16);

  MEMORY[0x1E12E5B90](v16, 0x10A1C40010F9A6CLL);
  *a15 = 0;
  _Unwind_Resume(a1);
}

RuntimeSpecializationsCache **std::unique_ptr<RuntimeSpecializationsCache>::~unique_ptr[abi:ne200100](RuntimeSpecializationsCache **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    RuntimeSpecializationsCache::~RuntimeSpecializationsCache(v2);
  }

  return a1;
}

uint64_t std::unordered_map<mlir::Operation *,std::unique_ptr<CPU::BaseOpHandler>>::~unordered_map[abi:ne200100](uint64_t a1)
{
  v2 = *(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = *v2;
      v4 = v2[3];
      v2[3] = 0;
      if (v4)
      {
        MEMORY[0x1E12E5B90](v4, 0x81C40B8603338);
      }

      operator delete(v2);
      v2 = v3;
    }

    while (v3);
  }

  v5 = *a1;
  *a1 = 0;
  if (v5)
  {
    operator delete(v5);
  }

  return a1;
}

uint64_t std::function<std::unique_ptr<BaseRuntime> ()(void)>::~function(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
    return a1;
  }

  else
  {
    if (v2)
    {
      (*(*v2 + 40))(v2);
    }

    return a1;
  }
}

void std::__shared_ptr_emplace<ModuleResourcesLoader>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F5B54370;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E12E5B90);
}

void std::__shared_ptr_emplace<ModuleResourcesLoader>::__on_zero_shared(uint64_t a1)
{
  v2 = *(a1 + 24);
}

uint64_t llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<isEntryFunctionFullyOnANE(mlir::func::FuncOp)::$_0>(uint64_t **a1, uint64_t a2)
{
  if (!a2)
  {
    goto LABEL_8;
  }

  v3 = *(*(a2 + 48) + 16);
  if (v3 == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id)
  {
    if (*(a2 + 36))
    {
      v10 = a2 - 16;
    }

    else
    {
      v10 = 0;
    }

    v11 = *mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0);
    if (!v11 || *v11)
    {
      return 0;
    }

    v12 = v11[2];
    v13 = **a1;
    if (v13)
    {
      if (v12 != v13)
      {
        return 0;
      }
    }

    else
    {
      **a1 = v12;
    }

    result = 0;
    v15 = *(*(a2 + 72) + 24);
    if (!v15 || (*(v15 + 8) & 7) != 7)
    {
      return result;
    }

    v16 = a1[1];
    v17 = *(v15 + 24);
    v18 = *(v16 + 16);
    if (v18)
    {
      v19 = (v18 - 1) & (37 * v17);
      v20 = *(*v16 + 4 * v19);
      if (v20 == v17)
      {
LABEL_37:
        if (v19 != v18)
        {
          return 0;
        }
      }

      else
      {
        v21 = 1;
        while (v20 != -1)
        {
          v22 = v19 + v21++;
          v19 = v22 & (v18 - 1);
          v20 = *(*v16 + 4 * v19);
          if (v20 == v17)
          {
            goto LABEL_37;
          }
        }
      }
    }

    v25 = v17;
    llvm::DenseMapBase<llvm::DenseMap<unsigned int,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseSetPair<unsigned int>>,unsigned int,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseSetPair<unsigned int>>::try_emplace<llvm::detail::DenseSetEmpty&>(v26, v16, &v25);
    return 1;
  }

  if (v3 == &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
  {
    v4 = a2;
  }

  else
  {
    v4 = 0;
  }

  v26[0] = v4;
  if (v3 == &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
  {
    if (**a1 == a2)
    {
      result = mlir::placement::RegionCall::getRegionType(v26);
      if (result == 1)
      {
        return result;
      }
    }

    return 0;
  }

  if (v3 == &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id)
  {
    v14 = **a1;
    v26[0] = *(*(a2 + 72) + 24);
    return v14 == mlir::Value::getDefiningOp(v26);
  }

LABEL_8:
  {
    v23 = llvm::getTypeName<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v23, v24);
  }

  result = (*(**(a2 + 48) + 32))(*(a2 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id);
  if (result)
  {
    if ((*(a2 + 46) & 0x80) != 0)
    {
      v6 = *(a2 + 68);
      if (v6)
      {
        for (i = (*(a2 + 72) + 24); ; i += 4)
        {
          v26[0] = *i;
          DefiningOp = mlir::Value::getDefiningOp(v26);
          if (!DefiningOp || *(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id || !*v26[0] || **v26[0])
          {
            break;
          }

          if (!--v6)
          {
            return 1;
          }
        }

        return 0;
      }
    }

    return 1;
  }

  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<unsigned int,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseSetPair<unsigned int>>,unsigned int,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseSetPair<unsigned int>>::try_emplace<llvm::detail::DenseSetEmpty&>(uint64_t result, uint64_t a2, _DWORD *a3)
{
  v3 = *(a2 + 16);
  if (!v3)
  {
    v7 = 0;
    goto LABEL_5;
  }

  v4 = *a2;
  v5 = v3 - 1;
  v6 = (37 * *a3) & (v3 - 1);
  v7 = (*a2 + 4 * v6);
  v8 = *v7;
  if (*a3 != *v7)
  {
    v11 = 0;
    v12 = 1;
    while (v8 != -1)
    {
      if (v11)
      {
        v13 = 0;
      }

      else
      {
        v13 = v8 == -2;
      }

      if (v13)
      {
        v11 = v7;
      }

      v14 = v6 + v12++;
      v6 = v14 & v5;
      v7 = (v4 + 4 * (v14 & v5));
      v8 = *v7;
      if (*a3 == *v7)
      {
        goto LABEL_3;
      }
    }

    if (v11)
    {
      v7 = v11;
    }

LABEL_5:
    v18 = v7;
    v10 = *(a2 + 8);
    if (4 * v10 + 4 >= 3 * v3)
    {
      v3 *= 2;
    }

    else if (v3 + ~v10 - *(a2 + 12) > v3 >> 3)
    {
      *(a2 + 8) = v10 + 1;
      if (*v7 == -1)
      {
LABEL_9:
        *v7 = *a3;
        v4 = *a2;
        v3 = *(a2 + 16);
        v9 = 1;
        goto LABEL_10;
      }

LABEL_8:
      --*(a2 + 12);
      goto LABEL_9;
    }

    v15 = result;
    v16 = a2;
    v17 = a3;
    llvm::DenseMap<unsigned int,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseSetPair<unsigned int>>::grow(a2, v3);
    llvm::DenseMapBase<llvm::DenseMap<unsigned int,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseSetPair<unsigned int>>,unsigned int,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseSetPair<unsigned int>>::LookupBucketFor<unsigned int>(v16, v17, &v18);
    a3 = v17;
    a2 = v16;
    result = v15;
    v7 = v18;
    ++*(v16 + 8);
    if (*v7 == -1)
    {
      goto LABEL_9;
    }

    goto LABEL_8;
  }

LABEL_3:
  v9 = 0;
LABEL_10:
  *result = v7;
  *(result + 8) = v4 + 4 * v3;
  *(result + 16) = v9;
  return result;
}

void _GLOBAL__sub_I_MPSGraphExecutable_mm()
{
  v0 = objc_autoreleasePoolPush();
  __cxa_atexit(MPSGraphExecutableEVOptions::~MPSGraphExecutableEVOptions, &byte_1EED2BC58, &dword_1DF9BF000);

  objc_autoreleasePoolPop(v0);
}

void sub_1E08E73DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  if (a28 < 0)
  {
    operator delete(__p);

    if ((a14 & 0x80000000) == 0)
    {
LABEL_3:

      _Unwind_Resume(a1);
    }
  }

  else
  {

    if ((a14 & 0x80000000) == 0)
    {
      goto LABEL_3;
    }
  }

  operator delete(a9);

  _Unwind_Resume(a1);
}

void sub_1E08E7B18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a19 < 0)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0)
    {
LABEL_3:

      if ((SHIBYTE(a12) & 0x80000000) == 0)
      {
        goto LABEL_4;
      }

      goto LABEL_7;
    }
  }

  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }

  operator delete(a20);

  if ((SHIBYTE(a12) & 0x80000000) == 0)
  {
LABEL_4:

    _Unwind_Resume(a1);
  }

LABEL_7:
  JUMPOUT(0x1E08E7B7CLL);
}

void sub_1E08E7B6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    JUMPOUT(0x1E08E7B7CLL);
  }

  JUMPOUT(0x1E08E7B38);
}

void mlir::OpInterface<mlir::CallOpInterface,mlir::detail::CallOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::CallOpInterface>();
    mlir::detail::TypeIDResolver<mlir::CallOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::CallOpInterface>();
    mlir::detail::TypeIDResolver<mlir::CallOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::CallableOpInterface,mlir::detail::CallableOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::CallableOpInterface>();
    mlir::detail::TypeIDResolver<mlir::CallableOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::CallableOpInterface>();
    mlir::detail::TypeIDResolver<mlir::CallableOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

char *llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<anonymous namespace::BlockInfoBuilder::BlockInfoBuilder(mlir::Block *)::{lambda(mlir::Operation *)#1}>(char *result, uint64_t a2)
{
  v3 = *result;
  v4 = *(a2 + 36);
  if (v4)
  {
    v5 = a2 - 16;
  }

  else
  {
    v5 = 0;
  }

  if (v4)
  {
    for (i = 0; i != v4; ++i)
    {
      result = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, i);
      v7 = *(v3 + 328);
      if (*(v3 + 336) != v7)
      {
        goto LABEL_7;
      }

      v8 = *(v3 + 348);
      if (v8)
      {
        v9 = 8 * v8;
        v10 = *(v3 + 328);
        while (*v10 != result)
        {
          ++v10;
          v9 -= 8;
          if (!v9)
          {
            goto LABEL_14;
          }
        }

        continue;
      }

LABEL_14:
      if (v8 < *(v3 + 344))
      {
        *(v3 + 348) = v8 + 1;
        *(v7 + 8 * v8) = result;
      }

      else
      {
LABEL_7:
        result = llvm::SmallPtrSetImplBase::insert_imp_big((v3 + 328), result);
      }
    }
  }

  v11 = *(a2 + 44);
  if ((v11 & 0x800000) != 0)
  {
    v12 = *(a2 + 68);
    if (v12)
    {
      v13 = 0;
      v14 = *(a2 + 72);
      v15 = *(v3 + 488);
      while (1)
      {
        v16 = *(v14 + 32 * v13 + 24);
        if (*(v3 + 496) != v15)
        {
          goto LABEL_20;
        }

        v17 = *(v3 + 508);
        if (v17)
        {
          v18 = 0;
          while (*(v15 + v18) != v16)
          {
            v18 += 8;
            if (8 * v17 == v18)
            {
              goto LABEL_28;
            }
          }

          goto LABEL_22;
        }

LABEL_28:
        if (v17 < *(v3 + 504))
        {
          *(v3 + 508) = v17 + 1;
          *(v15 + 8 * v17) = v16;
        }

        else
        {
LABEL_20:
          result = llvm::SmallPtrSetImplBase::insert_imp_big((v3 + 488), v16);
        }

        v15 = *(v3 + 488);
LABEL_22:
        if (++v13 == v12)
        {
          v11 = *(a2 + 44);
          break;
        }
      }
    }
  }

  if ((v11 & 0x7FFFFF) != 0)
  {
    v19 = ((a2 + 16 * ((v11 >> 23) & 1) + ((v11 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 40);
    v20 = v19 + 24 * (v11 & 0x7FFFFF);
    do
    {
      for (j = *(v19 + 8); j != v19; j = *(j + 8))
      {
        v22 = j - 8;
        if (!j)
        {
          v22 = 0;
        }

        v23 = *(v22 + 48);
        v24 = *(v22 + 56);
        if (v23 != v24)
        {
          v25 = *(v3 + 328);
          do
          {
            v26 = *v23;
            if (*(v3 + 336) != v25)
            {
              goto LABEL_39;
            }

            v27 = *(v3 + 348);
            if (v27)
            {
              v28 = 0;
              while (*(v25 + v28) != v26)
              {
                v28 += 8;
                if (8 * v27 == v28)
                {
                  goto LABEL_47;
                }
              }

              goto LABEL_41;
            }

LABEL_47:
            if (v27 < *(v3 + 344))
            {
              *(v3 + 348) = v27 + 1;
              *(v25 + 8 * v27) = v26;
            }

            else
            {
LABEL_39:
              result = llvm::SmallPtrSetImplBase::insert_imp_big((v3 + 328), v26);
            }

            v25 = *(v3 + 328);
LABEL_41:
            ++v23;
          }

          while (v23 != v24);
        }
      }

      v19 += 24;
    }

    while (v19 != v20);
  }

  return result;
}

uint64_t mlir::arith::SelectOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v4 = (*(*a2 + 16))(a2);
  v5 = v4[4];
  if (v4[3] == v5)
  {
    llvm::raw_ostream::write(v4, " ", 1uLL);
  }

  else
  {
    *v5 = 32;
    ++v4[4];
  }

  v6 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v7 = *(v6 + 9);
    v8 = *(v6 + 17);
  }

  else
  {
    v7 = 0;
    v8 = 0;
  }

  v9 = (*(*a2 + 16))(a2);
  if (v8)
  {
    v10 = v9;
    OUTLINED_FUNCTION_104();
    (*(v11 + 160))(a2);
    v12 = v8 - 1;
    if (v12)
    {
      v13 = v7 + 56;
      do
      {
        v14 = v10[4];
        if (v10[3] - v14 > 1uLL)
        {
          *v14 = 8236;
          v10[4] += 2;
        }

        else
        {
          llvm::raw_ostream::write(v10, ", ", 2uLL);
        }

        v13 += 32;
        OUTLINED_FUNCTION_104();
        (*(v15 + 160))(a2);
        --v12;
      }

      while (v12);
    }
  }

  AttrDictionary = mlir::Operation::getAttrDictionary(*this);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_104();
  (*(v16 + 192))(a2, v17, v18, 0, 0);
  OUTLINED_FUNCTION_104();
  v20 = (*(v19 + 16))(a2);
  v21 = v20[4];
  if ((v20[3] - v21) > 2)
  {
    *(v21 + 2) = 32;
    *v21 = 14880;
    v20[4] += 3;
  }

  else
  {
    llvm::raw_ostream::write(v20, " : ", 3uLL);
  }

  if (llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type,llvm::CastInfo<mlir::ShapedType,mlir::Type,void>>::doCastIfPossible((*(*(*(*this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8)))
  {
    OUTLINED_FUNCTION_104();
    (*(v22 + 32))(a2);
    OUTLINED_FUNCTION_104();
    v24 = (*(v23 + 16))(a2);
    v25 = v24[4];
    if (v24[3] - v25 > 1uLL)
    {
      *v25 = 8236;
      v24[4] += 2;
    }

    else
    {
      llvm::raw_ostream::write(v24, ", ", 2uLL);
    }
  }

  OUTLINED_FUNCTION_104();
  return (*(v26 + 32))(a2, v27 & 0xFFFFFFFFFFFFFFF8);
}

uint64_t anonymous namespace::SubIRHSAddConstant::matchAndRewrite(_anonymous_namespace_::SubIRHSAddConstant *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  OUTLINED_FUNCTION_88();
  v30[4] = *MEMORY[0x1E69E9840];
  if ((*(v5 + 46) & 0x80) != 0)
  {
    OUTLINED_FUNCTION_86();
  }

  else
  {
    OUTLINED_FUNCTION_90();
  }

  v28 = v30;
  v30[0] = v4;
  v29 = 0x400000001;
  if (*(*(v4 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::SubIOp,void>::id)
  {
    v6 = v4;
  }

  else
  {
    v6 = 0;
  }

  v27[0] = *(*(v6 + 72) + 24);
  if (!mlir::Value::getDefiningOp(v27))
  {
    v23 = *(v3 + 16);
    if (!v23 || !mlir::RewriterBase::Listener::classof(v23))
    {
      goto LABEL_28;
    }

    v24 = *(v6 + 24);
LABEL_27:
    (*(*v23 + 88))(v23, v24, v25, v27);
    goto LABEL_28;
  }

  v7 = OUTLINED_FUNCTION_57();
  {
    goto LABEL_28;
  }

  v13 = v29;
  if (v29 >= HIDWORD(v29))
  {
    OUTLINED_FUNCTION_128(v29);
    v13 = v29;
  }

  OUTLINED_FUNCTION_118(v13);
  v27[0] = *(*(v6 + 72) + 56);
  if (!mlir::Value::getDefiningOp(v27))
  {
    v23 = *(v3 + 16);
    if (!v23 || !mlir::RewriterBase::Listener::classof(v23))
    {
      goto LABEL_28;
    }

    v24 = *(v6 + 24);
    goto LABEL_27;
  }

  v14 = OUTLINED_FUNCTION_57();
  {
    v17 = v29;
    if (v29 >= HIDWORD(v29))
    {
      OUTLINED_FUNCTION_128(v29);
      v17 = v29;
    }

    OUTLINED_FUNCTION_118(v17);
    if (!*(v4 + 47) || (v19.var0 = "overflowFlags", v18 = OUTLINED_FUNCTION_114(v18, v19), (v19.var0 & 1) == 0))
    {
      v19.var0 = "overflowFlags";
      v18 = OUTLINED_FUNCTION_108(v18, v19);
    }

    if (!v18 || *(*v18 + 136) != &mlir::detail::TypeIDResolver<mlir::arith::IntegerOverflowFlagsAttr,void>::id)
    {
      v20 = OUTLINED_FUNCTION_66();
      mlir::arith::IntegerOverflowFlagsAttr::get(v20, v21);
    }

    v22 = *(v28[1] + 24);
    v27[0] = *(*v28 + 24);
    v27[1] = v22;
    mlir::Builder::getFusedLoc((v3 + 8), v27, 2, 0);
  }

LABEL_28:
  if (v28 != v30)
  {
    free(v28);
  }

  return 0;
}

void mlir::arith::ConstantOp::verify()
{
  {
    v0 = llvm::getTypeName<mlir::ElementsAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_62(v2);
  }
}

void mlir::arith::ConstantOp::materialize()
{
  {
    v0 = llvm::getTypeName<mlir::TypedAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_52(v2);
  }
}

void mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::TypedAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.constant";
  *(a2 + 24) = 14;
}

void mlir::arith::ConstantOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_103(v2);
  }
}

void mlir::arith::AddUIExtendedOp::fold()
{
  {
    v0 = llvm::getTypeName<mlir::TypedAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_52(v2);
  }
}

void mlir::arith::ExtUIOp::fold()
{
  {
    v0 = llvm::getTypeName<mlir::ShapedType>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_48(v2);
  }
}

void getTypeIfLikeOrMemRef<mlir::IntegerType,mlir::IndexType,mlir::FloatType>()
{
  {
    v0 = llvm::getTypeName<mlir::ShapedType>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_48(v2);
  }
}

void mlir::arith::AddFOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::AddFOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_81(v2);
  }
}

void mlir::arith::__mlir_ods_local_type_constraint_ArithOps1()
{
  {
    v0 = llvm::getTypeName<mlir::ValueSemantics<mlir::TypeID mlir::TypeID::get<mlir::ValueSemantics>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_102(v2);
  }
}

void mlir::arith::AddIOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::AddIOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_80(v2);
  }
}

void mlir::arith::__mlir_ods_local_type_constraint_ArithOps2()
{
  {
    v0 = llvm::getTypeName<mlir::ValueSemantics<mlir::TypeID mlir::TypeID::get<mlir::ValueSemantics>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_102(v2);
  }
}

void mlir::arith::CmpFOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::CmpFOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_58(v2);
  }
}

void mlir::arith::CmpIOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::CmpIOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_79(v2);
  }
}

void mlir::arith::DivFOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::DivFOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_78(v2);
  }
}

void mlir::arith::ExtFOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::ExtFOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_117(v2);
  }
}

void mlir::arith::MaxNumFOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::MaxNumFOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_77(v2);
  }
}

void mlir::arith::MaximumFOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::MaximumFOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_76(v2);
  }
}

void mlir::arith::MinNumFOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::MinNumFOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_75(v2);
  }
}

void mlir::arith::MinimumFOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::MinimumFOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_74(v2);
  }
}

void mlir::arith::MulFOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::MulFOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_73(v2);
  }
}

void mlir::arith::MulIOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::MulIOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_72(v2);
  }
}

void mlir::arith::NegFOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::NegFOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_71(v2);
  }
}

void mlir::arith::RemFOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::RemFOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_70(v2);
  }
}

void mlir::arith::ShLIOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::ShLIOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_69(v2);
  }
}

void mlir::arith::SubFOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::SubFOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_68(v2);
  }
}

void mlir::arith::SubIOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::SubIOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_67(v2);
  }
}

void mlir::arith::TruncFOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::arith::detail::TruncFOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_91(v2);
  }
}

void mlir::detail::constant_op_binder<mlir::IntegerAttr>::match()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::InferIntRangeInterface,mlir::detail::InferIntRangeInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::InferIntRangeInterface>();
    mlir::detail::TypeIDResolver<mlir::InferIntRangeInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferIntRangeInterface>();
    mlir::detail::TypeIDResolver<mlir::InferIntRangeInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void llvm::isa<mlir::ElementsAttr,mlir::Attribute>()
{
  {
    v0 = llvm::getTypeName<mlir::ElementsAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_62(v2);
  }
}

void mlir::OpBuilder::create<mlir::arith::AddIOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.addi";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::arith::SubIOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.subi";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::arith::MulIOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.muli";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::arith::CmpIOp,mlir::arith::CmpIPredicateAttr,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.cmpi";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::arith::ExtSIOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.extsi";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::arith::XOrIOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.xori";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::arith::ExtUIOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.extui";
  *(a2 + 24) = 11;
}

uint64_t anonymous namespace::static_dag_matcher_10()
{
  OUTLINED_FUNCTION_127();
  if (v3 < 0)
  {
    v4 = *(v1 + 72);
  }

  else
  {
    v4 = 0;
  }

  *v2 = v4;
  v2[1] = 1;
  if (!*(v1 + 47) || (v9.var0 = "fastmath", v9.var1 = 8, result = mlir::Operation::getInherentAttr(v1, v9), (v6 & 1) == 0))
  {
    v10.var0 = "fastmath";
    v10.var1 = 8;
    result = mlir::DictionaryAttr::get((v1 + 56), v10);
  }

  if (!result || *(*result + 136) != &mlir::detail::TypeIDResolver<mlir::arith::FastMathFlagsAttr,void>::id)
  {
    v7 = OUTLINED_FUNCTION_66();
    result = mlir::arith::FastMathFlagsAttr::get(v7, v8);
  }

  *v0 = 1;
  return result;
}

void mlir::OpBuilder::create<mlir::arith::MulFOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.mulf";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::arith::DivFOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.divf";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::arith::ShRUIOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.shrui";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::arith::TruncIOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.trunci";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::arith::MulSIExtendedOp,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.mulsi_extended";
  *(a2 + 24) = 20;
}

void mlir::OpBuilder::create<mlir::arith::MulUIExtendedOp,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.mului_extended";
  *(a2 + 24) = 20;
}

void mlir::OpBuilder::create<mlir::arith::AndIOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.andi";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::arith::OrIOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.ori";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::arith::IndexCastOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.index_cast";
  *(a2 + 24) = 16;
}

void mlir::OpBuilder::create<mlir::arith::IndexCastUIOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.index_castui";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::arith::SelectOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.select";
  *(a2 + 24) = 12;
}

void mlir::arith::ArithDialect::initialize()
{
  {
    v0 = llvm::getTypeName<mlir::DialectInlinerInterface>();
    mlir::detail::TypeIDResolver<mlir::DialectInlinerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ConvertToLLVMPatternInterface>();
    mlir::detail::TypeIDResolver<mlir::ConvertToLLVMPatternInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::bufferization::BufferDeallocationOpInterface>();
    mlir::detail::TypeIDResolver<mlir::bufferization::BufferDeallocationOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::declarePromisedInterfaces<mlir::bufferization::BufferizableOpInterface,mlir::arith::ConstantOp,mlir::arith::IndexCastOp,mlir::arith::SelectOp>()
{
  {
    v0 = llvm::getTypeName<mlir::bufferization::BufferizableOpInterface>();
    mlir::detail::TypeIDResolver<mlir::bufferization::BufferizableOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::bufferization::BufferizableOpInterface>();
    mlir::detail::TypeIDResolver<mlir::bufferization::BufferizableOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::declarePromisedInterfaces<mlir::ValueBoundsOpInterface,mlir::arith::AddIOp,mlir::arith::ConstantOp,mlir::arith::SubIOp,mlir::arith::MulIOp>()
{
  {
    v0 = llvm::getTypeName<mlir::ValueBoundsOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_34_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ValueBoundsOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_34_0(v2);
  }
}

void mlir::OpBuilder::create<mlir::ub::PoisonOp,mlir::Type &,mlir::ub::PoisonAttr &>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "ub.poison";
  *(a2 + 24) = 9;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

void mlir::OpBuilder::create<mlir::ub::PoisonOp,mlir::Type &,mlir::ub::PoisonAttr &>()
{
  {
    v0 = llvm::getTypeName<mlir::ub::PoisonAttrInterface>();
    mlir::detail::TypeIDResolver<mlir::ub::PoisonAttrInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::arith::AddFOp>,mlir::OpTrait::OneResult<mlir::arith::AddFOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::arith::AddFOp>,mlir::OpTrait::ZeroSuccessors<mlir::arith::AddFOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::arith::AddFOp>,mlir::OpTrait::OpInvariants<mlir::arith::AddFOp>,mlir::BytecodeOpInterface::Trait<mlir::arith::AddFOp>,mlir::ConditionallySpeculatable::Trait<mlir::arith::AddFOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::arith::AddFOp>,mlir::MemoryEffectOpInterface::Trait<mlir::arith::AddFOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::arith::AddFOp>,mlir::OpTrait::IsCommutative<mlir::arith::AddFOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::arith::AddFOp>,mlir::VectorUnrollOpInterface::Trait<mlir::arith::AddFOp>,mlir::OpTrait::Elementwise<mlir::arith::AddFOp>,mlir::OpTrait::Scalarizable<mlir::arith::AddFOp>,mlir::OpTrait::Vectorizable<mlir::arith::AddFOp>,mlir::OpTrait::Tensorizable<mlir::arith::AddFOp>,mlir::InferTypeOpInterface::Trait<mlir::arith::AddFOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_16_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffectOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::arith::ArithFastMathInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_21_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::VectorUnrollOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_2(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_3(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::arith::ArithFastMathInterface::Trait,mlir::OpTrait::IsCommutative,mlir::OpTrait::SameOperandsAndResultType,mlir::VectorUnrollOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::OpTrait::Scalarizable,mlir::OpTrait::Vectorizable,mlir::OpTrait::Tensorizable,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_9_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_18_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_17_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_8_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_20_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_7_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_24_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_6_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_15_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_5_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::arith::ArithFastMathInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithFastMathInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_27_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsCommutative<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsCommutative>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_26_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_25_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::VectorUnrollOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::VectorUnrollOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_14_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_13_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::Scalarizable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Scalarizable>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_12_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::Vectorizable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Vectorizable>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_11_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::Tensorizable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Tensorizable>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_10_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_19_0(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::arith::AddIOp>,mlir::OpTrait::OneResult<mlir::arith::AddIOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::arith::AddIOp>,mlir::OpTrait::ZeroSuccessors<mlir::arith::AddIOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::arith::AddIOp>,mlir::OpTrait::OpInvariants<mlir::arith::AddIOp>,mlir::BytecodeOpInterface::Trait<mlir::arith::AddIOp>,mlir::OpTrait::IsCommutative<mlir::arith::AddIOp>,mlir::ConditionallySpeculatable::Trait<mlir::arith::AddIOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::arith::AddIOp>,mlir::MemoryEffectOpInterface::Trait<mlir::arith::AddIOp>,mlir::InferIntRangeInterface::Trait<mlir::arith::AddIOp>,mlir::arith::ArithIntegerOverflowFlagsInterface::Trait<mlir::arith::AddIOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::arith::AddIOp>,mlir::VectorUnrollOpInterface::Trait<mlir::arith::AddIOp>,mlir::OpTrait::Elementwise<mlir::arith::AddIOp>,mlir::OpTrait::Scalarizable<mlir::arith::AddIOp>,mlir::OpTrait::Vectorizable<mlir::arith::AddIOp>,mlir::OpTrait::Tensorizable<mlir::arith::AddIOp>,mlir::InferTypeOpInterface::Trait<mlir::arith::AddIOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::InferIntRangeInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_4(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::arith::ArithIntegerOverflowFlagsInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_33_0(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::IsCommutative,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferIntRangeInterface::Trait,mlir::arith::ArithIntegerOverflowFlagsInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::VectorUnrollOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::OpTrait::Scalarizable,mlir::OpTrait::Vectorizable,mlir::OpTrait::Tensorizable,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::InferIntRangeInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferIntRangeInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_23_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::arith::ArithIntegerOverflowFlagsInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithIntegerOverflowFlagsInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::arith::ArithIntegerOverflowFlagsInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithIntegerOverflowFlagsInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::arith::AddUIExtendedOp>,mlir::OpTrait::NResults<2u>::Impl<mlir::arith::AddUIExtendedOp>,mlir::OpTrait::ZeroSuccessors<mlir::arith::AddUIExtendedOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::arith::AddUIExtendedOp>,mlir::OpTrait::OpInvariants<mlir::arith::AddUIExtendedOp>,mlir::ConditionallySpeculatable::Trait<mlir::arith::AddUIExtendedOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::arith::AddUIExtendedOp>,mlir::MemoryEffectOpInterface::Trait<mlir::arith::AddUIExtendedOp>,mlir::OpTrait::IsCommutative<mlir::arith::AddUIExtendedOp>,mlir::VectorUnrollOpInterface::Trait<mlir::arith::AddUIExtendedOp>,mlir::OpTrait::Elementwise<mlir::arith::AddUIExtendedOp>,mlir::OpTrait::Scalarizable<mlir::arith::AddUIExtendedOp>,mlir::OpTrait::Vectorizable<mlir::arith::AddUIExtendedOp>,mlir::OpTrait::Tensorizable<mlir::arith::AddUIExtendedOp>,mlir::OpAsmOpInterface::Trait<mlir::arith::AddUIExtendedOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::OpAsmOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_29_0(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsCommutative,mlir::VectorUnrollOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::OpTrait::Scalarizable,mlir::OpTrait::Vectorizable,mlir::OpTrait::Tensorizable,mlir::OpAsmOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NResults<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NResults<2u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NResults<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NResults<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_32_0(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::OpTrait::IsIdempotent,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferIntRangeInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::VectorUnrollOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::OpTrait::Scalarizable,mlir::OpTrait::Vectorizable,mlir::OpTrait::Tensorizable,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsIdempotent<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIdempotent>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::IsIdempotent<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIdempotent>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::arith::BitcastOp>,mlir::OpTrait::OneResult<mlir::arith::BitcastOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::arith::BitcastOp>,mlir::OpTrait::ZeroSuccessors<mlir::arith::BitcastOp>,mlir::OpTrait::OneOperand<mlir::arith::BitcastOp>,mlir::OpTrait::OpInvariants<mlir::arith::BitcastOp>,mlir::ConditionallySpeculatable::Trait<mlir::arith::BitcastOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::arith::BitcastOp>,mlir::MemoryEffectOpInterface::Trait<mlir::arith::BitcastOp>,mlir::OpTrait::SameOperandsAndResultShape<mlir::arith::BitcastOp>,mlir::CastOpInterface::Trait<mlir::arith::BitcastOp>,mlir::VectorUnrollOpInterface::Trait<mlir::arith::BitcastOp>,mlir::OpTrait::Elementwise<mlir::arith::BitcastOp>,mlir::OpTrait::Scalarizable<mlir::arith::BitcastOp>,mlir::OpTrait::Vectorizable<mlir::arith::BitcastOp>,mlir::OpTrait::Tensorizable<mlir::arith::BitcastOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::CastOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_22(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::CastOpInterface::Trait,mlir::VectorUnrollOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::OpTrait::Scalarizable,mlir::OpTrait::Vectorizable,mlir::OpTrait::Tensorizable>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_28_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsAndResultShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultShape>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_31_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::CastOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CastOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_30_0(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::arith::ArithFastMathInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameTypeOperands,mlir::VectorUnrollOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::OpTrait::Scalarizable,mlir::OpTrait::Vectorizable,mlir::OpTrait::Tensorizable,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameTypeOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameTypeOperands>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SameTypeOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameTypeOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::InferIntRangeInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::arith::TruncFOp>,mlir::OpTrait::OneResult<mlir::arith::TruncFOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::arith::TruncFOp>,mlir::OpTrait::ZeroSuccessors<mlir::arith::TruncFOp>,mlir::OpTrait::OneOperand<mlir::arith::TruncFOp>,mlir::OpTrait::OpInvariants<mlir::arith::TruncFOp>,mlir::BytecodeOpInterface::Trait<mlir::arith::TruncFOp>,mlir::ConditionallySpeculatable::Trait<mlir::arith::TruncFOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::arith::TruncFOp>,mlir::MemoryEffectOpInterface::Trait<mlir::arith::TruncFOp>,mlir::OpTrait::SameOperandsAndResultShape<mlir::arith::TruncFOp>,mlir::arith::ArithRoundingModeInterface::Trait<mlir::arith::TruncFOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::arith::TruncFOp>,mlir::CastOpInterface::Trait<mlir::arith::TruncFOp>,mlir::VectorUnrollOpInterface::Trait<mlir::arith::TruncFOp>,mlir::OpTrait::Elementwise<mlir::arith::TruncFOp>,mlir::OpTrait::Scalarizable<mlir::arith::TruncFOp>,mlir::OpTrait::Vectorizable<mlir::arith::TruncFOp>,mlir::OpTrait::Tensorizable<mlir::arith::TruncFOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::arith::ArithRoundingModeInterface>();
    mlir::detail::TypeIDResolver<mlir::arith::ArithRoundingModeInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::arith::ArithRoundingModeInterface::Trait,mlir::arith::ArithFastMathInterface::Trait,mlir::CastOpInterface::Trait,mlir::VectorUnrollOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::OpTrait::Scalarizable,mlir::OpTrait::Vectorizable,mlir::OpTrait::Tensorizable>()
{
  {
    v0 = llvm::getTypeName<mlir::arith::ArithRoundingModeInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithRoundingModeInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::arith::ArithRoundingModeInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithRoundingModeInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::arith::SelectOp>,mlir::OpTrait::OneResult<mlir::arith::SelectOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::arith::SelectOp>,mlir::OpTrait::ZeroSuccessors<mlir::arith::SelectOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::arith::SelectOp>,mlir::OpTrait::OpInvariants<mlir::arith::SelectOp>,mlir::ConditionallySpeculatable::Trait<mlir::arith::SelectOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::arith::SelectOp>,mlir::MemoryEffectOpInterface::Trait<mlir::arith::SelectOp>,mlir::InferIntRangeInterface::Trait<mlir::arith::SelectOp>,mlir::SelectLikeOpInterface::Trait<mlir::arith::SelectOp>,mlir::OpTrait::Elementwise<mlir::arith::SelectOp>,mlir::OpTrait::Scalarizable<mlir::arith::SelectOp>,mlir::OpTrait::Vectorizable<mlir::arith::SelectOp>,mlir::OpTrait::Tensorizable<mlir::arith::SelectOp>,mlir::VectorUnrollOpInterface::Trait<mlir::arith::SelectOp>,mlir::InferTypeOpInterface::Trait<mlir::arith::SelectOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::SelectLikeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::SelectLikeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferIntRangeInterface::Trait,mlir::SelectLikeOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::OpTrait::Scalarizable,mlir::OpTrait::Vectorizable,mlir::OpTrait::Tensorizable,mlir::VectorUnrollOpInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::SelectLikeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SelectLikeOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::SelectLikeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SelectLikeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::DenseElementsAttr::operator mlir::ElementsAttr()
{
  {
    v0 = llvm::getTypeName<mlir::ElementsAttr>();
    mlir::detail::TypeIDResolver<mlir::ElementsAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::createOrFold<mlir::arith::DivUIOp,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.divui";
  *(a2 + 24) = 11;
}

void mlir::AsmParserState::addDefinition(uint64_t a1, uint64_t *a2)
{
  v3 = a2;
  llvm::SmallVectorTemplateBase<std::unique_ptr<mlir::AsmParserState::BlockDefinition>,false>::growAndEmplaceBack<std::unique_ptr<mlir::AsmParserState::BlockDefinition>>(a1, a2);
  v4 = *v3;
  *v3 = 0;
  if (v4)
  {
    v5 = v4[11];
    if (*(v4 + 24))
    {
      OUTLINED_FUNCTION_0_0();
      do
      {
        if (v3 + 2 != *v3)
        {
          free(*v3);
        }

        v3 -= 10;
        v2 += 80;
      }

      while (v2);
      v5 = v4[11];
    }

    if (v5 != (v4 + 13))
    {
      free(v5);
    }

    v6 = v4[3];
    if (v6 != (v4 + 5))
    {
      free(v6);
    }

    operator delete(v4);
  }
}

void mlir::AsmParserState::Impl::PartialOpDef::PartialOpDef()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SymbolTable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SymbolTable>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SymbolTable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SymbolTable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::Parser::parseDenseResourceElementsAttr()
{
  {
    v0 = llvm::getTypeName<mlir::DialectResourceBlobHandle<mlir::BuiltinDialect>>();
    mlir::detail::TypeIDResolver<mlir::DialectResourceBlobHandle<mlir::BuiltinDialect>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::TensorType::operator mlir::ShapedType()
{
  {
    v0 = llvm::getTypeName<mlir::ShapedType>();
    mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::getRegisteredInterface<mlir::OpAsmDialectInterface>()
{
  {
    v0 = llvm::getTypeName<mlir::OpAsmDialectInterface>();
    mlir::detail::TypeIDResolver<mlir::OpAsmDialectInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void anonymous namespace::OperationParser::parseOperation()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpAsmOpInterface>();
    mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void anonymous namespace::OperationParser::parseGenericOperationAfterOpName()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::BaseMemRefType::isValidElementType()
{
  {
    v0 = llvm::getTypeName<mlir::MemRefElementTypeInterface>();
    mlir::detail::TypeIDResolver<mlir::MemRefElementTypeInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void llvm::DefaultDoCastIfPossible<mlir::VerifiableTensorEncoding,mlir::Attribute,llvm::CastInfo<mlir::VerifiableTensorEncoding,mlir::Attribute,void>>::doCastIfPossible()
{
  {
    v0 = llvm::getTypeName<mlir::VerifiableTensorEncoding>();
    mlir::detail::TypeIDResolver<mlir::VerifiableTensorEncoding,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void llvm::function_ref<llvm::ParseResult ()(void)>::callback_fn<mlir::detail::Parser::parseMemRefType(void)::$_0>()
{
  {
    v0 = llvm::getTypeName<mlir::MemRefLayoutAttrInterface>();
    mlir::detail::TypeIDResolver<mlir::MemRefLayoutAttrInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::BytecodeReader::Impl::parseRegions()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::getRegisteredInterface<mlir::BytecodeDialectInterface>()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeDialectInterface>();
    mlir::detail::TypeIDResolver<mlir::BytecodeDialectInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void anonymous namespace::BytecodeWriter::write()
{
  {
    v0 = llvm::getTypeName<mlir::detail::StorageUserTrait::IsMutable<mlir::TypeID mlir::TypeID::get<mlir::TypeTrait::IsMutable>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::detail::StorageUserTrait::IsMutable<mlir::TypeID mlir::TypeID::get<mlir::TypeTrait::IsMutable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::detail::StorageUserTrait::IsMutable<mlir::TypeID mlir::TypeID::get<mlir::TypeTrait::IsMutable>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::detail::StorageUserTrait::IsMutable<mlir::TypeID mlir::TypeID::get<mlir::AttributeTrait::IsMutable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::BytecodeOpInterface,mlir::detail::BytecodeOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::RegionBranchOpInterface,mlir::detail::RegionBranchOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchOpInterface>();
    mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchOpInterface>();
    mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::CastOpInterface,mlir::detail::CastOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::CastOpInterface>();
    mlir::detail::TypeIDResolver<mlir::CastOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::CastOpInterface>();
    mlir::detail::TypeIDResolver<mlir::CastOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::tensor::DimOp,mlir::Value &,long long &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.dim";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::memref::DeallocOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "memref.dealloc";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::bufferization::CloneOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "bufferization.clone";
  *(a2 + 24) = 19;
}

void mlir::MemoryEffects::Read::Read()
{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffects::Read>();
    mlir::detail::TypeIDResolver<mlir::MemoryEffects::Read,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::SideEffects::DefaultResource::DefaultResource()
{
  {
    v0 = llvm::getTypeName<mlir::SideEffects::DefaultResource>();
    mlir::detail::TypeIDResolver<mlir::SideEffects::DefaultResource,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::MemoryEffects::Write::Write()
{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffects::Write>();
    mlir::detail::TypeIDResolver<mlir::MemoryEffects::Write,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::MemoryEffectOpInterface::hasEffect<mlir::MemoryEffects::Free>()
{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffects::Free>();
    mlir::detail::TypeIDResolver<mlir::MemoryEffects::Free,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::ViewLikeOpInterface,mlir::detail::ViewLikeOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::ViewLikeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ViewLikeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ViewLikeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ViewLikeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffectOpInterface>();
    mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffectOpInterface>();
    mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::tensor::ExtractOp,mlir::detail::TypedValue<mlir::TensorType>,mlir::OperandRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.extract";
  *(a2 + 24) = 14;
}

void mlir::BoolAttr::operator mlir::TypedAttr()
{
  {
    v0 = llvm::getTypeName<mlir::TypedAttr>();
    mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void llvm::find_if<llvm::SmallVector<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,4u> &,std::optional<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>> mlir::MemoryEffectOpInterface::getEffectOnValue<mlir::MemoryEffects::Allocate>(mlir::Value)::{lambda(llvm::SmallVector<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,4u> & &)#1}>()
{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffects::Allocate>();
    mlir::detail::TypeIDResolver<mlir::MemoryEffects::Allocate,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::FunctionOpInterface>();
    mlir::detail::TypeIDResolver<mlir::FunctionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::FunctionOpInterface>();
    mlir::detail::TypeIDResolver<mlir::FunctionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::BranchOpInterface,mlir::detail::BranchOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::BranchOpInterface>();
    mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::BranchOpInterface>();
    mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::MemoryEffectOpInterface::hasEffect<mlir::MemoryEffects::Allocate>()
{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffects::Allocate>();
    mlir::detail::TypeIDResolver<mlir::MemoryEffects::Allocate,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_13bufferization21BufferPlacementAllocs5buildES3_E3__0NS1_23MemoryEffectOpInterfaceEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESM_E4typeES3_OT1_EUlS3_E_EEvlS3__cold_2()
{
  {
    mlir::SideEffects::AutomaticAllocationScopeResource::AutomaticAllocationScopeResource(mlir::SideEffects::Resource::Base<mlir::SideEffects::AutomaticAllocationScopeResource,mlir::SideEffects::Resource>::get(void)::instance);
    __cxa_atexit(mlir::SideEffects::AutomaticAllocationScopeResource::~AutomaticAllocationScopeResource, mlir::SideEffects::Resource::Base<mlir::SideEffects::AutomaticAllocationScopeResource,mlir::SideEffects::Resource>::get(void)::instance, &dword_1DF9BF000);
  }
}

void mlir::SideEffects::AutomaticAllocationScopeResource::AutomaticAllocationScopeResource()
{
  {
    v0 = llvm::getTypeName<mlir::SideEffects::AutomaticAllocationScopeResource>();
    mlir::detail::TypeIDResolver<mlir::SideEffects::AutomaticAllocationScopeResource,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::RegionBranchTerminatorOpInterface,mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchTerminatorOpInterface>();
    mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchTerminatorOpInterface>();
    mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::complex::AbsOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_23_1(v2);
  }
}

void mlir::complex::AddOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::AddOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_22_0(v2);
  }
}

void mlir::complex::AngleOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_21_1(v2);
  }
}

void mlir::complex::Atan2Op::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_20_1(v2);
  }
}

void mlir::complex::ConjOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_19_1(v2);
  }
}

void mlir::complex::ConstantOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_35_0(v2);
  }
}

void mlir::complex::CosOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_18_1(v2);
  }
}

void mlir::complex::DivOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_17_1(v2);
  }
}

void mlir::complex::ExpOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_16_1(v2);
  }
}

void mlir::complex::Expm1Op::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_15_1(v2);
  }
}

void mlir::complex::ImOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_14_1(v2);
  }
}

void mlir::complex::Log1pOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_13_1(v2);
  }
}

void mlir::complex::LogOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_12_1(v2);
  }
}

void mlir::complex::MulOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_11_1(v2);
  }
}

void mlir::complex::NegOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_10_1(v2);
  }
}

void mlir::complex::PowOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_32_1(v2);
  }
}

void mlir::complex::ReOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_31_1(v2);
  }
}

void mlir::complex::RsqrtOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_30_1(v2);
  }
}

void mlir::complex::SignOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_29_1(v2);
  }
}

void mlir::complex::SinOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_28_1(v2);
  }
}

void mlir::complex::SqrtOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_27_1(v2);
  }
}

void mlir::complex::SubOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_26_1(v2);
  }
}

void mlir::complex::TanOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_25_1(v2);
  }
}

void mlir::complex::TanhOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_24_1(v2);
  }
}

void mlir::OpBuilder::create<mlir::complex::BitcastOp,mlir::Type,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "complex.bitcast";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::arith::BitcastOp,mlir::Type,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.bitcast";
  *(a2 + 24) = 13;
}

void mlir::OpBuilder::create<mlir::arith::NegFOp,mlir::Type &,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "arith.negf";
  *(a2 + 24) = 10;
}

void mlir::complex::ComplexDialect::initialize()
{
  {
    v0 = llvm::getTypeName<mlir::ConvertToLLVMPatternInterface>();
    mlir::detail::TypeIDResolver<mlir::ConvertToLLVMPatternInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::DialectInlinerInterface>();
    mlir::detail::TypeIDResolver<mlir::DialectInlinerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::complex::ConstantOp,mlir::Type &,mlir::ArrayAttr>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "complex.constant";
  *(a2 + 24) = 16;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::complex::AbsOp>,mlir::OpTrait::OneResult<mlir::complex::AbsOp>,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl<mlir::complex::AbsOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AbsOp>,mlir::OpTrait::OneOperand<mlir::complex::AbsOp>,mlir::OpTrait::OpInvariants<mlir::complex::AbsOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AbsOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AbsOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AbsOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AbsOp>,mlir::OpTrait::Elementwise<mlir::complex::AbsOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AbsOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AbsOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_3_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffectOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_0_1(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::arith::ArithFastMathInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_4_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_2_0(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_6_1(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_5_1(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_11_2(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_10_2(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_15_2(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_9_1(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_8_1(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_7_1(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_14_2(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::arith::ArithFastMathInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithFastMathInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithFastMathInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_13_2(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_12_2(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::complex::ConstantOp>,mlir::OpTrait::OneResult<mlir::complex::ConstantOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConstantOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConstantOp>,mlir::OpTrait::ZeroOperands<mlir::complex::ConstantOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConstantOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConstantOp>,mlir::OpTrait::ConstantLike<mlir::complex::ConstantOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConstantOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConstantOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConstantOp>,mlir::OpAsmOpInterface::Trait<mlir::complex::ConstantOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::OpAsmOpInterface>();
    mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::AbstractAttribute::get<mlir::complex::NumberAttr>()
{
  {
    v0 = llvm::getTypeName<mlir::TypedAttr>();
    mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::StorageUserBase<mlir::complex::NumberAttr,mlir::Attribute,mlir::complex::detail::NumberAttrStorage,mlir::detail::AttributeUniquer,mlir::TypedAttr::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke()
{
  {
    v0 = llvm::getTypeName<mlir::TypedAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::TypedAttr::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::TypedAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::TypedAttr::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t simplifyPassThroughSwitch(uint64_t a1, uint64_t **a2)
{
  v61 = *MEMORY[0x1E69E9840];
  v44 = v58;
  v56 = v58;
  v57 = 0x600000000;
  v43 = v55;
  v53 = v55;
  v54 = 0x300000000;
  v50 = v52;
  v51 = 0x100000000;
  v4 = a1 + 64;
  v5 = *(a1 + 64 + 16 * ((*(a1 + 44) >> 23) & 1) + 8) != 0;
  v46 = *(a1 + 64 + 16 * ((*(a1 + 44) >> 23) & 1) + 8);
  LOBYTE(v47) = v5;
  v6 = mlir::DenseElementsAttr::getNumElements(&v46) + 1;
  if (v6 > HIDWORD(v51))
  {
    llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::OpFoldResult,6u>,false>::grow(&v50, v6);
  }

  v7 = mlir::SuccessorRange::SuccessorRange(&v59, a1);
  v8 = v59;
  mlir::SuccessorRange::SuccessorRange(v7, a1);
  NumElements = mlir::DenseElementsAttr::getNumElements(&v46);
  if (NumElements < 1)
  {
    v11 = 0;
  }

  else
  {
    v10 = NumElements;
    v11 = 0;
    v12 = 0;
    v13 = (v8 + 56);
    do
    {
      v45 = *v13;
      v14 = *(a1 + 44);
      if ((v14 & 0x800000) != 0)
      {
        v15 = *(a1 + 72);
      }

      else
      {
        v15 = 0;
      }

      v16 = v4 + 16 * ((v14 >> 23) & 1);
      v17 = (*(v16 + 20) + *(v16 + 16));
      v18 = (v15 + 32 * v17);
      v19 = (*(v16 + 24) + v17) - v17;
      v48 = v18;
      v49 = v19;
      mlir::OperandRange::split(&v48, *v16, &v59);
      v20 = mlir::OperandRangeRange::dereference(&v59, v60 + v12);
      mlir::ValueRange::ValueRange(&v59, v20, v21);
      if (v51 >= HIDWORD(v51))
      {
        llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,6u>,false>::growAndEmplaceBack<>(&v50);
      }

      else
      {
        OUTLINED_FUNCTION_14_3(v51, v41, *(&v41 + 1), v42, v43, v44, v45, v46, v47, v48, v49, v50);
      }

      OUTLINED_FUNCTION_34_1();
      v23 = collapseBranch(&v45, &v59, v22);
      v24 = v45;
      v25 = v57;
      if (v57 >= HIDWORD(v57))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v56, v44, v57 + 1, 8);
        v25 = v57;
      }

      v56[v25] = v24;
      LODWORD(v57) = v57 + 1;
      v26 = v59;
      v27 = v54;
      if (v54 >= HIDWORD(v54))
      {
        v41 = v59;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v53, v43, v54 + 1, 16);
        v26 = v41;
        v27 = v54;
      }

      v11 |= v23;
      *(v53 + v27) = v26;
      LODWORD(v54) = v54 + 1;
      ++v12;
      v13 += 4;
    }

    while (v10 != v12);
  }

  OUTLINED_FUNCTION_26_2();
  v48 = *(((v28 + 7) & 0xFFFFFFFFFFFFFFF8) + 24);
  v30 = *(v29 + 16);
  v31 = *(v29 + 20);
  if ((v32 & 0x800000) != 0)
  {
    v33 = *(a1 + 72);
  }

  else
  {
    v33 = 0;
  }

  mlir::ValueRange::ValueRange(&v59, v33 + 32 * v30, (v31 + v30) - v30);
  if (v51 >= HIDWORD(v51))
  {
    llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,6u>,false>::growAndEmplaceBack<>(&v50);
  }

  else
  {
    OUTLINED_FUNCTION_14_3(v51, v41, *(&v41 + 1), v42, v43, v44, v45, v46, v47, v48, v49, v50);
  }

  OUTLINED_FUNCTION_34_1();
  if ((collapseBranch(&v48, &v59, v34) | v11))
  {
    v45 = *(*(a1 + 72) + 24);
    v35 = mlir::OpBuilder::create<mlir::cf::SwitchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *&,mlir::ValueRange &,mlir::DenseIntElementsAttr &,llvm::SmallVector<mlir::Block *,6u> &,llvm::SmallVector<mlir::ValueRange,3u> &>(a2 + 1, *(a1 + 24), &v45, &v48, &v59, &v46, &v56, &v53);
    ((*a2)[1])(a2, a1, v35);
    v36 = 1;
  }

  else
  {
    v36 = 0;
  }

  v37 = v50;
  if (v51)
  {
    v38 = (v50 + 64 * v51 - 64);
    v39 = -64 * v51;
    do
    {
      if (v38 + 2 != *v38)
      {
        free(*v38);
      }

      v38 -= 8;
      v39 += 64;
    }

    while (v39);
    v37 = v50;
  }

  if (v37 != v52)
  {
    free(v37);
  }

  if (v53 != v43)
  {
    free(v53);
  }

  if (v56 != v44)
  {
    free(v56);
  }

  return v36;
}

void mlir::cf::BranchOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v51 = *MEMORY[0x1E69E9840];
  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v4, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v4, v5);
  }

  OUTLINED_FUNCTION_104();
  (*(v7 + 176))(a2);
  if ((*(*this + 46) & 0x80) != 0 && *(*this + 17))
  {
    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v10)
    {
      llvm::raw_ostream::write(v8, "(", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v8, v9);
    }

    v11 = *this;
    if ((*(*this + 46) & 0x80) != 0)
    {
      v12 = *(v11 + 17);
      v13 = *(v11 + 9);
    }

    else
    {
      v13 = 0;
      v12 = 0;
    }

    v14 = (*(*a2 + 16))(a2);
    if (v12)
    {
      v15 = v14;
      OUTLINED_FUNCTION_104();
      (*(v16 + 160))(a2);
      v17 = v12 - 1;
      if (v17)
      {
        v18 = v13 + 56;
        do
        {
          v19 = v15[4];
          if (v15[3] - v19 > 1uLL)
          {
            *v19 = 8236;
            v15[4] += 2;
          }

          else
          {
            llvm::raw_ostream::write(v15, ", ", 2uLL);
          }

          v18 += 32;
          OUTLINED_FUNCTION_104();
          (*(v20 + 160))(a2);
          --v17;
        }

        while (v17);
      }
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v6)
    {
      llvm::raw_ostream::write(v21, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v21, v22);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v10)
    {
      llvm::raw_ostream::write(v23, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v23, v24);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v6)
    {
      llvm::raw_ostream::write(v25, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v25, v26);
    }

    v27 = *this;
    if ((*(*this + 46) & 0x80) != 0)
    {
      v28 = *(v27 + 17);
      v29 = *(v27 + 9);
    }

    else
    {
      v29 = 0;
      v28 = 0;
    }

    v46[0] = v29;
    v46[1] = v28;
    mlir::OperandRange::getTypes(v46, &v47);
    v30 = v48;
    v31 = v50;
    if (v48 != v50)
    {
      v32 = v47 + 32 * v48;
      OUTLINED_FUNCTION_104();
      (*(v33 + 32))(a2, v34 & 0xFFFFFFFFFFFFFFF8);
      if (v30 + 1 != v31)
      {
        v35 = ~v30 + v31;
        v36 = v32 + 56;
        do
        {
          (*(*a2 + 16))(a2);
          OUTLINED_FUNCTION_25_2();
          if (!v10 & v6)
          {
            *v38 = 8236;
            OUTLINED_FUNCTION_24_2(v37);
          }

          else
          {
            llvm::raw_ostream::write(v37, ", ", 2uLL);
          }

          v36 += 32;
          OUTLINED_FUNCTION_104();
          (*(v39 + 32))(a2, v40 & 0xFFFFFFFFFFFFFFF8);
          --v35;
        }

        while (v35);
      }
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v10)
    {
      llvm::raw_ostream::write(v41, ")", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v41, v42);
    }
  }

  v47 = &v49;
  v48 = 0x200000000;
  v46[0] = mlir::Operation::getAttrDictionary(*this);
  mlir::ArrayAttr::getValue(v46);
  OUTLINED_FUNCTION_104();
  (*(v43 + 192))(a2, v44, v45);
  if (v47 != &v49)
  {
    free(v47);
  }
}

void mlir::cf::SwitchOp::print(Operation **this, mlir::OpAsmPrinter *a2)
{
  v86 = *MEMORY[0x1E69E9840];
  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v4, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v4, v5);
  }

  OUTLINED_FUNCTION_104();
  (*(v7 + 160))(a2);
  OUTLINED_FUNCTION_104();
  (*(v8 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v9, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v9, v10);
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v11, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v11, v12);
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v14, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v14, v15);
  }

  OUTLINED_FUNCTION_104();
  (*(v16 + 32))(a2, v17 & 0xFFFFFFFFFFFFFFF8);
  OUTLINED_FUNCTION_104();
  (*(v18 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v19, ",", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v19, v20);
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v21, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v21, v22);
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v23, "[", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v23, v24);
  }

  (*(*a2 + 128))(a2);
  v25 = *(((*this + 8 * *(*this + 47) + 87) & 0xFFFFFFFFFFFFFFF8) + 24);
  v26 = *(*this + 24);
  v27 = *(*this + 9) + 32 * v26;
  v28 = (*(*this + 25) + v26) - v26;
  v64[0] = v27;
  v64[1] = v28;
  mlir::OperandRange::getTypes(v64, &v69);
  mlir::ValueRange::ValueRange(v79, v69 + 32 * v70, v72 - v70);
  mlir::TypeRange::TypeRange(&v78, *v79, *&v79[8]);
  v29 = *(*this + 2 * ((*(*this + 11) >> 23) & 1) + 9);
  mlir::SuccessorRange::SuccessorRange(&v69, *this);
  v30 = v69;
  mlir::SuccessorRange::SuccessorRange(&v69, *this);
  OUTLINED_FUNCTION_21_2();
  OUTLINED_FUNCTION_20_2();
  mlir::OperandRange::split(&v69, v31, v63);
  OUTLINED_FUNCTION_21_2();
  OUTLINED_FUNCTION_20_2();
  mlir::OperandRange::split(&v69, v32, v62);
  mlir::OperandRangeRange::getTypes(v62, &v69);
  v68 = v29;
  OUTLINED_FUNCTION_104();
  v34 = (*(v33 + 16))(a2);
  v35 = v34[4];
  if ((v34[3] - v35) > 0xA)
  {
    *(v35 + 7) = 540701804;
    *v35 = *"  default: ";
    v34[4] += 11;
  }

  else
  {
    llvm::raw_ostream::write(v34, "  default: ", 0xBuLL);
  }

  mlir::ValueRange::ValueRange(v79, v27, v28);
  OUTLINED_FUNCTION_104();
  (*(v36 + 184))(a2, v25);
  if (v29)
  {
    mlir::DenseElementsAttr::getValues<llvm::APInt>(&v68, v79);
    v81 = *v79;
    v82 = *&v79[16];
    v83 = *&v79[32];
    *&v79[24] = *&v79[16];
    *&v79[8] = *v79;
    *v79 = 0;
    v37 = v80;
    if (*&v79[24] != v80)
    {
      v38 = 0;
      while (1)
      {
        mlir::DenseElementsAttr::IntElementIterator::operator*(&v79[8], &v84);
        v67 = v85;
        v65 = v38;
        __p = v84;
        OUTLINED_FUNCTION_104();
        (*(v39 + 16))(a2);
        OUTLINED_FUNCTION_13_3();
        if (v6)
        {
          llvm::raw_ostream::write(v40, 44);
        }

        else
        {
          *(v40 + 4) = v41 + 1;
          *v41 = 44;
        }

        (*(*a2 + 128))(a2);
        OUTLINED_FUNCTION_104();
        (*(v42 + 16))(a2);
        OUTLINED_FUNCTION_25_2();
        if (!v13 & v6)
        {
          *v44 = 8224;
          OUTLINED_FUNCTION_24_2(v43);
        }

        else
        {
          llvm::raw_ostream::write(v43, "  ", 2uLL);
        }

        v45 = v67;
        p_p = &__p;
        if (v67 < 0x41)
        {
          goto LABEL_38;
        }

        if (v45 - llvm::APInt::countLeadingZerosSlowCase(&__p) <= 0x40)
        {
          break;
        }

        v47 = -1;
LABEL_39:
        v48 = (*(*a2 + 16))(a2);
        llvm::raw_ostream::operator<<(v48, v47);
        OUTLINED_FUNCTION_104();
        (*(v49 + 16))(a2);
        OUTLINED_FUNCTION_25_2();
        if (!v13 & v6)
        {
          *v51 = 8250;
          OUTLINED_FUNCTION_24_2(v50);
        }

        else
        {
          llvm::raw_ostream::write(v50, ": ", 2uLL);
        }

        v52 = v30[4 * v65 + 7];
        v53 = mlir::OperandRangeRange::dereference(v63, v63[2] + v65);
        mlir::ValueRange::ValueRange(&v84, v53, v54);
        OUTLINED_FUNCTION_104();
        (*(v55 + 184))(a2, v52);
        if (v67 >= 0x41 && __p)
        {
          operator delete[](__p);
        }

        v38 = ++*v79;
        if (++*&v79[24] == v37)
        {
          goto LABEL_46;
        }
      }

      p_p = __p;
LABEL_38:
      v47 = *p_p;
      goto LABEL_39;
    }

LABEL_46:
    (*(*a2 + 128))(a2);
  }

  if (v77 == 1)
  {
    if (v76 == &v75)
    {
      (*(*v76 + 32))(v76);
    }

    else if (v76)
    {
      (*(*v76 + 40))();
    }
  }

  if (v74 == 1)
  {
    if (v73 == &v70)
    {
      (*(*v73 + 32))(v73);
    }

    else if (v73)
    {
      (*(*v73 + 40))();
    }
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v56, "]", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v56, v57);
  }

  v69 = &v71;
  v71 = "operandSegmentSizes";
  v72 = 19;
  v73 = "case_operand_segments";
  v74 = 21;
  v70 = 0x200000002;
  llvm::SmallVectorBase<unsigned int>::grow_pod(&v69, &v71, 3uLL, 16);
  v58 = v69 + 16 * v70;
  *v58 = "case_values";
  v58[1] = 11;
  LODWORD(v70) = v70 + 1;
  *v79 = mlir::Operation::getAttrDictionary(*this);
  mlir::ArrayAttr::getValue(v79);
  OUTLINED_FUNCTION_104();
  (*(v59 + 192))(a2, v60, v61);
  if (v69 != &v71)
  {
    free(v69);
  }
}

void mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getSuccessorOperands(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v6[3] = *MEMORY[0x1E69E9840];
  if ((*(a1 + 46) & 0x80) != 0)
  {
    v3 = *(a1 + 68);
  }

  else
  {
    v3 = 0;
  }

  mlir::MutableOperandRange::MutableOperandRange(&v4, a1, 0, v3, 0, 0);
  mlir::SuccessorOperands::SuccessorOperands(a2, &v4);
  if (v5 != v6)
  {
    free(v5);
  }
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::cf::BranchOp::print(&v7, a3);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::cf::SwitchOp::print(&v7, a3);
}

uint64_t anonymous namespace::SimplifyPassThroughCondBranch::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v32[2] = *MEMORY[0x1E69E9840];
  v5 = a2 + 64;
  OUTLINED_FUNCTION_26_2();
  v7 = (v6 + 7) & 0xFFFFFFFFFFFFFFF8;
  v8 = *(v7 + 24);
  v25 = *(v7 + 56);
  v26 = v8;
  v10 = *v9;
  v11 = v9[1];
  if ((v12 & 0x800000) != 0)
  {
    v13 = *(a2 + 72);
  }

  else
  {
    v13 = 0;
  }

  mlir::ValueRange::ValueRange(v32, v13 + 32 * v10, v11 + v10 - v10);
  v14 = *(a2 + 44);
  v15 = (v5 + 16 * ((v14 >> 23) & 1));
  v16 = *v15;
  v17 = v15[1];
  v18 = v15[2];
  if ((v14 & 0x800000) != 0)
  {
    v19 = *(a2 + 72);
  }

  else
  {
    v19 = 0;
  }

  mlir::ValueRange::ValueRange(v31, v19 + 32 * (v17 + v16), (v18 + v17 + v16) - (v17 + v16));
  v29[0] = v30;
  v29[1] = 0x400000000;
  v27[0] = v28;
  v27[1] = 0x400000000;
  v20 = collapseBranch(&v26, v32, v29);
  if ((collapseBranch(&v25, v31, v27) | v20))
  {
    v24 = *(*(a2 + 72) + 24);
    v21 = mlir::OpBuilder::create<mlir::cf::CondBranchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *&,mlir::ValueRange &,mlir::Block *&,mlir::ValueRange &>((a3 + 8), *(a2 + 24), &v24, &v26, v32, &v25, v31);
    (*(*a3 + 8))(a3, a2, v21);
    v22 = 1;
  }

  else
  {
    v22 = 0;
  }

  if (v27[0] != v28)
  {
    free(v27[0]);
  }

  if (v29[0] != v30)
  {
    free(v29[0]);
  }

  return v22;
}

void llvm::SmallVectorImpl<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>>::emplace_back<mlir::MemoryEffects::Write *>()
{
  {
    v0 = mlir::SideEffects::DefaultResource::DefaultResource(mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance);
    OUTLINED_FUNCTION_8_2(v0, v1, &dword_1DF9BF000);
  }
}

void mlir::cf::SwitchOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_10_3(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ShapedType>();
    mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t simplifySwitchWithOnlyDefault()
{
  OUTLINED_FUNCTION_9_2();
  OUTLINED_FUNCTION_26_2();
  v10 = *(((v2 + 71) & 0xFFFFFFFFFFFFFFF8) + 24);
  v4 = *(v3 + 80);
  v5 = *(v3 + 84);
  if ((v6 & 0x800000) != 0)
  {
    v7 = *(v0 + 72);
  }

  else
  {
    v7 = 0;
  }

  v11[0] = v7 + 32 * v4;
  v11[1] = (v5 + v4) - v4;
  v8 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((v1 + 8), *(v0 + 24), &v10, v11);
  return (*(*v1 + 8))(v1, v0, v8);
}

void mlir::cf::AssertOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_16_2(v2);
  }
}

void mlir::cf::CondBranchOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_27_2(v2);
  }
}

void mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,mlir::ValueRange &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "cf.br";
  *(a2 + 24) = 5;
}

void mlir::OpBuilder::create<mlir::cf::SwitchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *,mlir::OperandRange,llvm::SmallVector<llvm::APInt,3u> &,llvm::SmallVector<mlir::Block *,6u> &,llvm::SmallVector<mlir::ValueRange,3u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "cf.switch";
  *(a2 + 24) = 9;
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::AssertOp>::getEffects()
{
  {
    mlir::MemoryEffects::Write::Write(&mlir::SideEffects::Effect::get<mlir::MemoryEffects::Write>(void)::instance);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_31_2(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::cf::BranchOp>,mlir::OpTrait::ZeroResults<mlir::cf::BranchOp>,mlir::OpTrait::OneSuccessor<mlir::cf::BranchOp>,mlir::OpTrait::VariadicOperands<mlir::cf::BranchOp>,mlir::OpTrait::OpInvariants<mlir::cf::BranchOp>,mlir::BranchOpInterface::Trait<mlir::cf::BranchOp>,mlir::ConditionallySpeculatable::Trait<mlir::cf::BranchOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::cf::BranchOp>,mlir::MemoryEffectOpInterface::Trait<mlir::cf::BranchOp>,mlir::OpTrait::IsTerminator<mlir::cf::BranchOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable>();
    mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneSuccessor<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneSuccessor>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneSuccessor<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneSuccessor>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::BranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BranchOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::BranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NSuccessors<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NSuccessors<2u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NSuccessors<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NSuccessors<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::cf::CondBranchOp>,mlir::OpTrait::ZeroResults<mlir::cf::CondBranchOp>,mlir::OpTrait::NSuccessors<2u>::Impl<mlir::cf::CondBranchOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::cf::CondBranchOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::cf::CondBranchOp>,mlir::OpTrait::OpInvariants<mlir::cf::CondBranchOp>,mlir::BytecodeOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::BranchOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::ConditionallySpeculatable::Trait<mlir::cf::CondBranchOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::cf::CondBranchOp>,mlir::MemoryEffectOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::OpTrait::IsTerminator<mlir::cf::CondBranchOp>>(uint64_t a1, _BYTE *a2)
{
  v4 = *(a1 + 44);
  v5 = *(a1 + 16 * ((v4 >> 23) & 1) + 64);
  if ((v4 & 0x800000) != 0)
  {
    v6 = *(a1 + 72);
    if (v5)
    {
      goto LABEL_3;
    }
  }

  else
  {
    v6 = 0;
    if (v5)
    {
LABEL_3:
      v7 = 0;
      v8 = v6 + 24;
      while (mlir::complex::__mlir_ods_local_type_constraint_ComplexOps5(a1, *(*v8 + 8) & 0xFFFFFFFFFFFFFFF8, "operand", 7, v7))
      {
        ++v7;
        v8 += 32;
        if (v5 == v7)
        {
          goto LABEL_6;
        }
      }

      goto LABEL_8;
    }
  }

LABEL_6:
  if ((mlir::op_definition_impl::verifyTrait<mlir::BranchOpInterface::Trait<mlir::cf::CondBranchOp>>(a1) & 1) == 0)
  {
LABEL_8:
    result = 0;
    goto LABEL_9;
  }

  result = mlir::OpTrait::impl::verifyIsTerminator(a1, v9);
LABEL_9:
  *a2 = result;
  return result;
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNSuccessors<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNSuccessors<1u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNSuccessors<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNSuccessors<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::cf::CondBranchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *&,mlir::ValueRange &,mlir::Block *&,mlir::ValueRange &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "cf.cond_br";
  *(a2 + 24) = 10;
}

uint64_t mlir::OpTrait::impl::verifyCompatibleOperandBroadcast(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  v144 = *MEMORY[0x1E69E9840];
  if ((*(this + 46) & 0x80) != 0)
  {
    v3 = *(this + 9);
    v4 = *(this + 17);
  }

  else
  {
    v3 = 0;
    v4 = 0;
  }

  __src = v3;
  v127 = v4;
  mlir::OperandRange::getTypes(&__src, &v132);
  if (v133 == v135)
  {
    v5 = 0;
    v6 = 0;
  }

  else
  {
    v7 = v135 + ~v133;
    v8 = v132 + 32 * v133;
    v9 = (v8 + 24);
    do
    {
      v10 = v7;
      v11 = *v9;
      v9 += 4;
      v12 = *(*(*(v11 + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
      v13 = v12 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id || v12 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
      v5 = v13;
      if (v13)
      {
        break;
      }

      v7 = v10 - 1;
    }

    while (v10);
    v14 = v135 + ~v133;
    v15 = (v8 + 24);
    do
    {
      v16 = *v15;
      v15 += 4;
      v17 = *(*(*(v16 + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
      v6 = v17 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id;
    }

    while (v17 != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id && v14-- != 0);
  }

  v19 = *(this + 9);
  v20 = this - 16;
  v107 = this - 16;
  if (!v19)
  {
    v20 = 0;
  }

  __src = v20;
  v127 = v19;
  mlir::OperandRange::getTypes(&__src, &v132);
  v21 = v133;
  if (v133 == v135)
  {
    v22 = 0;
  }

  else
  {
    v23 = v132;
    v24 = v135 - 1;
    do
    {
      mlir::detail::OpResultImpl::getNextResultAtOffset(v23, v21);
      OUTLINED_FUNCTION_0_2();
      v26 = v25 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id || v25 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
      v22 = v26;
      if (v26)
      {
        break;
      }

      v13 = v24 == v21++;
    }

    while (!v13);
    v27 = v133;
    if (v133 != v135)
    {
      v29 = v132;
      v30 = v135 - 1;
      do
      {
        mlir::detail::OpResultImpl::getNextResultAtOffset(v29, v27);
        OUTLINED_FUNCTION_0_2();
        v13 = v31 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id;
        v28 = v31 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id;
      }

      while (!v13 && v30 != v27++);
      goto LABEL_42;
    }
  }

  v28 = 0;
LABEL_42:
  if ((v5 | v22) == 1 && (v6 || v28))
  {
    __src = "cannot broadcast vector with tensor";
    LOWORD(v130) = 259;
    mlir::Operation::emitError(this, &__src, &v132);
    v33 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v132);
    if (v132)
    {
      mlir::InFlightDiagnostic::report(&v132);
    }

    if (v143[0] == 1)
    {
      if (v142 != v143)
      {
        free(v142);
      }

      v34 = __p;
      if (__p)
      {
        v35 = v141;
        v36 = __p;
        if (v141 != __p)
        {
          do
          {
            v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v35 - 1);
          }

          while (v35 != v34);
          v36 = __p;
        }

        v141 = v34;
        operator delete(v36);
      }

      v37 = v138;
      if (v138)
      {
        v38 = v139;
        v39 = v138;
        if (v139 != v138)
        {
          do
          {
            v41 = *--v38;
            v40 = v41;
            *v38 = 0;
            if (v41)
            {
              operator delete[](v40);
            }
          }

          while (v38 != v37);
          v39 = v138;
        }

        v139 = v37;
        operator delete(v39);
      }

      v42 = v135;
      v43 = v137;
      goto LABEL_123;
    }

    return v33;
  }

  if ((*(this + 46) & 0x80) != 0)
  {
    v44 = *(this + 9);
    v45 = *(this + 17);
  }

  else
  {
    v44 = 0;
    v45 = 0;
  }

  __src = v44;
  v127 = v45;
  mlir::OperandRange::getTypes(&__src, &v132);
  v47 = v132;
  v46 = v133;
  v48 = v135;
  if (v133 != v135)
  {
    while (1)
    {
      OUTLINED_FUNCTION_2_1();
      if (v13)
      {
        break;
      }

      if (v48 == ++v46)
      {
        return 1;
      }
    }
  }

  if (v46 == v48)
  {
    return 1;
  }

  v33 = &v128;
  __src = &v128;
  v127 = 0x400000000;
  ArgAttrsAttr = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type,llvm::CastInfo<mlir::ShapedType,mlir::Type,void>>::doCastIfPossible((*(*(v47 + 4 * v46 + 3) + 8) & 0xFFFFFFFFFFFFFFF8));
  v132 = ArgAttrsAttr;
  v133 = v50;
  v104 = &v128;
  if (ArgAttrsAttr)
  {
    ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v132);
  }

  else
  {
    v51 = 0;
  }

  mlir::OpTrait::util::getBroadcastedShape(ArgAttrsAttr, v51, 0, 0, &__src);
  v105 = v137;
  v106 = v143;
  v108 = v47 + 56;
  while (v46 != v48)
  {
    v52 = v48;
    if ((v46 + 1) != v48)
    {
      v52 = (v46 + 1);
      while (1)
      {
        OUTLINED_FUNCTION_2_1();
        if (v13)
        {
          break;
        }

        if (v48 == ++v52)
        {
          v52 = v48;
          break;
        }
      }
    }

    v53 = *(*(v47 + 4 * v46 + 3) + 8);
    __dst = &v122;
    v121 = 0x400000000;
    v54 = v127;
    if (!v127)
    {
      v54 = 0;
      v57 = &v122;
      goto LABEL_86;
    }

    v55 = &v122;
    v56 = v127;
    if (v127 < 5uLL)
    {
      goto LABEL_83;
    }

    llvm::SmallVectorBase<unsigned int>::grow_pod(&__dst, &v122, v127, 8);
    v56 = v127;
    if (v127)
    {
      v55 = __dst;
LABEL_83:
      memcpy(v55, __src, 8 * v56);
    }

    LODWORD(v121) = v54;
    v57 = __dst;
LABEL_86:
    v132 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type,llvm::CastInfo<mlir::ShapedType,mlir::Type,void>>::doCastIfPossible((v53 & 0xFFFFFFFFFFFFFFF8));
    v133 = v58;
    if (v132)
    {
      v59 = mlir::CallableOpInterface::getArgAttrsAttr(&v132);
      v61 = v60;
    }

    else
    {
      v61 = 0;
      v59 = 0;
    }

    BroadcastedShape = mlir::OpTrait::util::getBroadcastedShape(v57, v54, v59, v61, &__src);
    if ((BroadcastedShape & 1) == 0)
    {
      v115 = "operands don't have broadcast-compatible shapes";
      LOWORD(v119) = 259;
      mlir::Operation::emitOpError(this, &v115, &v132);
      v33 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v132);
      if (v132)
      {
        mlir::InFlightDiagnostic::report(&v132);
      }

      if (v143[0] == 1)
      {
        if (v142 != v143)
        {
          free(v142);
        }

        v63 = __p;
        if (__p)
        {
          v64 = v141;
          v65 = __p;
          if (v141 != __p)
          {
            do
            {
              v64 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v64 - 1);
            }

            while (v64 != v63);
            v65 = __p;
          }

          v141 = v63;
          operator delete(v65);
        }

        v66 = v138;
        if (v138)
        {
          v67 = v139;
          v68 = v138;
          if (v139 != v138)
          {
            do
            {
              v70 = *--v67;
              v69 = v70;
              *v67 = 0;
              if (v70)
              {
                operator delete[](v69);
              }
            }

            while (v67 != v66);
            v68 = v138;
          }

          v139 = v66;
          operator delete(v68);
        }

        if (v135 != v137)
        {
          free(v135);
        }
      }
    }

    if (__dst != &v122)
    {
      free(__dst);
    }

    v46 = v52;
    if ((BroadcastedShape & 1) == 0)
    {
      goto LABEL_122;
    }
  }

  v71 = *(this + 9);
  v72 = this - 16;
  if (!v71)
  {
    v72 = 0;
  }

  __dst = v72;
  v121 = v71;
  mlir::OperandRange::getTypes(&__dst, &v132);
  v73 = v133;
  v74 = v135;
  if (v133 == v135)
  {
    goto LABEL_121;
  }

  v75 = v132;
  while (1)
  {
    mlir::detail::OpResultImpl::getNextResultAtOffset(v75, v73);
    OUTLINED_FUNCTION_0_2();
    if (v76 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      break;
    }

    if (v74 == ++v73)
    {
      v73 = v74;
      break;
    }
  }

  v77 = v135;
  if (v73 == v135)
  {
LABEL_121:
    v33 = 1;
    goto LABEL_122;
  }

  while (2)
  {
    v79 = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v75, v73) + 8);
    v80 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type,llvm::CastInfo<mlir::ShapedType,mlir::Type,void>>::doCastIfPossible((v79 & 0xFFFFFFFFFFFFFFF8));
    v132 = v80;
    v133 = v81;
    if (v80)
    {
      v80 = mlir::CallableOpInterface::getArgAttrsAttr(&v132);
      v83 = v127;
      if (v82 > v127)
      {
        v80 = (v80 + 8 * (v82 - v127));
        goto LABEL_131;
      }
    }

    else
    {
      v82 = 0;
      v83 = v127;
    }

    if (v83 != v82)
    {
      goto LABEL_147;
    }

LABEL_131:
    if (!v83)
    {
LABEL_140:
      v87 = v73 + 1;
      v73 = v74;
      if (v87 != v74)
      {
        v73 = v87;
        while (1)
        {
          mlir::detail::OpResultImpl::getNextResultAtOffset(v75, v73);
          OUTLINED_FUNCTION_0_2();
          if (v88 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
          {
            break;
          }

          if (v74 == ++v73)
          {
            v73 = v74;
            break;
          }
        }
      }

      v33 = 1;
      if (v73 == v77)
      {
        goto LABEL_122;
      }

      continue;
    }

    break;
  }

  v84 = __src;
  v85 = 8 * v83;
  while (*v80 == 0x8000000000000000 || *v84 == 0x8000000000000000 || *v84 == *v80)
  {
    ++v84;
    v80 = (v80 + 8);
    v85 -= 8;
    if (!v85)
    {
      goto LABEL_140;
    }
  }

LABEL_147:
  LOWORD(v119) = 257;
  mlir::Operation::emitOpError(this, &v115, &v132);
  if (v132)
  {
    LODWORD(__dst) = 3;
    OUTLINED_FUNCTION_4_2();
    if (v90)
    {
      OUTLINED_FUNCTION_5_3();
      OUTLINED_FUNCTION_3_1(&v135, &v132);
      v89 = v135;
    }

    OUTLINED_FUNCTION_1_1(v89, &v128, v137, v143, v107, v108, v109, v110, v111, v112, v113, v114, v115, v116, v117, v118, v119, __dst, v121, v122, v123, v124, v125, __src, v127, v128, v129, v130, v131, v132, v133, v134, v135, v136);
  }

  __dst = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type,llvm::CastInfo<mlir::ShapedType,mlir::Type,void>>::doCastIfPossible((v79 & 0xFFFFFFFFFFFFFFF8));
  v121 = v91;
  if (__dst)
  {
    v92 = mlir::CallableOpInterface::getArgAttrsAttr(&__dst);
    v94 = v93;
  }

  else
  {
    v94 = 0;
    v92 = 0;
  }

  getShapeString(&v112, v92, v94);
  if (v132)
  {
    LOWORD(v124) = 260;
    __dst = &v112;
    mlir::Diagnostic::operator<<(&v133, &__dst);
    if (v132)
    {
      LODWORD(__dst) = 3;
      OUTLINED_FUNCTION_4_2();
      if (v90)
      {
        OUTLINED_FUNCTION_5_3();
        OUTLINED_FUNCTION_3_1(&v135, &v132);
        v95 = v135;
      }

      OUTLINED_FUNCTION_1_1(v95, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, v116, v117, v118, v119, __dst, v121, v122, v123, v124, v125, __src, v127, v128, v129, v130, v131, v132, v133, v134, v135, v136);
    }
  }

  getShapeString(&v109, __src, v127);
  if (v132)
  {
    LOWORD(v124) = 260;
    __dst = &v109;
    mlir::Diagnostic::operator<<(&v133, &__dst);
  }

  v33 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v132);
  if (SHIBYTE(v111) < 0)
  {
    operator delete(v109);
  }

  if (SHIBYTE(v114) < 0)
  {
    operator delete(v112);
  }

  if (v132)
  {
    mlir::InFlightDiagnostic::report(&v132);
  }

  if (v143[0] == 1)
  {
    if (v142 != v143)
    {
      free(v142);
    }

    v96 = __p;
    if (__p)
    {
      v97 = v141;
      v98 = __p;
      if (v141 != __p)
      {
        do
        {
          v97 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v97 - 1);
        }

        while (v97 != v96);
        v98 = __p;
      }

      v141 = v96;
      operator delete(v98);
    }

    v99 = v138;
    if (v138)
    {
      v100 = v139;
      v101 = v138;
      if (v139 != v138)
      {
        do
        {
          v103 = *--v100;
          v102 = v103;
          *v100 = 0;
          if (v103)
          {
            operator delete[](v102);
          }
        }

        while (v100 != v99);
        v101 = v138;
      }

      v139 = v99;
      operator delete(v101);
    }

    if (v135 != v137)
    {
      free(v135);
    }
  }

LABEL_122:
  v42 = __src;
  v43 = v104;
LABEL_123:
  if (v42 != v43)
  {
    free(v42);
  }

  return v33;
}

BOOL mlir::func::ReturnOp::verify(mlir::Block ***this)
{
  v174 = *MEMORY[0x1E69E9840];
  v2 = (*this)[2];
  if (v2)
  {
    ParentOp = mlir::Block::getParentOp(v2);
  }

  else
  {
    ParentOp = 0;
  }

  Value = *&ParentOp[4 * ((ParentOp[11] >> 23) & 1) + 18];
  Value = mlir::AffineMapAttr::getValue(&Value);
  Results = mlir::FunctionType::getResults(&Value);
  v6 = Results;
  v7 = v5;
  v8 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v9 = *(v8 + 17);
  }

  else
  {
    v9 = 0;
  }

  if (v5 == v9)
  {
    if (!v5)
    {
      return 1;
    }

    v10 = 0;
    v11 = v8[9];
    for (i = 24; *(Results + 8 * v10) == (*(*(v11 + i) + 8) & 0xFFFFFFFFFFFFFFF8); i += 32)
    {
      if (v5 == ++v10)
      {
        return 1;
      }
    }

    LOWORD(v156) = 257;
    mlir::OpState::emitError(this, &v152, &Value);
    if (Value)
    {
      LODWORD(SymbolName) = 3;
      v158 = "type of return operand ";
      v159 = 23;
      OUTLINED_FUNCTION_24_3();
      if (v18)
      {
        OUTLINED_FUNCTION_5_3();
        v110 = OUTLINED_FUNCTION_11_3();
        llvm::SmallVectorBase<unsigned int>::grow_pod(v110, v112, v111 + 1, 24);
        v44 = v165;
      }

      OUTLINED_FUNCTION_14_4(v44, v147, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
      LODWORD(v166) = v45 + 1;
      if (Value)
      {
        LODWORD(SymbolName) = 5;
        v158 = v10;
        OUTLINED_FUNCTION_50_0();
        if (v47 >= v48)
        {
          OUTLINED_FUNCTION_51();
          if (v114 <= v115 && (v113 & 1) != 0)
          {
            v139 = OUTLINED_FUNCTION_11_3();
            OUTLINED_FUNCTION_32_2(v139, v140);
            v46 = v165;
          }

          else
          {
            v116 = OUTLINED_FUNCTION_11_3();
            OUTLINED_FUNCTION_32_2(v116, v117);
            OUTLINED_FUNCTION_50_0();
          }
        }

        OUTLINED_FUNCTION_3_2(&v46[24 * v166]);
        LODWORD(v166) = v49 + 1;
        if (Value)
        {
          OUTLINED_FUNCTION_38();
          OUTLINED_FUNCTION_9_3();
          if (v18)
          {
            OUTLINED_FUNCTION_13_4();
            if (v120 <= v121 && (v119 & 1) != 0)
            {
              OUTLINED_FUNCTION_10_4(v118, v148, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
            }

            else
            {
              OUTLINED_FUNCTION_10_4(v118, v148, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
              OUTLINED_FUNCTION_22_1();
            }
          }

          OUTLINED_FUNCTION_2_2(v50, v51, v52, v53, v54, v55, v56, v57, v148, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
          OUTLINED_FUNCTION_36();
          if (Value)
          {
            v58 = *(*((*this)[9] + i) + 8);
            v59 = &SymbolName;
            mlir::DiagnosticArgument::DiagnosticArgument(&SymbolName, v58 & 0xFFFFFFFFFFFFFFF8);
            v60 = v165;
            if (v166 >= HIDWORD(v166))
            {
              if (v165 <= &SymbolName && v165 + 24 * v166 > &SymbolName)
              {
                v141 = &SymbolName - v165;
                v142 = OUTLINED_FUNCTION_11_3();
                OUTLINED_FUNCTION_32_2(v142, v143);
                v60 = v165;
                v59 = (v165 + v141);
              }

              else
              {
                v122 = OUTLINED_FUNCTION_11_3();
                OUTLINED_FUNCTION_32_2(v122, v123);
                v59 = &SymbolName;
                v60 = v165;
              }
            }

            OUTLINED_FUNCTION_6_2(&v60[24 * v166], *v59);
            if (v61)
            {
              OUTLINED_FUNCTION_38();
              OUTLINED_FUNCTION_9_3();
              if (v18)
              {
                OUTLINED_FUNCTION_13_4();
                if (v126 <= v127 && (v125 & 1) != 0)
                {
                  OUTLINED_FUNCTION_10_4(v124, v149, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
                }

                else
                {
                  OUTLINED_FUNCTION_10_4(v124, v149, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
                  OUTLINED_FUNCTION_22_1();
                }
              }

              OUTLINED_FUNCTION_2_2(v62, v63, v64, v65, v66, v67, v68, v69, v149, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
              OUTLINED_FUNCTION_36();
              if (Value)
              {
                v70 = *(v6 + 8 * v10);
                v71 = &SymbolName;
                mlir::DiagnosticArgument::DiagnosticArgument(&SymbolName, v70);
                v72 = v165;
                if (v166 >= HIDWORD(v166))
                {
                  if (v165 <= &SymbolName && v165 + 24 * v166 > &SymbolName)
                  {
                    v144 = &SymbolName - v165;
                    v145 = OUTLINED_FUNCTION_11_3();
                    OUTLINED_FUNCTION_32_2(v145, v146);
                    v72 = v165;
                    v71 = (v165 + v144);
                  }

                  else
                  {
                    v128 = OUTLINED_FUNCTION_11_3();
                    OUTLINED_FUNCTION_32_2(v128, v129);
                    v71 = &SymbolName;
                    v72 = v165;
                  }
                }

                OUTLINED_FUNCTION_6_2(&v72[24 * v166], *v71);
                if (v73)
                {
                  OUTLINED_FUNCTION_38();
                  OUTLINED_FUNCTION_9_3();
                  if (v18)
                  {
                    OUTLINED_FUNCTION_13_4();
                    if (v132 <= v133 && (v131 & 1) != 0)
                    {
                      OUTLINED_FUNCTION_10_4(v130, v150, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
                    }

                    else
                    {
                      OUTLINED_FUNCTION_10_4(v130, v150, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
                      OUTLINED_FUNCTION_22_1();
                    }
                  }

                  OUTLINED_FUNCTION_2_2(v74, v75, v76, v77, v78, v79, v80, v81, v150, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
                  LODWORD(v166) = v82 + 1;
                  if (Value)
                  {
                    OUTLINED_FUNCTION_38();
                    OUTLINED_FUNCTION_9_3();
                    if (v18)
                    {
                      OUTLINED_FUNCTION_13_4();
                      if (v136 <= v137 && (v135 & 1) != 0)
                      {
                        OUTLINED_FUNCTION_10_4(v134, v151, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
                      }

                      else
                      {
                        OUTLINED_FUNCTION_10_4(v134, v151, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
                        OUTLINED_FUNCTION_22_1();
                      }
                    }

                    OUTLINED_FUNCTION_2_2(v83, v84, v85, v86, v87, v88, v89, v90, v151, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
                    OUTLINED_FUNCTION_36();
                  }
                }
              }
            }
          }
        }
      }
    }

    SymbolName = mlir::SymbolTable::getSymbolName(ParentOp, v43);
    AttrData = mlir::OpaqueAttr::getAttrData(&SymbolName);
    if (Value)
    {
      LOWORD(v161) = 261;
      SymbolName = AttrData;
      v158 = v92;
      mlir::Diagnostic::operator<<(&v163, &SymbolName);
    }

    v13 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&Value);
    if (Value)
    {
      mlir::InFlightDiagnostic::report(&Value);
    }

    if (v173)
    {
      if (v172 != &v173)
      {
        free(v172);
      }

      v93 = __p;
      if (__p)
      {
        v94 = v171;
        v95 = __p;
        if (v171 != __p)
        {
          do
          {
            v94 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v94 - 1);
          }

          while (v94 != v93);
          v95 = __p;
        }

        v171 = v93;
        operator delete(v95);
      }

      v38 = v168;
      if (!v168)
      {
        goto LABEL_79;
      }

      v96 = v169;
      v40 = v168;
      if (v169 == v168)
      {
LABEL_78:
        v169 = v38;
        operator delete(v40);
LABEL_79:
        if (v165 != v167)
        {
          free(v165);
        }

        return v13;
      }

      do
      {
        v98 = *--v96;
        v97 = v98;
        *v96 = 0;
        if (v98)
        {
          operator delete[](v97);
        }
      }

      while (v96 != v38);
LABEL_77:
      v40 = v168;
      goto LABEL_78;
    }
  }

  else
  {
    v152 = "has ";
    LOWORD(v156) = 259;
    mlir::OpState::emitOpError(this, &v152, &Value);
    if ((*(*this + 46) & 0x80) != 0)
    {
      v15 = *(*this + 17);
    }

    else
    {
      v15 = 0;
    }

    if (Value)
    {
      LODWORD(SymbolName) = 5;
      v158 = v15;
      OUTLINED_FUNCTION_24_3();
      if (v18)
      {
        OUTLINED_FUNCTION_5_3();
        if (v100 <= v102 && (v101 & 1) != 0)
        {
          v138 = &SymbolName - v100;
          OUTLINED_FUNCTION_3_1(&v165, &Value);
          v16 = v165;
          p_SymbolName = &v138[v165];
        }

        else
        {
          OUTLINED_FUNCTION_3_1(&v165, &Value);
          p_SymbolName = &SymbolName;
          v16 = v165;
        }
      }

      OUTLINED_FUNCTION_6_2(&v16[24 * v166], *p_SymbolName);
      if (v19)
      {
        OUTLINED_FUNCTION_38();
        OUTLINED_FUNCTION_9_3();
        if (v18)
        {
          OUTLINED_FUNCTION_13_4();
          if (v105 <= v106 && (v104 & 1) != 0)
          {
            OUTLINED_FUNCTION_43_0(v103, v147, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
          }

          else
          {
            OUTLINED_FUNCTION_43_0(v103, v147, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
            OUTLINED_FUNCTION_22_1();
          }
        }

        OUTLINED_FUNCTION_2_2(v20, v21, v22, v23, v24, v25, v26, v27, v147, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
        OUTLINED_FUNCTION_36();
      }
    }

    SymbolName = mlir::SymbolTable::getSymbolName(ParentOp, v14);
    v28 = mlir::OpaqueAttr::getAttrData(&SymbolName);
    if (Value)
    {
      LOWORD(v161) = 261;
      SymbolName = v28;
      v158 = v29;
      mlir::Diagnostic::operator<<(&v163, &SymbolName);
      if (Value)
      {
        LODWORD(SymbolName) = 3;
        v158 = ") returns ";
        v159 = 10;
        OUTLINED_FUNCTION_24_3();
        if (v18)
        {
          OUTLINED_FUNCTION_5_3();
          OUTLINED_FUNCTION_3_1(&v165, &Value);
          v30 = v165;
        }

        OUTLINED_FUNCTION_14_4(v30, v147, v152, v153, v154, v155, v156, SymbolName, v158, v159, v160, v161, Value, v163, v164, v165, v166);
        LODWORD(v166) = v31 + 1;
        if (Value)
        {
          LODWORD(SymbolName) = 5;
          v158 = v7;
          OUTLINED_FUNCTION_50_0();
          if (v33 >= v34)
          {
            OUTLINED_FUNCTION_51();
            if (v108 <= v109 && (v107 & 1) != 0)
            {
              OUTLINED_FUNCTION_32_2(&v165, v167);
              v32 = v165;
            }

            else
            {
              OUTLINED_FUNCTION_32_2(&v165, v167);
              OUTLINED_FUNCTION_50_0();
            }
          }

          OUTLINED_FUNCTION_3_2(&v32[24 * v166]);
          OUTLINED_FUNCTION_36();
        }
      }
    }

    v13 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&Value);
    if (Value)
    {
      mlir::InFlightDiagnostic::report(&Value);
    }

    if (v173 == 1)
    {
      if (v172 != &v173)
      {
        free(v172);
      }

      v35 = __p;
      if (__p)
      {
        v36 = v171;
        v37 = __p;
        if (v171 != __p)
        {
          do
          {
            v36 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v36 - 1);
          }

          while (v36 != v35);
          v37 = __p;
        }

        v171 = v35;
        operator delete(v37);
      }

      v38 = v168;
      if (!v168)
      {
        goto LABEL_79;
      }

      v39 = v169;
      v40 = v168;
      if (v169 == v168)
      {
        goto LABEL_78;
      }

      do
      {
        v42 = *--v39;
        v41 = v42;
        *v39 = 0;
        if (v42)
        {
          operator delete[](v41);
        }
      }

      while (v39 != v38);
      goto LABEL_77;
    }
  }

  return v13;
}

void mlir::func::CallIndirectOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v37[4] = *MEMORY[0x1E69E9840];
  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v4, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v4, v5);
  }

  OUTLINED_FUNCTION_104();
  (*(v7 + 160))(a2);
  OUTLINED_FUNCTION_104();
  (*(v8 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v11)
  {
    llvm::raw_ostream::write(v9, "(", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v9, v10);
  }

  OUTLINED_FUNCTION_47_0();
  if (v13 < 0)
  {
    v14 = *(v12 + 72);
    v15 = *(v12 + 68) - 1;
  }

  else
  {
    v14 = 0;
    v15 = -1;
  }

  (*(*a2 + 16))(a2);
  if (v15)
  {
    OUTLINED_FUNCTION_104();
    (*(v16 + 160))(a2);
    v17 = v15 - 1;
    if (v17)
    {
      v18 = v14 + 88;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v11 & v6)
        {
          *v19 = 8236;
          OUTLINED_FUNCTION_29_2();
        }

        else
        {
          OUTLINED_FUNCTION_42_0();
        }

        v18 += 32;
        OUTLINED_FUNCTION_104();
        (*(v20 + 160))(a2);
        --v17;
      }

      while (v17);
    }
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v11)
  {
    llvm::raw_ostream::write(v21, ")", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v21, v22);
  }

  v35 = v37;
  v36 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(*this);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_104();
  v23 = OUTLINED_FUNCTION_31_3();
  v24(v23);
  OUTLINED_FUNCTION_104();
  (*(v25 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v26, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v26, v27);
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v11)
  {
    llvm::raw_ostream::write(v28, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v28, v29);
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v30, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v30, v31);
  }

  OUTLINED_FUNCTION_104();
  (*(v32 + 32))(a2, v33 & 0xFFFFFFFFFFFFFFF8);
  if (v35 != v37)
  {
    free(v35);
  }
}

void mlir::func::CallOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v43[4] = *MEMORY[0x1E69E9840];
  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v4, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v4, v5);
  }

  OUTLINED_FUNCTION_104();
  (*(v7 + 48))(a2);
  OUTLINED_FUNCTION_104();
  (*(v8 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v11)
  {
    llvm::raw_ostream::write(v9, "(", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v9, v10);
  }

  OUTLINED_FUNCTION_47_0();
  if (v13 < 0)
  {
    v14 = *(v12 + 68);
    v15 = *(v12 + 72);
  }

  else
  {
    v15 = 0;
    v14 = 0;
  }

  (*(*a2 + 16))(a2);
  if (v14)
  {
    OUTLINED_FUNCTION_104();
    (*(v16 + 160))(a2);
    v17 = v14 - 1;
    if (v17)
    {
      v18 = v15 + 56;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v11 & v6)
        {
          *v19 = 8236;
          OUTLINED_FUNCTION_29_2();
        }

        else
        {
          OUTLINED_FUNCTION_42_0();
        }

        v18 += 32;
        OUTLINED_FUNCTION_104();
        (*(v20 + 160))(a2);
        --v17;
      }

      while (v17);
    }
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v11)
  {
    llvm::raw_ostream::write(v21, ")", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v21, v22);
  }

  v41 = v43;
  v43[0] = "callee";
  v43[1] = 6;
  v42 = 0x200000001;
  v39[0] = mlir::Operation::getAttrDictionary(*this);
  mlir::ArrayAttr::getValue(v39);
  OUTLINED_FUNCTION_104();
  v23 = OUTLINED_FUNCTION_31_3();
  v24(v23);
  OUTLINED_FUNCTION_104();
  (*(v25 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v26, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v26, v27);
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v11)
  {
    llvm::raw_ostream::write(v28, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v28, v29);
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v30, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v30, v31);
  }

  v32 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v33 = *(v32 + 17);
    v34 = *(v32 + 9);
  }

  else
  {
    v34 = 0;
    v33 = 0;
  }

  v38[0] = v34;
  v38[1] = v33;
  mlir::OperandRange::getTypes(v38, v39);
  OUTLINED_FUNCTION_34_2();
  v40[0] = v35;
  v40[1] = v36;
  mlir::OperandRange::getTypes(v40, v37);
  mlir::AsmPrinter::printFunctionalType<mlir::ValueTypeRange<mlir::OperandRange>,mlir::ValueTypeRange<mlir::ResultRange>>(a2, v39, v37);
  if (v41 != v43)
  {
    free(v41);
  }
}

unint64_t mlir::func::ReturnOp::getODSOperandIndexAndLength(mlir::func::ReturnOp *this, int a2)
{
  if ((*(*this + 46) & 0x80) != 0)
  {
    v2 = *(*this + 68);
  }

  else
  {
    v2 = 0;
  }

  return OUTLINED_FUNCTION_41_0(a2, v2);
}

void mlir::func::ReturnOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v47[4] = *MEMORY[0x1E69E9840];
  v45 = v47;
  v46 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(*this);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_104();
  v4 = OUTLINED_FUNCTION_31_3();
  v5(v4);
  OUTLINED_FUNCTION_47_0();
  if (v7 < 0 && *(v6 + 68))
  {
    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v10)
    {
      llvm::raw_ostream::write(v8, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v8, v9);
    }

    OUTLINED_FUNCTION_47_0();
    if (v12 < 0)
    {
      v13 = *(v11 + 68);
      v14 = *(v11 + 72);
    }

    else
    {
      v14 = 0;
      v13 = 0;
    }

    (*(*a2 + 16))(a2);
    if (v13)
    {
      OUTLINED_FUNCTION_104();
      (*(v15 + 160))(a2);
      v16 = v13 - 1;
      if (v16)
      {
        v17 = v14 + 56;
        do
        {
          OUTLINED_FUNCTION_30_2();
          if (!v19 & v10)
          {
            *v18 = 8236;
            OUTLINED_FUNCTION_29_2();
          }

          else
          {
            OUTLINED_FUNCTION_42_0();
          }

          v17 += 32;
          OUTLINED_FUNCTION_104();
          (*(v20 + 160))(a2);
          --v16;
        }

        while (v16);
      }
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v10)
    {
      llvm::raw_ostream::write(v21, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v21, v22);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v19)
    {
      llvm::raw_ostream::write(v23, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v23, v24);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v10)
    {
      llvm::raw_ostream::write(v25, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v25, v26);
    }

    v27 = *this;
    if ((*(*this + 46) & 0x80) != 0)
    {
      v28 = *(v27 + 17);
      v29 = *(v27 + 9);
    }

    else
    {
      v29 = 0;
      v28 = 0;
    }

    v41[0] = v29;
    v41[1] = v28;
    mlir::OperandRange::getTypes(v41, &AttrDictionary);
    v30 = v43;
    v31 = v44;
    if (v43 != v44)
    {
      v32 = AttrDictionary + 32 * v43;
      OUTLINED_FUNCTION_104();
      (*(v33 + 32))(a2, v34 & 0xFFFFFFFFFFFFFFF8);
      if (v30 + 1 != v31)
      {
        v35 = ~v30 + v31;
        v36 = v32 + 56;
        do
        {
          v37 = (*(*a2 + 16))(a2);
          v38 = v37[4];
          if (v37[3] - v38 > 1uLL)
          {
            *v38 = 8236;
            v37[4] += 2;
          }

          else
          {
            llvm::raw_ostream::write(v37, ", ", 2uLL);
          }

          v36 += 32;
          OUTLINED_FUNCTION_104();
          (*(v39 + 32))(a2, v40 & 0xFFFFFFFFFFFFFFF8);
          --v35;
        }

        while (v35);
      }
    }
  }

  if (v45 != v47)
  {
    free(v45);
  }
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
  }

  else
  {
    v2 = 0;
  }

  return v2 + 32;
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperandsMutable@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if ((*(a1 + 46) & 0x80) != 0)
  {
    v2 = *(a1 + 68) - 1;
  }

  else
  {
    v2 = -1;
  }

  return mlir::MutableOperandRange::MutableOperandRange(a2, a1, 1, v2, 0, 0);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::func::CallIndirectOp::print(&v7, a3);
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    return *(a2 + 72);
  }

  else
  {
    return 0;
  }
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperandsMutable@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if ((*(a1 + 46) & 0x80) != 0)
  {
    v2 = *(a1 + 68);
  }

  else
  {
    v2 = 0;
  }

  return mlir::MutableOperandRange::MutableOperandRange(a2, a1, 0, v2, 0, 0);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::func::CallOp::print(&v7, a3);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::func::ReturnOp::print(&v7, a3);
}

void mlir::OpBuilder::create<mlir::func::ConstantOp,mlir::Type &,mlir::FlatSymbolRefAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "func.constant";
  *(a2 + 24) = 13;
}

void mlir::func::CallOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::func::detail::CallOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_39(v2);
  }
}

void mlir::func::ConstantOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_28_2(v2);
  }
}

void mlir::func::FuncOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_15_3(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::CallOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_37(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::CallOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::CallOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::func::CallOp>,mlir::OpTrait::VariadicResults<mlir::func::CallOp>,mlir::OpTrait::ZeroSuccessors<mlir::func::CallOp>,mlir::OpTrait::VariadicOperands<mlir::func::CallOp>,mlir::OpTrait::OpInvariants<mlir::func::CallOp>,mlir::BytecodeOpInterface::Trait<mlir::func::CallOp>,mlir::CallOpInterface::Trait<mlir::func::CallOp>,mlir::OpTrait::MemRefsNormalizable<mlir::func::CallOp>,mlir::SymbolUserOpInterface::Trait<mlir::func::CallOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::SymbolUserOpInterface>();
    mlir::detail::TypeIDResolver<mlir::SymbolUserOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::MemRefsNormalizable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::MemRefsNormalizable>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::MemRefsNormalizable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::MemRefsNormalizable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::SymbolUserOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolUserOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::SymbolUserOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolUserOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::SymbolUserOpInterface::Trait,mlir::OpAsmOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::SymbolOpInterface>();
    mlir::detail::TypeIDResolver<mlir::SymbolOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::FunctionOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_49_0(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::SymbolOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::SymbolOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::CallableOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallableOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::CallableOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallableOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::FunctionOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::FunctionOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::FunctionOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::FunctionOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchTerminatorOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchTerminatorOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchTerminatorOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ReturnLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ReturnLike>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ReturnLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ReturnLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::func::CallOp,mlir::SymbolRefAttr &,mlir::ValueTypeRange<mlir::ResultRange>,mlir::OperandRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "func.call";
  *(a2 + 24) = 9;
}

uint64_t **anonymous namespace::FuncInlinerInterface::handleTerminator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v16[2] = *MEMORY[0x1E69E9840];
  v16[0] = a3;
  v16[1] = a4;
  v15 = a2;
  result = mlir::func::ReturnOp::getODSOperandIndexAndLength(&v15, 0);
  if ((*(v15 + 46) & 0x80) != 0)
  {
    v5 = *(v15 + 72);
  }

  else
  {
    v5 = 0;
  }

  v6 = (HIDWORD(result) + result);
  v7 = v6 - result;
  if (v6 != result)
  {
    v8 = 0;
    v9 = v5 + 32 * result;
    do
    {
      v10 = *(v9 + 32 * v8 + 24);
      result = mlir::ValueRange::dereference_iterator(v16, v8);
      while (1)
      {
        v11 = *result;
        if (!*result)
        {
          break;
        }

        v12 = v11[1];
        if (v12)
        {
          v13 = *v11;
          *v12 = *v11;
          if (v13)
          {
            *(v13 + 8) = v12;
          }
        }

        v11[3] = v10;
        v14 = *v10;
        *v11 = *v10;
        v11[1] = v10;
        if (v14)
        {
          *(v14 + 8) = v11;
        }

        *v10 = v11;
      }

      ++v8;
    }

    while (v8 != v7);
  }

  return result;
}

void mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,mlir::OperandRange>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "cf.br";
  *(a2 + 24) = 5;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

void mlir::ub::__mlir_ods_local_attr_constraint_UBOps1()
{
  {
    v0 = llvm::getTypeName<mlir::ub::PoisonAttrInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_2_3(v2);
  }
}

void mlir::ub::PoisonOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_3_3(v2);
  }
}

void mlir::ub::PoisonOp::populateDefaultProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ub::PoisonAttrInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_2_3(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::StorageUserBase<mlir::ub::PoisonAttr,mlir::Attribute,mlir::AttributeStorage,mlir::detail::AttributeUniquer,mlir::ub::PoisonAttrInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke()
{
  {
    v0 = llvm::getTypeName<mlir::ub::PoisonAttrInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ub::PoisonAttrInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ub::PoisonAttrInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ub::PoisonAttrInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>()
{
  {
    v0 = llvm::getTypeName<mlir::detail::AffineConstantExprStorage>();
    mlir::detail::TypeIDResolver<mlir::detail::AffineConstantExprStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>()
{
  {
    v0 = llvm::getTypeName<mlir::detail::AffineBinaryOpExprStorage>();
    mlir::detail::TypeIDResolver<mlir::detail::AffineBinaryOpExprStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>()
{
  {
    v0 = llvm::getTypeName<mlir::detail::AffineDimExprStorage>();
    mlir::detail::TypeIDResolver<mlir::detail::AffineDimExprStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

llvm::raw_ostream *mlir::OpAsmPrinter::printFunctionalType(mlir::OpAsmPrinter *this, mlir::Operation *a2)
{
  v4 = (*(*this + 16))(this);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v4, 40);
  }

  else
  {
    OUTLINED_FUNCTION_18_2(v5);
  }

  if ((*(a2 + 46) & 0x80) != 0)
  {
    v7 = *(a2 + 17);
    if (v7)
    {
      v8 = *(a2 + 9);
      v9 = *(v8 + 24);
      v10 = v9 ? *(v9 + 8) & 0xFFFFFFFFFFFFFFF8 : 0;
      (*(*this + 32))(this, v10);
      if (v7 != 1)
      {
        v11 = v7 - 1;
        v12 = v8 + 56;
        do
        {
          OUTLINED_FUNCTION_4_3();
          if (!v14 & v6)
          {
            OUTLINED_FUNCTION_13_5(v13);
          }

          else
          {
            llvm::raw_ostream::write(v4, ", ", 2uLL);
          }

          if (*v12)
          {
            v15 = *(*v12 + 8) & 0xFFFFFFFFFFFFFFF8;
          }

          else
          {
            v15 = 0;
          }

          (*(*this + 32))(this, v15);
          v12 += 32;
          --v11;
        }

        while (v11);
      }
    }
  }

  v16 = *(v4 + 4);
  if ((*(v4 + 3) - v16) > 4)
  {
    *(v16 + 4) = 32;
    *v16 = 1043144745;
    *(v4 + 4) += 5;
  }

  else
  {
    llvm::raw_ostream::write(v4, ") -> ", 5uLL);
  }

  if (*(a2 + 9) != 1 || (*(a2 - 1) & 0xFFFFFFFFFFFFFFF8) != 0 && *(*(*(a2 - 1) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
  {
    v19 = *(v4 + 4);
    if (v19 >= *(v4 + 3))
    {
      llvm::raw_ostream::write(v4, 40);
    }

    else
    {
      OUTLINED_FUNCTION_18_2(v19);
    }

    v20 = *(a2 + 9);
    result = (a2 - 16);
    if (v20)
    {
      v22 = a2 - 16;
    }

    else
    {
      v22 = 0;
    }

    if (v20)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(result, 0);
      v24 = NextResultAtOffset ? *(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8 : 0;
      result = (*(*this + 32))(this, v24);
      if (v20 != 1)
      {
        for (i = 1; i != v20; ++i)
        {
          OUTLINED_FUNCTION_4_3();
          if (!v14 & v6)
          {
            OUTLINED_FUNCTION_13_5(v26);
          }

          else
          {
            llvm::raw_ostream::write(v4, ", ", 2uLL);
          }

          v27 = mlir::detail::OpResultImpl::getNextResultAtOffset(v22, i);
          if (v27)
          {
            v28 = *(v27 + 8) & 0xFFFFFFFFFFFFFFF8;
          }

          else
          {
            v28 = 0;
          }

          result = (*(*this + 32))(this, v28);
        }
      }
    }

    v29 = *(v4 + 4);
    if (v29 >= *(v4 + 3))
    {

      return llvm::raw_ostream::write(v4, 41);
    }

    else
    {
      *(v4 + 4) = v29 + 1;
      *v29 = 41;
    }
  }

  else
  {
    v17 = mlir::detail::OpResultImpl::getNextResultAtOffset(a2 - 16, 0);
    if (v17)
    {
      v18 = *(v17 + 8) & 0xFFFFFFFFFFFFFFF8;
    }

    else
    {
      v18 = 0;
    }

    v30 = *(*this + 32);

    return v30(this, v18);
  }

  return result;
}

void anonymous namespace::OperationPrinter::printFullOpWithIndentAndLoc(_anonymous_namespace_::OperationPrinter *this, mlir::Operation *a2)
{
  v4 = *(this + 3);
  v5 = *(this + 20);
  v6 = *(this + 38);
  *&v121[0] = a2;
  v7 = *(v4 + 672);
  if (v7)
  {
    v8 = llvm::DenseMapBase<llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>,mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::operator[](v7, v121);
    *v8 = v5;
    v8[1] = v6;
    v6 = *(this + 38);
  }

  llvm::raw_ostream::indent(*(this + 2), v6);
  v9 = *(a2 + 9);
  if (v9)
  {
    v10 = *(this + 3);
    v11 = *(v10 + 368);
    if (v11)
    {
      v12 = *(v10 + 352);
      v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      v14 = *(v12 + 32 * v13);
      if (v14 == a2)
      {
LABEL_6:
        if (v13 != v11)
        {
          v15 = v12 + 32 * v13;
          v16 = *(v15 + 16);
          if (v16)
          {
            v17 = *(v15 + 8);
            v120 = *(v15 + 16);
            if (v16 != 1)
            {
              v18 = v16 - 1;
              v19 = *(this + 2);
              v20 = v17[1] - *v17;
              v21 = OUTLINED_FUNCTION_17_3(v10);
              if (v20 >= 2)
              {
                OUTLINED_FUNCTION_13_3();
                if (v91)
                {
                  v26 = llvm::raw_ostream::write(v24, 58);
                }

                else
                {
                  v26 = OUTLINED_FUNCTION_7_2(v24, v25);
                  *v27 = 58;
                }

                llvm::raw_ostream::operator<<(v26, v20);
              }

              if (v18 != 1)
              {
                v28 = v18 - 1;
                v29 = 0x100000000;
                do
                {
                  OUTLINED_FUNCTION_2_4();
                  if (!v31 && v91)
                  {
                    *v30 = 8236;
                    OUTLINED_FUNCTION_1_2();
                  }

                  else
                  {
                    llvm::raw_ostream::write(v19, ", ", 2uLL);
                  }

                  v32 = *(v17 + (v29 >> 30) + 4) - *(v17 + (v29 >> 30));
                  v33 = OUTLINED_FUNCTION_17_3(*(this + 3));
                  if (v32 >= 2)
                  {
                    OUTLINED_FUNCTION_13_3();
                    if (v91)
                    {
                      v39 = llvm::raw_ostream::write(v37, 58);
                    }

                    else
                    {
                      v39 = OUTLINED_FUNCTION_7_2(v37, v38);
                      *v40 = 58;
                    }

                    llvm::raw_ostream::operator<<(v39, v32);
                  }

                  v29 += 0x100000000;
                  --v28;
                }

                while (v28);
              }
            }

            OUTLINED_FUNCTION_6_3();
            OUTLINED_FUNCTION_4_3();
            if (!v31 && v91)
            {
              OUTLINED_FUNCTION_8_3(v41, v42);
            }

            else
            {
              llvm::raw_ostream::write(v41, ", ", 2uLL);
            }

            v9 -= v17[v120 - 1];
            v43 = OUTLINED_FUNCTION_17_3(*(this + 3));
            if (v9 < 2)
            {
              goto LABEL_38;
            }

            goto LABEL_34;
          }
        }
      }

      else
      {
        while (v14 != -4096)
        {
          OUTLINED_FUNCTION_9_4();
          v14 = *(v12 + v47);
          if (v14 == a2)
          {
            goto LABEL_6;
          }
        }
      }
    }

    v48 = OUTLINED_FUNCTION_17_3(v10);
    if (v9 == 1)
    {
LABEL_38:
      v56 = OUTLINED_FUNCTION_6_3();
      if ((v58 - v57) > 2)
      {
        *(v57 + 2) = 32;
        OUTLINED_FUNCTION_15_4(v56, v57);
      }

      else
      {
        llvm::raw_ostream::write(v56, " = ", 3uLL);
      }

      goto LABEL_41;
    }

LABEL_34:
    OUTLINED_FUNCTION_13_3();
    if (v91)
    {
      v54 = llvm::raw_ostream::write(v52, 58);
    }

    else
    {
      v54 = OUTLINED_FUNCTION_7_2(v52, v53);
      *v55 = 58;
    }

    llvm::raw_ostream::operator<<(v54, v9);
    goto LABEL_38;
  }

LABEL_41:
  (*(*this + 208))(this, a2);
  v59 = *(this + 72);
  if (v59)
  {
    v60 = *(a2 + 3);
    v61 = OUTLINED_FUNCTION_6_3();
    if (v63 == v62)
    {
      llvm::raw_ostream::write(v61, " ", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v61, v62);
    }

    v64.var0 = v60;
    mlir::AsmPrinter::Impl::printLocation((this + 16), v64, 1);
    v59 = *(this + 72);
  }

  if ((v59 & 0x40) == 0)
  {
    return;
  }

  v65 = *(a2 + 9);
  if (!v65)
  {
    if ((*(a2 + 46) & 0x80) != 0 && *(a2 + 17))
    {
      v71 = OUTLINED_FUNCTION_6_3();
      if ((v73 - v72) > 7)
      {
        *v72 = 0x203A6469202F2F20;
        v71[4] += 8;
      }

      else
      {
        llvm::raw_ostream::write(v71, " // id: ", 8uLL);
      }
    }

    return;
  }

  v66 = 0;
  v67 = a2 - 16;
  while (!*mlir::detail::OpResultImpl::getNextResultAtOffset(a2 - 16, v66))
  {
    if (v65 == ++v66)
    {
      v68 = OUTLINED_FUNCTION_6_3();
      if ((v70 - v69) > 9)
      {
        *(v69 + 8) = 25701;
        *v69 = *" // unused";
        v68[4] += 10;
      }

      else
      {
        llvm::raw_ostream::write(v68, " // unused", 0xAuLL);
      }

      return;
    }
  }

  v74 = *(a2 + 9);
  if (!v74)
  {
    return;
  }

  v75 = 0;
  while (1)
  {
    v76 = OUTLINED_FUNCTION_16_3();
    if (*mlir::detail::OpResultImpl::getNextResultAtOffset(v76, v77))
    {
      break;
    }

    if (v74 == ++v75)
    {
      return;
    }
  }

  v125 = &v129;
  v126 = &v129;
  v127 = 1;
  v128 = 0;
  v78 = *(a2 + 9);
  if (v78)
  {
    v79 = a2 - 16;
  }

  else
  {
    v79 = 0;
  }

  *&v121[0] = v79;
  *(&v121[0] + 1) = v78;
  mlir::ResultRange::use_begin(v121, v130);
  v80 = *(a2 + 9);
  if (v80)
  {
    v81 = a2 - 16;
  }

  else
  {
    v81 = 0;
  }

  v132.n128_u64[0] = v81;
  v132.n128_u64[1] = v80;
  mlir::ResultRange::use_end(&v132, v123);
  v82 = v131;
  v122 = v131;
  v121[0] = v130[0];
  v121[1] = v130[1];
  v83 = v124;
  if (v131 != v124)
  {
    v84 = 0;
    v85 = 0;
    while (1)
    {
      v86 = *(v82 + 16);
      if (v126 != v125)
      {
        goto LABEL_75;
      }

      v88 = HIDWORD(v127);
      if (HIDWORD(v127))
      {
        v89 = 8 * HIDWORD(v127);
        v90 = v125;
        while (*v90 != v86)
        {
          ++v90;
          v89 -= 8;
          if (!v89)
          {
            goto LABEL_81;
          }
        }

        goto LABEL_84;
      }

LABEL_81:
      if (HIDWORD(v127) < v127)
      {
        ++HIDWORD(v127);
        v125[v88] = v86;
      }

      else
      {
LABEL_75:
        llvm::SmallPtrSetImplBase::insert_imp_big(&v125, v86);
        if ((v87 & 1) == 0)
        {
          goto LABEL_84;
        }
      }

      ++v85;
      v84 += *(v86 + 36);
LABEL_84:
      mlir::ResultRange::UseIterator::operator++(v130);
      v82 = v131;
      if (v131 == v83)
      {
        v91 = v84 >= 2 || v85 >= 2;
        v92 = !v91;
        goto LABEL_92;
      }
    }
  }

  v92 = 1;
LABEL_92:
  v93 = v65 == 1;
  v94 = v93 & v92;
  if ((v93 & v92) != 0)
  {
    v95 = "user";
  }

  else
  {
    v95 = "users";
  }

  v96 = *(this + 2);
  v97 = v96[4];
  if (v96[3] - v97 > 3uLL)
  {
    *v97 = 539963168;
    v98 = (v96[4] + 4);
    v96[4] = v98;
  }

  else
  {
    v96 = llvm::raw_ostream::write(*(this + 2), " // ", 4uLL);
    v98 = v96[4];
  }

  if (v94)
  {
    v99 = 4;
  }

  else
  {
    v99 = 5;
  }

  if (v99 <= v96[3] - v98)
  {
    memcpy(v98, v95, v99);
    v96[4] += v99;
  }

  else
  {
    v100 = OUTLINED_FUNCTION_16_3();
    v96 = llvm::raw_ostream::write(v100, v101, v99);
  }

  OUTLINED_FUNCTION_4_3();
  if (!v31 && v91)
  {
    *v102 = 8250;
    OUTLINED_FUNCTION_1_2();
  }

  else
  {
    llvm::raw_ostream::write(v96, ": ", 2uLL);
  }

  v103 = *(a2 + 9);
  if (v103)
  {
    v104 = a2 - 16;
  }

  else
  {
    v104 = 0;
  }

  if (v103)
  {
    v105 = *(this + 2);
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v67, 0);
    if (v65 == 1)
    {
    }

    else
    {
      v107 = OUTLINED_FUNCTION_6_3();
      if (v109 == v108)
      {
        llvm::raw_ostream::write(v107, "(", 1uLL);
      }

      else
      {
        OUTLINED_FUNCTION_4_1(v107, v108);
      }

      OUTLINED_FUNCTION_17_2();
      if (v31)
      {
        llvm::raw_ostream::write(v110, ")", 1uLL);
      }

      else
      {
        OUTLINED_FUNCTION_4_1(v110, v111);
      }
    }

    if (v103 != 1)
    {
      for (i = 1; i != v103; ++i)
      {
        OUTLINED_FUNCTION_2_4();
        if (!v31 && v91)
        {
          *v113 = 8236;
          OUTLINED_FUNCTION_1_2();
        }

        else
        {
          llvm::raw_ostream::write(v105, ", ", 2uLL);
        }

        v114 = mlir::detail::OpResultImpl::getNextResultAtOffset(v104, i);
        if (v65 == 1)
        {
        }

        else
        {
          v115 = OUTLINED_FUNCTION_6_3();
          if (v117 == v116)
          {
            llvm::raw_ostream::write(v115, "(", 1uLL);
          }

          else
          {
            *v116 = 40;
            ++v115[4];
          }

          OUTLINED_FUNCTION_17_2();
          if (v31)
          {
            llvm::raw_ostream::write(v118, ")", 1uLL);
          }

          else
          {
            OUTLINED_FUNCTION_4_1(v118, v119);
          }
        }
      }
    }
  }

  if (v126 != v125)
  {
    free(v126);
  }
}

llvm::raw_ostream *anonymous namespace::OperationPrinter::printGenericOp(llvm::raw_ostream **this, mlir::Operation *a2, int a3)
{
  v105[6] = *MEMORY[0x1E69E9840];
  if (a3)
  {
    *&v94[0] = *(*(a2 + 6) + 8);
    AttrData = mlir::OpaqueAttr::getAttrData(v94);
    v8 = v7;
    OUTLINED_FUNCTION_17_2();
    if (v11)
    {
      llvm::raw_ostream::write(v9, "", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v9, v10);
    }

    llvm::printEscapedString(AttrData, v8, this[2]);
    OUTLINED_FUNCTION_17_2();
    if (v11)
    {
      llvm::raw_ostream::write(v12, "", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v12, v13);
    }
  }

  v14 = this + 2;
  OUTLINED_FUNCTION_13_3();
  if (v17)
  {
    llvm::raw_ostream::write(v15, 40);
  }

  else
  {
    OUTLINED_FUNCTION_7_2(v15, v16);
    *v18 = 40;
  }

  if ((*(a2 + 46) & 0x80) != 0)
  {
    v3 = *(a2 + 17);
    if (v3)
    {
      v19 = *(a2 + 9);
      if (v3 != 1)
      {
        AttrData = (v3 - 1);
        v20 = (v19 + 56);
        do
        {
          OUTLINED_FUNCTION_2_4();
          if (!v11 & v17)
          {
            *v21 = 8236;
            OUTLINED_FUNCTION_1_2();
          }

          else
          {
            v22 = OUTLINED_FUNCTION_16_3();
            llvm::raw_ostream::write(v22, v23, 2uLL);
          }

          v24 = *v20;
          v20 += 4;
          AttrData = (AttrData - 1);
        }

        while (AttrData);
      }
    }
  }

  v25 = OUTLINED_FUNCTION_3_4();
  if (v17)
  {
    llvm::raw_ostream::write(v25, 41);
  }

  else
  {
    OUTLINED_FUNCTION_7_2(v25, v26);
    *v27 = 41;
  }

  if (*(a2 + 10))
  {
    v28 = OUTLINED_FUNCTION_3_4();
    if (v17)
    {
      llvm::raw_ostream::write(v28, 91);
    }

    else
    {
      OUTLINED_FUNCTION_7_2(v28, v29);
      *v30 = 91;
    }

    mlir::SuccessorRange::SuccessorRange(v94, a2);
    v31 = *(&v94[0] + 1);
    if (!*(&v94[0] + 1))
    {
      goto LABEL_36;
    }

    v32 = this[2];
    if (*(this[3] + 98))
    {
      OUTLINED_FUNCTION_10_5();
      if (v11)
      {
LABEL_30:
        if (v35 != v33)
        {
          v39 = *(v34 + 32 * v35 + 24);
          v37 = OUTLINED_FUNCTION_14_5();
          if (v39 <= v41)
          {
            if (!v39)
            {
              goto LABEL_35;
            }

            goto LABEL_32;
          }

LABEL_34:
          llvm::raw_ostream::write(v32, v38, v39);
          goto LABEL_35;
        }
      }

      else
      {
        while (v36 != -4096)
        {
          OUTLINED_FUNCTION_9_4();
          v36 = *(v34 + v92);
          if (v36 == v93)
          {
            goto LABEL_30;
          }
        }
      }
    }

    v37 = OUTLINED_FUNCTION_14_5();
    v38 = "INVALIDBLOCK";
    v39 = 12;
    if (v40 > 0xB)
    {
LABEL_32:
      memcpy(v37, v38, v39);
      *AttrData += v39;
LABEL_35:
      if (v31 == 1)
      {
LABEL_36:
        v14 = this + 2;
        v42 = OUTLINED_FUNCTION_3_4();
        if (v17)
        {
          llvm::raw_ostream::write(v42, 93);
        }

        else
        {
          OUTLINED_FUNCTION_7_2(v42, v43);
          *v44 = 93;
        }

        goto LABEL_39;
      }

      v76 = 1;
      while (1)
      {
        OUTLINED_FUNCTION_2_4();
        if (!v11 & v17)
        {
          *v77 = 8236;
          OUTLINED_FUNCTION_1_2();
        }

        else
        {
          v78 = OUTLINED_FUNCTION_16_3();
          llvm::raw_ostream::write(v78, v79, 2uLL);
        }

        if (!*(this[3] + 98))
        {
          goto LABEL_81;
        }

        OUTLINED_FUNCTION_10_5();
        if (!v11)
        {
          break;
        }

LABEL_80:
        if (v82 == v80)
        {
          goto LABEL_81;
        }

        v88 = *(v81 + 32 * v82 + 24);
        OUTLINED_FUNCTION_19_2();
        if (v88 > v89)
        {
          goto LABEL_85;
        }

        if (v88)
        {
          goto LABEL_87;
        }

LABEL_88:
        if (++v76 == v31)
        {
          goto LABEL_36;
        }
      }

      while (v83 != -4096)
      {
        OUTLINED_FUNCTION_9_4();
        v83 = *(v81 + v90);
        if (v83 == v91)
        {
          goto LABEL_80;
        }
      }

LABEL_81:
      OUTLINED_FUNCTION_19_2();
      if (v86 > 0xB)
      {
        v88 = 12;
        v87 = "INVALIDBLOCK";
LABEL_87:
        memcpy(v85, v87, v88);
        *v3 += v88;
        goto LABEL_88;
      }

      v87 = "INVALIDBLOCK";
      v88 = 12;
LABEL_85:
      llvm::raw_ostream::write(v84, v87, v88);
      goto LABEL_88;
    }

    goto LABEL_34;
  }

LABEL_39:
  PropertiesAsAttribute = mlir::Operation::getPropertiesAsAttribute(a2);
  if (PropertiesAsAttribute)
  {
    v46 = PropertiesAsAttribute;
    OUTLINED_FUNCTION_4_3();
    if (!v11 & v17)
    {
      OUTLINED_FUNCTION_8_3(v47, v48);
    }

    else
    {
      llvm::raw_ostream::write(v47, " <", 2uLL);
    }

    {
      mlir::AsmPrinter::Impl::printAttributeImpl(v14, v46, 0);
    }

    v49 = OUTLINED_FUNCTION_3_4();
    if (v17)
    {
      llvm::raw_ostream::write(v49, 62);
    }

    else
    {
      OUTLINED_FUNCTION_7_2(v49, v50);
      *v51 = 62;
    }
  }

  v52 = *(a2 + 11);
  if ((v52 & 0x7FFFFF) != 0)
  {
    OUTLINED_FUNCTION_4_3();
    if (!v11 & v17)
    {
      OUTLINED_FUNCTION_8_3(v53, v54);
    }

    else
    {
      llvm::raw_ostream::write(v53, " (", 2uLL);
    }

    v55 = *(a2 + 11);
    v56 = v55 & 0x7FFFFF;
    if ((v55 & 0x7FFFFF) != 0)
    {
      v57 = ((a2 + 16 * ((v55 >> 23) & 1) + ((v55 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 10);
      v58 = this[2];
      v59 = OUTLINED_FUNCTION_12_3();
      v60(v59);
      if (v56 != 1)
      {
        v61 = v57 + 24;
        v62 = 24 * v56 - 24;
        do
        {
          OUTLINED_FUNCTION_2_4();
          if (!v11 & v17)
          {
            *v63 = 8236;
            OUTLINED_FUNCTION_1_2();
          }

          else
          {
            llvm::raw_ostream::write(v58, ", ", 2uLL);
          }

          v64 = OUTLINED_FUNCTION_12_3();
          v65(v64);
          v61 += 24;
          v62 -= 24;
        }

        while (v62);
      }
    }

    v66 = OUTLINED_FUNCTION_3_4();
    if (v17)
    {
      llvm::raw_ostream::write(v66, 41);
    }

    else
    {
      OUTLINED_FUNCTION_7_2(v66, v67);
      *v68 = 41;
    }

    v52 = *(a2 + 11);
  }

  v69 = HIBYTE(v52);
  if (HIBYTE(v52))
  {
    mlir::Operation::getDiscardableAttrs(a2, v94);
    v101[0] = v94[0];
    v101[1] = v94[1];
    v102 = v95;
    v99[0] = v96;
    v99[1] = v97;
    v100 = v98;
    AttrDictionary = v105;
    v104 = 0x300000000;
    llvm::SmallVectorImpl<mlir::NamedAttribute>::append<llvm::filter_iterator_impl<mlir::NamedAttribute const*,mlir::Operation::getDiscardableAttrs(void)::{lambda(mlir::NamedAttribute)#1},std::bidirectional_iterator_tag>,void>(&AttrDictionary, v101, v99);
    Value = AttrDictionary;
    v72 = v104;
  }

  else
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(a2);
    Value = mlir::ArrayAttr::getValue(&AttrDictionary);
    v72 = v71;
  }

  (*(*this + 24))(this, Value, v72, 0, 0);
  if (v69 && AttrDictionary != v105)
  {
    free(AttrDictionary);
  }

  v73 = *v14;
  v74 = *(*v14 + 4);
  if ((*(*v14 + 3) - v74) > 2)
  {
    *(v74 + 2) = 32;
    OUTLINED_FUNCTION_15_4(v73, v74);
  }

  else
  {
    llvm::raw_ostream::write(v73, " : ", 3uLL);
  }

  return mlir::OpAsmPrinter::printFunctionalType(this, a2);
}

uint64_t anonymous namespace::DummyAliasOperationPrinter::printGenericOp(_anonymous_namespace_::DummyAliasOperationPrinter *this, mlir::Operation *a2)
{
  if ((*(*(this + 2) + 40) & 8) == 0)
  {
    v4 = *(a2 + 11);
    if ((v4 & 0x7FFFFF) != 0)
    {
      v5 = ((a2 + 16 * ((v4 >> 23) & 1) + ((v4 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 10);
      v6 = 24 * (v4 & 0x7FFFFF);
      do
      {
        (*(*this + 224))(this, v5, 1, 1, 0);
        v5 += 24;
        v6 -= 24;
      }

      while (v6);
    }
  }

  if ((*(a2 + 46) & 0x80) != 0)
  {
    v7 = *(a2 + 9);
    v8 = *(a2 + 17);
  }

  else
  {
    v7 = 0;
    v8 = 0;
  }

  v26 = v7;
  v27 = v8;
  mlir::OperandRange::getTypes(&v26, &AttrDictionary);
  v9 = v25 - v24;
  if (v25 != v24)
  {
    v10 = (AttrDictionary + 32 * v24 + 24);
    do
    {
      v11 = *v10;
      v10 += 4;
      (*(*this + 32))(this, *(v11 + 8) & 0xFFFFFFFFFFFFFFF8);
      --v9;
    }

    while (v9);
  }

  v12 = *(a2 + 9);
  v13 = a2 - 16;
  if (!v12)
  {
    v13 = 0;
  }

  v26 = v13;
  v27 = v12;
  mlir::OperandRange::getTypes(&v26, &AttrDictionary);
  v14 = v24;
  v15 = v25;
  if (v24 != v25)
  {
    v16 = AttrDictionary;
    do
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, v14);
      (*(*this + 32))(this, *(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
      ++v14;
    }

    while (v15 != v14);
  }

  AttrDictionary = mlir::Operation::getAttrDictionary(a2);
  result = mlir::ArrayAttr::getValue(&AttrDictionary);
  if (v19)
  {
    v20 = 16 * v19;
    v21 = (result + 8);
    do
    {
      v22 = *v21;
      v21 += 2;
      result = (*(*this + 40))(this, v22);
      v20 -= 16;
    }

    while (v20);
  }

  return result;
}

void mlir::AsmPrinter::Impl::printAttributeImpl()
{
  {
    v0 = llvm::getTypeName<mlir::DistinctAttr>();
    mlir::detail::TypeIDResolver<mlir::DistinctAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t anonymous namespace::OperationPrinter::print(_anonymous_namespace_::OperationPrinter *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5 = a2;
  do
  {
    v7 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v5, a2);
    ++*(a1 + 20);
    OUTLINED_FUNCTION_13_3();
    if (v10)
    {
      result = llvm::raw_ostream::write(v8, 10);
    }

    else
    {
      result = OUTLINED_FUNCTION_7_2(v8, v9);
      *v12 = 10;
    }

    v5 = *(v5 + 8);
  }

  while (v5 != a4);
  return result;
}

void anonymous namespace::AliasInitializer::visit()
{
  {
    v0 = llvm::getTypeName<mlir::DistinctAttr>();
    mlir::detail::TypeIDResolver<mlir::DistinctAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Builder::getZeroAttr()
{
  {
    v0 = llvm::getTypeName<mlir::TypedAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1_3(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::TypedAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1_3(v2);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::SparseElementsAttr>::getElementType()
{
  {
    v0 = llvm::getTypeName<mlir::ElementsAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1_4(v2);
  }
}

void mlir::DistinctAttr::create()
{
  {
    v0 = llvm::getTypeName<mlir::DistinctAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_3_5(v2);
  }
}

void mlir::detail::StorageUserBase<mlir::AffineMapAttr,mlir::Attribute,mlir::detail::AffineMapAttrStorage,mlir::detail::AttributeUniquer,mlir::MemRefLayoutAttrInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke()
{
  {
    v0 = llvm::getTypeName<mlir::MemRefLayoutAttrInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemRefLayoutAttrInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::MemRefLayoutAttrInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemRefLayoutAttrInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<unsigned char,unsigned short,unsigned int,unsigned long long,signed char,short,int,long long,short,unsigned short,int,unsigned int,long,unsigned long,std::complex<unsigned char>,std::complex<unsigned short>,std::complex<unsigned int>,std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<unsigned char>();
    mlir::detail::TypeIDResolver<unsigned char,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<unsigned short,unsigned int,unsigned long long,signed char,short,int,long long,short,unsigned short,int,unsigned int,long,unsigned long,std::complex<unsigned char>,std::complex<unsigned short>,std::complex<unsigned int>,std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<unsigned short>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
    OUTLINED_FUNCTION_4_4(v2);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<unsigned int,unsigned long long,signed char,short,int,long long,short,unsigned short,int,unsigned int,long,unsigned long,std::complex<unsigned char>,std::complex<unsigned short>,std::complex<unsigned int>,std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<unsigned int>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
    OUTLINED_FUNCTION_7_3(v2);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<unsigned long long,signed char,short,int,long long,short,unsigned short,int,unsigned int,long,unsigned long,std::complex<unsigned char>,std::complex<unsigned short>,std::complex<unsigned int>,std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<unsigned long long>();
    mlir::detail::TypeIDResolver<unsigned long long,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<signed char,short,int,long long,short,unsigned short,int,unsigned int,long,unsigned long,std::complex<unsigned char>,std::complex<unsigned short>,std::complex<unsigned int>,std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<signed char>();
    mlir::detail::TypeIDResolver<signed char,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<short,int,long long,short,unsigned short,int,unsigned int,long,unsigned long,std::complex<unsigned char>,std::complex<unsigned short>,std::complex<unsigned int>,std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<short>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
    OUTLINED_FUNCTION_6_4(v2);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<int,long long,short,unsigned short,int,unsigned int,long,unsigned long,std::complex<unsigned char>,std::complex<unsigned short>,std::complex<unsigned int>,std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<int>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
    OUTLINED_FUNCTION_5_4(v2);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<long long,short,unsigned short,int,unsigned int,long,unsigned long,std::complex<unsigned char>,std::complex<unsigned short>,std::complex<unsigned int>,std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<long long>();
    mlir::detail::TypeIDResolver<long long,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<long,unsigned long,std::complex<unsigned char>,std::complex<unsigned short>,std::complex<unsigned int>,std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<long>();
    mlir::detail::TypeIDResolver<long,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<unsigned long,std::complex<unsigned char>,std::complex<unsigned short>,std::complex<unsigned int>,std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<unsigned long>();
    mlir::detail::TypeIDResolver<unsigned long,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<std::complex<unsigned char>,std::complex<unsigned short>,std::complex<unsigned int>,std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    v0 = llvm::getTypeName<std::complex<unsigned char>>();
    mlir::detail::TypeIDResolver<std::complex<unsigned char>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<std::complex<unsigned short>,std::complex<unsigned int>,std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    v0 = llvm::getTypeName<std::complex<unsigned short>>();
    mlir::detail::TypeIDResolver<std::complex<unsigned short>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<std::complex<unsigned int>,std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    v0 = llvm::getTypeName<std::complex<unsigned int>>();
    mlir::detail::TypeIDResolver<std::complex<unsigned int>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<std::complex<unsigned long long>,std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    v0 = llvm::getTypeName<std::complex<unsigned long long>>();
    mlir::detail::TypeIDResolver<std::complex<unsigned long long>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<std::complex<signed char>,std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    v0 = llvm::getTypeName<std::complex<signed char>>();
    mlir::detail::TypeIDResolver<std::complex<signed char>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<std::complex<short>,std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    v0 = llvm::getTypeName<std::complex<short>>();
    mlir::detail::TypeIDResolver<std::complex<short>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<std::complex<int>,std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    v0 = llvm::getTypeName<std::complex<int>>();
    mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<std::complex<long long>,float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    v0 = llvm::getTypeName<std::complex<long long>>();
    mlir::detail::TypeIDResolver<std::complex<long long>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<float,double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<float>();
    mlir::detail::TypeIDResolver<float,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<double,std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<double>();
    mlir::detail::TypeIDResolver<double,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<std::complex<float>,std::complex<double>,std::integral_constant<BOOL,true>>()
{
  {
    v0 = llvm::getTypeName<std::complex<float>>();
    mlir::detail::TypeIDResolver<std::complex<float>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void _ZNK4mlir6detail17ElementsAttrTraitINS_24DenseIntOrFPElementsAttrEE12getValueImplINSt3__17complexIdEEJENS5_17integral_constantIbLb1EEEEEDaNS_6TypeIDET1__cold_1()
{
  {
    v0 = llvm::getTypeName<std::complex<double>>();
    mlir::detail::TypeIDResolver<std::complex<double>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<mlir::Attribute,llvm::APInt,BOOL,std::complex<llvm::APInt>,llvm::APFloat,std::complex<llvm::APFloat>,std::integral_constant<BOOL,false>>()
{
  {
    v0 = llvm::getTypeName<mlir::Attribute>();
    mlir::detail::TypeIDResolver<mlir::Attribute,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<llvm::APInt,BOOL,std::complex<llvm::APInt>,llvm::APFloat,std::complex<llvm::APFloat>,std::integral_constant<BOOL,false>>()
{
  {
    v0 = llvm::getTypeName<llvm::APInt>();
    mlir::detail::TypeIDResolver<llvm::APInt,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    Type = llvm::getTypeName<BOOL>();
    mlir::detail::TypeIDResolver<BOOL,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<std::complex<llvm::APInt>,llvm::APFloat,std::complex<llvm::APFloat>,std::integral_constant<BOOL,false>>()
{
  {
    v0 = llvm::getTypeName<std::complex<llvm::APInt>>();
    mlir::detail::TypeIDResolver<std::complex<llvm::APInt>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::DenseIntOrFPElementsAttr>::getValueImpl<llvm::APFloat,std::complex<llvm::APFloat>,std::integral_constant<BOOL,false>>()
{
  {
    v0 = llvm::getTypeName<llvm::APFloat>();
    mlir::detail::TypeIDResolver<llvm::APFloat,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void _ZNK4mlir6detail17ElementsAttrTraitINS_24DenseIntOrFPElementsAttrEE12getValueImplINSt3__17complexIN4llvm7APFloatEEEJENS5_17integral_constantIbLb0EEEEEDaNS_6TypeIDET1__cold_1()
{
  {
    v0 = llvm::getTypeName<std::complex<llvm::APFloat>>();
    mlir::detail::TypeIDResolver<std::complex<llvm::APFloat>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::storage_user_base_impl::hasTrait<mlir::TypedAttr::Trait,mlir::ElementsAttr::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::TypedAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::TypedAttr::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_2_5(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ElementsAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::ElementsAttr::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ElementsAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::ElementsAttr::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void _ZNK4mlir6detail17ElementsAttrTraitINS_23DenseStringElementsAttrEE12getValueImplIN4llvm9StringRefEJENSt3__117integral_constantIbLb1EEEEEDaNS_6TypeIDET1__cold_1()
{
  {
    v0 = llvm::getTypeName<llvm::StringRef>();
    mlir::detail::TypeIDResolver<llvm::StringRef,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::addAttribute<mlir::DistinctAttr>()
{
  {
    v0 = llvm::getTypeName<mlir::DistinctAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_3_5(v2);
  }
}

void mlir::Dialect::getRegisteredInterface<mlir::ResourceBlobManagerDialectInterfaceBase<mlir::DialectResourceBlobHandle<mlir::BuiltinDialect>>>()
{
  {
    v0 = llvm::getTypeName<mlir::ResourceBlobManagerDialectInterface>();
    mlir::detail::TypeIDResolver<mlir::ResourceBlobManagerDialectInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::UnrealizedConversionCastOp::fold(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v4 = *a1;
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    v5 = *(v4 + 68);
    v6 = *(v4 + 72);
  }

  else
  {
    v6 = 0;
    v5 = 0;
  }

  v52 = v6;
  v53 = v5;
  OUTLINED_FUNCTION_16_4();
  v51[0] = v7;
  v51[1] = v8;
  mlir::OperandRange::getTypes(&v52, &v48);
  mlir::OperandRange::getTypes(v51, &v45);
  v9 = v50 - v49;
  v10 = v46;
  if (v50 - v49 == v47 - v46)
  {
    if (v50 == v49)
    {
LABEL_8:
      v14 = v53;
      v15 = *(a3 + 8);
      if (v53 + v15 > *(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, a3 + 16, v53 + v15, 8);
        v15 = *(a3 + 8);
      }

      if (!v14)
      {
        goto LABEL_61;
      }

      v16 = (*a3 + 8 * v15);
      if (v14 >= 0xB)
      {
        OUTLINED_FUNCTION_18_3();
        v19 = v19 || v18 >= v17;
        if (v19)
        {
          OUTLINED_FUNCTION_10_6();
          do
          {
            OUTLINED_FUNCTION_2_6(v20);
          }

          while (!v22);
          v16 = v21;
        }
      }

      do
      {
        OUTLINED_FUNCTION_17_4(v16);
      }

      while (!v22);
      goto LABEL_60;
    }

    v11 = v45;
    v12 = v48 + 32 * v49 + 24;
    while (1)
    {
      v13 = *(*v12 + 8);
      if ((*(mlir::detail::OpResultImpl::getNextResultAtOffset(v11, v10) + 8) ^ v13) > 7)
      {
        break;
      }

      ++v10;
      v12 += 32;
      if (!--v9)
      {
        goto LABEL_8;
      }
    }
  }

  if (!v53)
  {
    return 0;
  }

  v44 = *(v52 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v44);
  if (!DefiningOp)
  {
    return 0;
  }

  v24 = *(*(DefiningOp + 48) + 16);
  v25 = v24 == &mlir::detail::TypeIDResolver<mlir::UnrealizedConversionCastOp,void>::id ? DefiningOp : 0;
  if (v24 != &mlir::detail::TypeIDResolver<mlir::UnrealizedConversionCastOp,void>::id)
  {
    return 0;
  }

  v26 = *(DefiningOp + 36);
  v27 = v26 ? DefiningOp - 16 : 0;
  if (v53 != v26)
  {
    return 0;
  }

  if (v26)
  {
    v28 = 0;
    v29 = (v52 + 24);
    while (mlir::detail::OpResultImpl::getNextResultAtOffset(v27, v28) == *v29)
    {
      ++v28;
      v29 += 4;
      if (v26 == v28)
      {
        goto LABEL_35;
      }
    }

    return 0;
  }

LABEL_35:
  if ((*(v25 + 46) & 0x80) != 0)
  {
    v30 = *(v25 + 72);
    v31 = *(v25 + 68);
  }

  else
  {
    v30 = 0;
    v31 = 0;
  }

  v54[0] = v30;
  v54[1] = v31;
  mlir::OperandRange::getTypes(v54, &v48);
  mlir::OperandRange::getTypes(v51, &v45);
  v32 = v50 - v49;
  v33 = v46;
  if (v50 - v49 != v47 - v46)
  {
    return 0;
  }

  if (v50 != v49)
  {
    v34 = v45;
    v35 = v48 + 32 * v49 + 24;
    do
    {
      v36 = *(*v35 + 8);
      if ((*(mlir::detail::OpResultImpl::getNextResultAtOffset(v34, v33) + 8) ^ v36) > 7)
      {
        return 0;
      }

      ++v33;
      v35 += 32;
    }

    while (--v32);
  }

  if ((*(v25 + 46) & 0x80) != 0)
  {
    v14 = *(v25 + 68);
  }

  else
  {
    v14 = 0;
  }

  v15 = *(a3 + 8);
  if (v14 + v15 > *(a3 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, a3 + 16, v14 + v15, 8);
    v15 = *(a3 + 8);
  }

  if (v14)
  {
    v37 = (*a3 + 8 * v15);
    if (v14 >= 0xB)
    {
      OUTLINED_FUNCTION_18_3();
      if (v19 || v39 >= v38)
      {
        OUTLINED_FUNCTION_10_6();
        do
        {
          OUTLINED_FUNCTION_2_6(v41);
        }

        while (!v22);
        v37 = v42;
      }
    }

    do
    {
      OUTLINED_FUNCTION_17_4(v37);
    }

    while (!v22);
LABEL_60:
    LODWORD(v15) = *(a3 + 8);
  }

LABEL_61:
  *(a3 + 8) = v15 + v14;
  return 1;
}

unint64_t mlir::UnrealizedConversionCastOp::getODSOperandIndexAndLength(mlir::UnrealizedConversionCastOp *this, int a2)
{
  if ((*(*this + 46) & 0x80) != 0)
  {
    v2 = *(*this + 68);
  }

  else
  {
    v2 = 0;
  }

  return (v2 * a2) | (v2 << 32);
}

void mlir::UnrealizedConversionCastOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v65 = *MEMORY[0x1E69E9840];
  if ((*(*this + 46) & 0x80) != 0 && *(*this + 17))
  {
    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v6)
    {
      llvm::raw_ostream::write(v4, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v4, v5);
    }

    v7 = *this;
    if ((*(*this + 46) & 0x80) != 0)
    {
      v8 = *(v7 + 17);
      v9 = *(v7 + 9);
    }

    else
    {
      v9 = 0;
      v8 = 0;
    }

    v10 = (*(*a2 + 16))(a2);
    if (v8)
    {
      v11 = v10;
      OUTLINED_FUNCTION_104();
      (*(v12 + 160))(a2);
      v13 = v8 - 1;
      if (v13)
      {
        v14 = v9 + 56;
        do
        {
          v15 = v11[4];
          if (v11[3] - v15 > 1uLL)
          {
            *v15 = 8236;
            v11[4] += 2;
          }

          else
          {
            llvm::raw_ostream::write(v11, ", ", 2uLL);
          }

          v14 += 32;
          OUTLINED_FUNCTION_104();
          (*(v16 + 160))(a2);
          --v13;
        }

        while (v13);
      }
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v6)
    {
      llvm::raw_ostream::write(v17, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v17, v18);
    }

    v19 = (*(*a2 + 16))(a2);
    v20 = v19[4];
    if (v19[3] == v20)
    {
      llvm::raw_ostream::write(v19, ":", 1uLL);
    }

    else
    {
      *v20 = 58;
      ++v19[4];
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v6)
    {
      llvm::raw_ostream::write(v21, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v21, v22);
    }

    v23 = *this;
    if ((*(*this + 46) & 0x80) != 0)
    {
      v24 = *(v23 + 17);
      v25 = *(v23 + 9);
    }

    else
    {
      v25 = 0;
      v24 = 0;
    }

    AttrDictionary = v25;
    v60 = v24;
    mlir::OperandRange::getTypes(&AttrDictionary, &v61);
    v26 = v62;
    v27 = v64;
    if (v62 != v64)
    {
      v28 = v61 + 32 * v62;
      OUTLINED_FUNCTION_104();
      v29 = OUTLINED_FUNCTION_12_4();
      v30(v29);
      if (v26 + 1 != v27)
      {
        v31 = ~v26 + v27;
        v32 = v28 + 56;
        do
        {
          (*(*a2 + 16))(a2);
          OUTLINED_FUNCTION_25_2();
          if (!v35 & v6)
          {
            *v34 = 8236;
            OUTLINED_FUNCTION_24_2(v33);
          }

          else
          {
            llvm::raw_ostream::write(v33, ", ", 2uLL);
          }

          v32 += 32;
          OUTLINED_FUNCTION_104();
          v36 = OUTLINED_FUNCTION_12_4();
          v37(v36);
          --v31;
        }

        while (v31);
      }
    }
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v38, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v38, v39);
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_25_2();
  if (!v35 & v6)
  {
    *v41 = 28532;
    OUTLINED_FUNCTION_24_2(v40);
  }

  else
  {
    llvm::raw_ostream::write(v40, "to", 2uLL);
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v42, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v42, v43);
  }

  OUTLINED_FUNCTION_16_4();
  AttrDictionary = v44;
  v60 = v45;
  mlir::OperandRange::getTypes(&AttrDictionary, &v61);
  v46 = v62;
  v47 = v64;
  if (v62 != v64)
  {
    v48 = v61;
    mlir::detail::OpResultImpl::getNextResultAtOffset(v61, v62);
    OUTLINED_FUNCTION_104();
    v49 = OUTLINED_FUNCTION_12_4();
    v50(v49);
    for (i = v46 + 1; v47 != i; ++i)
    {
      (*(*a2 + 16))(a2);
      OUTLINED_FUNCTION_25_2();
      if (!v35 & v6)
      {
        *v53 = 8236;
        OUTLINED_FUNCTION_24_2(v52);
      }

      else
      {
        llvm::raw_ostream::write(v52, ", ", 2uLL);
      }

      mlir::detail::OpResultImpl::getNextResultAtOffset(v48, i);
      OUTLINED_FUNCTION_104();
      v54 = OUTLINED_FUNCTION_12_4();
      v55(v54);
    }
  }

  v61 = &v63;
  v62 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(*this);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_104();
  (*(v56 + 192))(a2, v57, v58);
  if (v61 != &v63)
  {
    free(v61);
  }
}

uint64_t llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::UnrealizedConversionCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  v17[4] = *MEMORY[0x1E69E9840];
  v9 = *(a2 + 48);
  v8 = *(a2 + 56);
  v15[0] = a2;
  v15[1] = v8;
  v15[2] = v9;
  v16 = 1;
  v10 = *(a2 + 44);
  v11 = v10 & 0x7FFFFF;
  if ((v10 & 0x7FFFFF) != 0)
  {
    v12 = ((a2 + 16 * ((v10 >> 23) & 1) + ((v10 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 40);
  }

  else
  {
    v12 = 0;
    v11 = 0;
  }

  mlir::ValueRange::ValueRange(v17, v12, v11);
  v17[2] = a3;
  v17[3] = a4;
  return mlir::UnrealizedConversionCastOp::fold(v15, v13, a5);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::UnrealizedConversionCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::UnrealizedConversionCastOp::print(&v7, a3);
}

void mlir::BuiltinDialect::initialize()
{
  {
    v0 = llvm::getTypeName<mlir::OpAsmDialectInterface>();
    mlir::detail::TypeIDResolver<mlir::OpAsmDialectInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::ModuleOp,std::optional<llvm::StringRef> &>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "builtin.module";
  *(a2 + 24) = 14;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

void mlir::ModuleOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::detail::ModuleOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::detail::ModuleOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void llvm::DefaultDoCastIfPossible<mlir::DataLayoutSpecInterface,mlir::Attribute const,llvm::CastInfo<mlir::DataLayoutSpecInterface,mlir::Attribute const,void>>::doCastIfPossible()
{
  {
    v0 = llvm::getTypeName<mlir::DataLayoutSpecInterface>();
    mlir::detail::TypeIDResolver<mlir::DataLayoutSpecInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::OneRegion<mlir::ModuleOp>,mlir::OpTrait::ZeroResults<mlir::ModuleOp>,mlir::OpTrait::ZeroSuccessors<mlir::ModuleOp>,mlir::OpTrait::ZeroOperands<mlir::ModuleOp>,mlir::OpTrait::NoRegionArguments<mlir::ModuleOp>,mlir::OpTrait::NoTerminator<mlir::ModuleOp>,mlir::OpTrait::SingleBlock<mlir::ModuleOp>,mlir::OpTrait::OpInvariants<mlir::ModuleOp>,mlir::BytecodeOpInterface::Trait<mlir::ModuleOp>,mlir::OpTrait::AffineScope<mlir::ModuleOp>,mlir::OpTrait::IsIsolatedFromAbove<mlir::ModuleOp>,mlir::OpTrait::SymbolTable<mlir::ModuleOp>,mlir::SymbolOpInterface::Trait<mlir::ModuleOp>,mlir::OpAsmOpInterface::Trait<mlir::ModuleOp>,mlir::RegionKindInterface::Trait<mlir::ModuleOp>,mlir::OpTrait::HasOnlyGraphRegion<mlir::ModuleOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::RegionKindInterface>();
    mlir::detail::TypeIDResolver<mlir::RegionKindInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::SymbolTable,mlir::SymbolOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NoRegionArguments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NoRegionArguments>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NoRegionArguments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NoRegionArguments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NoTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NoTerminator>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NoTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NoTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::RegionKindInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionKindInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::RegionKindInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionKindInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasOnlyGraphRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasOnlyGraphRegion>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasOnlyGraphRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasOnlyGraphRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ResourceBlobManagerDialectInterfaceBase<mlir::DialectResourceBlobHandle<mlir::BuiltinDialect>>::buildResources()
{
  {
    v0 = llvm::getTypeName<mlir::DialectResourceBlobHandle<mlir::BuiltinDialect>>();
    mlir::detail::TypeIDResolver<mlir::DialectResourceBlobHandle<mlir::BuiltinDialect>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::MemRefType::get()
{
  {
    v0 = llvm::getTypeName<mlir::MemRefLayoutAttrInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1_5(v2);
  }
}

void mlir::detail::StorageUserBase<mlir::MemRefType,mlir::BaseMemRefType,mlir::detail::MemRefTypeStorage,mlir::detail::TypeUniquer,mlir::ShapedType::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke()
{
  {
    v0 = llvm::getTypeName<mlir::ShapedType::Trait<mlir::TypeID mlir::TypeID::get<mlir::ShapedType::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ShapedType::Trait<mlir::TypeID mlir::TypeID::get<mlir::ShapedType::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::AttrTypeSubElementHandler<mlir::MemRefLayoutAttrInterface,void>::replace()
{
  {
    v0 = llvm::getTypeName<mlir::MemRefLayoutAttrInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1_5(v2);
  }
}

void mlir::detail::storage_user_base_impl::hasTrait<mlir::ShapedType::Trait,mlir::ValueSemantics>()
{
  {
    v0 = llvm::getTypeName<mlir::ValueSemantics<mlir::TypeID mlir::TypeID::get<mlir::ValueSemantics>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ValueSemantics<mlir::TypeID mlir::TypeID::get<mlir::ValueSemantics>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::RegionKindInterface,mlir::detail::RegionKindInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::RegionKindInterface>();
    mlir::detail::TypeIDResolver<mlir::RegionKindInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::MLIRContext::MLIRContext()
{
  {
    v0 = llvm::getTypeName<mlir::detail::AffineBinaryOpExprStorage>();
    mlir::detail::TypeIDResolver<mlir::detail::AffineBinaryOpExprStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::detail::AffineConstantExprStorage>();
    mlir::detail::TypeIDResolver<mlir::detail::AffineConstantExprStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::detail::AffineDimExprStorage>();
    mlir::detail::TypeIDResolver<mlir::detail::AffineDimExprStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::detail::AffineMapStorage>();
    mlir::detail::TypeIDResolver<mlir::detail::AffineMapStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::detail::IntegerSetStorage>();
    mlir::detail::TypeIDResolver<mlir::detail::IntegerSetStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::OperationName::OperationName(uint64_t a1, unsigned int *a2, const unsigned __int8 *a3, void *a4, void *a5)
{
  v9 = (a1 + 336);
  *a5 = a1 + 336;
  llvm::sys::RWMutexImpl::lock_shared((a1 + 336));
  v10 = llvm::StringMap<std::unique_ptr<mlir::OperationName::Impl>,llvm::MallocAllocator>::find(a1 + 160, a2, a3);
  if (*(a1 + 160) + 8 * *(a1 + 168) == v10)
  {
    llvm::sys::RWMutexImpl::unlock_shared(v9);
    llvm::sys::RWMutexImpl::lock(v9);
    return 1;
  }

  else
  {
    *a4 = *(*v10 + 8);
    llvm::sys::RWMutexImpl::unlock_shared(v9);
    return 0;
  }
}

void mlir::StorageUniquer::get<mlir::detail::AffineMapStorage,unsigned int &,unsigned int &,llvm::ArrayRef<mlir::AffineExpr> &>()
{
  {
    v0 = llvm::getTypeName<mlir::detail::AffineMapStorage>();
    mlir::detail::TypeIDResolver<mlir::detail::AffineMapStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::detail::IntegerSetStorage,unsigned int &,unsigned int &,llvm::ArrayRef<mlir::AffineExpr> &,llvm::ArrayRef<BOOL> &>()
{
  {
    v0 = llvm::getTypeName<mlir::detail::IntegerSetStorage>();
    mlir::detail::TypeIDResolver<mlir::detail::IntegerSetStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

_BYTE *mlir::ThreadLocalCache<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>::get()
{
  v0 = mlir::ThreadLocalCache<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>::getStaticCache(void)::cache();
  *v0 = 1;
  v0[1] = -4096;
  v0[6] = -4096;
  v0[11] = -4096;
  v0[16] = -4096;
  _tlv_atexit(mlir::ThreadLocalCache<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>::CacheType::~CacheType, v0);
  *result = 1;
  return result;
}

uint64_t mlir::Operation::replaceUsesOfWith(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3 && (*(result + 46) & 0x80) != 0)
  {
    v3 = *(result + 68);
    if (v3)
    {
      v4 = *(result + 72);
      v5 = 32 * v3;
      do
      {
        if (v4[3] == a2)
        {
          v6 = v4[1];
          if (v6)
          {
            v7 = *v4;
            *v6 = *v4;
            if (v7)
            {
              *(v7 + 8) = v6;
            }
          }

          v4[3] = a3;
          v8 = *a3;
          *v4 = *a3;
          v4[1] = a3;
          if (v8)
          {
            *(v8 + 8) = v4;
          }

          *a3 = v4;
        }

        v4 += 4;
        v5 -= 32;
      }

      while (v5);
    }
  }

  return result;
}

uint64_t *mlir::Operation::setOperands(uint64_t *result, uint64_t a2, unsigned int a3)
{
  if ((*(result + 46) & 0x80) != 0)
  {
    return mlir::detail::OperandStorage::setOperands((result + 8), result, a2, a3);
  }

  return result;
}

mlir::Operation *mlir::Operation::setOperands(mlir::Operation *result, unsigned int a2, unsigned int a3, uint64_t a4, unsigned int a5)
{
  if ((*(result + 46) & 0x80) != 0)
  {
    return mlir::detail::OperandStorage::setOperands(result + 64, result, a2, a3, a4, a5);
  }

  return result;
}

mlir::Operation *mlir::Operation::insertOperands(mlir::Operation *result, unsigned int a2, uint64_t a3, unsigned int a4)
{
  if ((*(result + 46) & 0x80) != 0)
  {
    return mlir::detail::OperandStorage::setOperands(result + 64, result, a2, 0, a3, a4);
  }

  return result;
}

void mlir::Operation::dropAllReferences(mlir::Operation *this)
{
  v2 = *(this + 11);
  if ((v2 & 0x800000) != 0 && *(this + 17))
  {
    v3 = *(this + 9);
    do
    {
      v4 = v3[1];
      if (v4)
      {
        v5 = *v3;
        *v4 = *v3;
        if (v5)
        {
          *(v5 + 8) = v4;
        }
      }

      OUTLINED_FUNCTION_48_0(v3);
    }

    while (!v6);
    v2 = *(this + 11);
  }

  if ((v2 & 0x7FFFFF) != 0)
  {
    OUTLINED_FUNCTION_26_3();
    v8 = (v7 + 32 * *(this + 10));
    v10 = 24 * v9;
    do
    {
      mlir::Region::dropAllReferences(v8);
      v8 = (v8 + 24);
      v10 -= 24;
    }

    while (v10);
  }

  if (*(this + 10))
  {
    OUTLINED_FUNCTION_26_3();
    do
    {
      v12 = v11[1];
      if (v12)
      {
        v13 = *v11;
        *v12 = *v11;
        if (v13)
        {
          *(v13 + 8) = v12;
        }
      }

      OUTLINED_FUNCTION_48_0(v11);
    }

    while (!v6);
  }
}

uint64_t mlir::Operation::fold(uint64_t a1)
{
  v21[6] = *MEMORY[0x1E69E9840];
  v18 = v21;
  v20 = 6;
  if ((*(a1 + 46) & 0x80) == 0)
  {
    v19 = 0;
    goto LABEL_13;
  }

  v2 = *(a1 + 68);
  if (v2 <= 6)
  {
    if (v2)
    {
      bzero(v21, 8 * v2);
    }

    v19 = v2;
  }

  else
  {
    v19 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v18, v21, v2, 8);
    bzero(v18, 8 * v2);
    v3 = *(a1 + 44);
    v19 = v2;
    if ((v3 & 0x800000) == 0)
    {
      goto LABEL_13;
    }
  }

  v4 = *(a1 + 68);
  if (v4)
  {
    v5 = 0;
    v6 = 8 * v4;
    v7 = 24;
    do
    {
      v8 = *(*(a1 + 72) + v7);
      v16 = (v18 + v5);
      v17 = v8;
      DefiningOp = mlir::Value::getDefiningOp(&v17);
      if (DefiningOp)
      {
        mlir::detail::constant_op_binder<mlir::Attribute>::match(&v16, DefiningOp);
      }

      v7 += 32;
      v5 += 8;
    }

    while (v6 != v5);
  }

LABEL_13:
  OUTLINED_FUNCTION_57_0();
  if (v10())
  {
    v11 = 1;
    goto LABEL_22;
  }

  v12 = *(a1 + 48);
  if (*(v12 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v17 = *(v12 + 8);
    Values = mlir::SparseElementsAttr::getValues(&v17);
    if (!Values)
    {
      goto LABEL_21;
    }
  }

  else
  {
    Values = *(v12 + 24);
    if (!Values)
    {
      goto LABEL_21;
    }
  }

  if (mlir::Dialect::getRegisteredInterface<mlir::DialectFoldInterface>(Values))
  {
    mlir::Dialect::getRegisteredInterface<mlir::DialectFoldInterface>(Values);
    OUTLINED_FUNCTION_57_0();
    v11 = v14();
    goto LABEL_22;
  }

LABEL_21:
  v11 = 0;
LABEL_22:
  if (v18 != v21)
  {
    free(v18);
  }

  return v11;
}

uint64_t mlir::Operation::clone(uint64_t a1, uint64_t a2, char a3)
{
  v81 = *MEMORY[0x1E69E9840];
  v67 = v78;
  v76 = v78;
  v77 = 0x800000000;
  v68 = v75;
  v73 = v75;
  v74 = 0x200000000;
  if ((a3 & 2) != 0 && (*(a1 + 46) & 0x80) != 0)
  {
    v6 = *(a1 + 68);
    if (v6 < 9 || (llvm::SmallVectorBase<unsigned int>::grow_pod(&v76, v78, v6, 8), (*(a1 + 46) & 0x80) != 0))
    {
      v7 = *(a1 + 68);
      if (v7)
      {
        v8 = 0;
        v9 = *(a1 + 72);
        do
        {
          v10 = *(v9 + 32 * v8 + 24);
          v11 = *(a2 + 16);
          if (v11)
          {
            v12 = *a2;
            v13 = 0x9DDFEA08EB382D69 * ((8 * *(v9 + 32 * v8 + 24) - 0xAE502812AA7333) ^ HIDWORD(*(v9 + 32 * v8 + 24)));
            v14 = 0x9DDFEA08EB382D69 * (HIDWORD(v10) ^ (v13 >> 47) ^ v13);
            v15 = (-348639895 * ((v14 >> 47) ^ v14)) & (v11 - 1);
            v16 = *(*a2 + 16 * v15);
            if (v16 == v10)
            {
LABEL_9:
              if (v15 != v11)
              {
                v10 = *(v12 + 16 * v15 + 8);
              }
            }

            else
            {
              while (v16 != -4096)
              {
                OUTLINED_FUNCTION_41_1();
                v16 = *(v12 + v18);
                if (v16 == v10)
                {
                  goto LABEL_9;
                }
              }
            }
          }

          v17 = v77;
          if (v77 >= HIDWORD(v77))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(&v76, v78, v77 + 1, 8);
            v17 = v77;
          }

          *(v76 + v17) = v10;
          LODWORD(v77) = v77 + 1;
          ++v8;
        }

        while (v8 != v7);
      }
    }
  }

  v19 = *(a1 + 40);
  if (HIDWORD(v74) < v19)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v73, v75, v19, 8);
  }

  mlir::SuccessorRange::SuccessorRange(&v69, a1);
  v20 = v70;
  if (v70)
  {
    v21 = 0;
    v22 = v69;
    do
    {
      v23 = *(v22 + 32 * v21 + 24);
      v24 = *(a2 + 40);
      if (v24)
      {
        v25 = *(a2 + 24);
        v26 = ((v23 >> 4) ^ (v23 >> 9)) & (v24 - 1);
        v27 = *(v25 + 16 * v26);
        if (v27 == v23)
        {
LABEL_24:
          if (v26 != v24)
          {
            v23 = *(v25 + 16 * v26 + 8);
          }
        }

        else
        {
          while (v27 != -4096)
          {
            OUTLINED_FUNCTION_41_1();
            v27 = *(v25 + v29);
            if (v27 == v23)
            {
              goto LABEL_24;
            }
          }
        }
      }

      v28 = v74;
      if (v74 >= HIDWORD(v74))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v73, v75, v74 + 1, 8);
        v28 = v74;
      }

      *(v73 + v28) = v23;
      OUTLINED_FUNCTION_6_5();
      ++v21;
    }

    while (v21 != v20);
  }

  v30 = *(a1 + 24);
  v31 = *(a1 + 48);
  v32 = *(a1 + 36);
  if (v32)
  {
    v33 = a1 - 16;
  }

  else
  {
    v33 = 0;
  }

  v79 = v33;
  v80 = v32;
  mlir::OperandRange::getTypes(&v79, &v69);
  NextResultAtOffset = v69;
  v35 = v70;
  v36 = v71;
  if (v70)
  {
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v69, v70);
  }

  mlir::ValueRange::ValueRange(&v79, NextResultAtOffset, v36 - v35);
  mlir::TypeRange::TypeRange(v72, v79, v80);
  mlir::ValueRange::ValueRange(&v69, v76, v77);
  v37 = *(a1 + 56);
  if (HIBYTE(*(a1 + 44)))
  {
    v38 = a1 + 64 + 16 * ((*(a1 + 44) >> 23) & 1);
  }

  else
  {
    v38 = 0;
  }

  mlir::BlockRange::BlockRange(&v79, v73, v74);
  v39 = mlir::Operation::create(v30, v31, v72[0], v72[1], v69, v70, v37, v38, v79, v80, *(a1 + 44) & 0x7FFFFF);
  v69 = a1;
  *llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::Operation *>>,mlir::Operation *,mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::Operation *>>::operator[](a2 + 48, &v69) = v39;
  if (a3)
  {
    v40 = *(a1 + 44);
    if ((v40 & 0x7FFFFF) != 0)
    {
      v41 = 0;
      do
      {
        mlir::Region::cloneInto((((a1 + 64 + 16 * ((v40 >> 23) & 1) + ((v40 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a1 + 40) + 24 * v41), (((v39 + 64 + 16 * ((*(v39 + 44) >> 23) & 1) + ((*(v39 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v39 + 40) + 24 * v41), a2);
        ++v41;
        v40 = *(a1 + 44);
      }

      while (v41 != (v40 & 0x7FFFFF));
    }
  }

  v42 = *(a1 + 36);
  if (v42)
  {
    v69 = a1 - 16;
    *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::operator[](a2, &v69) = v39 - 16;
    if (v42 != 1)
    {
      *OUTLINED_FUNCTION_25_3(a1 - 32, v47, v52, v57, v62, v78, v75, v69) = v39 - 32;
      if (v42 != 2)
      {
        *OUTLINED_FUNCTION_25_3(a1 - 48, v48, v53, v58, v63, v67, v68, v69) = v39 - 48;
        if (v42 != 3)
        {
          *OUTLINED_FUNCTION_25_3(a1 - 64, v49, v54, v59, v64, v67, v68, v69) = v39 - 64;
          if (v42 != 4)
          {
            *OUTLINED_FUNCTION_25_3(a1 - 80, v50, v55, v60, v65, v67, v68, v69) = v39 - 80;
            if (v42 != 5)
            {
              *OUTLINED_FUNCTION_25_3(a1 - 96, v51, v56, v61, v66, v67, v68, v69) = v39 - 96;
              if (v42 != 6)
              {
                v43 = a1 - 120;
                v44 = v39 - 120;
                v45 = v42 - 6;
                do
                {
                  v69 = v43;
                  *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::operator[](a2, &v69) = v44;
                  v43 -= 24;
                  v44 -= 24;
                  --v45;
                }

                while (v45);
              }
            }
          }
        }
      }
    }
  }

  if (v73 != v68)
  {
    free(v73);
  }

  if (v76 != v67)
  {
    free(v76);
  }

  return v39;
}

void mlir::Operation::cloneWithoutRegions(mlir::Operation *this)
{
  OUTLINED_FUNCTION_27_3();
  mlir::Operation::clone(v1, v2, 2);
  OUTLINED_FUNCTION_39_0(v3, v4);
}

void mlir::Operation::clone()
{
  OUTLINED_FUNCTION_27_3();
  mlir::Operation::clone(v0, v1, v2);
  OUTLINED_FUNCTION_39_0(v3, v4);
}

BOOL mlir::OpTrait::impl::foldCommutative(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v25[0] = a2;
  v25[1] = a3;
  if ((*(a1 + 46) & 0x80) == 0)
  {
    return 0;
  }

  v3 = *(a1 + 68);
  if (v3 < 2)
  {
    return 0;
  }

  v5 = 0;
  v6 = *(a1 + 72);
  v24 = v6;
  v7 = (v6 + 32 * v3);
  v8 = 32 * v3;
  v9 = v8;
  while (!*(a2 + (v5 >> 2)))
  {
    v5 += 32;
    v9 -= 32;
    if (!v9)
    {
      v10 = v7;
      return v10 != v7;
    }
  }

  v26[0] = v25;
  v26[1] = &v24;
  v10 = (v6 + v5);
  if (v9)
  {
    v11 = 0;
    for (i = v5; !*(a2 + (i >> 2)); i += 32)
    {
      v11 += 32;
      if (v9 == v11)
      {
        return v10 != v7;
      }
    }

    v13 = v8 - 32;
    v14 = v9 - v11;
    v15 = (v6 + v5 + v11);
    do
    {
      v14 -= 32;
      if (!v14)
      {
        v7 = v15;
        return v10 != v7;
      }

      v7 -= 4;
      v16 = *(a2 + (v13 >> 2));
      v13 -= 32;
    }

    while (v16);
    v17 = (v14 >> 5) + 1;
    if (v14 >> 5 < 3)
    {
      v23 = 0;
      v18 = 0;
    }

    else
    {
      if (v17 >= 0x3FFFFFFFFFFFFFFLL)
      {
        v18 = 0x3FFFFFFFFFFFFFFLL;
      }

      else
      {
        v18 = (v14 >> 5) + 1;
      }

      v19 = MEMORY[0x1E69E5398];
      while (1)
      {
        v20 = operator new(32 * v18, v19);
        if (v20)
        {
          break;
        }

        v21 = v18 >> 1;
        v22 = v18 > 1;
        v18 >>= 1;
        if (!v22)
        {
          v23 = 0;
          v18 = v21;
          goto LABEL_27;
        }
      }

      v23 = v20;
    }

LABEL_27:
    v7 = std::__stable_partition_impl<std::_ClassicAlgPolicy,mlir::OpTrait::impl::foldCommutative(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)::$_0 &,mlir::OpOperand *,long,std::pair<mlir::OpOperand *,long>>(v15, v7, v26, v17, v23, v18);
    if (v23)
    {
      operator delete(v23);
    }
  }

  return v10 != v7;
}

BOOL mlir::OpTrait::impl::verifyZeroOperands(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  v55 = *MEMORY[0x1E69E9840];
  if ((*(this + 46) & 0x80) == 0 || !*(this + 17))
  {
    return 1;
  }

  LOWORD(v40) = 257;
  mlir::Operation::emitOpError(this, &v36, &v44);
  if (v44)
  {
    OUTLINED_FUNCTION_37_0();
    v42 = "requires zero operands";
    v43 = 22;
    OUTLINED_FUNCTION_4_5();
    if (v3)
    {
      OUTLINED_FUNCTION_5_3();
      if (v32 <= v33 && (v31 & 1) != 0)
      {
        OUTLINED_FUNCTION_3_1(v47, &v44);
        v2 = v47[0];
      }

      else
      {
        OUTLINED_FUNCTION_3_1(v47, &v44);
        OUTLINED_FUNCTION_19_3();
      }
    }

    OUTLINED_FUNCTION_0_3(v2);
    OUTLINED_FUNCTION_6_5();
  }

  v4 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v44);
  if (v44)
  {
    mlir::InFlightDiagnostic::report(&v44);
  }

  OUTLINED_FUNCTION_49_1();
  if (v13)
  {
    v14 = OUTLINED_FUNCTION_32_3(v5, v6, v7, v8, v9, v10, v11, v12, v34, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47[0], v47[1], v47[2], v47[3], v47[4], v47[5], v47[6], v47[7], v47[8], v47[9], v47[10], v47[11], v47[12], v47[13], __p, v49, v50, v51, v52, v53, v54);
    if (!v13)
    {
      free(v14);
    }

    v22 = v51;
    if (v51)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v13)
      {
        do
        {
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v23 - 1);
        }

        while (v23 != v22);
        v24 = v51;
      }

      v52 = v22;
      operator delete(v24);
    }

    v25 = __p;
    if (__p)
    {
      v26 = v49;
      v27 = OUTLINED_FUNCTION_16_5();
      if (!v13)
      {
        do
        {
          v28 = OUTLINED_FUNCTION_17_5();
          if (v28)
          {
            operator delete[](v28);
          }
        }

        while (v26 != v25);
        v27 = __p;
      }

      v49 = v25;
      operator delete(v27);
    }

    v29 = OUTLINED_FUNCTION_12_5(v14, v15, v16, v17, v18, v19, v20, v21, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47[0]);
    if (!v13)
    {
      free(v29);
    }
  }

  return v4;
}

BOOL mlir::OpTrait::impl::verifyNOperands(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  v2 = a2;
  v116 = *MEMORY[0x1E69E9840];
  if ((*(this + 46) & 0x80) != 0)
  {
    v4 = *(this + 17);
  }

  else
  {
    v4 = 0;
  }

  if (v4 == a2)
  {
    return 1;
  }

  OUTLINED_FUNCTION_18_4();
  mlir::Operation::emitOpError(this, v6, v7);
  if (v92)
  {
    OUTLINED_FUNCTION_37_0();
    v87 = "expected ";
    v90 = 9;
    OUTLINED_FUNCTION_4_5();
    if (v9)
    {
      OUTLINED_FUNCTION_5_3();
      if (v59 <= v60 && (v58 & 1) != 0)
      {
        OUTLINED_FUNCTION_7_4(v50, v51, v52, v53, v54, v55, v56, v57, v73, v75, v77, v79, v81, v83);
        v8 = v95;
      }

      else
      {
        OUTLINED_FUNCTION_7_4(v50, v51, v52, v53, v54, v55, v56, v57, v73, v75, v77, v79, v81, v83);
        OUTLINED_FUNCTION_19_3();
      }
    }

    OUTLINED_FUNCTION_0_3(v8);
    OUTLINED_FUNCTION_13_6();
    if (v10)
    {
      OUTLINED_FUNCTION_43_1();
      v88 = v2;
      OUTLINED_FUNCTION_10_7();
      if (v9)
      {
        OUTLINED_FUNCTION_13_4();
        if (v67 <= v68 && (v66 & 1) != 0)
        {
          OUTLINED_FUNCTION_5_5(v65, v73, v75, v77, v79, v81, v83, v85, v2, 9, v92, v93, v94, v95, v96);
          OUTLINED_FUNCTION_52_0();
        }

        else
        {
          OUTLINED_FUNCTION_5_5(v65, v73, v75, v77, v79, v81, v83, v85, v2, 9, v92, v93, v94, v95, v96);
          OUTLINED_FUNCTION_23_2();
        }
      }

      OUTLINED_FUNCTION_3_6(v11, v12, v13, v14, v15, v16, v17, v18, v73, v75, v77, v79, v81, v83, v85, v88, v90, v92, v93, v94, v95, v96);
      LODWORD(v96) = v19 + 1;
      if (v92)
      {
        LODWORD(v85) = 3;
        v87 = " operands, but found ";
        v90 = 21;
        OUTLINED_FUNCTION_10_7();
        if (v9)
        {
          OUTLINED_FUNCTION_13_4();
          if (v71 <= v72 && (v70 & 1) != 0)
          {
            OUTLINED_FUNCTION_5_5(v69, v73, v75, v77, v79, v81, v83, v85, " operands, but found ", 21, v92, v93, v94, v95, v96);
            OUTLINED_FUNCTION_52_0();
          }

          else
          {
            OUTLINED_FUNCTION_5_5(v69, v73, v75, v77, v79, v81, v83, v85, " operands, but found ", 21, v92, v93, v94, v95, v96);
            OUTLINED_FUNCTION_23_2();
          }
        }

        OUTLINED_FUNCTION_2_7((v20 + 24 * v96), *v21);
      }
    }
  }

  if (v92)
  {
    OUTLINED_FUNCTION_43_1();
    v87 = v22;
    OUTLINED_FUNCTION_4_5();
    if (v9)
    {
      OUTLINED_FUNCTION_34_3();
      if (v63 <= v64 && (v62 & 1) != 0)
      {
        OUTLINED_FUNCTION_3_1(v61 + 24, &v92);
        v23 = v95;
      }

      else
      {
        OUTLINED_FUNCTION_3_1(v61 + 24, &v92);
        OUTLINED_FUNCTION_19_3();
      }
    }

    OUTLINED_FUNCTION_0_3(v23);
    OUTLINED_FUNCTION_6_5();
  }

  v5 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v92);
  if (v92)
  {
    mlir::InFlightDiagnostic::report(&v92);
  }

  OUTLINED_FUNCTION_49_1();
  if (v32)
  {
    v33 = OUTLINED_FUNCTION_32_3(v24, v25, v26, v27, v28, v29, v30, v31, v73, v75, v77, v79, v81, v83, v85, v87, v90, v92, v93, v94, v95, v96, v97, v98, v99, v100, v101, v102, v103, v104, v105, v106, v107, v108, __p, v110, v111, v112, v113, v114, v115);
    if (!v32)
    {
      free(v33);
    }

    v41 = v112;
    if (v112)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v32)
      {
        do
        {
          v42 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v42 - 1);
        }

        while (v42 != v41);
        v43 = v112;
      }

      v113 = v41;
      operator delete(v43);
    }

    v44 = __p;
    if (__p)
    {
      v45 = v110;
      v46 = OUTLINED_FUNCTION_16_5();
      if (!v32)
      {
        do
        {
          v47 = OUTLINED_FUNCTION_17_5();
          if (v47)
          {
            operator delete[](v47);
          }
        }

        while (v45 != v44);
        v46 = __p;
      }

      v110 = v44;
      operator delete(v46);
    }

    v48 = OUTLINED_FUNCTION_12_5(v33, v34, v35, v36, v37, v38, v39, v40, v74, v76, v78, v80, v82, v84, v86, v89, v91, v92, v93, v94, v95);
    if (!v32)
    {
      free(v48);
    }
  }

  return v5;
}

BOOL mlir::OpTrait::impl::verifyAtLeastNOperands(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  v2 = a2;
  v116 = *MEMORY[0x1E69E9840];
  if ((*(this + 46) & 0x80) != 0)
  {
    v4 = *(this + 17);
  }

  else
  {
    v4 = 0;
  }

  if (v4 >= a2)
  {
    return 1;
  }

  OUTLINED_FUNCTION_18_4();
  mlir::Operation::emitOpError(this, v5, v6);
  if (v92)
  {
    OUTLINED_FUNCTION_37_0();
    v87 = "expected ";
    v90 = 9;
    OUTLINED_FUNCTION_4_5();
    if (v8)
    {
      OUTLINED_FUNCTION_5_3();
      if (v59 <= v60 && (v58 & 1) != 0)
      {
        OUTLINED_FUNCTION_7_4(v50, v51, v52, v53, v54, v55, v56, v57, v73, v75, v77, v79, v81, v83);
        v7 = v95;
      }

      else
      {
        OUTLINED_FUNCTION_7_4(v50, v51, v52, v53, v54, v55, v56, v57, v73, v75, v77, v79, v81, v83);
        OUTLINED_FUNCTION_19_3();
      }
    }

    OUTLINED_FUNCTION_0_3(v7);
    OUTLINED_FUNCTION_13_6();
    if (v9)
    {
      OUTLINED_FUNCTION_43_1();
      v88 = v2;
      OUTLINED_FUNCTION_10_7();
      if (v8)
      {
        OUTLINED_FUNCTION_13_4();
        if (v67 <= v68 && (v66 & 1) != 0)
        {
          OUTLINED_FUNCTION_5_5(v65, v73, v75, v77, v79, v81, v83, v85, v2, 9, v92, v93, v94, v95, v96);
          OUTLINED_FUNCTION_52_0();
        }

        else
        {
          OUTLINED_FUNCTION_5_5(v65, v73, v75, v77, v79, v81, v83, v85, v2, 9, v92, v93, v94, v95, v96);
          OUTLINED_FUNCTION_23_2();
        }
      }

      OUTLINED_FUNCTION_3_6(v10, v11, v12, v13, v14, v15, v16, v17, v73, v75, v77, v79, v81, v83, v85, v88, v90, v92, v93, v94, v95, v96);
      LODWORD(v96) = v18 + 1;
      if (v92)
      {
        LODWORD(v85) = 3;
        v87 = " or more operands, but found ";
        v90 = 29;
        OUTLINED_FUNCTION_10_7();
        if (v8)
        {
          OUTLINED_FUNCTION_13_4();
          if (v71 <= v72 && (v70 & 1) != 0)
          {
            OUTLINED_FUNCTION_5_5(v69, v73, v75, v77, v79, v81, v83, v85, " or more operands, but found ", 29, v92, v93, v94, v95, v96);
            OUTLINED_FUNCTION_52_0();
          }

          else
          {
            OUTLINED_FUNCTION_5_5(v69, v73, v75, v77, v79, v81, v83, v85, " or more operands, but found ", 29, v92, v93, v94, v95, v96);
            OUTLINED_FUNCTION_23_2();
          }
        }

        OUTLINED_FUNCTION_2_7((v19 + 24 * v96), *v20);
      }
    }
  }

  if (v92)
  {
    OUTLINED_FUNCTION_43_1();
    v87 = v21;
    OUTLINED_FUNCTION_4_5();
    if (v8)
    {
      OUTLINED_FUNCTION_34_3();
      if (v63 <= v64 && (v62 & 1) != 0)
      {
        OUTLINED_FUNCTION_3_1(v61 + 24, &v92);
        v22 = v95;
      }

      else
      {
        OUTLINED_FUNCTION_3_1(v61 + 24, &v92);
        OUTLINED_FUNCTION_19_3();
      }
    }

    OUTLINED_FUNCTION_0_3(v22);
    OUTLINED_FUNCTION_6_5();
  }

  v23 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v92);
  if (v92)
  {
    mlir::InFlightDiagnostic::report(&v92);
  }

  OUTLINED_FUNCTION_49_1();
  if (v32)
  {
    v33 = OUTLINED_FUNCTION_32_3(v24, v25, v26, v27, v28, v29, v30, v31, v73, v75, v77, v79, v81, v83, v85, v87, v90, v92, v93, v94, v95, v96, v97, v98, v99, v100, v101, v102, v103, v104, v105, v106, v107, v108, __p, v110, v111, v112, v113, v114, v115);
    if (!v32)
    {
      free(v33);
    }

    v41 = v112;
    if (v112)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v32)
      {
        do
        {
          v42 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v42 - 1);
        }

        while (v42 != v41);
        v43 = v112;
      }

      v113 = v41;
      operator delete(v43);
    }

    v44 = __p;
    if (__p)
    {
      v45 = v110;
      v46 = OUTLINED_FUNCTION_16_5();
      if (!v32)
      {
        do
        {
          v47 = OUTLINED_FUNCTION_17_5();
          if (v47)
          {
            operator delete[](v47);
          }
        }

        while (v45 != v44);
        v46 = __p;
      }

      v110 = v44;
      operator delete(v46);
    }

    v48 = OUTLINED_FUNCTION_12_5(v33, v34, v35, v36, v37, v38, v39, v40, v74, v76, v78, v80, v82, v84, v86, v89, v91, v92, v93, v94, v95);
    if (!v32)
    {
      free(v48);
    }
  }

  return v23;
}

BOOL mlir::OpTrait::impl::verifySameTypeOperands(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  v36 = *MEMORY[0x1E69E9840];
  if ((*(this + 46) & 0x80) == 0)
  {
    return 1;
  }

  v3 = *(this + 17);
  if (v3 < 2)
  {
    return 1;
  }

  v4 = *(*(*(this + 9) + 24) + 8);
  v22[0] = *(this + 9);
  v22[1] = v3;
  mlir::OperandRange::getTypes(v22, &v26);
  if ((v27 + 1) == v28)
  {
    return 1;
  }

  v5 = v28 + ~v27;
  for (i = v26 + 32 * v27 + 56; (*(*i + 8) ^ v4) < 8; i += 32)
  {
    if (!--v5)
    {
      return 1;
    }
  }

  v23 = 257;
  mlir::Operation::emitOpError(this, v22, &v26);
  if (v26)
  {
    OUTLINED_FUNCTION_37_0();
    v24 = "requires all operands to have the same type";
    v25 = 43;
    OUTLINED_FUNCTION_4_5();
    if (v10)
    {
      OUTLINED_FUNCTION_5_3();
      if (v20 <= v21 && (v19 & 1) != 0)
      {
        OUTLINED_FUNCTION_21_3();
        v9 = v28;
      }

      else
      {
        OUTLINED_FUNCTION_21_3();
        OUTLINED_FUNCTION_19_3();
      }
    }

    OUTLINED_FUNCTION_0_3(v9);
    OUTLINED_FUNCTION_6_5();
  }

  v7 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v26);
  if (v26)
  {
    mlir::InFlightDiagnostic::report(&v26);
  }

  if (v35)
  {
    if (v34 != &v35)
    {
      free(v34);
    }

    v11 = v32;
    if (v32)
    {
      OUTLINED_FUNCTION_47_1();
      if (!v14)
      {
        do
        {
          v12 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v12 - 1);
        }

        while (v12 != v11);
        v13 = v32;
      }

      v33 = v11;
      operator delete(v13);
    }

    v15 = __p;
    if (__p)
    {
      v16 = v31;
      v17 = __p;
      if (v31 != __p)
      {
        do
        {
          v18 = OUTLINED_FUNCTION_35_1();
          if (v18)
          {
            operator delete[](v18);
          }
        }

        while (v16 != v15);
        v17 = __p;
      }

      v31 = v15;
      operator delete(v17);
    }

    if (v28 != &v29)
    {
      free(v28);
    }
  }

  return v7;
}

BOOL mlir::OpTrait::impl::verifySameOperandsShape(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  v34 = *MEMORY[0x1E69E9840];
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(this, 1))
  {
    return 0;
  }

  if ((*(this + 46) & 0x80) != 0)
  {
    v3 = *(this + 9);
    v4 = *(this + 17);
  }

  else
  {
    OUTLINED_FUNCTION_90();
  }

  v16 = v3;
  v17 = v4;
  mlir::OperandRange::getTypes(&v16, &v19);
  mlir::ValueRange::ValueRange(&v16, v19 + 32 * v20, v21 - v20);
  mlir::TypeRange::TypeRange(&v31, v16, v17);
  if (mlir::verifyCompatibleShapes(v31, v32))
  {
    return 1;
  }

  v18 = 257;
  mlir::Operation::emitOpError(this, &v16, &v19);
  if (v19)
  {
    LODWORD(v31) = 3;
    v32 = "requires the same shape for all operands";
    v33 = 40;
    v7 = v21;
    if (v22 >= v23)
    {
      OUTLINED_FUNCTION_5_3();
      OUTLINED_FUNCTION_3_1(&v21, &v19);
      v7 = v21;
    }

    OUTLINED_FUNCTION_0_3(v7);
    ++v22;
  }

  v5 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v19);
  if (v19)
  {
    mlir::InFlightDiagnostic::report(&v19);
  }

  if (v30 == 1)
  {
    if (v29 != &v30)
    {
      free(v29);
    }

    v8 = v27;
    if (v27)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v11)
      {
        do
        {
          v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v9 - 1);
        }

        while (v9 != v8);
        v10 = v27;
      }

      v28 = v8;
      operator delete(v10);
    }

    v12 = __p;
    if (__p)
    {
      v13 = v26;
      v14 = OUTLINED_FUNCTION_16_5();
      if (!v11)
      {
        do
        {
          v15 = OUTLINED_FUNCTION_17_5();
          if (v15)
          {
            operator delete[](v15);
          }
        }

        while (v13 != v12);
        v14 = __p;
      }

      v26 = v12;
      operator delete(v14);
    }

    if (v21 != &v24)
    {
      free(v21);
    }
  }

  return v5;
}

BOOL mlir::OpTrait::impl::verifySameOperandsAndResultShape(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  v83[8] = *MEMORY[0x1E69E9840];
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(this, 1) || !mlir::OpTrait::impl::verifyAtLeastNResults(this, 1))
  {
    return 0;
  }

  if ((*(this + 46) & 0x80) != 0)
  {
    v3 = *(this + 9);
    v4 = *(this + 17);
  }

  else
  {
    OUTLINED_FUNCTION_90();
  }

  v81 = v3;
  v82 = v4;
  mlir::OperandRange::getTypes(&v81, &__src);
  v81 = v83;
  v82 = 0x800000000;
  v5 = __src;
  v6 = v72;
  v7 = v74;
  v8 = v74 - v72;
  if (v74 - v72 < 9)
  {
    v9 = 0;
    v10 = 0;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v81, v83, v74 - v72, 8);
    v9 = v82;
    v10 = v82;
  }

  if (v7 != v6)
  {
    v13 = &v81[8 * v9];
    v14 = &v5[32 * v6 + 24];
    v15 = v8;
    do
    {
      v16 = *v14;
      v14 += 32;
      *v13++ = *(v16 + 8) & 0xFFFFFFFFFFFFFFF8;
      --v15;
    }

    while (v15);
    v10 = v82;
  }

  LODWORD(v82) = v10 + v8;
  v17 = *(this + 9);
  v18 = this - 16;
  if (!v17)
  {
    v18 = 0;
  }

  __src = v18;
  v72 = v17;
  mlir::OperandRange::getTypes(&__src, &v63);
  v19 = v63;
  v20 = v64;
  v21 = v66;
  __src = &v73;
  v72 = 0x400000000;
  v22 = v66 - v64;
  if ((v66 - v64) < 5)
  {
    v23 = 0;
    v25 = 0;
    v24 = &v73;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&__src, &v73, v66 - v64, 8);
    v23 = v72;
    v24 = __src;
    v25 = v72;
  }

  if (v21 != v20)
  {
    v26 = &v24[v23];
    do
    {
      *v26++ = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v19, v20++) + 8) & 0xFFFFFFFFFFFFFFF8;
    }

    while (v21 != v20);
    v25 = v72;
    v24 = __src;
  }

  v27 = (v25 + v22);
  LODWORD(v72) = v27;
  v28 = v82;
  if (v82 + v27 > HIDWORD(v82))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v81, v83, v82 + v27, 8);
    v28 = v82;
  }

  if (v27)
  {
    memcpy(&v81[8 * v28], v24, 8 * v27);
    v28 = v82;
  }

  v29 = v28 + v27;
  LODWORD(v82) = v29;
  if (__src != &v73)
  {
    free(__src);
    v29 = v82;
  }

  mlir::ValueRange::ValueRange(&__src, v81, v29);
  if (mlir::verifyCompatibleShapes(__src, v72))
  {
    v11 = 1;
  }

  else
  {
    OUTLINED_FUNCTION_18_4();
    mlir::Operation::emitOpError(this, v30, v31);
    if (__src)
    {
      OUTLINED_FUNCTION_37_0();
      v69 = "requires the same shape for all operands and results";
      v70 = 52;
      OUTLINED_FUNCTION_4_5();
      if (v33)
      {
        OUTLINED_FUNCTION_5_3();
        if (v60 <= v61 && (v59 & 1) != 0)
        {
          OUTLINED_FUNCTION_7_4(v51, v52, v53, v54, v55, v56, v57, v58, v62, v63, v64, v65, v66, v67);
          v32 = v74;
        }

        else
        {
          OUTLINED_FUNCTION_7_4(v51, v52, v53, v54, v55, v56, v57, v58, v62, v63, v64, v65, v66, v67);
          OUTLINED_FUNCTION_19_3();
        }
      }

      OUTLINED_FUNCTION_0_3(v32);
      OUTLINED_FUNCTION_6_5();
    }

    v11 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&__src);
    if (__src)
    {
      mlir::InFlightDiagnostic::report(&__src);
    }

    OUTLINED_FUNCTION_49_1();
    if (v41)
    {
      v42 = v79;
      if (v79 != &v80)
      {
        free(v79);
      }

      v43 = v77;
      if (v77)
      {
        OUTLINED_FUNCTION_47_1();
        if (!v41)
        {
          do
          {
            v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v44 - 1);
          }

          while (v44 != v43);
          v45 = v77;
        }

        v78 = v43;
        operator delete(v45);
      }

      v46 = __p;
      if (__p)
      {
        v47 = v76;
        v48 = __p;
        if (v76 != __p)
        {
          do
          {
            v49 = OUTLINED_FUNCTION_35_1();
            if (v49)
            {
              operator delete[](v49);
            }
          }

          while (v47 != v46);
          v48 = __p;
        }

        v76 = v46;
        operator delete(v48);
      }

      v50 = OUTLINED_FUNCTION_12_5(v42, v34, v35, v36, v37, v38, v39, v40, v62, v63, v64, v65, v66, v67, v68, v69, v70, __src, v72, v73, v74);
      if (!v41)
      {
        free(v50);
      }
    }
  }

  if (v81 != v83)
  {
    free(v81);
  }

  return v11;
}

BOOL mlir::OpTrait::impl::verifySameOperandsElementType(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  v33 = *MEMORY[0x1E69E9840];
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(this, 1))
  {
    return 0;
  }

  ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(*(this + 9) + 24));
  if ((*(this + 46) & 0x80) != 0)
  {
    v4 = *(this + 17);
    if (v4 == 1)
    {
      return 1;
    }

    v5 = *(this + 9);
  }

  else
  {
    OUTLINED_FUNCTION_90();
  }

  v6 = (v5 + 56);
  v7 = v4 - 1;
  while (mlir::getElementTypeOrSelf(*v6) == ElementTypeOrSelf)
  {
    v6 += 4;
    if (!--v7)
    {
      return 1;
    }
  }

  OUTLINED_FUNCTION_20_3("requires the same element type for all operands", v18, v19, v20, v21, v22, v23, v24[0]);
  v8 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v24);
  if (*v24)
  {
    mlir::InFlightDiagnostic::report(v24);
  }

  if (v32)
  {
    if (v31 != &v32)
    {
      free(v31);
    }

    v10 = v29;
    if (v29)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v13)
      {
        do
        {
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v11 - 1);
        }

        while (v11 != v10);
        v12 = v29;
      }

      v30 = v10;
      operator delete(v12);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v28;
      v16 = __p;
      if (v28 != __p)
      {
        do
        {
          v17 = OUTLINED_FUNCTION_35_1();
          if (v17)
          {
            operator delete[](v17);
          }
        }

        while (v15 != v14);
        v16 = __p;
      }

      v28 = v14;
      operator delete(v16);
    }

    if (v25 != &v26)
    {
      free(v25);
    }
  }

  return v8;
}

BOOL mlir::OpTrait::impl::verifySameOperandsAndResultElementType(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  v43 = *MEMORY[0x1E69E9840];
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(this, 1) || !mlir::OpTrait::impl::verifyAtLeastNResults(this, 1))
  {
    return 0;
  }

  v3 = this - 16;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(this - 16);
  v5 = *(this + 9);
  if (!v5)
  {
    v3 = 0;
  }

  if (v5 != 1)
  {
    v6 = 1;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v3, v6);
      if (mlir::getElementTypeOrSelf(NextResultAtOffset) != ElementTypeOrSelf)
      {
        break;
      }

      if (v5 == ++v6)
      {
        goto LABEL_9;
      }
    }

    OUTLINED_FUNCTION_20_3("requires the same element type for all operands and results", v28, v29, v30, v31, v32, v33, v34[0]);
    v10 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v34);
    if (*v34)
    {
      mlir::InFlightDiagnostic::report(v34);
    }

    if ((v42 & 1) == 0)
    {
      return v10;
    }

    if (v41 != &v42)
    {
      free(v41);
    }

    v12 = v39;
    if (v39)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v15)
      {
        do
        {
          v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v13 - 1);
        }

        while (v13 != v12);
        v14 = v39;
      }

      v40 = v12;
      operator delete(v14);
    }

    v16 = __p;
    if (__p)
    {
      v17 = v38;
      v18 = OUTLINED_FUNCTION_16_5();
      if (!v15)
      {
        do
        {
          v19 = OUTLINED_FUNCTION_17_5();
          if (v19)
          {
            operator delete[](v19);
          }
        }

        while (v17 != v16);
        v18 = __p;
      }

      v38 = v16;
      operator delete(v18);
    }

    v20 = v35;
    if (v35 == v36)
    {
      return v10;
    }

LABEL_54:
    free(v20);
    return v10;
  }

LABEL_9:
  if ((*(this + 46) & 0x80) == 0)
  {
    return 1;
  }

  v8 = *(this + 17);
  if (!v8)
  {
    return 1;
  }

  for (i = (*(this + 9) + 24); mlir::getElementTypeOrSelf(*i) == ElementTypeOrSelf; i += 4)
  {
    if (!--v8)
    {
      return 1;
    }
  }

  OUTLINED_FUNCTION_20_3("requires the same element type for all operands and results", v28, v29, v30, v31, v32, v33, v34[0]);
  v10 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v34);
  if (*v34)
  {
    mlir::InFlightDiagnostic::report(v34);
  }

  if (v42)
  {
    if (v41 != &v42)
    {
      free(v41);
    }

    v21 = v39;
    if (v39)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v15)
      {
        do
        {
          v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v22 - 1);
        }

        while (v22 != v21);
        v23 = v39;
      }

      v40 = v21;
      operator delete(v23);
    }

    v24 = __p;
    if (__p)
    {
      v25 = v38;
      v26 = __p;
      if (v38 != __p)
      {
        do
        {
          v27 = OUTLINED_FUNCTION_35_1();
          if (v27)
          {
            operator delete[](v27);
          }
        }

        while (v25 != v24);
        v26 = __p;
      }

      v38 = v24;
      operator delete(v26);
    }

    v20 = v35;
    if (v35 != v36)
    {
      goto LABEL_54;
    }
  }

  return v10;
}

mlir::OpTrait::impl *mlir::OpTrait::impl::verifySameOperandsAndResultType(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  v2 = this;
  v158 = *MEMORY[0x1E69E9840];
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(this, 1) || !mlir::OpTrait::impl::verifyAtLeastNResults(v2, 1))
  {
    return 0;
  }

  v3 = (*(v2 - 1) & 0xFFFFFFFFFFFFFFF8);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(v3);
  if (*(*v3 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v5 = v3;
  }

  else
  {
    v5 = 0;
  }

  v134 = v5;
  if (v5)
  {
    Values = mlir::SparseElementsAttr::getValues(&v134);
  }

  else
  {
    Values = 0;
  }

  v8 = *(v2 + 9);
  if (v8)
  {
    v9 = v2 - 16;
  }

  else
  {
    v9 = 0;
  }

  v126 = v9;
  v127 = v8;
  mlir::OperandRange::getTypes(&v126, &v134);
  v10 = v137;
  v11 = v135 + 1;
  if ((v135 + 1) != v137)
  {
    v12 = v134;
    v119 = v157;
    v120 = &v139;
    while (1)
    {
      v13 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v12, v11) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (mlir::getElementTypeOrSelf(v13) != ElementTypeOrSelf || !mlir::verifyCompatibleShape(v13, v3))
      {
        break;
      }

      if (Values)
      {
        v14 = *(*v13 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id ? v13 : 0;
        v131 = v14;
        if (Values != mlir::SparseElementsAttr::getValues(&v131))
        {
          OUTLINED_FUNCTION_54_0();
          OUTLINED_FUNCTION_30_3(v60, v61, v62, v63, v64, v65, v66, v67);
          if (v134)
          {
            LODWORD(v122) = 3;
            OUTLINED_FUNCTION_38_0();
            if (v31)
            {
              OUTLINED_FUNCTION_5_3();
              if (v105 <= v107 && (v106 & 1) != 0)
              {
                v2 = (&v122 - v105);
                OUTLINED_FUNCTION_29_3(&v137, v98, v99, v100, v101, v102, v103, v104, v118, v157, &v139);
                OUTLINED_FUNCTION_55_0();
              }

              else
              {
                OUTLINED_FUNCTION_29_3(&v137, v98, v99, v100, v101, v102, v103, v104, v118, v157, &v139);
                v68 = v137;
              }
            }

            OUTLINED_FUNCTION_0_3(v68);
            OUTLINED_FUNCTION_22_2();
          }

          mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v134);
          OUTLINED_FUNCTION_50_1();
          if (v69)
          {
            mlir::InFlightDiagnostic::report(&v134);
          }

          if ((v157[0] & 1) == 0)
          {
            return v2;
          }

          if (v156 != v119)
          {
            free(v156);
          }

          v70 = v154;
          if (v154)
          {
            OUTLINED_FUNCTION_15_5();
            if (!v36)
            {
              do
              {
                v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v71 - 1);
              }

              while (v71 != v70);
              v72 = v154;
            }

            OUTLINED_FUNCTION_58_0(v72, v118, v119, v120, v121, v122, v123, v124, v125, v126, v127, v128, v129, v130, v131, v132, v133, v134, v135, v136, v137, v138, v139, v140, v141, v142, v143, v144, v145, v146, v147, v148, v149, v150, __p, v152, v153, v154, v155);
          }

          v73 = __p;
          if (__p)
          {
            v74 = v152;
            v75 = OUTLINED_FUNCTION_16_5();
            if (!v36)
            {
              do
              {
                v76 = OUTLINED_FUNCTION_17_5();
                if (v76)
                {
                  operator delete[](v76);
                }
              }

              while (v74 != v73);
LABEL_120:
              v75 = __p;
            }

LABEL_121:
            v152 = v73;
            operator delete(v75);
          }

LABEL_122:
          v58 = v137;
          v59 = v120;
          goto LABEL_123;
        }
      }

      if (v10 == ++v11)
      {
        goto LABEL_24;
      }
    }

    OUTLINED_FUNCTION_54_0();
    OUTLINED_FUNCTION_30_3(v22, v23, v24, v25, v26, v27, v28, v29);
    if (v134)
    {
      LODWORD(v122) = 3;
      OUTLINED_FUNCTION_38_0();
      if (v31)
      {
        OUTLINED_FUNCTION_5_3();
        if (v92 <= v94 && (v93 & 1) != 0)
        {
          v2 = (&v122 - v92);
          OUTLINED_FUNCTION_3_1(&v137, &v134);
          OUTLINED_FUNCTION_55_0();
        }

        else
        {
          OUTLINED_FUNCTION_3_1(&v137, &v134);
          v30 = v137;
        }
      }

      OUTLINED_FUNCTION_0_3(v30);
      OUTLINED_FUNCTION_22_2();
    }

    mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v134);
    OUTLINED_FUNCTION_50_1();
    if (v32)
    {
      mlir::InFlightDiagnostic::report(&v134);
    }

    if (v157[0] != 1)
    {
      return v2;
    }

    if (v156 != v157)
    {
      free(v156);
    }

    v33 = v154;
    if (v154)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v36)
      {
        do
        {
          v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v34 - 1);
        }

        while (v34 != v33);
        v35 = v154;
      }

      OUTLINED_FUNCTION_58_0(v35, v118, v157, &v139, v121, v122, v123, v124, v125, v126, v127, v128, v129, v130, v131, v132, v133, v134, v135, v136, v137, v138, v139, v140, v141, v142, v143, v144, v145, v146, v147, v148, v149, v150, __p, v152, v153, v154, v155);
    }

    v37 = __p;
    if (!__p)
    {
      goto LABEL_82;
    }

    v38 = v152;
    v39 = OUTLINED_FUNCTION_16_5();
    if (v36)
    {
      goto LABEL_81;
    }

    do
    {
      v40 = OUTLINED_FUNCTION_17_5();
      if (v40)
      {
        operator delete[](v40);
      }
    }

    while (v38 != v37);
    goto LABEL_80;
  }

LABEL_24:
  if ((*(v2 + 46) & 0x80) != 0)
  {
    v15 = *(v2 + 9);
    v16 = *(v2 + 17);
  }

  else
  {
    OUTLINED_FUNCTION_90();
  }

  v134 = v15;
  v135 = v16;
  mlir::OperandRange::getTypes(&v134, &v122);
  v17 = v125 - v123;
  if (v125 == v123)
  {
    return 1;
  }

  v18 = v122 + 32 * v123;
  if (Values)
  {
    v120 = &v139;
    for (i = v18 + 24; ; i += 32)
    {
      v20 = (*(*i + 8) & 0xFFFFFFFFFFFFFFF8);
      if (mlir::getElementTypeOrSelf(v20) != ElementTypeOrSelf || !mlir::verifyCompatibleShape(v20, v3))
      {
        break;
      }

      if (*(*v20 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      {
        v21 = v20;
      }

      else
      {
        v21 = 0;
      }

      v121 = v21;
      if (Values != mlir::SparseElementsAttr::getValues(&v121))
      {
        OUTLINED_FUNCTION_54_0();
        OUTLINED_FUNCTION_30_3(v77, v78, v79, v80, v81, v82, v83, v84);
        if (v134)
        {
          LODWORD(v131) = 3;
          OUTLINED_FUNCTION_36_0();
          if (v31)
          {
            OUTLINED_FUNCTION_5_3();
            if (v115 <= v117 && (v116 & 1) != 0)
            {
              v2 = (&v131 - v115);
              OUTLINED_FUNCTION_29_3(&v137, v108, v109, v110, v111, v112, v113, v114, v118, v119, &v139);
              OUTLINED_FUNCTION_55_0();
            }

            else
            {
              OUTLINED_FUNCTION_29_3(&v137, v108, v109, v110, v111, v112, v113, v114, v118, v119, &v139);
              v85 = v137;
            }
          }

          OUTLINED_FUNCTION_0_3(v85);
          OUTLINED_FUNCTION_22_2();
        }

        mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v134);
        OUTLINED_FUNCTION_50_1();
        if (v86)
        {
          mlir::InFlightDiagnostic::report(&v134);
        }

        if ((v157[0] & 1) == 0)
        {
          return v2;
        }

        if (v156 != v157)
        {
          free(v156);
        }

        v87 = v154;
        if (v154)
        {
          OUTLINED_FUNCTION_15_5();
          if (!v36)
          {
            do
            {
              v88 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v88 - 1);
            }

            while (v88 != v87);
            v89 = v154;
          }

          OUTLINED_FUNCTION_58_0(v89, v118, v119, v120, v121, v122, v123, v124, v125, v126, v127, v128, v129, v130, v131, v132, v133, v134, v135, v136, v137, v138, v139, v140, v141, v142, v143, v144, v145, v146, v147, v148, v149, v150, __p, v152, v153, v154, v155);
        }

        v73 = __p;
        if (!__p)
        {
          goto LABEL_122;
        }

        v90 = v152;
        v75 = OUTLINED_FUNCTION_16_5();
        if (v36)
        {
          goto LABEL_121;
        }

        do
        {
          v91 = OUTLINED_FUNCTION_17_5();
          if (v91)
          {
            operator delete[](v91);
          }
        }

        while (v90 != v73);
        goto LABEL_120;
      }

      if (!--v17)
      {
        return 1;
      }
    }
  }

  else
  {
    v41 = (*(*(v18 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (mlir::getElementTypeOrSelf(v41) == ElementTypeOrSelf)
    {
      v42 = v18 + 56;
      do
      {
        if (!mlir::verifyCompatibleShape(v41, v3))
        {
          break;
        }

        if (!--v17)
        {
          return 1;
        }

        v41 = (*(*v42 + 8) & 0xFFFFFFFFFFFFFFF8);
        v42 += 32;
      }

      while (mlir::getElementTypeOrSelf(v41) == ElementTypeOrSelf);
    }
  }

  OUTLINED_FUNCTION_54_0();
  OUTLINED_FUNCTION_30_3(v43, v44, v45, v46, v47, v48, v49, v50);
  if (v134)
  {
    LODWORD(v131) = 3;
    OUTLINED_FUNCTION_36_0();
    if (v31)
    {
      OUTLINED_FUNCTION_5_3();
      if (v95 <= v97 && (v96 & 1) != 0)
      {
        v2 = (&v131 - v95);
        OUTLINED_FUNCTION_3_1(&v137, &v134);
        OUTLINED_FUNCTION_55_0();
      }

      else
      {
        OUTLINED_FUNCTION_3_1(&v137, &v134);
        v51 = v137;
      }
    }

    OUTLINED_FUNCTION_0_3(v51);
    OUTLINED_FUNCTION_22_2();
  }

  mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v134);
  OUTLINED_FUNCTION_50_1();
  if (v52)
  {
    mlir::InFlightDiagnostic::report(&v134);
  }

  if (v157[0] == 1)
  {
    if (v156 != v157)
    {
      free(v156);
    }

    v53 = v154;
    if (v154)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v36)
      {
        do
        {
          v54 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v54 - 1);
        }

        while (v54 != v53);
        v55 = v154;
      }

      OUTLINED_FUNCTION_58_0(v55, v118, v119, v120, v121, v122, v123, v124, v125, v126, v127, v128, v129, v130, v131, v132, v133, v134, v135, v136, v137, v138, v139, v140, v141, v142, v143, v144, v145, v146, v147, v148, v149, v150, __p, v152, v153, v154, v155);
    }

    v37 = __p;
    if (!__p)
    {
LABEL_82:
      v58 = v137;
      v59 = &v139;
LABEL_123:
      if (v58 != v59)
      {
        free(v58);
      }

      return v2;
    }

    v56 = v152;
    v39 = OUTLINED_FUNCTION_16_5();
    if (v36)
    {
LABEL_81:
      v152 = v37;
      operator delete(v39);
      goto LABEL_82;
    }

    do
    {
      v57 = OUTLINED_FUNCTION_17_5();
      if (v57)
      {
        operator delete[](v57);
      }
    }

    while (v56 != v37);
LABEL_80:
    v39 = __p;
    goto LABEL_81;
  }

  return v2;
}

uint64_t mlir::OpTrait::impl::verifyOperandSizeAttr(uint64_t a1, char *a2, unint64_t a3)
{
  if ((*(a1 + 46) & 0x80) != 0)
  {
    v3 = *(a1 + 68);
  }

  else
  {
    v3 = 0;
  }

  return mlir::OpTrait::impl::verifyValueSizeAttr(a1, a2, a3, "operand", 7, v3);
}

uint64_t mlir::OpTrait::impl::verifyElementwise(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  v2 = this;
  v140[1] = *MEMORY[0x1E69E9840];
  v3 = *(this + 9);
  v4 = this - 16;
  if (!v3)
  {
    v4 = 0;
  }

  v112.i64[0] = v4;
  v112.i64[1] = v3;
  mlir::OperandRange::getTypes(v112.i64, &__src);
  v6 = __src;
  v5 = v105;
  v7 = v106;
  if (v105 == *(&v106 + 1))
  {
    v8 = v106;
    v9 = v105;
  }

  else
  {
    while (1)
    {
      v10 = *(*(*(mlir::detail::OpResultImpl::getNextResultAtOffset(v6, v5) + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
      v11 = v10 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id || v10 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id;
      if (v11 || v10 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
      {
        break;
      }

      if (*(&v7 + 1) == ++v5)
      {
        v5 = *(&v7 + 1);
        break;
      }
    }

    v9 = v5;
    v5 = *(&v106 + 1);
    v8 = v106;
  }

  v112.i64[0] = v6;
  v112.i64[1] = v9;
  v113 = v7;
  __dst[0] = v8;
  __dst[1] = v5;
  *&v109 = v8;
  *(&v109 + 1) = v5;
  v138 = v140;
  v139 = 0x100000000;
  llvm::SmallVectorImpl<mlir::Type>::append<llvm::filter_iterator_impl<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,llvm::detail::IsaCheckPredicate<mlir::VectorType,mlir::TensorType>,std::bidirectional_iterator_tag>,void>(&v138, v112.i64, __dst);
  if ((*(v2 + 46) & 0x80) != 0)
  {
    v13 = *(v2 + 72);
    v14 = *(v2 + 68);
  }

  else
  {
    OUTLINED_FUNCTION_90();
  }

  v112.i64[0] = v13;
  v112.i64[1] = v14;
  mlir::OperandRange::getTypes(v112.i64, &__src);
  v15 = v105;
  if (v105 != *(&v106 + 1))
  {
    v16 = __src + 32 * v105 + 24;
    while (1)
    {
      v17 = *(*(*(*v16 + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
      v18 = v17 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id || v17 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id;
      if (v18 || v17 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
      {
        break;
      }

      ++v15;
      v16 += 32;
      if (*(&v106 + 1) == v15)
      {
        v15 = *(&v106 + 1);
        break;
      }
    }
  }

  v112.i64[0] = __src;
  v112.i64[1] = v15;
  v113 = v106;
  *__dst = v106;
  v109 = v106;
  v135 = v137;
  v136 = 0x200000000;
  llvm::SmallVectorImpl<mlir::Type>::append<llvm::filter_iterator_impl<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,llvm::detail::IsaCheckPredicate<mlir::VectorType,mlir::TensorType>,std::bidirectional_iterator_tag>,void>(&v135, v112.i64, __dst);
  if (!v139)
  {
    if (!v136)
    {
      v2 = 1;
      goto LABEL_129;
    }

    OUTLINED_FUNCTION_14_6("if an operand is non-scalar, then there must be at least one non-scalar result", v101, v102, v103, __src, v105, v106, *(&v106 + 1), v107);
    mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v112);
    OUTLINED_FUNCTION_51_0();
    if (v22)
    {
      mlir::InFlightDiagnostic::report(&v112);
    }

    OUTLINED_FUNCTION_40_0();
    if (!v11)
    {
      goto LABEL_129;
    }

    v31 = OUTLINED_FUNCTION_31_4(v23, v24, v25, v26, v27, v28, v29, v30, v101, v102, v103, __src, v105, v106, *(&v106 + 1), v107, __dst[0], __dst[1], v109, *(&v109 + 1), v110, v111, v112.i64[0], v112.i64[1], v113, *(&v113 + 1), v114, v115, v116, v117, v118, v119, v120, v121, v122, v123, v124, v125, v126, __p, v128, v129, v130, v131, v132, v133);
    if (!v11)
    {
      free(v31);
    }

    v39 = v130;
    if (v130)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v11)
      {
        do
        {
          v40 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v40 - 1);
        }

        while (v40 != v39);
        v41 = v130;
      }

      v131 = v39;
      operator delete(v41);
    }

    v42 = __p;
    if (!__p)
    {
      goto LABEL_87;
    }

    v43 = v128;
    v44 = OUTLINED_FUNCTION_16_5();
    if (v11)
    {
      goto LABEL_86;
    }

    do
    {
      v45 = OUTLINED_FUNCTION_17_5();
      if (v45)
      {
        operator delete[](v45);
      }
    }

    while (v43 != v42);
    goto LABEL_85;
  }

  if (!v136)
  {
    OUTLINED_FUNCTION_14_6("if a result is non-scalar, then at least one operand must be non-scalar", v101, v102, v103, __src, v105, v106, *(&v106 + 1), v107);
    mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v112);
    OUTLINED_FUNCTION_51_0();
    if (v46)
    {
      mlir::InFlightDiagnostic::report(&v112);
    }

    OUTLINED_FUNCTION_40_0();
    if (!v11)
    {
      goto LABEL_129;
    }

    v31 = OUTLINED_FUNCTION_31_4(v47, v48, v49, v50, v51, v52, v53, v54, v101, v102, v103, __src, v105, v106, *(&v106 + 1), v107, __dst[0], __dst[1], v109, *(&v109 + 1), v110, v111, v112.i64[0], v112.i64[1], v113, *(&v113 + 1), v114, v115, v116, v117, v118, v119, v120, v121, v122, v123, v124, v125, v126, __p, v128, v129, v130, v131, v132, v133);
    if (!v11)
    {
      free(v31);
    }

    v55 = v130;
    if (v130)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v11)
      {
        do
        {
          v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v56 - 1);
        }

        while (v56 != v55);
        v57 = v130;
      }

      v131 = v55;
      operator delete(v57);
    }

    v42 = __p;
    if (!__p)
    {
      goto LABEL_87;
    }

    v58 = v128;
    v44 = OUTLINED_FUNCTION_16_5();
    if (v11)
    {
      goto LABEL_86;
    }

    do
    {
      v59 = OUTLINED_FUNCTION_17_5();
      if (v59)
      {
        operator delete[](v59);
      }
    }

    while (v58 != v42);
    goto LABEL_85;
  }

  if (v139 == *(v2 + 36))
  {
    __src = &v106;
    v105 = 0x200000000;
    v112.i64[0] = v135;
    v112.i64[1] = v138;
    *&v113 = &v135[8 * v136];
    *(&v113 + 1) = &v138[8 * v139];
    *__dst = v113;
    v109 = v113;
    llvm::SmallVectorImpl<mlir::Type>::append<llvm::concat_iterator<mlir::Type,mlir::Type*,mlir::Type*>,void>(&__src, &v112, __dst);
    __dst[0] = &v109;
    __dst[1] = 0x400000000;
    v20 = v105;
    v21 = __src;
    if (v105)
    {
      if (__src == &v106)
      {
        v75 = v105;
        if (v105 < 5 || (llvm::SmallVectorBase<unsigned int>::grow_pod(__dst, &v109, v105, 8), v75 = v105, v21 = __src, v105))
        {
          memcpy(__dst[0], v21, 8 * v75);
          v21 = __src;
        }

        LODWORD(__dst[1]) = v20;
      }

      else
      {
        __dst[0] = __src;
        __dst[1] = v105;
        __src = &v106;
        HIDWORD(v105) = 0;
        v21 = &v106;
      }

      LODWORD(v105) = 0;
    }

    if (v21 != &v106)
    {
      free(v21);
      v20 = __dst[1];
    }

    if (v20)
    {
      v76 = 8 * v20;
      v77 = __dst[0];
      while (*(**v77 + 136) == *(**__dst[0] + 136))
      {
        v77 += 8;
        v76 -= 8;
        if (!v76)
        {
          goto LABEL_102;
        }
      }
    }

    else
    {
LABEL_102:
      mlir::ValueRange::ValueRange(&v112, __dst[0], v20);
      if (mlir::verifyCompatibleShapes(v112.i64[0], v112.u64[1]))
      {
        v2 = 1;
        goto LABEL_127;
      }
    }

    LOWORD(v107) = 257;
    mlir::Operation::emitOpError(v2, &__src, &v112);
    if (v112.i64[0])
    {
      LODWORD(v101) = 3;
      v102 = "all non-scalar operands/results must have the same shape and base type";
      v103 = 70;
      v78 = *(&v113 + 1);
      if (v114 >= HIDWORD(v114))
      {
        OUTLINED_FUNCTION_5_3();
        if (v98 <= v100 && (v99 & 1) != 0)
        {
          v2 = &v101 - v98;
          OUTLINED_FUNCTION_8_4(&v112);
          v78 = *(&v113 + 1);
        }

        else
        {
          OUTLINED_FUNCTION_8_4(&v112);
          v78 = *(&v113 + 1);
        }
      }

      OUTLINED_FUNCTION_0_3(v78);
      LODWORD(v114) = v114 + 1;
    }

    mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v112);
    OUTLINED_FUNCTION_51_0();
    if (v79)
    {
      mlir::InFlightDiagnostic::report(&v112);
    }

    OUTLINED_FUNCTION_40_0();
    if (v11)
    {
      v87 = v133;
      if (v133 != &v134)
      {
        free(v133);
      }

      v88 = v130;
      if (v130)
      {
        OUTLINED_FUNCTION_47_1();
        if (!v11)
        {
          do
          {
            v89 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v89 - 1);
          }

          while (v89 != v88);
          v90 = v130;
        }

        v131 = v88;
        operator delete(v90);
      }

      v91 = __p;
      if (__p)
      {
        v92 = v128;
        v93 = __p;
        if (v128 != __p)
        {
          do
          {
            v95 = *--v92;
            v94 = v95;
            *v92 = 0;
            if (v95)
            {
              operator delete[](v94);
            }
          }

          while (v92 != v91);
          v93 = __p;
        }

        v128 = v91;
        operator delete(v93);
      }

      v96 = OUTLINED_FUNCTION_56_0(v87, v80, v81, v82, v83, v84, v85, v86, v101, v102, v103, __src, v105, v106, *(&v106 + 1), v107, __dst[0], __dst[1], v109, *(&v109 + 1), v110, v111, v112.i64[0], v112.i64[1], v113, *(&v113 + 1));
      if (!v11)
      {
        free(v96);
      }
    }

LABEL_127:
    v74 = __dst[0];
    if (__dst[0] == &v109)
    {
      goto LABEL_129;
    }

    goto LABEL_128;
  }

  OUTLINED_FUNCTION_14_6("if an operand is non-scalar, then all results must be non-scalar", v101, v102, v103, __src, v105, v106, *(&v106 + 1), v107);
  mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v112);
  OUTLINED_FUNCTION_51_0();
  if (v60)
  {
    mlir::InFlightDiagnostic::report(&v112);
  }

  OUTLINED_FUNCTION_40_0();
  if (v11)
  {
    v31 = OUTLINED_FUNCTION_31_4(v61, v62, v63, v64, v65, v66, v67, v68, v101, v102, v103, __src, v105, v106, *(&v106 + 1), v107, __dst[0], __dst[1], v109, *(&v109 + 1), v110, v111, v112.i64[0], v112.i64[1], v113, *(&v113 + 1), v114, v115, v116, v117, v118, v119, v120, v121, v122, v123, v124, v125, v126, __p, v128, v129, v130, v131, v132, v133);
    if (!v11)
    {
      free(v31);
    }

    v69 = v130;
    if (v130)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v11)
      {
        do
        {
          v70 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v70 - 1);
        }

        while (v70 != v69);
        v71 = v130;
      }

      v131 = v69;
      operator delete(v71);
    }

    v42 = __p;
    if (!__p)
    {
LABEL_87:
      v74 = OUTLINED_FUNCTION_56_0(v31, v32, v33, v34, v35, v36, v37, v38, v101, v102, v103, __src, v105, v106, *(&v106 + 1), v107, __dst[0], __dst[1], v109, *(&v109 + 1), v110, v111, v112.i64[0], v112.i64[1], v113, *(&v113 + 1));
      if (!v11)
      {
LABEL_128:
        free(v74);
        goto LABEL_129;
      }

      goto LABEL_129;
    }

    v72 = v128;
    v44 = OUTLINED_FUNCTION_16_5();
    if (v11)
    {
LABEL_86:
      v128 = v42;
      operator delete(v44);
      goto LABEL_87;
    }

    do
    {
      v73 = OUTLINED_FUNCTION_17_5();
      if (v73)
      {
        operator delete[](v73);
      }
    }

    while (v72 != v42);
LABEL_85:
    v44 = __p;
    goto LABEL_86;
  }

LABEL_129:
  if (v135 != v137)
  {
    free(v135);
  }

  if (v138 != v140)
  {
    free(v138);
  }

  return v2;
}

void mlir::Dialect::getRegisteredInterface<mlir::DialectFoldInterface>()
{
  {
    v0 = llvm::getTypeName<mlir::DialectFoldInterface>();
    mlir::detail::TypeIDResolver<mlir::DialectFoldInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

double mlir::MutableOperandRange::MutableOperandRange(mlir::MutableOperandRange *this, mlir::Operation *a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 17);
  }

  else
  {
    v2 = 0;
  }

  *this = a2;
  *(this + 2) = 0;
  *(this + 3) = v2;
  *(this + 2) = this + 32;
  *&result = 0x100000000;
  *(this + 3) = 0x100000000;
  return result;
}

uint64_t mlir::MutableOperandRange::operator mlir::OperandRange(uint64_t a1)
{
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    v1 = *(*a1 + 72);
  }

  else
  {
    v1 = 0;
  }

  return OUTLINED_FUNCTION_1_6(a1, v1);
}

uint64_t mlir::MutableOperandRange::begin(mlir::MutableOperandRange *this)
{
  if ((*(*this + 46) & 0x80) != 0)
  {
    v1 = *(*this + 72);
  }

  else
  {
    v1 = 0;
  }

  return v1 + 32 * *(this + 2);
}

uint64_t mlir::MutableOperandRange::end(mlir::MutableOperandRange *this)
{
  if ((*(*this + 46) & 0x80) != 0)
  {
    v1 = *(*this + 72);
  }

  else
  {
    v1 = 0;
  }

  return v1 + 32 * *(this + 2) + 32 * *(this + 3);
}

unint64_t mlir::OperationEquivalence::computeHash(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t), uint64_t a5, char a6)
{
  v90 = *MEMORY[0x1E69E9840];
  v12 = *(a1 + 48);
  v13 = *(a1 + 56);
  v14 = *(a1 + 36);
  v15 = a1 - 16;
  v73 = a1 - 16;
  if (!v14)
  {
    v15 = 0;
  }

  v80 = v15;
  v81 = v14;
  mlir::OperandRange::getTypes(&v80, &v76);
  v75 = mlir::Operation::hashProperties(a1);
  v87 = 0u;
  OUTLINED_FUNCTION_0_4();
  v16 = 0x9DDFEA08EB382D69 * ((8 * v12 - 0xAE502812AA7333) ^ HIDWORD(v12));
  v17 = 0x9DDFEA08EB382D69 * (HIDWORD(v12) ^ (v16 >> 47) ^ v16);
  v81 = (v13 >> 4) ^ (v13 >> 9);
  v26 = OUTLINED_FUNCTION_2_8(v18, v19, v20, v21, v22, v23, v24, v25, v73, v75, v76, v77, v78, v79, 105 * (v17 ^ (v17 >> 47)));
  v29 = llvm::hashing::detail::hash_combine_recursive_helper::combine<mlir::ValueTypeRange<mlir::ResultRange>,llvm::hash_code>(v26, 0, v27, v28, &v76, &v75);
  if ((a6 & 1) == 0)
  {
    v87 = 0u;
    OUTLINED_FUNCTION_0_4();
    v81 = (v30 >> 4) ^ (v30 >> 9);
    v39 = OUTLINED_FUNCTION_2_8(v31, v32, v33, v34, v35, v36, v37, v38, v74, v75, v76, v77, v78, v79, v29);
    v29 = llvm::hashing::detail::hash_combine_recursive_helper::combine(v39, 0, v40, v41);
  }

  {
    v71 = llvm::getTypeName<mlir::OpTrait::IsCommutative<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsCommutative>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::IsCommutative<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsCommutative>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v71, v72);
  }

  v42 = (*(**(a1 + 48) + 32))(*(a1 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::IsCommutative<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsCommutative>(void)::Empty>,void>::resolveTypeID(void)::id);
  v43 = *(a1 + 44);
  if (v42)
  {
    if ((v43 & 0x800000) == 0)
    {
      goto LABEL_19;
    }

    if (*(a1 + 68))
    {
      v44 = a2(a3, *(*(a1 + 72) + 24));
      if ((*(a1 + 46) & 0x80) != 0)
      {
        v45 = *(a1 + 68);
        v46 = v45 - 1;
        if (v45 == 1)
        {
LABEL_14:
          v87 = 0u;
          OUTLINED_FUNCTION_0_4();
          v80 = v29;
          v81 = v44;
          v29 = llvm::hashing::detail::hash_combine_recursive_helper::combine(&v80, 0, (v50 + 16), (v50 + 64));
          goto LABEL_19;
        }

        v47 = *(a1 + 72) + 32;
      }

      else
      {
        v46 = -1;
        v47 = 32;
      }

      v48 = (v47 + 24);
      do
      {
        v49 = *v48;
        v48 += 4;
        v44 += a2(a3, v49);
        --v46;
      }

      while (v46);
      goto LABEL_14;
    }
  }

  else if ((v43 & 0x800000) == 0)
  {
    goto LABEL_19;
  }

  v51 = *(a1 + 68);
  if (v51)
  {
    v52 = (*(a1 + 72) + 24);
    do
    {
      v53 = *v52;
      v52 += 4;
      v54 = a2(a3, v53);
      v88 = 0;
      v86 = 0u;
      v87 = 0u;
      v84 = 0u;
      v85 = 0u;
      v82 = 0u;
      v83 = 0u;
      v89 = 0xFF51AFD7ED558CCDLL;
      v81 = v54;
      v62 = OUTLINED_FUNCTION_2_8(v54, v55, v56, v57, v58, v59, v60, v61, v74, v75, v76, v77, v78, v79, v29);
      v29 = llvm::hashing::detail::hash_combine_recursive_helper::combine(v62, 0, v63, v64);
      --v51;
    }

    while (v51);
  }

LABEL_19:
  v65 = *(a1 + 36);
  if (v65)
  {
    v66 = v74;
  }

  else
  {
    v66 = 0;
  }

  if (v65)
  {
    for (i = 0; i != v65; ++i)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v66, i);
      v69 = a4(a5, NextResultAtOffset);
      v88 = 0;
      v86 = 0u;
      v87 = 0u;
      v84 = 0u;
      v85 = 0u;
      v82 = 0u;
      v83 = 0u;
      v89 = 0xFF51AFD7ED558CCDLL;
      v80 = v29;
      v81 = v69;
      v29 = llvm::hashing::detail::hash_combine_recursive_helper::combine(&v80, 0, &v82, &v85);
    }
  }

  return v29;
}

void *mlir::OperationFingerPrint::OperationFingerPrint(mlir::Operation *,BOOL)::$_0::operator()(_DWORD **a1, mlir::Operation *a2)
{
  v49 = a2;
  llvm::SHA1::update(*a1, &v49, 8uLL);
  v10 = v49;
  if (v49 != *a1[1])
  {
    ParentOp = *(v49 + 2);
    if (ParentOp)
    {
      ParentOp = mlir::Block::getParentOp(ParentOp);
    }

    OUTLINED_FUNCTION_4_6(ParentOp, v3, v4, v5, v6, v7, v8, v9, v42, v46);
    v10 = v49;
  }

  OUTLINED_FUNCTION_3_7(*a1, *(v10 + 7), v42, v46);
  v12 = mlir::Operation::hashProperties(v49);
  OUTLINED_FUNCTION_4_6(v12, v13, v14, v15, v16, v17, v18, v19, v43, v46);
  v20 = v49;
  v21 = *(v49 + 11);
  if ((v21 & 0x7FFFFF) != 0)
  {
    v22 = ((v49 + 16 * ((v21 >> 23) & 1) + ((v21 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v49 + 10);
    v23 = v22 + 24 * (v21 & 0x7FFFFF);
    do
    {
      for (i = *(v22 + 8); i != v22; i = *(i + 8))
      {
        if (i)
        {
          v25 = (i - 8);
        }

        else
        {
          v25 = 0;
        }

        v26 = *a1;
        v46 = v25;
        llvm::SHA1::update(v26, &v46, 8uLL);
        v27 = *(v25 + 6);
        v28 = *(v25 + 7);
        while (v27 != v28)
        {
          v29 = *v27++;
          OUTLINED_FUNCTION_5_6(v29, v44, v46);
        }
      }

      v22 += 24;
    }

    while (v22 != v23);
    v20 = v49;
  }

  OUTLINED_FUNCTION_3_7(*a1, *(v20 + 3), v44, v46);
  v30 = v49;
  if ((*(v49 + 46) & 0x80) != 0)
  {
    v31 = *(v49 + 17);
    if (v31)
    {
      v32 = (*(v49 + 9) + 24);
      do
      {
        v33 = *v32;
        v32 += 4;
        OUTLINED_FUNCTION_5_6(v33, v45, v46);
        --v31;
      }

      while (v31);
      v30 = v49;
    }
  }

  v34 = *(v30 + 10);
  if (v34)
  {
    v35 = 24;
    do
    {
      OUTLINED_FUNCTION_3_7(*a1, *(((v49 + 16 * ((*(v49 + 11) >> 23) & 1) + ((*(v49 + 11) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + v35), v45, v46);
      v35 += 32;
      --v34;
    }

    while (v34);
    v30 = v49;
  }

  v36 = *(v30 + 9);
  v37 = v30 - 16;
  if (!v36)
  {
    v37 = 0;
  }

  v50[0] = v37;
  v50[1] = v36;
  result = mlir::OperandRange::getTypes(v50, &v46);
  v39 = v47;
  v40 = v48;
  if (v47 != v48)
  {
    v41 = v46;
    do
    {
      v50[0] = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v41, v39) + 8) & 0xFFFFFFFFFFFFFFF8;
      result = llvm::SHA1::update(*a1, v50, 8uLL);
      ++v39;
    }

    while (v40 != v39);
  }

  return result;
}

void mlir::Operation::hasTrait<mlir::OpTrait::IsCommutative>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsCommutative<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsCommutative>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::IsCommutative<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsCommutative>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::SymbolTable::getNearestSymbolTable()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SymbolTable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SymbolTable>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_0_5(v2);
  }
}

void mlir::SymbolTable::walkSymbolTables()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SymbolTable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SymbolTable>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_0_5(v2);
  }
}

void mlir::OpInterface<mlir::SymbolOpInterface,mlir::detail::SymbolOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::SymbolOpInterface>();
    mlir::detail::TypeIDResolver<mlir::SymbolOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::SymbolUserOpInterface,mlir::detail::SymbolUserOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::SymbolUserOpInterface>();
    mlir::detail::TypeIDResolver<mlir::SymbolUserOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

unint64_t mlir::OpOperand::getOperandNumber(mlir::OpOperand *this)
{
  v1 = *(this + 2);
  if ((*(v1 + 46) & 0x80) != 0)
  {
    v2 = *(v1 + 72);
  }

  else
  {
    v2 = 0;
  }

  return (this - v2) >> 5;
}

void anonymous namespace::OperationVerifier::verifyOpAndDominance(uint64_t *a1, unint64_t *a2)
{
  {
    *a1 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsIsolatedFromAbove<Empty>]";
    *a2 = 91;
    v4 = llvm::StringRef::find(a1, "DesiredTypeName = ", 0x12uLL, 0);
    if (*a2 >= v4)
    {
      v5 = v4;
    }

    else
    {
      v5 = *a2;
    }

    v6 = *a1 + v5;
    v7 = *a2 - v5;
    if (v7 >= 0x12)
    {
      v8 = 18;
    }

    else
    {
      v8 = *a2 - v5;
    }

    v9 = v7 - v8;
    if (v9 >= v9 - 1)
    {
      v10 = v9 - 1;
    }

    else
    {
      v10 = v9;
    }

    mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v6 + v8, v10);
  }
}

uint64_t mlir::detail::verifyInferredResultTypes(mlir::detail *this, mlir::Operation *a2)
{
  v67[4] = *MEMORY[0x1E69E9840];
  v3 = *(this + 9);
  v4 = this - 16;
  if (!v3)
  {
    v4 = 0;
  }

  v65 = v4;
  v66 = v3;
  mlir::OperandRange::getTypes(&v65, &v53);
  v65 = v67;
  v66 = 0x400000000;
  v5 = v53;
  v6 = v54;
  v7 = v55;
  v8 = v55 - v54;
  if (v55 - v54 < 5)
  {
    v9 = 0;
    v10 = 0;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v65, v67, v55 - v54, 8);
    v9 = v66;
    v10 = v66;
  }

  if (v7 == v6)
  {
    LODWORD(v66) = v10 + v8;
LABEL_11:
    InterfaceFor = mlir::OpInterface<mlir::InferTypeOpInterface,mlir::detail::InferTypeOpInterfaceInterfaceTraits>::getInterfaceFor(this);
    goto LABEL_12;
  }

  v11 = &v65[8 * v9];
  do
  {
    *v11++ = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v5, v6++) + 8) & 0xFFFFFFFFFFFFFFF8;
  }

  while (v7 != v6);
  LODWORD(v66) = v66 + v8;
  if (this)
  {
    goto LABEL_11;
  }

  InterfaceFor = 0;
LABEL_12:
  Context = mlir::Attribute::getContext((this + 24));
  v14 = *(this + 3);
  if ((*(this + 46) & 0x80) != 0)
  {
    v15 = *(this + 9);
    v16 = *(this + 17);
  }

  else
  {
    v15 = 0;
    v16 = 0;
  }

  mlir::ValueRange::ValueRange(&v53, v15, v16);
  v17 = *(this + 7);
  v18 = *(this + 11);
  if (HIBYTE(*(this + 11)))
  {
    v19 = this + 16 * ((v18 >> 23) & 1) + 64;
  }

  else
  {
    v19 = 0;
  }

  v20 = v18 & 0x7FFFFF;
  if ((v18 & 0x7FFFFF) != 0)
  {
    v21 = ((this + 16 * ((v18 >> 23) & 1) + ((v18 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(this + 10);
  }

  else
  {
    v21 = 0;
    v20 = 0;
  }

  mlir::ValueRange::ValueRange(&v50, v21, v20);
  v46 = v51;
  v45 = v50;
  v22 = (*(InterfaceFor + 8))(Context, v14, 1, v53, v54, v17, v19);
  if ((v22 & 1) == 0)
  {
    v52 = 257;
    mlir::Operation::emitOpError(this, &v50, &v53);
    if (v53)
    {
      LODWORD(v47) = 3;
      v48 = "failed to infer returned types";
      v49 = 30;
      v31 = &v47;
      v32 = v55;
      if (v56 >= v57)
      {
        if (v55 <= &v47 && v55 + 24 * v56 > &v47)
        {
          v44 = &v47 - v55;
          OUTLINED_FUNCTION_1_7(v23, v24, v25, v26, v27, v28, v29, v30, v45, v46, &v65, v47, v48, v49, v50, v51);
          v32 = v55;
          v31 = (v55 + v44);
        }

        else
        {
          OUTLINED_FUNCTION_1_7(v23, v24, v25, v26, v27, v28, v29, v30, v45, v46, &v65, v47, v48, v49, v50, v51);
          v31 = &v47;
          v32 = v55;
        }
      }

      v33 = &v32[24 * v56];
      v34 = *v31;
      *(v33 + 2) = v31[2];
      *v33 = v34;
      ++v56;
      if (v53)
      {
        mlir::InFlightDiagnostic::report(&v53);
      }
    }

    if (v64 == 1)
    {
      if (v63 != &v64)
      {
        free(v63);
      }

      v35 = __p;
      if (__p)
      {
        v36 = v62;
        v37 = __p;
        if (v62 != __p)
        {
          do
          {
            v36 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v36 - 1);
          }

          while (v36 != v35);
          v37 = __p;
        }

        v62 = v35;
        operator delete(v37);
      }

      v38 = v59;
      if (v59)
      {
        v39 = v60;
        v40 = v59;
        if (v60 != v59)
        {
          do
          {
            v42 = *--v39;
            v41 = v42;
            *v39 = 0;
            if (v42)
            {
              operator delete[](v41);
            }
          }

          while (v39 != v38);
          v40 = v59;
        }

        v60 = v38;
        operator delete(v40);
      }

      if (v55 != &v58)
      {
        free(v55);
      }
    }
  }

  if (v65 != v67)
  {
    free(v65);
  }

  return v22;
}

void mlir::OpInterface<mlir::InferTypeOpInterface,mlir::detail::InferTypeOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::memref::AllocaScopeOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
    v3 = *(a2 + 68);
  }

  else
  {
    v2 = 0;
    v3 = 0;
  }

  return v2 + 32 * v3;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::memref::ReinterpretCastOp>::getOffsets(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 1u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::memref::ReinterpretCastOp>::getSizes(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 2u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::memref::ReinterpretCastOp>::getStrides(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 3u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedOffsets(mlir::memref::ReinterpretCastOp *a1@<X0>, uint64_t a2@<X8>)
{
  v18[6] = *MEMORY[0x1E69E9840];
  Context = mlir::Attribute::getContext((*a1 + 24));
  StaticOffsets = mlir::memref::ReinterpretCastOp::getStaticOffsets(a1);
  v6 = v5;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(a1, 1u);
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    v8 = *(*a1 + 72);
  }

  else
  {
    v8 = 0;
  }

  mlir::ValueRange::ValueRange(v14, v8 + 32 * ODSOperandIndexAndLength, (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength) - ODSOperandIndexAndLength);
  mlir::getMixedValues(StaticOffsets, v6, v14[0], v14[1], &Context, &__src);
  *a2 = a2 + 16;
  *(a2 + 8) = 0x400000000;
  v9 = v16;
  v10 = __src;
  if (v16 && &__src != a2)
  {
    if (__src == v18)
    {
      v12 = v16;
      if (v16 < 5 || (llvm::SmallVectorBase<unsigned int>::grow_pod(a2, a2 + 16, v16, 8), v12 = v16, v10 = __src, v16))
      {
        memcpy(*a2, v10, 8 * v12);
        v10 = __src;
      }

      *(a2 + 8) = v9;
    }

    else
    {
      *a2 = __src;
      v11 = v17;
      *(a2 + 8) = v9;
      *(a2 + 12) = v11;
      __src = v18;
      v17 = 0;
      v10 = v18;
    }

    v16 = 0;
  }

  if (v10 != v18)
  {
    free(v10);
  }
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes(mlir::memref::ReinterpretCastOp *a1@<X0>, uint64_t a2@<X8>)
{
  v18[6] = *MEMORY[0x1E69E9840];
  Context = mlir::Attribute::getContext((*a1 + 24));
  StaticSizes = mlir::memref::ReinterpretCastOp::getStaticSizes(a1);
  v6 = v5;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(a1, 2u);
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    v8 = *(*a1 + 72);
  }

  else
  {
    v8 = 0;
  }

  mlir::ValueRange::ValueRange(v14, v8 + 32 * ODSOperandIndexAndLength, (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength) - ODSOperandIndexAndLength);
  mlir::getMixedValues(StaticSizes, v6, v14[0], v14[1], &Context, &__src);
  *a2 = a2 + 16;
  *(a2 + 8) = 0x400000000;
  v9 = v16;
  v10 = __src;
  if (v16 && &__src != a2)
  {
    if (__src == v18)
    {
      v12 = v16;
      if (v16 < 5 || (llvm::SmallVectorBase<unsigned int>::grow_pod(a2, a2 + 16, v16, 8), v12 = v16, v10 = __src, v16))
      {
        memcpy(*a2, v10, 8 * v12);
        v10 = __src;
      }

      *(a2 + 8) = v9;
    }

    else
    {
      *a2 = __src;
      v11 = v17;
      *(a2 + 8) = v9;
      *(a2 + 12) = v11;
      __src = v18;
      v17 = 0;
      v10 = v18;
    }

    v16 = 0;
  }

  if (v10 != v18)
  {
    free(v10);
  }
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides(mlir::memref::ReinterpretCastOp *a1@<X0>, uint64_t a2@<X8>)
{
  v18[6] = *MEMORY[0x1E69E9840];
  Context = mlir::Attribute::getContext((*a1 + 24));
  StaticStrides = mlir::memref::ReinterpretCastOp::getStaticStrides(a1);
  v6 = v5;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(a1, 3u);
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    v8 = *(*a1 + 72);
  }

  else
  {
    v8 = 0;
  }

  mlir::ValueRange::ValueRange(v14, v8 + 32 * ODSOperandIndexAndLength, (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength) - ODSOperandIndexAndLength);
  mlir::getMixedValues(StaticStrides, v6, v14[0], v14[1], &Context, &__src);
  *a2 = a2 + 16;
  *(a2 + 8) = 0x400000000;
  v9 = v16;
  v10 = __src;
  if (v16 && &__src != a2)
  {
    if (__src == v18)
    {
      v12 = v16;
      if (v16 < 5 || (llvm::SmallVectorBase<unsigned int>::grow_pod(a2, a2 + 16, v16, 8), v12 = v16, v10 = __src, v16))
      {
        memcpy(*a2, v10, 8 * v12);
        v10 = __src;
      }

      *(a2 + 8) = v9;
    }

    else
    {
      *a2 = __src;
      v11 = v17;
      *(a2 + 8) = v9;
      *(a2 + 12) = v11;
      __src = v18;
      v17 = 0;
      v10 = v18;
    }

    v16 = 0;
  }

  if (v10 != v18)
  {
    free(v10);
  }
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::memref::SubViewOp>::getOffsets(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 1u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::memref::SubViewOp>::getSizes(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 2u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::memref::SubViewOp>::getStrides(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 3u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

void mlir::memref::MemRefDialect::initialize()
{
  {
    v0 = llvm::getTypeName<mlir::DestructurableTypeInterface>();
    mlir::detail::TypeIDResolver<mlir::DestructurableTypeInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::declarePromisedInterfaces<mlir::bufferization::AllocationOpInterface,mlir::memref::AllocOp,mlir::memref::AllocaOp,mlir::memref::ReallocOp>()
{
  {
    v0 = llvm::getTypeName<mlir::bufferization::AllocationOpInterface>();
    mlir::detail::TypeIDResolver<mlir::bufferization::AllocationOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::bufferization::AllocationOpInterface>();
    mlir::detail::TypeIDResolver<mlir::bufferization::AllocationOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::declarePromisedInterfaces<mlir::RuntimeVerifiableOpInterface,mlir::memref::CastOp,mlir::memref::ExpandShapeOp,mlir::memref::LoadOp,mlir::memref::ReinterpretCastOp,mlir::memref::StoreOp,mlir::memref::SubViewOp>()
{
  {
    v0 = llvm::getTypeName<mlir::RuntimeVerifiableOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_23_3(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::RuntimeVerifiableOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_23_3(v2);
  }
}

void mlir::Dialect::declarePromisedInterfaces<mlir::ValueBoundsOpInterface,mlir::memref::AllocOp,mlir::memref::AllocaOp,mlir::memref::CastOp,mlir::memref::DimOp,mlir::memref::GetGlobalOp,mlir::memref::RankOp,mlir::memref::SubViewOp>()
{
  {
    v0 = llvm::getTypeName<mlir::ValueBoundsOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_21_4(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ValueBoundsOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_21_4(v2);
  }
}

void mlir::RegisteredOperationName::Model<mlir::memref::AssumeAlignmentOp>::Model()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_10_8(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_14_7(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_13_7(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_9_5(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::memref::AtomicRMWOp>,mlir::OpTrait::OneResult<mlir::memref::AtomicRMWOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::memref::AtomicRMWOp>,mlir::OpTrait::ZeroSuccessors<mlir::memref::AtomicRMWOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::memref::AtomicRMWOp>,mlir::OpTrait::OpInvariants<mlir::memref::AtomicRMWOp>,mlir::BytecodeOpInterface::Trait<mlir::memref::AtomicRMWOp>,mlir::InferTypeOpInterface::Trait<mlir::memref::AtomicRMWOp>,mlir::MemoryEffectOpInterface::Trait<mlir::memref::AtomicRMWOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_10_8(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_20_4(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_5_7(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_25_4(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_19_4(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::memref::AtomicYieldOp>,mlir::OpTrait::ZeroResults<mlir::memref::AtomicYieldOp>,mlir::OpTrait::ZeroSuccessors<mlir::memref::AtomicYieldOp>,mlir::OpTrait::OneOperand<mlir::memref::AtomicYieldOp>,mlir::OpTrait::HasParent<mlir::memref::GenericAtomicRMWOp>::Impl<mlir::memref::AtomicYieldOp>,mlir::OpTrait::OpInvariants<mlir::memref::AtomicYieldOp>,mlir::ConditionallySpeculatable::Trait<mlir::memref::AtomicYieldOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::memref::AtomicYieldOp>,mlir::MemoryEffectOpInterface::Trait<mlir::memref::AtomicYieldOp>,mlir::OpTrait::IsTerminator<mlir::memref::AtomicYieldOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_7_5(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::memref::GenericAtomicRMWOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::memref::GenericAtomicRMWOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::memref::GenericAtomicRMWOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::memref::GenericAtomicRMWOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::memref::GenericAtomicRMWOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_6_6(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_8_5(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::memref::CopyOp>,mlir::OpTrait::ZeroResults<mlir::memref::CopyOp>,mlir::OpTrait::ZeroSuccessors<mlir::memref::CopyOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::memref::CopyOp>,mlir::OpTrait::OpInvariants<mlir::memref::CopyOp>,mlir::CopyOpInterface::Trait<mlir::memref::CopyOp>,mlir::OpTrait::SameOperandsElementType<mlir::memref::CopyOp>,mlir::OpTrait::SameOperandsShape<mlir::memref::CopyOp>,mlir::MemoryEffectOpInterface::Trait<mlir::memref::CopyOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::CopyOpInterface>();
    mlir::detail::TypeIDResolver<mlir::CopyOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::CopyOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::SameOperandsShape,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::CopyOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CopyOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::CopyOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CopyOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsElementType>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsElementType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsShape>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::memref::AtomicYieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::InferTypeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_18_5(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::memref::AtomicYieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::memref::AtomicYieldOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::memref::AtomicYieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::memref::AtomicYieldOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::memref::LoadOp>,mlir::OpTrait::OneResult<mlir::memref::LoadOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::memref::LoadOp>,mlir::OpTrait::ZeroSuccessors<mlir::memref::LoadOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::memref::LoadOp>,mlir::OpTrait::OpInvariants<mlir::memref::LoadOp>,mlir::BytecodeOpInterface::Trait<mlir::memref::LoadOp>,mlir::OpTrait::MemRefsNormalizable<mlir::memref::LoadOp>,mlir::PromotableMemOpInterface::Trait<mlir::memref::LoadOp>,mlir::DestructurableAccessorOpInterface::Trait<mlir::memref::LoadOp>,mlir::InferTypeOpInterface::Trait<mlir::memref::LoadOp>,mlir::MemoryEffectOpInterface::Trait<mlir::memref::LoadOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::PromotableMemOpInterface>();
    mlir::detail::TypeIDResolver<mlir::PromotableMemOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::DestructurableAccessorOpInterface>();
    mlir::detail::TypeIDResolver<mlir::DestructurableAccessorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::PromotableMemOpInterface::Trait,mlir::DestructurableAccessorOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::MemRefsNormalizable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::MemRefsNormalizable>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_22_3(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::PromotableMemOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::PromotableMemOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::PromotableMemOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::PromotableMemOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::DestructurableAccessorOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DestructurableAccessorOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::DestructurableAccessorOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DestructurableAccessorOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::memref::AllocOp>,mlir::OpTrait::OneResult<mlir::memref::AllocOp>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::memref::AllocOp>,mlir::OpTrait::ZeroSuccessors<mlir::memref::AllocOp>,mlir::OpTrait::VariadicOperands<mlir::memref::AllocOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::memref::AllocOp>,mlir::OpTrait::OpInvariants<mlir::memref::AllocOp>,mlir::BytecodeOpInterface::Trait<mlir::memref::AllocOp>,mlir::OpAsmOpInterface::Trait<mlir::memref::AllocOp>,mlir::MemoryEffectOpInterface::Trait<mlir::memref::AllocOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::OpAsmOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_12_6(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_15_6(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_28_3(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_27_4(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_11_4(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::memref::AllocaOp>,mlir::OpTrait::OneResult<mlir::memref::AllocaOp>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::memref::AllocaOp>,mlir::OpTrait::ZeroSuccessors<mlir::memref::AllocaOp>,mlir::OpTrait::VariadicOperands<mlir::memref::AllocaOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::memref::AllocaOp>,mlir::OpTrait::OpInvariants<mlir::memref::AllocaOp>,mlir::BytecodeOpInterface::Trait<mlir::memref::AllocaOp>,mlir::OpAsmOpInterface::Trait<mlir::memref::AllocaOp>,mlir::PromotableAllocationOpInterface::Trait<mlir::memref::AllocaOp>,mlir::DestructurableAllocationOpInterface::Trait<mlir::memref::AllocaOp>,mlir::MemoryEffectOpInterface::Trait<mlir::memref::AllocaOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::PromotableAllocationOpInterface>();
    mlir::detail::TypeIDResolver<mlir::PromotableAllocationOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::DestructurableAllocationOpInterface>();
    mlir::detail::TypeIDResolver<mlir::DestructurableAllocationOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::PromotableAllocationOpInterface::Trait,mlir::DestructurableAllocationOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::PromotableAllocationOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::PromotableAllocationOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::PromotableAllocationOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::PromotableAllocationOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::DestructurableAllocationOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DestructurableAllocationOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::DestructurableAllocationOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DestructurableAllocationOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::OneRegion<mlir::memref::AllocaScopeOp>,mlir::OpTrait::VariadicResults<mlir::memref::AllocaScopeOp>,mlir::OpTrait::ZeroSuccessors<mlir::memref::AllocaScopeOp>,mlir::OpTrait::ZeroOperands<mlir::memref::AllocaScopeOp>,mlir::OpTrait::SingleBlock<mlir::memref::AllocaScopeOp>,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::memref::AllocaScopeReturnOp>::Impl<mlir::memref::AllocaScopeOp>,mlir::OpTrait::NoRegionArguments<mlir::memref::AllocaScopeOp>,mlir::OpTrait::OpInvariants<mlir::memref::AllocaScopeOp>,mlir::OpTrait::AutomaticAllocationScope<mlir::memref::AllocaScopeOp>,mlir::RegionBranchOpInterface::Trait<mlir::memref::AllocaScopeOp>,mlir::OpTrait::HasRecursiveMemoryEffects<mlir::memref::AllocaScopeOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_26_4(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::memref::AllocaScopeReturnOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::memref::AllocaScopeReturnOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::memref::AllocaScopeReturnOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::memref::AllocaScopeReturnOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::memref::AllocaScopeReturnOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::memref::AllocaScopeOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::memref::AllocaScopeOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::memref::AllocaScopeOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::memref::AllocaScopeOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::memref::AllocaScopeOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::memref::CastOp>,mlir::OpTrait::OneResult<mlir::memref::CastOp>,mlir::OpTrait::OneTypedResult<mlir::BaseMemRefType>::Impl<mlir::memref::CastOp>,mlir::OpTrait::ZeroSuccessors<mlir::memref::CastOp>,mlir::OpTrait::OneOperand<mlir::memref::CastOp>,mlir::OpTrait::OpInvariants<mlir::memref::CastOp>,mlir::CastOpInterface::Trait<mlir::memref::CastOp>,mlir::OpAsmOpInterface::Trait<mlir::memref::CastOp>,mlir::OpTrait::MemRefsNormalizable<mlir::memref::CastOp>,mlir::ConditionallySpeculatable::Trait<mlir::memref::CastOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::memref::CastOp>,mlir::MemoryEffectOpInterface::Trait<mlir::memref::CastOp>,mlir::OpTrait::SameOperandsAndResultShape<mlir::memref::CastOp>,mlir::ViewLikeOpInterface::Trait<mlir::memref::CastOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::ViewLikeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_17_6(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::BaseMemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::ViewLikeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::BaseMemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::BaseMemRefType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::BaseMemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::BaseMemRefType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::CastOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CastOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::CastOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CastOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsAndResultShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultShape>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ViewLikeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ViewLikeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_16_6(v2);
  }
}

void mlir::RegisteredOperationName::Model<mlir::memref::DeallocOp>::Model()
{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffectOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_0_1(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::memref::DimOp>,mlir::OpTrait::OneResult<mlir::memref::DimOp>,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<mlir::memref::DimOp>,mlir::OpTrait::ZeroSuccessors<mlir::memref::DimOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::memref::DimOp>,mlir::OpTrait::OpInvariants<mlir::memref::DimOp>,mlir::OpAsmOpInterface::Trait<mlir::memref::DimOp>,mlir::OpTrait::MemRefsNormalizable<mlir::memref::DimOp>,mlir::ConditionallySpeculatable::Trait<mlir::memref::DimOp>,mlir::MemoryEffectOpInterface::Trait<mlir::memref::DimOp>,mlir::ShapedDimOpInterface::Trait<mlir::memref::DimOp>,mlir::InferTypeOpInterface::Trait<mlir::memref::DimOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::ShapedDimOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ShapedDimOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ShapedDimOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ShapedDimOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ShapedDimOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ShapedDimOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::memref::ExpandShapeOp>,mlir::OpTrait::OneResult<mlir::memref::ExpandShapeOp>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::memref::ExpandShapeOp>,mlir::OpTrait::ZeroSuccessors<mlir::memref::ExpandShapeOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::memref::ExpandShapeOp>,mlir::OpTrait::OpInvariants<mlir::memref::ExpandShapeOp>,mlir::BytecodeOpInterface::Trait<mlir::memref::ExpandShapeOp>,mlir::OpAsmOpInterface::Trait<mlir::memref::ExpandShapeOp>,mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::memref::ExpandShapeOp>,mlir::ConditionallySpeculatable::Trait<mlir::memref::ExpandShapeOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::memref::ExpandShapeOp>,mlir::MemoryEffectOpInterface::Trait<mlir::memref::ExpandShapeOp>,mlir::ViewLikeOpInterface::Trait<mlir::memref::ExpandShapeOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::ReifyRankedShapedTypeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ViewLikeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ReifyRankedShapedTypeOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ReifyRankedShapedTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ViewLikeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNResults<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNResults<2u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNResults<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNResults<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::InferTypeOpAdaptor<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::InferTypeOpAdaptor>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::InferTypeOpAdaptor<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::InferTypeOpAdaptor>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::BaseMemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultShape,mlir::ViewLikeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsAndResultElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::memref::ReinterpretCastOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::OffsetSizeAndStrideOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_24_4(v2);
  }
}

void mlir::OpInterface<mlir::OffsetSizeAndStrideOpInterface,mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::OffsetSizeAndStrideOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_24_4(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::ViewLikeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OffsetSizeAndStrideOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OffsetSizeAndStrideOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::memref::LoadOp::rewire(mlir::memref::LoadOp *a1, uint64_t a2, uint64_t *a3)
{
  v21 = *MEMORY[0x1E69E9840];
  mlir::Attribute::getContext((*a1 + 24));
  ODSOperandIndexAndLength = mlir::memref::LoadOp::getODSOperandIndexAndLength(a1, 1u);
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    v6 = *(*a1 + 72);
  }

  else
  {
    v6 = 0;
  }

  OUTLINED_FUNCTION_1_8(ODSOperandIndexAndLength, v6, v19[0]);
  OUTLINED_FUNCTION_5_8(*(*(*a1 + 72) + 24), v19[0], v19[1]);
  v7 = *a3;
  v8 = *(a3 + 4);
  if (!v8)
  {
LABEL_8:
    v10 = v7 + 24 * v8;
    goto LABEL_9;
  }

  OUTLINED_FUNCTION_0_6();
  if (!v11)
  {
    while (v9 != -4096)
    {
      OUTLINED_FUNCTION_0_6();
      if (v11)
      {
        goto LABEL_9;
      }
    }

    goto LABEL_8;
  }

LABEL_9:
  v12 = *(v10 + 8);
  v13 = *(*a1 + 72);
  v14 = v13[1];
  if (v14)
  {
    v15 = *v13;
    *v14 = *v13;
    if (v15)
    {
      *(v15 + 8) = v14;
    }
  }

  v13[3] = v12;
  v13[1] = v12;
  v16 = *v12;
  *v13 = *v12;
  if (v16)
  {
    *(v16 + 8) = v13;
  }

  OUTLINED_FUNCTION_4_7(v12);
  mlir::memref::LoadOp::getIndicesMutable(v17);
  mlir::MutableOperandRange::clear(v19);
  if (v20 != a3 + 4)
  {
    free(v20);
  }

  return 0;
}

uint64_t mlir::memref::StoreOp::rewire(mlir::memref::StoreOp *a1, uint64_t a2, uint64_t *a3)
{
  v22 = *MEMORY[0x1E69E9840];
  mlir::Attribute::getContext((*a1 + 24));
  ODSOperandIndexAndLength = mlir::memref::StoreOp::getODSOperandIndexAndLength(a1, 2u);
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    v6 = *(*a1 + 72);
  }

  else
  {
    v6 = 0;
  }

  OUTLINED_FUNCTION_1_8(ODSOperandIndexAndLength, v6, v20[0]);
  OUTLINED_FUNCTION_5_8(*(*(*a1 + 72) + 56), v20[0], v20[1]);
  v7 = *a3;
  v8 = *(a3 + 4);
  if (!v8)
  {
LABEL_8:
    v10 = v7 + 24 * v8;
    goto LABEL_9;
  }

  OUTLINED_FUNCTION_0_6();
  if (!v11)
  {
    while (v9 != -4096)
    {
      OUTLINED_FUNCTION_0_6();
      if (v11)
      {
        goto LABEL_9;
      }
    }

    goto LABEL_8;
  }

LABEL_9:
  v12 = *(v10 + 8);
  v13 = *(*a1 + 72);
  v14 = v13 + 4;
  v15 = v13[5];
  if (v15)
  {
    v16 = *v14;
    *v15 = *v14;
    if (v16)
    {
      *(v16 + 8) = v15;
    }
  }

  v13[7] = v12;
  v13[5] = v12;
  v17 = *v12;
  v13[4] = *v12;
  if (v17)
  {
    *(v17 + 8) = v14;
  }

  OUTLINED_FUNCTION_4_7(v12);
  mlir::memref::StoreOp::getIndicesMutable(v18);
  mlir::MutableOperandRange::clear(v20);
  if (v21 != a3 + 4)
  {
    free(v21);
  }

  return 0;
}

void mlir::memref::AllocaOp::destructure()
{
  {
    v0 = llvm::getTypeName<mlir::DestructurableTypeInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_2_9(v2);
  }
}

void mlir::OpBuilder::create<mlir::memref::AllocaOp,mlir::MemRefType &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "memref.alloca";
  *(a2 + 24) = 13;
}

void mlir::OpInterface<mlir::DestructurableAllocationOpInterface,mlir::detail::DestructurableAllocationOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::DestructurableAllocationOpInterface>();
    mlir::detail::TypeIDResolver<mlir::DestructurableAllocationOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::memref::foldMemRefCast()
{
  OUTLINED_FUNCTION_186();
  if ((*(v0 + 46) & 0x80) != 0)
  {
    v2 = *(v0 + 68);
    if (v2)
    {
      v3 = v1;
      v4 = *(v0 + 72);
      v5 = 32 * v2;
      do
      {
        OUTLINED_FUNCTION_86_0();
        DefiningOp = mlir::Value::getDefiningOp(v6);
        if (DefiningOp)
        {
          if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::CastOp,void>::id && *(v4 + 24) != v3)
          {
            OUTLINED_FUNCTION_13_8();
            if (v9 != &mlir::detail::TypeIDResolver<mlir::UnrankedMemRefType,void>::id)
            {
              if (*(v4 + 8))
              {
                OUTLINED_FUNCTION_182();
                if (v11)
                {
                  *(v11 + 8) = v10;
                }
              }

              OUTLINED_FUNCTION_99_0(v8);
              if (v13)
              {
                *(v13 + 8) = v4;
              }

              *v12 = v4;
            }
          }
        }

        v4 += 32;
        v5 -= 32;
      }

      while (v5);
    }
  }

  OUTLINED_FUNCTION_185();
}

void mlir::memref::CastOp::fold()
{
  OUTLINED_FUNCTION_186();
  OUTLINED_FUNCTION_131();
  if (v3 < 0 && *(v2 + 68))
  {
    OUTLINED_FUNCTION_180();
    do
    {
      while (1)
      {
        OUTLINED_FUNCTION_86_0();
        if (mlir::Value::getDefiningOp(v4))
        {
          OUTLINED_FUNCTION_43_2();
          if (v5)
          {
            if (*(v0 + 24))
            {
              OUTLINED_FUNCTION_13_8();
              if (v7 != &mlir::detail::TypeIDResolver<mlir::UnrankedMemRefType,void>::id)
              {
                break;
              }
            }
          }
        }

        v0 += 32;
        if (v0 == v1)
        {
          goto LABEL_18;
        }
      }

      if (*(v0 + 8))
      {
        OUTLINED_FUNCTION_182();
        if (v9)
        {
          *(v9 + 8) = v8;
        }
      }

      OUTLINED_FUNCTION_99_0(v6);
      if (v11)
      {
        *(v11 + 8) = v0;
      }

      OUTLINED_FUNCTION_181(v10);
    }

    while (!v5);
  }

LABEL_18:
  OUTLINED_FUNCTION_185();
}

void mlir::memref::CopyOp::fold()
{
  OUTLINED_FUNCTION_186();
  OUTLINED_FUNCTION_131();
  if (v1 < 0)
  {
    v2 = *(v0 + 68);
    if (v2)
    {
      v3 = *(v0 + 72);
      v4 = 32 * v2;
      do
      {
        OUTLINED_FUNCTION_86_0();
        if (mlir::Value::getDefiningOp(v5))
        {
          OUTLINED_FUNCTION_43_2();
          v8 = v7 ? v6 : 0;
          if (v8 && mlir::memref::CastOp::canFoldIntoConsumerOp(v8))
          {
            v9 = *(*(v8 + 72) + 24);
            if (*(v3 + 8))
            {
              OUTLINED_FUNCTION_182();
              if (v11)
              {
                *(v11 + 8) = v10;
              }
            }

            OUTLINED_FUNCTION_99_0(v9);
            if (v13)
            {
              *(v13 + 8) = v3;
            }

            *v12 = v3;
          }
        }

        v3 += 32;
        v4 -= 32;
      }

      while (v4);
    }
  }

  OUTLINED_FUNCTION_185();
}

void mlir::memref::DeallocOp::fold()
{
  OUTLINED_FUNCTION_186();
  OUTLINED_FUNCTION_131();
  if (v2 < 0 && *(v1 + 68))
  {
    OUTLINED_FUNCTION_97_0();
    do
    {
      OUTLINED_FUNCTION_86_0();
      if (mlir::Value::getDefiningOp(v3))
      {
        OUTLINED_FUNCTION_43_2();
        if (v4)
        {
          if (*(v0 + 24))
          {
            OUTLINED_FUNCTION_13_8();
            if (v6 != &mlir::detail::TypeIDResolver<mlir::UnrankedMemRefType,void>::id)
            {
              if (*(v0 + 8))
              {
                OUTLINED_FUNCTION_156();
                if (v8)
                {
                  *(v8 + 8) = v7;
                }
              }

              OUTLINED_FUNCTION_74_0(v5);
              if (v10)
              {
                *(v10 + 8) = v0;
              }

              OUTLINED_FUNCTION_178(v9);
            }
          }
        }
      }

      OUTLINED_FUNCTION_179();
    }

    while (!v4);
  }

  OUTLINED_FUNCTION_185();
}

BOOL mlir::memref::DmaStartOp::isStrided(mlir::memref::DmaStartOp *this)
{
  v2 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(v2 + 68);
  }

  else
  {
    v3 = 0;
  }

  v15 = *(*(*(v2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue(&v15);
  v5 = v4;
  v15 = *(*(*(*this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue(&v15);
  v15 = *(*(*(*this + 72) + 32 * (v6 + 1) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue(&v15);
  v8 = v7;
  v15 = *(*(*(*this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue(&v15);
  v10 = v9;
  v15 = *(*(*(*this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue(&v15);
  v15 = *(*(*(*this + 72) + 32 * (v11 + 1) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue(&v15);
  v15 = *(*(*(*this + 72) + 32 * (v10 + v12 + 3) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue(&v15);
  return v3 != v5 + v8 + v13 + 4;
}

uint64_t mlir::memref::DmaStartOp::getStride(mlir::memref::DmaStartOp *this)
{
  if (!mlir::memref::DmaStartOp::isStrided(this))
  {
    return 0;
  }

  v2 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = (*(v2 + 68) - 2);
  }

  else
  {
    v3 = 4294967294;
  }

  return *(*(v2 + 72) + 32 * v3 + 24);
}

uint64_t mlir::memref::DmaStartOp::getNumElementsPerStride(mlir::memref::DmaStartOp *this)
{
  if (!mlir::memref::DmaStartOp::isStrided(this))
  {
    return 0;
  }

  v2 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = (*(v2 + 68) - 1);
  }

  else
  {
    v3 = 0xFFFFFFFFLL;
  }

  return *(*(v2 + 72) + 32 * v3 + 24);
}

BOOL mlir::memref::DmaWaitOp::verify(mlir::memref::DmaWaitOp *this)
{
  v89 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_131();
  if (v3 < 0)
  {
    v4 = *(v2 + 68) - 2;
  }

  else
  {
    v4 = -2;
  }

  OUTLINED_FUNCTION_27_5();
  OUTLINED_FUNCTION_176();
  mlir::ArrayAttr::getValue(v5);
  v7 = v6;
  if (v4 == v6)
  {
    return 1;
  }

  LOWORD(v74) = 257;
  mlir::OpState::emitOpError(this, &v70, &v78);
  if (v78)
  {
    OUTLINED_FUNCTION_37_0();
    v76 = "expected tagIndices to have the same number of elements as the tagMemRef rank, expected ";
    v77 = 88;
    OUTLINED_FUNCTION_4_5();
    if (v10)
    {
      OUTLINED_FUNCTION_5_3();
      OUTLINED_FUNCTION_3_1(&v81, &v78);
      v9 = v81;
    }

    OUTLINED_FUNCTION_0_3(v9);
    OUTLINED_FUNCTION_13_6();
    if (v11)
    {
      LODWORD(v75) = 5;
      v76 = v7;
      OUTLINED_FUNCTION_10_7();
      if (v10)
      {
        OUTLINED_FUNCTION_13_4();
        if (v59 <= v60 && (v58 & 1) != 0)
        {
          OUTLINED_FUNCTION_5_5(v57, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82);
        }

        else
        {
          OUTLINED_FUNCTION_5_5(v57, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82);
          OUTLINED_FUNCTION_23_2();
        }
      }

      OUTLINED_FUNCTION_3_6(v12, v13, v14, v15, v16, v17, v18, v19, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82);
      LODWORD(v82) = v20 + 1;
      if (v78)
      {
        LODWORD(v75) = 3;
        v76 = ", but got ";
        v77 = 10;
        OUTLINED_FUNCTION_10_7();
        if (v10)
        {
          OUTLINED_FUNCTION_13_4();
          if (v63 <= v64 && (v62 & 1) != 0)
          {
            OUTLINED_FUNCTION_5_5(v61, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82);
          }

          else
          {
            OUTLINED_FUNCTION_5_5(v61, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82);
            OUTLINED_FUNCTION_23_2();
          }
        }

        OUTLINED_FUNCTION_3_6(v21, v22, v23, v24, v25, v26, v27, v28, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82);
        LODWORD(v82) = v29 + 1;
        if (v78)
        {
          LODWORD(v75) = 5;
          v76 = v4;
          OUTLINED_FUNCTION_10_7();
          if (v10)
          {
            OUTLINED_FUNCTION_13_4();
            if (v67 <= v68 && (v66 & 1) != 0)
            {
              OUTLINED_FUNCTION_5_5(v65, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82);
            }

            else
            {
              OUTLINED_FUNCTION_5_5(v65, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82);
              OUTLINED_FUNCTION_23_2();
            }
          }

          OUTLINED_FUNCTION_3_6(v30, v31, v32, v33, v34, v35, v36, v37, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82);
          LODWORD(v82) = v38 + 1;
        }
      }
    }
  }

  v8 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v78);
  if (v78)
  {
    mlir::InFlightDiagnostic::report(&v78);
  }

  if (v88 == 1)
  {
    v46 = v87;
    if (v87 != &v88)
    {
      free(v87);
    }

    v47 = v85;
    if (v85)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v50)
      {
        do
        {
          v48 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v48 - 1);
        }

        while (v48 != v47);
        v49 = v85;
      }

      v86 = v47;
      operator delete(v49);
    }

    v51 = __p;
    if (__p)
    {
      v52 = v84;
      v53 = OUTLINED_FUNCTION_16_5();
      if (!v50)
      {
        do
        {
          v54 = OUTLINED_FUNCTION_17_5();
          if (v54)
          {
            operator delete[](v54);
          }
        }

        while (v52 != v51);
        v53 = __p;
      }

      v84 = v51;
      operator delete(v53);
    }

    v55 = OUTLINED_FUNCTION_12_5(v46, v39, v40, v41, v42, v43, v44, v45, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81);
    if (!v50)
    {
      free(v55);
    }
  }

  return v8;
}

uint64_t mlir::memref::GenericAtomicRMWOp::print(mlir::memref::GenericAtomicRMWOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v6, v7);
  }

  OUTLINED_FUNCTION_12_7();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v10 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v11, "[", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v11, v12);
  }

  OUTLINED_FUNCTION_47_0();
  if (v14 < 0)
  {
    OUTLINED_FUNCTION_130_0();
    v16 = v15 - 1;
  }

  else
  {
    v16 = -1;
  }

  (*(*v2 + 16))(v2);
  if (v16)
  {
    OUTLINED_FUNCTION_104();
    (*(v17 + 160))(v2);
    for (i = v16 - 1; i; --i)
    {
      OUTLINED_FUNCTION_30_2();
      if (!v13 & v8)
      {
        OUTLINED_FUNCTION_21_5(v19);
      }

      else
      {
        OUTLINED_FUNCTION_42_0();
      }

      OUTLINED_FUNCTION_33_1();
      (*(v20 + 160))(v2);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v23 > 3)
  {
    OUTLINED_FUNCTION_160(v22);
    *(v25 + 32) = v24 + 4;
  }

  else
  {
    llvm::raw_ostream::write(v21, "] : ", 4uLL);
  }

  OUTLINED_FUNCTION_11_5();
  v26 = OUTLINED_FUNCTION_12_4();
  v27(v26);
  OUTLINED_FUNCTION_104();
  (*(v28 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v29, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v29, v30);
  }

  OUTLINED_FUNCTION_105_0();
  OUTLINED_FUNCTION_104();
  (*(v31 + 224))(v2);
  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_104();
  return (*(v32 + 192))(v2, v33, v34, 0, 0);
}

BOOL mlir::memref::LoadOp::verify(mlir::memref::LoadOp *this)
{
  v66 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_131();
  if (v3 < 0)
  {
    v4 = *(v2 + 68) - 1;
  }

  else
  {
    v4 = -1;
  }

  OUTLINED_FUNCTION_27_5();
  OUTLINED_FUNCTION_176();
  mlir::ArrayAttr::getValue(v5);
  if (v4 == v6)
  {
    return 1;
  }

  v47 = "incorrect number of indices for load, expected ";
  LOWORD(v51) = 259;
  mlir::OpState::emitOpError(this, &v47, &v55);
  OUTLINED_FUNCTION_27_5();
  v46 = v8 & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue(&v46);
  if (v55)
  {
    LODWORD(v52) = 2;
    v53 = v9;
    OUTLINED_FUNCTION_4_5();
    if (v11)
    {
      OUTLINED_FUNCTION_5_3();
      OUTLINED_FUNCTION_3_1(&v58, &v55);
      v10 = v58;
    }

    OUTLINED_FUNCTION_0_3(v10);
    OUTLINED_FUNCTION_13_6();
    if (v12)
    {
      LODWORD(v52) = 3;
      v53 = " but got ";
      v54 = 9;
      OUTLINED_FUNCTION_10_7();
      if (v11)
      {
        OUTLINED_FUNCTION_13_4();
        if (v44 <= v45 && (v43 & 1) != 0)
        {
          OUTLINED_FUNCTION_164(v42, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
        }

        else
        {
          OUTLINED_FUNCTION_164(v42, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
          OUTLINED_FUNCTION_23_2();
        }
      }

      OUTLINED_FUNCTION_3_6(v13, v14, v15, v16, v17, v18, v19, v20, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
      LODWORD(v59) = v21 + 1;
    }
  }

  if ((*(*this + 46) & 0x80) != 0)
  {
    v22 = *(*this + 68) - 1;
  }

  else
  {
    v22 = -1;
  }

  if (v55)
  {
    LODWORD(v52) = 5;
    v53 = v22;
    OUTLINED_FUNCTION_4_5();
    if (v11)
    {
      OUTLINED_FUNCTION_3_1(&v58, &v55);
      v23 = v58;
    }

    OUTLINED_FUNCTION_0_3(v23);
    LODWORD(v59) = v59 + 1;
  }

  v7 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v55);
  if (v55)
  {
    mlir::InFlightDiagnostic::report(&v55);
  }

  if (v65 == 1)
  {
    v31 = v64;
    if (v64 != &v65)
    {
      free(v64);
    }

    v32 = v62;
    if (v62)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v35)
      {
        do
        {
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v33 - 1);
        }

        while (v33 != v32);
        v34 = v62;
      }

      v63 = v32;
      operator delete(v34);
    }

    v36 = __p;
    if (__p)
    {
      v37 = v61;
      v38 = OUTLINED_FUNCTION_16_5();
      if (!v35)
      {
        do
        {
          v39 = OUTLINED_FUNCTION_17_5();
          if (v39)
          {
            operator delete[](v39);
          }
        }

        while (v37 != v36);
        v38 = __p;
      }

      v61 = v36;
      operator delete(v38);
    }

    v40 = OUTLINED_FUNCTION_12_5(v31, v24, v25, v26, v27, v28, v29, v30, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58);
    if (!v35)
    {
      free(v40);
    }
  }

  return v7;
}

void mlir::memref::LoadOp::fold()
{
  OUTLINED_FUNCTION_186();
  OUTLINED_FUNCTION_131();
  if (v5 < 0 && *(v4 + 68))
  {
    OUTLINED_FUNCTION_180();
    do
    {
      while (1)
      {
        OUTLINED_FUNCTION_86_0();
        if (!mlir::Value::getDefiningOp(v6))
        {
          break;
        }

        OUTLINED_FUNCTION_43_2();
        if (!v7)
        {
          break;
        }

        if (!*(v1 + 24))
        {
          break;
        }

        OUTLINED_FUNCTION_13_8();
        if (v9 == &mlir::detail::TypeIDResolver<mlir::UnrankedMemRefType,void>::id)
        {
          break;
        }

        if (*(v1 + 8))
        {
          OUTLINED_FUNCTION_182();
          if (v11)
          {
            *(v11 + 8) = v10;
          }
        }

        OUTLINED_FUNCTION_99_0(v8);
        if (v13)
        {
          *(v13 + 8) = v1;
        }

        OUTLINED_FUNCTION_181(v12);
        if (v7)
        {
          goto LABEL_20;
        }
      }

      v1 += 32;
    }

    while (v1 != v2);
    if ((v3 & 1) == 0)
    {
      goto LABEL_21;
    }

LABEL_20:
    OUTLINED_FUNCTION_28_4(*v0);
  }

LABEL_21:
  OUTLINED_FUNCTION_185();
}

uint64_t mlir::memref::PrefetchOp::print(mlir::memref::PrefetchOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v67 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_17_2();
  if (v8)
  {
    llvm::raw_ostream::write(v6, " ", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v6, v7);
  }

  OUTLINED_FUNCTION_12_7();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v10 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v13)
  {
    llvm::raw_ostream::write(v11, 91);
  }

  else
  {
    *(v11 + 4) = v12 + 1;
    *v12 = 91;
  }

  OUTLINED_FUNCTION_47_0();
  if (v14 < 0)
  {
    OUTLINED_FUNCTION_130_0();
    v16 = v15 - 1;
  }

  else
  {
    v16 = -1;
  }

  (*(*v2 + 16))(v2);
  if (v16)
  {
    OUTLINED_FUNCTION_104();
    (*(v17 + 160))(v2);
    for (i = v16 - 1; i; --i)
    {
      OUTLINED_FUNCTION_30_2();
      if (!v8 & v13)
      {
        OUTLINED_FUNCTION_21_5(v19);
      }

      else
      {
        OUTLINED_FUNCTION_42_0();
      }

      OUTLINED_FUNCTION_33_1();
      (*(v20 + 160))(v2);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v13)
  {
    llvm::raw_ostream::write(v21, 93);
  }

  else
  {
    *(v21 + 4) = v22 + 1;
    *v22 = 93;
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_25_2();
  if (!v8 & v13)
  {
    OUTLINED_FUNCTION_8_3(v23, v24);
  }

  else
  {
    llvm::raw_ostream::write(v23, ", ", 2uLL);
  }

  OUTLINED_FUNCTION_19_5();
  __p[0] = *(v25 + 72);
  Value = mlir::BoolAttr::getValue(__p);
  OUTLINED_FUNCTION_104();
  v28 = (*(v27 + 16))(v2);
  v29 = v28;
  if (Value)
  {
    v30 = "write";
  }

  else
  {
    v30 = "read";
  }

  if (Value)
  {
    v31 = 5;
  }

  else
  {
    v31 = 4;
  }

  v33 = *(v28 + 24);
  v32 = *(v28 + 32);
  if (v31 <= v33 - v32)
  {
    memcpy(v32, v30, v31);
    v29[4] += v31;
  }

  else
  {
    llvm::raw_ostream::write(v29, v30, v31);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v36 > 0xA)
  {
    *(v35 + 7) = 1014592617;
    *v35 = *", locality<";
    v34[4] += 11;
  }

  else
  {
    llvm::raw_ostream::write(v34, ", locality<", 0xBuLL);
  }

  OUTLINED_FUNCTION_19_5();
  v63 = *(v37 + 80);
  mlir::IntegerAttr::getValue(&v63, __p);
  if (LODWORD(__p[1]) > 0x40)
  {
    v38 = *__p[0];
    operator delete[](__p[0]);
  }

  else
  {
    v38 = LODWORD(__p[0]);
  }

  v39 = (*(*v2 + 16))(v2);
  llvm::raw_ostream::operator<<(v39, v38);
  OUTLINED_FUNCTION_104();
  (*(v40 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v43 > 2)
  {
    *(v42 + 2) = 32;
    OUTLINED_FUNCTION_15_4(v41, v42);
  }

  else
  {
    llvm::raw_ostream::write(v41, ">, ", 3uLL);
  }

  OUTLINED_FUNCTION_19_5();
  __p[0] = *(v44 + 64);
  v45 = mlir::BoolAttr::getValue(__p);
  OUTLINED_FUNCTION_104();
  v47 = (*(v46 + 16))(v2);
  v48 = v47;
  if (v45)
  {
    v49 = "data";
  }

  else
  {
    v49 = "instr";
  }

  if (v45)
  {
    v50 = 4;
  }

  else
  {
    v50 = 5;
  }

  v52 = *(v47 + 24);
  v51 = *(v47 + 32);
  if (v50 <= v52 - v51)
  {
    memcpy(v51, v49, v50);
    v48[4] += v50;
  }

  else
  {
    llvm::raw_ostream::write(v48, v49, v50);
  }

  __p[0] = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(__p);
  *__p = xmmword_1E86D2C78;
  v65 = *&off_1E86D2C88;
  v66 = xmmword_1E86D2C98;
  OUTLINED_FUNCTION_104();
  (*(v53 + 192))(v2, v54, v55, __p, 3);
  OUTLINED_FUNCTION_104();
  (*(v56 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v59 > 2)
  {
    *(v58 + 2) = 32;
    OUTLINED_FUNCTION_15_4(v57, v58);
  }

  else
  {
    llvm::raw_ostream::write(v57, " : ", 3uLL);
  }

  OUTLINED_FUNCTION_11_5();
  v60 = OUTLINED_FUNCTION_12_4();
  return v61(v60);
}

BOOL mlir::memref::PrefetchOp::verify(mlir::memref::PrefetchOp *this)
{
  v71 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_131();
  if (v3 < 0)
  {
    v4 = *(v2 + 68);
  }

  else
  {
    v4 = 0;
  }

  OUTLINED_FUNCTION_27_5();
  v46 = v5 & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue(&v46);
  if (v6 + 1 == v4)
  {
    return 1;
  }

  OUTLINED_FUNCTION_60_0();
  mlir::OpState::emitOpError(this, v8, v9);
  v10 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v46);
  v7 = v10;
  if (v46)
  {
    mlir::InFlightDiagnostic::report(&v46);
  }

  if (v70 == 1)
  {
    v18 = OUTLINED_FUNCTION_134(v10, v11, v12, v13, v14, v15, v16, v17, v36, v38, v40, v42, v44, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, __p, v64, v65, v66, v67, v68, v69);
    if (!v26)
    {
      free(v18);
    }

    v27 = v66;
    if (v66)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v26)
      {
        do
        {
          v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v28 - 1);
        }

        while (v28 != v27);
        v29 = v66;
      }

      v67 = v27;
      operator delete(v29);
    }

    v30 = __p;
    if (__p)
    {
      v31 = v64;
      v32 = OUTLINED_FUNCTION_16_5();
      if (!v26)
      {
        do
        {
          v33 = OUTLINED_FUNCTION_17_5();
          if (v33)
          {
            operator delete[](v33);
          }
        }

        while (v31 != v30);
        v32 = __p;
      }

      v64 = v30;
      operator delete(v32);
    }

    v34 = OUTLINED_FUNCTION_89_0(v18, v19, v20, v21, v22, v23, v24, v25, v37, v39, v41, v43, v45, v46, v47, v48, v49);
    if (!v26)
    {
      free(v34);
    }
  }

  return v7;
}

uint64_t mlir::memref::ExpandShapeOp::reifyResultShapes(uint64_t *a1, uint64_t **a2, uint64_t a3)
{
  v16[6] = *MEMORY[0x1E69E9840];
  v15[0] = *(*a1 + 16 * ((*(*a1 + 44) >> 23) & 1) + 72);
  v6 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(v15);
  v8 = v7;
  v9 = *a1;
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    v10 = *(v9 + 68);
    v11 = *(v9 + 72);
    v12 = v10 - 1;
  }

  else
  {
    v11 = 0;
    v12 = -1;
  }

  mlir::ValueRange::ValueRange(v14, v11 + 32, v12);
  mlir::getMixedValues(v6, v8, v14[0], v14[1], a2, v15);
  llvm::SmallVectorImpl<llvm::SmallVector<mlir::OpFoldResult,6u>>::assign(a3, v15, 1);
  if (v15[0] != v16)
  {
    free(v15[0]);
  }

  return 1;
}

BOOL mlir::memref::StoreOp::verify(mlir::memref::StoreOp *this)
{
  v71 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_131();
  if (v3 < 0)
  {
    v4 = *(v2 + 68);
  }

  else
  {
    v4 = 0;
  }

  OUTLINED_FUNCTION_177();
  v46 = v5;
  mlir::ArrayAttr::getValue(&v46);
  if (v6 + 2 == v4)
  {
    return 1;
  }

  OUTLINED_FUNCTION_60_0();
  mlir::OpState::emitOpError(this, v8, v9);
  v10 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v46);
  v7 = v10;
  if (v46)
  {
    mlir::InFlightDiagnostic::report(&v46);
  }

  if (v70 == 1)
  {
    v18 = OUTLINED_FUNCTION_134(v10, v11, v12, v13, v14, v15, v16, v17, v36, v38, v40, v42, v44, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, __p, v64, v65, v66, v67, v68, v69);
    if (!v26)
    {
      free(v18);
    }

    v27 = v66;
    if (v66)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v26)
      {
        do
        {
          v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v28 - 1);
        }

        while (v28 != v27);
        v29 = v66;
      }

      v67 = v27;
      operator delete(v29);
    }

    v30 = __p;
    if (__p)
    {
      v31 = v64;
      v32 = OUTLINED_FUNCTION_16_5();
      if (!v26)
      {
        do
        {
          v33 = OUTLINED_FUNCTION_17_5();
          if (v33)
          {
            operator delete[](v33);
          }
        }

        while (v31 != v30);
        v32 = __p;
      }

      v64 = v30;
      operator delete(v32);
    }

    v34 = OUTLINED_FUNCTION_89_0(v18, v19, v20, v21, v22, v23, v24, v25, v37, v39, v41, v43, v45, v46, v47, v48, v49);
    if (!v26)
    {
      free(v34);
    }
  }

  return v7;
}

void mlir::memref::StoreOp::fold()
{
  OUTLINED_FUNCTION_186();
  OUTLINED_FUNCTION_131();
  if (v1 < 0)
  {
    v2 = *(v0 + 68);
    if (v2)
    {
      v3 = *(v0 + 72);
      v4 = *(v3 + 24);
      v5 = 32 * v2;
      do
      {
        OUTLINED_FUNCTION_86_0();
        if (mlir::Value::getDefiningOp(v6))
        {
          OUTLINED_FUNCTION_43_2();
          if (v7)
          {
            if (*(v3 + 24) != v4)
            {
              OUTLINED_FUNCTION_13_8();
              if (v9 != &mlir::detail::TypeIDResolver<mlir::UnrankedMemRefType,void>::id)
              {
                if (*(v3 + 8))
                {
                  OUTLINED_FUNCTION_156();
                  if (v11)
                  {
                    *(v11 + 8) = v10;
                  }
                }

                OUTLINED_FUNCTION_74_0(v8);
                if (v13)
                {
                  *(v13 + 8) = v3;
                }

                *v12 = v3;
              }
            }
          }
        }

        v3 += 32;
        v5 -= 32;
      }

      while (v5);
    }
  }

  OUTLINED_FUNCTION_185();
}

BOOL mlir::memref::AtomicRMWOp::verify(mlir::memref::AtomicRMWOp *this)
{
  v127 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_177();
  v118[0] = v2;
  mlir::ArrayAttr::getValue(v118);
  v4 = *this;
  v5 = *(*this + 44);
  if ((v5 & 0x800000) != 0)
  {
    v6 = (*(v4 + 68) - 2);
  }

  else
  {
    v6 = 4294967294;
  }

  if (v3 == v6)
  {
    v118[0] = *(v4 + 16 * ((v5 >> 23) & 1) + 64);
    Value = mlir::arith::AtomicRMWKindAttr::getValue(v118);
    v8 = 1;
    if (Value > 0xC)
    {
      return v8;
    }

    if (((1 << Value) & 0x1DB2) != 0)
    {
      OUTLINED_FUNCTION_20_5();
      OUTLINED_FUNCTION_58_1();
      if (v10 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      {
        OUTLINED_FUNCTION_144(v9);
        if (v118[0])
        {
          OUTLINED_FUNCTION_37_0();
          v115 = "with kind '";
          v116 = 11;
          OUTLINED_FUNCTION_24_3();
          if (v12)
          {
            OUTLINED_FUNCTION_5_3();
            if (v73 <= v74 && (v72 & 1) != 0)
            {
              OUTLINED_FUNCTION_37_1(v64, v65, v66, v67, v68, v69, v70, v71, v108, v109, v110, v111, v112, v113, v114, v115);
              v11 = v119;
            }

            else
            {
              OUTLINED_FUNCTION_37_1(v64, v65, v66, v67, v68, v69, v70, v71, v108, v109, v110, v111, v112, v113, v114, v115);
              OUTLINED_FUNCTION_104_0();
            }
          }

          OUTLINED_FUNCTION_0_3(v11);
          OUTLINED_FUNCTION_33();
        }

        OUTLINED_FUNCTION_19_5();
        OUTLINED_FUNCTION_183();
        v14 = mlir::arith::AtomicRMWKindAttr::getValue(v13);
        v15 = mlir::arith::stringifyAtomicRMWKind(v14);
        if (v118[0])
        {
          OUTLINED_FUNCTION_146(v15, v16, v17, v18, v19, v20, v21, v22);
          if (v118[0])
          {
            OUTLINED_FUNCTION_37_0();
            v115 = "' expects an integer type";
            v116 = 25;
            OUTLINED_FUNCTION_24_3();
            if (v12)
            {
              OUTLINED_FUNCTION_5_3();
              if (v84 <= v85 && (v83 & 1) != 0)
              {
                OUTLINED_FUNCTION_37_1(v75, v76, v77, v78, v79, v80, v81, v82, v108, v109, v110, v111, v112, v113, v114, v115);
                v23 = v119;
              }

              else
              {
                OUTLINED_FUNCTION_37_1(v75, v76, v77, v78, v79, v80, v81, v82, v108, v109, v110, v111, v112, v113, v114, v115);
                OUTLINED_FUNCTION_104_0();
              }
            }

            OUTLINED_FUNCTION_0_3(v23);
            OUTLINED_FUNCTION_33();
          }
        }

        v8 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v118);
        if (v118[0])
        {
          mlir::InFlightDiagnostic::report(v118);
        }

        if (v126 == 1)
        {
          if (v125 != &v126)
          {
            free(v125);
          }

          v24 = v123;
          if (v123)
          {
            OUTLINED_FUNCTION_15_5();
            if (!v38)
            {
              do
              {
                v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v25 - 1);
              }

              while (v25 != v24);
              v26 = v123;
            }

            v124 = v24;
            operator delete(v26);
          }

          v27 = __p;
          if (!__p)
          {
            goto LABEL_47;
          }

          v28 = v122;
          v29 = OUTLINED_FUNCTION_16_5();
          if (v38)
          {
LABEL_46:
            v122 = v27;
            operator delete(v29);
LABEL_47:
            if (v119 != &v120)
            {
              free(v119);
            }

            return v8;
          }

          do
          {
            v30 = OUTLINED_FUNCTION_17_5();
            if (v30)
            {
              operator delete[](v30);
            }
          }

          while (v28 != v27);
LABEL_45:
          v29 = __p;
          goto LABEL_46;
        }
      }
    }

    else if (((1 << Value) & 0x249) != 0)
    {
      OUTLINED_FUNCTION_20_5();
      OUTLINED_FUNCTION_58_1();
      if (v37 != &mlir::detail::TypeIDResolver<mlir::Float4E2M1FNType,void>::id)
      {
        v38 = v37 == &mlir::detail::TypeIDResolver<mlir::Float6E2M3FNType,void>::id || v37 == &mlir::detail::TypeIDResolver<mlir::Float6E3M2FNType,void>::id;
        if (!v38 && v37 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id && v37 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3Type,void>::id && v37 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id && v37 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id && v37 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id && v37 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id && v37 != &mlir::detail::TypeIDResolver<mlir::Float8E3M4Type,void>::id && v37 != &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id && v37 != &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id && v37 != &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id && v37 != &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id && v37 != &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id && v37 != &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id && v37 != &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
        {
          OUTLINED_FUNCTION_144(v36);
          if (v118[0])
          {
            OUTLINED_FUNCTION_37_0();
            v115 = "with kind '";
            v116 = 11;
            OUTLINED_FUNCTION_24_3();
            if (v12)
            {
              OUTLINED_FUNCTION_5_3();
              if (v95 <= v96 && (v94 & 1) != 0)
              {
                OUTLINED_FUNCTION_37_1(v86, v87, v88, v89, v90, v91, v92, v93, v108, v109, v110, v111, v112, v113, v114, v115);
                v46 = v119;
              }

              else
              {
                OUTLINED_FUNCTION_37_1(v86, v87, v88, v89, v90, v91, v92, v93, v108, v109, v110, v111, v112, v113, v114, v115);
                OUTLINED_FUNCTION_104_0();
              }
            }

            OUTLINED_FUNCTION_0_3(v46);
            OUTLINED_FUNCTION_33();
          }

          OUTLINED_FUNCTION_19_5();
          OUTLINED_FUNCTION_183();
          v48 = mlir::arith::AtomicRMWKindAttr::getValue(v47);
          v49 = mlir::arith::stringifyAtomicRMWKind(v48);
          if (v118[0])
          {
            OUTLINED_FUNCTION_146(v49, v50, v51, v52, v53, v54, v55, v56);
            if (v118[0])
            {
              OUTLINED_FUNCTION_37_0();
              v115 = "' expects a floating-point type";
              v116 = 31;
              OUTLINED_FUNCTION_24_3();
              if (v12)
              {
                OUTLINED_FUNCTION_5_3();
                if (v106 <= v107 && (v105 & 1) != 0)
                {
                  OUTLINED_FUNCTION_37_1(v97, v98, v99, v100, v101, v102, v103, v104, v108, v109, v110, v111, v112, v113, v114, v115);
                  v57 = v119;
                }

                else
                {
                  OUTLINED_FUNCTION_37_1(v97, v98, v99, v100, v101, v102, v103, v104, v108, v109, v110, v111, v112, v113, v114, v115);
                  OUTLINED_FUNCTION_104_0();
                }
              }

              OUTLINED_FUNCTION_0_3(v57);
              OUTLINED_FUNCTION_33();
            }
          }

          v8 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v118);
          if (v118[0])
          {
            mlir::InFlightDiagnostic::report(v118);
          }

          if (v126 == 1)
          {
            if (v125 != &v126)
            {
              free(v125);
            }

            v58 = v123;
            if (v123)
            {
              OUTLINED_FUNCTION_15_5();
              if (!v38)
              {
                do
                {
                  v59 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v59 - 1);
                }

                while (v59 != v58);
                v60 = v123;
              }

              v124 = v58;
              operator delete(v60);
            }

            v27 = __p;
            if (!__p)
            {
              goto LABEL_47;
            }

            v61 = v122;
            v29 = OUTLINED_FUNCTION_16_5();
            if (v38)
            {
              goto LABEL_46;
            }

            do
            {
              v62 = OUTLINED_FUNCTION_17_5();
              if (v62)
              {
                operator delete[](v62);
              }
            }

            while (v61 != v27);
            goto LABEL_45;
          }
        }
      }
    }
  }

  else
  {
    v114 = "expects the number of subscripts to be equal to memref rank";
    v117 = 259;
    mlir::OpState::emitOpError(this, &v114, v118);
    v8 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v118);
    if (v118[0])
    {
      mlir::InFlightDiagnostic::report(v118);
    }

    if (v126 == 1)
    {
      if (v125 != &v126)
      {
        free(v125);
      }

      v31 = v123;
      if (v123)
      {
        OUTLINED_FUNCTION_15_5();
        if (!v38)
        {
          do
          {
            v32 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v32 - 1);
          }

          while (v32 != v31);
          v33 = v123;
        }

        v124 = v31;
        operator delete(v33);
      }

      v27 = __p;
      if (!__p)
      {
        goto LABEL_47;
      }

      v34 = v122;
      v29 = OUTLINED_FUNCTION_16_5();
      if (v38)
      {
        goto LABEL_46;
      }

      do
      {
        v35 = OUTLINED_FUNCTION_17_5();
        if (v35)
        {
          operator delete[](v35);
        }
      }

      while (v34 != v27);
      goto LABEL_45;
    }
  }

  return v8;
}

uint64_t mlir::memref::LoadOp::getODSOperandIndexAndLength(mlir::memref::LoadOp *this, unsigned int a2)
{
  v2 = &dword_1E097B0E8;
  if (a2)
  {
    v3 = a2;
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
      goto LABEL_15;
    }

    if (a2 >= 0x20)
    {
      *v6.i64 = OUTLINED_FUNCTION_22_4();
      do
      {
        *v6.i64 = OUTLINED_FUNCTION_14_8(v6);
      }

      while (!v14);
      OUTLINED_FUNCTION_26_5(v6, v7, v8, v9, v10, v11, v12, v13);
      if (v14)
      {
        goto LABEL_17;
      }

      if ((v3 & 0x1C) == 0)
      {
LABEL_15:
        v17 = v2 + v4;
        v18 = v3 - v4;
        do
        {
          v19 = *v17++;
          v5 += v19;
          --v18;
        }

        while (v18);
        goto LABEL_17;
      }
    }

    *v15.i32 = OUTLINED_FUNCTION_82_0();
    do
    {
      *v15.i64 = OUTLINED_FUNCTION_184(v15, v16);
    }

    while (!v14);
    v5 = vaddvq_s32(v15);
    if (v4 != v3)
    {
      goto LABEL_15;
    }
  }

LABEL_17:
  OUTLINED_FUNCTION_87_0();
  if (!v14)
  {
    v20 = v21;
  }

  return OUTLINED_FUNCTION_78_0(v20);
}

uint64_t mlir::memref::LoadOp::getIndicesMutable@<X0>(uint64_t a1@<X8>)
{
  v2 = OUTLINED_FUNCTION_168(a1);
  if (v4 < 0)
  {
    v5 = *(v3 + 68) - 1;
  }

  else
  {
    v5 = -1;
  }

  return OUTLINED_FUNCTION_7_6(v2, v3, 1, v5);
}

void mlir::memref::AllocaScopeReturnOp::print(mlir::memref::AllocaScopeReturnOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v50[4] = *MEMORY[0x1E69E9840];
  v48 = v50;
  v49 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(*v4);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_81_0();
  OUTLINED_FUNCTION_104();
  v5 = OUTLINED_FUNCTION_31_3();
  v6(v5);
  OUTLINED_FUNCTION_47_0();
  if (v8 < 0 && *(v7 + 68))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v11)
    {
      llvm::raw_ostream::write(v9, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v9, v10);
    }

    OUTLINED_FUNCTION_47_0();
    if (v13 < 0)
    {
      v14 = *(v12 + 68);
      v15 = *(v12 + 72);
    }

    else
    {
      v15 = 0;
      v14 = 0;
    }

    v16 = (*(*v2 + 16))(v2);
    if (v14)
    {
      v17 = v16;
      OUTLINED_FUNCTION_104();
      (*(v18 + 160))(v2);
      v19 = v14 - 1;
      if (v19)
      {
        v20 = v15 + 56;
        do
        {
          OUTLINED_FUNCTION_30_2();
          if (!v22 & v11)
          {
            *v21 = 8236;
            *(v17 + 32) += 2;
          }

          else
          {
            OUTLINED_FUNCTION_42_0();
          }

          v20 += 32;
          OUTLINED_FUNCTION_104();
          (*(v23 + 160))(v2);
          --v19;
        }

        while (v19);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v11)
    {
      llvm::raw_ostream::write(v24, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v24, v25);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v22)
    {
      llvm::raw_ostream::write(v26, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v26, v27);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v11)
    {
      llvm::raw_ostream::write(v28, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v28, v29);
    }

    v30 = *v3;
    if ((*(*v3 + 46) & 0x80) != 0)
    {
      v31 = *(v30 + 68);
      v32 = *(v30 + 72);
    }

    else
    {
      v32 = 0;
      v31 = 0;
    }

    v44[0] = v32;
    v44[1] = v31;
    mlir::OperandRange::getTypes(v44, &AttrDictionary);
    v33 = v46;
    v34 = v47;
    if (v46 != v47)
    {
      v35 = AttrDictionary + 32 * v46;
      OUTLINED_FUNCTION_29_4();
      v36 = OUTLINED_FUNCTION_12_4();
      v37(v36);
      if (v33 + 1 != v34)
      {
        v38 = ~v33 + v34;
        v39 = v35 + 56;
        do
        {
          (*(*v2 + 16))(v2);
          OUTLINED_FUNCTION_25_2();
          if (!v22 & v11)
          {
            *v41 = 8236;
            v40[4] += 2;
          }

          else
          {
            llvm::raw_ostream::write(v40, ", ", 2uLL);
          }

          v39 += 32;
          OUTLINED_FUNCTION_29_4();
          v42 = OUTLINED_FUNCTION_12_4();
          v43(v42);
          --v38;
        }

        while (v38);
      }
    }
  }

  if (v48 != v50)
  {
    free(v48);
  }
}

void mlir::memref::ExpandShapeOp::print(mlir::memref::ExpandShapeOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v59[4] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v6, v7);
  }

  OUTLINED_FUNCTION_12_7();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v10 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v11, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v11, v12);
  }

  OUTLINED_FUNCTION_19_5();
  OUTLINED_FUNCTION_104();
  (*(v13 + 48))(v2);
  OUTLINED_FUNCTION_104();
  (*(v14 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v15, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v15, v16);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v19 > 0xB)
  {
    *(v18 + 8) = 1701863784;
    *v18 = *"output_shape";
    v17[4] += 12;
  }

  else
  {
    llvm::raw_ostream::write(v17, "output_shape", 0xCuLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v20, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v20, v21);
  }

  v22 = *v3;
  v23 = *(*v3 + 11);
  if ((v23 & 0x800000) != 0)
  {
    v24 = *(v22 + 72);
    v25 = *(v22 + 68) - 1;
  }

  else
  {
    v24 = 0;
    v25 = -1;
  }

  AttrDictionary = *(v22 + 16 * ((v23 >> 23) & 1) + 72);
  v26 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&AttrDictionary);
  v28 = v27;
  OUTLINED_FUNCTION_44_0();
  mlir::ValueRange::ValueRange(v29, v30, v31);
  mlir::printDynamicIndexList(v2, v22, v24 + 32, v25, v26, v28, 0, 0, v57, v58, 2);
  v57 = v59;
  v59[0] = "reassociation";
  v59[1] = 13;
  v59[2] = "static_output_shape";
  v59[3] = 19;
  v58 = 0x200000002;
  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_81_0();
  OUTLINED_FUNCTION_104();
  v32 = OUTLINED_FUNCTION_31_3();
  v33(v32);
  OUTLINED_FUNCTION_104();
  (*(v34 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v35, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v35, v36);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v39)
  {
    llvm::raw_ostream::write(v37, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v37, v38);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v40, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v40, v41);
  }

  OUTLINED_FUNCTION_11_5();
  v42 = OUTLINED_FUNCTION_12_4();
  v43(v42);
  OUTLINED_FUNCTION_104();
  (*(v44 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v45, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v45, v46);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v49 > 3)
  {
    OUTLINED_FUNCTION_160(v48);
    *(v51 + 32) = v50 + 4;
  }

  else
  {
    llvm::raw_ostream::write(v47, "into", 4uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v52, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v52, v53);
  }

  OUTLINED_FUNCTION_25_5();
  OUTLINED_FUNCTION_41_2();
  v54 = OUTLINED_FUNCTION_12_4();
  v55(v54);
  if (v57 != v59)
  {
    free(v57);
  }
}

uint64_t mlir::memref::PrefetchOp::getODSOperands(mlir::memref::PrefetchOp *this, unsigned int a2, double a3, int32x4_t a4)
{
  if (a2)
  {
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
LABEL_14:
      v26 = a2 - v4;
      v27 = &dword_1E097B0E8 + v4;
      do
      {
        v28 = *v27++;
        v5 += v28;
        --v26;
      }

      while (v26);
      goto LABEL_16;
    }

    if (a2 >= 0x20)
    {
      v6 = 0uLL;
      v7 = "_N_118SimplifyAllocConstIN4mlir6memref7AllocOpEEE";
      v8 = 0uLL;
      v4 = a2 & 0xFFFFFFE0;
      v9 = v4;
      v10 = 0uLL;
      v11 = 0uLL;
      v12 = 0uLL;
      v13 = 0uLL;
      v14 = 0uLL;
      v15 = 0uLL;
      do
      {
        v16 = *v7[-2].i8;
        v17 = vmovl_u8(*v16.i8);
        v18 = vmovl_high_u8(v16);
        v19 = vmovl_u8(*v7);
        v20 = vmovl_high_u8(*v7->i8);
        v11 = vaddw_high_u16(v11, v18);
        v10 = vaddw_u16(v10, *v18.i8);
        v8 = vaddw_high_u16(v8, v17);
        v6 = vaddw_u16(v6, *v17.i8);
        v15 = vaddw_high_u16(v15, v20);
        v14 = vaddw_u16(v14, *v20.i8);
        v13 = vaddw_high_u16(v13, v19);
        v12 = vaddw_u16(v12, *v19.i8);
        v7 += 4;
        v9 -= 32;
      }

      while (v9);
      a4 = vaddq_s32(vaddq_s32(v13, v8), vaddq_s32(v15, v11));
      v5 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v12, v6), vaddq_s32(v14, v10)), a4));
      if (v4 == a2)
      {
        goto LABEL_16;
      }

      if ((a2 & 0x1C) == 0)
      {
        goto LABEL_14;
      }
    }

    else
    {
      v5 = 0;
      v4 = 0;
    }

    v21 = v4;
    v4 = a2 & 0xFFFFFFFC;
    v22 = v5;
    v23 = (&dword_1E097B0E8 + v21);
    v24 = v21 - v4;
    do
    {
      v25 = *v23++;
      a4.i32[0] = v25;
      a4.i64[0] = vmovl_u8(*a4.i8).u64[0];
      v22 = vaddw_u16(v22, *a4.i8);
      v24 += 4;
    }

    while (v24);
    v5 = vaddvq_s32(v22);
    if (v4 == a2)
    {
      goto LABEL_16;
    }

    goto LABEL_14;
  }

  v5 = 0;
LABEL_16:
  v29 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v30 = *(v29 + 68);
    v31 = *(v29 + 72);
  }

  else
  {
    v30 = 0;
    v31 = 0;
  }

  return v31 + 32 * (a2 + (v30 - 2) * v5);
}

uint64_t mlir::memref::ReinterpretCastOp::getODSOperands(mlir::memref::ReinterpretCastOp *this, unsigned int a2)
{
  v2 = *this;
  v3 = *(*this + 44);
  v4 = (v3 >> 23) & 1;
  if (!a2)
  {
    v7 = 0;
    goto LABEL_11;
  }

  if (a2 > 7)
  {
    v5 = a2 & 0xFFFFFFF8;
    v8 = (*this + 16 * v4 + 104);
    v9 = 0uLL;
    v10 = v5;
    v11 = 0uLL;
    do
    {
      v9 = vaddq_s32(v8[-1], v9);
      v11 = vaddq_s32(*v8, v11);
      v8 += 2;
      v10 -= 8;
    }

    while (v10);
    v6 = vaddvq_s32(vaddq_s32(v11, v9));
    if (v5 == a2)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v5 = 0;
    v6 = 0;
  }

  v12 = a2 - v5;
  v13 = (16 * v4 + 4 * v5 + v2 + 88);
  do
  {
    v14 = *v13++;
    v6 += v14;
    --v12;
  }

  while (v12);
LABEL_10:
  v7 = v6;
LABEL_11:
  if ((v3 & 0x800000) != 0)
  {
    v15 = *(v2 + 72);
  }

  else
  {
    v15 = 0;
  }

  return v15 + 32 * v7;
}

void mlir::memref::ReinterpretCastOp::print(mlir::memref::ReinterpretCastOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v142[4] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v3 + 16))(v4);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v5, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v5, v6);
  }

  OUTLINED_FUNCTION_12_7();
  (*(v8 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v9 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v10, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v10, v11);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_25_2();
  if (!v14 & v7)
  {
    OUTLINED_FUNCTION_8_3(v12, v13);
  }

  else
  {
    llvm::raw_ostream::write(v12, "to", 2uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v15, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v15, v16);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v19 > 5)
  {
    *(v18 + 4) = 29797;
    OUTLINED_FUNCTION_160(v18);
    *(v21 + 32) = v20 + 6;
  }

  else
  {
    llvm::raw_ostream::write(v17, "offset", 6uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v22, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v22, v23);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v24, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v24, v25);
  }

  OUTLINED_FUNCTION_155();
  OUTLINED_FUNCTION_142(v26, v111, v118, v125, v132, v139);
  OUTLINED_FUNCTION_90_0();
  OUTLINED_FUNCTION_44_0();
  v30 = mlir::ValueRange::ValueRange(v27, v28, v29);
  OUTLINED_FUNCTION_15_7(v30, v31, v32, v33, v34, v35, v36, v37, v112, v119, v126, v133, v139, v140, v141);
  OUTLINED_FUNCTION_104();
  (*(v38 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v39, ",", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v39, v40);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v41, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v41, v42);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v45 > 4)
  {
    *(v44 + 4) = 115;
    OUTLINED_FUNCTION_160(v44);
    *(v47 + 32) = v46 + 5;
  }

  else
  {
    llvm::raw_ostream::write(v43, "sizes", 5uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v48, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v48, v49);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v50, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v50, v51);
  }

  OUTLINED_FUNCTION_116_0();
  OUTLINED_FUNCTION_125_0(v52, v113, v120, v127, v134, v139);
  OUTLINED_FUNCTION_90_0();
  OUTLINED_FUNCTION_44_0();
  v56 = mlir::ValueRange::ValueRange(v53, v54, v55);
  OUTLINED_FUNCTION_15_7(v56, v57, v58, v59, v60, v61, v62, v63, v114, v121, v128, v135, v139, v140, v141);
  OUTLINED_FUNCTION_104();
  (*(v64 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v65, ",", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v65, v66);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v67, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v67, v68);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v71 > 6)
  {
    *(v70 + 3) = 1936024681;
    OUTLINED_FUNCTION_160(v70);
    *(v73 + 32) = v72 + 7;
  }

  else
  {
    llvm::raw_ostream::write(v69, "strides", 7uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v74, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v74, v75);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v76, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v76, v77);
  }

  OUTLINED_FUNCTION_129_0();
  OUTLINED_FUNCTION_119_0(v78, v115, v122, v129, v136, v139);
  OUTLINED_FUNCTION_90_0();
  OUTLINED_FUNCTION_44_0();
  v82 = mlir::ValueRange::ValueRange(v79, v80, v81);
  OUTLINED_FUNCTION_15_7(v82, v83, v84, v85, v86, v87, v88, v89, v116, v123, v130, v137, v139, v140, v141);
  OUTLINED_FUNCTION_106("operandSegmentSizes", v117, v124, v131, v138, v139, v142, v141, v142[0], v142[1], v142[2], v142[3]);
  OUTLINED_FUNCTION_122_0(v140 + 2 * v141);
  if (v7)
  {
    OUTLINED_FUNCTION_124_0(&v140, v90);
    LODWORD(v90) = v141;
  }

  v139 = OUTLINED_FUNCTION_141(v140 + 2 * v90);
  mlir::ArrayAttr::getValue(&v139);
  OUTLINED_FUNCTION_81_0();
  OUTLINED_FUNCTION_104();
  v91 = OUTLINED_FUNCTION_31_3();
  v92(v91);
  OUTLINED_FUNCTION_104();
  (*(v93 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v94, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v94, v95);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v96, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v96, v97);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v98, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v98, v99);
  }

  OUTLINED_FUNCTION_11_5();
  v100 = OUTLINED_FUNCTION_12_4();
  v101(v100);
  OUTLINED_FUNCTION_104();
  (*(v102 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v103, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v103, v104);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_25_2();
  if (!v14 & v7)
  {
    OUTLINED_FUNCTION_8_3(v105, v106);
  }

  else
  {
    llvm::raw_ostream::write(v105, "to", 2uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v107, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v107, v108);
  }

  OUTLINED_FUNCTION_25_5();
  OUTLINED_FUNCTION_41_2();
  v109 = OUTLINED_FUNCTION_12_4();
  v110(v109);
  if (v140 != v142)
  {
    free(v140);
  }
}

void mlir::memref::ReshapeOp::print(mlir::memref::ReshapeOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v37[4] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v6, v7);
  }

  OUTLINED_FUNCTION_12_7();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v10 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v11, "(", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v11, v12);
  }

  OUTLINED_FUNCTION_38_1();
  (*(v14 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v15 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v16, ")", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v16, v17);
  }

  v35 = v37;
  v36 = 0x200000000;
  v33[0] = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(v33);
  OUTLINED_FUNCTION_81_0();
  OUTLINED_FUNCTION_104();
  v18 = OUTLINED_FUNCTION_31_3();
  v19(v18);
  OUTLINED_FUNCTION_104();
  (*(v20 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v21, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v21, v22);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v23, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v23, v24);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v25, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v25, v26);
  }

  v27 = *v3;
  if ((*(*v3 + 46) & 0x80) != 0)
  {
    v28 = *(v27 + 9);
    v29 = *(v27 + 17);
  }

  else
  {
    v28 = 0;
    v29 = 0;
  }

  v32[0] = v28;
  v32[1] = v29;
  mlir::OperandRange::getTypes(v32, v33);
  OUTLINED_FUNCTION_34_2();
  v34[0] = v30;
  v34[1] = v31;
  mlir::OperandRange::getTypes(v34, v32);
  mlir::AsmPrinter::printFunctionalType<mlir::ValueTypeRange<mlir::OperandRange>,mlir::ValueTypeRange<mlir::ResultRange>>(v2, v33, v32);
  if (v35 != v37)
  {
    free(v35);
  }
}

uint64_t mlir::memref::StoreOp::getODSOperandIndexAndLength(mlir::memref::StoreOp *this, unsigned int a2)
{
  v2 = &dword_1E097B0E8 + 2;
  if (a2)
  {
    v3 = a2;
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
      goto LABEL_15;
    }

    if (a2 >= 0x20)
    {
      *v6.i64 = OUTLINED_FUNCTION_22_4();
      do
      {
        *v6.i64 = OUTLINED_FUNCTION_14_8(v6);
      }

      while (!v14);
      OUTLINED_FUNCTION_26_5(v6, v7, v8, v9, v10, v11, v12, v13);
      if (v14)
      {
        goto LABEL_17;
      }

      if ((v3 & 0x1C) == 0)
      {
LABEL_15:
        v17 = &v2[v4];
        v18 = v3 - v4;
        do
        {
          v19 = *v17++;
          v5 += v19;
          --v18;
        }

        while (v18);
        goto LABEL_17;
      }
    }

    *v15.i32 = OUTLINED_FUNCTION_82_0();
    do
    {
      *v15.i64 = OUTLINED_FUNCTION_184(v15, v16);
    }

    while (!v14);
    v5 = vaddvq_s32(v15);
    if (v4 != v3)
    {
      goto LABEL_15;
    }
  }

LABEL_17:
  OUTLINED_FUNCTION_114_0();
  if (!v14)
  {
    v20 = v21;
  }

  return OUTLINED_FUNCTION_78_0(v20);
}

uint64_t mlir::memref::StoreOp::getIndicesMutable@<X0>(uint64_t a1@<X8>)
{
  v2 = OUTLINED_FUNCTION_168(a1);
  if (v4 < 0)
  {
    v5 = *(v3 + 68) - 2;
  }

  else
  {
    v5 = -2;
  }

  return OUTLINED_FUNCTION_7_6(v2, v3, 2, v5);
}

void mlir::memref::ViewOp::print(mlir::memref::ViewOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v65[4] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v6, v7);
  }

  OUTLINED_FUNCTION_12_7();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v10 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v11, "[", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v11, v12);
  }

  OUTLINED_FUNCTION_38_1();
  (*(v14 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v15 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v16, "]", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v16, v17);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v18, "[", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v18, v19);
  }

  OUTLINED_FUNCTION_47_0();
  if (v20 < 0)
  {
    OUTLINED_FUNCTION_130_0();
    v22 = v21 - 2;
  }

  else
  {
    v22 = -2;
  }

  (*(*v2 + 16))(v2);
  if (v22)
  {
    OUTLINED_FUNCTION_104();
    (*(v23 + 160))(v2);
    for (i = v22 - 1; i; --i)
    {
      OUTLINED_FUNCTION_30_2();
      if (!v13 & v8)
      {
        OUTLINED_FUNCTION_21_5(v25);
      }

      else
      {
        OUTLINED_FUNCTION_42_0();
      }

      OUTLINED_FUNCTION_33_1();
      (*(v26 + 160))(v2);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v27, "]", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v27, v28);
  }

  v63 = v65;
  v64 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_81_0();
  OUTLINED_FUNCTION_104();
  v29 = OUTLINED_FUNCTION_31_3();
  v30(v29);
  OUTLINED_FUNCTION_104();
  (*(v31 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v32, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v32, v33);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v34, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v34, v35);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v36, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v36, v37);
  }

  OUTLINED_FUNCTION_11_5();
  v38 = OUTLINED_FUNCTION_12_4();
  v39(v38);
  OUTLINED_FUNCTION_104();
  (*(v40 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v41, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v41, v42);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_25_2();
  if (!v13 & v8)
  {
    OUTLINED_FUNCTION_8_3(v43, v44);
  }

  else
  {
    llvm::raw_ostream::write(v43, "to", 2uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v45, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v45, v46);
  }

  OUTLINED_FUNCTION_34_2();
  v62[0] = v47;
  v62[1] = v48;
  mlir::OperandRange::getTypes(v62, &AttrDictionary);
  v49 = v60;
  v50 = v61;
  if (v60 != v61)
  {
    v51 = AttrDictionary;
    mlir::detail::OpResultImpl::getNextResultAtOffset(AttrDictionary, v60);
    OUTLINED_FUNCTION_41_2();
    v52 = OUTLINED_FUNCTION_12_4();
    v53(v52);
    for (j = v49 + 1; v50 != j; ++j)
    {
      (*(*v2 + 16))(v2);
      OUTLINED_FUNCTION_25_2();
      if (!v13 & v8)
      {
        *v56 = 8236;
        v55[4] += 2;
      }

      else
      {
        llvm::raw_ostream::write(v55, ", ", 2uLL);
      }

      mlir::detail::OpResultImpl::getNextResultAtOffset(v51, j);
      OUTLINED_FUNCTION_41_2();
      v57 = OUTLINED_FUNCTION_12_4();
      v58(v57);
    }
  }

  if (v63 != v65)
  {
    free(v63);
  }
}

void mlir::memref::SubViewOp::print(mlir::memref::SubViewOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v104[4] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v3 + 16))(v4);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v5, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v5, v6);
  }

  OUTLINED_FUNCTION_12_7();
  (*(v8 + 160))(v2);
  OUTLINED_FUNCTION_155();
  OUTLINED_FUNCTION_142(v9, v73, v80, v87, v94, v101);
  OUTLINED_FUNCTION_90_0();
  OUTLINED_FUNCTION_44_0();
  v13 = mlir::ValueRange::ValueRange(v10, v11, v12);
  OUTLINED_FUNCTION_15_7(v13, v14, v15, v16, v17, v18, v19, v20, v74, v81, v88, v95, v101, v102, v103);
  OUTLINED_FUNCTION_104();
  (*(v21 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v22, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v22, v23);
  }

  OUTLINED_FUNCTION_116_0();
  OUTLINED_FUNCTION_125_0(v24, v75, v82, v89, v96, v101);
  OUTLINED_FUNCTION_90_0();
  OUTLINED_FUNCTION_44_0();
  v28 = mlir::ValueRange::ValueRange(v25, v26, v27);
  OUTLINED_FUNCTION_15_7(v28, v29, v30, v31, v32, v33, v34, v35, v76, v83, v90, v97, v101, v102, v103);
  OUTLINED_FUNCTION_104();
  (*(v36 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v37, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v37, v38);
  }

  OUTLINED_FUNCTION_129_0();
  OUTLINED_FUNCTION_119_0(v39, v77, v84, v91, v98, v101);
  OUTLINED_FUNCTION_90_0();
  OUTLINED_FUNCTION_44_0();
  v43 = mlir::ValueRange::ValueRange(v40, v41, v42);
  OUTLINED_FUNCTION_15_7(v43, v44, v45, v46, v47, v48, v49, v50, v78, v85, v92, v99, v101, v102, v103);
  OUTLINED_FUNCTION_106("operandSegmentSizes", v79, v86, v93, v100, v101, v104, v103, v104[0], v104[1], v104[2], v104[3]);
  OUTLINED_FUNCTION_122_0(v102 + 2 * v103);
  if (v7)
  {
    OUTLINED_FUNCTION_124_0(&v102, v51);
    LODWORD(v51) = v103;
  }

  v101 = OUTLINED_FUNCTION_141(v102 + 2 * v51);
  mlir::ArrayAttr::getValue(&v101);
  OUTLINED_FUNCTION_81_0();
  OUTLINED_FUNCTION_104();
  v52 = OUTLINED_FUNCTION_31_3();
  v53(v52);
  OUTLINED_FUNCTION_104();
  (*(v54 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v55, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v55, v56);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v59)
  {
    llvm::raw_ostream::write(v57, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v57, v58);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v60, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v60, v61);
  }

  OUTLINED_FUNCTION_11_5();
  v62 = OUTLINED_FUNCTION_12_4();
  v63(v62);
  OUTLINED_FUNCTION_104();
  (*(v64 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v65, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v65, v66);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_25_2();
  if (!v59 & v7)
  {
    OUTLINED_FUNCTION_8_3(v67, v68);
  }

  else
  {
    llvm::raw_ostream::write(v67, "to", 2uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v69, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v69, v70);
  }

  OUTLINED_FUNCTION_25_5();
  OUTLINED_FUNCTION_41_2();
  v71 = OUTLINED_FUNCTION_12_4();
  v72(v71);
  if (v102 != v104)
  {
    free(v102);
  }
}

uint64_t anonymous namespace::SimplifyAllocConst<mlir::memref::AllocOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_133(*MEMORY[0x1E69E9840]);
  if ((v10 & 0x800000) == 0)
  {
    if (v9)
    {
      goto LABEL_3;
    }

    return 0;
  }

  if (!v9)
  {
    return 0;
  }

LABEL_3:
  OUTLINED_FUNCTION_132();
  do
  {
    v11 = OUTLINED_FUNCTION_166(v11, v12, v13, v14, v15, v16, v17, v18, v90, v93, v96, v99, v101, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p, v117);
    v19 = v11;
    if (v11)
    {
      v11 = OUTLINED_FUNCTION_188(v11, v12, v13, v14, v15, v16, v17, v18, v90, v93, v96, v99, v101, v103, v104, v105, v106, v107, v108, v109, v110);
      if (v11 && ((OUTLINED_FUNCTION_58_1(), v20 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) ? (v21 = v20 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id) : (v21 = 1), !v21 ? (v22 = v20 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) : (v22 = 1), !v22 ? (v23 = v20 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) : (v23 = 1), v23 && (v11 = mlir::detail::constant_int_value_binder::match(&v108, v110), v11)))
      {
        OUTLINED_FUNCTION_83_0();
      }

      else
      {
        v19 = 0;
      }
    }

    if (v117 >= 0x41)
    {
      v11 = __p;
      if (__p)
      {
        operator delete[](__p);
      }
    }

    if (v3)
    {
      v24 = v19;
    }

    else
    {
      v24 = 1;
    }

    v3 = (v3 - 1);
    v4 += 32;
  }

  while (v24 != 1);
  if (!v19)
  {
    return 0;
  }

  OUTLINED_FUNCTION_117_0();
  v117 = 0x400000000;
  Value = mlir::ArrayAttr::getValue(&v106);
  if (v26 > HIDWORD(v117))
  {
    OUTLINED_FUNCTION_187(Value, v26, v27, v28, v29, v30, v31, v32, v90, v93, v96, v99, v101, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p);
  }

  OUTLINED_FUNCTION_145(Value, v26, v27, v28, v29, v30, v31, v32, v90, v93, v96, v99, v101, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112);
  if (v33)
  {
    OUTLINED_FUNCTION_118_0();
    while (1)
    {
      v34 = mlir::ArrayAttr::getValue(&v106);
      if (*(v34 + v4) != v5)
      {
        OUTLINED_FUNCTION_128_0();
        if (v55)
        {
          OUTLINED_FUNCTION_65_0(v54, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p);
          v54 = v117;
        }

        OUTLINED_FUNCTION_174(v54, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p);
        OUTLINED_FUNCTION_98_0();
        goto LABEL_63;
      }

      v42 = OUTLINED_FUNCTION_101_0(v34, v35, v36, v37, v38, v39, v40, v41, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107);
      if (!v42 || !OUTLINED_FUNCTION_162(v42, v43, v44, v45, v46, v47, v48, v49, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109))
      {
        break;
      }

      OUTLINED_FUNCTION_58_1();
      v51 = v50 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id || v50 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id;
      v52 = v51 || v50 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id;
      v53 = v52 || v50 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id;
      if (!v53 || !mlir::detail::constant_int_value_binder::match(&v103, v109))
      {
        break;
      }

      if (v105 > 0x40)
      {
        OUTLINED_FUNCTION_173();
        if (v56)
        {
          break;
        }
      }

      else if ((v104 >> (v105 - 1)))
      {
        break;
      }

      OUTLINED_FUNCTION_128_0();
      if (v55)
      {
        OUTLINED_FUNCTION_65_0(v60, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p);
        v60 = v117;
      }

      OUTLINED_FUNCTION_174(v60, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p);
      v59 = v91;
LABEL_59:
      OUTLINED_FUNCTION_135(v59);
      if (v105 >= 0x41 && v104)
      {
        operator delete[](v104);
      }

      v19 = (v19 + 1);
LABEL_63:
      v4 += 8;
      if (a3 == v4)
      {
        goto LABEL_68;
      }
    }

    OUTLINED_FUNCTION_128_0();
    if (v55)
    {
      OUTLINED_FUNCTION_65_0(v57, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p);
      v57 = v117;
    }

    *(__p + v57) = v5;
    OUTLINED_FUNCTION_98_0();
    v58 = v111;
    if (v111 >= HIDWORD(v111))
    {
      OUTLINED_FUNCTION_163(&v110, v111, v91, v94, v97);
      v58 = v111;
    }

    *(v110 + v58) = v6;
    v59 = v3;
    goto LABEL_59;
  }

LABEL_68:
  OUTLINED_FUNCTION_183();
  mlir::ArrayAttr::getValue(v61);
  mlir::AffineBinaryOpExpr::getRHS(&v104);
  mlir::DenseElementsAttr::getRawStringData(&v104);
  OUTLINED_FUNCTION_90_0();
  MemorySpace = mlir::MemRefType::getMemorySpace(&v104);
  OUTLINED_FUNCTION_143(MemorySpace, v63, v64, v65, v66, v67, v68, v69, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p, v117);
  OUTLINED_FUNCTION_112_0();
  v78 = OUTLINED_FUNCTION_76_0(v70, v71, v72, v73, v74, v75, v76, v77, v92, v95);
  mlir::OpBuilder::create<mlir::memref::AllocOp,mlir::MemRefType &,llvm::SmallVector<mlir::Value,4u> &,mlir::OperandRange,mlir::IntegerAttr>(v78, v79, v80, v81, v82, v83);
  v84 = OUTLINED_FUNCTION_102_0();
  mlir::OpBuilder::create<mlir::memref::CastOp,mlir::MemRefType,mlir::memref::AllocOp &>(v84, v85, v86, v87);
  OUTLINED_FUNCTION_140();
  (*(v88 + 8))(v3, a2);
  if (v110 != v98)
  {
    free(v110);
  }

  if (__p != v19)
  {
    free(__p);
  }

  return 1;
}

uint64_t anonymous namespace::SimplifyAllocConst<mlir::memref::AllocaOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_133(*MEMORY[0x1E69E9840]);
  if ((v10 & 0x800000) == 0)
  {
    if (v9)
    {
      goto LABEL_3;
    }

    return 0;
  }

  if (!v9)
  {
    return 0;
  }

LABEL_3:
  OUTLINED_FUNCTION_132();
  do
  {
    v11 = OUTLINED_FUNCTION_166(v11, v12, v13, v14, v15, v16, v17, v18, v90, v93, v96, v99, v101, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p, v117);
    v19 = v11;
    if (v11)
    {
      v11 = OUTLINED_FUNCTION_188(v11, v12, v13, v14, v15, v16, v17, v18, v90, v93, v96, v99, v101, v103, v104, v105, v106, v107, v108, v109, v110);
      if (v11 && ((OUTLINED_FUNCTION_58_1(), v20 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) ? (v21 = v20 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id) : (v21 = 1), !v21 ? (v22 = v20 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) : (v22 = 1), !v22 ? (v23 = v20 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) : (v23 = 1), v23 && (v11 = mlir::detail::constant_int_value_binder::match(&v108, v110), v11)))
      {
        OUTLINED_FUNCTION_83_0();
      }

      else
      {
        v19 = 0;
      }
    }

    if (v117 >= 0x41)
    {
      v11 = __p;
      if (__p)
      {
        operator delete[](__p);
      }
    }

    if (v3)
    {
      v24 = v19;
    }

    else
    {
      v24 = 1;
    }

    v3 = (v3 - 1);
    v4 += 32;
  }

  while (v24 != 1);
  if (!v19)
  {
    return 0;
  }

  OUTLINED_FUNCTION_117_0();
  v117 = 0x400000000;
  Value = mlir::ArrayAttr::getValue(&v106);
  if (v26 > HIDWORD(v117))
  {
    OUTLINED_FUNCTION_187(Value, v26, v27, v28, v29, v30, v31, v32, v90, v93, v96, v99, v101, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p);
  }

  OUTLINED_FUNCTION_145(Value, v26, v27, v28, v29, v30, v31, v32, v90, v93, v96, v99, v101, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112);
  if (v33)
  {
    OUTLINED_FUNCTION_118_0();
    while (1)
    {
      v34 = mlir::ArrayAttr::getValue(&v106);
      if (*(v34 + v4) != v5)
      {
        OUTLINED_FUNCTION_128_0();
        if (v55)
        {
          OUTLINED_FUNCTION_65_0(v54, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p);
          v54 = v117;
        }

        OUTLINED_FUNCTION_174(v54, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p);
        OUTLINED_FUNCTION_98_0();
        goto LABEL_63;
      }

      v42 = OUTLINED_FUNCTION_101_0(v34, v35, v36, v37, v38, v39, v40, v41, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107);
      if (!v42 || !OUTLINED_FUNCTION_162(v42, v43, v44, v45, v46, v47, v48, v49, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109))
      {
        break;
      }

      OUTLINED_FUNCTION_58_1();
      v51 = v50 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id || v50 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id;
      v52 = v51 || v50 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id;
      v53 = v52 || v50 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id;
      if (!v53 || !mlir::detail::constant_int_value_binder::match(&v103, v109))
      {
        break;
      }

      if (v105 > 0x40)
      {
        OUTLINED_FUNCTION_173();
        if (v56)
        {
          break;
        }
      }

      else if ((v104 >> (v105 - 1)))
      {
        break;
      }

      OUTLINED_FUNCTION_128_0();
      if (v55)
      {
        OUTLINED_FUNCTION_65_0(v60, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p);
        v60 = v117;
      }

      OUTLINED_FUNCTION_174(v60, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p);
      v59 = v91;
LABEL_59:
      OUTLINED_FUNCTION_135(v59);
      if (v105 >= 0x41 && v104)
      {
        operator delete[](v104);
      }

      v19 = (v19 + 1);
LABEL_63:
      v4 += 8;
      if (a3 == v4)
      {
        goto LABEL_68;
      }
    }

    OUTLINED_FUNCTION_128_0();
    if (v55)
    {
      OUTLINED_FUNCTION_65_0(v57, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p);
      v57 = v117;
    }

    *(__p + v57) = v5;
    OUTLINED_FUNCTION_98_0();
    v58 = v111;
    if (v111 >= HIDWORD(v111))
    {
      OUTLINED_FUNCTION_163(&v110, v111, v91, v94, v97);
      v58 = v111;
    }

    *(v110 + v58) = v6;
    v59 = v3;
    goto LABEL_59;
  }

LABEL_68:
  OUTLINED_FUNCTION_183();
  mlir::ArrayAttr::getValue(v61);
  mlir::AffineBinaryOpExpr::getRHS(&v104);
  mlir::DenseElementsAttr::getRawStringData(&v104);
  OUTLINED_FUNCTION_90_0();
  MemorySpace = mlir::MemRefType::getMemorySpace(&v104);
  OUTLINED_FUNCTION_143(MemorySpace, v63, v64, v65, v66, v67, v68, v69, v91, v94, v97, v100, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, __p, v117);
  OUTLINED_FUNCTION_112_0();
  v78 = OUTLINED_FUNCTION_76_0(v70, v71, v72, v73, v74, v75, v76, v77, v92, v95);
  mlir::OpBuilder::create<mlir::memref::AllocaOp,mlir::MemRefType &,llvm::SmallVector<mlir::Value,4u> &,mlir::OperandRange,mlir::IntegerAttr>(v78, v79, v80, v81, v82, v83);
  v84 = OUTLINED_FUNCTION_102_0();
  mlir::OpBuilder::create<mlir::memref::CastOp,mlir::MemRefType,mlir::memref::AllocOp &>(v84, v85, v86, v87);
  OUTLINED_FUNCTION_140();
  (*(v88 + 8))(v3, a2);
  if (v110 != v98)
  {
    free(v110);
  }

  if (__p != v19)
  {
    free(__p);
  }

  return 1;
}

uint64_t mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp,SubViewReturnTypeCanonicalizer,SubViewCanonicalizer>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  v34[6] = *MEMORY[0x1E69E9840];
  v21 = a2;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedOffsets(&v21, &__src);
  v32 = v34;
  v33 = 0x600000000;
  v4 = v30;
  v5 = __src;
  if (v30)
  {
    if (__src == v31)
    {
      v6 = v30;
      if (v30 < 7 || (llvm::SmallVectorBase<unsigned int>::grow_pod(&v32, v34, v30, 8), v6 = v30, v5 = __src, v30))
      {
        memcpy(v32, v5, 8 * v6);
        v5 = __src;
      }

      LODWORD(v33) = v4;
    }

    else
    {
      v32 = __src;
      v33 = v30;
      __src = v31;
      HIDWORD(v30) = 0;
      v5 = v31;
    }

    LODWORD(v30) = 0;
  }

  if (v5 != v31)
  {
    free(v5);
  }

  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes(&v21, &__dst);
  __src = v31;
  v30 = 0x600000000;
  v7 = v27;
  v8 = __dst;
  if (v27)
  {
    if (__dst == v28)
    {
      v9 = v27;
      if (v27 < 7 || (llvm::SmallVectorBase<unsigned int>::grow_pod(&__src, v31, v27, 8), v9 = v27, v8 = __dst, v27))
      {
        memcpy(__src, v8, 8 * v9);
        v8 = __dst;
      }

      LODWORD(v30) = v7;
    }

    else
    {
      __src = __dst;
      v30 = v27;
      __dst = v28;
      HIDWORD(v27) = 0;
      v8 = v28;
    }

    LODWORD(v27) = 0;
  }

  if (v8 != v28)
  {
    free(v8);
  }

  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides(&v21, &v23);
  __dst = v28;
  v27 = 0x600000000;
  v10 = v24;
  v11 = v23;
  if (v24)
  {
    if (v23 == v25)
    {
      v12 = v24;
      if (v24 < 7 || (llvm::SmallVectorBase<unsigned int>::grow_pod(&__dst, v28, v24, 8), v12 = v24, v11 = v23, v24))
      {
        memcpy(__dst, v11, 8 * v12);
        v11 = v23;
      }

      LODWORD(v27) = v10;
    }

    else
    {
      __dst = v23;
      v27 = v24;
      v23 = v25;
      HIDWORD(v24) = 0;
      v11 = v25;
    }

    LODWORD(v24) = 0;
  }

  if (v11 != v25)
  {
    free(v11);
  }

  if (mlir::foldDynamicIndexList(&v32, 1, 0) & 1) != 0 || (mlir::foldDynamicIndexList(&__src, 1, 0) & 1) != 0 || (v13 = 0, (mlir::foldDynamicIndexList(&__dst, 0, 0)))
  {
    v20 = SubViewReturnTypeCanonicalizer::operator()(&v23, v21, v32, v33, __src, v30, __dst, v27);
    if (v20)
    {
      v14 = *(v21 + 24);
      v23 = *(*(v21 + 72) + 24);
      v15 = mlir::OpBuilder::create<mlir::memref::SubViewOp,mlir::MemRefType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(a3 + 1, v14, &v20, &v23, &v32, &__src, &__dst);
      v16 = v21;
      v23 = v15;
      if (*(v21 + 36))
      {
        v17 = v21 - 16;
      }

      else
      {
        v17 = 0;
      }

      v22 = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v17, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      v18 = mlir::OpBuilder::create<mlir::memref::CastOp,mlir::MemRefType,mlir::memref::AllocOp &>((a3 + 1), *(v16 + 24), &v22, &v23);
      ((*a3)[1])(a3, v16, v18);
      v13 = 1;
    }

    else
    {
      v13 = 0;
    }
  }

  if (__dst != v28)
  {
    free(__dst);
  }

  if (__src != v31)
  {
    free(__src);
  }

  if (v32 != v34)
  {
    free(v32);
  }

  return v13;
}

uint64_t anonymous namespace::ViewOpShapeFolder::matchAndRewrite(uint64_t DefiningOp, uint64_t a2, uint64_t a3)
{
  v55[4] = *MEMORY[0x1E69E9840];
  if ((*(a2 + 46) & 0x80) == 0)
  {
    return 0;
  }

  v6 = *(a2 + 68);
  if (!v6)
  {
    return 0;
  }

  for (i = (*(a2 + 72) + 24); ; i += 4)
  {
    v9 = *i;
    MPSGraphDelegateCompiler.precompilationDescriptor.modify(DefiningOp, a2);
    v54[0] = v9;
    DefiningOp = mlir::Value::getDefiningOp(v54);
    if (DefiningOp)
    {
      DefiningOp = mlir::arith::ConstantIndexOp::classof(DefiningOp, a2);
      if (DefiningOp)
      {
        break;
      }
    }

    if (!--v6)
    {
      return 0;
    }
  }

  v12 = *(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
  v45 = 0;
  v46 = v12;
  v13 = v55;
  v54[0] = v55;
  v54[1] = 0x400000000;
  if (mlir::getStridesAndOffset(v12, v54, &v45))
  {
    v39 = v55;
    v40 = v53;
    v51 = v53;
    v52 = 0x400000000;
    v48 = v50;
    v49 = 0x400000000;
    mlir::ArrayAttr::getValue(&v46);
    if (v14 > HIDWORD(v49))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(&v48, v50, v14, 8);
    }

    v41 = v50;
    mlir::ArrayAttr::getValue(&v46);
    if (v15)
    {
      v3 = 0;
      v4 = 0;
      v16 = 8 * v15;
      while (1)
      {
        v17 = *(v3 + mlir::ArrayAttr::getValue(&v46));
        if (v17 != 0x8000000000000000)
        {
          v27 = v49;
          if (v49 >= HIDWORD(v49))
          {
            OUTLINED_FUNCTION_77_0(&v48, v49, v38, v39, v40, v41);
            v27 = v49;
          }

          *(v48 + v27) = v17;
          LODWORD(v49) = v49 + 1;
          goto LABEL_33;
        }

        OUTLINED_FUNCTION_176();
        v19 = mlir::Value::getDefiningOp(v18);
        if (!v19)
        {
          break;
        }

        v21 = v19;
        v22 = mlir::arith::ConstantIndexOp::classof(v19, v20);
        if (v22)
        {
          v23 = v21;
        }

        else
        {
          v23 = 0;
        }

        v44 = v23;
        if (!v22)
        {
          goto LABEL_27;
        }

        Value = mlir::arith::ConstantOp::getValue(&v44);
        Int = mlir::IntegerAttr::getInt(&Value);
        v25 = v49;
        if (v49 >= HIDWORD(v49))
        {
          OUTLINED_FUNCTION_77_0(&v48, v49, v38, v39, v40, v41);
          v25 = v49;
        }

        *(v48 + v25) = Int;
        v26 = &v49;
LABEL_32:
        OUTLINED_FUNCTION_135(v26);
        v4 = (v4 + 1);
LABEL_33:
        if (v16 == ++v3)
        {
          goto LABEL_36;
        }
      }

      v44 = 0;
LABEL_27:
      v28 = v49;
      if (v49 >= HIDWORD(v49))
      {
        OUTLINED_FUNCTION_77_0(&v48, v49, v38, v39, v40, v41);
        v28 = v49;
      }

      *(v48 + v28) = 0x8000000000000000;
      LODWORD(v49) = v49 + 1;
      v29 = *(*(a2 + 72) + 32 * v4 + 88);
      v30 = v52;
      if (v52 >= HIDWORD(v52))
      {
        OUTLINED_FUNCTION_163(&v51, v52, v38, v39, v40);
        v30 = v52;
      }

      *(v51 + v30) = v29;
      v26 = &v52;
      goto LABEL_32;
    }

LABEL_36:
    OUTLINED_FUNCTION_176();
    mlir::ArrayAttr::getValue(v31);
    RHS = mlir::AffineBinaryOpExpr::getRHS(&Value);
    mlir::DenseElementsAttr::getRawStringData(&Value);
    OUTLINED_FUNCTION_90_0();
    MemorySpace = mlir::MemRefType::getMemorySpace(&Value);
    Value = mlir::MemRefType::get(v48, v49, RHS, v3, v4, MemorySpace);
    if (v46 == Value)
    {
      v10 = 0;
    }

    else
    {
      v34 = *(a2 + 24);
      v35 = *(a2 + 72);
      v36 = *(v35 + 24);
      v42 = *(v35 + 56);
      v43 = v36;
      v44 = mlir::OpBuilder::create<mlir::memref::ViewOp,mlir::MemRefType &,mlir::Value,mlir::detail::TypedValue<mlir::IndexType>,llvm::SmallVector<mlir::Value,4u> &>((a3 + 8), v34, &Value, &v43, &v42, &v51);
      v43 = *(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
      mlir::OpBuilder::create<mlir::memref::CastOp,mlir::MemRefType,mlir::memref::AllocOp &>((a3 + 8), *(a2 + 24), &v43, &v44);
      OUTLINED_FUNCTION_140();
      (*(v37 + 8))(a3, a2);
      v10 = 1;
    }

    v13 = v39;
    if (v48 != v41)
    {
      free(v48);
    }

    if (v51 != v40)
    {
      free(v51);
    }
  }

  else
  {
    v10 = 0;
  }

  if (v54[0] != v13)
  {
    free(v54[0]);
  }

  return v10;
}

void mlir::Operation::getParentWithTrait<mlir::OpTrait::AutomaticAllocationScope>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_159(v2);
  }
}

void mlir::memref::DimOp::fold()
{
  OUTLINED_FUNCTION_139();
  mlir::ArrayAttr::getValue(v0);
  OUTLINED_FUNCTION_138();
  if (v1)
  {
    OUTLINED_FUNCTION_137();
    if (!(!v3 & v2))
    {
      goto LABEL_14;
    }

    *v5.i64 = OUTLINED_FUNCTION_42_1();
    do
    {
      *v5.i64 = OUTLINED_FUNCTION_32_4(v5, v6);
    }

    while (!v3);
    OUTLINED_FUNCTION_96_0(v5, *v6.i64, v7);
    if (!v3)
    {
LABEL_14:
      do
      {
        OUTLINED_FUNCTION_136();
      }

      while (v9 != v10);
    }

    v4 = v8;
  }

  else
  {
    v4 = 0;
  }

  OUTLINED_FUNCTION_95_0(v4);
}

{
  OUTLINED_FUNCTION_139();
  mlir::ArrayAttr::getValue(v0);
  OUTLINED_FUNCTION_138();
  if (v1)
  {
    OUTLINED_FUNCTION_137();
    if (!(!v3 & v2))
    {
      goto LABEL_14;
    }

    *v5.i64 = OUTLINED_FUNCTION_42_1();
    do
    {
      *v5.i64 = OUTLINED_FUNCTION_32_4(v5, v6);
    }

    while (!v3);
    OUTLINED_FUNCTION_96_0(v5, *v6.i64, v7);
    if (!v3)
    {
LABEL_14:
      do
      {
        OUTLINED_FUNCTION_136();
      }

      while (v9 != v10);
    }

    v4 = v8;
  }

  else
  {
    v4 = 0;
  }

  OUTLINED_FUNCTION_95_0(v4);
}

void mlir::memref::DmaStartOp::verify(uint64_t a1, _BYTE *a2)
{
  v67 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_60_0();
  mlir::OpState::emitOpError(v3, v4, v5);
  v6 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v42);
  *a2 = v6;
  if (v42)
  {
    mlir::InFlightDiagnostic::report(&v42);
  }

  if (v66 == 1)
  {
    v14 = OUTLINED_FUNCTION_134(v6, v7, v8, v9, v10, v11, v12, v13, v32, v34, v36, v38, v40, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, __p, v63, v64, v65);
    if (!v22)
    {
      free(v14);
    }

    v23 = __p;
    if (__p)
    {
      v24 = v63;
      v25 = __p;
      if (v63 != __p)
      {
        do
        {
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v24 - 1);
        }

        while (v24 != v23);
        v25 = __p;
      }

      v63 = v23;
      operator delete(v25);
    }

    v26 = v59;
    if (v59)
    {
      v27 = v60;
      v28 = v59;
      if (v60 != v59)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
          {
            operator delete[](v29);
          }
        }

        while (v27 != v26);
        v28 = v59;
      }

      v60 = v26;
      operator delete(v28);
    }

    v31 = OUTLINED_FUNCTION_89_0(v14, v15, v16, v17, v18, v19, v20, v21, v33, v35, v37, v39, v41, v42, v43, v44, v45);
    if (!v22)
    {
      free(v31);
    }
  }
}

void mlir::memref::GlobalOp::verify()
{
  {
    v0 = llvm::getTypeName<mlir::ElementsAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_153(v2);
  }
}

void mlir::memref::GlobalOp::getConstantInitValue()
{
  {
    v0 = llvm::getTypeName<mlir::ElementsAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_153(v2);
  }
}

void mlir::memref::ExpandShapeOp::computeExpandedType()
{
  {
    v0 = llvm::getTypeName<mlir::MemRefLayoutAttrInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_92_0(v2);
  }
}

void mlir::memref::ExpandShapeOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::ExpandShapeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_80_0(v2);
  }
}

void mlir::memref::CollapseShapeOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::CollapseShapeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_152(v2);
  }
}

void mlir::memref::SubViewOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::SubViewOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_66_0(v2);
  }
}

void mlir::memref::AssumeAlignmentOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::AssumeAlignmentOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_113_0(v2);
  }
}

void mlir::memref::AtomicRMWOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::AtomicRMWOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_85_0(v2);
  }
}

uint64_t mlir::memref::AtomicRMWOp::verifyInvariantsImpl()
{
  OUTLINED_FUNCTION_157();
  while (1)
  {
    v3 = OUTLINED_FUNCTION_8_6();
    if ((mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v3, v4, v5, v6, v2) & 1) == 0)
    {
      break;
    }

    OUTLINED_FUNCTION_57_1();
    if (v7)
    {
      result = 0;
      *v0 = *v1;
      return result;
    }
  }

  return 1;
}

void mlir::memref::AtomicRMWOp::getEffects()
{
  {
    mlir::MemoryEffects::Read::Read(&mlir::SideEffects::Effect::get<mlir::MemoryEffects::Read>(void)::instance);
  }
}

{
  {
    mlir::MemoryEffects::Write::Write(&mlir::SideEffects::Effect::get<mlir::MemoryEffects::Write>(void)::instance);
  }
}

{
  {
    v0 = mlir::SideEffects::DefaultResource::DefaultResource(mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance);
    OUTLINED_FUNCTION_8_2(v0, v1, &dword_1DF9BF000);
  }
}

void mlir::memref::LoadOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::LoadOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_91_0(v2);
  }
}

void mlir::memref::AllocOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::AllocOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_109_0(v2);
  }
}

uint64_t mlir::memref::AllocOp::verifyInvariantsImpl()
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_158();
  if ((v7 & 0x800000) != 0)
  {
    v8 = *(v5 + 72);
    if (v2)
    {
      goto LABEL_3;
    }
  }

  else
  {
    v8 = 0;
    if (v2)
    {
LABEL_3:
      v4 = v8 + 24;
      v3 = "operand";
      while (1)
      {
        v9 = OUTLINED_FUNCTION_8_6();
        result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v9, v10, v11, v12, 0);
        if ((result & 1) == 0)
        {
          goto LABEL_15;
        }

        OUTLINED_FUNCTION_57_1();
        if (v14)
        {
          v5 = *v1;
          v7 = *(*v1 + 44);
          v6 = (v7 >> 23) & 1;
          break;
        }
      }
    }
  }

  v15 = *(v5 + 16 * v6 + 76);
  if ((v7 & 0x800000) != 0)
  {
    if (v15)
    {
      goto LABEL_10;
    }
  }

  else if (v15)
  {
LABEL_10:
    OUTLINED_FUNCTION_150();
    while (1)
    {
      v16 = OUTLINED_FUNCTION_17_7();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v16, v17, "operand", 7, v2);
      if ((result & 1) == 0)
      {
        break;
      }

      ++v2;
      v4 += 32;
      if (!--v3)
      {
        v5 = *v1;
        goto LABEL_14;
      }
    }

LABEL_15:
    v19 = 0;
    goto LABEL_16;
  }

LABEL_14:
  OUTLINED_FUNCTION_28_4(v5);
  OUTLINED_FUNCTION_169();
  result = OUTLINED_FUNCTION_84_0("result", v18);
  v19 = result & 1;
LABEL_16:
  *v0 = v19;
  return result;
}

void mlir::memref::AllocOp::getEffects()
{
  {
    mlir::MemoryEffects::Allocate::Allocate(&mlir::SideEffects::Effect::get<mlir::MemoryEffects::Allocate>(void)::instance);
  }
}

void mlir::memref::AllocaOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::AllocaOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_108_0(v2);
  }
}

void mlir::memref::AllocaOp::getEffects()
{
  {
    mlir::SideEffects::AutomaticAllocationScopeResource::AutomaticAllocationScopeResource(mlir::SideEffects::Resource::Base<mlir::SideEffects::AutomaticAllocationScopeResource,mlir::SideEffects::Resource>::get(void)::instance);
    __cxa_atexit(mlir::SideEffects::AutomaticAllocationScopeResource::~AutomaticAllocationScopeResource, mlir::SideEffects::Resource::Base<mlir::SideEffects::AutomaticAllocationScopeResource,mlir::SideEffects::Resource>::get(void)::instance, &dword_1DF9BF000);
  }
}

void mlir::memref::DeallocOp::getEffects()
{
  {
    mlir::MemoryEffects::Free::Free(&mlir::SideEffects::Effect::get<mlir::MemoryEffects::Free>(void)::instance);
  }
}

void mlir::memref::GetGlobalOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::GetGlobalOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_107_0(v2);
  }
}

void mlir::memref::GlobalOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::GlobalOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_53_0(v2);
  }
}

void mlir::memref::PrefetchOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::PrefetchOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_75_0(v2);
  }
}

void mlir::memref::ReallocOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::ReallocOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_170(v2);
  }
}

void mlir::memref::ReallocOp::getEffects()
{
  {
    mlir::MemoryEffects::Allocate::Allocate(&mlir::SideEffects::Effect::get<mlir::MemoryEffects::Allocate>(void)::instance);
  }
}

void mlir::memref::ReinterpretCastOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::ReinterpretCastOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_69_0(v2);
  }
}

uint64_t mlir::memref::ReinterpretCastOp::verifyInvariantsImpl()
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_94_0();
  v3 = *(v2 + 88);
  if ((v4 & 0x800000) != 0)
  {
    if (v3)
    {
      goto LABEL_3;
    }
  }

  else if (v3)
  {
LABEL_3:
    do
    {
      v5 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps6(v5, v6, v7, v8, 0);
      if ((result & 1) == 0)
      {
        goto LABEL_22;
      }

      OUTLINED_FUNCTION_57_1();
    }

    while (!v10);
  }

  mlir::memref::ReinterpretCastOp::getODSOperands(v1, 1u);
  if (v11)
  {
    OUTLINED_FUNCTION_123_0();
    do
    {
      v12 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v12, v13, v14, v15, v3);
      if ((result & 1) == 0)
      {
        goto LABEL_22;
      }

      OUTLINED_FUNCTION_55_1();
    }

    while (!v10);
  }

  mlir::memref::ReinterpretCastOp::getODSOperands(v1, 2u);
  if (v16)
  {
    OUTLINED_FUNCTION_123_0();
    do
    {
      v17 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v17, v18, v19, v20, v3);
      if ((result & 1) == 0)
      {
        goto LABEL_22;
      }

      OUTLINED_FUNCTION_55_1();
    }

    while (!v10);
  }

  mlir::memref::ReinterpretCastOp::getODSOperands(v1, 3u);
  if (v21)
  {
    OUTLINED_FUNCTION_123_0();
    while (1)
    {
      v22 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v22, v23, v24, v25, v3);
      if ((result & 1) == 0)
      {
        break;
      }

      OUTLINED_FUNCTION_55_1();
      if (v10)
      {
        goto LABEL_21;
      }
    }

LABEL_22:
    v27 = 0;
    goto LABEL_23;
  }

LABEL_21:
  OUTLINED_FUNCTION_25_5();
  OUTLINED_FUNCTION_169();
  result = OUTLINED_FUNCTION_84_0("result", v26);
  v27 = result & 1;
LABEL_23:
  *v0 = v27;
  return result;
}

void mlir::memref::StoreOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::StoreOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_120_0(v2);
  }
}

void mlir::memref::TransposeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::memref::detail::TransposeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_127_0(v2);
  }
}

uint64_t mlir::memref::SubViewOp::verifyInvariantsImpl()
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_94_0();
  v3 = *(v2 + 88);
  if ((v4 & 0x800000) != 0)
  {
    if (v3)
    {
      goto LABEL_3;
    }
  }

  else if (v3)
  {
LABEL_3:
    do
    {
      v5 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps1(v5, v6, v7, v8, 0);
      if ((result & 1) == 0)
      {
        goto LABEL_22;
      }

      OUTLINED_FUNCTION_57_1();
    }

    while (!v10);
  }

  mlir::memref::ReinterpretCastOp::getODSOperands(v1, 1u);
  if (v11)
  {
    OUTLINED_FUNCTION_123_0();
    do
    {
      v12 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v12, v13, v14, v15, v3);
      if ((result & 1) == 0)
      {
        goto LABEL_22;
      }

      OUTLINED_FUNCTION_55_1();
    }

    while (!v10);
  }

  mlir::memref::ReinterpretCastOp::getODSOperands(v1, 2u);
  if (v16)
  {
    OUTLINED_FUNCTION_123_0();
    do
    {
      v17 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v17, v18, v19, v20, v3);
      if ((result & 1) == 0)
      {
        goto LABEL_22;
      }

      OUTLINED_FUNCTION_55_1();
    }

    while (!v10);
  }

  mlir::memref::ReinterpretCastOp::getODSOperands(v1, 3u);
  if (v21)
  {
    OUTLINED_FUNCTION_123_0();
    while (1)
    {
      v22 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v22, v23, v24, v25, v3);
      if ((result & 1) == 0)
      {
        break;
      }

      OUTLINED_FUNCTION_55_1();
      if (v10)
      {
        goto LABEL_21;
      }
    }

LABEL_22:
    v27 = 0;
    goto LABEL_23;
  }

LABEL_21:
  OUTLINED_FUNCTION_25_5();
  OUTLINED_FUNCTION_169();
  result = OUTLINED_FUNCTION_84_0("result", v26);
  v27 = result & 1;
LABEL_23:
  *v0 = v27;
  return result;
}

void mlir::OpBuilder::createOrFold<mlir::memref::DimOp,mlir::Value &,long long &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "memref.dim";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::memref::AllocOp,mlir::MemRefType &,llvm::SmallVector<mlir::Value,4u> &,mlir::OperandRange,mlir::IntegerAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "memref.alloc";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::memref::CastOp,mlir::MemRefType,mlir::memref::AllocOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "memref.cast";
  *(a2 + 24) = 11;
}

void AllocaScopeInliner::matchAndRewrite()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_159(v2);
  }
}

uint64_t AllocaScopeInliner::matchAndRewrite()
{
  OUTLINED_FUNCTION_70_0();
  v18[4] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_105_0();
  v5 = *(v3 + 32 * v4 + 8);
  if (v5)
  {
    v6 = (v5 - 8);
  }

  else
  {
    v6 = 0;
  }

  Terminator = mlir::Block::getTerminator(v6, v2);
  v8 = Terminator;
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v9 = *(Terminator + 72);
    v10 = *(Terminator + 68);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(v18, v9, v10);
  v11 = *v1;
  OUTLINED_FUNCTION_44_0();
  mlir::ValueRange::ValueRange(v12, v13, v14);
  mlir::RewriterBase::inlineBlockBefore(v0, v6, v11, v18[2], v18[3]);
  OUTLINED_FUNCTION_104();
  (*v15)(v0);
  OUTLINED_FUNCTION_104();
  return (*(v16 + 16))(v0, v8);
}

void AllocaScopeInliner::matchAndRewrite(mlir::memref::AllocaScopeOp,mlir::PatternRewriter &)const::{lambda(mlir::Operation *)#1}::operator()()
{
  {
    v0 = llvm::getTypeName<mlir::SideEffects::AutomaticAllocationScopeResource>();
    mlir::detail::TypeIDResolver<mlir::SideEffects::AutomaticAllocationScopeResource,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void AllocaScopeHoister::matchAndRewrite(mlir::memref::AllocaScopeOp,mlir::PatternRewriter &)const::{lambda(mlir::Operation *)#1}::operator()(uint64_t a1, uint64_t a2)
{
  v3 = *(a1 + 8);
  v4 = *(v3 + 8);
  if (v4 >= *(v3 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(*(a1 + 8), v3 + 16, v4 + 1, 8);
    LODWORD(v4) = *(v3 + 8);
  }

  *(*v3 + 8 * v4) = a2;
  ++*(v3 + 8);
}

void mlir::OpBuilder::create<mlir::memref::LoadOp,mlir::detail::TypedValue<mlir::MemRefType>,mlir::detail::TypedValue<mlir::IndexType>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "memref.load";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::memref::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "memref.expand_shape";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::memref::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "memref.collapse_shape";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::memref::SubViewOp,mlir::MemRefType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "memref.subview";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::memref::ViewOp,mlir::MemRefType &,mlir::Value,mlir::detail::TypedValue<mlir::IndexType>,llvm::SmallVector<mlir::Value,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "memref.view";
  *(a2 + 24) = 11;
}

void mlir::MemoryEffects::Free::Free()
{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffects::Free>();
    mlir::detail::TypeIDResolver<mlir::MemoryEffects::Free,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::bufferization::detail::AllocationOpInterfaceInterfaceTraits::FallbackModel<anonymous namespace::DefaultAllocationInterface>::buildPromotedAlloc(mlir::OpBuilder *a1, uint64_t a2)
{
  v14 = a2;
  DefiningOp = mlir::Value::getDefiningOp(&v14);
  v4 = *(DefiningOp + 24);
  v5 = *(DefiningOp + 36);
  v6 = DefiningOp - 16;
  if (!v5)
  {
    v6 = 0;
  }

  v15 = v6;
  v16 = v5;
  mlir::OperandRange::getTypes(&v15, v12);
  v13 = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v12[0], v12[1]) + 8) & 0xFFFFFFFFFFFFFFF8;
  if ((*(DefiningOp + 46) & 0x80) != 0)
  {
    v7 = *(DefiningOp + 72);
    v8 = *(DefiningOp + 68);
  }

  else
  {
    v7 = 0;
    v8 = 0;
  }

  v15 = v7;
  v16 = v8;
  v11[0] = mlir::Operation::getAttrDictionary(DefiningOp);
  v11[0] = mlir::ArrayAttr::getValue(v11);
  v11[1] = v9;
  return mlir::OpBuilder::create<mlir::memref::AllocaOp,mlir::MemRefType,mlir::OperandRange,llvm::ArrayRef<mlir::NamedAttribute>>(a1, v4, &v13, &v15, v11);
}

void mlir::memref::registerAllocationOpInterfaceExternalModels(mlir::DialectRegistry &)::$_0::__invoke()
{
  {
    v0 = llvm::getTypeName<mlir::bufferization::AllocationOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1_9(v2);
  }
}

void mlir::OpInterface<mlir::MPSRuntimeDynamicEncodeOpInterface,mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::MPSRuntimeDynamicEncodeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::MPSRuntimeDynamicEncodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::MPSRuntimeDynamicEncodeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::MPSRuntimeDynamicEncodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::mps::anonymous namespace::traverse(uint64_t a1, uint64_t a2)
{
  v92 = a1;
  if (!a1)
  {
LABEL_10:
    {
      v87 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v87, v88);
    }

    if ((*(**(a1 + 48) + 32))(*(a1 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id))
    {
      goto LABEL_39;
    }

    InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(v92);
    if (v92 && InterfaceFor)
    {
      mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(v92);
    }

    else if (*(*(v92 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::BufferToTensorOp,void>::id)
    {
      goto LABEL_28;
    }

    if ((*(v92 + 46) & 0x80) != 0)
    {
      v7 = *(v92 + 68);
      if (v7)
      {
        v8 = *(a2 + 16);
        if (v8)
        {
          v9 = 0;
          v10 = *a2;
          v11 = v8 - 1;
          while (1)
          {
            v12 = *(*(v92 + 72) + 32 * v9 + 24);
            v13 = 0x9DDFEA08EB382D69 * ((8 * v12 - 0xAE502812AA7333) ^ HIDWORD(v12));
            v14 = 0x9DDFEA08EB382D69 * (HIDWORD(v12) ^ (v13 >> 47) ^ v13);
            v15 = (-348639895 * ((v14 >> 47) ^ v14)) & v11;
            v16 = *(v10 + 8 * v15);
            if (v16 != v12)
            {
              break;
            }

LABEL_21:
            if (v15 == v8)
            {
              goto LABEL_28;
            }

            if (++v9 == v7)
            {
              goto LABEL_39;
            }
          }

          v17 = 1;
          while (v16 != -4096)
          {
            v18 = v15 + v17++;
            v15 = v18 & v11;
            v16 = *(v10 + 8 * v15);
            if (v16 == v12)
            {
              goto LABEL_21;
            }
          }
        }
      }
    }

LABEL_28:
    v19 = *(*(v92 + 48) + 16);
    v20 = v19 == &mlir::detail::TypeIDResolver<mlir::mps::DimensionSizeOp,void>::id || v19 == &mlir::detail::TypeIDResolver<mlir::mps::RankOp,void>::id;
    if (!v20 && v19 != &mlir::detail::TypeIDResolver<mlir::mps::ShapeOp,void>::id && v19 != &mlir::detail::TypeIDResolver<mlir::mps::SizeOp,void>::id)
    {
      return;
    }

LABEL_39:
    v23 = *(v92 + 36);
    if (v23)
    {
      v24 = v92 - 16;
    }

    else
    {
      v24 = 0;
    }

    if (v23)
    {
      for (i = 0; i != v23; ++i)
      {
        NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v24, i);
        OUTLINED_FUNCTION_5_9(NextResultAtOffset, v27, v28, v29, v30);
      }
    }

    return;
  }

  if (mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(a1);
    v93 = &v92;
    v94 = a2;
    return;
  }

  v4 = *(*(a1 + 48) + 16);
  if (v4 == &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
  {
    v5 = a1;
  }

  else
  {
    v5 = 0;
  }

  v91 = v5;
  if (v4 == &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
  {
    if (!mlir::placement::RegionCall::getRegionType(&v91))
    {
      v31 = a1;
      while (1)
      {
        v32 = *(v31 + 16);
        if (!v32)
        {
          break;
        }

        ParentOp = mlir::Block::getParentOp(v32);
        if (!ParentOp)
        {
          break;
        }

        v31 = ParentOp;
        if (*(*(ParentOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ModuleOp,void>::id)
        {
          Callee = mlir::placement::RegionCall::getCallee(&v91);
          v36 = v35;
          Context = mlir::Attribute::getContext((v31 + 24));
          v95 = 261;
          v93 = Callee;
          v94 = v36;
          v38 = mlir::StringAttr::get(Context, &v93);
          v39 = mlir::SymbolTable::lookupSymbolIn(v31, v38);
          if (v39)
          {
            v40 = *(*(v39 + 6) + 16);
            v41 = v40 == &mlir::detail::TypeIDResolver<mlir::mpsx::GPUOp,void>::id;
            v42 = v40 == &mlir::detail::TypeIDResolver<mlir::mpsx::GPUOp,void>::id ? v39 : 0;
            if (v41)
            {
              v89 = v42;
              OUTLINED_FUNCTION_3_8();
              if (*v43 == v43)
              {
                v44 = 0;
                v45 = 0;
              }

              else
              {
                v65 = v43[1];
                if (v65)
                {
                  v66 = v65 - 8;
                }

                else
                {
                  v66 = 0;
                }

                v44 = *(v66 + 48);
                v45 = (*(v66 + 56) - v44) >> 3;
              }

              if ((*(a1 + 46) & 0x80) != 0)
              {
                if (v45)
                {
                  v67 = *(a1 + 68);
                  if (v67)
                  {
                    v68 = 0;
                    v69 = &v44[v45];
                    do
                    {
                      if (*(a2 + 16))
                      {
                        OUTLINED_FUNCTION_6_7();
                        OUTLINED_FUNCTION_2_10();
                        if (v20)
                        {
LABEL_103:
                          if (v71 != v70)
                          {
                            llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::try_emplace<llvm::detail::DenseSetEmpty&>(a2, v44, &v93);
                          }
                        }

                        else
                        {
                          while (v72 != -4096)
                          {
                            OUTLINED_FUNCTION_2_10();
                            if (v20)
                            {
                              goto LABEL_103;
                            }
                          }
                        }
                      }

                      ++v44;
                      ++v68;
                    }

                    while (v44 != v69 && v68 != v67);
                  }
                }
              }

              OUTLINED_FUNCTION_3_8();
              v76 = *(v75 + 8);
              if (v76)
              {
                v77 = (v76 - 8);
              }

              else
              {
                v77 = 0;
              }

              Terminator = mlir::Block::getTerminator(v77, v74);
              if ((*(Terminator + 46) & 0x80) != 0)
              {
                v79 = *(Terminator + 68);
                v80 = *(a1 + 36);
                v81 = v80 ? a1 - 16 : 0;
                if (v79 && v80)
                {
                  v82 = 0;
                  OUTLINED_FUNCTION_1_10();
                  do
                  {
                    v90 = mlir::detail::OpResultImpl::getNextResultAtOffset(v81, v82);
                    if (*(a2 + 16))
                    {
                      OUTLINED_FUNCTION_0_7();
                      if (v20)
                      {
LABEL_127:
                        if (v84 != v83)
                        {
                          llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::try_emplace<llvm::detail::DenseSetEmpty&>(a2, &v90, &v93);
                        }
                      }

                      else
                      {
                        while (v85 != -4096)
                        {
                          OUTLINED_FUNCTION_4_8();
                          if (v20)
                          {
                            goto LABEL_127;
                          }
                        }
                      }
                    }
                  }

                  while (++v82 != v79 && v82 != v80);
                }
              }
            }
          }

          return;
        }
      }
    }
  }

  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mpsx::ReturnStitchedOp,void>::id)
  {
    v46 = a1;
    while (1)
    {
      v47 = *(v46 + 16);
      if (!v47)
      {
        break;
      }

      v46 = mlir::Block::getParentOp(v47);
      if (!v46)
      {
        break;
      }

      if (*(*(v46 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
      {
        if ((*(a1 + 46) & 0x80) != 0)
        {
          v48 = *(a1 + 68);
          v49 = *(v46 + 36);
          v50 = v49 ? v46 - 16 : 0;
          if (v48 && v49)
          {
            v51 = 0;
            OUTLINED_FUNCTION_1_10();
            do
            {
              v90 = mlir::detail::OpResultImpl::getNextResultAtOffset(v50, v51);
              if (*(a2 + 16))
              {
                OUTLINED_FUNCTION_0_7();
                if (v20)
                {
LABEL_73:
                  if (v53 != v52)
                  {
                    llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::try_emplace<llvm::detail::DenseSetEmpty&>(a2, &v90, &v93);
                  }
                }

                else
                {
                  while (v54 != -4096)
                  {
                    OUTLINED_FUNCTION_4_8();
                    if (v20)
                    {
                      goto LABEL_73;
                    }
                  }
                }
              }
            }

            while (++v51 != v48 && v51 != v49);
          }
        }

        return;
      }
    }
  }

  else
  {
    if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::IdentityOp,void>::id)
    {
      goto LABEL_10;
    }

    if (*(a2 + 16))
    {
      OUTLINED_FUNCTION_6_7();
      OUTLINED_FUNCTION_2_10();
      if (v20)
      {
LABEL_87:
        if (v57 != v56)
        {
          if (*(a1 + 36))
          {
            v59 = a1 - 16;
          }

          else
          {
            v59 = 0;
          }

          v60 = mlir::detail::OpResultImpl::getNextResultAtOffset(v59, 0);
          OUTLINED_FUNCTION_5_9(v60, v61, v62, v63, v64);
        }
      }

      else
      {
        while (v58 != -4096)
        {
          OUTLINED_FUNCTION_2_10();
          if (v20)
          {
            goto LABEL_87;
          }
        }
      }
    }
  }
}

uint64_t mlir::mps::ConstantRuntimeAnalysis::ConstantRuntimeAnalysis(uint64_t a1, uint64_t a2)
{
  *a1 = 0;
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  return a1;
}

void mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::ExternalFoldInterface>();
    mlir::detail::TypeIDResolver<mlir::ExternalFoldInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ExternalFoldInterface>();
    mlir::detail::TypeIDResolver<mlir::ExternalFoldInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::func::CallOp,mlir::func::FuncOp &,mlir::OperandRange>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "func.call";
  *(a2 + 24) = 9;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

uint64_t mlir::mps::anonymous namespace::AddSubConsts::matchAndRewrite()
{
  v22[1] = *MEMORY[0x1E69E9840];
  v19 = 0;
  v20 = 0;
  v18[0] = &v20;
  v18[1] = &v19;
  v18[2] = 0;
  OUTLINED_FUNCTION_8_7();
  if (v1 != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
  {
    return 0;
  }

  OUTLINED_FUNCTION_19_6();
  if ((v3 & 0x80) == 0 || *(v0 + 68) != 2)
  {
    return 0;
  }

  v5 = v2;
  v6 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(v0, 0, v18);
  v21[0] = *(*(v0 + 72) + 56);
  result = mlir::Value::getDefiningOp(v21);
  if (result)
  {
    OUTLINED_FUNCTION_12_8();
    if (((v8 == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id) & v6) != 1)
    {
      return 0;
    }

    v9 = *(v0 + 24);
    v16 = v19;
    v17 = v7;
    v21[0] = v22;
    v21[1] = 0x100000000;
    mlir::OpBuilder::createOrFold<mlir::mps::SubtractOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>(v5 + 8, v21, v9, &v17, &v16);
    v10 = *v21[0];
    if (v21[0] != v22)
    {
      free(v21[0]);
    }

    v21[0] = v10;
    v11 = OUTLINED_FUNCTION_4_9();
    mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(v11, v12, v13, v21);
    OUTLINED_FUNCTION_140();
    v14 = OUTLINED_FUNCTION_9_6();
    v15(v14);
    return 1;
  }

  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  v14 = *(*(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v14);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **a3) == 0) ? (**a3 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v11 = a3[1], v14 = *(v7 + 56), (v12 = mlir::Value::getDefiningOp(&v14)) != 0) && *(*(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id && (!*v11 || *v11 == v12) && (*v11 = v12, v10)))
    {
      a3[2] = v6;
      v5 = 1;
    }

    else
    {
      v5 = 0;
    }
  }

  return (v6 != 0) & v5;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul,4ul>(uint64_t **a1, uint64_t a2)
{
  v4 = *(**(a2 + 8) + 72);
  v5 = *(v4 + 24);
  v6 = **a1;
  if (v6)
  {
    v7 = v6 == v5;
  }

  else
  {
    **a1 = v5;
    v4 = *(**(a2 + 8) + 72);
    v7 = 1;
  }

  **a2 &= v7;
  v8 = a1[1];
  v40 = *(v4 + 56);
  DefiningOp = mlir::Value::getDefiningOp(&v40);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v11 = *(DefiningOp + 72), v12 = *(v11 + 24), (v13 = **v8) == 0) ? (**v8 = v12, v11 = *(DefiningOp + 72), v14 = 1) : (v14 = v13 == v12), (v15 = v8[1], v16 = *(v11 + 56), !*v15) ? (*v15 = v16, v17 = 1) : (v17 = *v15 == v16), v10 = v14 && v17, v10 == 1))
    {
      v8[2] = DefiningOp;
    }

    else
    {
      LOBYTE(v10) = 0;
    }
  }

  v18 = v10 & **a2;
  if (!DefiningOp)
  {
    v18 = 0;
  }

  **a2 = v18;
  v19 = a1[2];
  v40 = *(*(**(a2 + 8) + 72) + 88);
  result = mlir::Value::getDefiningOp(&v40);
  if (result)
  {
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionVarianceOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 2 && ((v22 = *(result + 72), v23 = *(v22 + 24), (v24 = **v19) == 0) ? (**v19 = v23, v22 = *(result + 72), v25 = 1) : (v25 = v24 == v23), (v26 = v19[1], v27 = *(v22 + 56), !*v26) ? (*v26 = v27, v28 = 1) : (v28 = *v26 == v27), v25 && v28))
    {
      v19[2] = result;
      v21 = 1;
    }

    else
    {
      v21 = 0;
    }
  }

  v29 = *a2;
  v30 = v21 & **a2;
  if (result)
  {
    v31 = v30;
  }

  else
  {
    v31 = 0;
  }

  *v29 = v31;
  v32 = a1[3];
  v33 = *(**(a2 + 8) + 72);
  v34 = *(v33 + 120);
  if (*v32)
  {
    v35 = *v32 == v34;
  }

  else
  {
    *v32 = v34;
    v29 = *a2;
    v33 = *(**(a2 + 8) + 72);
    v31 = **a2 != 0;
    v35 = 1;
  }

  v36 = v35 && v31;
  *v29 = v36;
  v37 = a1[4];
  v38 = *(v33 + 152);
  if (*v37)
  {
    v39 = *v37 == v38;
  }

  else
  {
    *v37 = v38;
    v29 = *a2;
    v36 = **a2 != 0;
    v39 = 1;
  }

  *v29 = v39 && v36;
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t ***a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *a1;
  v19 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v19);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **v4) == 0) ? (**v4 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v13 = v4[1], v14 = *(v7 + 56), !*v13) ? (*v13 = v14, v15 = 1) : (v15 = *v13 == v14), v10 && v15))
    {
      v4[2] = DefiningOp;
      v6 = 1;
    }

    else
    {
      v6 = 0;
    }
  }

  v16 = a1[1];
  v17 = *(*(a2 + 72) + 56);
  if (*v16)
  {
    v18 = *v16 == v17;
  }

  else
  {
    *v16 = v17;
    v18 = 1;
  }

  v11 = 0;
  if (DefiningOp && (v6 & v18) != 0)
  {
    a1[2] = a2;
    return 1;
  }

  return v11;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  v4 = *a1;
  v15 = *(*(**(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp(&v15);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id || (*(result + 46) & 0x80) == 0 || *(result + 68) != 1)
    {
      goto LABEL_7;
    }

    v7 = *(*(result + 72) + 24);
    v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        v6 = 0;
        goto LABEL_8;
      }
    }

    else
    {
      **v4 = v7;
    }

    v4[1] = result;
    v6 = 1;
  }

LABEL_8:
  v9 = *a2;
  v10 = *(a2 + 8);
  v11 = v6 & **a2;
  if (!result)
  {
    v11 = 0;
  }

  *v9 = v11;
  v12 = a1[1];
  v13 = *(*(*v10 + 72) + 56);
  if (*v12)
  {
    v14 = *v12 == v13;
  }

  else
  {
    *v12 = v13;
    v9 = *a2;
    v11 = **a2 != 0;
    v14 = 1;
  }

  *v9 = v14 & v11;
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t ***a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *a1;
  v19 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v19);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **v4) == 0) ? (**v4 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v13 = v4[1], v14 = *(v7 + 56), !*v13) ? (*v13 = v14, v15 = 1) : (v15 = *v13 == v14), v10 && v15))
    {
      v4[2] = DefiningOp;
      v6 = 1;
    }

    else
    {
      v6 = 0;
    }
  }

  v16 = a1[1];
  v17 = *(*(a2 + 72) + 56);
  if (*v16)
  {
    v18 = *v16 == v17;
  }

  else
  {
    *v16 = v17;
    v18 = 1;
  }

  v11 = 0;
  if (DefiningOp && (v6 & v18) != 0)
  {
    a1[2] = a2;
    return 1;
  }

  return v11;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  v4 = *a1;
  v15 = *(*(**(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp(&v15);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id || (*(result + 46) & 0x80) == 0 || *(result + 68) != 1)
    {
      goto LABEL_7;
    }

    v7 = *(*(result + 72) + 24);
    v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        v6 = 0;
        goto LABEL_8;
      }
    }

    else
    {
      **v4 = v7;
    }

    v4[1] = result;
    v6 = 1;
  }

LABEL_8:
  v9 = *a2;
  v10 = *(a2 + 8);
  v11 = v6 & **a2;
  if (!result)
  {
    v11 = 0;
  }

  *v9 = v11;
  v12 = a1[1];
  v13 = *(*(*v10 + 72) + 56);
  if (*v12)
  {
    v14 = *v12 == v13;
  }

  else
  {
    *v12 = v13;
    v9 = *a2;
    v11 = **a2 != 0;
    v14 = 1;
  }

  *v9 = v14 & v11;
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t ***a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *a1;
  v19 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v19);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **v4) == 0) ? (**v4 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v13 = v4[1], v14 = *(v7 + 56), !*v13) ? (*v13 = v14, v15 = 1) : (v15 = *v13 == v14), v10 && v15))
    {
      v4[2] = DefiningOp;
      v6 = 1;
    }

    else
    {
      v6 = 0;
    }
  }

  v16 = a1[1];
  v17 = *(*(a2 + 72) + 56);
  if (*v16)
  {
    v18 = *v16 == v17;
  }

  else
  {
    *v16 = v17;
    v18 = 1;
  }

  v11 = 0;
  if (DefiningOp && (v6 & v18) != 0)
  {
    a1[2] = a2;
    return 1;
  }

  return v11;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  v4 = *a1;
  v15 = *(*(**(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp(&v15);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id || (*(result + 46) & 0x80) == 0 || *(result + 68) != 1)
    {
      goto LABEL_7;
    }

    v7 = *(*(result + 72) + 24);
    v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        v6 = 0;
        goto LABEL_8;
      }
    }

    else
    {
      **v4 = v7;
    }

    v4[1] = result;
    v6 = 1;
  }

LABEL_8:
  v9 = *a2;
  v10 = *(a2 + 8);
  v11 = v6 & **a2;
  if (!result)
  {
    v11 = 0;
  }

  *v9 = v11;
  v12 = a1[1];
  v13 = *(*(*v10 + 72) + 56);
  if (*v12)
  {
    v14 = *v12 == v13;
  }

  else
  {
    *v12 = v13;
    v9 = *a2;
    v11 = **a2 != 0;
    v14 = 1;
  }

  *v9 = v14 & v11;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  v4 = *a1;
  v15 = *(*(**(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp(&v15);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidOp,void>::id || (*(result + 46) & 0x80) == 0 || *(result + 68) != 1)
    {
      goto LABEL_7;
    }

    v7 = *(*(result + 72) + 24);
    v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        v6 = 0;
        goto LABEL_8;
      }
    }

    else
    {
      **v4 = v7;
    }

    v4[1] = result;
    v6 = 1;
  }

LABEL_8:
  v9 = *a2;
  v10 = *(a2 + 8);
  v11 = v6 & **a2;
  if (!result)
  {
    v11 = 0;
  }

  *v9 = v11;
  v12 = a1[1];
  v13 = *(*(*v10 + 72) + 56);
  if (*v12)
  {
    v14 = *v12 == v13;
  }

  else
  {
    *v12 = v13;
    v9 = *a2;
    v11 = **a2 != 0;
    v14 = 1;
  }

  *v9 = v14 & v11;
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder>>::match(uint64_t **a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *(a2 + 72);
  v5 = *(v4 + 24);
  v6 = **a1;
  if (v6)
  {
    v7 = v6 == v5;
  }

  else
  {
    **a1 = v5;
    v4 = *(a2 + 72);
    v7 = 1;
  }

  v8 = a1[1];
  v12 = *(v4 + 56);
  result = mlir::Value::getDefiningOp(&v12);
  if (result)
  {
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SigmoidOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 1)
    {
      v10 = *(*(result + 72) + 24);
      v11 = **v8;
      if (!v11)
      {
        **v8 = v10;
        goto LABEL_15;
      }

      if (v11 == v10)
      {
LABEL_15:
        v8[1] = result;
        if (v7)
        {
          a1[2] = a2;
          return 1;
        }
      }
    }

    return 0;
  }

  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  v14 = *(*(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v14);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **a3) == 0) ? (**a3 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v11 = a3[1], v14 = *(v7 + 56), (v12 = mlir::Value::getDefiningOp(&v14)) != 0) && *(*(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id && (!*v11 || *v11 == v12) && (*v11 = v12, v10)))
    {
      a3[2] = v6;
      v5 = 1;
    }

    else
    {
      v5 = 0;
    }
  }

  return (v6 != 0) & v5;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> & *)#1},0ul,1ul,2ul,3ul,4ul>(uint64_t *a1, uint64_t a2)
{
  v4 = *a1;
  v29 = *(*(**(a2 + 8) + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v29);
  v7 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v25 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(DefiningOp, 0, *v4), v26 = *(v4 + 8), v27 = *(*(v7 + 72) + 56), !*v26) ? (*v26 = v27, v28 = 1) : (v28 = *v26 == v27), v6 = v25 & v28, v6 == 1))
    {
      *(v4 + 16) = v7;
    }

    else
    {
      LOBYTE(v6) = 0;
    }
  }

  v8 = v6 & **a2;
  if (!v7)
  {
    v8 = 0;
  }

  **a2 = v8;
  v9 = a1[1];
  v29 = *(*(**(a2 + 8) + 72) + 56);
  v10 = mlir::Value::getDefiningOp(&v29);
  if (v10)
  {
    if (*(*(v10 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id && (!*v9 || *v9 == v10))
    {
      *v9 = v10;
      v11 = 1;
    }

    else
    {
      v11 = 0;
    }
  }

  v12 = v11 & **a2;
  if (!v10)
  {
    v12 = 0;
  }

  **a2 = v12;
  v13 = a1[2];
  v29 = *(*(**(a2 + 8) + 72) + 88);
  v14 = mlir::Value::getDefiningOp(&v29);
  if (v14)
  {
    if (*(*(v14 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id && (!*v13 || *v13 == v14))
    {
      *v13 = v14;
      v15 = 1;
    }

    else
    {
      v15 = 0;
    }
  }

  v16 = v15 & **a2;
  if (!v14)
  {
    v16 = 0;
  }

  **a2 = v16;
  v17 = a1[3];
  v29 = *(*(**(a2 + 8) + 72) + 120);
  v18 = mlir::Value::getDefiningOp(&v29);
  if (v18)
  {
    if (*(*(v18 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id && (!*v17 || *v17 == v18))
    {
      *v17 = v18;
      v19 = 1;
    }

    else
    {
      v19 = 0;
    }
  }

  v20 = v19 & **a2;
  if (!v18)
  {
    v20 = 0;
  }

  **a2 = v20;
  v21 = a1[4];
  v29 = *(*(**(a2 + 8) + 72) + 152);
  result = mlir::Value::getDefiningOp(&v29);
  if (result)
  {
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id && (!*v21 || *v21 == result))
    {
      *v21 = result;
      v23 = 1;
    }

    else
    {
      v23 = 0;
    }
  }

  v24 = v23 & **a2;
  if (!result)
  {
    v24 = 0;
  }

  **a2 = v24;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::FastFourierTransformOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  v4 = *a1;
  v15 = *(*(**(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp(&v15);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id || (*(result + 46) & 0x80) == 0 || *(result + 68) != 1)
    {
      goto LABEL_7;
    }

    v7 = *(*(result + 72) + 24);
    v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        v6 = 0;
        goto LABEL_8;
      }
    }

    else
    {
      **v4 = v7;
    }

    v4[1] = result;
    v6 = 1;
  }

LABEL_8:
  v9 = *a2;
  v10 = *(a2 + 8);
  v11 = v6 & **a2;
  if (!result)
  {
    v11 = 0;
  }

  *v9 = v11;
  v12 = a1[1];
  v13 = *(*(*v10 + 72) + 56);
  if (*v12)
  {
    v14 = *v12 == v13;
  }

  else
  {
    *v12 = v13;
    v9 = *a2;
    v11 = **a2 != 0;
    v14 = 1;
  }

  *v9 = v14 & v11;
  return result;
}

uint64_t mlir::mps::anonymous namespace::CanonicalizeMatMulExpandSqueezeBinary<mlir::mps::AddOp>::matchAndRewrite(uint64_t a1, uint64_t a2)
{
  v53 = 0;
  v54 = a2;
  v51 = 0;
  v52 = 0;
  v49[0] = &v53;
  v49[1] = &v52;
  v50 = 0;
  v47[0] = v49;
  v47[1] = &v51;
  v48 = 0;
  v45 = 0;
  v46 = 0;
  v44[0] = v47;
  v44[1] = &v46;
  OUTLINED_FUNCTION_8_7();
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id || (*(v2 + 46) & 0x80) == 0 || *(v2 + 68) != 2)
  {
    return 0;
  }

  v6 = v3;
  result = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>(v2, 0, v44);
  if (result)
  {
    SingleSqueezeIndex = mlir::mps::getSingleSqueezeIndex(v50, v6);
    if (v8)
    {
      v9 = SingleSqueezeIndex;
      OUTLINED_FUNCTION_17_8();
      v11 = (*(v10 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (v11)
      {
        v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v11 + 8);
      }

      else
      {
        v12 = 0;
      }

      v43[0] = v11;
      v43[1] = v12;
      v55[0] = v48;
      IsNegated = mlir::pdl::ApplyNativeConstraintOp::getIsNegated(v55);
      if (v9 == -1)
      {
        goto LABEL_19;
      }

      v14 = 1;
      if (IsNegated)
      {
        v14 = 2;
      }

      v15 = v14 + v9;
      mlir::CallableOpInterface::getArgAttrsAttr(v43);
      if (v15 >= v16)
      {
LABEL_19:
        OUTLINED_FUNCTION_14_9("cannot apply pattern if the squeeze is applied to the last two dimensions");
        if (v6)
        {
          if (mlir::RewriterBase::Listener::classof(v6))
          {
            OUTLINED_FUNCTION_1_11();
            (*(*v6 + 11))(v6);
          }
        }
      }

      else
      {
        v17 = OUTLINED_FUNCTION_9_6();
        SingleExpandedIndex = mlir::mps::getSingleExpandedIndex(v17, v18);
        if (v20)
        {
          if (SingleExpandedIndex == v9)
          {
            if (v9)
            {
              v21 = "cannot apply squeeze->matmul->add->expand pattern if the expand/squeeze dimension is not 0";
            }

            else
            {
              if (mlir::Operation::hasOneUse(v48))
              {
                OUTLINED_FUNCTION_17_8();
                v56 = v22;
                v42 = v51;
                v37 = v48;
                v41 = mlir::pdl::ApplyNativeConstraintOp::getIsNegated(&v37);
                OUTLINED_FUNCTION_86_0();
                TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs(v23);
                v55[0] = OUTLINED_FUNCTION_6_8(TransposeRhs, v25, v26, v27, v28, v29, v30, v31, v34, v35, v36, SWORD2(v36), SBYTE6(v36), HIBYTE(v36), v37, v38, v39, v40, v41, v42);
                v32 = *(v54 + 24);
                v56 = *(*(v45 + 72) + 56);
                mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MultiplyOp &,mlir::Value>(v6 + 1, v32, v55, &v56);
                OUTLINED_FUNCTION_21_6();
                (*(v33 + 8))(v6);
                return 1;
              }

              v21 = "pattern should not be applied if matmul ops have more than one use";
            }
          }

          else
          {
            v21 = "squeezed dimension and expanded dimension did not match";
          }

          return mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(v6, &v54, v21);
        }
      }
    }

    return 0;
  }

  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>(uint64_t a1, unsigned int a2, uint64_t a3)
{
  v13 = *(*(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v13);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id || (*(DefiningOp + 46) & 0x80) == 0 || *(DefiningOp + 68) != 2)
    {
      goto LABEL_13;
    }

    v7 = *a3;
    v13 = *(*(DefiningOp + 72) + 24);
    v8 = mlir::Value::getDefiningOp(&v13);
    if (v8)
    {
      LODWORD(v8) = mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(v7, v8);
    }

    v9 = *(a3 + 8);
    v10 = *(*(v6 + 72) + 56);
    if (*v9)
    {
      v11 = *v9 == v10;
    }

    else
    {
      *v9 = v10;
      v11 = 1;
    }

    v5 = v8 & v11;
    if (v5 == 1)
    {
      *(a3 + 16) = v6;
    }

    else
    {
LABEL_13:
      LOBYTE(v5) = 0;
    }
  }

  return (v6 != 0) & v5;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t ***a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *a1;
  v19 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v19);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **v4) == 0) ? (**v4 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v13 = v4[1], v14 = *(v7 + 56), !*v13) ? (*v13 = v14, v15 = 1) : (v15 = *v13 == v14), v10 && v15))
    {
      v4[2] = DefiningOp;
      v6 = 1;
    }

    else
    {
      v6 = 0;
    }
  }

  v16 = a1[1];
  v17 = *(*(a2 + 72) + 56);
  if (*v16)
  {
    v18 = *v16 == v17;
  }

  else
  {
    *v16 = v17;
    v18 = 1;
  }

  v11 = 0;
  if (DefiningOp && (v6 & v18) != 0)
  {
    a1[2] = a2;
    return 1;
  }

  return v11;
}

uint64_t mlir::mps::anonymous namespace::CanonicalizeMatMulExpandSqueezeUnary<mlir::mps::ReluOp>::matchAndRewrite(uint64_t a1, uint64_t a2)
{
  v51 = 0;
  v52 = a2;
  v49 = 0;
  v50 = 0;
  v47[0] = &v51;
  v47[1] = &v50;
  v48 = 0;
  v45[0] = v47;
  v45[1] = &v49;
  v46 = 0;
  OUTLINED_FUNCTION_8_7();
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id || (*(v2 + 46) & 0x80) == 0 || *(v2 + 68) != 2)
  {
    return 0;
  }

  v5 = v3;
  v53[0] = *(*(v2 + 72) + 24);
  result = mlir::Value::getDefiningOp(v53);
  if (!result)
  {
    return result;
  }

  OUTLINED_FUNCTION_12_8();
  if (v8 != &mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id || (*(v7 + 46) & 0x80) == 0 || *(v7 + 68) != 1)
  {
    return 0;
  }

  v53[0] = *(*(v7 + 72) + 24);
  result = mlir::Value::getDefiningOp(v53);
  if (!result)
  {
    return result;
  }

  result = mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(v45, result);
  if (!result)
  {
    return result;
  }

  SingleSqueezeIndex = mlir::mps::getSingleSqueezeIndex(v48, v5);
  if ((v10 & 1) == 0)
  {
    return 0;
  }

  v11 = SingleSqueezeIndex;
  OUTLINED_FUNCTION_17_8();
  v13 = (*(v12 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v13)
  {
    v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
  }

  else
  {
    v14 = 0;
  }

  v44[0] = v13;
  v44[1] = v14;
  v53[0] = v46;
  IsNegated = mlir::pdl::ApplyNativeConstraintOp::getIsNegated(v53);
  if (v11 == -1)
  {
    goto LABEL_22;
  }

  v16 = 1;
  if (IsNegated)
  {
    v16 = 2;
  }

  v17 = v16 + v11;
  mlir::CallableOpInterface::getArgAttrsAttr(v44);
  if (v17 >= v18)
  {
LABEL_22:
    OUTLINED_FUNCTION_14_9("cannot apply pattern if the squeeze is applied to the last two dimensions");
    if (v5)
    {
      if (mlir::RewriterBase::Listener::classof(v5))
      {
        OUTLINED_FUNCTION_1_11();
        (*(*v5 + 88))(v5);
      }
    }

    return 0;
  }

  v19 = OUTLINED_FUNCTION_9_6();
  SingleExpandedIndex = mlir::mps::getSingleExpandedIndex(v19, v20);
  if ((v22 & 1) == 0)
  {
    return 0;
  }

  if (SingleExpandedIndex == v11)
  {
    if (mlir::Operation::hasOneUse(v46))
    {
      OUTLINED_FUNCTION_17_8();
      v53[5] = v23;
      v43 = v49;
      v38 = v46;
      v42 = mlir::pdl::ApplyNativeConstraintOp::getIsNegated(&v38);
      OUTLINED_FUNCTION_86_0();
      TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs(v24);
      v53[0] = OUTLINED_FUNCTION_6_8(TransposeRhs, v26, v27, v28, v29, v30, v31, v32, v35, v36, v37, SWORD2(v37), SBYTE6(v37), HIBYTE(v37), v38, v39, v40, v41, v42, v43);
      mlir::OpBuilder::create<mlir::mps::ReluOp,mlir::mps::MatMulOp &>((v5 + 8), *(v52 + 24), v53);
      OUTLINED_FUNCTION_21_6();
      (*(v33 + 8))(v5);
      return 1;
    }

    v34 = "pattern should not be applied if matmul ops have more than one use";
  }

  else
  {
    v34 = "squeezed dimension and expanded dimension did not match";
  }

  return mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(v5, &v52, v34);
}

uint64_t mlir::detail::enumerate<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DivideOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder> * *)#1}>(uint64_t *a1, uint64_t a2)
{
  v4 = *a1;
  v12 = *(*(**(a2 + 8) + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v12);
  v7 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 1 && (v8 = *v4, v12 = *(*(DefiningOp + 72) + 24), (v9 = mlir::Value::getDefiningOp(&v12)) != 0) && mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>::match(v8, v9))
    {
      *(v4 + 8) = v7;
      v6 = 1;
    }

    else
    {
      v6 = 0;
    }
  }

  v10 = v6 & **a2;
  if (!v7)
  {
    v10 = 0;
  }

  **a2 = v10;
  return mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DivideOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,mlir::mps::DivideOp *)#1}::operator()<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder>>(a2, 1u, a1[1]);
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DivideOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,mlir::mps::DivideOp *)#1}::operator()<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder>>(uint64_t a1, unsigned int a2, uint64_t *a3)
{
  v15 = *(*(**(a1 + 8) + 72) + 32 * a2 + 24);
  result = mlir::Value::getDefiningOp(&v15);
  if (result && (v6 = result, *(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id) && (*(result + 46) & 0x80) != 0 && *(result + 68) == 2)
  {
    v7 = *a3;
    v15 = *(*(result + 72) + 24);
    result = mlir::Value::getDefiningOp(&v15);
    v9 = result;
    if (result)
    {
      if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 1 && (v10 = *v7, v15 = *(*(result + 72) + 24), (result = mlir::Value::getDefiningOp(&v15)) != 0) && (result = mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>::match(v10, result), result))
      {
        *(v7 + 8) = v9;
        v8 = 1;
      }

      else
      {
        v8 = 0;
      }
    }

    v12 = a3[1];
    v13 = *(*(v6 + 72) + 56);
    if (*v12)
    {
      v14 = *v12 == v13;
    }

    else
    {
      *v12 = v13;
      v14 = 1;
    }

    v11 = 0;
    if (v9 && (v8 & v14) != 0)
    {
      a3[2] = v6;
      v11 = 1;
    }
  }

  else
  {
    v11 = 0;
  }

  **a1 &= v11;
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>::match(uint64_t **a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *(a2 + 72);
  v5 = *(v4 + 24);
  v6 = **a1;
  if (v6)
  {
    v7 = v6 == v5;
  }

  else
  {
    **a1 = v5;
    v4 = *(a2 + 72);
    v7 = 1;
  }

  v8 = a1[1];
  v17 = *(v4 + 56);
  result = mlir::Value::getDefiningOp(&v17);
  if (result)
  {
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 2)
    {
      v10 = *(result + 72);
      v11 = *(v10 + 24);
      v12 = **v8;
      if (v12)
      {
        v13 = v12 == v11;
      }

      else
      {
        **v8 = v11;
        v10 = *(result + 72);
        v13 = 1;
      }

      v14 = v8[1];
      v15 = *(v10 + 56);
      if (*v14)
      {
        v16 = *v14 == v15;
      }

      else
      {
        *v14 = v15;
        v16 = 1;
      }

      if (v13 && v16)
      {
        v8[2] = result;
        if (v7)
        {
          a1[2] = a2;
          return 1;
        }
      }
    }

    return 0;
  }

  return result;
}

uint64_t mlir::mps::anonymous namespace::CanonicalizeTensorFromElements::matchAndRewrite()
{
  OUTLINED_FUNCTION_8_7();
  if (v1 != &mlir::detail::TypeIDResolver<mlir::tensor::FromElementsOp,void>::id)
  {
    return 0;
  }

  OUTLINED_FUNCTION_19_6();
  if ((v3 & 0x80) == 0)
  {
    return 0;
  }

  if (*(v0 + 68) != 1)
  {
    return 0;
  }

  v4 = v2;
  v19 = *(*(v0 + 72) + 24);
  if (!mlir::Value::getDefiningOp(&v19))
  {
    return 0;
  }

  OUTLINED_FUNCTION_12_8();
  if (v6 != &mlir::detail::TypeIDResolver<mlir::tensor::ExtractOp,void>::id || (*(v5 + 46) & 0x80) == 0 || *(v5 + 68) != 1)
  {
    return 0;
  }

  v7 = *(*(v5 + 72) + 24);
  v8 = *(v7 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(*v8 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v8 = 0;
  }

  v19 = v8;
  if (!v8)
  {
    return 0;
  }

  Value = mlir::ArrayAttr::getValue(&v19);
  if (mlir::ShapedType::getNumElements(Value, v10) != 1)
  {
    return 0;
  }

  v11 = *(v0 + 24);
  v12 = 1;
  LODWORD(v17) = 1;
  v13 = mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((v4 + 8), v11, &v17);
  v17 = v7;
  v18 = v13 - 16;
  mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value&>((v4 + 8), *(v0 + 24), &v17, &v18);
  OUTLINED_FUNCTION_140();
  v14 = OUTLINED_FUNCTION_9_6();
  v15(v14);
  return v12;
}

uint64_t mlir::mps::anonymous namespace::FuseBinaryWithConstants<mlir::mps::AddOp,true>::matchAndRewrite()
{
  OUTLINED_FUNCTION_3_9(*MEMORY[0x1E69E9840]);
  if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
  {
    return 0;
  }

  OUTLINED_FUNCTION_19_6();
  if ((v3 & 0x80) == 0 || *(v0 + 68) != 2)
  {
    return 0;
  }

  v5 = OUTLINED_FUNCTION_13_9();
  v8 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(v5, v6, v7);
  result = OUTLINED_FUNCTION_15_8(v8, v9, v10, v11, v12, v13, v14, v15, v51, v54, v57, v58, v59, v60, v61, v62, v63, v64, v65[0]);
  if (result)
  {
    v16 = result;
    OUTLINED_FUNCTION_12_8();
    OUTLINED_FUNCTION_20_6();
    if (!v17)
    {
      return 0;
    }

    v65[0] = v64;
    AsAttribute = mlir::mps::ConstantOp::getAsAttribute(v65);
    v26 = OUTLINED_FUNCTION_22_5(AsAttribute, v19, v20, v21, v22, v23, v24, v25, v52, v55, v57);
    v28 = OUTLINED_FUNCTION_23_4(v26, v27);
    if ((v28 & 1) == 0)
    {
      return 0;
    }

    if ((*(v1 + 96) & 1) == 0)
    {
      v36 = *OUTLINED_FUNCTION_11_6(v28, v29, v30, v31, v32, v33, v34, v35, v53, v56, v57, v58, v59, v60, v61, v62);
      if (!v36 || *v36)
      {
        v59 = v16;
        v65[0] = mlir::mps::ConstantOp::getAsAttribute(&v59);
        v65[1] = v37;
        if (mlir::ElementsAttr::isSplat(v65))
        {
          OUTLINED_FUNCTION_86_0();
          v57 = mlir::mps::ConstantOp::getAsAttribute(v38);
          v58 = v39;
          if ((mlir::ElementsAttr::isSplat(&v57) & 1) == 0)
          {
            return 0;
          }
        }
      }
    }

    OUTLINED_FUNCTION_7_7();
    v40 = OUTLINED_FUNCTION_10_9();
    mlir::OpBuilder::createOrFold<mlir::mps::AddOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>(v40, v41, v42, v43, v44);
    v45 = *v65[0];
    if (v65[0] != v16)
    {
      free(v65[0]);
    }

    v65[0] = v45;
    v46 = OUTLINED_FUNCTION_4_9();
    mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(v46, v47, v48, v65);
    OUTLINED_FUNCTION_140();
    v49 = OUTLINED_FUNCTION_9_6();
    v50(v49);
    return 1;
  }

  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  v14 = *(*(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v14);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **a3) == 0) ? (**a3 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v11 = a3[1], v14 = *(v7 + 56), (v12 = mlir::Value::getDefiningOp(&v14)) != 0) && *(*(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id && (!*v11 || *v11 == v12) && (*v11 = v12, v10)))
    {
      a3[2] = v6;
      v5 = 1;
    }

    else
    {
      v5 = 0;
    }
  }

  return (v6 != 0) & v5;
}

uint64_t mlir::mps::anonymous namespace::FuseBinaryWithConstants<mlir::mps::MultiplyOp,true>::matchAndRewrite()
{
  OUTLINED_FUNCTION_3_9(*MEMORY[0x1E69E9840]);
  if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id)
  {
    return 0;
  }

  OUTLINED_FUNCTION_19_6();
  if ((v3 & 0x80) == 0 || *(v0 + 68) != 2)
  {
    return 0;
  }

  v5 = OUTLINED_FUNCTION_13_9();
  v8 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(v5, v6, v7);
  result = OUTLINED_FUNCTION_15_8(v8, v9, v10, v11, v12, v13, v14, v15, v51, v54, v57, v58, v59, v60, v61, v62, v63, v64, v65[0]);
  if (result)
  {
    v16 = result;
    OUTLINED_FUNCTION_12_8();
    OUTLINED_FUNCTION_20_6();
    if (!v17)
    {
      return 0;
    }

    v65[0] = v64;
    AsAttribute = mlir::mps::ConstantOp::getAsAttribute(v65);
    v26 = OUTLINED_FUNCTION_22_5(AsAttribute, v19, v20, v21, v22, v23, v24, v25, v52, v55, v57);
    v28 = OUTLINED_FUNCTION_23_4(v26, v27);
    if ((v28 & 1) == 0)
    {
      return 0;
    }

    if ((*(v1 + 96) & 1) == 0)
    {
      v36 = *OUTLINED_FUNCTION_11_6(v28, v29, v30, v31, v32, v33, v34, v35, v53, v56, v57, v58, v59, v60, v61, v62);
      if (!v36 || *v36)
      {
        v59 = v16;
        v65[0] = mlir::mps::ConstantOp::getAsAttribute(&v59);
        v65[1] = v37;
        if (mlir::ElementsAttr::isSplat(v65))
        {
          OUTLINED_FUNCTION_86_0();
          v57 = mlir::mps::ConstantOp::getAsAttribute(v38);
          v58 = v39;
          if ((mlir::ElementsAttr::isSplat(&v57) & 1) == 0)
          {
            return 0;
          }
        }
      }
    }

    OUTLINED_FUNCTION_7_7();
    v40 = OUTLINED_FUNCTION_10_9();
    mlir::OpBuilder::createOrFold<mlir::mps::MultiplyOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>(v40, v41, v42, v43, v44);
    v45 = *v65[0];
    if (v65[0] != v16)
    {
      free(v65[0]);
    }

    v65[0] = v45;
    v46 = OUTLINED_FUNCTION_4_9();
    mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(v46, v47, v48, v65);
    OUTLINED_FUNCTION_140();
    v49 = OUTLINED_FUNCTION_9_6();
    v50(v49);
    return 1;
  }

  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  v14 = *(*(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v14);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **a3) == 0) ? (**a3 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v11 = a3[1], v14 = *(v7 + 56), (v12 = mlir::Value::getDefiningOp(&v14)) != 0) && *(*(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id && (!*v11 || *v11 == v12) && (*v11 = v12, v10)))
    {
      a3[2] = v6;
      v5 = 1;
    }

    else
    {
      v5 = 0;
    }
  }

  return (v6 != 0) & v5;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder>::match(uint64_t *a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *a1;
  v12[0] = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(v12);
  v7 = DefiningOp;
  if (DefiningOp)
  {
    v14 = DefiningOp;
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SoftmaxOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2)
    {
      v13 = 1;
      v12[0] = &v13;
      v12[1] = &v14;
      mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul>(v4, v12);
      v6 = v13;
      if (v13 == 1)
      {
        *(v4 + 16) = v14;
      }
    }

    else
    {
      v6 = 0;
    }
  }

  v9 = a1[1];
  v10 = *(*(a2 + 72) + 56);
  if (*v9)
  {
    v11 = *v9 == v10;
  }

  else
  {
    *v9 = v10;
    v11 = 1;
  }

  result = 0;
  if (v7)
  {
    if ((v6 & v11) != 0)
    {
      a1[2] = a2;
      return 1;
    }
  }

  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t a1, uint64_t a2)
{
  v4 = *(*(a2 + 48) + 16);
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id)
  {
    if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id && (*(a2 + 46) & 0x80) != 0 && *(a2 + 68) == 2)
    {
      v5 = *a1;
      v6 = **a1;
      v7 = *(a2 + 72);
      v8 = *(v7 + 24);
      if (*v6)
      {
        v9 = *v6 == v8;
      }

      else
      {
        *v6 = v8;
        v7 = *(a2 + 72);
        v9 = 1;
      }

      v18 = v5[1];
      v19 = *(v7 + 56);
      if (*v18)
      {
        v20 = *v18 == v19;
      }

      else
      {
        *v18 = v19;
        v20 = 1;
      }

      if (v9 && v20)
      {
        v5[2] = a2;
        return 1;
      }
    }

    if (*(a2 + 36))
    {
      v21 = *(a1 + 8);
      v22 = a2 - 16;
      if (*v21)
      {
        return *v21 == v22;
      }

      *v21 = v22;
      return 1;
    }

    return 0;
  }

  v11 = *a1;
  v10 = *(a1 + 8);
  v42 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v42);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v14 = *(DefiningOp + 72), v15 = *(v14 + 24), (v16 = **v11) == 0) ? (**v11 = v15, v14 = *(DefiningOp + 72), v17 = 1) : (v17 = v16 == v15), (v24 = v11[1], v25 = *(v14 + 56), !*v24) ? (*v24 = v25, v26 = 1) : (v26 = *v24 == v25), v13 = v17 && v26, v13 == 1))
    {
      v11[2] = DefiningOp;
    }

    else
    {
      v13 = 0;
    }
  }

  v27 = *(*(a2 + 72) + 56);
  if (*v10)
  {
    v28 = *v10 == v27;
    if (!DefiningOp)
    {
      goto LABEL_40;
    }
  }

  else
  {
    *v10 = v27;
    v28 = 1;
    if (!DefiningOp)
    {
      goto LABEL_40;
    }
  }

  if (v13 & v28)
  {
    goto LABEL_36;
  }

LABEL_40:
  **(a1 + 8) = 0;
  v29 = *a1;
  ***a1 = 0;
  *v29[1] = 0;
  v29[2] = 0;
  v31 = *a1;
  v30 = *(a1 + 8);
  v32 = *(a2 + 72);
  v33 = *(v32 + 24);
  if (*v30)
  {
    v34 = *v30 == v33;
  }

  else
  {
    *v30 = v33;
    v32 = *(a2 + 72);
    v34 = 1;
  }

  v42 = *(v32 + 56);
  result = mlir::Value::getDefiningOp(&v42);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id || (*(result + 46) & 0x80) == 0 || *(result + 68) != 2)
    {
      return 0;
    }

    v35 = *(result + 72);
    v36 = *(v35 + 24);
    v37 = **v31;
    if (v37)
    {
      v38 = v37 == v36;
    }

    else
    {
      **v31 = v36;
      v35 = *(result + 72);
      v38 = 1;
    }

    v39 = v31[1];
    v40 = *(v35 + 56);
    if (*v39)
    {
      v41 = *v39 == v40;
    }

    else
    {
      *v39 = v40;
      v41 = 1;
    }

    if (!v38 || !v41)
    {
      return 0;
    }

    v31[2] = result;
    if (!v34)
    {
      return 0;
    }

LABEL_36:
    if ((*(a1 + 24) & 1) == 0)
    {
      *(a1 + 24) = 1;
    }

    *(a1 + 16) = a2;
    return 1;
  }

  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps_spi::ScaledDotProductAttentionOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul,4ul>(uint64_t **a1, uint64_t a2)
{
  v4 = *(**(a2 + 8) + 72);
  v5 = *(v4 + 24);
  v6 = **a1;
  if (v6)
  {
    v7 = v6 == v5;
  }

  else
  {
    **a1 = v5;
    v4 = *(**(a2 + 8) + 72);
    v7 = 1;
  }

  **a2 &= v7;
  v8 = a1[1];
  v33 = *(v4 + 56);
  DefiningOp = mlir::Value::getDefiningOp(&v33);
  v11 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && (v28 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(DefiningOp, 0, *v8), v29 = v8[1], v33 = *(*(v11 + 72) + 56), (v30 = mlir::Value::getDefiningOp(&v33)) != 0) && *(*(v30 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id && (!*v29 || *v29 == v30) && (*v29 = v30, v28))
    {
      v8[2] = v11;
      v10 = 1;
    }

    else
    {
      v10 = 0;
    }
  }

  v12 = v10 & **a2;
  if (!v11)
  {
    v12 = 0;
  }

  **a2 = v12;
  v13 = a1[2];
  v33 = *(*(**(a2 + 8) + 72) + 88);
  result = mlir::Value::getDefiningOp(&v33);
  v16 = result;
  if (result)
  {
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 2 && (v31 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(result, 0, *v13), v32 = v13[1], v33 = *(*(v16 + 72) + 56), (result = mlir::Value::getDefiningOp(&v33)) != 0) && *(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id && (!*v32 || *v32 == result) && (*v32 = result, v31))
    {
      v13[2] = v16;
      v15 = 1;
    }

    else
    {
      v15 = 0;
    }
  }

  v17 = *a2;
  v18 = v15 & **a2;
  if (v16)
  {
    v19 = v18;
  }

  else
  {
    v19 = 0;
  }

  *v17 = v19;
  v20 = a1[3];
  v21 = *(**(a2 + 8) + 72);
  v22 = *(v21 + 120);
  if (*v20)
  {
    v23 = *v20 == v22;
  }

  else
  {
    *v20 = v22;
    v17 = *a2;
    v21 = *(**(a2 + 8) + 72);
    v19 = **a2 != 0;
    v23 = 1;
  }

  v24 = v23 && v19;
  *v17 = v24;
  v25 = a1[4];
  v26 = *(v21 + 152);
  if (*v25)
  {
    v27 = *v25 == v26;
  }

  else
  {
    *v25 = v26;
    v17 = *a2;
    v24 = **a2 != 0;
    v27 = 1;
  }

  *v17 = v27 && v24;
  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  v14 = *(*(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v14);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BroadcastToOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **a3) == 0) ? (**a3 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v11 = a3[1], v14 = *(v7 + 56), (v12 = mlir::Value::getDefiningOp(&v14)) != 0) && *(*(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id && (!*v11 || *v11 == v12) && (*v11 = v12, v10)))
    {
      a3[2] = v6;
      v5 = 1;
    }

    else
    {
      v5 = 0;
    }
  }

  return (v6 != 0) & v5;
}

void mlir::detail::constant_op_binder<mlir::ElementsAttr>::match()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_5_10(v2);
  }
}

void mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value,mlir::Value,unsigned long long,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::mps::PaddingStyle,mlir::mps::TensorDataLayout,mlir::mps::TensorDataLayout>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.conv_2d";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::mps::DepthwiseConv2DOp,mlir::Value,mlir::Value,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::mps::PaddingStyle,mlir::mps::TensorDataLayout,mlir::mps::TensorDataLayout>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.depthwise_conv_2d";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DOp,mlir::Value,mlir::Value,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::mps::PaddingStyle,int>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.depthwise_conv_3d";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::mps::PoolAvgOp,mlir::Value,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyleAttr,mlir::DenseIntElementsAttr&,mlir::UnitAttr,mlir::UnitAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.pooling_average";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyleAttr,mlir::DenseIntElementsAttr&,mlir::UnitAttr,mlir::UnitAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.pooling_l2_norm";
  *(a2 + 24) = 19;
}

void mlir::OpInterface<mlir::ConvertOpLayoutInterface,mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::ConvertOpLayoutInterface>();
    mlir::detail::TypeIDResolver<mlir::ConvertOpLayoutInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ConvertOpLayoutInterface>();
    mlir::detail::TypeIDResolver<mlir::ConvertOpLayoutInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value,mlir::Value,BOOL,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.matmul";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value,mlir::mps::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.permute";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::mps::PermuteOp &,mlir::Value,mlir::Value,mlir::Value,mlir::Type,mlir::IntegerAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.dequantize";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.transpose";
  *(a2 + 24) = 13;
}

void mlir::ElementsAttr::value_begin<llvm::APInt>(llvm *a1, uint64_t *a2)
{
  v3 = llvm::errs(a1);
  v4 = llvm::getTypeName<llvm::APInt>();
  v6 = OUTLINED_FUNCTION_16_7(v4, v5);
  v8 = mlir::operator<<(v7, *a2);
  llvm::raw_ostream::operator<<(v8, "\n");
  __break(1u);
}

void mlir::ElementsAttr::value_begin<mlir::Attribute>(llvm *a1, uint64_t *a2)
{
  v3 = llvm::errs(a1);
  v4 = llvm::getTypeName<mlir::Attribute>();
  v6 = OUTLINED_FUNCTION_16_7(v4, v5);
  v8 = mlir::operator<<(v7, *a2);
  llvm::raw_ostream::operator<<(v8, "\n");
  __break(1u);
}

void mlir::OpBuilder::createOrFold<mlir::mps::DivideOp,mlir::Value,mlir::mps::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.divide";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.constant";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.multiply";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::createOrFold<mlir::mps::SubtractOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.subtract";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.add";
  *(a2 + 24) = 7;
}

void mlir::OpBuilder::create<mlir::mps::InstanceNormOp,mlir::Value,mlir::Value,llvm::APFloat>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.instance_norm";
  *(a2 + 24) = 17;
}

void mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.square";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value,mlir::UnitAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reshape";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.cast";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::mps::BroadcastToOp,mlir::Value &,mlir::mps::ShapeOp>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.broadcast_to";
  *(a2 + 24) = 16;
}

void mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.shape";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::mps::SquareRootOp,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.square_root";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reciprocal_square_root";
  *(a2 + 24) = 26;
}

void mlir::OpBuilder::create<mlir::mps::ReciprocalOp,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reciprocal";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::mps::TypeConstraintOp,mlir::mps::BroadcastToOp &,mlir::Type>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.type_constraint";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::mps::SwishOp,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.swish";
  *(a2 + 24) = 9;
}

void mlir::mps::anonymous namespace::CanonicalizeIdentity::matchAndRewrite()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_5_10(v2);
  }
}

void mlir::OpBuilder::create<mlir::mps::ConcatOp,llvm::SmallVector<mlir::Value,4u> &,mlir::Value,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.concat";
  *(a2 + 24) = 10;
}

void mlir::mps::anonymous namespace::CanonicalizeOpsWith0Dims::matchAndRewrite()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::mps::FastFourierTransformOp,mlir::Value,mlir::Value,mlir::mps::FFTScalingMode,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.fast_fourier_transform";
  *(a2 + 24) = 26;
}

void mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::Value&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.squeeze";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::mps::ReluOp,mlir::mps::MatMulOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.relu";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::mps::SoftmaxOp,mlir::Value,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.softmax";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::mps_spi::ScaledDotProductAttentionOp,mlir::Value,mlir::Value,mlir::Value,mlir::Value&,mlir::Value&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps_spi.sdpa";
  *(a2 + 24) = 12;
}

void mlir::mps::registerConvertOpLayoutExternalModels(mlir::DialectRegistry &)::$_0::__invoke()
{
  {
    v0 = llvm::getTypeName<mlir::ConvertOpLayoutInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1_12(v2);
  }
}

void mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.dynamic_shape_cast";
  *(a2 + 24) = 22;
}

void mlir::OpBuilder::create<mlir::mps::PoolMaxOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL,mlir::mps::PoolIndicesMode,mlir::TypeAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.pooling_max";
  *(a2 + 24) = 15;
}

void mlir::mps::registerMapDynamicShapeOpExternalModels(mlir::DialectRegistry &)::$_0::__invoke()
{
  {
    v0 = llvm::getTypeName<mlir::MapDynamicShapeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_0_8(v2);
  }
}

uint64_t llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::mps::MemrefAllocTransformationBase::buildDependencies(mlir::Operation *)::$_1>(uint64_t **a1, uint64_t a2)
{
  v234 = *MEMORY[0x1E69E9840];
  v4 = *(*(a2 + 48) + 16);
  v5 = v4 == &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id || v4 == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id;
  if (!v5 || (v220 = *(*(a2 + 72) + 24), (DefiningOp = mlir::Value::getDefiningOp(&v220)) == 0))
  {
LABEL_13:
    InterfaceFor = mlir::OpInterface<mlir::ViewLikeOpInterface,mlir::detail::ViewLikeOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
    if (InterfaceFor)
    {
      if (a2)
      {
        InterfaceFor = mlir::OpInterface<mlir::ViewLikeOpInterface,mlir::detail::ViewLikeOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
      }

      else
      {
        InterfaceFor = 0;
      }

      v9 = a2;
    }

    else
    {
      v9 = 0;
    }

    v227 = v9;
    v228 = InterfaceFor;
    if (v9)
    {
      CallableForCallee = mlir::CallOpInterface::getCallableForCallee(&v227);
      v220 = (v227 - 16);
      OUTLINED_FUNCTION_3_10();
      while (1)
      {
        v11 = mlir::ValueRange::dereference_iterator(&p_CallableForCallee, v10);
        v19 = OUTLINED_FUNCTION_10_10(v11, v12, v13, v14, v15, v16, v17, v18, v184, v188, v193, v197, v202, v208, v209, v210, v211, v212, v213, v214, v215, v216, v217, v218, v219, v220, v221, p_CallableForCallee, v223, v224, v225);
        OUTLINED_FUNCTION_11_7(v19, v20, v21, v22, v23, v24, v25, v26, v185, v189, v194, v198, v203, v208, v209, v210, v211);
        OUTLINED_FUNCTION_2_11();
        if (!v5)
        {
          goto LABEL_22;
        }

        if (*(v27 + 5))
        {
          OUTLINED_FUNCTION_4_10();
          do
          {
            OUTLINED_FUNCTION_7_8();
            if (v5)
            {
              goto LABEL_23;
            }

            OUTLINED_FUNCTION_6_9();
          }

          while (!v5);
        }

        OUTLINED_FUNCTION_5_11();
        if (v31)
        {
LABEL_22:
          llvm::SmallPtrSetImplBase::insert_imp_big(v27, v28);
        }

        else
        {
          OUTLINED_FUNCTION_1_13(v27, v28, v30);
        }

LABEL_23:
        OUTLINED_FUNCTION_0_9();
        if (!v29)
        {
          return 1;
        }
      }
    }

    v32 = *(*(a2 + 48) + 16);
    if (v32 == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
    {
      goto LABEL_110;
    }

    if (v32 != &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id && v32 != &mlir::detail::TypeIDResolver<mlir::mps::StridedSliceOp,void>::id && v32 != &mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id && v32 != &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id && v32 != &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id && v32 != &mlir::detail::TypeIDResolver<mlir::mps::SliceOp,void>::id && v32 != &mlir::detail::TypeIDResolver<mlir::mps::CropOp,void>::id && v32 != &mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id && v32 != &mlir::detail::TypeIDResolver<mlir::mps::Flatten2DOp,void>::id && v32 != &mlir::detail::TypeIDResolver<mlir::tensor::ExtractOp,void>::id && v32 != &mlir::detail::TypeIDResolver<mlir::mps::ReinterpretCastOp,void>::id && v32 != &mlir::detail::TypeIDResolver<mlir::mps::VariableFromTensorOp,void>::id && v32 != &mlir::detail::TypeIDResolver<mlir::mps::AssignVariableOp,void>::id && v32 != &mlir::detail::TypeIDResolver<mlir::mps::ReadVariableOp,void>::id)
    {
      v115 = mlir::OpInterface<mlir::BranchOpInterface,mlir::detail::BranchOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
      if (v115)
      {
        v115 = mlir::OpInterface<mlir::BranchOpInterface,mlir::detail::BranchOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
        v116 = a2;
      }

      else
      {
        v116 = 0;
      }

      CallableForCallee = v116;
      v233 = v115;
      if (v116)
      {
        v117 = v116[2];
        mlir::SuccessorRange::SuccessorRange(&p_CallableForCallee, v117);
        v118 = p_CallableForCallee;
        mlir::SuccessorRange::SuccessorRange(&p_CallableForCallee, v117);
        v119 = v223;
        if (!v223)
        {
          return 1;
        }

        v120 = 0;
        while (1)
        {
          mlir::BranchOpInterface::getSuccessorOperands(&CallableForCallee, v120);
          v121 = *a1;
          v122 = mlir::MutableOperandRange::operator mlir::OperandRange(&v223);
          mlir::ValueRange::ValueRange(&v220, v122, v123);
          mlir::ValueRange::ValueRange(&v218, *(v118[4 * v120 + 3] + 48) + 8 * p_CallableForCallee, ((*(v118[4 * v120 + 3] + 56) - *(v118[4 * v120 + 3] + 48)) >> 3) - p_CallableForCallee);
          v124 = v221;
          v125 = *v121;
          v210 = v220;
          v211 = 0;
          v212 = v218;
          v213 = 0;
          if (v221)
          {
            break;
          }

LABEL_153:
          if (v225 != &v226)
          {
            free(v225);
          }

          if (++v120 == v119)
          {
            return 1;
          }
        }

        v126 = 0;
        while (1)
        {
          v127 = mlir::ValueRange::dereference_iterator(&v210, v126);
          v128 = mlir::ValueRange::dereference_iterator(&v212, v213);
          v227 = v127;
          v228 = v128;
          v129 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>>>,mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>>>::operator[](v125 + 200, &v227);
          v130 = v228;
          if (*(v129 + 8) != *v129)
          {
            goto LABEL_143;
          }

          if (*(v129 + 20))
          {
            OUTLINED_FUNCTION_4_10();
            do
            {
              OUTLINED_FUNCTION_7_8();
              if (v5)
              {
                goto LABEL_144;
              }

              OUTLINED_FUNCTION_6_9();
            }

            while (!v5);
          }

          OUTLINED_FUNCTION_5_11();
          if (v31)
          {
LABEL_143:
            llvm::SmallPtrSetImplBase::insert_imp_big(v129, v130);
          }

          else
          {
            OUTLINED_FUNCTION_1_13(v129, v130, v131);
          }

LABEL_144:
          OUTLINED_FUNCTION_8_8();
          if (v126 == v124)
          {
            goto LABEL_153;
          }
        }
      }

      v132 = mlir::OpInterface<mlir::RegionBranchOpInterface,mlir::detail::RegionBranchOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
      if (v132)
      {
        v132 = mlir::OpInterface<mlir::RegionBranchOpInterface,mlir::detail::RegionBranchOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
        v133 = a2;
      }

      else
      {
        v133 = 0;
      }

      v220 = v133;
      v221 = v132;
      if (v133)
      {
        p_CallableForCallee = &v224;
        v223 = 0x200000000;
        mlir::RegionBranchOpInterface::getSuccessorRegions(&v220, 0, &p_CallableForCallee);
        if (v223)
        {
          v134 = p_CallableForCallee;
          v135 = (p_CallableForCallee + 24 * v223);
          while (1)
          {
            v136 = *a1;
            EntrySuccessorOperands = mlir::RegionBranchOpInterface::getEntrySuccessorOperands(&v220, *v134);
            mlir::ValueRange::ValueRange(&CallableForCallee, EntrySuccessorOperands, v138);
            v139 = v134[1];
            v140 = v233;
            v141 = *v136;
            v210 = CallableForCallee;
            v211 = 0;
            v212 = v139;
            v213 = 0;
            if (v233)
            {
              break;
            }

LABEL_176:
            v134 += 3;
            if (v134 == v135)
            {
              goto LABEL_177;
            }
          }

          v142 = 0;
          while (1)
          {
            v143 = mlir::ValueRange::dereference_iterator(&v210, v142);
            v144 = mlir::ValueRange::dereference_iterator(&v212, v213);
            v227 = v143;
            v228 = v144;
            v145 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>>>,mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>>>::operator[](v141 + 200, &v227);
            v146 = v228;
            if (*(v145 + 8) != *v145)
            {
              goto LABEL_166;
            }

            if (*(v145 + 20))
            {
              OUTLINED_FUNCTION_4_10();
              do
              {
                OUTLINED_FUNCTION_7_8();
                if (v5)
                {
                  goto LABEL_167;
                }

                OUTLINED_FUNCTION_6_9();
              }

              while (!v5);
            }

            OUTLINED_FUNCTION_5_11();
            if (v31)
            {
LABEL_166:
              llvm::SmallPtrSetImplBase::insert_imp_big(v145, v146);
            }

            else
            {
              OUTLINED_FUNCTION_1_13(v145, v146, v147);
            }

LABEL_167:
            OUTLINED_FUNCTION_8_8();
            if (v142 == v140)
            {
              goto LABEL_176;
            }
          }
        }

LABEL_177:
        v148 = v220[11];
        if ((v148 & 0x7FFFFF) == 0)
        {
LABEL_213:
          if (p_CallableForCallee != &v224)
          {
            free(p_CallableForCallee);
          }

          return 1;
        }

        v149 = ((&v220[4 * ((v148 >> 23) & 1) + 17] + ((v148 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8) + 32 * v220[10];
        v206 = v149 + 24 * (v148 & 0x7FFFFF);
        while (1)
        {
          v210 = &v212;
          v211 = 0x200000000;
          mlir::RegionBranchOpInterface::getSuccessorRegions(&v220, v149, &v210);
          v151 = v210;
          if (v211)
          {
            v152 = (v210 + 24 * v211);
            do
            {
              for (i = *(v149 + 8); i != v149; i = *(i + 8))
              {
                if (i)
                {
                  v154 = (i - 8);
                }

                else
                {
                  v154 = 0;
                }

                Terminator = mlir::Block::getTerminator(v154, v150);
                v156 = mlir::OpInterface<mlir::RegionBranchTerminatorOpInterface,mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits>::getInterfaceFor(Terminator);
                if (v156)
                {
                  if (Terminator)
                  {
                    v156 = mlir::OpInterface<mlir::RegionBranchTerminatorOpInterface,mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits>::getInterfaceFor(Terminator);
                  }

                  else
                  {
                    v156 = 0;
                  }
                }

                else
                {
                  Terminator = 0;
                }

                v218 = Terminator;
                v219 = v156;
                if (Terminator)
                {
                  v157 = *a1;
                  mlir::BranchOpInterface::getSuccessorOperands(&v218, *v151);
                  v158 = mlir::MutableOperandRange::operator mlir::OperandRange(&v227);
                  v160 = v159;
                  if (v229 != &v231)
                  {
                    free(v229);
                  }

                  mlir::ValueRange::ValueRange(&v208, v158, v160);
                  v161 = v151[1];
                  v162 = v209;
                  v163 = *v157;
                  v227 = v208;
                  v228 = 0;
                  v229 = v161;
                  v230 = 0;
                  if (v209)
                  {
                    v150 = 0;
                    do
                    {
                      v164 = mlir::ValueRange::dereference_iterator(&v227, v150);
                      v165 = mlir::ValueRange::dereference_iterator(&v229, v230);
                      CallableForCallee = v164;
                      v233 = v165;
                      v166 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>>>,mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>>>::operator[](v163 + 200, &CallableForCallee);
                      v167 = v233;
                      if (*(v166 + 8) != *v166)
                      {
                        goto LABEL_197;
                      }

                      if (*(v166 + 20))
                      {
                        OUTLINED_FUNCTION_4_10();
                        do
                        {
                          OUTLINED_FUNCTION_7_8();
                          if (v5)
                          {
                            goto LABEL_198;
                          }

                          OUTLINED_FUNCTION_6_9();
                        }

                        while (!v5);
                      }

                      OUTLINED_FUNCTION_5_11();
                      if (v31)
                      {
LABEL_197:
                        llvm::SmallPtrSetImplBase::insert_imp_big(v166, v167);
                      }

                      else
                      {
                        OUTLINED_FUNCTION_1_13(v166, v167, v168);
                      }

LABEL_198:
                      v150 = (v228 + 1);
                      v228 = v150;
                      ++v230;
                    }

                    while (v150 != v162);
                  }
                }
              }

              v151 += 3;
            }

            while (v151 != v152);
            v151 = v210;
          }

          if (v151 != &v212)
          {
            free(v151);
          }

          v149 += 24;
          if (v149 == v206)
          {
            goto LABEL_213;
          }
        }
      }

      if (mlir::OpInterface<mlir::RegionBranchTerminatorOpInterface,mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits>::getInterfaceFor(a2))
      {
        return 1;
      }

      if (!mlir::OpInterface<mlir::CallOpInterface,mlir::detail::CallOpInterfaceInterfaceTraits>::getInterfaceFor(a2))
      {
        return 1;
      }

      if ((*(a2 + 46) & 0x80) == 0)
      {
        return 1;
      }

      v201 = *(a2 + 68);
      if (!v201)
      {
        return 1;
      }

      v207 = 0;
      v192 = *(a2 + 72);
      while (1)
      {
        v170 = *(a2 + 36);
        v171 = v170 ? a2 - 16 : 0;
        if (v170)
        {
          break;
        }

LABEL_240:
        if (++v207 == v201)
        {
          return 1;
        }
      }

      v172 = 0;
      v173 = *(v192 + 32 * v207 + 24);
      while (1)
      {
        NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v171, v172);
        v175 = *a1;
        v220 = v173;
        mlir::ValueRange::ValueRange(&v227, &v220, 1uLL);
        v218 = NextResultAtOffset;
        mlir::ValueRange::ValueRange(&CallableForCallee, &v218, 1uLL);
        v176 = v228;
        v177 = *v175;
        p_CallableForCallee = v227;
        v223 = 0;
        v224 = CallableForCallee;
        v225 = 0;
        if (v228)
        {
          break;
        }

LABEL_239:
        if (++v172 == v170)
        {
          goto LABEL_240;
        }
      }

      v178 = 0;
      while (1)
      {
        v179 = mlir::ValueRange::dereference_iterator(&p_CallableForCallee, v178);
        v180 = mlir::ValueRange::dereference_iterator(&v224, v225);
        v210 = v179;
        v211 = v180;
        llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>>>,mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>>>::operator[](v177 + 200, &v210);
        OUTLINED_FUNCTION_2_11();
        if (!v5)
        {
          goto LABEL_229;
        }

        if (*(v181 + 5))
        {
          OUTLINED_FUNCTION_4_10();
          do
          {
            OUTLINED_FUNCTION_7_8();
            if (v5)
            {
              goto LABEL_230;
            }

            OUTLINED_FUNCTION_6_9();
          }

          while (!v5);
        }

        OUTLINED_FUNCTION_5_11();
        if (v31)
        {
LABEL_229:
          llvm::SmallPtrSetImplBase::insert_imp_big(v181, v182);
        }

        else
        {
          OUTLINED_FUNCTION_1_13(v181, v182, v183);
        }

LABEL_230:
        OUTLINED_FUNCTION_9_7();
        if (v178 == v176)
        {
          goto LABEL_239;
        }
      }
    }

    if (v32 == &mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id)
    {
      v46 = a2;
    }

    else
    {
      v46 = 0;
    }

    v227 = v46;
    if (v46)
    {
      ODSOperandIndexAndLength = mlir::mps::ConcatOp::getODSOperandIndexAndLength(&v227, 0);
      if ((*(v227 + 46) & 0x80) != 0)
      {
        v48 = *(v227 + 72);
      }

      else
      {
        v48 = 0;
      }

      v49 = (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength);
      v50 = v49 - ODSOperandIndexAndLength;
      if (v49 == ODSOperandIndexAndLength)
      {
        return 1;
      }

      v51 = 0;
      v52 = v48 + 32 * ODSOperandIndexAndLength;
      v53 = (a2 - 16);
LABEL_82:
      v54 = 0;
      CallableForCallee = *(v52 + 32 * v51 + 24);
      v55 = *a1;
      v220 = v53;
      v56 = *v55;
      p_CallableForCallee = &CallableForCallee;
      v223 = 0;
      v224 = &v220;
      v225 = 0;
      while (1)
      {
        v57 = mlir::ValueRange::dereference_iterator(&p_CallableForCallee, v54);
        v58 = mlir::ValueRange::dereference_iterator(&v224, v225);
        v210 = v57;
        v211 = v58;
        llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>>>,mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>>>::operator[](v56 + 200, &v210);
        OUTLINED_FUNCTION_2_11();
        if (!v5)
        {
          goto LABEL_84;
        }

        if (*(v59 + 5))
        {
          OUTLINED_FUNCTION_4_10();
          do
          {
            OUTLINED_FUNCTION_7_8();
            if (v5)
            {
              goto LABEL_85;
            }

            OUTLINED_FUNCTION_6_9();
          }

          while (!v5);
        }

        OUTLINED_FUNCTION_5_11();
        if (v31)
        {
LABEL_84:
          llvm::SmallPtrSetImplBase::insert_imp_big(v59, v60);
        }

        else
        {
          OUTLINED_FUNCTION_1_13(v59, v60, v62);
        }

LABEL_85:
        OUTLINED_FUNCTION_0_9();
        if (!v61)
        {
          if (++v51 == v50)
          {
            return 1;
          }

          goto LABEL_82;
        }
      }
    }

    if (v32 != &mlir::detail::TypeIDResolver<mlir::mps::AssignVariableOp,void>::id)
    {
LABEL_110:
      CallableForCallee = *(*(a2 + 72) + 24);
      v220 = (a2 - 16);
      OUTLINED_FUNCTION_3_10();
      while (1)
      {
        v73 = mlir::ValueRange::dereference_iterator(&p_CallableForCallee, v72);
        v81 = OUTLINED_FUNCTION_10_10(v73, v74, v75, v76, v77, v78, v79, v80, v184, v188, v193, v197, v202, v208, v209, v210, v211, v212, v213, v214, v215, v216, v217, v218, v219, v220, v221, p_CallableForCallee, v223, v224, v225);
        OUTLINED_FUNCTION_11_7(v81, v82, v83, v84, v85, v86, v87, v88, v186, v190, v195, v199, v204, v208, v209, v210, v211);
        OUTLINED_FUNCTION_2_11();
        if (!v5)
        {
          goto LABEL_112;
        }

        if (!*(v89 + 5))
        {
          break;
        }

        OUTLINED_FUNCTION_4_10();
        while (1)
        {
          OUTLINED_FUNCTION_7_8();
          if (v5)
          {
            break;
          }

          OUTLINED_FUNCTION_6_9();
          if (v5)
          {
            goto LABEL_120;
          }
        }

LABEL_113:
        OUTLINED_FUNCTION_0_9();
        if (!v91)
        {
          return 1;
        }
      }

LABEL_120:
      OUTLINED_FUNCTION_5_11();
      if (!v31)
      {
        OUTLINED_FUNCTION_1_13(v89, v90, v92);
        goto LABEL_113;
      }

LABEL_112:
      llvm::SmallPtrSetImplBase::insert_imp_big(v89, v90);
      goto LABEL_113;
    }

    v93 = *(a2 + 72);
    CallableForCallee = *(v93 + 56);
    v220 = *(v93 + 24);
    OUTLINED_FUNCTION_3_10();
    while (1)
    {
      v95 = mlir::ValueRange::dereference_iterator(&p_CallableForCallee, v94);
      v103 = OUTLINED_FUNCTION_10_10(v95, v96, v97, v98, v99, v100, v101, v102, v184, v188, v193, v197, v202, v208, v209, v210, v211, v212, v213, v214, v215, v216, v217, v218, v219, v220, v221, p_CallableForCallee, v223, v224, v225);
      OUTLINED_FUNCTION_11_7(v103, v104, v105, v106, v107, v108, v109, v110, v187, v191, v196, v200, v205, v208, v209, v210, v211);
      OUTLINED_FUNCTION_2_11();
      if (!v5)
      {
        goto LABEL_124;
      }

      if (!*(v111 + 5))
      {
        break;
      }

      OUTLINED_FUNCTION_4_10();
      while (1)
      {
        OUTLINED_FUNCTION_7_8();
        if (v5)
        {
          break;
        }

        OUTLINED_FUNCTION_6_9();
        if (v5)
        {
          goto LABEL_132;
        }
      }

LABEL_125:
      OUTLINED_FUNCTION_0_9();
      if (!v113)
      {
        return 1;
      }
    }

LABEL_132:
    OUTLINED_FUNCTION_5_11();
    if (!v31)
    {
      OUTLINED_FUNCTION_1_13(v111, v112, v114);
      goto LABEL_125;
    }

LABEL_124:
    llvm::SmallPtrSetImplBase::insert_imp_big(v111, v112);
    goto LABEL_125;
  }

  v7 = DefiningOp;
  while ((mlir::hasEffect<mlir::MemoryEffects::Allocate>(v7, v220) & 1) == 0 && *(*(v7 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::memref::ViewOp,void>::id)
  {
    if ((*(v7 + 46) & 0x80) == 0 || !*(v7 + 68))
    {
      return 1;
    }

    v220 = *(*(v7 + 72) + 24);
    v7 = mlir::Value::getDefiningOp(&v220);
    if (!v7)
    {
      goto LABEL_13;
    }
  }

  v63 = *a1;
  v218 = v220;
  mlir::ValueRange::ValueRange(&v227, &v218, 1uLL);
  v208 = a2 - 16;
  mlir::ValueRange::ValueRange(&CallableForCallee, &v208, 1uLL);
  v64 = v228;
  v65 = *v63;
  p_CallableForCallee = v227;
  v223 = 0;
  v224 = CallableForCallee;
  v225 = 0;
  if (v228)
  {
    v66 = 0;
    while (1)
    {
      v67 = mlir::ValueRange::dereference_iterator(&p_CallableForCallee, v66);
      v68 = mlir::ValueRange::dereference_iterator(&v224, v225);
      v210 = v67;
      v211 = v68;
      llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>>>,mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SmallPtrSet<mlir::Value,16u>>>::operator[](v65 + 200, &v210);
      OUTLINED_FUNCTION_2_11();
      if (!v5)
      {
        goto LABEL_99;
      }

      if (!*(v69 + 5))
      {
        break;
      }

      OUTLINED_FUNCTION_4_10();
      while (1)
      {
        OUTLINED_FUNCTION_7_8();
        if (v5)
        {
          break;
        }

        OUTLINED_FUNCTION_6_9();
        if (v5)
        {
          goto LABEL_107;
        }
      }

LABEL_100:
      OUTLINED_FUNCTION_9_7();
      if (v66 == v64)
      {
        return 1;
      }
    }

LABEL_107:
    OUTLINED_FUNCTION_5_11();
    if (!v31)
    {
      OUTLINED_FUNCTION_1_13(v69, v70, v71);
      goto LABEL_100;
    }

LABEL_99:
    llvm::SmallPtrSetImplBase::insert_imp_big(v69, v70);
    goto LABEL_100;
  }

  return 1;
}

void mlir::OpInterface<mlir::LoopLikeOpInterface,mlir::detail::LoopLikeOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::LoopLikeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::LoopLikeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::placement::TensorToMemref,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "placement.tensor_to_memref";
  *(a2 + 24) = 26;
}

void mlir::OpBuilder::create<mlir::mpsx::MemrefBackedOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.memref_backed";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::mpsx::UseMemrefOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.use_memref";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::placement::MemrefToTensor,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "placement.memref_to_tensor";
  *(a2 + 24) = 26;
}

void mlir::OpBuilder::create<mlir::mps_spi::StridedArrayViewOp,mlir::MemRefType &,mlir::Value &,long long &,llvm::SmallVector<long long,6u> &,llvm::SmallVector<long long,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps_spi.strided_array_view";
  *(a2 + 24) = 26;
}

void mlir::OperationName::hasInterface<mlir::FunctionOpInterface>()
{
  {
    v0 = llvm::getTypeName<mlir::FunctionOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1_14(v2);
  }
}

void mlir::mps::anonymous namespace::MemrefAllocLoopHoistingPass::runOnOperation()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParallelRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParallelRegion>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParallelRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParallelRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::mps::isRegionMemrefRegionPassCompatible()
{
  {
    v0 = llvm::getTypeName<mlir::mpsx::ListType>();
    mlir::detail::TypeIDResolver<mlir::mpsx::ListType,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::mps::registerMPSRuntimeDynamicEncodeOpExternalModels(mlir::DialectRegistry &)::$_0::operator()()
{
  {
    v0 = llvm::getTypeName<mlir::MPSRuntimeDynamicEncodeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_0_10(v2);
  }
}

uint64_t mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsScale(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(this, 9);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsZeroPoint(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(this, 10);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mps::anonymous namespace::LowerReductionMean::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v40[2] = *MEMORY[0x1E69E9840];
  v38 = a2;
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(&v38, 0);
  OUTLINED_FUNCTION_32_5();
  v37 = v6;
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(&v38, 1u);
  OUTLINED_FUNCTION_41_3();
  if (v7)
  {
    v9 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v9 = *(v8 + 24);
  }

  v36 = v9;
  InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes(&v38);
  v10 = *(a2 + 24);
  v11 = OUTLINED_FUNCTION_64_0();
  if (v9)
  {
    v13 = mlir::OpBuilder::create<mlir::mps::DimensionSizeOp,mlir::Value &,mlir::Value &>(v11, v10, v12, &v36);
  }

  else
  {
    v13 = mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>(v11, v10, v12);
  }

  v34 = v13 - 16;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(v37);
  if (mlir::Type::isF16(&ElementTypeOrSelf))
  {
    IntegerType = mlir::Float32Type::get(*(a4 + 8), v14);
LABEL_12:
    v40[0] = mlir::TypeAttr::get(IntegerType);
    v17 = OUTLINED_FUNCTION_64_0();
    v37 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr>(v17, v10, v18, v40) - 16;
    v19 = 1;
    goto LABEL_13;
  }

  if (mlir::Type::isInteger(&ElementTypeOrSelf, 8) || mlir::Type::isInteger(&ElementTypeOrSelf, 16))
  {
    isSignedInteger = mlir::Type::isSignedInteger(&ElementTypeOrSelf);
    IntegerType = mlir::Builder::getIntegerType((a4 + 8), 32, isSignedInteger);
    goto LABEL_12;
  }

  v19 = 0;
LABEL_13:
  v20 = OUTLINED_FUNCTION_64_0();
  v32 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::Value &,BOOL &>(v20, v10, v21, &v36, &InferredResultTypes);
  v31 = mlir::OpBuilder::create<mlir::mps::ReductionProdOp,mlir::Value &>((a4 + 8), v10, &v34);
  v22 = mlir::getElementTypeOrSelf(v32 - 16);
  v40[0] = mlir::TypeAttr::get(v22);
  v30 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::ReductionProdOp &,mlir::TypeAttr>((a4 + 8), v10, &v31, v40);
  v23 = mlir::OpBuilder::create<mlir::mps::DivideOp,mlir::mps::ReductionSumOp &,mlir::mps::CastOp &>((a4 + 8), v10, &v32, &v30) - 16;
  v29 = v23;
  if (v19)
  {
    v40[0] = mlir::TypeAttr::get(ElementTypeOrSelf);
    v23 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr>((a4 + 8), v10, &v29, v40) - 16;
    v29 = v23;
  }

  v39 = v23;
  mlir::ValueRange::ValueRange(v40, &v39, 1uLL);
  v24 = OUTLINED_FUNCTION_9_6();
  mlir::ConversionPatternRewriter::replaceOp(v24, v25, v26, v27);
  return 1;
}

uint64_t mlir::mps::anonymous namespace::LowerReductionVariance::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v24 = a2;
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(&v24, 0);
  OUTLINED_FUNCTION_32_5();
  v23[1] = v6;
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(&v24, 1u);
  OUTLINED_FUNCTION_41_3();
  if (v7)
  {
    v9 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v9 = *(v8 + 24);
  }

  v23[0] = v9;
  InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes(&v24);
  v10 = *(a2 + 24);
  LOBYTE(v20) = 1;
  v11 = OUTLINED_FUNCTION_121_0();
  v21 = mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::Value &,BOOL>(v11, v10, v12, v23, &v20);
  v13 = OUTLINED_FUNCTION_121_0();
  v20 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::mps::ReductionMeanOp &>(v13, v10, v14, &v21);
  v19 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::mps::SubtractOp &>((a4 + 8), v10, &v20);
  mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::mps::SquareOp &,mlir::Value &,BOOL &>((a4 + 8), v10, &v19, v23, &InferredResultTypes);
  v15 = OUTLINED_FUNCTION_9_6();
  mlir::ConversionPatternRewriter::replaceOp(v15, v16, v17);
  return 1;
}

uint64_t mlir::mps::anonymous namespace::LowerQuantizedMatmul::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t **a4)
{
  v83 = a2;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v83, 1);
  OUTLINED_FUNCTION_118_1();
  OUTLINED_FUNCTION_41_3();
  if (v5)
  {
    v7 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v7 = *(v6 + 24);
  }

  v82 = v7;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v83, 2);
  OUTLINED_FUNCTION_118_1();
  OUTLINED_FUNCTION_41_3();
  if (v5)
  {
    v9 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v9 = *(v8 + 24);
  }

  v81 = v9;
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v83, 3);
  if ((*(v83 + 46) & 0x80) != 0)
  {
    v11 = *(v83 + 9);
  }

  else
  {
    v11 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    v12 = 0;
  }

  else
  {
    v12 = *(v11 + 32 * ODSOperandIndexAndLength + 24);
  }

  v80 = v12;
  AttrDictionary = mlir::Operation::getAttrDictionary(v83);
  v14 = OUTLINED_FUNCTION_131_0(AttrDictionary);
  v15 = mlir::Operation::getAttrDictionary(v83);
  OUTLINED_FUNCTION_131_0(v15);
  OUTLINED_FUNCTION_102_1();
  if (mlir::impl::getAttrFromSortedRange<mlir::NamedAttribute const*,mlir::StringAttr>(v14, v17, *v16))
  {
    OUTLINED_FUNCTION_100_0();
    if (v5)
    {
      v19 = v18;
    }

    else
    {
      v19 = 0;
    }
  }

  else
  {
    v19 = 0;
  }

  v79 = v19;
  if (mlir::mpsx::QuantizedMatMulOp::isInputAffneQuantized(&v83))
  {
    v20 = mlir::Operation::getAttrDictionary(v83);
    v21 = OUTLINED_FUNCTION_131_0(v20);
    v22 = mlir::Operation::getAttrDictionary(v83);
    OUTLINED_FUNCTION_131_0(v22);
    OUTLINED_FUNCTION_102_1();
    if (mlir::impl::getAttrFromSortedRange<mlir::NamedAttribute const*,mlir::StringAttr>(v21, v24, *v23))
    {
      OUTLINED_FUNCTION_100_0();
      if (v5)
      {
        mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v83, 0);
        OUTLINED_FUNCTION_32_5();
        v26 = (*(v25 + 8) & 0xFFFFFFFFFFFFFFF8);
        v27 = v26 ? mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v26 + 8) : 0;
        v77 = v26;
        v78 = v27;
        if (mlir::CallOpInterface::getArgOperands(&v77))
        {
          mlir::CallableOpInterface::getArgAttrsAttr(&v77);
          v29 = v28;
          mlir::IntegerAttr::getValue(&v79, &__p);
          if (v76 > 0x40)
          {
            v31 = *__p;
            operator delete[](__p);
          }

          else
          {
            OUTLINED_FUNCTION_133_0();
            if (v5)
            {
              v31 = 0;
            }

            else
            {
              v31 = v30;
            }
          }

          v79 = 0;
        }
      }
    }
  }

  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v83, 5);
  OUTLINED_FUNCTION_118_1();
  OUTLINED_FUNCTION_41_3();
  if (v5)
  {
    v33 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v33 = *(v32 + 24);
  }

  v74 = v33;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v83, 6);
  OUTLINED_FUNCTION_118_1();
  OUTLINED_FUNCTION_41_3();
  if (v5)
  {
    v35 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v35 = *(v34 + 24);
  }

  v73 = v35;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v83, 7);
  OUTLINED_FUNCTION_118_1();
  OUTLINED_FUNCTION_41_3();
  if (v5)
  {
    v37 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v37 = *(v36 + 24);
  }

  v72 = v37;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v83, 9);
  OUTLINED_FUNCTION_118_1();
  OUTLINED_FUNCTION_41_3();
  if (v5)
  {
    v39 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v39 = *(v38 + 24);
  }

  v71 = v39;
  v40 = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v83, 10);
  if ((*(v83 + 46) & 0x80) != 0)
  {
    v41 = *(v83 + 9);
  }

  else
  {
    v41 = 0;
  }

  if (HIDWORD(v40) + v40 == v40)
  {
    v42 = 0;
  }

  else
  {
    v42 = *(v41 + 32 * v40 + 24);
  }

  v70 = v42;
  v43 = mlir::Operation::getAttrDictionary(v83);
  v44 = OUTLINED_FUNCTION_131_0(v43);
  v45 = mlir::Operation::getAttrDictionary(v83);
  OUTLINED_FUNCTION_131_0(v45);
  OUTLINED_FUNCTION_102_1();
  if (mlir::impl::getAttrFromSortedRange<mlir::NamedAttribute const*,mlir::StringAttr>((v44 + 32), v47, *(v46 + 40)))
  {
    OUTLINED_FUNCTION_100_0();
    if (v5)
    {
      v49 = v48;
    }

    else
    {
      v49 = 0;
    }
  }

  else
  {
    v49 = 0;
  }

  v69 = v49;
  if (mlir::mpsx::QuantizedMatMulOp::isWeightsAffineQuantized(&v83) || mlir::mpsx::QuantizedMatMulOp::isWeightsDoubleAffineQuantized(&v83))
  {
    v50 = mlir::Operation::getAttrDictionary(v83);
    v51 = OUTLINED_FUNCTION_131_0(v50);
    v52 = mlir::Operation::getAttrDictionary(v83);
    OUTLINED_FUNCTION_131_0(v52);
    OUTLINED_FUNCTION_102_1();
    if (mlir::impl::getAttrFromSortedRange<mlir::NamedAttribute const*,mlir::StringAttr>((v51 + 32), v54, *(v53 + 40)))
    {
      OUTLINED_FUNCTION_100_0();
      if (v5)
      {
        mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v83, 4);
        OUTLINED_FUNCTION_32_5();
        v56 = (*(v55 + 8) & 0xFFFFFFFFFFFFFFF8);
        v57 = v56 ? mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v56 + 8) : 0;
        v77 = v56;
        v78 = v57;
        if (mlir::CallOpInterface::getArgOperands(&v77))
        {
          mlir::CallableOpInterface::getArgAttrsAttr(&v77);
          mlir::IntegerAttr::getValue(&v69, &__p);
          if (v76 > 0x40)
          {
            operator delete[](__p);
          }

          else
          {
            OUTLINED_FUNCTION_133_0();
          }

          v69 = 0;
          v74 = OUTLINED_FUNCTION_150_0(a4, v33);
          v73 = OUTLINED_FUNCTION_150_0(a4, v35);
          v72 = OUTLINED_FUNCTION_150_0(a4, v37);
          if (mlir::mpsx::QuantizedMatMulOp::isWeightsDoubleAffineQuantized(&v83))
          {
            v71 = OUTLINED_FUNCTION_150_0(a4, v39);
            v70 = OUTLINED_FUNCTION_150_0(a4, v42);
          }
        }
      }
    }
  }

  v58 = v83;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v83, 0);
  OUTLINED_FUNCTION_32_5();
  v77 = v59;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v83, 4);
  OUTLINED_FUNCTION_32_5();
  __p = v60;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v83, 8);
  OUTLINED_FUNCTION_118_1();
  OUTLINED_FUNCTION_41_3();
  if (v5)
  {
    v62 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v62 = *(v61 + 24);
  }

  v68 = v62;
  FunctionType = mlir::mpsx::ANEOp::getFunctionType(&v83);
  TransposeLhs = mlir::mpsx::QuantizedMatMulOp::getTransposeLhs(&v83);
  TransposeRhs = mlir::mpsx::QuantizedMatMulOp::getTransposeRhs(&v83);
  v63 = mlir::OpBuilder::create<mlir::mpsx::QuantizedMatMulOp,mlir::detail::TypedValue<mlir::TensorType>,mlir::Value &,mlir::Value &,mlir::Value &,mlir::IntegerAttr &,mlir::detail::TypedValue<mlir::TensorType>,mlir::Value &,mlir::Value &,mlir::Value &,mlir::IntegerAttr &,mlir::Value,mlir::Value &,mlir::Value &,mlir::Type,BOOL,BOOL>(a4 + 1, *(v58 + 3), &v77, &v82, &v81, &v80, &v79, &__p, &v74, &v73, &v72, &v69, &v68, &v71, &v70, &FunctionType, &TransposeLhs, &TransposeRhs);
  ((*a4)[1])(a4, v58, v63);
  return 1;
}

void mlir::mps::anonymous namespace::MPS_LowerBiasAddNHWC::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerBiasAddNHWC *this, mlir::Operation *a2, mlir::PatternRewriter *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, void *a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t *a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, uint64_t a54, uint64_t a55, uint64_t a56, uint64_t a57, uint64_t a58)
{
  OUTLINED_FUNCTION_119();
  a57 = v60;
  a58 = v61;
  OUTLINED_FUNCTION_75_1();
  a44 = *MEMORY[0x1E69E9840];
  v63 = *(v62 + 44);
  a38 = &a40;
  a40 = v62;
  a39 = 0x400000001;
  if (!HIBYTE(v63) || (v67.var0 = "data_format", v67.var1 = 11, InherentAttr = mlir::Operation::getInherentAttr(v58, v67), (v65 & 1) == 0))
  {
    v68.var0 = "data_format";
    v68.var1 = 11;
    InherentAttr = mlir::DictionaryAttr::get((v58 + 7), v68);
  }

  if (!InherentAttr || *(*InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    InherentAttr = mlir::mps::TensorDataLayoutAttr::get(*(v59 + 8), 1u);
  }

  a9 = InherentAttr;
  if (mlir::arith::FastMathFlagsAttr::getValue(&a9) == 1)
  {
    a16 = *(*a38 + 24);
    OUTLINED_FUNCTION_115_0((v59 + 8), &a16);
  }

  v66 = *(v59 + 16);
  if (v66 && mlir::RewriterBase::Listener::classof(v66))
  {
  }

  if (a38 != &a40)
  {
    free(a38);
  }

  OUTLINED_FUNCTION_120();
}

void mlir::mps::anonymous namespace::MPS_LowerFloorDiv::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerFloorDiv *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  OUTLINED_FUNCTION_75_1();
  v7[4] = *MEMORY[0x1E69E9840];
  v6[22] = v7;
  v7[0] = v5;
  v6[23] = 0x400000001;
  v6[0] = *(v3 + 24);
  OUTLINED_FUNCTION_115_0((v4 + 8), v6);
}

void mlir::mps::anonymous namespace::MPS_LowerInstanceNorm::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerInstanceNorm *this, mlir::Operation *a2, mlir::Float32Type **a3)
{
  OUTLINED_FUNCTION_20_7(*MEMORY[0x1E69E9840]);
  OUTLINED_FUNCTION_77_1(v5, v6);
  OUTLINED_FUNCTION_34_4();
  if (!*(a2 + 47) || (v11.var0 = "epsilon", v11.var1 = 7, InherentAttr = mlir::Operation::getInherentAttr(a2, v11), (v8 & 1) == 0))
  {
    v12.var0 = "epsilon";
    v12.var1 = 7;
    InherentAttr = mlir::DictionaryAttr::get((a2 + 56), v12);
  }

  if (!InherentAttr || *(*InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    F32Type = mlir::Builder::getF32Type(a3 + 1, v8);
    mlir::Builder::getFloatAttr(0.0, (a3 + 1), F32Type);
  }

  v10[0] = *(*v10[22] + 24);
  OUTLINED_FUNCTION_115_0(a3 + 1, v10);
}

uint64_t mlir::mps::anonymous namespace::MPS_LowerNormalization::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerNormalization *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  OUTLINED_FUNCTION_75_1();
  v31[4] = *MEMORY[0x1E69E9840];
  v6 = *(v5 + 44);
  v29 = v31;
  v31[0] = v5;
  v30 = 0x400000001;
  if (!HIBYTE(v6) || (v32.var0 = "epsilon", v32.var1 = 7, InherentAttr = mlir::Operation::getInherentAttr(v3, v32), (v8 & 1) == 0))
  {
    v33.var0 = "epsilon";
    v33.var1 = 7;
    InherentAttr = mlir::DictionaryAttr::get((v3 + 7), v33);
  }

  if (InherentAttr && *(*InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    OUTLINED_FUNCTION_113_1(InherentAttr, v8, v9, v10, v11, v12, v13, v14, v17, v18, v19, v20, v21, 0, v22, v23, v24, v25, v26, v27, v28);
  }

  v15 = *(v4 + 16);
  if (v15 && mlir::RewriterBase::Listener::classof(v15))
  {
  }

  if (v29 != v31)
  {
    free(v29);
  }

  return 0;
}

void mlir::mps::anonymous namespace::MPS_LowerReductionLogSumExp::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerReductionLogSumExp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  OUTLINED_FUNCTION_75_1();
  OUTLINED_FUNCTION_20_7(*MEMORY[0x1E69E9840]);
  v18 = v4;
  OUTLINED_FUNCTION_77_1(v5, v4);
  OUTLINED_FUNCTION_38_2(COERCE_DOUBLE(0x400000001));
  if (v7 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionLogSumExpOp,void>::id)
  {
    v8 = v6;
  }

  else
  {
    v8 = 0;
  }

  v20[0] = v8;
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v20, 0);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v20, 1u);
  if (!v3[47] || (v21.var0 = "keep_dims", v21.var1 = 9, InherentAttr = mlir::Operation::getInherentAttr(v3, v21), (v10 & 1) == 0))
  {
    v22.var0 = "keep_dims";
    v22.var1 = 9;
    InherentAttr = mlir::DictionaryAttr::get((v3 + 56), v22);
  }

  if (!InherentAttr || *(*InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    InherentAttr = 0;
  }

  OUTLINED_FUNCTION_113_1(InherentAttr, v10, v11, v12, v13, v14, v15, v16, v3, v17, v18, v19, v20[0], v20[1], v20[2], v20[3], v20[4], v20[5], v20[6], v20[7], v20[8]);
}

void mlir::OpBuilder::create<mlir::mps::RankOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.rank";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::mps::RankOp &,mlir::mps::ConstantOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.get_coordinates";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp &,int,int,int>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.crop";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::mps::GetCoordOp &,int,int,int>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.slice";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::mps::ConcatOp &,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reduction_sum";
  *(a2 + 24) = 17;
}

void mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::mps::CastOp &,mlir::mps::CropOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.expand_dims";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::mps::DimensionSizeOp,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.dimension_size";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::mps::ReductionProdOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reduction_prod";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::Value &,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reduction_mean";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::mps::ExponentOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.exponent";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::mps::LogarithmOp,mlir::mps::AddOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.logarithm";
  *(a2 + 24) = 13;
}

void mlir::OpBuilder::create<mlir::mps::GreaterThanOp,mlir::Value &,mlir::mps::ConstantOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.greater";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::mps::GreaterThanOp &,mlir::Value &,mlir::mps::LogarithmOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.select";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::mps::LessThanOp,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.less";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::mps::SoftplusOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.softplus";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::mps::NotEqualToOp,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.not_equal";
  *(a2 + 24) = 13;
}

void mlir::OpBuilder::create<mlir::mps::CumulativeSumOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.cumulative_sum";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::mps::ScatterOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::mps::ScatterMode>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.scatter";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.negative";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::tensor::FromElementsOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.from_elements";
  *(a2 + 24) = 20;
}

void mlir::OpBuilder::create<mlir::mps::SpaceToBatchOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.space_to_batch";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::mps::BatchToSpaceOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.batch_to_space";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::mpsx::QuantizedMatMulOp,mlir::detail::TypedValue<mlir::TensorType>,mlir::Value &,mlir::Value &,mlir::Value &,mlir::IntegerAttr &,mlir::detail::TypedValue<mlir::TensorType>,mlir::Value &,mlir::Value &,mlir::Value &,mlir::IntegerAttr &,mlir::Value,mlir::Value &,mlir::Value &,mlir::Type,BOOL,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.quantized_matmul";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::mps::PowerOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.power";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::mps::EqualToOp,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.equal";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::mps::GreaterThanOrEqualToOp,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.greater_equal";
  *(a2 + 24) = 17;
}

void mlir::OpBuilder::create<mlir::mps::FloorOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.floor";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::mps::ErfOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.erf";
  *(a2 + 24) = 7;
}

void mlir::OpBuilder::create<mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::Value &,mlir::UnitAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reduction_variance";
  *(a2 + 24) = 22;
}

void mlir::OpBuilder::create<mlir::mps::NormalizationOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.normalization";
  *(a2 + 24) = 17;
}

void mlir::OpBuilder::create<mlir::mps::AbsoluteOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.absolute";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::mps::MinimumOp,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.minimum";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::mps::RoundOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.round";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::mps::ClampOp,mlir::Value &,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.clamp";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::mpsx::FPToIntClampedOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.fp_to_int_clamped";
  *(a2 + 24) = 22;
}

void mlir::OpBuilder::create<mlir::mps::ReductionMaxOp,mlir::Value &,mlir::Value &,mlir::UnitAttr,mlir::UnitAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reduction_max";
  *(a2 + 24) = 17;
}

void mlir::OpBuilder::create<mlir::mps::MaximumOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.maximum";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::mps::SigmoidOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.sigmoid";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::mps::CeilOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.ceil";
  *(a2 + 24) = 8;
}

void llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::mps::anonymous namespace::RefineDynamicShapes::runOnOperation(void)::$_0>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::mps::anonymous namespace::hasDynamicShapes()
{
  {
    v0 = llvm::getTypeName<mlir::mpsx::ListType>();
    mlir::detail::TypeIDResolver<mlir::mpsx::ListType,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::MapDynamicShapeOpInterface,mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::MapDynamicShapeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::MapDynamicShapeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::MapDynamicShapeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::MapDynamicShapeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::mps::anonymous namespace::GPURegionOpCreator::isOpCompatible(void **a1, mlir::InFlightDiagnostic *a2, uint64_t a3)
{
  OUTLINED_FUNCTION_1_16(a1, a1, a3, "Could not follow op placement hint");
  mlir::InFlightDiagnostic::~InFlightDiagnostic(a2);
  __break(1u);
}

void mlir::OpBuilder::create<mlir::mpsx::GPUOp,std::string &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.gpu";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::mpsx::RegionReturnOp,llvm::ArrayRef<mlir::Value> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.region_return";
  *(a2 + 24) = 18;
}

void mlir::OpInterface<mlir::FormableRegionOpInterface,mlir::detail::FormableRegionOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::FormableRegionOpInterface>();
    mlir::detail::TypeIDResolver<mlir::FormableRegionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::FormableRegionOpInterface>();
    mlir::detail::TypeIDResolver<mlir::FormableRegionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::placement::RegionCall,mlir::Operation *&,mlir::placement::RegionType,mlir::ValueRange &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "placement.region_call";
  *(a2 + 24) = 21;
}

uint64_t mlir::mps::anonymous namespace::ReorderThroughOperandsBase::canPropagateThroughInput(mlir::mps::_anonymous_namespace_::ReorderThroughOperandsBase *this, mlir::Operation *a2)
{
  v18 = *(*(a2 + 9) + 24);
  result = mlir::Value::getDefiningOp(&v18);
  if (result)
  {
    v4 = result;
    if ((*(**(this + 1) + 24))(*(this + 1), result))
    {
      return 0;
    }

    result = (*(**(this + 1) + 64))(*(this + 1), v4);
    if (result)
    {
      if (*(v4 + 36) != 1)
      {
        return 0;
      }

      v5 = (*(v4 - 8) & 0xFFFFFFFFFFFFFFF8);
      v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
      if (v6)
      {
        v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
      }

      else
      {
        v5 = 0;
      }

      v18 = v5;
      v19 = v6;
      if (!v5 || !mlir::CallOpInterface::getArgOperands(&v18))
      {
        return 0;
      }

      ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v18);
      if (v8)
      {
        v9 = 8 * v8;
        while (*ArgAttrsAttr != 0x8000000000000000)
        {
          ++ArgAttrsAttr;
          v9 -= 8;
          if (!v9)
          {
            goto LABEL_15;
          }
        }

        return 0;
      }

LABEL_15:
      if ((*(v4 + 46) & 0x80) != 0)
      {
        v10 = *(v4 + 68);
        if (v10)
        {
          v11 = 0;
          v12 = *(v4 + 72);
          while (1)
          {
            v13 = (*(*(v12 + 32 * v11 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
            v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
            if (v14)
            {
              v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
            }

            else
            {
              v13 = 0;
            }

            v18 = v13;
            v19 = v14;
            if (!v13 || !mlir::CallOpInterface::getArgOperands(&v18))
            {
              return 0;
            }

            v15 = mlir::CallableOpInterface::getArgAttrsAttr(&v18);
            if (v16)
            {
              v17 = 8 * v16;
              while (*v15 != 0x8000000000000000)
              {
                ++v15;
                v17 -= 8;
                if (!v17)
                {
                  goto LABEL_27;
                }
              }

              return 0;
            }

LABEL_27:
            ++v11;
            result = 1;
            if (v11 == v10)
            {
              return result;
            }
          }
        }
      }

      return 1;
    }
  }

  return result;
}

void mlir::mps::anonymous namespace::PermuteOpReorderDetails::isInputCompatible()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::mps::StridedSliceOp,mlir::mps::PermuteOp &,mlir::mps::ConstantOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp,unsigned int,unsigned int,unsigned int,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.strided_slice";
  *(a2 + 24) = 17;
}

void mlir::OpBuilder::create<mlir::mps::PadOp,mlir::mps::PermuteOp &,mlir::mps::ConstantOp &,mlir::Value,mlir::mps::PaddingMode>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.pad";
  *(a2 + 24) = 7;
}

uint64_t mlir::mps::Conv2DDataGradientOp::getOutputShape(mlir::mps::Conv2DDataGradientOp *this)
{
  ODSOperandIndexAndLength = mlir::mps::Conv2DDataGradientOp::getODSOperandIndexAndLength(this, 2u);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 72);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mps::anonymous namespace::CanonicalizeQuantizedMatmulTranpose::matchAndRewriteImpl(uint64_t a1, mlir::Operation *a2, uint64_t **a3)
{
  v67 = a2;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v67, 0);
  OUTLINED_FUNCTION_88_0();
  v5 = *(v4 + 24);
  v66 = v5;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v67, 1);
  OUTLINED_FUNCTION_25_7();
  OUTLINED_FUNCTION_41_3();
  if (v6)
  {
    v8 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v8 = *(v7 + 24);
  }

  v65 = v8;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v67, 2);
  OUTLINED_FUNCTION_25_7();
  OUTLINED_FUNCTION_41_3();
  if (v6)
  {
    v10 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v10 = *(v9 + 24);
  }

  v64 = v10;
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v67, 3);
  if ((*(v67 + 46) & 0x80) != 0)
  {
    v12 = *(v67 + 9);
  }

  else
  {
    v12 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    v13 = 0;
  }

  else
  {
    v13 = *(v12 + 32 * ODSOperandIndexAndLength + 24);
  }

  v63 = v13;
  AttrDictionary = mlir::Operation::getAttrDictionary(v67);
  v15 = OUTLINED_FUNCTION_39_2(AttrDictionary);
  v16 = mlir::Operation::getAttrDictionary(v67);
  v17 = OUTLINED_FUNCTION_39_2(v16);
  if (mlir::impl::getAttrFromSortedRange<mlir::NamedAttribute const*,mlir::StringAttr>(v15, (v17 + 16 * v18 - 32), **(*(v67 + 6) + 96)))
  {
    OUTLINED_FUNCTION_24_6();
    if (v20 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v21 = v19;
    }

    else
    {
      v21 = 0;
    }
  }

  else
  {
    v21 = 0;
  }

  v62 = v21;
  v23 = TransposedInput;
  if (TransposedInput)
  {
    v66 = TransposedInput;
  }

  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v67, 4);
  OUTLINED_FUNCTION_88_0();
  v25 = *(v24 + 24);
  v61 = v25;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v67, 5);
  OUTLINED_FUNCTION_25_7();
  OUTLINED_FUNCTION_41_3();
  if (v6)
  {
    v27 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v27 = *(v26 + 24);
  }

  v60 = v27;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v67, 6);
  OUTLINED_FUNCTION_25_7();
  OUTLINED_FUNCTION_41_3();
  if (v6)
  {
    v29 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v29 = *(v28 + 24);
  }

  v59 = v29;
  v30 = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v67, 7);
  if ((*(v67 + 46) & 0x80) != 0)
  {
    v31 = *(v67 + 9);
  }

  else
  {
    v31 = 0;
  }

  if (HIDWORD(v30) + v30 == v30)
  {
    v32 = 0;
  }

  else
  {
    v32 = *(v31 + 32 * v30 + 24);
  }

  v58 = v32;
  v33 = mlir::Operation::getAttrDictionary(v67);
  v34 = OUTLINED_FUNCTION_39_2(v33);
  v35 = mlir::Operation::getAttrDictionary(v67);
  v36 = OUTLINED_FUNCTION_39_2(v35);
  if (mlir::impl::getAttrFromSortedRange<mlir::NamedAttribute const*,mlir::StringAttr>((v34 + 32), (v36 + 16 * v37), *(*(*(v67 + 6) + 96) + 40)))
  {
    OUTLINED_FUNCTION_24_6();
    if (v39 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v40 = v38;
    }

    else
    {
      v40 = 0;
    }
  }

  else
  {
    v40 = 0;
  }

  v68 = v40;
  v42 = v41;
  if (v41)
  {
    v61 = v41;
  }

  else if (!v23)
  {
    return 0;
  }

  v43 = v67;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v67, 8);
  OUTLINED_FUNCTION_25_7();
  OUTLINED_FUNCTION_41_3();
  if (v6)
  {
    v45 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v45 = *(v44 + 24);
  }

  v57 = v45;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v67, 9);
  OUTLINED_FUNCTION_25_7();
  OUTLINED_FUNCTION_41_3();
  if (v6)
  {
    v47 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v47 = *(v46 + 24);
  }

  v56 = v47;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v67, 10);
  OUTLINED_FUNCTION_25_7();
  OUTLINED_FUNCTION_41_3();
  if (v6)
  {
    v49 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_88_0();
    v49 = *(v48 + 24);
  }

  v55 = v49;
  FunctionType = mlir::mpsx::ANEOp::getFunctionType(&v67);
  v53 = mlir::mpsx::QuantizedMatMulOp::getTransposeLhs(&v67) ^ (v23 != 0);
  v52 = mlir::mpsx::QuantizedMatMulOp::getTransposeRhs(&v67) ^ (v42 != 0);
  v50 = mlir::OpBuilder::create<mlir::mpsx::QuantizedMatMulOp,mlir::detail::TypedValue<mlir::TensorType>,mlir::Value &,mlir::Value &,mlir::Value &,mlir::IntegerAttr &,mlir::detail::TypedValue<mlir::TensorType>,mlir::Value &,mlir::Value &,mlir::Value &,mlir::IntegerAttr &,mlir::Value,mlir::Value &,mlir::Value &,mlir::Type,BOOL,BOOL>(a3 + 1, *(v43 + 3), &v66, &v65, &v64, &v63, &v62, &v61, &v60, &v59, &v58, &v68, &v57, &v56, &v55, &FunctionType, &v53, &v52);
  ((*a3)[1])(a3, v43, v50);
  return 1;
}

uint64_t mlir::mpsx::QuantizedMatMulOp::getInputScale(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(this, 1);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mpsx::QuantizedMatMulOp::getInputZeroPoint(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(this, 2);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mpsx::QuantizedMatMulOp::getInputMin(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(this, 3);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mpsx::QuantizedMatMulOp::getWeightsScale(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(this, 5);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mpsx::QuantizedMatMulOp::getWeightsZeroPoint(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(this, 6);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mpsx::QuantizedMatMulOp::getWeightsMin(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(this, 7);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mpsx::QuantizedMatMulOp::getWeightsPaletteLut(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(this, 8);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReciprocalSquareRootOp,mlir::detail::any_value_binder>>::match(uint64_t ***a1, uint64_t a2)
{
  v4 = *(*(a2 + 48) + 16);
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
  {
    if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalSquareRootOp,void>::id && (*(a2 + 46) & 0x80) != 0 && *(a2 + 68) == 1)
    {
      v5 = *a1;
      v6 = **a1;
      v7 = *(*(a2 + 72) + 24);
      if (!*v6)
      {
        *v6 = v7;
LABEL_19:
        v5[1] = a2;
        return 1;
      }

      if (*v6 == v7)
      {
        goto LABEL_19;
      }
    }

    return 0;
  }

  if ((*(a2 + 46) & 0x80) != 0 && *(a2 + 68) == 1)
  {
    v8 = *a1;
    v12 = *(*(a2 + 72) + 24);
    result = mlir::Value::getDefiningOp(&v12);
    if (!result)
    {
      return result;
    }

    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalSquareRootOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 1)
    {
      v10 = *(*(result + 72) + 24);
      v11 = **v8;
      if (v11)
      {
        if (v11 != v10)
        {
          return 0;
        }
      }

      else
      {
        **v8 = v10;
      }

      v8[1] = result;
      if ((a1[2] & 1) == 0)
      {
        *(a1 + 16) = 1;
      }

      a1[1] = a2;
      return 1;
    }
  }

  return 0;
}

uint64_t mlir::detail::enumerate<mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder>> *,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder>>,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder>> *,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::any_value_binder> * *)#1}>(uint64_t a1, uint64_t a2)
{
  v4 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder>>>(**(a2 + 8), 0, *a1);
  v5 = *(a2 + 8);
  **a2 &= v4;
  v6 = *(a1 + 8);
  v15 = *(*(*v5 + 72) + 56);
  result = mlir::Value::getDefiningOp(&v15);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
    {
      v8 = *(result + 36);
      if (!v8)
      {
        goto LABEL_23;
      }

      v9 = result - 16;
      v10 = **v6;
      if (v10)
      {
        v11 = v10 == v9;
        goto LABEL_8;
      }

      **v6 = v9;
LABEL_22:
      LOBYTE(v8) = 1;
      goto LABEL_23;
    }

    if ((*(result + 46) & 0x80) != 0 && *(result + 68) == 1)
    {
      v13 = *(*(result + 72) + 24);
      v14 = **v6;
      if (v14)
      {
        if (v14 != v13)
        {
          goto LABEL_15;
        }
      }

      else
      {
        **v6 = v13;
      }

      if ((v6[2] & 1) == 0)
      {
        *(v6 + 16) = 1;
      }

      v6[1] = result;
      goto LABEL_22;
    }

LABEL_15:
    LOBYTE(v8) = 0;
    goto LABEL_23;
  }

  v12 = **v6;
  if (!v12)
  {
    **v6 = v15;
    goto LABEL_22;
  }

  v11 = v12 == v15;
LABEL_8:
  LOBYTE(v8) = v11;
LABEL_23:
  **a2 &= v8;
  return result;
}

uint64_t mlir::detail::enumerate<mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder>> *,mlir::detail::RecursivePatternMatcherBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder>>,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder>> * *)#2}>(uint64_t a1, uint64_t a2)
{
  v4 = *a1;
  v15 = *(*(**(a2 + 8) + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v15);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
    {
      v6 = *(DefiningOp + 36);
      if (!v6)
      {
        goto LABEL_23;
      }

      v7 = DefiningOp - 16;
      v8 = **v4;
      if (v8)
      {
        v9 = v8 == v7;
        goto LABEL_8;
      }

      **v4 = v7;
LABEL_22:
      LOBYTE(v6) = 1;
      goto LABEL_23;
    }

    if ((*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 1)
    {
      v11 = *(*(DefiningOp + 72) + 24);
      v12 = **v4;
      if (v12)
      {
        if (v12 != v11)
        {
          goto LABEL_15;
        }
      }

      else
      {
        **v4 = v11;
      }

      if ((v4[2] & 1) == 0)
      {
        *(v4 + 16) = 1;
      }

      v4[1] = DefiningOp;
      goto LABEL_22;
    }

LABEL_15:
    LOBYTE(v6) = 0;
    goto LABEL_23;
  }

  v10 = **v4;
  if (!v10)
  {
    **v4 = v15;
    goto LABEL_22;
  }

  v9 = v10 == v15;
LABEL_8:
  LOBYTE(v6) = v9;
LABEL_23:
  v13 = *(a2 + 8);
  **a2 &= v6;
  result = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder>>>(*v13, 1u, *(a1 + 8));
  **a2 &= result;
  return result;
}

uint64_t mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder>>::match(uint64_t a1, uint64_t a2)
{
  v10 = a2;
  v3 = *(*(a2 + 48) + 16);
  if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
  {
    v4 = *a1;
    v14 = a2;
    if (v3 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id && (*(a2 + 46) & 0x80) != 0 && *(a2 + 68) == 2)
    {
      v13 = 1;
      v11 = &v13;
      v12 = &v14;
      mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,mlir::mps::ReductionMeanOp *)#1}::operator()<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>>(&v11, 0, *v4);
      v5 = *(v4 + 8);
      v6 = *(*(*v12 + 72) + 56);
      if (*v5)
      {
        v7 = *v5 == v6;
      }

      else
      {
        *v5 = v6;
        v7 = 1;
      }

      *v11 &= v7;
      result = v13;
      if (v13 == 1)
      {
        *(v4 + 16) = v14;
      }

      return result;
    }

    return 0;
  }

  if ((*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 1)
  {
    return 0;
  }

  LOBYTE(v14) = 1;
  v11 = &v14;
  v12 = &v10;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder> *> & *)#1},0ul>(a1, &v11);
  result = v14;
  if (v14 == 1)
  {
    v9 = v10;
    if ((*(a1 + 16) & 1) == 0)
    {
      *(a1 + 16) = 1;
    }

    *(a1 + 8) = v9;
  }

  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,mlir::mps::ReductionMeanOp *)#1}::operator()<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareOp,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::value_binder>>>(uint64_t a1, unsigned int a2, uint64_t *a3)
{
  v10 = *(*(**(a1 + 8) + 72) + 32 * a2 + 24);
  result = mlir::Value::getDefiningOp(&v10);
  v7 = result;
  if (result)
  {
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SquareOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 1)
    {
      v8 = *a3;
      v10 = *(*(result + 72) + 24);
      result = mlir::Value::getDefiningOp(&v10);
      if (result)
      {
        if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
        {
          if ((*(result + 46) & 0x80) != 0 && *(result + 68) == 1 && **v8 == *(*(result + 72) + 24))
          {
            if ((*(v8 + 16) & 1) == 0)
            {
              *(v8 + 16) = 1;
            }

            *(v8 + 8) = result;
            goto LABEL_23;
          }
        }

        else if (*(result + 36) && **v8 == result - 16)
        {
          goto LABEL_23;
        }
      }

      else if (**v8 == v10)
      {
LABEL_23:
        a3[1] = v7;
        v6 = 1;
        goto LABEL_17;
      }
    }

    v6 = 0;
  }

LABEL_17:
  v9 = v6 & **a1;
  if (!v7)
  {
    v9 = 0;
  }

  **a1 = v9;
  return result;
}

uint64_t mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::CastOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SquareRootOp,mlir::detail::any_value_binder>>::match(uint64_t ***a1, uint64_t a2)
{
  v4 = *(*(a2 + 48) + 16);
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
  {
    if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id && (*(a2 + 46) & 0x80) != 0 && *(a2 + 68) == 1)
    {
      v5 = *a1;
      v6 = **a1;
      v7 = *(*(a2 + 72) + 24);
      if (!*v6)
      {
        *v6 = v7;
LABEL_19:
        v5[1] = a2;
        return 1;
      }

      if (*v6 == v7)
      {
        goto LABEL_19;
      }
    }

    return 0;
  }

  if ((*(a2 + 46) & 0x80) != 0 && *(a2 + 68) == 1)
  {
    v8 = *a1;
    v12 = *(*(a2 + 72) + 24);
    result = mlir::Value::getDefiningOp(&v12);
    if (!result)
    {
      return result;
    }

    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 1)
    {
      v10 = *(*(result + 72) + 24);
      v11 = **v8;
      if (v11)
      {
        if (v11 != v10)
        {
          return 0;
        }
      }

      else
      {
        **v8 = v10;
      }

      v8[1] = result;
      if ((a1[2] & 1) == 0)
      {
        *(a1 + 16) = 1;
      }

      a1[1] = a2;
      return 1;
    }
  }

  return 0;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ConcatOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  v14 = *(*(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v14);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **a3) == 0) ? (**a3 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v11 = a3[1], v14 = *(v7 + 56), (v12 = mlir::Value::getDefiningOp(&v14)) != 0) && (v5 = v10 & mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ConcatOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(v11, v12), v5 == 1)))
    {
      a3[2] = v6;
    }

    else
    {
      LOBYTE(v5) = 0;
    }
  }

  return (v6 != 0) & v5;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ConcatOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t *a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *a1;
  v12[0] = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(v12);
  v7 = DefiningOp;
  if (DefiningOp)
  {
    v14 = DefiningOp;
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 3)
    {
      v13 = 1;
      v12[0] = &v13;
      v12[1] = &v14;
      mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ConcatOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul,2ul>(v4, v12);
      v6 = v13;
      if (v13 == 1)
      {
        *(v4 + 24) = v14;
      }
    }

    else
    {
      v6 = 0;
    }
  }

  v9 = a1[1];
  v10 = *(*(a2 + 72) + 56);
  if (*v9)
  {
    v11 = *v9 == v10;
  }

  else
  {
    *v9 = v10;
    v11 = 1;
  }

  result = 0;
  if (v7)
  {
    if ((v6 & v11) != 0)
    {
      a1[2] = a2;
      return 1;
    }
  }

  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ConcatOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul,2ul>(uint64_t ***a1, uint64_t a2)
{
  v4 = *a1;
  v30 = *(*(**(a2 + 8) + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v30);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **v4) == 0) ? (**v4 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v11 = v4[1], v12 = *(v7 + 56), !*v11) ? (*v11 = v12, v13 = 1) : (v13 = *v11 == v12), v6 = v10 && v13, v6 == 1))
    {
      v4[2] = DefiningOp;
    }

    else
    {
      LOBYTE(v6) = 0;
    }
  }

  v14 = v6 & **a2;
  if (!DefiningOp)
  {
    v14 = 0;
  }

  **a2 = v14;
  v15 = a1[1];
  v30 = *(*(**(a2 + 8) + 72) + 56);
  result = mlir::Value::getDefiningOp(&v30);
  if (result)
  {
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 2 && ((v18 = *(result + 72), v19 = *(v18 + 24), (v20 = **v15) == 0) ? (**v15 = v19, v18 = *(result + 72), v21 = 1) : (v21 = v20 == v19), (v22 = v15[1], v23 = *(v18 + 56), !*v22) ? (*v22 = v23, v24 = 1) : (v24 = *v22 == v23), v21 && v24))
    {
      v15[2] = result;
      v17 = 1;
    }

    else
    {
      v17 = 0;
    }
  }

  v25 = *a2;
  v26 = v17 & **a2;
  if (!result)
  {
    v26 = 0;
  }

  *v25 = v26;
  v27 = a1[2];
  v28 = *(*(**(a2 + 8) + 72) + 88);
  if (*v27)
  {
    v29 = *v27 == v28;
  }

  else
  {
    *v27 = v28;
    v25 = *a2;
    v26 = **a2 != 0;
    v29 = 1;
  }

  *v25 = v29 & v26;
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ConcatOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t *a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *a1;
  v12[0] = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(v12);
  v7 = DefiningOp;
  if (DefiningOp)
  {
    v14 = DefiningOp;
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 3)
    {
      v13 = 1;
      v12[0] = &v13;
      v12[1] = &v14;
      mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>*,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ConcatOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>*,mlir::detail::any_value_binder*> & *)#1},0ul,1ul,2ul>(v4, v12);
      v6 = v13;
      if (v13 == 1)
      {
        *(v4 + 24) = v14;
      }
    }

    else
    {
      v6 = 0;
    }
  }

  v9 = a1[1];
  v10 = *(*(a2 + 72) + 56);
  if (*v9)
  {
    v11 = *v9 == v10;
  }

  else
  {
    *v9 = v10;
    v11 = 1;
  }

  result = 0;
  if (v7)
  {
    if ((v6 & v11) != 0)
    {
      a1[2] = a2;
      return 1;
    }
  }

  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>*,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ConcatOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>*,mlir::detail::any_value_binder*> & *)#1},0ul,1ul,2ul>(uint64_t a1, uint64_t a2)
{
  v4 = *a1;
  v22[0] = *(*(**(a2 + 8) + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(v22);
  v7 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v18 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>(DefiningOp, 0, *v4), v19 = v4[1], v20 = *(*(v7 + 72) + 56), !*v19) ? (*v19 = v20, v21 = 1) : (v21 = *v19 == v20), v6 = v18 & v21, v6 == 1))
    {
      v4[2] = v7;
    }

    else
    {
      LOBYTE(v6) = 0;
    }
  }

  v8 = v6 & **a2;
  if (!v7)
  {
    v8 = 0;
  }

  **a2 = v8;
  v9 = *(a1 + 8);
  v22[0] = *(*(**(a2 + 8) + 72) + 56);
  result = mlir::Value::getDefiningOp(v22);
  v12 = result;
  if (result)
  {
    v24 = result;
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::StridedSliceOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 4)
    {
      v23 = 1;
      v22[0] = &v23;
      v22[1] = &v24;
      result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> & *)#1},0ul,1ul,2ul,3ul>(v9, v22);
      v11 = v23;
      if (v23 == 1)
      {
        *(v9 + 32) = v24;
      }
    }

    else
    {
      v11 = 0;
    }
  }

  v13 = *a2;
  v14 = v11 & **a2;
  if (!v12)
  {
    v14 = 0;
  }

  *v13 = v14;
  v15 = *(a1 + 16);
  v16 = *(*(**(a2 + 8) + 72) + 88);
  if (*v15)
  {
    v17 = *v15 == v16;
  }

  else
  {
    *v15 = v16;
    v13 = *a2;
    v14 = **a2 != 0;
    v17 = 1;
  }

  *v13 = v17 & v14;
  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>(uint64_t a1, unsigned int a2, uint64_t a3)
{
  v13 = *(*(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v13);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id || (*(DefiningOp + 46) & 0x80) == 0 || *(DefiningOp + 68) != 2)
    {
      goto LABEL_13;
    }

    v7 = *a3;
    v13 = *(*(DefiningOp + 72) + 24);
    v8 = mlir::Value::getDefiningOp(&v13);
    if (v8)
    {
      LODWORD(v8) = mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(v7, v8);
    }

    v9 = *(a3 + 8);
    v10 = *(*(v6 + 72) + 56);
    if (*v9)
    {
      v11 = *v9 == v10;
    }

    else
    {
      *v9 = v10;
      v11 = 1;
    }

    v5 = v8 & v11;
    if (v5 == 1)
    {
      *(a3 + 16) = v6;
    }

    else
    {
LABEL_13:
      LOBYTE(v5) = 0;
    }
  }

  return (v6 != 0) & v5;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t *a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *a1;
  v12[0] = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(v12);
  v7 = DefiningOp;
  if (DefiningOp)
  {
    v14 = DefiningOp;
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::StridedSliceOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 4)
    {
      v13 = 1;
      v12[0] = &v13;
      v12[1] = &v14;
      mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> & *)#1},0ul,1ul,2ul,3ul>(v4, v12);
      v6 = v13;
      if (v13 == 1)
      {
        *(v4 + 32) = v14;
      }
    }

    else
    {
      v6 = 0;
    }
  }

  v9 = a1[1];
  v10 = *(*(a2 + 72) + 56);
  if (*v9)
  {
    v11 = *v9 == v10;
  }

  else
  {
    *v9 = v10;
    v11 = 1;
  }

  result = 0;
  if (v7)
  {
    if ((v6 & v11) != 0)
    {
      a1[2] = a2;
      return 1;
    }
  }

  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> & *)#1},0ul,1ul,2ul,3ul>(uint64_t ***a1, uint64_t a2)
{
  v4 = *a1;
  v30 = *(*(**(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp(&v30);
  if (result)
  {
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 2 && ((v7 = *(result + 72), v8 = *(v7 + 24), (v9 = **v4) == 0) ? (**v4 = v8, v7 = *(result + 72), v10 = 1) : (v10 = v9 == v8), (v11 = v4[1], v12 = *(v7 + 56), !*v11) ? (*v11 = v12, v13 = 1) : (v13 = *v11 == v12), v10 && v13))
    {
      v4[2] = result;
      v6 = 1;
    }

    else
    {
      v6 = 0;
    }
  }

  v14 = *a2;
  v15 = *(a2 + 8);
  v16 = v6 & **a2;
  if (result)
  {
    v17 = v16;
  }

  else
  {
    v17 = 0;
  }

  *v14 = v17;
  v18 = a1[1];
  v19 = *(*v15 + 72);
  v20 = v19[7];
  if (*v18)
  {
    v21 = *v18 == v20;
  }

  else
  {
    *v18 = v20;
    v14 = *a2;
    v19 = *(**(a2 + 8) + 72);
    v17 = **a2 != 0;
    v21 = 1;
  }

  v22 = v21 && v17;
  *v14 = v22;
  v23 = a1[2];
  v24 = v19[11];
  if (*v23)
  {
    v25 = *v23 == v24;
  }

  else
  {
    *v23 = v24;
    v14 = *a2;
    v19 = *(**(a2 + 8) + 72);
    v22 = **a2 != 0;
    v25 = 1;
  }

  v26 = v25 && v22;
  *v14 = v26;
  v27 = a1[3];
  v28 = v19[15];
  if (*v27)
  {
    v29 = *v27 == v28;
  }

  else
  {
    *v27 = v28;
    v14 = *a2;
    v26 = **a2 != 0;
    v29 = 1;
  }

  *v14 = v29 && v26;
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DepthwiseConv3DOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SpaceToBatchOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t *a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *a1;
  v12[0] = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(v12);
  v7 = DefiningOp;
  if (DefiningOp)
  {
    v14 = DefiningOp;
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SpaceToBatchOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 4)
    {
      v13 = 1;
      v12[0] = &v13;
      v12[1] = &v14;
      mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SpaceToBatchOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul>(v4, v12);
      v6 = v13;
      if (v13 == 1)
      {
        *(v4 + 32) = v14;
      }
    }

    else
    {
      v6 = 0;
    }
  }

  v9 = a1[1];
  v10 = *(*(a2 + 72) + 56);
  if (*v9)
  {
    v11 = *v9 == v10;
  }

  else
  {
    *v9 = v10;
    v11 = 1;
  }

  result = 0;
  if (v7)
  {
    if ((v6 & v11) != 0)
    {
      a1[2] = a2;
      return 1;
    }
  }

  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps_spi::ScaledDotProductAttentionOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t *a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *a1;
  v12[0] = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(v12);
  v7 = DefiningOp;
  if (DefiningOp)
  {
    v14 = DefiningOp;
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps_spi::ScaledDotProductAttentionOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 5)
    {
      v13 = 1;
      v12[0] = &v13;
      v12[1] = &v14;
      mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps_spi::ScaledDotProductAttentionOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> & *)#1},0ul,1ul,2ul,3ul,4ul>(v4, v12);
      v6 = v13;
      if (v13 == 1)
      {
        *(v4 + 40) = v14;
      }
    }

    else
    {
      v6 = 0;
    }
  }

  v9 = a1[1];
  v10 = *(*(a2 + 72) + 56);
  if (*v9)
  {
    v11 = *v9 == v10;
  }

  else
  {
    *v9 = v10;
    v11 = 1;
  }

  result = 0;
  if (v7)
  {
    if ((v6 & v11) != 0)
    {
      a1[2] = a2;
      return 1;
    }
  }

  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps_spi::ScaledDotProductAttentionOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> & *)#1},0ul,1ul,2ul,3ul,4ul>(uint64_t ***a1, uint64_t a2)
{
  v4 = *a1;
  v47 = *(*(**(a2 + 8) + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v47);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **v4) == 0) ? (**v4 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v11 = v4[1], v12 = *(v7 + 56), !*v11) ? (*v11 = v12, v13 = 1) : (v13 = *v11 == v12), v6 = v10 && v13, v6 == 1))
    {
      v4[2] = DefiningOp;
    }

    else
    {
      LOBYTE(v6) = 0;
    }
  }

  v14 = v6 & **a2;
  if (!DefiningOp)
  {
    v14 = 0;
  }

  **a2 = v14;
  v15 = a1[1];
  v47 = *(*(**(a2 + 8) + 72) + 56);
  v16 = mlir::Value::getDefiningOp(&v47);
  if (v16)
  {
    if (*(*(v16 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id && (*(v16 + 46) & 0x80) != 0 && *(v16 + 68) == 2 && ((v18 = *(v16 + 72), v19 = *(v18 + 24), (v20 = **v15) == 0) ? (**v15 = v19, v18 = *(v16 + 72), v21 = 1) : (v21 = v20 == v19), (v22 = v15[1], v23 = *(v18 + 56), !*v22) ? (*v22 = v23, v24 = 1) : (v24 = *v22 == v23), v17 = v21 && v24, v17 == 1))
    {
      v15[2] = v16;
    }

    else
    {
      LOBYTE(v17) = 0;
    }
  }

  v25 = v17 & **a2;
  if (!v16)
  {
    v25 = 0;
  }

  **a2 = v25;
  v26 = a1[2];
  v47 = *(*(**(a2 + 8) + 72) + 88);
  result = mlir::Value::getDefiningOp(&v47);
  if (result)
  {
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 2 && ((v29 = *(result + 72), v30 = *(v29 + 24), (v31 = **v26) == 0) ? (**v26 = v30, v29 = *(result + 72), v32 = 1) : (v32 = v31 == v30), (v33 = v26[1], v34 = *(v29 + 56), !*v33) ? (*v33 = v34, v35 = 1) : (v35 = *v33 == v34), v32 && v35))
    {
      v26[2] = result;
      v28 = 1;
    }

    else
    {
      v28 = 0;
    }
  }

  v36 = *a2;
  v37 = v28 & **a2;
  if (result)
  {
    v38 = v37;
  }

  else
  {
    v38 = 0;
  }

  *v36 = v38;
  v39 = a1[3];
  v40 = *(**(a2 + 8) + 72);
  v41 = *(v40 + 120);
  if (*v39)
  {
    v42 = *v39 == v41;
  }

  else
  {
    *v39 = v41;
    v36 = *a2;
    v40 = *(**(a2 + 8) + 72);
    v38 = **a2 != 0;
    v42 = 1;
  }

  v43 = v42 && v38;
  *v36 = v43;
  v44 = a1[4];
  v45 = *(v40 + 152);
  if (*v44)
  {
    v46 = *v44 == v45;
  }

  else
  {
    *v44 = v45;
    v36 = *a2;
    v43 = **a2 != 0;
    v46 = 1;
  }

  *v36 = v46 && v43;
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::GatherNDOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t *a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::GatherNDOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *a1;
  v12[0] = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(v12);
  v7 = DefiningOp;
  if (DefiningOp)
  {
    v14 = DefiningOp;
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 4)
    {
      v13 = 1;
      v12[0] = &v13;
      v12[1] = &v14;
      mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SpaceToBatchOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul>(v4, v12);
      v6 = v13;
      if (v13 == 1)
      {
        *(v4 + 32) = v14;
      }
    }

    else
    {
      v6 = 0;
    }
  }

  v9 = a1[1];
  v10 = *(*(a2 + 72) + 56);
  if (*v9)
  {
    v11 = *v9 == v10;
  }

  else
  {
    *v9 = v10;
    v11 = 1;
  }

  result = 0;
  if (v7)
  {
    if ((v6 & v11) != 0)
    {
      a1[2] = a2;
      return 1;
    }
  }

  return result;
}

uint64_t mlir::mps::anonymous namespace::CanonicalizeQuantizedLayerScale<mlir::mps::MatMulOp>::matchAndRewriteImpl(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  v5 = 0;
  v92[2] = *MEMORY[0x1E69E9840];
  v6 = v92;
  v90 = v92;
  v91 = 0x200000000;
  v87 = v89;
  v88 = 0x200000000;
  v84 = v86;
  v85 = 0x200000000;
  while (1)
  {
    v7 = (*(a2 + 46) & 0x80) != 0 ? *(a2 + 68) : 0;
    if (v5 >= v7)
    {
      break;
    }

    v8 = *(*(a2 + 72) + 32 * v5 + 24);
    v83 = v8;
    v9 = v85;
    if (v85 >= HIDWORD(v85))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(&v84, v86, v85 + 1, 8);
      v9 = v85;
    }

    *(v84 + v9) = v8;
    OUTLINED_FUNCTION_98_0();
    DefiningOp = mlir::Value::getDefiningOp(&v83);
    if (DefiningOp)
    {
      v11 = DefiningOp;
      v12 = *(*(DefiningOp + 48) + 16);
      v13 = v12 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id ? DefiningOp : 0;
      if (v12 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id && mlir::isConstantFPZero(*(*(DefiningOp + 72) + 120)))
      {
        v14 = *(*(v11 + 72) + 56);
        v15 = (v14[1] & 0xFFFFFFFFFFFFFFF8);
        v16 = v15 ? mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8) : 0;
        v79 = v15;
        v80 = v16;
        if (mlir::CallOpInterface::getArgOperands(&v79))
        {
          ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v79);
          if (v18)
          {
            v19 = 8 * v18;
            while (*ArgAttrsAttr != 0x8000000000000000)
            {
              ++ArgAttrsAttr;
              v19 -= 8;
              if (!v19)
              {
                goto LABEL_21;
              }
            }
          }

          else
          {
LABEL_21:
            if (mlir::isConstantFPOne(v14))
            {
              goto LABEL_44;
            }

            v20 = (v14[1] & 0xFFFFFFFFFFFFFFF8);
            if (v20)
            {
              v21 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
            }

            else
            {
              v21 = 0;
            }

            v79 = v20;
            v80 = v21;
            v22 = mlir::CallableOpInterface::getArgAttrsAttr(&v79);
            if (mlir::ShapedType::getNumElements(v22, v23) == 1)
            {
              v24 = -1;
LABEL_27:
              v25 = v91;
              if (v91 >= HIDWORD(v91))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod(&v90, v6, v91 + 1, 8);
                v25 = v91;
              }

              v90[v25] = v14;
              LODWORD(v91) = v91 + 1;
              v26 = v88;
              if (v88 >= HIDWORD(v88))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod(&v87, v89, v88 + 1, 8);
                v26 = v88;
              }

              *(v87 + v26) = v24;
              LODWORD(v88) = v88 + 1;
              v27 = (v14[1] & 0xFFFFFFFFFFFFFFF8);
              if (v27)
              {
                v28 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v27 + 8);
              }

              else
              {
                v28 = 0;
              }

              AttrDictionary = v27;
              v78 = v28;
              isSplat = mlir::ElementsAttr::isSplat(&AttrDictionary);
              v33 = mlir::RankedTensorType::get(0, 0, isSplat, 0);
              v34 = v33;
              if (v33)
              {
                v35 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v33 + 8);
              }

              else
              {
                v35 = 0;
              }

              DenseElementsAttrOf = mlir::createDenseElementsAttrOfType<float>(v34, v35, 1.0);
              v37 = DenseElementsAttrOf;
              if (DenseElementsAttrOf)
              {
                DenseElementsAttrOf = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*DenseElementsAttrOf + 8);
              }

              v79 = v37;
              v80 = DenseElementsAttrOf;
              v38 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr>((a3 + 1), v13[3], &v79);
              v39 = v13[3];
              v40 = *(v11 + 72);
              v76 = *(v40 + 24);
              AttrDictionary = (v38 - 16);
              v41 = *(v40 + 88);
              v42 = v13[10];
              v74 = v13[11];
              v75 = v41;
              v82 = v42;
              v43 = mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::Value,mlir::Value&,mlir::Value,mlir::TypeAttr,mlir::IntegerAttr>(a3 + 1, v39, &v76, &AttrDictionary, &v75, &v74, &v82);
              *(v84 + v5) = v43 - 16;
              goto LABEL_44;
            }

            AttrDictionary = a2;
            v79 = *(*(a2 + 72) + 32 * v5 + 24);
            v76 = mlir::Value::getDefiningOp(&v79);
            Axis = mlir::mps::DequantizeLUTOp::getAxis(&v76);
            if ((Axis & 0x100000000) == 0)
            {
              goto LABEL_44;
            }

            v24 = Axis;
            if ((Axis & 0x80000000) == 0)
            {
              v72 = v6;
              v30 = (*(v76 - 8) & 0xFFFFFFFFFFFFFFF8);
              v31 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v30 + 8);
              if (v31)
              {
                v31 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v30 + 8);
              }

              else
              {
                v30 = 0;
              }

              v79 = v30;
              v80 = v31;
              if (!v30 || (mlir::CallOpInterface::getArgOperands(&v79) & 1) == 0)
              {
                v6 = v72;
                goto LABEL_44;
              }

              mlir::CallableOpInterface::getArgAttrsAttr(&v79);
              v24 -= v44;
              v6 = v72;
            }

            if (v24 <= -3)
            {
              goto LABEL_27;
            }

            v45 = -2;
            if (v5)
            {
              v45 = -1;
            }

            v73 = v45;
            if (v5)
            {
              TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs(&AttrDictionary);
              v47 = -2;
            }

            else
            {
              TransposeRhs = mlir::pdl::ApplyNativeConstraintOp::getIsNegated(&AttrDictionary);
              v47 = -1;
            }

            if (!TransposeRhs)
            {
              v47 = v73;
            }

            v69 = v47 == v24;
            v24 = v73;
            if (v69)
            {
              goto LABEL_27;
            }
          }
        }
      }
    }

LABEL_44:
    ++v5;
  }

  if (v91)
  {
    v48 = *(a2 + 24);
    v49 = *(a2 + 36);
    v50 = a2 - 16;
    if (!v49)
    {
      v50 = 0;
    }

    AttrDictionary = v50;
    v78 = v49;
    mlir::OperandRange::getTypes(&AttrDictionary, &v79);
    AttrDictionary = mlir::Operation::getAttrDictionary(a2);
    AttrDictionary = mlir::ArrayAttr::getValue(&AttrDictionary);
    v78 = v51;
    v52 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::ValueTypeRange<mlir::ResultRange>,llvm::SmallVector<mlir::Value,2u> &,llvm::ArrayRef<mlir::NamedAttribute>>((a3 + 1), v48, &v79, &v84, &AttrDictionary) - 16;
    v76 = v52;
    AttrDictionary = mlir::getElementTypeOrSelf(v52);
    if (v91 && v88)
    {
      v53 = v90;
      v54 = v87;
      v55 = &v90[v91];
      v56 = v87 + 8 * v88;
      do
      {
        v83 = *v53;
        v57 = *v54;
        ElementTypeOrSelf = mlir::getElementTypeOrSelf(v83);
        if (AttrDictionary != ElementTypeOrSelf)
        {
          Loc = mlir::Value::getLoc(&v83);
          v83 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 1, Loc, &v83, &AttrDictionary) - 16;
        }

        if (v57 != -1)
        {
          v60 = 0;
          v79 = v81;
          v80 = 0x500000000;
          v61 = v57 + 1;
          do
          {
            if (v60 >= HIDWORD(v80))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(&v79, v81, v60 + 1, 8);
              v60 = v80;
            }

            *(v79 + v60) = v61;
            v60 = v80 + 1;
            LODWORD(v80) = v80 + 1;
          }

          while (!__CFADD__(v61++, 1));
          v63 = mlir::Value::getLoc(&v83);
          v82 = v80;
          IntegerType = mlir::Builder::getIntegerType(a3 + 1, 64, 1);
          v65 = mlir::RankedTensorType::get(&v82, 1, IntegerType, 0);
          v66 = v65;
          if (v65)
          {
            v67 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v65 + 8);
          }

          else
          {
            v67 = 0;
          }

          v74 = mlir::DenseElementsAttr::getFromRawBuffer(v66, v67, v79, 8 * v80, 8, 1, 1);
          v75 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseElementsAttr &>((a3 + 1), v63, &v74) - 16;
          v83 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((a3 + 1), *(a2 + 24), &v83, &v75) - 16;
          if (v79 != v81)
          {
            free(v79);
          }
        }

        v68 = mlir::Value::getLoc(&v83);
        v52 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(a3 + 1, v68, &v76, &v83) - 16;
        v76 = v52;
        ++v53;
        v54 += 8;
        v69 = v53 == v55 || v54 == v56;
      }

      while (!v69);
    }

    v83 = v52;
    v70 = 1;
    mlir::ValueRange::ValueRange(&v79, &v83, 1uLL);
    (**a3)(a3, a2, v79, v80);
  }

  else
  {
    v70 = 0;
  }

  if (v84 != v86)
  {
    free(v84);
  }

  if (v87 != v89)
  {
    free(v87);
  }

  if (v90 != v6)
  {
    free(v90);
  }

  return v70;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>(uint64_t a1, unsigned int a2, uint64_t a3)
{
  v13 = *(*(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v13);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id || (*(DefiningOp + 46) & 0x80) == 0 || *(DefiningOp + 68) != 2)
    {
      goto LABEL_13;
    }

    v7 = *a3;
    v13 = *(*(DefiningOp + 72) + 24);
    v8 = mlir::Value::getDefiningOp(&v13);
    if (v8)
    {
      LODWORD(v8) = mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(v7, v8);
    }

    v9 = *(a3 + 8);
    v10 = *(*(v6 + 72) + 56);
    if (*v9)
    {
      v11 = *v9 == v10;
    }

    else
    {
      *v9 = v10;
      v11 = 1;
    }

    v5 = v8 & v11;
    if (v5 == 1)
    {
      *(a3 + 16) = v6;
    }

    else
    {
LABEL_13:
      LOBYTE(v5) = 0;
    }
  }

  return (v6 != 0) & v5;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t ***a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *a1;
  v19 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v19);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **v4) == 0) ? (**v4 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v13 = v4[1], v14 = *(v7 + 56), !*v13) ? (*v13 = v14, v15 = 1) : (v15 = *v13 == v14), v10 && v15))
    {
      v4[2] = DefiningOp;
      v6 = 1;
    }

    else
    {
      v6 = 0;
    }
  }

  v16 = a1[1];
  v17 = *(*(a2 + 72) + 56);
  if (*v16)
  {
    v18 = *v16 == v17;
  }

  else
  {
    *v16 = v17;
    v18 = 1;
  }

  v11 = 0;
  if (DefiningOp && (v6 & v18) != 0)
  {
    a1[2] = a2;
    return 1;
  }

  return v11;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mpsx::BufferToTensorOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::GatherNDOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mpsx::BufferToTensorOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mpsx::BufferToTensorOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  v4 = *a1;
  v15 = *(*(**(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp(&v15);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::BufferToTensorOp,void>::id || (*(result + 46) & 0x80) == 0 || *(result + 68) != 1)
    {
      goto LABEL_7;
    }

    v7 = *(*(result + 72) + 24);
    v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        v6 = 0;
        goto LABEL_8;
      }
    }

    else
    {
      **v4 = v7;
    }

    v4[1] = result;
    v6 = 1;
  }

LABEL_8:
  v9 = *a2;
  v10 = *(a2 + 8);
  v11 = v6 & **a2;
  if (!result)
  {
    v11 = 0;
  }

  *v9 = v11;
  v12 = a1[1];
  v13 = *(*(*v10 + 72) + 56);
  if (*v12)
  {
    v14 = *v12 == v13;
  }

  else
  {
    *v12 = v13;
    v9 = *a2;
    v11 = **a2 != 0;
    v14 = 1;
  }

  *v9 = v14 & v11;
  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mpsx::BufferToTensorOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mpsx::TensorToBufferOp,mlir::detail::any_value_binder>>>(uint64_t a1, unsigned int a2, uint64_t ***a3)
{
  v12 = *(*(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v12);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::BufferToTensorOp,void>::id)
    {
      goto LABEL_11;
    }

    if ((*(DefiningOp + 46) & 0x80) == 0)
    {
      goto LABEL_11;
    }

    if (*(DefiningOp + 68) != 1)
    {
      goto LABEL_11;
    }

    v7 = *a3;
    v12 = *(*(DefiningOp + 72) + 24);
    v8 = mlir::Value::getDefiningOp(&v12);
    if (!v8 || *(*(v8 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::TensorToBufferOp,void>::id || (*(v8 + 46) & 0x80) == 0 || *(v8 + 68) != 1)
    {
      goto LABEL_11;
    }

    v9 = *(*(v8 + 72) + 24);
    v10 = **v7;
    if (v10)
    {
      if (v10 != v9)
      {
LABEL_11:
        v5 = 0;
        return (v6 != 0) & v5;
      }
    }

    else
    {
      **v7 = v9;
    }

    v7[1] = v8;
    a3[1] = v6;
    v5 = 1;
  }

  return (v6 != 0) & v5;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::VariableFromTensorOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AssignVariableOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::VariableFromTensorOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::VariableFromTensorOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  v4 = *a1;
  v15 = *(*(**(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp(&v15);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::VariableFromTensorOp,void>::id || (*(result + 46) & 0x80) == 0 || *(result + 68) != 1)
    {
      goto LABEL_7;
    }

    v7 = *(*(result + 72) + 24);
    v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        v6 = 0;
        goto LABEL_8;
      }
    }

    else
    {
      **v4 = v7;
    }

    v4[1] = result;
    v6 = 1;
  }

LABEL_8:
  v9 = *a2;
  v10 = *(a2 + 8);
  v11 = v6 & **a2;
  if (!result)
  {
    v11 = 0;
  }

  *v9 = v11;
  v12 = a1[1];
  v13 = *(*(*v10 + 72) + 56);
  if (*v12)
  {
    v14 = *v12 == v13;
  }

  else
  {
    *v12 = v13;
    v9 = *a2;
    v11 = **a2 != 0;
    v14 = 1;
  }

  *v9 = v14 & v11;
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
  {
    return 0;
  }

  v6 = *a1;
  v5 = *(a1 + 8);
  v31 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v31);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v9 = *(DefiningOp + 72), v10 = *(v9 + 24), (v11 = **v6) == 0) ? (**v6 = v10, v9 = *(DefiningOp + 72), v12 = 1) : (v12 = v11 == v10), (v13 = v6[1], v14 = *(v9 + 56), !*v13) ? (*v13 = v14, v15 = 1) : (v15 = *v13 == v14), v8 = v12 && v15, v8 == 1))
    {
      v6[2] = DefiningOp;
    }

    else
    {
      v8 = 0;
    }
  }

  v16 = *(*(a2 + 72) + 56);
  if (*v5)
  {
    v17 = *v5 == v16;
    if (!DefiningOp)
    {
      goto LABEL_25;
    }
  }

  else
  {
    *v5 = v16;
    v17 = 1;
    if (!DefiningOp)
    {
      goto LABEL_25;
    }
  }

  if (v8 & v17)
  {
LABEL_22:
    if ((*(a1 + 24) & 1) == 0)
    {
      *(a1 + 24) = 1;
    }

    *(a1 + 16) = a2;
    return 1;
  }

LABEL_25:
  **(a1 + 8) = 0;
  v18 = *a1;
  ***a1 = 0;
  *v18[1] = 0;
  v18[2] = 0;
  v20 = *a1;
  v19 = *(a1 + 8);
  v21 = *(a2 + 72);
  v22 = *(v21 + 24);
  if (*v19)
  {
    v23 = *v19 == v22;
  }

  else
  {
    *v19 = v22;
    v21 = *(a2 + 72);
    v23 = 1;
  }

  v31 = *(v21 + 56);
  result = mlir::Value::getDefiningOp(&v31);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id || (*(result + 46) & 0x80) == 0 || *(result + 68) != 2)
    {
      return 0;
    }

    v24 = *(result + 72);
    v25 = *(v24 + 24);
    v26 = **v20;
    if (v26)
    {
      v27 = v26 == v25;
    }

    else
    {
      **v20 = v25;
      v24 = *(result + 72);
      v27 = 1;
    }

    v28 = v20[1];
    v29 = *(v24 + 56);
    if (*v28)
    {
      v30 = *v28 == v29;
    }

    else
    {
      *v28 = v29;
      v30 = 1;
    }

    if (!v27 || !v30)
    {
      return 0;
    }

    v20[2] = result;
    if (!v23)
    {
      return 0;
    }

    goto LABEL_22;
  }

  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DDataGradientOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
  {
    return 0;
  }

  v6 = *a1;
  v5 = *(a1 + 8);
  v31 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v31);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v9 = *(DefiningOp + 72), v10 = *(v9 + 24), (v11 = **v6) == 0) ? (**v6 = v10, v9 = *(DefiningOp + 72), v12 = 1) : (v12 = v11 == v10), (v13 = v6[1], v14 = *(v9 + 56), !*v13) ? (*v13 = v14, v15 = 1) : (v15 = *v13 == v14), v8 = v12 && v15, v8 == 1))
    {
      v6[2] = DefiningOp;
    }

    else
    {
      v8 = 0;
    }
  }

  v16 = *(*(a2 + 72) + 56);
  if (*v5)
  {
    v17 = *v5 == v16;
    if (!DefiningOp)
    {
      goto LABEL_25;
    }
  }

  else
  {
    *v5 = v16;
    v17 = 1;
    if (!DefiningOp)
    {
      goto LABEL_25;
    }
  }

  if (v8 & v17)
  {
LABEL_22:
    if ((*(a1 + 24) & 1) == 0)
    {
      *(a1 + 24) = 1;
    }

    *(a1 + 16) = a2;
    return 1;
  }

LABEL_25:
  **(a1 + 8) = 0;
  v18 = *a1;
  ***a1 = 0;
  *v18[1] = 0;
  v18[2] = 0;
  v20 = *a1;
  v19 = *(a1 + 8);
  v21 = *(a2 + 72);
  v22 = *(v21 + 24);
  if (*v19)
  {
    v23 = *v19 == v22;
  }

  else
  {
    *v19 = v22;
    v21 = *(a2 + 72);
    v23 = 1;
  }

  v31 = *(v21 + 56);
  result = mlir::Value::getDefiningOp(&v31);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id || (*(result + 46) & 0x80) == 0 || *(result + 68) != 2)
    {
      return 0;
    }

    v24 = *(result + 72);
    v25 = *(v24 + 24);
    v26 = **v20;
    if (v26)
    {
      v27 = v26 == v25;
    }

    else
    {
      **v20 = v25;
      v24 = *(result + 72);
      v27 = 1;
    }

    v28 = v20[1];
    v29 = *(v24 + 56);
    if (*v28)
    {
      v30 = *v28 == v29;
    }

    else
    {
      *v28 = v29;
      v30 = 1;
    }

    if (!v27 || !v30)
    {
      return 0;
    }

    v20[2] = result;
    if (!v23)
    {
      return 0;
    }

    goto LABEL_22;
  }

  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv3DOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
  {
    return 0;
  }

  v6 = *a1;
  v5 = *(a1 + 8);
  v31 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v31);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v9 = *(DefiningOp + 72), v10 = *(v9 + 24), (v11 = **v6) == 0) ? (**v6 = v10, v9 = *(DefiningOp + 72), v12 = 1) : (v12 = v11 == v10), (v13 = v6[1], v14 = *(v9 + 56), !*v13) ? (*v13 = v14, v15 = 1) : (v15 = *v13 == v14), v8 = v12 && v15, v8 == 1))
    {
      v6[2] = DefiningOp;
    }

    else
    {
      v8 = 0;
    }
  }

  v16 = *(*(a2 + 72) + 56);
  if (*v5)
  {
    v17 = *v5 == v16;
    if (!DefiningOp)
    {
      goto LABEL_25;
    }
  }

  else
  {
    *v5 = v16;
    v17 = 1;
    if (!DefiningOp)
    {
      goto LABEL_25;
    }
  }

  if (v8 & v17)
  {
LABEL_22:
    if ((*(a1 + 24) & 1) == 0)
    {
      *(a1 + 24) = 1;
    }

    *(a1 + 16) = a2;
    return 1;
  }

LABEL_25:
  **(a1 + 8) = 0;
  v18 = *a1;
  ***a1 = 0;
  *v18[1] = 0;
  v18[2] = 0;
  v20 = *a1;
  v19 = *(a1 + 8);
  v21 = *(a2 + 72);
  v22 = *(v21 + 24);
  if (*v19)
  {
    v23 = *v19 == v22;
  }

  else
  {
    *v19 = v22;
    v21 = *(a2 + 72);
    v23 = 1;
  }

  v31 = *(v21 + 56);
  result = mlir::Value::getDefiningOp(&v31);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id || (*(result + 46) & 0x80) == 0 || *(result + 68) != 2)
    {
      return 0;
    }

    v24 = *(result + 72);
    v25 = *(v24 + 24);
    v26 = **v20;
    if (v26)
    {
      v27 = v26 == v25;
    }

    else
    {
      **v20 = v25;
      v24 = *(result + 72);
      v27 = 1;
    }

    v28 = v20[1];
    v29 = *(v24 + 56);
    if (*v28)
    {
      v30 = *v28 == v29;
    }

    else
    {
      *v28 = v29;
      v30 = 1;
    }

    if (!v27 || !v30)
    {
      return 0;
    }

    v20[2] = result;
    if (!v23)
    {
      return 0;
    }

    goto LABEL_22;
  }

  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv3DDataGradientOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
  {
    return 0;
  }

  v6 = *a1;
  v5 = *(a1 + 8);
  v31 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v31);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v9 = *(DefiningOp + 72), v10 = *(v9 + 24), (v11 = **v6) == 0) ? (**v6 = v10, v9 = *(DefiningOp + 72), v12 = 1) : (v12 = v11 == v10), (v13 = v6[1], v14 = *(v9 + 56), !*v13) ? (*v13 = v14, v15 = 1) : (v15 = *v13 == v14), v8 = v12 && v15, v8 == 1))
    {
      v6[2] = DefiningOp;
    }

    else
    {
      v8 = 0;
    }
  }

  v16 = *(*(a2 + 72) + 56);
  if (*v5)
  {
    v17 = *v5 == v16;
    if (!DefiningOp)
    {
      goto LABEL_25;
    }
  }

  else
  {
    *v5 = v16;
    v17 = 1;
    if (!DefiningOp)
    {
      goto LABEL_25;
    }
  }

  if (v8 & v17)
  {
LABEL_22:
    if ((*(a1 + 24) & 1) == 0)
    {
      *(a1 + 24) = 1;
    }

    *(a1 + 16) = a2;
    return 1;
  }

LABEL_25:
  **(a1 + 8) = 0;
  v18 = *a1;
  ***a1 = 0;
  *v18[1] = 0;
  v18[2] = 0;
  v20 = *a1;
  v19 = *(a1 + 8);
  v21 = *(a2 + 72);
  v22 = *(v21 + 24);
  if (*v19)
  {
    v23 = *v19 == v22;
  }

  else
  {
    *v19 = v22;
    v21 = *(a2 + 72);
    v23 = 1;
  }

  v31 = *(v21 + 56);
  result = mlir::Value::getDefiningOp(&v31);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id || (*(result + 46) & 0x80) == 0 || *(result + 68) != 2)
    {
      return 0;
    }

    v24 = *(result + 72);
    v25 = *(v24 + 24);
    v26 = **v20;
    if (v26)
    {
      v27 = v26 == v25;
    }

    else
    {
      **v20 = v25;
      v24 = *(result + 72);
      v27 = 1;
    }

    v28 = v20[1];
    v29 = *(v24 + 56);
    if (*v28)
    {
      v30 = *v28 == v29;
    }

    else
    {
      *v28 = v29;
      v30 = 1;
    }

    if (!v27 || !v30)
    {
      return 0;
    }

    v20[2] = result;
    if (!v23)
    {
      return 0;
    }

    goto LABEL_22;
  }

  return result;
}

void mlir::OpBuilder::create<mlir::mps::RealPartOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.real_part";
  *(a2 + 24) = 13;
}

void mlir::OpBuilder::create<mlir::mps::ImaginaryPartOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.imaginary_part";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::mps::CreateComplexOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.create_complex";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::mps::BiasAddOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.bias_add";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::mps::ReductionArgMaxOp,mlir::Value &,mlir::Value &,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reduction_argmax";
  *(a2 + 24) = 20;
}

void mlir::OpBuilder::create<mlir::mps::ReductionArgMinOp,mlir::Value &,mlir::Value &,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reduction_argmin";
  *(a2 + 24) = 20;
}

void mlir::OpBuilder::create<mlir::mps::ReductionMinOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reduction_min";
  *(a2 + 24) = 17;
}

void mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Value,mlir::Value&,mlir::Value,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,long long &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.depthwise_conv_3d_data_gradient";
  *(a2 + 24) = 35;
}

void mlir::OpBuilder::create<mlir::mpsx::SparseDenseMatMulOp,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::mps::TransposeOp &,BOOL,BOOL,mlir::mps::SparseTensorStorage>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.sparse_dense_matmul";
  *(a2 + 24) = 24;
}

void mlir::OpBuilder::create<mlir::mps_spi::RMSNormOp,mlir::Value &,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps_spi.rms_norm";
  *(a2 + 24) = 16;
}

void mlir::OpBuilder::create<mlir::mps::ReinterpretCastOp,mlir::Value,mlir::ComplexType>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reinterpret_cast";
  *(a2 + 24) = 20;
}

void mlir::mps::anonymous namespace::CanonicalizeReadVariable::matchAndRewriteImpl()
{
  OUTLINED_FUNCTION_15_10();
  if (v0)
  {
    if (mlir::RewriterBase::Listener::classof(v0))
    {
      OUTLINED_FUNCTION_16_9();
      v1 = OUTLINED_FUNCTION_38_3();
      v2(v1);
    }
  }
}

void mlir::OpBuilder::create<mlir::mps::ReadVariableOp,mlir::detail::TypedValue<mlir::TensorType> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.read_variable";
  *(a2 + 24) = 17;
}

void mlir::OpBuilder::create<mlir::mps::IdentityOp,mlir::mps::ReadVariableOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.identity";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::mpsx::QuantizedGatherOp,mlir::Value &,mlir::Value,mlir::Value,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Type,unsigned int,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.quantized_gather";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::mpsx::FusionOp,mlir::mpsx::FusionType const&,mlir::IRMapping &,llvm::SmallVector<mlir::Value,5u> &,llvm::SmallVector<mlir::Value,1u> &,llvm::ArrayRef<mlir::Operation *>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.fusion";
  *(a2 + 24) = 11;
}

void mlir::mps::anonymous namespace::ReshapeConvBiasReshape::matchAndRewriteImpl()
{
  OUTLINED_FUNCTION_15_10();
  if (v0)
  {
    if (mlir::RewriterBase::Listener::classof(v0))
    {
      v1 = OUTLINED_FUNCTION_38_3();
      v2(v1);
    }
  }
}

void mlir::OpBuilder::create<mlir::mps::ModuloOp,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.modulo";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::mps::GatherNDOp,mlir::Value &,mlir::Value &,unsigned int,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.gather_nd";
  *(a2 + 24) = 13;
}

void mlir::mps::anonymous namespace::CanonicalizeTensorBuffer::matchAndRewriteImpl(uint64_t a1, uint64_t a2)
{
  if (*(a2 + 16))
  {
    if (mlir::RewriterBase::Listener::classof(*(a2 + 16)))
    {
      v2 = OUTLINED_FUNCTION_38_3();
      v3(v2);
    }
  }
}

void mlir::mps::anonymous namespace::CanonicalizeReadStateTensorBuffer::matchAndRewriteImpl()
{
  OUTLINED_FUNCTION_15_10();
  if (v0)
  {
    if (mlir::RewriterBase::Listener::classof(v0))
    {
      OUTLINED_FUNCTION_16_9();
      v1 = OUTLINED_FUNCTION_38_3();
      v2(v1);
    }
  }
}

void mlir::OpBuilder::create<mlir::mps::VariableFromTensorOp,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.variable_from_tensor";
  *(a2 + 24) = 24;
}

void mlir::OpBuilder::create<mlir::mpsx::TensorToBufferOp,mlir::detail::TypedValue<mlir::TensorType>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.tensor_to_buffer";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::mpsx::BufferToTensorOp,mlir::Value &,mlir::DenseIntElementsAttr,mlir::TypeAttr,mlir::DenseIntElementsAttr,BOOL,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.buffer_to_tensor";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::mps::AssignVariableOp,mlir::OpResult,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.assign_variable";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::mps::Flatten2DOp,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.flatten_2d";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::mps::RandomUniformOp,mlir::RankedTensorType &,mlir::OperandRange,llvm::ArrayRef<mlir::NamedAttribute>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.random_uniform";
  *(a2 + 24) = 18;
}

uint64_t *mlir::Operation::getOperandTypes@<X0>(mlir::Operation *this@<X0>, uint64_t *a2@<X8>)
{
  if ((*(this + 46) & 0x80) != 0)
  {
    v2 = *(this + 9);
    v3 = *(this + 17);
  }

  else
  {
    v2 = 0;
    v3 = 0;
  }

  v5[0] = v2;
  v5[1] = v3;
  return mlir::OperandRange::getTypes(v5, a2);
}

void mlir::mps::anonymous namespace::isStitchable()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsAndResultShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultShape>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::mpsx::ReturnStitchedOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.stitched_return";
  *(a2 + 24) = 20;
}

void mlir::OpBuilder::create<mlir::mpsx::StitchedOp,mlir::UnrankedTensorType &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.stitched";
  *(a2 + 24) = 13;
}

mlir::Block *mlir::mps::anonymous namespace::StitchedRegion::recursePrefixes(uint64_t a1, uint64_t a2, mlir::Block **a3, void *a4)
{
  v7 = (a1 - 16);
  do
  {
    v8 = a4[2];
    result = *(v8 + 16);
    if (result)
    {
      result = mlir::Block::getParentOp(result);
    }

    if (result == *a3 && (*(v8 + 46) & 0x80) != 0)
    {
      v10 = *(v8 + 68);
      if (v10)
      {
        v11 = 0;
        v12 = 32 * v10;
        v13 = *(v8 + 72) + 24;
        do
        {
          if (*(v13 + v11) == a2)
          {
            v14 = (*(v8 + 72) + v11);
            v15 = v14[1];
            if (v15)
            {
              v16 = *v14;
              *v15 = *v14;
              if (v16)
              {
                *(v16 + 8) = v14[1];
              }
            }

            v14[3] = v7;
            v17 = *v7;
            *v14 = *v7;
            v14[1] = v7;
            if (v17)
            {
              *(v17 + 8) = v14;
            }

            *v7 = v14;
          }

          v11 += 32;
        }

        while (v12 != v11);
      }
    }

    a4 = *a4;
  }

  while (a4);
  return result;
}

void mlir::mps::anonymous namespace::TypeInferencePass::inferTypes(unint64_t a1, _DWORD *a2, void *a3, unint64_t a4)
{
  if (a1 <= 4)
  {
    v7 = 0;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, a4, a1, 8);
    v7 = *a2;
  }

  if (a1 != v7)
  {
    bzero((*a3 + 8 * v7), 8 * (a1 - v7));
  }

  *a2 = a1;
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::mpsx::anonymous namespace::anonymous namespace::outlineRegion(mlir::RewriterBase &,mlir::mpsx::GPUOp,llvm::ArrayRef<mlir::Operation *>,mlir::mps::ConstantRuntimeAnalysis &,unsigned long long,BOOL,BOOL)::$_0>(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 68);
    if (v2)
    {
      v4 = (*(a2 + 72) + 24);
      do
      {
        v14 = *v4;
        DefiningOp = mlir::Value::getDefiningOp(&v14);
        if (DefiningOp)
        {
          v6 = DefiningOp;
          ParentOp = *(DefiningOp + 16);
          if (ParentOp)
          {
            ParentOp = mlir::Block::getParentOp(ParentOp);
          }

          {
            v8 = *(a1 + 16);
            v9 = v8[2];
            v10 = v8[1];
            if (v9 == v10)
            {
              v11 = 0;
            }

            else
            {
              v11 = ((v9 - v10) << 6) - 1;
            }

            v12 = v8[5];
            v13 = v12 + v8[4];
            if (v11 == v13)
            {
              std::deque<mlir::func::FuncOp>::__add_back_capacity(*(a1 + 16));
              v10 = v8[1];
              v12 = v8[5];
              v13 = v8[4] + v12;
            }

            *(*(v10 + ((v13 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v13 & 0x1FF)) = v6;
            v8[5] = v12 + 1;
          }
        }

        v4 += 4;
        --v2;
      }

      while (v2);
    }
  }
}

mlir::Block *llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::mpsx::anonymous namespace::anonymous namespace::outlineRegion(mlir::RewriterBase &,mlir::mpsx::GPUOp,llvm::ArrayRef<mlir::Operation *>,mlir::mps::ConstantRuntimeAnalysis &,unsigned long long,BOOL,BOOL)::$_2>(mlir::Block *result, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 68);
    if (v2)
    {
      v3 = result;
      v4 = 0;
      v5 = *(a2 + 72);
      do
      {
        v33 = *(v5 + 32 * v4 + 24);
        result = mlir::Value::getDefiningOp(&v33);
        ParentOp = result;
        v7 = *v3;
        v8 = *v3 + 8;
        v9 = **v3;
        if (v9)
        {
          v10 = 4;
        }

        else
        {
          v8 = *(v7 + 1);
          v10 = v7[4];
          if (!v10)
          {
            v11 = 0;
            v12 = 0;
            goto LABEL_7;
          }
        }

        v14 = 0x9DDFEA08EB382D69 * ((8 * v33 - 0xAE502812AA7333) ^ HIDWORD(v33));
        v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v33) ^ (v14 >> 47) ^ v14);
        LODWORD(v14) = -348639895 * ((v15 >> 47) ^ v15);
        v16 = v10 - 1;
        v17 = v14 & (v10 - 1);
        v18 = *(v8 + 8 * v17);
        if (v33 == v18)
        {
LABEL_10:
          v13 = (v8 + 8 * v17);
          if ((v9 & 1) == 0)
          {
            v8 = *(v7 + 1);
            v11 = v7[4];
            goto LABEL_12;
          }
        }

        else
        {
          v20 = 1;
          while (v18 != -4096)
          {
            v21 = v17 + v20++;
            v17 = v21 & v16;
            v18 = *(v8 + 8 * v17);
            if (v33 == v18)
            {
              goto LABEL_10;
            }
          }

          if ((v9 & 1) == 0)
          {
            v8 = *(v7 + 1);
            v11 = v7[4];
            v12 = v11;
LABEL_7:
            v13 = (v8 + 8 * v12);
LABEL_12:
            v19 = (v8 + 8 * v11);
            goto LABEL_21;
          }

          v13 = v7 + 10;
        }

        v19 = v7 + 10;
LABEL_21:
        if (v13 == v19)
        {
          if (!result)
          {
            goto LABEL_33;
          }

          v22 = v3[1];
          v23 = *v3[2];
          if (v23 == result)
          {
            ParentOp = 0;
          }

          else
          {
            while (1)
            {
              result = *(ParentOp + 16);
              if (result)
              {
                result = mlir::Block::getParentOp(result);
              }

              if (result == v23)
              {
                break;
              }

              v24 = *(ParentOp + 16);
              ParentOp = 0;
              if (v24)
              {
                ParentOp = mlir::Block::getParentOp(v24);
              }
            }
          }

          v25 = *(v22 + 16);
          if (!v25)
          {
            goto LABEL_33;
          }

          v26 = ((ParentOp >> 4) ^ (ParentOp >> 9)) & (v25 - 1);
          v27 = *(*v22 + 8 * v26);
          if (v27 != ParentOp)
          {
            v31 = 1;
            while (v27 != -4096)
            {
              v32 = v26 + v31++;
              v26 = v32 & (v25 - 1);
              v27 = *(*v22 + 8 * v26);
              if (v27 == ParentOp)
              {
                goto LABEL_32;
              }
            }

LABEL_33:
            v28 = v3[3];
            v29 = v33;
            v30 = *(v28 + 8);
            if (v30 >= *(v28 + 12))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(v3[3], v28 + 16, v30 + 1, 8);
              v30 = *(v28 + 8);
            }

            *(*v28 + 8 * v30) = v29;
            ++*(v28 + 8);
            result = llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Value,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::try_emplace<llvm::detail::DenseSetEmpty&>(*v3, &v33, v34);
            goto LABEL_36;
          }

LABEL_32:
          if (v26 == v25)
          {
            goto LABEL_33;
          }
        }

LABEL_36:
        ++v4;
      }

      while (v4 != v2);
    }
  }

  return result;
}

void mlir::OpBuilder::create<mlir::func::FuncOp,std::string &,mlir::FunctionType &>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "func.func";
  *(a2 + 24) = 9;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

BOOL mlir::mpsx::anonymous namespace::ANERegionOpCreator::replaceOutOfRegionUses(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) == 0)
  {
    return 1;
  }

  v2 = *(a2 + 68);
  if (!v2)
  {
    return 1;
  }

  v3 = v2 - 1;
  for (i = (*(a2 + 72) + 24); ; i += 4)
  {
    v9 = *i;
    DefiningOp = mlir::Value::getDefiningOp(&v9);
    if (!DefiningOp)
    {
      break;
    }

    v6 = *(*(DefiningOp + 48) + 16);
    result = v6 != &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id;
    if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id || v3-- == 0)
    {
      return result;
    }
  }

  return 1;
}

void mlir::mpsx::anonymous namespace::ANERegionFormationPass::runOnOperation()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::mpsx::anonymous namespace::ANERegionOpCreator::isOpCompatible(uint64_t a1, mlir::InFlightDiagnostic *a2, uint64_t a3)
{
  *a1 = "Could not follow op placement hint";
  *(a1 + 32) = 259;
  mlir::Operation::emitOpError(a3, a1, a2);
  mlir::InFlightDiagnostic::~InFlightDiagnostic(a2);
  __break(1u);
}

void mlir::OpBuilder::create<mlir::mpsx::ANEOp,mlir::FunctionType &,std::string,BOOL,mlir::ArrayAttr,mlir::ArrayAttr,mlir::ArrayAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.ane";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::placement::ANEIOCast,mlir::Type,mlir::BlockArgument &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "placement.ane_io_cast";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::func::ReturnOp>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "func.return";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::mps::ReadDataFromFileOp,mlir::Type,std::string &,unsigned long &,std::string &>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.read_data_from_file";
  *(a2 + 24) = 23;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

void mlir::OpBuilder::create<mlir::mpsx::ANEOp,mlir::FunctionType,llvm::StringRef,BOOL,mlir::ArrayAttr,mlir::ArrayAttr,mlir::ArrayAttr>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.ane";
  *(a2 + 24) = 8;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

void mlir::OpBuilder::create<mlir::func::FuncOp,llvm::StringRef const&,mlir::FunctionType &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "func.func";
  *(a2 + 24) = 9;
}

void anonymous namespace::IRPrinterInstrumentation::runBeforePass()
{
  {
    v0 = llvm::getTypeName<mlir::detail::OpToOpPassAdaptor>();
    mlir::detail::TypeIDResolver<mlir::detail::OpToOpPassAdaptor,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Pass::printAsTextualPipeline()
{
  {
    v0 = llvm::getTypeName<mlir::detail::OpToOpPassAdaptor>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_0_11(v2);
  }
}

void mlir::detail::OpPassManagerImpl::canScheduleOn()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1_18(v2);
  }
}

void mlir::OpPassManager::hash()
{
  {
    v0 = llvm::getTypeName<mlir::detail::OpToOpPassAdaptor>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_0_11(v2);
  }
}

void mlir::detail::OpToOpPassAdaptor::run()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1_18(v2);
  }
}

void mlir::detail::PreservedAnalyses::isAll()
{
  {
    v0 = llvm::getTypeName<mlir::detail::PreservedAnalyses::AllAnalysesType>();
    mlir::detail::TypeIDResolver<mlir::detail::PreservedAnalyses::AllAnalysesType,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::RecoveryReproducerContext::enable()
{
  {
    llvm::sys::AddSignalHandler(mlir::detail::RecoveryReproducerContext::crashHandler, 0, v0);
  }
}

void anonymous namespace::PassTiming::runBeforePass()
{
  {
    v0 = llvm::getTypeName<mlir::detail::OpToOpPassAdaptor>();
    mlir::detail::TypeIDResolver<mlir::detail::OpToOpPassAdaptor,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

BOOL mlir::pdl::AttributeOp::verify(mlir::pdl::AttributeOp *this)
{
  v74 = *MEMORY[0x1E69E9840];
  v2 = *this;
  v3 = *(*this + 44);
  v4 = (v3 & 0x800000) == 0 || !*(v2 + 68) || *(*(v2 + 72) + 24) == 0;
  if (*(v2 + 16 * ((v3 >> 23) & 1) + 64))
  {
    if (v4)
    {
      return 1;
    }

    OUTLINED_FUNCTION_60_0();
    mlir::OpState::emitOpError(this, v8, v9);
    v10 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v49);
    v5 = v10;
    if (v49)
    {
      mlir::InFlightDiagnostic::report(&v49);
    }

    if (v73 != 1)
    {
      return v5;
    }

    v18 = OUTLINED_FUNCTION_134(v10, v11, v12, v13, v14, v15, v16, v17, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, __p, v67, v68, v69, v70, v71, v72);
    if (!v19)
    {
      free(v18);
    }

    v20 = v69;
    if (v69)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v19)
      {
        do
        {
          v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v21 - 1);
        }

        while (v21 != v20);
        v22 = v69;
      }

      v70 = v20;
      operator delete(v22);
    }

    v23 = __p;
    if (!__p)
    {
LABEL_45:
      OUTLINED_FUNCTION_92_2();
      if (!v19)
      {
        free(v43);
      }

      return v5;
    }

    v24 = v67;
    v25 = OUTLINED_FUNCTION_16_5();
    if (v19)
    {
LABEL_44:
      v67 = v23;
      operator delete(v25);
      goto LABEL_45;
    }

    do
    {
      v26 = OUTLINED_FUNCTION_17_5();
      if (v26)
      {
        operator delete[](v26);
      }
    }

    while (v24 != v23);
LABEL_43:
    v25 = __p;
    goto LABEL_44;
  }

  if (*(*(mlir::Block::getParentOp(*(v2 + 16)) + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::pdl::RewriteOp,void>::id)
  {
    OUTLINED_FUNCTION_60_0();
    mlir::OpState::emitOpError(this, v27, v28);
    v29 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v49);
    v5 = v29;
    if (v49)
    {
      mlir::InFlightDiagnostic::report(&v49);
    }

    if (v73 != 1)
    {
      return v5;
    }

    v37 = OUTLINED_FUNCTION_134(v29, v30, v31, v32, v33, v34, v35, v36, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, __p, v67, v68, v69, v70, v71, v72);
    if (!v19)
    {
      free(v37);
    }

    v38 = v69;
    if (v69)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v19)
      {
        do
        {
          v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v39 - 1);
        }

        while (v39 != v38);
        v40 = v69;
      }

      v70 = v38;
      operator delete(v40);
    }

    v23 = __p;
    if (!__p)
    {
      goto LABEL_45;
    }

    v41 = v67;
    v25 = OUTLINED_FUNCTION_16_5();
    if (v19)
    {
      goto LABEL_44;
    }

    do
    {
      v42 = OUTLINED_FUNCTION_17_5();
      if (v42)
      {
        operator delete[](v42);
      }
    }

    while (v41 != v23);
    goto LABEL_43;
  }

  v6 = *this;

  return verifyHasBindingUse(v6);
}

BOOL mlir::pdl::RangeOp::verify(mlir::pdl::RangeOp *this)
{
  v54 = *MEMORY[0x1E69E9840];
  v41 = *(*this - 8) & 0xFFFFFFFFFFFFFFF8;
  Value = mlir::AffineMapAttr::getValue(&v41);
  v3 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v4 = *(v3 + 72);
    v5 = *(v3 + 68);
  }

  else
  {
    v4 = 0;
    v5 = 0;
  }

  v41 = v4;
  v42 = v5;
  mlir::OperandRange::getTypes(&v41, &v34);
  v6 = v37 - v35;
  if (v37 == v35)
  {
    return 1;
  }

  for (i = v34 + 32 * v35 + 24; ; i += 32)
  {
    RangeElementTypeOrSelf = mlir::pdl::getRangeElementTypeOrSelf((*(*i + 8) & 0xFFFFFFFFFFFFFFF8));
    if (RangeElementTypeOrSelf != Value)
    {
      break;
    }

    if (!--v6)
    {
      return 1;
    }
  }

  v11 = RangeElementTypeOrSelf;
  v29 = "expected operand to have element type ";
  LOWORD(v33) = 259;
  mlir::OpState::emitOpError(this, &v29, &v41);
  if (v41)
  {
    mlir::DiagnosticArgument::DiagnosticArgument(&v38, Value);
    v12 = v44;
    if (v45 >= v46)
    {
      OUTLINED_FUNCTION_88_1();
      OUTLINED_FUNCTION_46_1();
      v12 = v44;
    }

    OUTLINED_FUNCTION_54_2(v12, v27, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45);
    v14 = v13 + 1;
    v45 = v14;
    if (v41)
    {
      LODWORD(v38) = 3;
      v39 = ", but got ";
      v40 = 10;
      v15 = v44;
      if (v14 >= v46)
      {
        OUTLINED_FUNCTION_13_4();
        OUTLINED_FUNCTION_99_2(v26);
        v15 = v44;
      }

      OUTLINED_FUNCTION_50_3(&v15[24 * v45++]);
      if (v41)
      {
        mlir::DiagnosticArgument::DiagnosticArgument(&v38, v11);
        v16 = v44;
        if (v45 >= v46)
        {
          OUTLINED_FUNCTION_88_1();
          OUTLINED_FUNCTION_46_1();
          v16 = v44;
        }

        OUTLINED_FUNCTION_54_2(v16, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45);
        v45 = v17 + 1;
      }
    }
  }

  v9 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v41);
  if (v41)
  {
    mlir::InFlightDiagnostic::report(&v41);
  }

  if (v53)
  {
    if (v52 != &v53)
    {
      free(v52);
    }

    v18 = __p;
    if (__p)
    {
      v19 = v51;
      v20 = __p;
      if (v51 != __p)
      {
        do
        {
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v19 - 1);
        }

        while (v19 != v18);
        v20 = __p;
      }

      v51 = v18;
      operator delete(v20);
    }

    v21 = v48;
    if (v48)
    {
      v22 = v49;
      v23 = v48;
      if (v49 != v48)
      {
        do
        {
          v25 = *--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
          {
            operator delete[](v24);
          }
        }

        while (v22 != v21);
        v23 = v48;
      }

      v49 = v21;
      operator delete(v23);
    }

    if (v44 != &v47)
    {
      free(v44);
    }
  }

  return v9;
}

BOOL mlir::pdl::ReplaceOp::verify(mlir::pdl::ReplaceOp *this)
{
  v51 = *MEMORY[0x1E69E9840];
  v1 = *(*this + 44);
  v2 = *this + 16 * ((v1 >> 23) & 1);
  v4 = *(v2 + 64);
  v5 = *(v2 + 68);
  v3 = v2 + 64;
  if ((v1 & 0x800000) == 0)
  {
    v6 = 0;
    if (v5)
    {
      goto LABEL_3;
    }

    return 1;
  }

  v6 = *(*this + 72);
  if (!v5)
  {
    return 1;
  }

LABEL_3:
  if (!*(v6 + 32 * v4 + 24) || !*(v3 + 8))
  {
    return 1;
  }

  LOWORD(v38) = 257;
  mlir::OpState::emitOpError(this, &v34, v42);
  if (v42[0])
  {
    LODWORD(v39) = 3;
    v40 = "expected no replacement values to be provided when the replacement operation is present";
    v41 = 87;
    OUTLINED_FUNCTION_19_3();
    if (v8 >= v9)
    {
      OUTLINED_FUNCTION_5_3();
      if (v31 <= v32 && (v30 & 1) != 0)
      {
        OUTLINED_FUNCTION_79_2(v22, v23, v24, v25, v26, v27, v28, v29, v33, v34, v35, v36, v37, v38);
        v7 = v43;
      }

      else
      {
        OUTLINED_FUNCTION_79_2(v22, v23, v24, v25, v26, v27, v28, v29, v33, v34, v35, v36, v37, v38);
        OUTLINED_FUNCTION_19_3();
      }
    }

    OUTLINED_FUNCTION_59_2(v7, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42[0], v42[1], v42[2], v43, v44);
    v44 = v10 + 1;
  }

  v11 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v42);
  if (v42[0])
  {
    mlir::InFlightDiagnostic::report(v42);
  }

  if (v50 == 1)
  {
    if (v49 != &v50)
    {
      free(v49);
    }

    v12 = v47;
    if (v47)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v15)
      {
        do
        {
          v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v13 - 1);
        }

        while (v13 != v12);
        v14 = v47;
      }

      v48 = v12;
      operator delete(v14);
    }

    v16 = __p;
    if (__p)
    {
      v17 = v46;
      v18 = OUTLINED_FUNCTION_16_5();
      if (!v15)
      {
        do
        {
          v19 = OUTLINED_FUNCTION_17_5();
          if (v19)
          {
            operator delete[](v19);
          }
        }

        while (v17 != v16);
        v18 = __p;
      }

      v46 = v16;
      operator delete(v18);
    }

    OUTLINED_FUNCTION_92_2();
    if (!v15)
    {
      free(v20);
    }
  }

  return v11;
}

void mlir::pdl::AttributeOp::print(mlir::pdl::AttributeOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v30 = *MEMORY[0x1E69E9840];
  v5 = *v4;
  v6 = *(v5 + 44);
  if ((v6 & 0x800000) != 0 && *(v5 + 68) && *(*(v5 + 72) + 24))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v9)
    {
      llvm::raw_ostream::write(v7, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v7, v8);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v12)
    {
      llvm::raw_ostream::write(v10, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_6_11(v10, v11);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v9)
    {
      llvm::raw_ostream::write(v13, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v13, v14);
    }

    v5 = *v3;
    v6 = *(*v3 + 44);
    if ((v6 & 0x800000) != 0 && *(v5 + 68) && *(*(v5 + 72) + 24))
    {
      (*(*v2 + 160))(v2);
      v5 = *v3;
      v6 = *(*v3 + 44);
    }
  }

  if (*(v5 + 16 * ((v6 >> 23) & 1) + 64))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v9)
    {
      llvm::raw_ostream::write(v15, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v15, v16);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v12)
    {
      llvm::raw_ostream::write(v17, "=", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v17, v18);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v9)
    {
      llvm::raw_ostream::write(v19, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v19, v20);
    }

    OUTLINED_FUNCTION_19_5();
    OUTLINED_FUNCTION_104();
    (*(v21 + 40))(v2);
  }

  OUTLINED_FUNCTION_67_1();
  v28 = "value";
  v29 = 5;
  v27 = 0x200000001;
  AttrDictionary = mlir::Operation::getAttrDictionary(v22);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_104();
  v23 = OUTLINED_FUNCTION_31_3();
  v24(v23);
  if (v26 != v3)
  {
    free(v26);
  }
}

void mlir::pdl::OperandOp::print(mlir::pdl::OperandOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v21 = *MEMORY[0x1E69E9840];
  v5 = *v4;
  if ((*(v5 + 46) & 0x80) != 0 && *(v5 + 68) && *(*(v5 + 72) + 24))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v8)
    {
      llvm::raw_ostream::write(v6, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v6, v7);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v11)
    {
      llvm::raw_ostream::write(v9, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_6_11(v9, v10);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v8)
    {
      llvm::raw_ostream::write(v12, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v12, v13);
    }

    v14 = *v3;
    if ((*(*v3 + 46) & 0x80) != 0 && *(v14 + 68) && *(*(v14 + 72) + 24))
    {
      (*(*v2 + 160))(v2);
    }
  }

  OUTLINED_FUNCTION_67_1();
  v20 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(v15);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_104();
  v16 = OUTLINED_FUNCTION_31_3();
  v17(v16);
  if (v19 != v3)
  {
    free(v19);
  }
}

void mlir::pdl::OperationOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v158 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_42_3();
  if (*(v4 + 16 * v5 + 72))
  {
    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v8)
    {
      llvm::raw_ostream::write(v6, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v6, v7);
    }

    OUTLINED_FUNCTION_42_3();
    OUTLINED_FUNCTION_104();
    (*(v9 + 48))(a2);
    OUTLINED_FUNCTION_42_3();
  }

  if (*(v4 + 16 * v5 + 80))
  {
    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v12)
    {
      llvm::raw_ostream::write(v10, "(", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v10, v11);
    }

    v13 = *(*this + 11);
    v14 = *(*this + 4 * ((v13 >> 23) & 1) + 20);
    if ((v13 & 0x800000) != 0)
    {
      v15 = *(*this + 9);
    }

    else
    {
      v15 = 0;
    }

    (*(*a2 + 16))(a2);
    if (v14)
    {
      OUTLINED_FUNCTION_104();
      (*(v16 + 160))(a2);
      if (v14 != 1)
      {
        v17 = v14 - 1;
        v18 = v15 + 56;
        do
        {
          OUTLINED_FUNCTION_30_2();
          if (!v12 & v8)
          {
            OUTLINED_FUNCTION_21_5(v19);
          }

          else
          {
            v20 = OUTLINED_FUNCTION_38_4();
            llvm::raw_ostream::write(v20, v21, 2uLL);
          }

          v18 += 32;
          OUTLINED_FUNCTION_104();
          (*(v22 + 160))(a2);
          --v17;
        }

        while (v17);
      }
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v8)
    {
      llvm::raw_ostream::write(v23, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v23, v24);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v12)
    {
      llvm::raw_ostream::write(v25, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_6_11(v25, v26);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v8)
    {
      llvm::raw_ostream::write(v27, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v27, v28);
    }

    OUTLINED_FUNCTION_36_3();
    if ((v38 & 0x800000) != 0)
    {
      v39 = *(v37 + 72);
    }

    else
    {
      LOBYTE(v39) = 0;
    }

    v40 = OUTLINED_FUNCTION_51_2(v29, v30, v31, v32, v33, v34, v35, v36, v150, v39);
    mlir::OperandRange::getTypes(v40, v41);
    if (v153 != v155)
    {
      OUTLINED_FUNCTION_29_4();
      v42 = OUTLINED_FUNCTION_12_4();
      v43(v42);
      if (v153 + 1 != v155)
      {
        v44 = ~v153 + v155;
        v45 = v152 + 32 * v153 + 56;
        do
        {
          (*(*a2 + 16))(a2);
          OUTLINED_FUNCTION_25_2();
          if (!v12 & v8)
          {
            OUTLINED_FUNCTION_11_10(v46, v47);
          }

          else
          {
            OUTLINED_FUNCTION_78_2(v46);
          }

          v45 += 32;
          OUTLINED_FUNCTION_29_4();
          v48 = OUTLINED_FUNCTION_12_4();
          v49(v48);
          --v44;
        }

        while (v44);
      }
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v12)
    {
      llvm::raw_ostream::write(v50, ")", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v50, v51);
    }
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v52, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v52, v53);
  }

  OUTLINED_FUNCTION_36_3();
  v152 = *(v54 + 64);
  mlir::ArrayAttr::getValue(&v152);
  if (v55)
  {
    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_25_2();
    v150 = this;
    if (!v12 & v8)
    {
      *v57 = 31520;
      OUTLINED_FUNCTION_24_2(v56);
    }

    else
    {
      llvm::raw_ostream::write(v56, " {", 2uLL);
    }

    mlir::ArrayAttr::getValue(&v152);
    v59 = v58 << 32;
    if (v58 << 32)
    {
      v60 = v58;
      mlir::ArrayAttr::getValue(&v152);
      OUTLINED_FUNCTION_41_4();
      (*(v61 + 40))(a2);
      OUTLINED_FUNCTION_41_4();
      (*(v62 + 16))(a2);
      OUTLINED_FUNCTION_72_0();
      if (v65 > 2)
      {
        *(v64 + 2) = 32;
        *v64 = 15648;
        v63[4] += 3;
      }

      else
      {
        llvm::raw_ostream::write(v63, " = ", 3uLL);
      }

      OUTLINED_FUNCTION_41_4();
      (*(v66 + 160))(a2);
      if (v59 != 0x100000000)
      {
        v67 = 1;
        v68 = 0x100000000;
        do
        {
          (*(*a2 + 16))(a2);
          OUTLINED_FUNCTION_25_2();
          if (!v12 & v8)
          {
            *v70 = 8236;
            OUTLINED_FUNCTION_24_2(v69);
          }

          else
          {
            llvm::raw_ostream::write(v69, ", ", 2uLL);
          }

          mlir::ArrayAttr::getValue(&v152);
          OUTLINED_FUNCTION_41_4();
          (*(v71 + 40))(a2);
          OUTLINED_FUNCTION_41_4();
          (*(v72 + 16))(a2);
          OUTLINED_FUNCTION_72_0();
          if (v75 > 2)
          {
            *(v74 + 2) = 32;
            *v74 = 15648;
            v73[4] += 3;
          }

          else
          {
            llvm::raw_ostream::write(v73, " = ", 3uLL);
          }

          OUTLINED_FUNCTION_41_4();
          (*(v76 + 160))(a2);
          ++v67;
          v68 += 0x100000000;
        }

        while (v60 != v67);
      }
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v8)
    {
      llvm::raw_ostream::write(v77, 125);
    }

    else
    {
      *(v77 + 4) = v78 + 1;
      *v78 = 125;
    }
  }

  OUTLINED_FUNCTION_42_3();
  if (*(v79 + 16 * v80 + 88))
  {
    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v8)
    {
      llvm::raw_ostream::write(v81, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v81, v82);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_25_2();
    if (!v12 & v8)
    {
      *v84 = 15917;
      OUTLINED_FUNCTION_24_2(v83);
    }

    else
    {
      llvm::raw_ostream::write(v83, "->", 2uLL);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v8)
    {
      llvm::raw_ostream::write(v85, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v85, v86);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v12)
    {
      llvm::raw_ostream::write(v87, "(", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v87, v88);
    }

    OUTLINED_FUNCTION_36_3();
    v91 = v89[22];
    if ((v92 & 0x800000) != 0)
    {
      v93 = *(v90 + 72);
    }

    else
    {
      v93 = 0;
    }

    v94 = v89[20];
    v95 = v89[21];
    OUTLINED_FUNCTION_41_4();
    (*(v96 + 16))(a2);
    if (v91)
    {
      v97 = (v95 + v94);
      v98 = (v91 + v97);
      v99 = v93 + 32 * v97;
      OUTLINED_FUNCTION_41_4();
      (*(v100 + 160))(a2);
      if (v98 - v97 != 1)
      {
        v101 = ~v97 + v98;
        v102 = v99 + 56;
        do
        {
          OUTLINED_FUNCTION_30_2();
          if (!v12 & v8)
          {
            OUTLINED_FUNCTION_21_5(v103);
          }

          else
          {
            v104 = OUTLINED_FUNCTION_38_4();
            llvm::raw_ostream::write(v104, v105, 2uLL);
          }

          v102 += 32;
          OUTLINED_FUNCTION_41_4();
          (*(v106 + 160))(a2);
          --v101;
        }

        while (v101);
      }
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v8)
    {
      llvm::raw_ostream::write(v107, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v107, v108);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v12)
    {
      llvm::raw_ostream::write(v109, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_6_11(v109, v110);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v8)
    {
      v113 = llvm::raw_ostream::write(v111, 32);
    }

    else
    {
      v113 = OUTLINED_FUNCTION_5_2(v111, v112);
    }

    v121 = *(*this + 11);
    if ((v121 & 0x800000) != 0)
    {
      v123 = *(*this + 9);
    }

    else
    {
      LOBYTE(v123) = 0;
    }

    v122 = *this + 16 * ((v121 >> 23) & 1);
    v124 = OUTLINED_FUNCTION_51_2(v113, v114, v115, v116, v117, v118, v119, v120, v150, v123 + 32 * (*(v122 + 84) + *(v122 + 80)));
    mlir::OperandRange::getTypes(v124, v125);
    v126 = v153;
    v127 = v155;
    if (v153 != v155)
    {
      v128 = v152 + 32 * v153;
      OUTLINED_FUNCTION_41_4();
      v129 = OUTLINED_FUNCTION_12_4();
      v130(v129);
      if (v126 + 1 != v127)
      {
        v131 = ~v126 + v127;
        v132 = v128 + 56;
        do
        {
          (*(*a2 + 16))(a2);
          OUTLINED_FUNCTION_25_2();
          if (!v12 & v8)
          {
            OUTLINED_FUNCTION_11_10(v133, v134);
          }

          else
          {
            OUTLINED_FUNCTION_78_2(v133);
          }

          v132 += 32;
          OUTLINED_FUNCTION_41_4();
          v135 = OUTLINED_FUNCTION_12_4();
          v136(v135);
          --v131;
        }

        while (v131);
      }
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v12)
    {
      llvm::raw_ostream::write(v137, ")", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v137, v138);
    }
  }

  v152 = &v154;
  v154 = "operandSegmentSizes";
  v155 = 19;
  v156 = "opName";
  v157 = 6;
  v153 = 0x200000002;
  llvm::SmallVectorBase<unsigned int>::grow_pod(&v152, &v154, 3uLL, 16);
  v139 = v152 + 16 * v153;
  *v139 = "attributeValueNames";
  v139[1] = 19;
  LODWORD(v153) = v153 + 1;
  AttrDictionary = mlir::Operation::getAttrDictionary(*this);
  OUTLINED_FUNCTION_81_2(AttrDictionary, v141, v142, v143, v144, v145, v146, v147, v150, v151);
  OUTLINED_FUNCTION_9_9();
  v148 = OUTLINED_FUNCTION_31_3();
  v149(v148);
  if (v152 != &v154)
  {
    free(v152);
  }
}

void mlir::pdl::RangeOp::print(mlir::pdl::RangeOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v63 = *MEMORY[0x1E69E9840];
  if ((*(*v4 + 46) & 0x80) != 0 && *(*v4 + 68))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v7)
    {
      llvm::raw_ostream::write(v5, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v5, v6);
    }

    OUTLINED_FUNCTION_47_0();
    if (v9 < 0)
    {
      v10 = *(v8 + 68);
      v11 = *(v8 + 72);
    }

    else
    {
      v11 = 0;
      v10 = 0;
    }

    (*(*v2 + 16))(v2);
    if (v10)
    {
      OUTLINED_FUNCTION_104();
      (*(v12 + 160))(v2);
      if (--v10)
      {
        v13 = v11 + 56;
        v11 = ", ";
        do
        {
          OUTLINED_FUNCTION_30_2();
          if (!v15 & v7)
          {
            OUTLINED_FUNCTION_21_5(v14);
          }

          else
          {
            v16 = OUTLINED_FUNCTION_38_4();
            llvm::raw_ostream::write(v16, v17, 2uLL);
          }

          v13 += 32;
          OUTLINED_FUNCTION_104();
          (*(v18 + 160))(v2);
          --v10;
        }

        while (v10);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v7)
    {
      llvm::raw_ostream::write(v19, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v19, v20);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v15)
    {
      llvm::raw_ostream::write(v21, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_6_11(v21, v22);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v7)
    {
      llvm::raw_ostream::write(v23, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v23, v24);
    }

    OUTLINED_FUNCTION_90_2();
    if (v25 < 0)
    {
      OUTLINED_FUNCTION_89_2();
    }

    else
    {
      OUTLINED_FUNCTION_84_2();
    }

    AttrDictionary = v27;
    v62 = v26;
    mlir::OperandRange::getTypes(&AttrDictionary, &v57);
    OUTLINED_FUNCTION_35_4();
    if (!v15)
    {
      OUTLINED_FUNCTION_10_12();
      v28 = OUTLINED_FUNCTION_12_4();
      v29(v28);
      OUTLINED_FUNCTION_76_2();
      if (!v15)
      {
        OUTLINED_FUNCTION_34_6();
        do
        {
          (*(*v2 + 16))(v2);
          OUTLINED_FUNCTION_25_2();
          if (!v15 & v7)
          {
            OUTLINED_FUNCTION_11_10(v30, v31);
          }

          else
          {
            OUTLINED_FUNCTION_78_2(v30);
          }

          v10 += 32;
          OUTLINED_FUNCTION_29_4();
          v32 = OUTLINED_FUNCTION_12_4();
          v33(v32);
          --v11;
        }

        while (v11);
      }
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v34, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v34, v35);
  }

  OUTLINED_FUNCTION_90_2();
  if (v36 < 0)
  {
    OUTLINED_FUNCTION_89_2();
  }

  else
  {
    OUTLINED_FUNCTION_84_2();
  }

  v46 = OUTLINED_FUNCTION_51_2(v37, v38, v39, v40, v41, v42, v43, v44, v56, v45);
  mlir::OperandRange::getTypes(v46, v47);
  mlir::ValueRange::ValueRange(&AttrDictionary, v57 + 32 * v58, v59[1] - v58);
  mlir::TypeRange::TypeRange(v60, AttrDictionary, v62);
  if (*(*v3 + 9))
  {
    v48 = *v3 - 16;
  }

  else
  {
    v48 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v48, 0);
  if (!v60[1])
  {
    v50 = *(NextResultAtOffset + 8);
    OUTLINED_FUNCTION_104();
    (*(v51 + 16))(v2);
    OUTLINED_FUNCTION_25_2();
    if (!v15 & v7)
    {
      *v53 = 8250;
      OUTLINED_FUNCTION_24_2(v52);
    }

    else
    {
      llvm::raw_ostream::write(v52, ": ", 2uLL);
    }

    (*(*v2 + 32))(v2, v50 & 0xFFFFFFFFFFFFFFF8);
  }

  v57 = v59;
  v58 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_9_9();
  v54 = OUTLINED_FUNCTION_31_3();
  v55(v54);
  if (v57 != v59)
  {
    free(v57);
  }
}

BOOL mlir::pdl::ReplaceOp::verifyInvariantsImpl(mlir::pdl::ReplaceOp *this)
{
  v82 = *MEMORY[0x1E69E9840];
  v2 = *this;
  v3 = *(*this + 44);
  v4 = (v3 >> 23) & 1;
  v5 = *(*this + 16 * v4 + 64);
  if ((v3 & 0x800000) != 0)
  {
    v6 = *(v2 + 72);
    if (v5)
    {
      goto LABEL_3;
    }
  }

  else
  {
    v6 = 0;
    if (v5)
    {
LABEL_3:
      v7 = 0;
      v8 = v6 + 24;
      while (1)
      {
        v9 = OUTLINED_FUNCTION_49_3();
        if ((mlir::pdl::__mlir_ods_local_type_constraint_PDLOps4(v9, v10, "operand", 7, v7) & 1) == 0)
        {
          return 0;
        }

        ++v7;
        v8 += 32;
        if (v5 == v7)
        {
          v2 = *this;
          v3 = *(*this + 44);
          v4 = (v3 >> 23) & 1;
          break;
        }
      }
    }
  }

  v11 = v3 & 0x800000;
  v12 = v2 + 16 * v4;
  v13 = *(v12 + 64);
  v14 = *(v12 + 68);
  if (v11)
  {
    v15 = *(v2 + 72);
  }

  else
  {
    v15 = 0;
  }

  v16 = ((v14 + v13) - v13);
  if (v16 <= 1)
  {
    if (v14)
    {
      v35 = v15 + 32 * v13 + 24;
      while (1)
      {
        v36 = OUTLINED_FUNCTION_49_3();
        if ((mlir::pdl::__mlir_ods_local_type_constraint_PDLOps4(v36, v37, "operand", 7, v5) & 1) == 0)
        {
          return 0;
        }

        LODWORD(v5) = v5 + 1;
        v35 += 32;
        if (!--v16)
        {
          v2 = *this;
          v38 = *(*this + 44);
          v4 = (v38 >> 23) & 1;
          v11 = v38 & 0x800000;
          break;
        }
      }
    }

    v39 = (v2 + 16 * v4);
    v40 = v39[18];
    if (v11)
    {
      v41 = *(v2 + 72);
      if (v40)
      {
        goto LABEL_45;
      }
    }

    else
    {
      v41 = 0;
      if (v40)
      {
LABEL_45:
        v42 = (v39[17] + v39[16]);
        v43 = (v40 + v42) - v42;
        for (i = v41 + 32 * v42 + 24; ; i += 32)
        {
          v45 = OUTLINED_FUNCTION_49_3();
          if ((mlir::pdl::__mlir_ods_local_type_constraint_PDLOps8(v45, v46, "operand", 7, v5) & 1) == 0)
          {
            break;
          }

          LODWORD(v5) = v5 + 1;
          if (!--v43)
          {
            return 1;
          }
        }

        return 0;
      }
    }

    return 1;
  }

  v63 = "operand group starting at #";
  LOWORD(v67) = 259;
  mlir::OpState::emitOpError(this, &v63, &v71);
  if (v71)
  {
    LODWORD(v68) = 5;
    v69 = v5;
    OUTLINED_FUNCTION_19_3();
    if (v18 >= v19)
    {
      OUTLINED_FUNCTION_5_3();
      if (v49 <= v50 && (v48 & 1) != 0)
      {
        v58 = OUTLINED_FUNCTION_47_3();
        llvm::SmallVectorBase<unsigned int>::grow_pod(v58, v60, v59 + 1, 24);
        v17 = v74;
      }

      else
      {
        v51 = OUTLINED_FUNCTION_47_3();
        llvm::SmallVectorBase<unsigned int>::grow_pod(v51, v53, v52 + 1, 24);
        OUTLINED_FUNCTION_19_3();
      }
    }

    OUTLINED_FUNCTION_59_2(v17, v61, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75);
    v21 = v20 + 1;
    LODWORD(v75) = v21;
    if (v71)
    {
      LODWORD(v68) = 3;
      v69 = " requires 0 or 1 element, but found ";
      v70 = 36;
      v22 = v74;
      if (v21 >= HIDWORD(v75))
      {
        OUTLINED_FUNCTION_13_4();
        OUTLINED_FUNCTION_5_5(v54, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75);
        v22 = v74;
      }

      OUTLINED_FUNCTION_50_3((v22 + 24 * v75));
      v23 = v75 + 1;
      LODWORD(v75) = v75 + 1;
      if (v71)
      {
        LODWORD(v68) = 5;
        v69 = v16;
        v24 = v74;
        if (v23 >= HIDWORD(v75))
        {
          v55 = OUTLINED_FUNCTION_47_3();
          llvm::SmallVectorBase<unsigned int>::grow_pod(v55, v57, v56 + 1, 24);
          v24 = v74;
        }

        OUTLINED_FUNCTION_50_3((v24 + 24 * v75));
        LODWORD(v75) = v75 + 1;
      }
    }
  }

  v25 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v71);
  if (v71)
  {
    mlir::InFlightDiagnostic::report(&v71);
  }

  if (v81 == 1)
  {
    if (v80 != &v81)
    {
      free(v80);
    }

    v26 = v78;
    if (v78)
    {
      OUTLINED_FUNCTION_15_5();
      if (!v29)
      {
        do
        {
          v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v27 - 1);
        }

        while (v27 != v26);
        v28 = v78;
      }

      v79 = v26;
      operator delete(v28);
    }

    v30 = __p;
    if (__p)
    {
      v31 = v77;
      v32 = OUTLINED_FUNCTION_16_5();
      if (!v29)
      {
        do
        {
          v33 = OUTLINED_FUNCTION_17_5();
          if (v33)
          {
            operator delete[](v33);
          }
        }

        while (v31 != v30);
        v32 = __p;
      }

      v77 = v30;
      operator delete(v32);
    }

    OUTLINED_FUNCTION_92_2();
    if (!v29)
    {
      free(v34);
    }
  }

  return v25;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl::ApplyNativeConstraintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::pdl::PatternOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::pdl::ApplyNativeConstraintOp::print(&v8, a3);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl::ApplyNativeRewriteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::pdl::RewriteOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::pdl::ApplyNativeRewriteOp::print(&v8, a3);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl::AttributeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::AttributeType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::pdl::AttributeOp::print(&v7, a3);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl::OperandOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::ValueType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::pdl::PatternOp>::Impl,mlir::OpTrait::OpInvariants>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::pdl::OperandOp::print(&v7, a3);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl::OperandsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::RangeType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::pdl::PatternOp>::Impl,mlir::OpTrait::OpInvariants>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::pdl::OperandOp::print(&v7, a3);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl::OperationOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::OperationType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::pdl::OperationOp::print(&v7, a3);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl::RangeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::RangeType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::pdl::RewriteOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::pdl::RangeOp::print(&v7, a3);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl::ReplaceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::HasParent<mlir::pdl::RewriteOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::pdl::ReplaceOp::print(&v8, a3);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl::RewriteOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::pdl::PatternOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::SingleBlock,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::pdl::RewriteOp::print(&v8, a3);
}

void mlir::pdl::ApplyNativeConstraintOp::verify(uint64_t a1, _BYTE *a2)
{
  v39 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_60_0();
  mlir::OpState::emitOpError(v3, v4, v5);
  v6 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v30);
  *a2 = v6;
  if (v30[0])
  {
    mlir::InFlightDiagnostic::report(v30);
  }

  if (v38 == 1)
  {
    v14 = OUTLINED_FUNCTION_134(v6, v7, v8, v9, v10, v11, v12, v13, v25, v26, v27, v28, v29, v30[0], v30[1], v30[2], v30[3], v30[4], v30[5], v30[6], v30[7], v30[8], v30[9], v30[10], v30[11], v30[12], v30[13], v30[14], v30[15], v30[16], v31, v32, v33, __p, v35, v36, v37);
    if (!v15)
    {
      free(v14);
    }

    v16 = __p;
    if (__p)
    {
      v17 = v35;
      v18 = __p;
      if (v35 != __p)
      {
        do
        {
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v17 - 1);
        }

        while (v17 != v16);
        v18 = __p;
      }

      v35 = v16;
      operator delete(v18);
    }

    v19 = v31;
    if (v31)
    {
      v20 = v32;
      v21 = v31;
      if (v32 != v31)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
          {
            operator delete[](v22);
          }
        }

        while (v20 != v19);
        v21 = v31;
      }

      v32 = v19;
      operator delete(v21);
    }

    OUTLINED_FUNCTION_92_2();
    if (!v15)
    {
      free(v24);
    }
  }
}

void mlir::pdl::OperationOp::verify()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_77_2(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t visit(uint64_t result, uint64_t a2)
{
  v3 = *(result + 44);
  v4 = *(result + 16 * ((v3 >> 23) & 1) + 80);
  if ((v3 & 0x800000) != 0)
  {
    v5 = *(result + 72);
    if (!v4)
    {
      return result;
    }
  }

  else
  {
    v5 = 0;
    if (!v4)
    {
      return result;
    }
  }

  v6 = (v5 + 24);
  do
  {
    v7 = *v6;
    v6 += 4;
    v9 = v7;
    DefiningOp = mlir::Value::getDefiningOp(&v9);
    result = visit(DefiningOp, a2);
    --v4;
  }

  while (v4);
  return result;
}

void mlir::pdl::ApplyNativeConstraintOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl::detail::ApplyNativeConstraintOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_61_1(v2);
  }
}

void mlir::pdl::ApplyNativeConstraintOp::verifyInvariantsImpl()
{
  OUTLINED_FUNCTION_75_2();
  if (v1)
  {
    while (1)
    {
      v2 = OUTLINED_FUNCTION_38_4();
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, v3);
      if ((OUTLINED_FUNCTION_62_1(NextResultAtOffset) & 1) == 0)
      {
        break;
      }

      OUTLINED_FUNCTION_85_2();
      if (v5)
      {
        goto LABEL_5;
      }
    }

    v6 = 0;
  }

  else
  {
LABEL_5:
    v6 = 1;
  }

  *v0 = v6;
}

void mlir::pdl::ApplyNativeRewriteOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl::detail::ApplyNativeRewriteOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_74_1(v2);
  }
}

void mlir::pdl::AttributeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl::detail::AttributeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_73_1(v2);
  }
}

uint64_t mlir::pdl::OperandOp::verifyInvariantsImpl(uint64_t a1, uint64_t *a2, _BYTE *a3)
{
  if (*(a1 + 36))
  {
    v5 = a1 - 16;
  }

  else
  {
    v5 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  result = mlir::pdl::__mlir_ods_local_type_constraint_PDLOps5(*a2, *(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, "result", 6, 0);
  *a3 = result & 1;
  return result;
}

void mlir::pdl::OperationOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl::detail::OperationOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_45_0(v2);
  }
}

void mlir::pdl::PatternOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl::detail::PatternOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_40_2(v2);
  }
}

void mlir::pdl::ReplaceOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl::detail::ReplaceOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_72_1(v2);
  }
}

void mlir::pdl::ResultOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl::detail::ResultOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_60_2(v2);
  }
}

void mlir::pdl::ResultsOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl::detail::ResultsOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_71_1(v2);
  }
}

void mlir::pdl::RewriteOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl::detail::RewriteOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_53_2(v2);
  }
}

void mlir::pdl::TypeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl::detail::TypeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_70_2(v2);
  }
}

void mlir::pdl::TypesOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl::detail::TypesOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_68_1(v2);
  }
}

void mlir::RegisteredOperationName::Model<mlir::pdl::ApplyNativeConstraintOp>::Model()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_44_2(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::pdl::PatternOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::pdl::PatternOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::pdl::PatternOp>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_83_2(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_43_4(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::pdl::RewriteOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::pdl::RewriteOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::pdl::RewriteOp>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_82_2(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::AttributeType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_48_2(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::pdl::AttributeType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::pdl::AttributeType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::pdl::AttributeType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::pdl::AttributeType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::pdl::RewriteOp>::Impl,mlir::OpTrait::OpInvariants>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_77_2(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::ValueType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::pdl::PatternOp>::Impl,mlir::OpTrait::OpInvariants>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::pdl::ValueType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::pdl::ValueType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::pdl::ValueType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::pdl::ValueType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::RangeType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::pdl::PatternOp>::Impl,mlir::OpTrait::OpInvariants>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::pdl::RangeType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::pdl::RangeType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::pdl::RangeType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::pdl::RangeType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::OperationType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::pdl::OperationType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::pdl::OperationType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::pdl::OperationType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::pdl::OperationType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::OneRegion<mlir::pdl::PatternOp>,mlir::OpTrait::ZeroResults<mlir::pdl::PatternOp>,mlir::OpTrait::ZeroSuccessors<mlir::pdl::PatternOp>,mlir::OpTrait::ZeroOperands<mlir::pdl::PatternOp>,mlir::OpTrait::SingleBlock<mlir::pdl::PatternOp>,mlir::OpTrait::OpInvariants<mlir::pdl::PatternOp>,mlir::BytecodeOpInterface::Trait<mlir::pdl::PatternOp>,mlir::OpTrait::IsIsolatedFromAbove<mlir::pdl::PatternOp>,mlir::SymbolOpInterface::Trait<mlir::pdl::PatternOp>,mlir::OpAsmOpInterface::Trait<mlir::pdl::PatternOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_44_2(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::PDLType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::pdl::PDLType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::pdl::PDLType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::pdl::PDLType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::pdl::PDLType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::TypeType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::pdl::TypeType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::pdl::TypeType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::pdl::TypeType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::pdl::TypeType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

BOOL mlir::pdl_interp::CreateRangeOp::verify(mlir::pdl_interp::CreateRangeOp *this)
{
  v57 = *MEMORY[0x1E69E9840];
  v44 = *(*this - 8) & 0xFFFFFFFFFFFFFFF8;
  Value = mlir::AffineMapAttr::getValue(&v44);
  v3 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v4 = *(v3 + 72);
    v5 = *(v3 + 68);
  }

  else
  {
    v4 = 0;
    v5 = 0;
  }

  v44 = v4;
  v45 = v5;
  mlir::OperandRange::getTypes(&v44, &v37);
  v6 = v40 - v38;
  if (v40 == v38)
  {
    return 1;
  }

  for (i = v37 + 32 * v38 + 24; ; i += 32)
  {
    RangeElementTypeOrSelf = mlir::pdl::getRangeElementTypeOrSelf((*(*i + 8) & 0xFFFFFFFFFFFFFFF8));
    if (RangeElementTypeOrSelf != Value)
    {
      break;
    }

    if (!--v6)
    {
      return 1;
    }
  }

  v11 = RangeElementTypeOrSelf;
  v32 = "expected operand to have element type ";
  LOWORD(v36) = 259;
  mlir::OpState::emitOpError(this, &v32, &v44);
  if (v44)
  {
    mlir::DiagnosticArgument::DiagnosticArgument(&v41, Value);
    v12 = v47;
    if (v48 >= v49)
    {
      OUTLINED_FUNCTION_88_1();
      OUTLINED_FUNCTION_46_1();
      v12 = v47;
    }

    OUTLINED_FUNCTION_54_2(v12, v30, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48);
    v14 = (v13 + 1);
    v48 = v14;
    if (v44)
    {
      LODWORD(v41) = 3;
      v42 = ", but got ";
      v43 = 10;
      v15 = &v41;
      v16 = v47;
      if (v14 >= v49)
      {
        if (v47 <= &v41 && v47 + 24 * v14 > &v41)
        {
          v29 = &v41 - v47;
          OUTLINED_FUNCTION_99_2(v14);
          v16 = v47;
          v15 = (v47 + v29);
        }

        else
        {
          OUTLINED_FUNCTION_99_2(v14);
          v15 = &v41;
          v16 = v47;
        }
      }

      v17 = &v16[24 * v48];
      v18 = *v15;
      *(v17 + 2) = v15[2];
      *v17 = v18;
      ++v48;
      if (v44)
      {
        mlir::DiagnosticArgument::DiagnosticArgument(&v41, v11);
        v19 = v47;
        if (v48 >= v49)
        {
          OUTLINED_FUNCTION_88_1();
          OUTLINED_FUNCTION_46_1();
          v19 = v47;
        }

        OUTLINED_FUNCTION_54_2(v19, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48);
        v48 = v20 + 1;
      }
    }
  }

  v9 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v44);
  if (v44)
  {
    mlir::InFlightDiagnostic::report(&v44);
  }

  if (v56)
  {
    if (v55 != &v56)
    {
      free(v55);
    }

    v21 = __p;
    if (__p)
    {
      v22 = v54;
      v23 = __p;
      if (v54 != __p)
      {
        do
        {
          v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v22 - 1);
        }

        while (v22 != v21);
        v23 = __p;
      }

      v54 = v21;
      operator delete(v23);
    }

    v24 = v51;
    if (v51)
    {
      v25 = v52;
      v26 = v51;
      if (v52 != v51)
      {
        do
        {
          v28 = *--v25;
          v27 = v28;
          *v25 = 0;
          if (v28)
          {
            operator delete[](v27);
          }
        }

        while (v25 != v24);
        v26 = v51;
      }

      v52 = v24;
      operator delete(v26);
    }

    if (v47 != &v50)
    {
      free(v47);
    }
  }

  return v9;
}

void mlir::pdl_interp::CreateOperationOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v173 = *MEMORY[0x1E69E9840];
  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v5, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v5, v6);
  }

  OUTLINED_FUNCTION_13_12();
  OUTLINED_FUNCTION_104();
  (*(v8 + 48))(a2);
  OUTLINED_FUNCTION_13_12();
  if (*(v9 + 88))
  {
    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v12)
    {
      llvm::raw_ostream::write(v10, "(", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v10, v11);
    }

    v13 = *(*this + 11);
    v14 = *(*this + 4 * ((v13 >> 23) & 1) + 22);
    if ((v13 & 0x800000) != 0)
    {
      v15 = *(*this + 9);
    }

    else
    {
      v15 = 0;
    }

    (*(*a2 + 16))(a2);
    if (v14)
    {
      OUTLINED_FUNCTION_17_10();
      (*(v16 + 160))(a2);
      if (v14 != 1)
      {
        v17 = v14 - 1;
        v18 = v15 + 56;
        do
        {
          OUTLINED_FUNCTION_30_2();
          if (!v12 & v7)
          {
            *v19 = 8236;
            *(v2 + 32) += 2;
          }

          else
          {
            v20 = OUTLINED_FUNCTION_38_4();
            llvm::raw_ostream::write(v20, v21, 2uLL);
          }

          v18 += 32;
          OUTLINED_FUNCTION_104();
          (*(v22 + 160))(a2);
          --v17;
        }

        while (v17);
      }
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v7)
    {
      llvm::raw_ostream::write(v23, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v23, v24);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v12)
    {
      llvm::raw_ostream::write(v25, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v25, v26);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v7)
    {
      llvm::raw_ostream::write(v27, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v27, v28);
    }

    OUTLINED_FUNCTION_36_3();
    v31 = *(v30 + 88);
    if ((v32 & 0x800000) != 0)
    {
      v33 = *(v29 + 72);
    }

    else
    {
      v33 = 0;
    }

    AttrDictionary = v33;
    v172 = v31;
    mlir::OperandRange::getTypes(&AttrDictionary, &v163);
    v34 = v164;
    v35 = v166;
    if (v164 != v166)
    {
      v36 = v163 + 32 * v164;
      OUTLINED_FUNCTION_29_4();
      v37 = OUTLINED_FUNCTION_12_4();
      v38(v37);
      if (v34 + 1 != v35)
      {
        v39 = ~v34 + v35;
        v40 = v36 + 56;
        do
        {
          (*(*a2 + 16))(a2);
          OUTLINED_FUNCTION_25_2();
          if (!v12 & v7)
          {
            *v42 = 8236;
            OUTLINED_FUNCTION_24_2(v41);
          }

          else
          {
            OUTLINED_FUNCTION_78_2(v41);
          }

          v40 += 32;
          OUTLINED_FUNCTION_29_4();
          v43 = OUTLINED_FUNCTION_12_4();
          v44(v43);
          --v39;
        }

        while (v39);
      }
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v12)
    {
      llvm::raw_ostream::write(v45, ")", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v45, v46);
    }
  }

  v163 = *(*this + 2 * ((*(*this + 11) >> 23) & 1) + 9);
  mlir::ArrayAttr::getValue(&v163);
  if (v47)
  {
    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_25_2();
    v154 = this;
    if (!v12 & v7)
    {
      *v49 = 31520;
      OUTLINED_FUNCTION_24_2(v48);
    }

    else
    {
      llvm::raw_ostream::write(v48, " {", 2uLL);
    }

    mlir::ArrayAttr::getValue(&v163);
    v51 = v50 << 32;
    if (v50 << 32)
    {
      v52 = v50;
      mlir::ArrayAttr::getValue(&v163);
      OUTLINED_FUNCTION_104();
      (*(v53 + 40))(a2);
      OUTLINED_FUNCTION_104();
      (*(v54 + 16))(a2);
      OUTLINED_FUNCTION_72_0();
      if (v57 > 2)
      {
        *(v56 + 2) = 32;
        OUTLINED_FUNCTION_15_4(v55, v56);
      }

      else
      {
        llvm::raw_ostream::write(v55, " = ", 3uLL);
      }

      OUTLINED_FUNCTION_104();
      (*(v58 + 160))(a2);
      if (v51 != 0x100000000)
      {
        v59 = v52;
        v60 = 1;
        v61 = 0x100000000;
        do
        {
          (*(*a2 + 16))(a2);
          OUTLINED_FUNCTION_25_2();
          if (!v12 & v7)
          {
            *v63 = 8236;
            OUTLINED_FUNCTION_24_2(v62);
          }

          else
          {
            llvm::raw_ostream::write(v62, ", ", 2uLL);
          }

          mlir::ArrayAttr::getValue(&v163);
          OUTLINED_FUNCTION_104();
          (*(v64 + 40))(a2);
          OUTLINED_FUNCTION_104();
          (*(v65 + 16))(a2);
          OUTLINED_FUNCTION_72_0();
          if (v68 > 2)
          {
            *(v67 + 2) = 32;
            *v67 = 15648;
            v66[4] += 3;
          }

          else
          {
            llvm::raw_ostream::write(v66, " = ", 3uLL);
          }

          OUTLINED_FUNCTION_104();
          (*(v69 + 160))(a2);
          ++v60;
          v61 += 0x100000000;
        }

        while (v59 != v60);
      }
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v7)
    {
      llvm::raw_ostream::write(v70, 125);
    }

    else
    {
      *(v70 + 4) = v71 + 1;
      *v71 = 125;
    }
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    v74 = llvm::raw_ostream::write(v72, 32);
  }

  else
  {
    v74 = OUTLINED_FUNCTION_5_2(v72, v73);
  }

  v82 = *this;
  v83 = *(*this + 11);
  v84 = (*this + 16 * ((v83 >> 23) & 1));
  v85 = v84[22];
  v86 = v84[23];
  v87 = v84[24];
  if ((v83 & 0x800000) != 0)
  {
    v88 = (v86 + v85);
    v89 = *(v82 + 9) + 32 * v88;
    v90 = (v87 + v88) - v88;
    v91 = *(v82 + 9);
  }

  else
  {
    LOBYTE(v91) = 0;
    v88 = (v86 + v85);
    v89 = 32 * v88;
    v90 = (v87 + v88) - v88;
  }

  v92 = OUTLINED_FUNCTION_51_2(v74, v75, v76, v77, v78, v79, v80, v81, v154, v91 + 32 * v88);
  Types = mlir::OperandRange::getTypes(v92, v93);
  OUTLINED_FUNCTION_95_3(Types, v95, v96, v97, v98, v99, v100, v101, v155, v158, v90);
  mlir::TypeRange::TypeRange(&v169, AttrDictionary, v172);
  OUTLINED_FUNCTION_13_12();
  if (!*(v102 + 64))
  {
    v108 = v170;
    if (!v170)
    {
      goto LABEL_92;
    }

    v109 = v169;
    OUTLINED_FUNCTION_104();
    (*(v110 + 16))(a2);
    OUTLINED_FUNCTION_72_0();
    if (v113 > 4)
    {
      *(v112 + 4) = 40;
      *v112 = 540945696;
      v111[4] += 5;
    }

    else
    {
      llvm::raw_ostream::write(v111, " -> (", 5uLL);
    }

    v115 = (*(*a2 + 16))(a2);
    if (v87)
    {
      v116 = v115;
      OUTLINED_FUNCTION_104();
      (*(v117 + 160))(a2);
      v118 = v90 - 1;
      if (v90 != 1)
      {
        v119 = v89 + 56;
        do
        {
          v120 = v116[4];
          if (v116[3] - v120 > 1uLL)
          {
            *v120 = 8236;
            v116[4] += 2;
          }

          else
          {
            OUTLINED_FUNCTION_111_1(v116);
          }

          v119 += 32;
          OUTLINED_FUNCTION_104();
          (*(v121 + 160))(a2);
          --v118;
        }

        while (v118);
      }
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_72_0();
    if (v124 > 2)
    {
      *(v123 + 2) = 32;
      OUTLINED_FUNCTION_15_4(v122, v123);
    }

    else
    {
      llvm::raw_ostream::write(v122, " : ", 3uLL);
    }

    mlir::TypeRange::dereference_iterator(v109, 0);
    OUTLINED_FUNCTION_104();
    (*(v125 + 32))(a2);
    if (v108 != 1)
    {
      do
      {
        (*(*a2 + 16))(a2);
        OUTLINED_FUNCTION_25_2();
        if (!v12 & v7)
        {
          *v127 = 8236;
          OUTLINED_FUNCTION_24_2(v126);
        }

        else
        {
          OUTLINED_FUNCTION_111_1(v126);
        }

        v128 = OUTLINED_FUNCTION_38_4();
        mlir::TypeRange::dereference_iterator(v128, v129);
        OUTLINED_FUNCTION_104();
        (*(v130 + 32))(a2);
        OUTLINED_FUNCTION_85_2();
      }

      while (!v12);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_17_2();
    if (v12)
    {
      v106 = ")";
      v107 = 1;
      goto LABEL_91;
    }

    *v131 = 41;
    v114 = v103[4] + 1;
LABEL_89:
    v103[4] = v114;
    goto LABEL_92;
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_72_0();
  if (v105 > 0xD)
  {
    qmemcpy(v104, " -> <inferred>", 14);
    v114 = v103[4] + 14;
    goto LABEL_89;
  }

  v106 = " -> <inferred>";
  v107 = 14;
LABEL_91:
  llvm::raw_ostream::write(v103, v106, v107);
LABEL_92:
  OUTLINED_FUNCTION_74_2();
  v165 = "operandSegmentSizes";
  v166 = 19;
  v167 = "name";
  v168 = 4;
  OUTLINED_FUNCTION_75_3(v132, v133, v134, v135, v136, v137, v138, v139, v156, v159, v161, v163, v164);
  v140 = (v163 + 16 * v164);
  *v140 = "inputAttributeNames";
  v140[1] = 19;
  OUTLINED_FUNCTION_56_3();
  if (v7)
  {
    OUTLINED_FUNCTION_51_3(v141, v157, v160, v162);
  }

  OUTLINED_FUNCTION_102_2();
  OUTLINED_FUNCTION_55_3(v142);
  mlir::Attribute::getContext((*this + 24));
  AttrDictionary = mlir::Operation::getAttrDictionary(*this);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_7_11();
  v143 = OUTLINED_FUNCTION_31_3();
  v145 = v144(v143);
  v153 = OUTLINED_FUNCTION_79_3(v145, v146, v147, v148, v149, v150, v151, v152, v157, v160, v162, v163);
  if (!v12)
  {
    free(v153);
  }
}

void mlir::pdl_interp::CreateRangeOp::print(mlir::pdl_interp::CreateRangeOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v89 = *MEMORY[0x1E69E9840];
  if ((*(*v7 + 46) & 0x80) != 0 && *(*v7 + 68))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v10)
    {
      llvm::raw_ostream::write(v8, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v8, v9);
    }

    OUTLINED_FUNCTION_47_0();
    if (v12 < 0)
    {
      v6 = *(v11 + 68);
      v5 = *(v11 + 72);
    }

    else
    {
      OUTLINED_FUNCTION_99_3();
    }

    (*(*v2 + 16))(v2);
    if (v6)
    {
      OUTLINED_FUNCTION_17_10();
      (*(v13 + 160))(v2);
      v14 = v6 - 1;
      if (v14)
      {
        v15 = v5 + 56;
        v5 = ", ";
        do
        {
          OUTLINED_FUNCTION_30_2();
          if (!v17 & v10)
          {
            OUTLINED_FUNCTION_21_5(v16);
          }

          else
          {
            v18 = OUTLINED_FUNCTION_38_4();
            llvm::raw_ostream::write(v18, v19, 2uLL);
          }

          v15 += 32;
          OUTLINED_FUNCTION_104();
          (*(v20 + 160))(v2);
          --v14;
        }

        while (v14);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v10)
    {
      llvm::raw_ostream::write(v21, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v21, v22);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v17)
    {
      llvm::raw_ostream::write(v23, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v23, v24);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v10)
    {
      llvm::raw_ostream::write(v25, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v25, v26);
    }

    OUTLINED_FUNCTION_90_2();
    if (v27 < 0)
    {
      OUTLINED_FUNCTION_89_2();
    }

    else
    {
      OUTLINED_FUNCTION_84_2();
    }

    AttrDictionary = v29;
    v88 = v28;
    mlir::OperandRange::getTypes(&AttrDictionary, v84);
    OUTLINED_FUNCTION_35_4();
    if (!v17)
    {
      v30 = v84[0] + 32 * v4;
      OUTLINED_FUNCTION_29_4();
      v31 = OUTLINED_FUNCTION_12_4();
      v32(v31);
      OUTLINED_FUNCTION_76_2();
      if (!v17)
      {
        OUTLINED_FUNCTION_34_6();
        do
        {
          (*(*v2 + 16))(v2);
          OUTLINED_FUNCTION_25_2();
          if (!v17 & v10)
          {
            *v34 = 8236;
            OUTLINED_FUNCTION_24_2(v33);
          }

          else
          {
            OUTLINED_FUNCTION_78_2(v33);
          }

          v30 += 32;
          OUTLINED_FUNCTION_29_4();
          v35 = OUTLINED_FUNCTION_12_4();
          v36(v35);
          --v5;
        }

        while (v5);
      }
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v10)
  {
    llvm::raw_ostream::write(v37, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v37, v38);
  }

  OUTLINED_FUNCTION_90_2();
  if (v39 < 0)
  {
    OUTLINED_FUNCTION_89_2();
  }

  else
  {
    OUTLINED_FUNCTION_84_2();
  }

  v82 = v48;
  v50 = OUTLINED_FUNCTION_51_2(v40, v41, v42, v43, v44, v45, v46, v47, v77, v49);
  Types = mlir::OperandRange::getTypes(v50, v51);
  OUTLINED_FUNCTION_95_3(Types, v53, v54, v55, v56, v57, v58, v59, v78, v80, v82);
  mlir::TypeRange::TypeRange(v86, AttrDictionary, v88);
  if (*(*v3 + 9))
  {
    v60 = *v3 - 16;
  }

  else
  {
    v60 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v60, 0);
  if (!v86[1])
  {
    v62 = *(NextResultAtOffset + 8);
    OUTLINED_FUNCTION_104();
    (*(v63 + 16))(v2);
    OUTLINED_FUNCTION_25_2();
    if (!v17 & v10)
    {
      *v65 = 8250;
      OUTLINED_FUNCTION_24_2(v64);
    }

    else
    {
      llvm::raw_ostream::write(v64, ": ", 2uLL);
    }

    (*(*v2 + 32))(v2, v62 & 0xFFFFFFFFFFFFFFF8);
  }

  v84[0] = &v85;
  v84[1] = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_7_11();
  v66 = OUTLINED_FUNCTION_31_3();
  v68 = v67(v66);
  v76 = OUTLINED_FUNCTION_79_3(v68, v69, v70, v71, v72, v73, v74, v75, v79, v81, v83, v84[0]);
  if (!v17)
  {
    free(v76);
  }
}

uint64_t mlir::pdl_interp::RecordMatchOp::getODSOperands(mlir::pdl_interp::RecordMatchOp *this, unsigned int a2)
{
  v2 = *this;
  v3 = *(*this + 44);
  v4 = (v3 >> 23) & 1;
  if (!a2)
  {
    v7 = 0;
    goto LABEL_11;
  }

  if (a2 > 7)
  {
    v5 = a2 & 0xFFFFFFF8;
    v8 = (*this + 16 * v4 + 112);
    v9 = 0uLL;
    v10 = v5;
    v11 = 0uLL;
    do
    {
      v9 = vaddq_s32(v8[-1], v9);
      v11 = vaddq_s32(*v8, v11);
      v8 += 2;
      v10 -= 8;
    }

    while (v10);
    v6 = vaddvq_s32(vaddq_s32(v11, v9));
    if (v5 == a2)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v5 = 0;
    v6 = 0;
  }

  v12 = a2 - v5;
  v13 = (16 * v4 + 4 * v5 + v2 + 96);
  do
  {
    v14 = *v13++;
    v6 += v14;
    --v12;
  }

  while (v12);
LABEL_10:
  v7 = v6;
LABEL_11:
  if ((v3 & 0x800000) != 0)
  {
    v15 = *(v2 + 72);
  }

  else
  {
    v15 = 0;
  }

  return v15 + 32 * v7;
}

uint64_t mlir::pdl_interp::ReplaceOp::getODSOperandIndexAndLength(mlir::pdl_interp::ReplaceOp *this, unsigned int a2, double a3, int32x4_t a4)
{
  if (a2)
  {
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
LABEL_14:
      v26 = &byte_1E097C8C3[v4];
      v27 = a2 - v4;
      do
      {
        v28 = *v26++;
        v5 += v28;
        --v27;
      }

      while (v27);
      goto LABEL_16;
    }

    if (a2 >= 0x20)
    {
      v6 = 0uLL;
      v7 = "terp16PDLInterpDialectE";
      v8 = 0uLL;
      v4 = a2 & 0xFFFFFFE0;
      v9 = v4;
      v10 = 0uLL;
      v11 = 0uLL;
      v12 = 0uLL;
      v13 = 0uLL;
      v14 = 0uLL;
      v15 = 0uLL;
      do
      {
        v16 = *v7[-2].i8;
        v17 = vmovl_u8(*v16.i8);
        v18 = vmovl_high_u8(v16);
        v19 = vmovl_u8(*v7);
        v20 = vmovl_high_u8(*v7->i8);
        v11 = vaddw_high_u16(v11, v18);
        v10 = vaddw_u16(v10, *v18.i8);
        v8 = vaddw_high_u16(v8, v17);
        v6 = vaddw_u16(v6, *v17.i8);
        v15 = vaddw_high_u16(v15, v20);
        v14 = vaddw_u16(v14, *v20.i8);
        v13 = vaddw_high_u16(v13, v19);
        v12 = vaddw_u16(v12, *v19.i8);
        v7 += 4;
        v9 -= 32;
      }

      while (v9);
      a4 = vaddq_s32(vaddq_s32(v13, v8), vaddq_s32(v15, v11));
      v5 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v12, v6), vaddq_s32(v14, v10)), a4));
      if (v4 == a2)
      {
        goto LABEL_16;
      }

      if ((a2 & 0x1C) == 0)
      {
        goto LABEL_14;
      }
    }

    else
    {
      v5 = 0;
      v4 = 0;
    }

    v21 = v4;
    v4 = a2 & 0xFFFFFFFC;
    v22 = v5;
    v23 = &byte_1E097C8C3[v21];
    v24 = v21 - v4;
    do
    {
      v25 = *v23;
      v23 += 4;
      a4.i32[0] = v25;
      a4.i64[0] = vmovl_u8(*a4.i8).u64[0];
      v22 = vaddw_u16(v22, *a4.i8);
      v24 += 4;
    }

    while (v24);
    v5 = vaddvq_s32(v22);
    if (v4 == a2)
    {
      goto LABEL_16;
    }

    goto LABEL_14;
  }

  v5 = 0;
LABEL_16:
  if ((*(*this + 46) & 0x80) != 0)
  {
    v29 = *(*this + 68);
  }

  else
  {
    v29 = 0;
  }

  v30 = (v29 - 1);
  v31 = a2 + (v29 - 2) * v5;
  v32 = v30 << 32;
  v33 = 0x100000000;
  if (byte_1E097C8C3[a2])
  {
    v33 = v32;
  }

  return v33 | v31;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl_interp::ApplyConstraintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::pdl_interp::ApplyConstraintOp::print(&v8, a3);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl_interp::ApplyRewriteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::pdl_interp::ApplyRewriteOp::print(&v8, a3);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl_interp::AreEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameTypeOperands>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::pdl_interp::AreEqualOp::print(&v8, a3);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl_interp::CreateOperationOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::OperationType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::pdl_interp::CreateOperationOp::print(&v7, a3);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl_interp::CreateRangeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::RangeType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::pdl_interp::CreateRangeOp::print(&v7, a3);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::pdl_interp::RecordMatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::pdl_interp::RecordMatchOp::print(&v8, a3);
}

void mlir::pdl_interp::ApplyConstraintOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::ApplyConstraintOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_60_3(v2);
  }
}

void mlir::pdl_interp::ApplyRewriteOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::ApplyRewriteOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_93_1(v2);
  }
}

void mlir::pdl_interp::CheckAttributeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::CheckAttributeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_92_3(v2);
  }
}

void mlir::pdl_interp::CheckOperandCountOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::CheckOperandCountOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_48_3(v2);
  }
}

void mlir::pdl_interp::CheckOperationNameOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::CheckOperationNameOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_69_3(v2);
  }
}

void mlir::pdl_interp::CheckResultCountOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::CheckResultCountOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_47_4(v2);
  }
}

void mlir::pdl_interp::CheckTypeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::CheckTypeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_67_2(v2);
  }
}

void mlir::pdl_interp::CheckTypesOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::CheckTypesOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_91_2(v2);
  }
}

void mlir::pdl_interp::CreateAttributeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::CreateAttributeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_90_3(v2);
  }
}

void mlir::pdl_interp::CreateOperationOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::CreateOperationOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_36_4(v2);
  }
}

void mlir::pdl_interp::CreateTypeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::CreateTypeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_66_2(v2);
  }
}

void mlir::pdl_interp::CreateTypesOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::CreateTypesOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_89_3(v2);
  }
}

void mlir::pdl_interp::ExtractOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_65_3(v2);
  }
}

void mlir::pdl_interp::FuncOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::FuncOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::FuncOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::pdl_interp::GetAttributeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::GetAttributeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_64_2(v2);
  }
}

void mlir::pdl_interp::GetOperandOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::GetOperandOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_63_2(v2);
  }
}

void mlir::pdl_interp::GetOperandsOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::GetOperandsOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_87_2(v2);
  }
}

void mlir::pdl_interp::GetResultOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_62_2(v2);
  }
}

void mlir::pdl_interp::GetResultsOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::GetResultsOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_86_2(v2);
  }
}

void mlir::pdl_interp::RecordMatchOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::RecordMatchOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_35_5(v2);
  }
}

void mlir::pdl_interp::SwitchAttributeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::SwitchAttributeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_85_3(v2);
  }
}

void mlir::pdl_interp::SwitchOperandCountOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::SwitchOperandCountOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_84_3(v2);
  }
}

void mlir::pdl_interp::SwitchOperationNameOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::SwitchOperationNameOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_83_3(v2);
  }
}

void mlir::pdl_interp::SwitchResultCountOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::SwitchResultCountOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_82_3(v2);
  }
}

void mlir::pdl_interp::SwitchTypeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::SwitchTypeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_81_3(v2);
  }
}

void mlir::pdl_interp::SwitchTypesOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_interp::detail::SwitchTypesOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_80_2(v2);
  }
}

void mlir::RegisteredOperationName::Model<mlir::pdl_interp::ApplyConstraintOp>::Model()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_32_6(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NSuccessors<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NSuccessors<2u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_100_2(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_43_5(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_50_4(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::pdl_interp::AreEqualOp>,mlir::OpTrait::ZeroResults<mlir::pdl_interp::AreEqualOp>,mlir::OpTrait::NSuccessors<2u>::Impl<mlir::pdl_interp::AreEqualOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::pdl_interp::AreEqualOp>,mlir::OpTrait::OpInvariants<mlir::pdl_interp::AreEqualOp>,mlir::OpTrait::IsTerminator<mlir::pdl_interp::AreEqualOp>,mlir::ConditionallySpeculatable::Trait<mlir::pdl_interp::AreEqualOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::pdl_interp::AreEqualOp>,mlir::MemoryEffectOpInterface::Trait<mlir::pdl_interp::AreEqualOp>,mlir::OpTrait::SameTypeOperands<mlir::pdl_interp::AreEqualOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_28_6(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameTypeOperands>()
{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_39_3(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_38_5(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_61_2(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::pdl_interp::CheckAttributeOp>,mlir::OpTrait::ZeroResults<mlir::pdl_interp::CheckAttributeOp>,mlir::OpTrait::NSuccessors<2u>::Impl<mlir::pdl_interp::CheckAttributeOp>,mlir::OpTrait::OneOperand<mlir::pdl_interp::CheckAttributeOp>,mlir::OpTrait::OpInvariants<mlir::pdl_interp::CheckAttributeOp>,mlir::BytecodeOpInterface::Trait<mlir::pdl_interp::CheckAttributeOp>,mlir::OpTrait::IsTerminator<mlir::pdl_interp::CheckAttributeOp>,mlir::ConditionallySpeculatable::Trait<mlir::pdl_interp::CheckAttributeOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::pdl_interp::CheckAttributeOp>,mlir::MemoryEffectOpInterface::Trait<mlir::pdl_interp::CheckAttributeOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_32_6(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_45_1(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::pdl_interp::ForEachOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::pdl_interp::ForEachOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::pdl_interp::ForEachOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::pdl_interp::ForEachOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::pdl_interp::ForEachOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::pdl::AttributeType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_44_3(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::pdl_interp::FuncOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::FunctionOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_101_2(v2);
  }
}

void mlir::OpBuilder::create<mlir::pdl_interp::FuncOp,llvm::StringRef,mlir::FunctionType,std::nullopt_t const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.func";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::ModuleOp,llvm::StringRef>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "builtin.module";
  *(a2 + 24) = 14;
}

void anonymous namespace::PatternLowering::generateMatcher()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::ExitNode>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::ExitNode,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::BoolNode>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::BoolNode,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::SwitchNode>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::SwitchNode,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::pdl_to_pdl_interp::PredicateUniquer::PredicateUniquer()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::AttributePosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::AttributePosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::AttributeLiteralPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::AttributeLiteralPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::ConstraintPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::ConstraintPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::ForEachPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::ForEachPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperandPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperandPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperandGroupPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperandGroupPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperationPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperationPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::ResultPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::ResultPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::ResultGroupPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::ResultGroupPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::TypePosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::TypePosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::TypeLiteralPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::TypeLiteralPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::UsersPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::UsersPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::AttributeAnswer>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::AttributeAnswer,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperationNameAnswer>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperationNameAnswer,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::TypeAnswer>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::TypeAnswer,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::UnsignedAnswer>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::UnsignedAnswer,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::FalseAnswer>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::FalseAnswer,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::TrueAnswer>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::TrueAnswer,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::ConstraintQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::ConstraintQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::EqualToQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::EqualToQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::AttributeQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::AttributeQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::IsNotNullQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::IsNotNullQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperandCountQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperandCountQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperandCountAtLeastQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperandCountAtLeastQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperationNameQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperationNameQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::ResultCountQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::ResultCountQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::ResultCountAtLeastQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::ResultCountAtLeastQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::TypeQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::TypeQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::OperationPosition,decltype(nullptr),int>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperationPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperationPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::pdl_interp::FinalizeOp>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.finalize";
  *(a2 + 24) = 19;
}

void llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::pdl_to_pdl_interp::MatcherNode *,void>,mlir::pdl_to_pdl_interp::MatcherNode *>::Case<anonymous namespace::PatternLowering::generateMatcher(mlir::pdl_to_pdl_interp::MatcherNode&,mlir::Region &,mlir::Block *)::$_1>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::SuccessNode>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::SuccessNode,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::pdl_to_pdl_interp::MatcherNode *,void>,mlir::pdl_to_pdl_interp::MatcherNode *>::Case<anonymous namespace::PatternLowering::generateMatcher(mlir::pdl_to_pdl_interp::MatcherNode&,mlir::Region &,mlir::Block *)::$_1>(mlir::InFlightDiagnostic *a1, uint64_t *a2, uint64_t a3)
{
  v4 = *a2;
  *(a3 + 32) = 257;
  mlir::Operation::emitOpError(v4, a3, a1);
  mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(a1, "unable to infer result type for operation");
  mlir::InFlightDiagnostic::~InFlightDiagnostic(a1);
  __break(1u);
}

void mlir::OpBuilder::create<mlir::pdl_interp::GetDefiningOpOp,mlir::pdl::OperationType,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.get_defining_op";
  *(a2 + 24) = 26;
}

void mlir::OpBuilder::create<mlir::pdl_interp::ExtractOp,mlir::Value &,int>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.extract";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::pdl_interp::GetUsersOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.get_users";
  *(a2 + 24) = 20;
}

void mlir::OpBuilder::create<mlir::pdl_interp::ForEachOp,mlir::Value &,mlir::Block *&,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.foreach";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::pdl_interp::ContinueOp>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.continue";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::pdl_interp::GetOperandOp,mlir::pdl::ValueType,mlir::Value &,unsigned int>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.get_operand";
  *(a2 + 24) = 22;
}

void mlir::OpBuilder::create<mlir::pdl_interp::GetOperandsOp,mlir::Type,mlir::Value &,std::optional<unsigned int>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.get_operands";
  *(a2 + 24) = 23;
}

void mlir::OpBuilder::create<mlir::pdl_interp::GetAttributeOp,mlir::pdl::AttributeType,mlir::Value &,llvm::StringRef>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.get_attribute";
  *(a2 + 24) = 24;
}

void mlir::OpBuilder::create<mlir::pdl_interp::GetAttributeTypeOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.get_attribute_type";
  *(a2 + 24) = 29;
}

void mlir::OpBuilder::create<mlir::pdl_interp::GetValueTypeOp,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.get_value_type";
  *(a2 + 24) = 25;
}

void mlir::OpBuilder::create<mlir::pdl_interp::GetResultOp,mlir::pdl::ValueType,mlir::Value &,unsigned int>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.get_result";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::pdl_interp::GetResultsOp,mlir::Type,mlir::Value &,std::optional<unsigned int>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.get_results";
  *(a2 + 24) = 22;
}

void mlir::OpBuilder::create<mlir::pdl_interp::CreateAttributeOp,mlir::Attribute const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.create_attribute";
  *(a2 + 24) = 27;
}

void mlir::OpBuilder::create<mlir::pdl_interp::CreateTypeOp,mlir::TypeAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.create_type";
  *(a2 + 24) = 22;
}

void mlir::OpBuilder::create<mlir::pdl_interp::CreateTypesOp,mlir::ArrayAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.create_types";
  *(a2 + 24) = 23;
}

void mlir::OpBuilder::create<mlir::pdl_interp::IsNotNullOp,mlir::Value &,mlir::Block *&,mlir::Block *&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.is_not_null";
  *(a2 + 24) = 22;
}

void mlir::OpBuilder::create<mlir::pdl_interp::CheckOperationNameOp,mlir::Value &,llvm::StringRef,mlir::Block *&,mlir::Block *&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.check_operation_name";
  *(a2 + 24) = 31;
}

void mlir::OpBuilder::create<mlir::pdl_interp::CheckTypesOp,mlir::Value &,mlir::ArrayAttr,mlir::Block *&,mlir::Block *&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.check_types";
  *(a2 + 24) = 22;
}

void mlir::OpBuilder::create<mlir::pdl_interp::CheckTypeOp,mlir::Value &,mlir::TypeAttr,mlir::Block *&,mlir::Block *&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.check_type";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::pdl_interp::CheckAttributeOp,mlir::Value &,mlir::Attribute const&,mlir::Block *&,mlir::Block *&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.check_attribute";
  *(a2 + 24) = 26;
}

void mlir::OpBuilder::create<mlir::pdl_interp::CheckOperandCountOp,mlir::Value &,unsigned int const&,BOOL,mlir::Block *&,mlir::Block *&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.check_operand_count";
  *(a2 + 24) = 30;
}

void mlir::OpBuilder::create<mlir::pdl_interp::CheckResultCountOp,mlir::Value &,unsigned int const&,BOOL,mlir::Block *&,mlir::Block *&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.check_result_count";
  *(a2 + 24) = 29;
}

void mlir::OpBuilder::create<mlir::pdl_interp::AreEqualOp,mlir::Value &,mlir::Value &,mlir::Block *&,mlir::Block *&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.are_equal";
  *(a2 + 24) = 20;
}

void mlir::OpBuilder::create<mlir::pdl_interp::ApplyConstraintOp,llvm::ArrayRef<mlir::Type>,llvm::StringRef,llvm::SmallVector<mlir::Value,6u> &,BOOL,mlir::Block *&,mlir::Block *&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.apply_constraint";
  *(a2 + 24) = 27;
}

void mlir::OpBuilder::create<mlir::pdl_interp::SwitchOperandCountOp,mlir::Value &,std::vector<int> &,mlir::Block *&,std::vector<mlir::Block *> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.switch_operand_count";
  *(a2 + 24) = 31;
}

void mlir::OpBuilder::create<mlir::pdl_interp::SwitchResultCountOp,mlir::Value &,std::vector<int> &,mlir::Block *&,std::vector<mlir::Block *> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.switch_result_count";
  *(a2 + 24) = 30;
}

void mlir::OpBuilder::create<mlir::pdl_interp::SwitchOperationNameOp,mlir::Value &,std::vector<mlir::OperationName> &,mlir::Block *&,std::vector<mlir::Block *> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.switch_operation_name";
  *(a2 + 24) = 32;
}

void mlir::OpBuilder::create<mlir::pdl_interp::SwitchTypesOp,mlir::Value &,std::vector<mlir::Attribute> &,mlir::Block *&,std::vector<mlir::Block *> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.switch_types";
  *(a2 + 24) = 23;
}

void mlir::OpBuilder::create<mlir::pdl_interp::SwitchTypeOp,mlir::Value &,std::vector<mlir::Attribute> &,mlir::Block *&,std::vector<mlir::Block *> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.switch_type";
  *(a2 + 24) = 22;
}

void mlir::OpBuilder::create<mlir::pdl_interp::SwitchAttributeOp,mlir::Value &,std::vector<mlir::Attribute> &,mlir::Block *&,std::vector<mlir::Block *> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.switch_attribute";
  *(a2 + 24) = 27;
}

void mlir::OpBuilder::create<mlir::pdl_interp::RecordMatchOp,std::vector<mlir::Value> &,llvm::ArrayRef<mlir::Value>,mlir::SymbolRefAttr &,mlir::StringAttr &,mlir::ArrayAttr &,mlir::IntegerAttr,mlir::Block *&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.record_match";
  *(a2 + 24) = 23;
}

void mlir::OpBuilder::create<mlir::pdl_interp::ApplyRewriteOp,mlir::TypeRange,mlir::StringAttr &,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.apply_rewrite";
  *(a2 + 24) = 24;
}

void mlir::OpBuilder::create<mlir::pdl_interp::EraseOp,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.erase";
  *(a2 + 24) = 16;
}

void mlir::OpBuilder::create<mlir::pdl_interp::CreateOperationOp,llvm::StringRef,llvm::SmallVector<mlir::Value,2u> &,BOOL &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::Value,4u> &,mlir::ArrayAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.create_operation";
  *(a2 + 24) = 27;
}

void mlir::OpBuilder::create<mlir::pdl_interp::CreateRangeOp,mlir::pdl::RangeType,llvm::SmallVector<mlir::Value,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.create_range";
  *(a2 + 24) = 23;
}

void mlir::OpBuilder::create<mlir::pdl_interp::ReplaceOp,mlir::Value,llvm::SmallVector<mlir::Value,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "pdl_interp.replace";
  *(a2 + 24) = 18;
}

void buildPredicateList(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v115 = a4;
  v158 = *MEMORY[0x1E69E9840];
  v131 = a1;
  v152 = a1;
  v7 = a1[10];
  v6 = a1[11];
  v150 = 0;
  v149 = 0;
  v151 = 0;
  mlir::Region::getOps<mlir::pdl::OperationOp>((((&a1[4 * ((v6 >> 23) & 1) + 17] + ((v6 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8) + 32 * v7), &v153);
  v145 = v153;
  v146 = v154;
  v147 = v155;
  v148 = v156;
  v9 = v157;
  v10 = v154;
  v116 = a3;
  v114 = a2;
  if (v154 == v157)
  {
LABEL_60:
    *&v153 = mlir::pdl::PatternOp::getRewriter(&v152, v8);
    mlir::memref::AllocOp::getODSOperandIndexAndLength(&v153, 0);
    OUTLINED_FUNCTION_34_7();
    if (v54 != v53)
    {
      OUTLINED_FUNCTION_88_0();
      if (*(v55 + 24))
      {
        if (v151)
        {
          OUTLINED_FUNCTION_9_10();
          OUTLINED_FUNCTION_1_19();
          v59 = (v57 - 1) & v58;
          v60 = *(v56 + 8 * v59);
          if (v61 == v60)
          {
LABEL_64:
            *(v56 + 8 * v59) = -8192;
            v150 = vadd_s32(v150, 0x1FFFFFFFFLL);
          }

          else
          {
            while (v60 != -4096)
            {
              OUTLINED_FUNCTION_26_7();
              v60 = *(v56 + 8 * v59);
              if (v88 == v60)
              {
                goto LABEL_64;
              }
            }
          }
        }
      }
    }

    v90 = &v142;
    v140 = &v142;
    v141 = 0x600000000;
    OUTLINED_FUNCTION_39_4();
    mlir::Region::getOps<mlir::pdl::OperationOp>((v62 + 32 * v63), &v153);
    v145 = v153;
    v146 = v154;
    v147 = v155;
    v148 = v156;
    v65 = v157;
LABEL_66:
    v66 = v146;
    while (1)
    {
      if (v66 == v65)
      {
        llvm::deallocate_buffer(v149, (8 * v151));
      }

      v67 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v66, v64);
      v68 = (*(&v148 + 1))(v67) - 16;
      OUTLINED_FUNCTION_8_10();
      OUTLINED_FUNCTION_4_12();
      if (v69)
      {
        OUTLINED_FUNCTION_32_7();
        v73 = (v71 * v72) & (v70 - 1);
        v75 = *(v74 + 8 * v73);
        if (v68 == v75)
        {
LABEL_70:
          if (v73 != v70)
          {
            goto LABEL_74;
          }
        }

        else
        {
          while (v75 != -4096)
          {
            OUTLINED_FUNCTION_26_7();
            v75 = *(v87 + 8 * v73);
            if (v68 == v75)
            {
              goto LABEL_70;
            }
          }
        }
      }

      v76 = v141;
      if (v141 >= HIDWORD(v141))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v140, v90, v141 + 1, 8);
        v76 = v141;
      }

      *(v140 + v76) = v68;
      LODWORD(v141) = v141 + 1;
LABEL_74:
      while (1)
      {
        v77 = mlir::Region::OpIterator::operator++(&v145);
        v66 = OUTLINED_FUNCTION_36_5(v77, v78, v79, v80, v81, v82, v83, v84, v90, __p, v92, v93, v94, v95, v96, v97, v98, v99, v100, v101, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, v116, v117, v118, v119, v120, v121, v122, v123, v124, v125, v126, v127, v128, v129, v130, v131, v132, v133, v134, v135, v136, v137, v138, v139, v140, v141, v142, v143, v144);
        if (v24)
        {
          break;
        }

        v85 = v148;
        v86 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v66, v64);
        if (v85(v86))
        {
          goto LABEL_66;
        }
      }
    }
  }

  while (1)
  {
    v11 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v10, v8);
    v140 = (*(&v148 + 1))(v11);
    mlir::pdl::OperationOp::getODSOperandIndexAndLength(&v140, 0);
    OUTLINED_FUNCTION_34_7();
    v15 = v14 - v12;
    if (v14 != v12)
    {
      break;
    }

LABEL_3:
    v16 = mlir::Region::OpIterator::operator++(&v145);
    v10 = OUTLINED_FUNCTION_36_5(v16, v17, v18, v19, v20, v21, v22, v23, v89, __p, v92, v93, v94, v95, v96, v97, v98, v99, v100, v101, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, v116, v117, v118, v119, v120, v121, v122, v123, v124, v125, v126, v127, v128, v129, v130, v131, v132, v133, v134, v135, v136, v137, v138, v139, v140, v141, v142, v143, v144);
    if (v24)
    {
      a2 = v114;
    }

    else
    {
      a2 = v114;
      while (1)
      {
        v25 = v148;
        v26 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v10, v8);
        if (v25(v26))
        {
          break;
        }

        v27 = mlir::Region::OpIterator::operator++(&v145);
        v10 = OUTLINED_FUNCTION_36_5(v27, v28, v29, v30, v31, v32, v33, v34, v89, __p, v92, v93, v94, v95, v96, v97, v98, v99, v100, v101, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, v116, v117, v118, v119, v120, v121, v122, v123, v124, v125, v126, v127, v128, v129, v130, v131, v132, v133, v134, v135, v136, v137, v138, v139, v140, v141, v142, v143, v144);
        if (v24)
        {
          goto LABEL_59;
        }
      }

      v10 = v146;
    }

LABEL_59:
    if (v10 == v9)
    {
      goto LABEL_60;
    }
  }

  v35 = 0;
  v36 = v13 + 32 * v12;
  while (1)
  {
    v132 = *(v36 + 32 * v35 + 24);
    mlir::Value::getDefiningOp(&v132);
    OUTLINED_FUNCTION_12_8();
    if (v38 && v37 == &mlir::detail::TypeIDResolver<mlir::pdl::ResultOp,void>::id)
    {
      OUTLINED_FUNCTION_40_3();
      if (!v39)
      {
        goto LABEL_25;
      }

      OUTLINED_FUNCTION_13_13();
      OUTLINED_FUNCTION_3_13();
      OUTLINED_FUNCTION_5_13();
      OUTLINED_FUNCTION_12_10();
      if (!v24)
      {
        OUTLINED_FUNCTION_44_4();
        while (v40 != -4096)
        {
          OUTLINED_FUNCTION_12_10();
          if (v24)
          {
            goto LABEL_34;
          }
        }

LABEL_25:
        OUTLINED_FUNCTION_29_6();
        if (v44)
        {
          v45 = 2 * v43;
        }

        else
        {
          OUTLINED_FUNCTION_28_7();
          if (!v24 & v44)
          {
            goto LABEL_31;
          }
        }

        llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::grow(&v149, v45);
        if (v151)
        {
          OUTLINED_FUNCTION_14_11();
          OUTLINED_FUNCTION_2_14();
          OUTLINED_FUNCTION_25_8();
          if (!v24)
          {
            OUTLINED_FUNCTION_49_4();
            while (v51 != -4096)
            {
              OUTLINED_FUNCTION_24_7();
              OUTLINED_FUNCTION_25_8();
              if (v24)
              {
                goto LABEL_53;
              }
            }

            goto LABEL_54;
          }

          goto LABEL_53;
        }

        goto LABEL_52;
      }
    }

    else if (v37 == &mlir::detail::TypeIDResolver<mlir::pdl::ResultsOp,void>::id)
    {
      OUTLINED_FUNCTION_40_3();
      if (!v41)
      {
        goto LABEL_28;
      }

      OUTLINED_FUNCTION_13_13();
      OUTLINED_FUNCTION_3_13();
      OUTLINED_FUNCTION_5_13();
      OUTLINED_FUNCTION_12_10();
      if (!v24)
      {
        OUTLINED_FUNCTION_44_4();
        while (v42 != -4096)
        {
          OUTLINED_FUNCTION_12_10();
          if (v24)
          {
            goto LABEL_34;
          }
        }

LABEL_28:
        OUTLINED_FUNCTION_29_6();
        if (v44)
        {
          v49 = 2 * v48;
          goto LABEL_46;
        }

        OUTLINED_FUNCTION_28_7();
        if (!v24 & v44)
        {
          goto LABEL_31;
        }

LABEL_46:
        llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::grow(&v149, v49);
        if (v151)
        {
          OUTLINED_FUNCTION_14_11();
          OUTLINED_FUNCTION_2_14();
          OUTLINED_FUNCTION_25_8();
          if (!v24)
          {
            OUTLINED_FUNCTION_49_4();
            while (v52 != -4096)
            {
              OUTLINED_FUNCTION_24_7();
              OUTLINED_FUNCTION_25_8();
              if (v24)
              {
                goto LABEL_53;
              }
            }

LABEL_54:
            if (v50)
            {
              v46 = v50;
            }
          }

LABEL_53:
          v47 = v150.i32[0];
LABEL_31:
          v150.i32[0] = v47 + 1;
          if (*v46 != -4096)
          {
            --v150.i32[1];
          }

          *v46 = a2;
          goto LABEL_34;
        }

LABEL_52:
        v46 = 0;
        goto LABEL_53;
      }
    }

LABEL_34:
    if (++v35 == v15)
    {
      goto LABEL_3;
    }
  }
}

void mlir::pdl_to_pdl_interp::MatcherNode::generateMatcherTree()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::SwitchNode>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_43_6(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::SuccessNode>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::SuccessNode,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void foldSwitchToBool()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::SwitchNode>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_43_6(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::BoolNode>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_50_5(v2);
  }
}

void mlir::pdl_to_pdl_interp::PredicateBuilder::getEqualTo()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::TrueAnswer>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_41_5(v2);
  }
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::EqualToQuestion,mlir::pdl_to_pdl_interp::Position *&>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::EqualToQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::EqualToQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::pdl_to_pdl_interp::PredicateBuilder::getIsNotNull()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::IsNotNullQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::IsNotNullQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::TrueAnswer>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_41_5(v2);
  }
}

void mlir::pdl_to_pdl_interp::PredicateBuilder::getAttributeConstraint()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::AttributeQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::AttributeQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::TypePosition,mlir::pdl_to_pdl_interp::Position *&>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::TypePosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::TypePosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::AttributeAnswer,mlir::Attribute &>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::AttributeAnswer>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::AttributeAnswer,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::pdl_to_pdl_interp::PredicateBuilder::getOperationName()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperationNameQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperationNameQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::pdl_to_pdl_interp::PredicateBuilder::getOperandCountAtLeast()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperandCountAtLeastQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperandCountAtLeastQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::pdl_to_pdl_interp::PredicateBuilder::getOperandCount()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperandCountQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperandCountQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::pdl_to_pdl_interp::PredicateBuilder::getResultCount()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::ResultCountQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::ResultCountQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::pdl_to_pdl_interp::PredicateBuilder::getResultCountAtLeast()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::ResultCountAtLeastQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::ResultCountAtLeastQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::OperationNameAnswer,mlir::OperationName>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperationNameAnswer>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperationNameAnswer,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::UnsignedAnswer,unsigned int &>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::UnsignedAnswer>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::UnsignedAnswer,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::OperandGroupPosition,mlir::pdl_to_pdl_interp::OperationPosition *&,std::optional<unsigned int> &,BOOL &>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperandGroupPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperandGroupPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::OperandPosition,mlir::pdl_to_pdl_interp::OperationPosition *&,unsigned int &>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::OperandPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::OperandPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::ResultGroupPosition,mlir::pdl_to_pdl_interp::OperationPosition *&,std::optional<unsigned int> &,BOOL &>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::ResultGroupPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::ResultGroupPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::ResultPosition,mlir::pdl_to_pdl_interp::OperationPosition *&,unsigned int &>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::ResultPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::ResultPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::pdl_to_pdl_interp::PredicateBuilder::getTypeConstraint()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::TypeQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::TypeQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::TypeAnswer,mlir::Attribute &>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::TypeAnswer>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::TypeAnswer,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void llvm::TypeSwitch<mlir::Operation *,void>::Case<mlir::pdl::OperandsOp,getOperandTreePredicates(std::vector<mlir::pdl_to_pdl_interp::PositionalPredicate> &,mlir::Value,mlir::pdl_to_pdl_interp::PredicateBuilder &,llvm::DenseMap<mlir::Value,mlir::pdl_to_pdl_interp::Position *,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::pdl_to_pdl_interp::Position *>> &,mlir::pdl_to_pdl_interp::Position *)::$_0 &>(mlir::func::ReturnOp *a1, _BYTE *a2, void *a3)
{
  mlir::func::ReturnOp::getODSOperandIndexAndLength(a1, 0);
  OUTLINED_FUNCTION_34_7();
  if (v6 != v5)
  {
    OUTLINED_FUNCTION_88_0();
    v8 = *(v7 + 24);
    if (v8)
    {
      v9 = a3[2];
      v10 = a3[3];
      v11 = a3[1];
      OUTLINED_FUNCTION_44_0();
      v16 = mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::TypePosition,mlir::pdl_to_pdl_interp::Position *&>(v12, v13, v14, v15);
      getTreePredicates(v11, v8, v9, v10, v16);
    }
  }

  *a2 = 1;
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::AttributeLiteralPosition,mlir::Attribute &>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::AttributeLiteralPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::AttributeLiteralPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::ConstraintQuestion,std::tuple<llvm::StringRef,llvm::ArrayRef<mlir::pdl_to_pdl_interp::Position *>,llvm::ArrayRef<mlir::Type>,BOOL>>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::ConstraintQuestion>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::ConstraintQuestion,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::StorageUniquer::get<mlir::pdl_to_pdl_interp::TypeLiteralPosition,mlir::Attribute &>()
{
  {
    v0 = llvm::getTypeName<mlir::pdl_to_pdl_interp::TypeLiteralPosition>();
    mlir::detail::TypeIDResolver<mlir::pdl_to_pdl_interp::TypeLiteralPosition,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void anonymous namespace::ByteCodeExecutor::execute()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AttrSizedResultSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedResultSegments>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedResultSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedResultSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

unsigned int *anonymous namespace::ByteCodeExecutor::execute(unsigned int *result, uint64_t a2, void *a3, uint64_t *a4)
{
  v4 = *result;
  v7 = *(a2 + 8);
  v5 = a2 + 8;
  v6 = v7;
  *a3 = v5;
  v8 = *a4;
  v9 = *(*a4 + 8 * *(v5 - 2));
  *a3 = v5 + 2;
  if ((*(v9 + 46) & 0x80) != 0 && *(v9 + 68) > v4)
  {
    v10 = *(*(v9 + 72) + 32 * v4 + 24);
  }

  else
  {
    v10 = 0;
  }

  *(v8 + 8 * v6) = v10;
  return result;
}

void anonymous namespace::Generator::generate(uint64_t a1, uint64_t a2, double a3, int32x4_t a4)
{
  v34 = a1;
  ODSOperandIndexAndLength = mlir::pdl_interp::ReplaceOp::getODSOperandIndexAndLength(&v34, 0, a3, a4);
  v8 = *(*(v34 + 72) + 32 * ODSOperandIndexAndLength + 24);
  v9 = *(a2 + 24);
  OUTLINED_FUNCTION_1_20();
  if (!v15 & v14)
  {
    OUTLINED_FUNCTION_2_15(v10, v11, v12);
    v13 = v9[1];
  }

  *(*v9 + 2 * v13) = 40;
  ++v9[1];
  v17 = *(a2 + 24);
  v16 = *(a2 + 32);
  v33 = v8;
  v18 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>,mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>::operator[](v16, &v33);
  OUTLINED_FUNCTION_1_20();
  if (!v15 & v14)
  {
    OUTLINED_FUNCTION_2_15(v19, v20, v21);
    v22 = *(v17 + 8);
  }

  OUTLINED_FUNCTION_0_13(v22);
  mlir::pdl_interp::ReplaceOp::getODSOperandIndexAndLength(&v34, 1u, v23, v24);
  if ((*(v34 + 46) & 0x80) != 0)
  {
    v25 = *(v34 + 72);
  }

  else
  {
    v25 = 0;
  }

  OUTLINED_FUNCTION_3_14();
  v26 = *(a2 + 24);
  OUTLINED_FUNCTION_1_20();
  if (!v15 & v14)
  {
    OUTLINED_FUNCTION_2_15(v27, v28, v29);
    v30 = *(v26 + 8);
  }

  OUTLINED_FUNCTION_0_13(v30);
  if (v5 != v4)
  {
    v31 = (v25 + 32 * v4 + 24);
    do
    {
      v32 = *v31;
      v31 += 4;
      --v18;
    }

    while (v18);
  }
}

void anonymous namespace::Generator::generate(mlir::memref::ReinterpretCastOp *a1, uint64_t *a2, uint64_t a3)
{
  v7 = a1;
  mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(a1, 2u);
  if ((*(*v7 + 46) & 0x80) != 0)
  {
    v8 = *(*v7 + 72);
  }

  else
  {
    v8 = 0;
  }

  OUTLINED_FUNCTION_3_14();
  v9 = *a2;
  OUTLINED_FUNCTION_1_20();
  if (!v15 & v14)
  {
    OUTLINED_FUNCTION_2_15(v10, v11, v12);
    v13 = *(v9 + 8);
  }

  OUTLINED_FUNCTION_0_13(v13);
  if (v4 != v3)
  {
    v16 = (v8 + 32 * v3 + 24);
    do
    {
      v17 = *v16;
      v16 += 4;
      v7 = (v7 - 1);
    }

    while (v7);
  }
}

void mlir::collect_regions::detail::verifyShouldAddToQueue()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::RegionOp<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RegionOp>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_2_16(v2);
  }
}

void mlir::anonymous namespace::eraseOpsWeCannotConvert()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::TypeChanger<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::TypeChanger>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::TypeChanger<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::TypeChanger>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::placement::ReplacedOps,std::string &,mlir::Operation *&,llvm::SmallVector<mlir::Operation *,6u> &,llvm::SmallVector<mlir::Value,6u> &,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "placement.replaced_ops";
  *(a2 + 24) = 22;
}

void mlir::OpBuilder::create<mlir::placement::StartTimer,mlir::placement::TimerHandleType,mlir::FlatSymbolRefAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "placement.start_timer";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::placement::HostTypeCast,mlir::Type const&,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "placement.host_type_cast";
  *(a2 + 24) = 24;
}

void mlir::OpBuilder::create<mlir::placement::StopTimer,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "placement.stop_timer";
  *(a2 + 24) = 20;
}

void mlir::anonymous namespace::eraseTypeChangers(llvm::SmallVectorImpl<mlir::Operation *> &,llvm::SmallVectorImpl<mlir::Value> &,llvm::SmallVectorImpl<mlir::Value> &,llvm::SmallVectorImpl<mlir::Location> &,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>> &,llvm::SmallVector<mlir::Operation *,6u> &,mlir::OpBuilder &,mlir::IRMapping &)::$_0::operator()()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::TypeChanger<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::TypeChanger>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::TypeChanger<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::TypeChanger>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::TargetLegalizerInterface,mlir::detail::TargetLegalizerInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::TargetLegalizerInterface>();
    mlir::detail::TypeIDResolver<mlir::TargetLegalizerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::TargetLegalizerInterface>();
    mlir::detail::TypeIDResolver<mlir::TargetLegalizerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::collectRegions(mlir::FunctionOpInterface,mlir::RegionOpCreator *,mlir::CostModelParams const*,std::function<void ()(mlir::Operation *,mlir::Operation *)>)::$_7>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::RegionOp<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RegionOp>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_2_16(v2);
  }
}

void mlir::OpInterface<mlir::ExecutionCostOpInterface,mlir::detail::ExecutionCostOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::ExecutionCostOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ExecutionCostOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ExecutionCostOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ExecutionCostOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::MemoryEffectOpInterface::hasEffect<mlir::MemoryEffects::Write>()
{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffects::Write>();
    mlir::detail::TypeIDResolver<mlir::MemoryEffects::Write,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::placement::HostTypeCast,mlir::Type,mlir::Value &>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "placement.host_type_cast";
  *(a2 + 24) = 24;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

void mlir::placement::ReplacedOpsLiveOuts::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v50[4] = *MEMORY[0x1E69E9840];
  v4 = (*(*a2 + 16))(a2);
  v5 = *(v4 + 4);
  if (v5 >= *(v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v4, v5);
  }

  v6 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v7 = *(v6 + 17);
    v8 = *(v6 + 9);
  }

  else
  {
    v8 = 0;
    v7 = 0;
  }

  OUTLINED_FUNCTION_104();
  v10 = (*(v9 + 16))(a2);
  if (v7)
  {
    v11 = v10;
    OUTLINED_FUNCTION_104();
    (*(v12 + 160))(a2);
    v13 = v7 - 1;
    if (v13)
    {
      v14 = v8 + 56;
      do
      {
        v15 = v11[4];
        if (v11[3] - v15 > 1uLL)
        {
          *v15 = 8236;
          v11[4] += 2;
        }

        else
        {
          llvm::raw_ostream::write(v11, ", ", 2uLL);
        }

        v14 += 32;
        OUTLINED_FUNCTION_104();
        (*(v16 + 160))(a2);
        --v13;
      }

      while (v13);
    }
  }

  v48 = v50;
  v49 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(*this);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_104();
  (*(v17 + 192))(a2, v18, v19);
  OUTLINED_FUNCTION_104();
  v21 = (*(v20 + 16))(a2);
  v22 = *(v21 + 4);
  if (v22 >= *(v21 + 3))
  {
    llvm::raw_ostream::write(v21, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v21, v22);
  }

  OUTLINED_FUNCTION_104();
  v24 = (*(v23 + 16))(a2);
  v25 = v24[4];
  if (v24[3] == v25)
  {
    llvm::raw_ostream::write(v24, ":", 1uLL);
  }

  else
  {
    *v25 = 58;
    ++v24[4];
  }

  OUTLINED_FUNCTION_104();
  v27 = (*(v26 + 16))(a2);
  v28 = *(v27 + 4);
  if (v28 >= *(v27 + 3))
  {
    llvm::raw_ostream::write(v27, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v27, v28);
  }

  v29 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v30 = *(v29 + 17);
    v31 = *(v29 + 9);
  }

  else
  {
    v31 = 0;
    v30 = 0;
  }

  v44[0] = v31;
  v44[1] = v30;
  mlir::OperandRange::getTypes(v44, &AttrDictionary);
  v32 = v46;
  v33 = v47;
  if (v46 != v47)
  {
    v34 = AttrDictionary + 32 * v46;
    OUTLINED_FUNCTION_104();
    (*(v35 + 32))(a2, v36 & 0xFFFFFFFFFFFFFFF8);
    if (v32 + 1 != v33)
    {
      v37 = ~v32 + v33;
      v38 = v34 + 56;
      do
      {
        OUTLINED_FUNCTION_104();
        v40 = (*(v39 + 16))(a2);
        v41 = v40[4];
        if (v40[3] - v41 > 1uLL)
        {
          *v41 = 8236;
          v40[4] += 2;
        }

        else
        {
          llvm::raw_ostream::write(v40, ", ", 2uLL);
        }

        v38 += 32;
        OUTLINED_FUNCTION_104();
        (*(v42 + 32))(a2, v43 & 0xFFFFFFFFFFFFFFF8);
        --v37;
      }

      while (v37);
    }
  }

  if (v48 != v50)
  {
    free(v48);
  }
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::placement::ReplacedOpsLiveOuts,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::placement::ReplacedOpsLiveOuts::print(&v7, a3);
}

BOOL mlir::placement::RegionCall::verifyInvariantsImpl(_BOOL8 result, uint64_t a2, char *a3)
{
  v4 = *(a2 + 36);
  if (*(a2 + 36))
  {
    v5 = a2 - 16;
  }

  else
  {
    v5 = 0;
  }

  if (v4)
  {
    v6 = result;
    v7 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, v7);
      result = mlir::placement::__mlir_ods_local_type_constraint_PlacementOps5(*v6, (*(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), "result", 6, v7);
      if (!result)
      {
        break;
      }

      if (v4 == ++v7)
      {
        goto LABEL_8;
      }
    }

    v9 = 0;
  }

  else
  {
LABEL_8:
    v9 = 1;
  }

  *a3 = v9;
  return result;
}

void mlir::OpBuilder::create<mlir::placement::ReplacedOpsLiveOuts,llvm::SmallVector<mlir::Value,6u> &>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "placement.live_outs";
  *(a2 + 24) = 19;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

void mlir::detail::InterfaceMap::lookup<mlir::SymbolOpInterface>()
{
  {
    v0 = llvm::getTypeName<mlir::SymbolOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_17_12(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::HostTypeConversion>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HostTypeConversion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HostTypeConversion>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_13_14(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::placement::MemrefToTensor>>()
{
  {
    v0 = llvm::getTypeName<mlir::CompatibleReturnTypesInterface>();
    mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::HostTypeConversion,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::RegionOp,mlir::SymbolUserOpInterface::Trait,mlir::ExecutionCostOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::RegionOp<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RegionOp>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::RegionOp<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RegionOp>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::placement::TimerHandleType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::placement::TimerHandleType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::placement::TimerHandleType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::placement::TimerHandleType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::placement::TimerHandleType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::HostTypeConversion,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

unint64_t mlir::detail::LoopLikeOpInterfaceTrait<mlir::scf::ForOp>::getYieldedValues(uint64_t a1, uint64_t a2)
{
  v16[3] = *MEMORY[0x1E69E9840];
  v2 = *(((*a1 + 16 * ((*(*a1 + 44) >> 23) & 1) + ((*(*a1 + 44) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(*a1 + 40) + 8);
  if (v2)
  {
    v3 = (v2 - 8);
  }

  else
  {
    v3 = 0;
  }

  Terminator = mlir::Block::getTerminator(v3, a2);
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v5 = *(Terminator + 68);
  }

  else
  {
    v5 = 0;
  }

  mlir::MutableOperandRange::MutableOperandRange(v14, Terminator, 0, v5, 0, 0);
  v6 = mlir::MutableOperandRange::operator mlir::OperandRange(v14);
  v8 = v7;
  if (v15 != v16)
  {
    free(v15);
  }

  if (v8)
  {
    v9 = *(v6 + 2);
    OperandNumber = mlir::OpOperand::getOperandNumber(v6);
    if ((*(v9 + 46) & 0x80) != 0)
    {
      v11 = *(v9 + 72);
    }

    else
    {
      v11 = 0;
    }

    mlir::ValueRange::ValueRange(&v13, v11 + 32 * OperandNumber, v8);
  }

  else
  {
    mlir::ValueRange::ValueRange(&v13, 0, 0);
  }

  return v13;
}

uint64_t mlir::scf::ForOp::print(mlir::scf::ForOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v87 = *MEMORY[0x1E69E9840];
  (*(*v4 + 16))(v4);
  OUTLINED_FUNCTION_17_2();
  if (v7)
  {
    llvm::raw_ostream::write(v5, " ", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v5, v6);
  }

  OUTLINED_FUNCTION_105_0();
  OUTLINED_FUNCTION_14_12();
  OUTLINED_FUNCTION_104();
  (*(v8 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v9 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v12 > 2)
  {
    *(v11 + 2) = 32;
    OUTLINED_FUNCTION_15_4(v10, v11);
  }

  else
  {
    llvm::raw_ostream::write(v10, " = ", 3uLL);
  }

  OUTLINED_FUNCTION_104();
  (*(v13 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v14 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v17 > 3)
  {
    OUTLINED_FUNCTION_23_8(v15, v16);
  }

  else
  {
    llvm::raw_ostream::write(v15, " to ", 4uLL);
  }

  OUTLINED_FUNCTION_104();
  (*(v18 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v19 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v22 > 5)
  {
    *(v21 + 4) = 8304;
    OUTLINED_FUNCTION_160(v21);
    *(v24 + 32) = v23 + 6;
  }

  else
  {
    llvm::raw_ostream::write(v20, " step ", 6uLL);
  }

  OUTLINED_FUNCTION_104();
  (*(v25 + 160))(v2);
  OUTLINED_FUNCTION_54_3();
  v28 = *(v27 + 48);
  v29 = ((*(v27 + 56) - v28) >> 3) - 1;
  if ((v30 & 0x800000) != 0)
  {
    v31 = *(v26 + 68);
    v32 = *(v26 + 72);
    v33 = v31 - 3;
  }

  else
  {
    v32 = 0;
    v33 = -3;
  }

  mlir::ValueRange::ValueRange(&AttrDictionary, v32 + 96, v33);
  printInitializationList(v2, (v28 + 8), v29, AttrDictionary, v85, " iter_args", 0xAuLL);
  OUTLINED_FUNCTION_47_0();
  if ((v35 & 0x80) == 0 || *(v34 + 68) != 3)
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v38 > 4)
    {
      *(v37 + 4) = 40;
      OUTLINED_FUNCTION_160(v37);
      *(v40 + 32) = v39 + 5;
    }

    else
    {
      llvm::raw_ostream::write(v36, " -> (", 5uLL);
    }

    OUTLINED_FUNCTION_47_0();
    if (v50 < 0)
    {
      v51 = *(v49 + 72);
    }

    else
    {
      LOBYTE(v51) = 0;
    }

    v52 = OUTLINED_FUNCTION_51_2(v41, v42, v43, v44, v45, v46, v47, v48, v83, v51 + 96);
    mlir::OperandRange::getTypes(v52, v53);
    v54 = v85;
    v55 = v86;
    if (v85 != v86)
    {
      v56 = AttrDictionary + 32 * v85;
      OUTLINED_FUNCTION_104();
      v57 = OUTLINED_FUNCTION_12_4();
      v58(v57);
      if (v54 + 1 != v55)
      {
        v59 = ~v54 + v55;
        v60 = v56 + 56;
        do
        {
          (*(*v2 + 16))(v2);
          OUTLINED_FUNCTION_25_2();
          if (!v7 & v63)
          {
            *v62 = 8236;
            OUTLINED_FUNCTION_24_2(v61);
          }

          else
          {
            llvm::raw_ostream::write(v61, ", ", 2uLL);
          }

          v60 += 32;
          OUTLINED_FUNCTION_104();
          v64 = OUTLINED_FUNCTION_12_4();
          v65(v64);
          --v59;
        }

        while (v59);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v63)
    {
      llvm::raw_ostream::write(v66, 41);
    }

    else
    {
      *(v66 + 4) = v67 + 1;
      *v67 = 41;
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v63)
  {
    llvm::raw_ostream::write(v68, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v68, v69);
  }

  OUTLINED_FUNCTION_105_0();
  OUTLINED_FUNCTION_14_12();
  OUTLINED_FUNCTION_121_1();
  AttrDictionary = v70;
  if (!mlir::Type::isIndex(&AttrDictionary))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v73 > 2)
    {
      *(v72 + 2) = 32;
      OUTLINED_FUNCTION_15_4(v71, v72);
    }

    else
    {
      llvm::raw_ostream::write(v71, " : ", 3uLL);
    }

    OUTLINED_FUNCTION_104();
    (*(v74 + 32))(v2);
    OUTLINED_FUNCTION_104();
    (*(v75 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v63)
    {
      llvm::raw_ostream::write(v76, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v76, v77);
    }
  }

  OUTLINED_FUNCTION_96_2();
  OUTLINED_FUNCTION_104();
  v78 = OUTLINED_FUNCTION_160_0();
  v79(v78);
  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_118_2();
  OUTLINED_FUNCTION_104();
  v80 = OUTLINED_FUNCTION_120_2();
  return v81(v80);
}

uint64_t mlir::scf::ForOp::getInitsMutable(mlir::scf::ForOp *this)
{
  v11[3] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_132_1();
  mlir::MutableOperandRange::MutableOperandRange(v1, v2, v3, v4, v5, v6);
  v7 = mlir::MutableOperandRange::operator mlir::OperandRange(&v9);
  if (v10 != v11)
  {
    free(v10);
  }

  return v7;
}

void mlir::scf::promote(uint64_t a1, uint64_t a2)
{
  v85[6] = *MEMORY[0x1E69E9840];
  v74 = a2;
  v64 = *(a1 + 24);
  OUTLINED_FUNCTION_117_2();
  v65 = v3;
  v4 = (v3 - 16);
  OUTLINED_FUNCTION_8_11();
  OUTLINED_FUNCTION_14_12();
  if (v7)
  {
    v8 = 0;
  }

  else
  {
    v8 = v6;
  }

  Terminator = mlir::Block::getTerminator(v8, v5);
  mlir::scf::ForallOp::getLowerBound(&v74, v4, &v82);
  v10 = *(v74 + 44);
  v11 = (v74 + 16 * ((v10 >> 23) & 1));
  v12 = v11[27];
  if ((v10 & 0x800000) != 0)
  {
    v13 = *(v74 + 72);
  }

  else
  {
    v13 = 0;
  }

  v14 = (v11[25] + v11[24] + v11[26]);
  v15 = (v12 + v14);
  v16 = v15 - v14;
  v17 = v83;
  v18 = v15 - v14 + v83;
  if (v18 > v84)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v82, v85, v18, 8);
    v17 = v83;
  }

  if (v12)
  {
    v19 = (v82 + 8 * v17);
    if (v16 >= 0x13 && ((v20 = v82 + 8 * (v17 + v15 - v14), v19 < v13 + 32 * v15) ? (v21 = v13 + 32 * v14 + 24 >= v20) : (v21 = 1), v21))
    {
      v22 = (v19 + 2);
      do
      {
        OUTLINED_FUNCTION_35_7(v22);
      }

      while (v25 != -4);
      v19 = v24;
    }

    else
    {
      v23 = 0;
    }

    v26 = v23 + v14 - v15;
    v27 = (32 * v23 + 32 * v14 + v13 + 24);
    do
    {
      v28 = *v27;
      v27 += 4;
      *v19++ = v28;
      v21 = __CFADD__(v26++, 1);
    }

    while (!v21);
    LODWORD(v17) = v83;
  }

  v83 = v17 + v16;
  v29 = v74;
  OUTLINED_FUNCTION_8_11();
  OUTLINED_FUNCTION_14_12();
  if (v7)
  {
    v32 = 0;
  }

  else
  {
    v32 = v31;
  }

  v33 = *(v29 + 16);
  mlir::ValueRange::ValueRange(&v79, v82, v30);
  OUTLINED_FUNCTION_104();
  (*(v34 + 32))(a1, v32, v33, v29);
  v35 = *(v74 + 16);
  v37 = *(MPSGraphDelegateCompiler.precompilationDescriptor.modify(v74, v36) + 8);
  *(a1 + 24) = v35;
  *(a1 + 32) = v37;
  v79 = v81;
  v80 = 0x600000000;
  v38 = *(v74 + 36);
  if (v38 >= 7)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v79, v81, v38, 8);
  }

  OUTLINED_FUNCTION_8_11();
  OUTLINED_FUNCTION_14_12();
  if (v7)
  {
    v41 = 0;
  }

  else
  {
    v41 = v40;
  }

  v42 = v41 + 32;
  v43 = *(v41 + 40);
  if (v43 != v41 + 32)
  {
    do
    {
      v73 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v43, v39);
      mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v73, 1u);
      OUTLINED_FUNCTION_107_2();
      v72 = *(v44 + 24);
      mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v73, 0);
      OUTLINED_FUNCTION_107_2();
      v45 = *(v74 + 24);
      OUTLINED_FUNCTION_121_1();
      v70 = v46;
      v71 = v47;
      mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v73, 2u);
      OUTLINED_FUNCTION_49_5();
      v77 = v48;
      v78 = v49;
      mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v73, 3u);
      OUTLINED_FUNCTION_49_5();
      v75 = v50;
      v76 = v51;
      mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v73, 4u);
      OUTLINED_FUNCTION_49_5();
      v69[0] = v52;
      v69[1] = v53;
      v68[0] = mlir::memref::ReinterpretCastOp::getStaticOffsets(&v73);
      v68[1] = v54;
      v67[0] = mlir::memref::ReinterpretCastOp::getStaticSizes(&v73);
      v67[1] = v55;
      v66[0] = mlir::memref::ReinterpretCastOp::getStaticStrides(&v73);
      v66[1] = v56;
      v57 = mlir::OpBuilder::create<mlir::tensor::InsertSliceOp,mlir::Type,mlir::Value &,mlir::Value &,mlir::OperandRange,mlir::OperandRange,mlir::OperandRange,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>>(v4, v45, &v70, &v71, &v72, &v77, &v75, v69, v68, v67, v66);
      v58 = v80;
      if (v80 >= HIDWORD(v80))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v79, v81, v80 + 1, 8);
        v58 = v80;
      }

      *(v79 + v58) = v57 - 16;
      LODWORD(v80) = v80 + 1;
      v43 = *(v43 + 8);
    }

    while (v43 != v42);
  }

  v59 = *(v74 + 36);
  if (v59)
  {
    v60 = v74 - 16;
  }

  else
  {
    v60 = 0;
  }

  mlir::ValueRange::ValueRange(&v77, v60, v59);
  mlir::ValueRange::ValueRange(&v75, v79, v80);
  mlir::RewriterBase::replaceAllUsesWith(a1, v77, v78, v75, v76);
  OUTLINED_FUNCTION_104();
  (*(v61 + 16))(a1, Terminator);
  OUTLINED_FUNCTION_104();
  (*(v62 + 16))(a1);
  if (v79 != v81)
  {
    free(v79);
  }

  OUTLINED_FUNCTION_65_4();
  if (!v7)
  {
    free(v63);
  }

  if (v64)
  {
    *v65 = v64;
  }

  else
  {
    *v65 = 0;
    *(v65 + 8) = 0;
  }
}

void mlir::scf::replaceAndCastForOpIterArg(uint64_t a1@<X0>, mlir::Operation *a2@<X1>, mlir::OpOperand *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, unint64_t *a6@<X8>)
{
  v104[6] = *MEMORY[0x1E69E9840];
  v11 = *(a4 + 8);
  v91 = *(*(a3 + 3) + 8);
  v102 = v104;
  v103 = 0x600000000;
  v89 = v11;
  OUTLINED_FUNCTION_132_1();
  mlir::MutableOperandRange::MutableOperandRange(v12, v13, v14, v15, v16, v17);
  v18 = mlir::MutableOperandRange::begin(&AttrDictionary);
  v19 = mlir::MutableOperandRange::end(&AttrDictionary);
  if (v18 != v19)
  {
    v34 = v19;
    do
    {
      OperandNumber = mlir::OpOperand::getOperandNumber(v18);
      if (OperandNumber == mlir::OpOperand::getOperandNumber(a3))
      {
        v36 = v103;
        v37 = HIDWORD(v103);
        v38 = a4;
      }

      else
      {
        v38 = *(v18 + 3);
        v36 = v103;
        v37 = HIDWORD(v103);
      }

      if (v36 >= v37)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v102, v104, v36 + 1, 8);
        v36 = v103;
      }

      v102[v36] = v38;
      LODWORD(v103) = v103 + 1;
      v18 = (v18 + 32);
    }

    while (v18 != v34);
  }

  if (v97[0] != &v98)
  {
    free(v97[0]);
  }

  v20 = *(a2 + 3);
  v21 = *(a2 + 9);
  AttrDictionary = *(v21 + 24);
  v99 = *(v21 + 56);
  v93 = *(v21 + 88);
  v22 = mlir::OpBuilder::create<mlir::scf::ForOp,mlir::Value,mlir::Value,mlir::Value,llvm::SmallVector<mlir::Value,6u> &>((a1 + 8), v20, &AttrDictionary, &v99, &v93, &v102);
  v94 = v22;
  AttrDictionary = mlir::Operation::getAttrDictionary(a2);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_118_2();
  mlir::Operation::setAttrs(v22, v23, v24);
  OUTLINED_FUNCTION_8_11();
  OUTLINED_FUNCTION_14_12();
  if (v26)
  {
    v27 = 0;
  }

  else
  {
    v27 = v25;
  }

  v29 = *(v27 + 6);
  v28 = *(v27 + 7);
  v99 = v101;
  v100 = 0x400000000;
  v30 = v28 - v29;
  v31 = (v28 - v29) >> 3;
  if (v31 < 5)
  {
    v32 = 0;
    v33 = 0;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v99, v101, v31, 8);
    v32 = v100;
    v33 = v100;
  }

  if (v29 != v28)
  {
    v39 = v99 + 8 * v32;
    if (v30 - 8 < 0x38)
    {
      goto LABEL_71;
    }

    if ((v39 - v29) < 0x20)
    {
      goto LABEL_71;
    }

    v40 = ((v30 - 8) >> 3) + 1;
    v39 += 8 * (v40 & 0x3FFFFFFFFFFFFFFCLL);
    v41 = (v29 + 16);
    v42 = v99 + 8 * v32 + 16;
    v43 = v40 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v44 = *v41;
      *(v42 - 1) = *(v41 - 1);
      *v42 = v44;
      v41 += 2;
      v42 += 2;
      v43 -= 4;
    }

    while (v43);
    v29 += 8 * (v40 & 0x3FFFFFFFFFFFFFFCLL);
    if (v40 != (v40 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_71:
      do
      {
        v45 = *v29;
        v29 += 8;
        *v39 = v45;
        v39 += 8;
      }

      while (v29 != v28);
    }
  }

  LODWORD(v100) = v33 + (v30 >> 3);
  v46 = (a1 + 24);
  v90 = *(a1 + 24);
  v47 = *(v27 + 5);
  *(a1 + 24) = v27;
  *(a1 + 32) = v47;
  v48 = mlir::OpOperand::getOperandNumber(a3);
  TiedLoopRegionIterArg = mlir::detail::LoopLikeOpInterfaceTrait<mlir::scf::ForOp>::getTiedLoopRegionIterArg(&v94, *(v22 + 72) + 32 * v48);
  v50 = (*a5)(*(a5 + 8), a1 + 8, *(v94 + 24), v91 & 0xFFFFFFFFFFFFFFF8, TiedLoopRegionIterArg);
  *(v99 + *(TiedLoopRegionIterArg + 24)) = v50;
  OUTLINED_FUNCTION_8_11();
  OUTLINED_FUNCTION_14_12();
  if (v26)
  {
    v53 = 0;
  }

  else
  {
    v53 = v52;
  }

  mlir::ValueRange::ValueRange(&AttrDictionary, v51, v100);
  mlir::RewriterBase::mergeBlocks(a1, v53, v27, AttrDictionary, v96);
  Terminator = mlir::Block::getTerminator(v27, v54);
  v56 = *(Terminator + 16);
  v58 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(Terminator, v57);
  *v46 = v56;
  *(a1 + 32) = v58;
  v59 = (*(TiedLoopRegionIterArg + 24) - 1);
  v60 = (*a5)(*(a5 + 8), a1 + 8, *(v94 + 24), v89 & 0xFFFFFFFFFFFFFFF8, *(*(Terminator + 72) + 32 * v59 + 24));
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v61 = *(Terminator + 72);
    v62 = *(Terminator + 68);
    AttrDictionary = v97;
    v96 = 0x600000000;
    if (v62 < 7)
    {
      if (!v62)
      {
        v75 = 0;
        v76 = v97;
        goto LABEL_46;
      }

      v63 = 0;
      v64 = v97;
    }

    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(&AttrDictionary, v97, v62, 8);
      v63 = v96;
      v64 = AttrDictionary;
    }

    v65 = &v64[8 * v63];
    if (v62 >= 0xD && ((v66 = &v64[8 * v63 + 8 * v62], v65 < v61 + 32 * v62) ? (v67 = v61 + 24 >= v66) : (v67 = 1), v67))
    {
      v68 = (v65 + 16);
      do
      {
        OUTLINED_FUNCTION_35_7(v68);
      }

      while (v71 != 4);
      v65 = v70;
    }

    else
    {
      v69 = 0;
    }

    v72 = v62 - v69;
    v73 = (v61 + 32 * v69 + 24);
    do
    {
      v74 = *v73;
      v73 += 4;
      *v65 = v74;
      v65 += 8;
      --v72;
    }

    while (v72);
    v75 = v96;
    v76 = AttrDictionary;
  }

  else
  {
    LODWORD(v62) = 0;
    v75 = 0;
    v76 = v97;
    AttrDictionary = v97;
    HIDWORD(v96) = 6;
  }

LABEL_46:
  LODWORD(v96) = v75 + v62;
  v76[v59] = v60;
  mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>((a1 + 8), *(v94 + 24), &AttrDictionary);
  (*(*a1 + 16))(a1, Terminator);
  v77 = *(v94 + 16);
  v79 = *(MPSGraphDelegateCompiler.precompilationDescriptor.modify(v94, v78) + 8);
  *(a1 + 24) = v77;
  *(a1 + 32) = v79;
  v80 = v94;
  v81 = *(v94 + 36);
  if (v81)
  {
    v82 = v94 - 16;
  }

  else
  {
    v82 = 0;
  }

  v83 = (a6 + 2);
  *a6 = (a6 + 2);
  a6[1] = 0x600000000;
  if (v81 < 7)
  {
    if (!v81)
    {
      v87 = 0;
      goto LABEL_56;
    }

    v84 = 0;
  }

  else
  {
    OUTLINED_FUNCTION_124_2(a6, v83);
    v84 = *(a6 + 2);
    v83 = *a6;
  }

  v85 = 0;
  v86 = v83 + 8 * v84;
  do
  {
    *(v86 + 8 * v85) = mlir::detail::OpResultImpl::getNextResultAtOffset(v82, v85);
    ++v85;
  }

  while (v81 != v85);
  v87 = *(a6 + 2);
  v80 = v94;
  v83 = *a6;
LABEL_56:
  *(a6 + 2) = v87 + v81;
  *(*a6 + 8 * v59) = (*a5)(*(a5 + 8), a1 + 8, *(v80 + 24), v91 & 0xFFFFFFFFFFFFFFF8, *(v83 + 8 * v59));
  if (AttrDictionary != v97)
  {
    free(AttrDictionary);
  }

  if (v90)
  {
    *v46 = v90;
  }

  else
  {
    *v46 = 0;
    *(a1 + 32) = 0;
  }

  if (v99 != v101)
  {
    free(v99);
  }

  OUTLINED_FUNCTION_152_1();
  if (!v26)
  {
    free(v88);
  }
}

uint64_t mlir::detail::LoopLikeOpInterfaceTrait<mlir::scf::ForOp>::getTiedLoopRegionIterArg(uint64_t *a1, uint64_t a2)
{
  v17[3] = *MEMORY[0x1E69E9840];
  v4 = *a1;
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    v5 = *(v4 + 68) - 3;
  }

  else
  {
    v5 = -3;
  }

  mlir::MutableOperandRange::MutableOperandRange(v15, v4, 3, v5, 0, 0);
  v6 = mlir::MutableOperandRange::operator mlir::OperandRange(v15);
  v8 = v7;
  if (v16 != v17)
  {
    free(v16);
  }

  v9 = 0;
  do
  {
    v10 = -32 * v8 == v9 || v6 == a2;
    v6 += 32;
    v11 = v9 - 32;
    v9 -= 32;
  }

  while (!v10);
  if (v11 == 32 * ~v8)
  {
    return 0;
  }

  v13 = *(((*a1 + 16 * ((*(*a1 + 44) >> 23) & 1) + ((*(*a1 + 44) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(*a1 + 40) + 8);
  if (v13)
  {
    v14 = v13 - 8;
  }

  else
  {
    v14 = 0;
  }

  return *(*(v14 + 48) + ((-32 - v11) >> 2) + 8);
}

uint64_t mlir::scf::ForallOp::getDynamicStep(mlir::scf::ForallOp *this)
{
  v1 = *(*this + 44);
  if ((v1 & 0x800000) != 0)
  {
    v3 = *(*this + 72);
  }

  else
  {
    v3 = 0;
  }

  v2 = *this + 16 * ((v1 >> 23) & 1);
  return v3 + 32 * (*(v2 + 100) + *(v2 + 96));
}

uint64_t mlir::scf::ForallOp::print(mlir::scf::ForallOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v170 = *MEMORY[0x1E69E9840];
  v5 = *v4;
  (*(*v6 + 16))(v6);
  OUTLINED_FUNCTION_25_2();
  if (!v10 & v9)
  {
    *v8 = 10272;
    OUTLINED_FUNCTION_24_2(v7);
  }

  else
  {
    llvm::raw_ostream::write(v7, " (", 2uLL);
  }

  mlir::scf::ForallOp::getLoopInductionVars(v3, &__src);
  v153 = &v155;
  v154 = 0x600000000;
  v11 = v162;
  if (v162)
  {
    if (v162 < 7)
    {
      v13 = &v155;
      v12 = v162;
    }

    else
    {
      OUTLINED_FUNCTION_139_1(&v153, &v155);
      v12 = v162;
      if (!v162)
      {
LABEL_10:
        LODWORD(v154) = v11;
        goto LABEL_11;
      }

      v13 = v153;
    }

    memcpy(v13, __src, 8 * v12);
    goto LABEL_10;
  }

LABEL_11:
  if (v169 == 1)
  {
    OUTLINED_FUNCTION_65_4();
    if (!v10)
    {
      free(v14);
      v11 = v154;
    }
  }

  v15 = v153;
  OUTLINED_FUNCTION_104();
  v17 = (*(v16 + 16))(v2);
  if (v11)
  {
    v18 = v17;
    OUTLINED_FUNCTION_104();
    (*(v19 + 160))(v2);
    if (v11 != 1)
    {
      v20 = v15 + 8;
      v21 = 8 * v11 - 8;
      v11 = ", ";
      do
      {
        v22 = v18[4];
        if (v18[3] - v22 > 1uLL)
        {
          *v22 = 8236;
          v18[4] += 2;
        }

        else
        {
          llvm::raw_ostream::write(v18, ", ", 2uLL);
        }

        v20 += 8;
        OUTLINED_FUNCTION_104();
        (*(v23 + 160))(v2);
        v21 -= 8;
      }

      while (v21);
    }
  }

  if (v153 != &v155)
  {
    free(v153);
  }

  isNormalized = mlir::scf::ForallOp::isNormalized(v3);
  OUTLINED_FUNCTION_104();
  (*(v25 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (isNormalized)
  {
    if (v28 > 4)
    {
      *(v27 + 4) = 32;
      OUTLINED_FUNCTION_160(v27);
      *(v30 + 32) = v29 + 5;
    }

    else
    {
      llvm::raw_ostream::write(v26, ") in ", 5uLL);
    }

    OUTLINED_FUNCTION_103_1();
    OUTLINED_FUNCTION_149_1();
  }

  else
  {
    if (v28 > 3)
    {
      OUTLINED_FUNCTION_23_8(v26, v27);
    }

    else
    {
      llvm::raw_ostream::write(v26, ") = ", 4uLL);
    }

    v32 = *(*v3 + 44);
    v33 = *v3 + 64 + 16 * ((v32 >> 23) & 1);
    v34 = *(v33 + 32);
    if ((v32 & 0x800000) != 0)
    {
      v35 = *(*v3 + 72);
    }

    else
    {
      v35 = 0;
    }

    OUTLINED_FUNCTION_138_1(*(v33 + 8), v129, v136, v143, v150, v151, v152, v153, v154, v155, v156, v157, v158, v159, v160, __src);
    OUTLINED_FUNCTION_44_0();
    mlir::ValueRange::ValueRange(v36, v37, v38);
    v39 = OUTLINED_FUNCTION_34_8();
    OUTLINED_FUNCTION_90_4(v39, v40, v35, v34, v41, v42, v43, v44, v130, v137, v144);
    OUTLINED_FUNCTION_104();
    (*(v45 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v48 > 3)
    {
      OUTLINED_FUNCTION_23_8(v46, v47);
    }

    else
    {
      llvm::raw_ostream::write(v46, " to ", 4uLL);
    }

    OUTLINED_FUNCTION_103_1();
    OUTLINED_FUNCTION_149_1();
    OUTLINED_FUNCTION_138_1(v49, v131, v138, v145, v150, v151, v152, v153, v154, v155, v156, v157, v158, v159, v160, __src);
    OUTLINED_FUNCTION_44_0();
    mlir::ValueRange::ValueRange(v50, v51, v52);
    v53 = OUTLINED_FUNCTION_34_8();
    OUTLINED_FUNCTION_90_4(v53, v54, v34, v35, v55, v56, v57, v58, v132, v139, v146);
    OUTLINED_FUNCTION_104();
    (*(v59 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v62 > 5)
    {
      *(v61 + 4) = 8304;
      OUTLINED_FUNCTION_160(v61);
      *(v64 + 32) = v63 + 6;
    }

    else
    {
      llvm::raw_ostream::write(v60, " step ", 6uLL);
    }

    v65 = *(*v3 + 44);
    v66 = *v3 + 16 * ((v65 >> 23) & 1);
    if ((v65 & 0x800000) != 0)
    {
      v67 = *(*v3 + 72);
    }

    else
    {
      v67 = 0;
    }

    v68 = (*(v66 + 100) + *(v66 + 96));
    isNormalized = v67 + 32 * v68;
    v11 = (*(v66 + 104) + v68) - v68;
    v31 = *(v66 + 80);
  }

  OUTLINED_FUNCTION_138_1(v31, v129, v136, v143, v150, v151, v152, v153, v154, v155, v156, v157, v158, v159, v160, __src);
  OUTLINED_FUNCTION_44_0();
  mlir::ValueRange::ValueRange(v69, v70, v71);
  v72 = OUTLINED_FUNCTION_34_8();
  OUTLINED_FUNCTION_90_4(v72, v73, isNormalized, v11, v74, v75, v76, v77, v133, v140, v147);
  OUTLINED_FUNCTION_9_11();
  OUTLINED_FUNCTION_96_2();
  OUTLINED_FUNCTION_51_5();
  v79 = *(v78 + 48);
  v80 = (*(v78 + 56) - v79) >> 3;
  OUTLINED_FUNCTION_138_1(*(v81 + 72), v134, v141, v148, v150, v151, v152, v153, v154, v155, v156, v157, v158, v159, v160, __src);
  v83 = v80 - v82;
  v84 = (v79 + 8 * v82);
  v85 = *(*v3 + 44);
  v86 = (*v3 + 16 * ((v85 >> 23) & 1));
  v87 = v86[24];
  v88 = v86[25];
  v90 = v86[26];
  v89 = v86[27];
  if ((v85 & 0x800000) != 0)
  {
    v91 = *(*v3 + 72);
  }

  else
  {
    v91 = 0;
  }

  mlir::ValueRange::ValueRange(&__src, v91 + 32 * (v88 + v87 + v90), (v89 + v88 + v87 + v90) - (v88 + v87 + v90));
  printInitializationList(v2, v84, v83, __src, v162, " shared_outs", 0xCuLL);
  OUTLINED_FUNCTION_104();
  (*(v92 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v10)
  {
    llvm::raw_ostream::write(v93, " ", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v93, v94);
  }

  OUTLINED_FUNCTION_9_11();
  OUTLINED_FUNCTION_96_2();
  OUTLINED_FUNCTION_51_5();
  v96 = *(v95 + 56) - *(v95 + 48);
  OUTLINED_FUNCTION_138_1(*(v97 + 72), v135, v142, v149, v150, v151, v152, v153, v154, v155, v156, v157, v158, v159, v160, __src);
  if (v98 != v96 >> 3)
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v101 > 3)
    {
      OUTLINED_FUNCTION_23_8(v99, v100);
    }

    else
    {
      llvm::raw_ostream::write(v99, "-> (", 4uLL);
    }

    OUTLINED_FUNCTION_34_2();
    v153 = v102;
    v154 = v103;
    mlir::OperandRange::getTypes(&v153, &__src);
    v104 = v162;
    v105 = v164;
    if (v162 != v164)
    {
      v106 = __src;
      mlir::detail::OpResultImpl::getNextResultAtOffset(__src, v162);
      OUTLINED_FUNCTION_104();
      v107 = OUTLINED_FUNCTION_12_4();
      v108(v107);
      for (i = v104 + 1; v105 != i; ++i)
      {
        (*(*v2 + 16))(v2);
        OUTLINED_FUNCTION_25_2();
        if (!v10 & v9)
        {
          *v111 = 8236;
          OUTLINED_FUNCTION_24_2(v110);
        }

        else
        {
          llvm::raw_ostream::write(v110, ", ", 2uLL);
        }

        mlir::detail::OpResultImpl::getNextResultAtOffset(v106, i);
        OUTLINED_FUNCTION_104();
        v112 = OUTLINED_FUNCTION_12_4();
        v113(v112);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_25_2();
    if (!v10 & v9)
    {
      *v115 = 8233;
      OUTLINED_FUNCTION_24_2(v114);
    }

    else
    {
      llvm::raw_ostream::write(v114, ") ", 2uLL);
    }
  }

  OUTLINED_FUNCTION_94_0();
  OUTLINED_FUNCTION_96_2();
  v116 = OUTLINED_FUNCTION_160_0();
  v117(v116);
  __src = mlir::Operation::getAttrDictionary(v5);
  mlir::ArrayAttr::getValue(&__src);
  OUTLINED_FUNCTION_146_1();
  v153 = *(v118 - 8);
  __src = mlir::OpaqueAttr::getAttrData(&v153);
  v162 = v119;
  OUTLINED_FUNCTION_108_2();
  v152 = *(v120 + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v152);
  v164 = v121;
  OUTLINED_FUNCTION_108_2();
  v151 = *(v122 + 24);
  v165 = mlir::OpaqueAttr::getAttrData(&v151);
  v166 = v123;
  OUTLINED_FUNCTION_108_2();
  v150 = *(v124 + 16);
  v167 = mlir::OpaqueAttr::getAttrData(&v150);
  v168 = v125;
  OUTLINED_FUNCTION_104();
  v126 = OUTLINED_FUNCTION_88_2();
  return v127(v126);
}

void mlir::scf::ForallOp::getLoopLowerBounds(mlir::scf::ForallOp *this@<X0>, uint64_t a2@<X8>)
{
  OUTLINED_FUNCTION_127_2(this, *MEMORY[0x1E69E9840]);
  OUTLINED_FUNCTION_48_5();
  v4 = OUTLINED_FUNCTION_133_1(*(v3 + 72), v23, v26, v27, v28);
  OUTLINED_FUNCTION_94_0();
  if ((v7 & 0x800000) != 0)
  {
    v8 = *(v5 + 72);
  }

  else
  {
    v8 = 0;
  }

  v9 = mlir::ValueRange::ValueRange(&v26, v8, *(v6 + 96));
  OUTLINED_FUNCTION_61_3(v9, v10, v11, v12, v13, v14, v15, v16, v24, v26, v27, v28);
  OUTLINED_FUNCTION_94_2();
  OUTLINED_FUNCTION_47_5(COERCE_DOUBLE(0x600000000));
  if (v4 && (v17 & 1) == 0)
  {
    OUTLINED_FUNCTION_32_8();
    if (v21)
    {
      if (v4 < 7 || (OUTLINED_FUNCTION_74_3(v18, v19), v20 = v28, v29))
      {
        OUTLINED_FUNCTION_126_2(v20);
      }

      *(a2 + 8) = v4;
    }

    else
    {
      OUTLINED_FUNCTION_31_7(v20, v25, v26, v27, v28, v29, v30);
    }

    v29 = 0;
  }

  *(a2 + 64) = 1;
  OUTLINED_FUNCTION_32_8();
  if (!v21)
  {
    free(v22);
  }
}

void mlir::scf::ForallOp::getLoopUpperBounds(mlir::scf::ForallOp *this@<X0>, uint64_t a2@<X8>)
{
  OUTLINED_FUNCTION_127_2(this, *MEMORY[0x1E69E9840]);
  OUTLINED_FUNCTION_48_5();
  v5 = OUTLINED_FUNCTION_133_1(*(v4 + 88), v25, v28, v29, v30);
  v6 = *(*this + 44);
  v7 = *this + 16 * ((v6 >> 23) & 1);
  v8 = *(v7 + 96);
  v9 = *(v7 + 100);
  if ((v6 & 0x800000) != 0)
  {
    v10 = *(*this + 72);
  }

  else
  {
    v10 = 0;
  }

  v11 = mlir::ValueRange::ValueRange(&v28, v10 + 32 * v8, (v9 + v8) - v8);
  OUTLINED_FUNCTION_61_3(v11, v12, v13, v14, v15, v16, v17, v18, v26, v28, v29, v30);
  OUTLINED_FUNCTION_94_2();
  OUTLINED_FUNCTION_47_5(COERCE_DOUBLE(0x600000000));
  if (v5 && (v19 & 1) == 0)
  {
    OUTLINED_FUNCTION_32_8();
    if (v23)
    {
      if (v5 < 7 || (OUTLINED_FUNCTION_74_3(v20, v21), v22 = v30, v31))
      {
        OUTLINED_FUNCTION_126_2(v22);
      }

      *(a2 + 8) = v5;
    }

    else
    {
      OUTLINED_FUNCTION_31_7(v22, v27, v28, v29, v30, v31, v32);
    }

    v31 = 0;
  }

  *(a2 + 64) = 1;
  OUTLINED_FUNCTION_32_8();
  if (!v23)
  {
    free(v24);
  }
}

void mlir::scf::ForallOp::getLoopSteps(mlir::scf::ForallOp *this@<X0>, uint64_t a2@<X8>)
{
  OUTLINED_FUNCTION_127_2(this, *MEMORY[0x1E69E9840]);
  OUTLINED_FUNCTION_48_5();
  v5 = OUTLINED_FUNCTION_133_1(*(v4 + 80), v26, v29, v30, v31);
  v6 = *(*this + 44);
  v7 = (*this + 16 * ((v6 >> 23) & 1));
  v8 = v7[24];
  v9 = v7[25];
  v10 = v7[26];
  if ((v6 & 0x800000) != 0)
  {
    v11 = *(*this + 72);
  }

  else
  {
    v11 = 0;
  }

  v12 = mlir::ValueRange::ValueRange(&v29, v11 + 32 * (v9 + v8), (v10 + v9 + v8) - (v9 + v8));
  OUTLINED_FUNCTION_61_3(v12, v13, v14, v15, v16, v17, v18, v19, v27, v29, v30, v31);
  OUTLINED_FUNCTION_94_2();
  OUTLINED_FUNCTION_47_5(COERCE_DOUBLE(0x600000000));
  if (v5 && (v20 & 1) == 0)
  {
    OUTLINED_FUNCTION_32_8();
    if (v24)
    {
      if (v5 < 7 || (OUTLINED_FUNCTION_74_3(v21, v22), v23 = v31, v32))
      {
        OUTLINED_FUNCTION_126_2(v23);
      }

      *(a2 + 8) = v5;
    }

    else
    {
      OUTLINED_FUNCTION_31_7(v23, v28, v29, v30, v31, v32, v33);
    }

    v32 = 0;
  }

  *(a2 + 64) = 1;
  OUTLINED_FUNCTION_32_8();
  if (!v24)
  {
    free(v25);
  }
}

uint64_t mlir::scf::ParallelOp::verify(mlir::scf::ParallelOp *this)
{
  v2 = this;
  v277 = *MEMORY[0x1E69E9840];
  v3 = *(*this + 44);
  v4 = (*this + 16 * ((v3 >> 23) & 1));
  v5 = v4[18];
  if ((v3 & 0x800000) == 0)
  {
    v6 = 0;
    if (v5)
    {
      goto LABEL_3;
    }

LABEL_154:
    OUTLINED_FUNCTION_100_3();
    OUTLINED_FUNCTION_75_4(v175, v176, v177, v178, v179);
    mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v252);
    OUTLINED_FUNCTION_119_2();
    if (v188)
    {
      mlir::InFlightDiagnostic::report(&v252);
    }

    if (v276 != 1)
    {
      return v2;
    }

    v53 = OUTLINED_FUNCTION_106_1(v180, v181, v182, v183, v184, v185, v186, v187, v234, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, v267, v268, __p, v270, v271, v272, v273, v274, v275);
    if (!v14)
    {
      free(v53);
    }

    v189 = v272;
    if (v272)
    {
      v190 = OUTLINED_FUNCTION_72_2(v53, v54, v55, v56, v57, v58, v59, v60, v235, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, v267, v268, __p, v270, v271, v272, v273);
      if (!v14)
      {
        do
        {
          v190 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v190 - 8));
        }

        while (v190 != v189);
        v191 = v272;
      }

      OUTLINED_FUNCTION_165_0(v191, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, v267, v268, __p, v270, v271, v272, v273);
    }

    v64 = __p;
    if (!__p)
    {
      goto LABEL_171;
    }

    v65 = OUTLINED_FUNCTION_105_2();
    if (v14)
    {
      goto LABEL_170;
    }

    do
    {
      v193 = *--v1;
      v192 = v193;
      *v1 = 0;
      if (v193)
      {
        operator delete[](v192);
      }
    }

    while (v1 != v64);
LABEL_169:
    v65 = __p;
LABEL_170:
    v270 = v64;
    operator delete(v65);
LABEL_171:
    v132 = OUTLINED_FUNCTION_154_0(v53, v54, v55, v56, v57, v58, v59, v60, v235, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255);
    if (!v14)
    {
LABEL_172:
      free(v132);
    }

    return v2;
  }

  v6 = *(*this + 72);
  if (!v5)
  {
    goto LABEL_154;
  }

LABEL_3:
  v7 = (v4[17] + v4[16]);
  v8 = (v5 + v7) - v7;
  v9 = (v6 + 32 * v7 + 24);
  v10 = v8;
  do
  {
    ConstantIntValue = mlir::getConstantIntValue(*v9 | 4);
    if ((v12 & 1) != 0 && ConstantIntValue <= 0)
    {
      OUTLINED_FUNCTION_100_3();
      OUTLINED_FUNCTION_75_4(v39, v40, v41, v42, v43);
      mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v252);
      OUTLINED_FUNCTION_119_2();
      if (v52)
      {
        mlir::InFlightDiagnostic::report(&v252);
      }

      if ((v276 & 1) == 0)
      {
        return v2;
      }

      v53 = OUTLINED_FUNCTION_106_1(v44, v45, v46, v47, v48, v49, v50, v51, v234, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, v267, v268, __p, v270, v271, v272, v273, v274, v275);
      if (!v14)
      {
        free(v53);
      }

      v61 = v272;
      if (v272)
      {
        v62 = OUTLINED_FUNCTION_72_2(v53, v54, v55, v56, v57, v58, v59, v60, v235, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, v267, v268, __p, v270, v271, v272, v273);
        if (!v14)
        {
          do
          {
            v62 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v62 - 8));
          }

          while (v62 != v61);
          v63 = v272;
        }

        OUTLINED_FUNCTION_165_0(v63, v236, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, v267, v268, __p, v270, v271, v272, v273);
      }

      v64 = __p;
      if (!__p)
      {
        goto LABEL_171;
      }

      v65 = OUTLINED_FUNCTION_105_2();
      if (v14)
      {
        goto LABEL_170;
      }

      do
      {
        v67 = *--v9;
        v66 = v67;
        *v9 = 0;
        if (v67)
        {
          operator delete[](v66);
        }
      }

      while (v9 != v64);
      goto LABEL_169;
    }

    v9 += 4;
    --v10;
  }

  while (v10);
  OUTLINED_FUNCTION_105_0();
  OUTLINED_FUNCTION_14_12();
  if (v14)
  {
    v15 = 0;
  }

  else
  {
    v15 = v13;
  }

  v17 = *(v15 + 48);
  v16 = *(v15 + 56);
  if (v8 != ((v16 - v17) >> 3))
  {
    OUTLINED_FUNCTION_158_1();
    v68 = &v252;
    OUTLINED_FUNCTION_75_4(v69, v70, v71, v72, v73);
    if (v252)
    {
      LODWORD(v249) = 3;
      v250 = "expects the same number of induction variables: ";
      v251 = 48;
      OUTLINED_FUNCTION_70_3();
      if (v76)
      {
        OUTLINED_FUNCTION_5_3();
        if (v195 <= v197 && (v196 & 1) != 0)
        {
          v2 = &v249 - v195;
          v224 = OUTLINED_FUNCTION_38_7();
          OUTLINED_FUNCTION_130_2(v224, v225);
          v74 = v255;
          v75 = (v255 + v2);
        }

        else
        {
          v198 = OUTLINED_FUNCTION_38_7();
          OUTLINED_FUNCTION_130_2(v198, v199);
          v75 = &v249;
          v74 = v255;
        }
      }

      OUTLINED_FUNCTION_16_11(&v74[3 * v256], *v75);
      if (v252)
      {
        v77 = *(v15 + 56) - *(v15 + 48);
        LODWORD(v249) = 5;
        v250 = (v77 >> 3);
        OUTLINED_FUNCTION_70_3();
        if (v76)
        {
          OUTLINED_FUNCTION_5_3();
          if (v200 <= v202 && (v201 & 1) != 0)
          {
            v2 = &v249 - v200;
            v230 = OUTLINED_FUNCTION_38_7();
            OUTLINED_FUNCTION_130_2(v230, v231);
            v78 = v255;
            v79 = (v255 + v2);
          }

          else
          {
            v203 = OUTLINED_FUNCTION_38_7();
            OUTLINED_FUNCTION_130_2(v203, v204);
            v79 = &v249;
            v78 = v255;
          }
        }

        OUTLINED_FUNCTION_17_13(&v78[3 * v256], *v79);
        OUTLINED_FUNCTION_68_2();
        if (v80)
        {
          OUTLINED_FUNCTION_155_1();
          OUTLINED_FUNCTION_21_9();
          if (v76)
          {
            OUTLINED_FUNCTION_13_4();
            if (v207 <= v209 && (v208 & 1) != 0)
            {
              v2 = &v249 - v207;
              OUTLINED_FUNCTION_129_2(v206, v234, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257);
              v81 = v255;
            }

            else
            {
              OUTLINED_FUNCTION_129_2(v206, v234, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257);
              OUTLINED_FUNCTION_76_3();
            }
          }

          OUTLINED_FUNCTION_12_11(&v81[3 * v256]);
          OUTLINED_FUNCTION_104_2();
          if (v82)
          {
            LODWORD(v249) = 5;
            v250 = v8;
            OUTLINED_FUNCTION_66_3();
            if (v76)
            {
              OUTLINED_FUNCTION_51();
              v210 = OUTLINED_FUNCTION_38_7();
              llvm::SmallVectorBase<unsigned int>::grow_pod(v210, v212, v211 + 1, 24);
              v83 = v255;
            }

            OUTLINED_FUNCTION_12_11(&v83[3 * v256]);
            LODWORD(v256) = v84 + 1;
          }
        }
      }
    }

    mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v252);
    OUTLINED_FUNCTION_119_2();
    if (v93)
    {
      mlir::InFlightDiagnostic::report(&v252);
    }

    if (v276 != 1)
    {
      return v2;
    }

    v53 = OUTLINED_FUNCTION_106_1(v85, v86, v87, v88, v89, v90, v91, v92, v234, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, v267, v268, __p, v270, v271, v272, v273, v274, v275);
    if (!v14)
    {
      free(v53);
    }

    v94 = v272;
    if (v272)
    {
      v95 = OUTLINED_FUNCTION_72_2(v53, v54, v55, v56, v57, v58, v59, v60, v235, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, v267, v268, __p, v270, v271, v272, v273);
      if (!v14)
      {
        do
        {
          v95 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v95 - 8));
        }

        while (v95 != v94);
        v96 = v272;
      }

      OUTLINED_FUNCTION_165_0(v96, v237, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, v267, v268, __p, v270, v271, v272, v273);
    }

    v64 = __p;
    if (!__p)
    {
      goto LABEL_171;
    }

    v65 = OUTLINED_FUNCTION_105_2();
    if (v14)
    {
      goto LABEL_170;
    }

    do
    {
      v98 = *--v68;
      v97 = v98;
      *v68 = 0;
      if (v98)
      {
        operator delete[](v97);
      }
    }

    while (v68 != v64);
    goto LABEL_169;
  }

  if (v17 != v16)
  {
    while (1)
    {
      OUTLINED_FUNCTION_121_1();
      v252 = v18;
      if (!mlir::Type::isIndex(&v252))
      {
        break;
      }

      v17 += 8;
      if (v17 == v16)
      {
        goto LABEL_14;
      }
    }

    OUTLINED_FUNCTION_100_3();
    OUTLINED_FUNCTION_75_4(v118, v119, v120, v121, v122);
    mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v252);
    OUTLINED_FUNCTION_119_2();
    if (v123)
    {
      mlir::InFlightDiagnostic::report(&v252);
    }

    if (v276)
    {
      if (v275 != &v276)
      {
        free(v275);
      }

      v124 = v272;
      if (v272)
      {
        v125 = v273;
        v126 = v272;
        if (v273 != v272)
        {
          do
          {
            v125 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v125 - 1);
          }

          while (v125 != v124);
          v126 = v272;
        }

        v273 = v124;
        operator delete(v126);
      }

      v127 = __p;
      if (__p)
      {
        v128 = v270;
        v129 = __p;
        if (v270 != __p)
        {
          do
          {
            v131 = *--v128;
            v130 = v131;
            *v128 = 0;
            if (v131)
            {
              operator delete[](v130);
            }
          }

          while (v128 != v127);
LABEL_111:
          v129 = __p;
        }

        goto LABEL_112;
      }

      goto LABEL_113;
    }

    return v2;
  }

LABEL_14:
  v19 = *v2;
  OUTLINED_FUNCTION_123_2();
  OUTLINED_FUNCTION_8_11();
  if (*v20 == v20 || ((OUTLINED_FUNCTION_14_12(), !v14) ? (v23 = v22) : (v23 = 0), v24 = *(v23 + 32), v24 == v23 + 32))
  {
    v26 = 0;
    goto LABEL_72;
  }

  v25 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v24, v21);
  v26 = v25;
  if (*(*(v25 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::scf::ReduceOp,void>::id)
  {
LABEL_72:
    LOWORD(v248) = 261;
    v244 = "expects body to terminate with 'scf.reduce'";
    v245 = 43;
    mlir::Operation::emitOpError(v19, &v244, &v252);
    if (v26)
    {
      v106 = mlir::Diagnostic::attachNote(&v253, *(v26 + 24), 1);
      v107 = *(v106 + 16);
      LODWORD(v244) = 3;
      v245 = "terminator here";
      v246 = 15;
      if (*(v106 + 24) >= *(v106 + 28))
      {
        OUTLINED_FUNCTION_5_3();
        OUTLINED_FUNCTION_130_2(v205, v106 + 32);
        v107 = *(v106 + 16);
      }

      OUTLINED_FUNCTION_22_7((v107 + 24 * *(v106 + 24)));
      ++*(v106 + 24);
    }

    if (v252)
    {
      mlir::InFlightDiagnostic::report(&v252);
    }

    if (v276 == 1)
    {
      v108 = v275;
      if (v275 != &v276)
      {
        free(v275);
      }

      v109 = v272;
      if (v272)
      {
        v110 = OUTLINED_FUNCTION_72_2(v108, v99, v100, v101, v102, v103, v104, v105, v234, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, v267, v268, __p, v270, v271, v272, v273);
        if (!v14)
        {
          do
          {
            v110 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v110 - 8));
          }

          while (v110 != v109);
          v111 = v272;
        }

        OUTLINED_FUNCTION_165_0(v111, v238, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, v267, v268, __p, v270, v271, v272, v273);
      }

      v112 = __p;
      if (__p)
      {
        v113 = v270;
        v114 = __p;
        if (v270 != __p)
        {
          do
          {
            v116 = *--v113;
            v115 = v116;
            *v113 = 0;
            if (v116)
            {
              operator delete[](v115);
            }
          }

          while (v113 != v112);
          v114 = __p;
        }

        v270 = v112;
        operator delete(v114);
      }

      v117 = OUTLINED_FUNCTION_154_0(v108, v99, v100, v101, v102, v103, v104, v105, v234, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255);
      if (!v14)
      {
        free(v117);
      }
    }

    return 0;
  }

  v27 = *v2;
  v28 = *(*v2 + 36);
  v242 = v28;
  v243 = v25;
  v29 = *(v25 + 44) & 0x7FFFFF;
  v241 = v29;
  v30 = (v27 + 16 * ((*(v27 + 44) >> 23) & 1));
  v31 = (v30[17] + v30[16] + v30[18]);
  v32 = (v30[19] + v31) - v31;
  v240 = v32;
  if (v29 != v28)
  {
    OUTLINED_FUNCTION_158_1();
    OUTLINED_FUNCTION_75_4(v133, v134, v135, v136, v137);
    mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(&v252, "expects number of results: ");
    mlir::InFlightDiagnostic::operator<<<unsigned long>(v138, &v242);
    mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v139, " to be the same as number of reductions: ");
    v141 = &v241;
LABEL_117:
    mlir::InFlightDiagnostic::operator<<<unsigned long>(v140, v141);
    v2 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v149);
    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v252);
    return v2;
  }

  if (v32 != v28)
  {
    OUTLINED_FUNCTION_158_1();
    OUTLINED_FUNCTION_75_4(v142, v143, v144, v145, v146);
    mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(&v252, "expects number of results: ");
    mlir::InFlightDiagnostic::operator<<<unsigned long>(v147, &v242);
    mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v148, " to be the same as number of initial values: ");
    v141 = &v240;
    goto LABEL_117;
  }

  if (!v29)
  {
    return 1;
  }

  v33 = 0;
  v34 = *v2;
  v35 = *v2 - 96;
  for (i = *(v243 + 72) + 24; ; i += 32)
  {
    v37 = v35 - 24 * (v33 - 5);
    if (v33 <= 5)
    {
      v37 = v34 - 16 * ((v33 + 1) & 0xF);
    }

    v2 = *(v37 + 8) & 0xFFFFFFFFFFFFFFF8;
    v38 = *(*i + 8) & 0xFFFFFFFFFFFFFFF8;
    if (v2 != v38)
    {
      break;
    }

    if (++v33 >= v29)
    {
      return 1;
    }
  }

  OUTLINED_FUNCTION_158_1();
  mlir::OpState::emitOpError(&v243, &v244, &v252);
  if (v252)
  {
    LODWORD(v249) = 3;
    v250 = "expects type of ";
    v251 = 16;
    OUTLINED_FUNCTION_70_3();
    if (v76)
    {
      OUTLINED_FUNCTION_5_3();
      if (v213 <= v215 && (v214 & 1) != 0)
      {
        v232 = &v249 - v213;
        OUTLINED_FUNCTION_164_0();
        v150 = v255;
        v151 = &v232[v255];
      }

      else
      {
        OUTLINED_FUNCTION_164_0();
        v151 = &v249;
        v150 = v255;
      }
    }

    OUTLINED_FUNCTION_17_13(&v150[3 * v256], *v151);
    OUTLINED_FUNCTION_104_2();
    if (v152)
    {
      LODWORD(v249) = 2;
      v250 = v33;
      OUTLINED_FUNCTION_66_3();
      if (v76)
      {
        OUTLINED_FUNCTION_51();
        OUTLINED_FUNCTION_29_7();
        v153 = v255;
      }

      OUTLINED_FUNCTION_12_11(&v153[3 * v256]);
      OUTLINED_FUNCTION_68_2();
      if (v154)
      {
        OUTLINED_FUNCTION_155_1();
        OUTLINED_FUNCTION_21_9();
        if (v76)
        {
          OUTLINED_FUNCTION_13_4();
          if (v218 <= v219 && (v217 & 1) != 0)
          {
            OUTLINED_FUNCTION_45_3(v216);
            v155 = v255;
          }

          else
          {
            OUTLINED_FUNCTION_45_3(v216);
            OUTLINED_FUNCTION_76_3();
          }
        }

        OUTLINED_FUNCTION_12_11(&v155[3 * v256]);
        LODWORD(v256) = v156 + 1;
        if (v252)
        {
          v157 = &v249;
          mlir::DiagnosticArgument::DiagnosticArgument(&v249, v38);
          v158 = v255;
          if (v256 >= HIDWORD(v256))
          {
            if (v255 <= &v249 && &v255[3 * v256] > &v249)
            {
              v233 = (&v249 - v255);
              OUTLINED_FUNCTION_29_7();
              v158 = v255;
              v157 = &v233[v255];
            }

            else
            {
              OUTLINED_FUNCTION_29_7();
              v157 = &v249;
              v158 = v255;
            }
          }

          OUTLINED_FUNCTION_17_13(&v158[3 * v256], *v157);
          OUTLINED_FUNCTION_68_2();
          if (v159)
          {
            OUTLINED_FUNCTION_155_1();
            OUTLINED_FUNCTION_21_9();
            if (v76)
            {
              OUTLINED_FUNCTION_13_4();
              if (v222 <= v223 && (v221 & 1) != 0)
              {
                OUTLINED_FUNCTION_45_3(v220);
                v160 = v255;
              }

              else
              {
                OUTLINED_FUNCTION_45_3(v220);
                OUTLINED_FUNCTION_76_3();
              }
            }

            OUTLINED_FUNCTION_12_11(&v160[3 * v256]);
            OUTLINED_FUNCTION_104_2();
            if (v161)
            {
              LODWORD(v249) = 2;
              v250 = v33;
              OUTLINED_FUNCTION_66_3();
              if (v76)
              {
                OUTLINED_FUNCTION_51();
                OUTLINED_FUNCTION_29_7();
                v162 = v255;
              }

              OUTLINED_FUNCTION_12_11(&v162[3 * v256]);
              OUTLINED_FUNCTION_68_2();
              if (v163)
              {
                OUTLINED_FUNCTION_155_1();
                OUTLINED_FUNCTION_21_9();
                if (v76)
                {
                  OUTLINED_FUNCTION_13_4();
                  if (v228 <= v229 && (v227 & 1) != 0)
                  {
                    OUTLINED_FUNCTION_45_3(v226);
                    v164 = v255;
                  }

                  else
                  {
                    OUTLINED_FUNCTION_45_3(v226);
                    OUTLINED_FUNCTION_76_3();
                  }
                }

                OUTLINED_FUNCTION_12_11(&v164[3 * v256]);
                LODWORD(v256) = v165 + 1;
                if (v252)
                {
                  v166 = &v249;
                  mlir::DiagnosticArgument::DiagnosticArgument(&v249, v2);
                  v167 = v255;
                  if (v256 >= HIDWORD(v256))
                  {
                    if (v255 <= &v249 && &v255[3 * v256] > &v249)
                    {
                      v2 = &v249 - v255;
                      OUTLINED_FUNCTION_29_7();
                      v167 = v255;
                      v166 = (v255 + v2);
                    }

                    else
                    {
                      OUTLINED_FUNCTION_29_7();
                      v166 = &v249;
                      v167 = v255;
                    }
                  }

                  OUTLINED_FUNCTION_16_11(&v167[3 * v256], *v166);
                }
              }
            }
          }
        }
      }
    }
  }

  mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v252);
  OUTLINED_FUNCTION_119_2();
  if (v168)
  {
    mlir::InFlightDiagnostic::report(&v252);
  }

  if (v276)
  {
    if (v275 != &v276)
    {
      free(v275);
    }

    v169 = v272;
    if (v272)
    {
      v170 = v273;
      v171 = v272;
      if (v273 != v272)
      {
        do
        {
          v170 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v170 - 1);
        }

        while (v170 != v169);
        v171 = v272;
      }

      v273 = v169;
      operator delete(v171);
    }

    v127 = __p;
    if (__p)
    {
      v172 = v270;
      v129 = __p;
      if (v270 != __p)
      {
        do
        {
          v174 = *--v172;
          v173 = v174;
          *v172 = 0;
          if (v174)
          {
            operator delete[](v173);
          }
        }

        while (v172 != v127);
        goto LABEL_111;
      }

LABEL_112:
      v270 = v127;
      operator delete(v129);
    }

LABEL_113:
    v132 = v255;
    if (v255 != &v257)
    {
      goto LABEL_172;
    }
  }

  return v2;
}

uint64_t mlir::scf::ParallelOp::print(mlir::scf::ParallelOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  (*(*v4 + 16))(v4);
  OUTLINED_FUNCTION_25_2();
  if (!v8 & v7)
  {
    *v6 = 10272;
    OUTLINED_FUNCTION_24_2(v5);
  }

  else
  {
    llvm::raw_ostream::write(v5, " (", 2uLL);
  }

  OUTLINED_FUNCTION_105_0();
  OUTLINED_FUNCTION_14_12();
  if (v8)
  {
    v10 = 0;
  }

  else
  {
    v10 = v9;
  }

  v11 = *(v10 + 48);
  v12 = *(v10 + 56);
  OUTLINED_FUNCTION_104();
  (*(v13 + 16))(v2);
  if (v12 != v11)
  {
    OUTLINED_FUNCTION_104();
    (*(v14 + 160))(v2);
    if (v12 - v11 != 8)
    {
      v15 = v11 + 8;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v8 & v7)
        {
          OUTLINED_FUNCTION_21_5(v16);
        }

        else
        {
          OUTLINED_FUNCTION_42_0();
        }

        v15 += 8;
        OUTLINED_FUNCTION_104();
        (*(v17 + 160))(v2);
      }

      while (v15 != v12);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v20 > 4)
  {
    *(v19 + 4) = 40;
    OUTLINED_FUNCTION_160(v19);
    *(v22 + 32) = v21 + 5;
  }

  else
  {
    llvm::raw_ostream::write(v18, ") = (", 5uLL);
  }

  OUTLINED_FUNCTION_94_0();
  v25 = *(v24 + 64);
  if ((v26 & 0x800000) != 0)
  {
    v27 = *(v23 + 72);
  }

  else
  {
    v27 = 0;
  }

  (*(*v2 + 16))(v2);
  if (v25)
  {
    OUTLINED_FUNCTION_104();
    (*(v28 + 160))(v2);
    if (v25 != 1)
    {
      v29 = v25 - 1;
      v30 = v27 + 56;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v8 & v7)
        {
          OUTLINED_FUNCTION_21_5(v31);
        }

        else
        {
          OUTLINED_FUNCTION_42_0();
        }

        v30 += 32;
        OUTLINED_FUNCTION_104();
        (*(v32 + 160))(v2);
        --v29;
      }

      while (v29);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v35 > 5)
  {
    *(v34 + 4) = 10272;
    OUTLINED_FUNCTION_160(v34);
    *(v37 + 32) = v36 + 6;
  }

  else
  {
    llvm::raw_ostream::write(v33, ") to (", 6uLL);
  }

  OUTLINED_FUNCTION_36_3();
  v40 = *(v38 + 68);
  if ((v41 & 0x800000) != 0)
  {
    v42 = *(v39 + 72);
  }

  else
  {
    v42 = 0;
  }

  v43 = *(v38 + 64);
  OUTLINED_FUNCTION_104();
  (*(v44 + 16))(v2);
  if (v40)
  {
    v45 = (v40 + v43);
    v46 = v42 + 32 * v43;
    OUTLINED_FUNCTION_104();
    (*(v47 + 160))(v2);
    if (v45 - v43 != 1)
    {
      v48 = ~v43 + v45;
      v49 = v46 + 56;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v8 & v7)
        {
          OUTLINED_FUNCTION_21_5(v50);
        }

        else
        {
          OUTLINED_FUNCTION_42_0();
        }

        v49 += 32;
        OUTLINED_FUNCTION_104();
        (*(v51 + 160))(v2);
        --v48;
      }

      while (v48);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v54 > 7)
  {
    *v53 = 0x2820706574732029;
    v52[4] += 8;
  }

  else
  {
    llvm::raw_ostream::write(v52, ") step (", 8uLL);
  }

  OUTLINED_FUNCTION_36_3();
  v57 = v55[18];
  if ((v58 & 0x800000) != 0)
  {
    v59 = *(v56 + 72);
  }

  else
  {
    v59 = 0;
  }

  v60 = v55[16];
  v61 = v55[17];
  OUTLINED_FUNCTION_104();
  (*(v62 + 16))(v2);
  if (v57)
  {
    v63 = (v61 + v60);
    v64 = (v57 + v63);
    v65 = v59 + 32 * v63;
    OUTLINED_FUNCTION_104();
    (*(v66 + 160))(v2);
    if (v64 - v63 != 1)
    {
      v67 = ~v63 + v64;
      v68 = v65 + 56;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v8 & v7)
        {
          OUTLINED_FUNCTION_21_5(v69);
        }

        else
        {
          OUTLINED_FUNCTION_42_0();
        }

        v68 += 32;
        OUTLINED_FUNCTION_104();
        (*(v70 + 160))(v2);
        --v67;
      }

      while (v67);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v8)
  {
    llvm::raw_ostream::write(v71, ")", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v71, v72);
  }

  if (*(*v3 + 4 * ((*(*v3 + 11) >> 23) & 1) + 19))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v75 > 6)
    {
      *(v74 + 3) = 673215593;
      OUTLINED_FUNCTION_160(v74);
      *(v77 + 32) = v76 + 7;
    }

    else
    {
      llvm::raw_ostream::write(v73, " init (", 7uLL);
    }

    OUTLINED_FUNCTION_36_3();
    v80 = v78[19];
    if ((v81 & 0x800000) != 0)
    {
      v82 = *(v79 + 72);
    }

    else
    {
      v82 = 0;
    }

    v83 = v78[16];
    v84 = v78[17];
    v85 = v78[18];
    OUTLINED_FUNCTION_104();
    (*(v86 + 16))(v2);
    if (v80)
    {
      v87 = (v84 + v83 + v85);
      v88 = (v80 + v87);
      v89 = v82 + 32 * v87;
      OUTLINED_FUNCTION_104();
      (*(v90 + 160))(v2);
      if (v88 - v87 != 1)
      {
        v91 = ~v87 + v88;
        v92 = v89 + 56;
        do
        {
          OUTLINED_FUNCTION_30_2();
          if (!v8 & v7)
          {
            OUTLINED_FUNCTION_21_5(v93);
          }

          else
          {
            OUTLINED_FUNCTION_42_0();
          }

          v92 += 32;
          OUTLINED_FUNCTION_104();
          (*(v94 + 160))(v2);
          --v91;
        }

        while (v91);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v8)
    {
      llvm::raw_ostream::write(v95, ")", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v95, v96);
    }
  }

  OUTLINED_FUNCTION_34_2();
  v109[0] = v97;
  v109[1] = v98;
  mlir::OperandRange::getTypes(v109, &AttrDictionary);
  if (v107 != v108)
  {
    mlir::AsmPrinter::printArrowTypeList<mlir::ValueTypeRange<mlir::ResultRange> &>(v2, &AttrDictionary);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v7)
  {
    llvm::raw_ostream::write(v99, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v99, v100);
  }

  OUTLINED_FUNCTION_105_0();
  OUTLINED_FUNCTION_104();
  v101 = OUTLINED_FUNCTION_160_0();
  v102(v101);
  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  AttrDictionary = "operandSegmentSizes";
  v107 = 19;
  OUTLINED_FUNCTION_104();
  v103 = OUTLINED_FUNCTION_120_2();
  return v104(v103);
}

uint64_t mlir::scf::WhileOp::print(mlir::scf::WhileOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v50[4] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_54_3();
  v6 = (*(v5 + 56) - *(v5 + 48)) >> 3;
  if ((v7 & 0x800000) != 0)
  {
    v8 = *(v4 + 68);
    v9 = *(v4 + 72);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(v50, v9, v8);
  v10 = OUTLINED_FUNCTION_88_2();
  printInitializationList(v10, v11, v6, v12, v13, v14, 1uLL);
  OUTLINED_FUNCTION_104();
  (*(v15 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v18 > 2)
  {
    *(v17 + 2) = 32;
    OUTLINED_FUNCTION_15_4(v16, v17);
  }

  else
  {
    llvm::raw_ostream::write(v16, " : ", 3uLL);
  }

  v19 = *v3;
  if ((*(*v3 + 46) & 0x80) != 0)
  {
    v20 = *(v19 + 17);
    v21 = *(v19 + 9);
  }

  else
  {
    OUTLINED_FUNCTION_84_2();
  }

  v49[0] = v21;
  v49[1] = v20;
  mlir::OperandRange::getTypes(v49, v50);
  OUTLINED_FUNCTION_34_2();
  v31 = OUTLINED_FUNCTION_51_2(v22, v23, v24, v25, v26, v27, v28, v29, v47, v30);
  mlir::OperandRange::getTypes(v31, v32);
  mlir::AsmPrinter::printFunctionalType<mlir::ValueTypeRange<mlir::OperandRange>,mlir::ValueTypeRange<mlir::ResultRange>>(v2, v50, v48);
  OUTLINED_FUNCTION_104();
  (*(v33 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v36)
  {
    llvm::raw_ostream::write(v34, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v34, v35);
  }

  OUTLINED_FUNCTION_105_0();
  OUTLINED_FUNCTION_104();
  v37 = OUTLINED_FUNCTION_160_0();
  v38(v37);
  OUTLINED_FUNCTION_104();
  (*(v39 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v42 > 3)
  {
    OUTLINED_FUNCTION_23_8(v40, v41);
  }

  else
  {
    llvm::raw_ostream::write(v40, " do ", 4uLL);
  }

  OUTLINED_FUNCTION_105_0();
  OUTLINED_FUNCTION_104();
  OUTLINED_FUNCTION_109_2();
  v43();
  v50[0] = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(v50);
  OUTLINED_FUNCTION_118_2();
  OUTLINED_FUNCTION_104();
  v44 = OUTLINED_FUNCTION_120_2();
  return v45(v44);
}

uint64_t mlir::scf::ForOp::getODSOperandIndexAndLength(mlir::scf::ForOp *this, unsigned int a2, double a3, uint8x8_t a4)
{
  v4 = &dword_1E097EB2C;
  if (a2)
  {
    v5 = a2;
    if (a2 < 4)
    {
      v6 = 0;
      v7 = 0;
LABEL_15:
      v22 = v4 + v6;
      v23 = v5 - v6;
      do
      {
        v24 = *v22++;
        v7 += v24;
        --v23;
      }

      while (v23);
      goto LABEL_17;
    }

    if (a2 >= 0x20)
    {
      *v8.i64 = OUTLINED_FUNCTION_22_4();
      do
      {
        *v8.i64 = OUTLINED_FUNCTION_14_8(v8);
      }

      while (!v16);
      OUTLINED_FUNCTION_26_5(v8, v9, v10, v11, v12, v13, v14, v15);
      if (v16)
      {
        goto LABEL_17;
      }

      if ((v5 & 0x1C) == 0)
      {
        goto LABEL_15;
      }
    }

    else
    {
      v7 = 0;
      v6 = 0;
    }

    v17 = v6;
    v6 = v5 & 0xFFFFFFFC;
    v18 = v7;
    v19 = (v4 + v17);
    v20 = v17 - v6;
    do
    {
      v21 = *v19++;
      a4.i32[0] = v21;
      a4 = vmovl_u8(a4).u64[0];
      v18 = vaddw_u16(v18, a4);
      v20 += 4;
    }

    while (v20);
    v7 = vaddvq_s32(v18);
    if (v6 == v5)
    {
      goto LABEL_17;
    }

    goto LABEL_15;
  }

  v7 = 0;
LABEL_17:
  if ((*(*this + 46) & 0x80) != 0)
  {
    v25 = *(*this + 68);
  }

  else
  {
    v25 = 0;
  }

  v26 = (v25 - 3);
  v27 = a2 + (v25 - 4) * v7;
  v28 = v26 << 32;
  v16 = *(v4 + a2) == 0;
  v29 = 0x100000000;
  if (!v16)
  {
    v29 = v28;
  }

  return v29 | v27;
}

uint64_t mlir::scf::ParallelOp::verifyInvariantsImpl(mlir::scf::ParallelOp *this)
{
  v2 = *this;
  v3 = *(v2 + 44);
  v4 = (v3 >> 23) & 1;
  v5 = *(v2 + 16 * v4 + 64);
  if ((v3 & 0x800000) != 0)
  {
    v6 = *(v2 + 72);
    if (v5)
    {
      goto LABEL_3;
    }
  }

  else
  {
    v6 = 0;
    if (v5)
    {
LABEL_3:
      v7 = 0;
      v8 = v6 + 24;
      while (1)
      {
        v9 = OUTLINED_FUNCTION_49_3();
        if ((mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v9, v10, "operand", 7, v7) & 1) == 0)
        {
          return 0;
        }

        ++v7;
        v8 += 32;
        if (v5 == v7)
        {
          v2 = *this;
          v3 = *(*this + 44);
          v4 = (v3 >> 23) & 1;
          break;
        }
      }
    }
  }

  v11 = v3 & 0x800000;
  v12 = v2 + 16 * v4;
  v13 = *(v12 + 68);
  if (v11)
  {
    v14 = *(v2 + 72);
    if (v13)
    {
      goto LABEL_9;
    }
  }

  else
  {
    v14 = 0;
    if (v13)
    {
LABEL_9:
      v15 = *(v12 + 64);
      v16 = (v13 + v15) - v15;
      v17 = v14 + 32 * v15 + 24;
      while (1)
      {
        v18 = OUTLINED_FUNCTION_49_3();
        if ((mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v18, v19, "operand", 7, v5) & 1) == 0)
        {
          return 0;
        }

        LODWORD(v5) = v5 + 1;
        v17 += 32;
        if (!--v16)
        {
          v2 = *this;
          v20 = *(*this + 44);
          v4 = (v20 >> 23) & 1;
          v11 = v20 & 0x800000;
          break;
        }
      }
    }
  }

  v21 = (v2 + 16 * v4);
  v22 = v21[18];
  if (v11)
  {
    v23 = *(v2 + 72);
    if (v22)
    {
      goto LABEL_15;
    }
  }

  else
  {
    v23 = 0;
    if (v22)
    {
LABEL_15:
      v24 = (v21[17] + v21[16]);
      v25 = (v22 + v24) - v24;
      v26 = v23 + 32 * v24 + 24;
      while (1)
      {
        v27 = OUTLINED_FUNCTION_49_3();
        if ((mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v27, v28, "operand", 7, v5) & 1) == 0)
        {
          return 0;
        }

        LODWORD(v5) = v5 + 1;
        v26 += 32;
        if (!--v25)
        {
          v2 = *this;
          break;
        }
      }
    }
  }

  v29 = *(v2 + 36);
  if (*(v2 + 36))
  {
    v30 = v2 - 16;
  }

  else
  {
    v30 = 0;
  }

  if (v29)
  {
    for (i = 0; i != v29; ++i)
    {
      mlir::detail::OpResultImpl::getNextResultAtOffset(v30, i);
    }
  }

  OUTLINED_FUNCTION_87_3();
  OUTLINED_FUNCTION_10_14();
  return mlir::scf::__mlir_ods_local_region_constraint_SCFOps2(v34, v32 + 32 * v33, "region", 6, 0) & 1;
}

void mlir::scf::ReduceOp::print(mlir::scf::ReduceOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v68 = *MEMORY[0x1E69E9840];
  if ((*(*v4 + 46) & 0x80) != 0 && *(*v4 + 68))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v7)
    {
      llvm::raw_ostream::write(v5, "(", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v5, v6);
    }

    OUTLINED_FUNCTION_47_0();
    if (v9 < 0)
    {
      v10 = *(v8 + 68);
      v11 = *(v8 + 72);
    }

    else
    {
      v11 = 0;
      v10 = 0;
    }

    (*(*v2 + 16))(v2);
    if (v10)
    {
      OUTLINED_FUNCTION_104();
      (*(v12 + 160))(v2);
      v13 = v10 - 1;
      if (v13)
      {
        v14 = v11 + 56;
        do
        {
          OUTLINED_FUNCTION_30_2();
          if (!v7 & v16)
          {
            OUTLINED_FUNCTION_21_5(v15);
          }

          else
          {
            OUTLINED_FUNCTION_42_0();
          }

          v14 += 32;
          OUTLINED_FUNCTION_104();
          (*(v17 + 160))(v2);
          --v13;
        }

        while (v13);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v16)
    {
      llvm::raw_ostream::write(v18, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v18, v19);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v7)
    {
      llvm::raw_ostream::write(v20, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v20, v21);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v16)
    {
      v24 = llvm::raw_ostream::write(v22, 32);
    }

    else
    {
      v24 = OUTLINED_FUNCTION_5_2(v22, v23);
    }

    v32 = *v3;
    if ((*(*v3 + 46) & 0x80) != 0)
    {
      v33 = *(v32 + 17);
      v34 = *(v32 + 9);
    }

    else
    {
      OUTLINED_FUNCTION_84_2();
    }

    v63[1] = v33;
    v35 = OUTLINED_FUNCTION_51_2(v24, v25, v26, v27, v28, v29, v30, v31, v62, v34);
    mlir::OperandRange::getTypes(v35, v36);
    if (v65 != v67)
    {
      OUTLINED_FUNCTION_104();
      v37 = OUTLINED_FUNCTION_12_4();
      v38(v37);
      if (v65 + 1 != v67)
      {
        v39 = ~v65 + v67;
        v40 = v64 + 32 * v65 + 56;
        do
        {
          (*(*v2 + 16))(v2);
          OUTLINED_FUNCTION_25_2();
          if (!v7 & v16)
          {
            *v42 = 8236;
            OUTLINED_FUNCTION_24_2(v41);
          }

          else
          {
            llvm::raw_ostream::write(v41, ", ", 2uLL);
          }

          v40 += 32;
          OUTLINED_FUNCTION_104();
          v43 = OUTLINED_FUNCTION_12_4();
          v44(v43);
          --v39;
        }

        while (v39);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v7)
    {
      llvm::raw_ostream::write(v45, ")", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v45, v46);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v16)
  {
    llvm::raw_ostream::write(v47, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v47, v48);
  }

  v49 = *(*v3 + 11);
  v50 = *&v49 & 0x7FFFFFLL;
  if ((v49 & 0x7FFFFF) != 0)
  {
    OUTLINED_FUNCTION_84_4();
    v53 = v52 + 32 * *(v51 + 40);
    OUTLINED_FUNCTION_104();
    OUTLINED_FUNCTION_88_2();
    OUTLINED_FUNCTION_109_2();
    v54();
    if (v50 != 1)
    {
      v55 = v53 + 24;
      v56 = 24 * v50 - 24;
      do
      {
        (*(*v2 + 16))(v2);
        OUTLINED_FUNCTION_25_2();
        if (!v7 & v16)
        {
          *v58 = 8236;
          OUTLINED_FUNCTION_24_2(v57);
        }

        else
        {
          llvm::raw_ostream::write(v57, ", ", 2uLL);
        }

        OUTLINED_FUNCTION_88_2();
        OUTLINED_FUNCTION_109_2();
        v59();
        v55 += 24;
        v56 -= 24;
      }

      while (v56);
    }
  }

  v64 = &v66;
  v65 = 0x200000000;
  v63[0] = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(v63);
  OUTLINED_FUNCTION_104();
  v60 = OUTLINED_FUNCTION_120_2();
  v61(v60);
  if (v64 != &v66)
  {
    free(v64);
  }
}

void mlir::scf::YieldOp::print(mlir::scf::YieldOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v58[4] = *MEMORY[0x1E69E9840];
  v56 = v58;
  v57 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(*v4);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_104();
  v5 = OUTLINED_FUNCTION_120_2();
  v6(v5);
  OUTLINED_FUNCTION_47_0();
  if (v8 < 0 && *(v7 + 68))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v11)
    {
      llvm::raw_ostream::write(v9, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v9, v10);
    }

    OUTLINED_FUNCTION_47_0();
    if (v13 < 0)
    {
      v14 = *(v12 + 68);
      v15 = *(v12 + 72);
    }

    else
    {
      v15 = 0;
      v14 = 0;
    }

    v16 = (*(*v2 + 16))(v2);
    if (v14)
    {
      v17 = v16;
      OUTLINED_FUNCTION_104();
      (*(v18 + 160))(v2);
      v19 = v14 - 1;
      if (v19)
      {
        v20 = v15 + 56;
        do
        {
          OUTLINED_FUNCTION_30_2();
          if (!v22 & v11)
          {
            *v21 = 8236;
            *(v17 + 32) += 2;
          }

          else
          {
            OUTLINED_FUNCTION_42_0();
          }

          v20 += 32;
          OUTLINED_FUNCTION_104();
          (*(v23 + 160))(v2);
          --v19;
        }

        while (v19);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v11)
    {
      llvm::raw_ostream::write(v24, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v24, v25);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v22)
    {
      llvm::raw_ostream::write(v26, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v26, v27);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v11)
    {
      v30 = llvm::raw_ostream::write(v28, 32);
    }

    else
    {
      v30 = OUTLINED_FUNCTION_5_2(v28, v29);
    }

    if ((*(*v3 + 46) & 0x80) != 0)
    {
      v38 = *(*v3 + 72);
    }

    else
    {
      OUTLINED_FUNCTION_84_2();
    }

    v39 = OUTLINED_FUNCTION_51_2(v30, v31, v32, v33, v34, v35, v36, v37, v52, v38);
    mlir::OperandRange::getTypes(v39, v40);
    v41 = v54;
    v42 = v55;
    if (v54 != v55)
    {
      v43 = AttrDictionary + 32 * v54;
      OUTLINED_FUNCTION_104();
      v44 = OUTLINED_FUNCTION_12_4();
      v45(v44);
      if (v41 + 1 != v42)
      {
        v46 = ~v41 + v42;
        v47 = v43 + 56;
        do
        {
          (*(*v2 + 16))(v2);
          OUTLINED_FUNCTION_25_2();
          if (!v22 & v11)
          {
            *v49 = 8236;
            OUTLINED_FUNCTION_24_2(v48);
          }

          else
          {
            llvm::raw_ostream::write(v48, ", ", 2uLL);
          }

          v47 += 32;
          OUTLINED_FUNCTION_104();
          v50 = OUTLINED_FUNCTION_12_4();
          v51(v50);
          --v46;
        }

        while (v46);
      }
    }
  }

  if (v56 != v58)
  {
    free(v56);
  }
}

uint64_t mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::scf::ConditionOp>::getMutableSuccessorOperands@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if ((*(a1 + 46) & 0x80) != 0)
  {
    v2 = *(a1 + 68) - 1;
  }

  else
  {
    v2 = -1;
  }

  return mlir::MutableOperandRange::MutableOperandRange(a2, a1, 1, v2, 0, 0);
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ExecuteRegionOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
    v3 = *(a2 + 68);
  }

  else
  {
    v2 = 0;
    v3 = 0;
  }

  return v2 + 32 * v3;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getInitsMutable(uint64_t a1, uint64_t a2)
{
  v7[3] = *MEMORY[0x1E69E9840];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 68) - 3;
  }

  else
  {
    v2 = -3;
  }

  mlir::MutableOperandRange::MutableOperandRange(v5, a2, 3, v2, 0, 0);
  v3 = mlir::MutableOperandRange::operator mlir::OperandRange(v5);
  if (v6 != v7)
  {
    free(v6);
  }

  return v3;
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getYieldedValuesMutable(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v10[3] = *MEMORY[0x1E69E9840];
  v3 = *(((a1 + 16 * ((*(a1 + 44) >> 23) & 1) + ((*(a1 + 44) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a1 + 40) + 8);
  if (v3)
  {
    v4 = (v3 - 8);
  }

  else
  {
    v4 = 0;
  }

  Terminator = mlir::Block::getTerminator(v4, a1);
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v6 = *(Terminator + 68);
  }

  else
  {
    v6 = 0;
  }

  mlir::MutableOperandRange::MutableOperandRange(v8, Terminator, 0, v6, 0, 0);
  *a2 = mlir::MutableOperandRange::operator mlir::OperandRange(v8);
  *(a2 + 8) = v7;
  *(a2 + 16) = 1;
  if (v9 != v10)
  {
    free(v9);
  }
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
  }

  else
  {
    v2 = 0;
  }

  return v2 + 96;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::scf::ForOp::print(&v8, a3);
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
    v3 = *(a2 + 68);
  }

  else
  {
    v2 = 0;
    v3 = 0;
  }

  return v2 + 32 * v3;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::OpTrait::HasParallelRegion>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::scf::ForallOp::print(&v8, a3);
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
    v3 = *(a2 + 68);
  }

  else
  {
    v2 = 0;
    v3 = 0;
  }

  return v2 + 32 * v3;
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
    v3 = *(a2 + 68);
  }

  else
  {
    v2 = 0;
    v3 = 0;
  }

  return v2 + 32 * v3;
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getLoopLowerBounds(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v3 = *(a1 + 44);
  v4 = *(a1 + 16 * ((v3 >> 23) & 1) + 64);
  if ((v3 & 0x800000) != 0)
  {
    v5 = *(a1 + 72);
  }

  else
  {
    v5 = 0;
  }

  v6 = a2 + 16;
  *a2 = a2 + 16;
  *(a2 + 8) = 0x600000000;
  if (v4 < 7)
  {
    if (!v4)
    {
      v24 = 0;
      goto LABEL_22;
    }

    v7 = 0;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2, v6, v4, 8);
    v7 = *(a2 + 8);
    v6 = *a2;
  }

  v8 = (v6 + 8 * v7);
  if (v4 >= 0xB && ((v9 = v6 + 8 * (v7 + v4), v8 < v5 + 32 * v4) ? (v10 = v5 + 24 >= v9) : (v10 = 1), v10))
  {
    v11 = v4 & 3;
    if ((v4 & 3) == 0)
    {
      v11 = 4;
    }

    v12 = v4 - v11;
    v13 = (v8 + 8 * v12);
    v14 = (v5 + 88);
    v15 = v8 + 1;
    v16 = v12;
    do
    {
      v17 = v14 - 8;
      v18 = vld4q_f64(v17);
      v19 = vld4q_f64(v14);
      v20 = vdupq_n_s64(4uLL);
      v15[-1] = vorrq_s8(v18, v20);
      *v15 = vorrq_s8(v19, v20);
      v14 += 16;
      v15 += 2;
      v16 -= 4;
    }

    while (v16);
    v8 = v13;
  }

  else
  {
    v12 = 0;
  }

  v21 = v4 - v12;
  v22 = (v5 + 32 * v12 + 24);
  do
  {
    v23 = *v22;
    v22 += 4;
    v8->i64[0] = v23 | 4;
    v8 = (v8 + 8);
    --v21;
  }

  while (v21);
  v24 = *(a2 + 8);
LABEL_22:
  *(a2 + 8) = v24 + v4;
  *(a2 + 64) = 1;
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getLoopSteps(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v3 = *(a1 + 44);
  v4 = (a1 + 16 * ((v3 >> 23) & 1));
  v5 = v4[16];
  v6 = v4[17];
  v7 = v4[18];
  if ((v3 & 0x800000) != 0)
  {
    v8 = *(a1 + 72);
  }

  else
  {
    v8 = 0;
  }

  v9 = (v6 + v5);
  v10 = (v7 + v9);
  v11 = v10 - v9;
  v12 = a2 + 16;
  *a2 = a2 + 16;
  *(a2 + 8) = 0x600000000;
  if ((v10 - v9) < 7)
  {
    if (!v7)
    {
      goto LABEL_24;
    }

    v13 = 0;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2, v12, v10 - v9, 8);
    v13 = *(a2 + 8);
    v12 = *a2;
  }

  v14 = (v12 + 8 * v13);
  if (v11 >= 0x11 && ((v15 = v12 + 8 * (v13 + v10 - v9), v16 = v8 + 32 * v9, v14 < v8 + 32 * v10) ? (v17 = v16 + 24 >= v15) : (v17 = 1), v17))
  {
    if ((v11 & 3) != 0)
    {
      v18 = v11 & 3;
    }

    else
    {
      v18 = 4;
    }

    v19 = v11 - v18;
    v20 = (v14 + 8 * (v11 - v18));
    v21 = (v16 + 88);
    v22 = v14 + 1;
    v23 = v18 + v9 - v10;
    do
    {
      v24 = v21 - 8;
      v25 = vld4q_f64(v24);
      v26 = vld4q_f64(v21);
      v27 = vdupq_n_s64(4uLL);
      v22[-1] = vorrq_s8(v25, v27);
      *v22 = vorrq_s8(v26, v27);
      v21 += 16;
      v22 += 2;
      v23 += 4;
    }

    while (v23);
    v14 = v20;
  }

  else
  {
    v19 = 0;
  }

  v28 = v19 + v9 - v10;
  v29 = (32 * v19 + 32 * v9 + v8 + 24);
  do
  {
    v30 = *v29;
    v29 += 4;
    v14->i64[0] = v30 | 4;
    v14 = (v14 + 8);
    v17 = __CFADD__(v28++, 1);
  }

  while (!v17);
  v7 = *(a2 + 8);
LABEL_24:
  *(a2 + 8) = v7 + v11;
  *(a2 + 64) = 1;
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getLoopUpperBounds(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v3 = *(a1 + 44);
  v4 = a1 + 16 * ((v3 >> 23) & 1);
  v6 = *(v4 + 64);
  v5 = *(v4 + 68);
  if ((v3 & 0x800000) != 0)
  {
    v7 = *(a1 + 72);
  }

  else
  {
    v7 = 0;
  }

  v8 = (v5 + v6);
  v9 = v8 - v6;
  v10 = a2 + 16;
  *a2 = a2 + 16;
  *(a2 + 8) = 0x600000000;
  if ((v8 - v6) < 7)
  {
    if (!v5)
    {
      goto LABEL_24;
    }

    v11 = 0;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2, v10, v8 - v6, 8);
    v11 = *(a2 + 8);
    v10 = *a2;
  }

  v12 = (v10 + 8 * v11);
  if (v9 >= 0x11 && ((v13 = v10 + 8 * (v11 + v8 - v6), v14 = v7 + 32 * v6, v12 < v7 + 32 * v8) ? (v15 = v14 + 24 >= v13) : (v15 = 1), v15))
  {
    if ((v9 & 3) != 0)
    {
      v16 = v9 & 3;
    }

    else
    {
      v16 = 4;
    }

    v17 = v9 - v16;
    v18 = (v12 + 8 * (v9 - v16));
    v19 = (v14 + 88);
    v20 = v12 + 1;
    v21 = v16 + v6 - v8;
    do
    {
      v22 = v19 - 8;
      v23 = vld4q_f64(v22);
      v24 = vld4q_f64(v19);
      v25 = vdupq_n_s64(4uLL);
      v20[-1] = vorrq_s8(v23, v25);
      *v20 = vorrq_s8(v24, v25);
      v19 += 16;
      v20 += 2;
      v21 += 4;
    }

    while (v21);
    v12 = v18;
  }

  else
  {
    v17 = 0;
  }

  v26 = v17 + v6 - v8;
  v27 = (32 * v17 + 32 * v6 + v7 + 24);
  do
  {
    v28 = *v27;
    v27 += 4;
    v12->i64[0] = v28 | 4;
    v12 = (v12 + 8);
    v15 = __CFADD__(v26++, 1);
  }

  while (!v15);
  v5 = *(a2 + 8);
LABEL_24:
  *(a2 + 8) = v5 + v9;
  *(a2 + 64) = 1;
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
    v3 = *(a2 + 68);
  }

  else
  {
    v2 = 0;
    v3 = 0;
  }

  return v2 + 32 * v3;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasParallelRegion>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::scf::ParallelOp::print(&v8, a3);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::VariadicRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchTerminatorOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::scf::ReduceOp::print(&v7, a3);
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    return *(a2 + 72);
  }

  else
  {
    return 0;
  }
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getInitsMutable(uint64_t a1, uint64_t a2)
{
  v7[3] = *MEMORY[0x1E69E9840];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 68);
  }

  else
  {
    v2 = 0;
  }

  mlir::MutableOperandRange::MutableOperandRange(v5, a2, 0, v2, 0, 0);
  v3 = mlir::MutableOperandRange::operator mlir::OperandRange(v5);
  if (v6 != v7)
  {
    free(v6);
  }

  return v3;
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getYieldedValuesMutable(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v10[3] = *MEMORY[0x1E69E9840];
  v3 = *(((a1 + 16 * ((*(a1 + 44) >> 23) & 1) + ((*(a1 + 44) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a1 + 40) + 32);
  if (v3)
  {
    v4 = (v3 - 8);
  }

  else
  {
    v4 = 0;
  }

  Terminator = mlir::Block::getTerminator(v4, a1);
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v6 = *(Terminator + 68);
  }

  else
  {
    v6 = 0;
  }

  mlir::MutableOperandRange::MutableOperandRange(v8, Terminator, 0, v6, 0, 0);
  *a2 = mlir::MutableOperandRange::operator mlir::OperandRange(v8);
  *(a2 + 8) = v7;
  *(a2 + 16) = 1;
  if (v9 != v10)
  {
    free(v9);
  }
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::scf::WhileOp::print(&v8, a3);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::scf::YieldOp::print(&v7, a3);
}

uint64_t anonymous namespace::ForOpIterArgsFolder::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  v135[4] = *MEMORY[0x1E69E9840];
  v116 = a2;
  v5 = a2[9];
  v6 = &v115;
  v113 = &v115;
  v114 = xmmword_1E096FAF0;
  if (v5 >= 5)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod(&v113, &v115, v5, 1);
  }

  v133 = v135;
  v134 = 0x400000000;
  v130 = v132;
  v131 = 0x400000000;
  v127 = v129;
  v128 = 0x400000000;
  OUTLINED_FUNCTION_151_1();
  if (v5 < 4)
  {
    v7 = 0;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v133, v135, v5 + 1, 8);
    v7 = v134;
    if (v134 >= HIDWORD(v134))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(&v133, v135, v134 + 1, 8);
      v7 = v134;
    }
  }

  *&v133[8 * v7] = 0;
  LODWORD(v134) = v134 + 1;
  if ((*(v116 + 46) & 0x80) == 0)
  {
    v8 = -3;
    goto LABEL_9;
  }

  v8 = *(v116 + 17) - 3;
  if (v8 > HIDWORD(v131))
  {
LABEL_9:
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v130, v132, v8, 8);
  }

  if (HIDWORD(v128) < v5)
  {
    OUTLINED_FUNCTION_124_2(&v127, v129);
  }

  if (v126 < v5)
  {
    OUTLINED_FUNCTION_124_2(&v124, v3);
  }

  v109 = v3;
  v110 = v135;
  v107 = v129;
  v108 = v132;
  v106 = a3;
  if ((*(v116 + 11) & 0x800000) != 0)
  {
    v9 = *(v116 + 9);
    v10 = *(v116 + 17) - 3;
  }

  else
  {
    v9 = 0;
    v10 = -3;
  }

  v11 = (v9 + 96);
  OUTLINED_FUNCTION_84_4();
  v13 = *(v12 + 36);
  OUTLINED_FUNCTION_51_5();
  v16 = *(v15 + 56);
  v17 = (*(v15 + 48) + 8);
  v19 = (v18 - 16);
  if (v13)
  {
    v20 = v19;
  }

  else
  {
    v20 = 0;
  }

  YieldedValues = mlir::detail::LoopLikeOpInterfaceTrait<mlir::scf::ForOp>::getYieldedValues(&v116, v14);
  AttrDictionary = v11;
  v118 = 0;
  v119 = v17;
  v120 = v20;
  v121 = 0;
  v122 = YieldedValues;
  v123 = 0;
  if (!v10 || ((v23 = v22, v17 != v16) ? (v24 = v13 == 0) : (v24 = 1), !v24 ? (v25 = v22 == 0) : (v25 = 1), v25))
  {
    v44 = 0;
    v46 = v3;
    v45 = v135;
    goto LABEL_102;
  }

  v105 = &v115;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  do
  {
    v29 = *(AttrDictionary + 4 * v27 + 3);
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v120, v26);
    v31 = mlir::ValueRange::dereference_iterator(&v122, v123);
    v32 = v31;
    if (*v17 == v31)
    {
      goto LABEL_33;
    }

    if (**v17)
    {
      v33 = 0;
      goto LABEL_34;
    }

    if (v29 == v31)
    {
LABEL_33:
      v33 = 1;
    }

    else
    {
      v33 = *NextResultAtOffset == 0;
    }

LABEL_34:
    v34 = v114;
    if ((v114 + 1) > *(&v114 + 1))
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod(&v113, v105, v114 + 1, 1);
      v34 = v114;
    }

    *(v113 + v34) = !v33;
    *&v114 = v114 + 1;
    if (v33)
    {
      v35 = v134;
      if (v134 >= HIDWORD(v134))
      {
        OUTLINED_FUNCTION_163_0(v134, v102, v104, v105, v106, v107, v108, v109, v110);
        v35 = v134;
      }

      *&v133[8 * v35] = v29;
    }

    else
    {
      v36 = v131;
      if (v131 >= HIDWORD(v131))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v130, v108, v131 + 1, 8);
        v36 = v131;
      }

      *&v130[8 * v36] = v29;
      LODWORD(v131) = v131 + 1;
      v37 = v128;
      if (v128 >= HIDWORD(v128))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v127, v107, v128 + 1, 8);
        v37 = v128;
      }

      *&v127[8 * v37] = v32;
      LODWORD(v128) = v128 + 1;
      v38 = v134;
      if (v134 >= HIDWORD(v134))
      {
        OUTLINED_FUNCTION_163_0(v134, v102, v104, v105, v106, v107, v108, v109, v110);
        v38 = v134;
      }

      v29 = 0;
      *&v133[8 * v38] = 0;
    }

    LODWORD(v134) = v134 + 1;
    v39 = v125;
    if (v125 >= v126)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(&v124, v109, v125 + 1, 8);
      v39 = v125;
    }

    v28 |= v33;
    *(v124 + v39) = v29;
    ++v125;
    v27 = v118 + 1;
    v17 = v119 + 1;
    v118 = v27;
    ++v119;
    v26 = v121 + 1;
    v40 = v123 + 1;
    ++v121;
    ++v123;
  }

  while (v27 != v10 && v17 != v16 && v26 != v13 && v40 != v23);
  v46 = v109;
  if (v28)
  {
    v47 = *(v116 + 3);
    v48 = *(v116 + 9);
    AttrDictionary = *(v48 + 24);
    v49 = *(v48 + 56);
    v111 = *(v48 + 88);
    v112 = v49;
    v50 = mlir::OpBuilder::create<mlir::scf::ForOp,mlir::Value,mlir::Value,mlir::Value,llvm::SmallVector<mlir::Value,6u> &>((v106 + 8), v47, &AttrDictionary, &v112, &v111, &v130);
    AttrDictionary = mlir::Operation::getAttrDictionary(v116);
    mlir::ArrayAttr::getValue(&AttrDictionary);
    OUTLINED_FUNCTION_118_2();
    mlir::Operation::setAttrs(v50, v51, v52);
    OUTLINED_FUNCTION_37_4();
    v56 = *(v55 + 8);
    if (v56)
    {
      v57 = (v56 - 8);
    }

    else
    {
      v57 = 0;
    }

    v58 = v133;
    *v133 = **(v57 + 6);
    v59 = v125;
    v6 = v105;
    if (v125)
    {
      v60 = 0;
      v61 = 32 * v54;
      v62 = v124;
      v63 = v58 + 8;
      do
      {
        if (!*v63)
        {
          v64 = *(((v53 + 16 * ((*(v50 + 44) >> 23) & 1) + ((*(v50 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + v61 + 8);
          if (v64)
          {
            v65 = v64 - 8;
          }

          else
          {
            v65 = 0;
          }

          *v63 = *(*(v65 + 48) + 8 * v60 + 8);
          v66 = v60 - 5;
          v67 = v60++ >= 6;
          v68 = v50 - 96 - 24 * v66;
          if (!v67)
          {
            v68 = v50 - 16 * v60;
          }

          *v62 = v68;
        }

        ++v62;
        ++v63;
        --v59;
      }

      while (v59);
    }

    OUTLINED_FUNCTION_105_0();
    OUTLINED_FUNCTION_14_12();
    if (v24)
    {
      v71 = 0;
    }

    else
    {
      v71 = v70;
    }

    if (v131)
    {
      mlir::ValueRange::ValueRange(&AttrDictionary, v69, v134);
      mlir::RewriterBase::mergeBlocks(v106, v71, v57, AttrDictionary, v118);
      Terminator = mlir::Block::getTerminator(v57, v72);
      v74 = (v106 + 24);
      v103 = *(v106 + 24);
      v75 = Terminator[2];
      v77 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(Terminator, v76);
      *(v106 + 24) = v75;
      *(v106 + 32) = v77;
      AttrDictionary = &v119;
      v118 = 0x400000000;
      if (v125 >= 5)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&AttrDictionary, &v119, v125, 8);
      }

      v78 = v114;
      if (v114)
      {
        v79 = 0;
        v80 = 24;
        do
        {
          if (*(v113 + v79) == 1)
          {
            v81 = *(Terminator[9] + v80);
            v82 = v118;
            if (v118 >= HIDWORD(v118))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(&AttrDictionary, &v119, v118 + 1, 8);
              v82 = v118;
            }

            *(AttrDictionary + v82) = v81;
            LODWORD(v118) = v118 + 1;
          }

          ++v79;
          v80 += 32;
        }

        while (v78 != v79);
      }

      mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>((v106 + 8), Terminator[3], &AttrDictionary);
      v90 = AttrDictionary;
      if (AttrDictionary != &v119)
      {
        free(AttrDictionary);
      }

      v91 = OUTLINED_FUNCTION_144_1(v90, v83, v84, v85, v86, v87, v88, v89, v103);
      v45 = v110;
      if (v92)
      {
        *v74 = v91;
      }

      else
      {
        v74->n128_u64[0] = 0;
        *(v106 + 32) = 0;
      }

      (*(*v106 + 16))(v106, Terminator);
    }

    else
    {
      v93 = mlir::Block::getTerminator(v57, v69);
      mlir::ValueRange::ValueRange(&AttrDictionary, v133, v134);
      mlir::RewriterBase::inlineBlockBefore(v106, v71, v93, AttrDictionary, v118);
      v95 = mlir::Block::getTerminator(v57, v94);
      v45 = v110;
      if (*(v95[2] + 40) == v95)
      {
        v97 = 0;
      }

      else
      {
        v97 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(*v95, v96);
      }

      v6 = v105;
      (*(*v106 + 16))(v106, v97);
    }

    v98 = v116;
    mlir::ValueRange::ValueRange(&AttrDictionary, v124, v125);
    (**v106)(v106, v98, AttrDictionary, v118);
    v44 = 1;
  }

  else
  {
    v44 = 0;
    v6 = v105;
    v45 = v110;
  }

LABEL_102:
  if (v124 != v46)
  {
    free(v124);
  }

  OUTLINED_FUNCTION_153_1();
  if (!v24)
  {
    free(v99);
  }

  OUTLINED_FUNCTION_152_1();
  if (!v24)
  {
    free(v100);
  }

  if (v133 != v45)
  {
    free(v133);
  }

  if (v113 != v6)
  {
    free(v113);
  }

  return v44;
}

uint64_t anonymous namespace::ForOpTensorCastFolder::matchAndRewrite(uint64_t a1, unsigned int *a2, void (***a3)(void, unsigned int *, unint64_t, unint64_t))
{
  v40 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_132_1();
  mlir::MutableOperandRange::MutableOperandRange(v5, v6, v7, v8, v9, v10);
  v11 = a2[9];
  if (v11)
  {
    v12 = a2 - 4;
  }

  else
  {
    v12 = 0;
  }

  v35 = *v30;
  v36[0] = v37;
  v36[1] = 0x100000000;
  if (v32)
  {
    llvm::SmallVectorImpl<std::pair<unsigned int,mlir::NamedAttribute>>::operator=(v36, &v31);
  }

  v38 = v12;
  v39 = v11;
  if (v31 != &v33)
  {
    free(v31);
  }

  v13 = mlir::MutableOperandRange::begin(&v35);
  v14 = v38;
  v15 = mlir::MutableOperandRange::end(&v35);
  v16 = 0;
  if (v13 != v15 && v39)
  {
    v17 = v15;
    v28 = a3;
    v18 = 0;
    v19 = v39 - 1;
    v20 = v13 + 32;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v14, v18);
      v30[0] = *(v20 - 8);
      DefiningOp = mlir::Value::getDefiningOp(v30);
      if (DefiningOp)
      {
        v23 = DefiningOp;
        if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id && (*(DefiningOp - 8) ^ *(*(*(DefiningOp + 72) + 24) + 8)) >= 8)
        {
          v24 = *(DefiningOp + 36) ? DefiningOp - 16 : 0;
          v25 = mlir::detail::OpResultImpl::getNextResultAtOffset(v24, 0);
          if (OUTLINED_FUNCTION_162_0(*(v25 + 8)))
          {
            if (*NextResultAtOffset && !**NextResultAtOffset)
            {
              break;
            }
          }
        }
      }

      v26 = v20 == v17 || v19 == v18++;
      v20 += 32;
      if (v26)
      {
        v16 = 0;
        goto LABEL_26;
      }
    }

    v29[1] = v30;
    mlir::scf::replaceAndCastForOpIterArg(v28, a2, (v20 - 32), *(*(v23 + 72) + 24), v29, v30);
    mlir::ValueRange::ValueRange(v34, v30[0], LODWORD(v30[1]));
    (**v28)(v28, a2, v34[0], v34[1]);
    if (v30[0] != &v31)
    {
      free(v30[0]);
    }

    v16 = 1;
  }

LABEL_26:
  if (v36[0] != v37)
  {
    free(v36[0]);
  }

  return v16;
}

void anonymous namespace::FoldTensorCastOfOutputIntoForallOp::matchAndRewrite()
{
  OUTLINED_FUNCTION_93_2();
  v176 = *MEMORY[0x1E69E9840];
  v125 = v0;
  v164 = 1;
  LODWORD(v165) = -1;
  v166 = -1;
  v121 = v169;
  v167 = v169;
  v168 = 0x200000000;
  v2 = *(v0 + 44);
  v3 = (v0 + 16 * ((v2 >> 23) & 1));
  v4 = v3[24];
  v5 = v3[25];
  v7 = v3[26];
  v6 = v3[27];
  if ((v2 & 0x800000) != 0)
  {
    v8 = *(v0 + 72);
  }

  else
  {
    v8 = 0;
  }

  v9 = (v5 + v4 + v7);
  v10 = (v6 + v9);
  v11 = v10 - v9;
  v156 = &v158;
  v157 = 0x600000000;
  v119 = v1;
  v120 = &v158;
  if ((v10 - v9) < 7)
  {
    if (!v6)
    {
      v24 = &v158;
      goto LABEL_21;
    }

    v12 = 0;
    v13 = &v158;
  }

  else
  {
    OUTLINED_FUNCTION_139_1(&v156, &v158);
    v12 = v157;
    v13 = v156;
  }

  v14 = (v13 + 8 * v12);
  if (v11 >= 0x13 && ((v15 = v13 + 8 * (v12 + v10 - v9), v14 < v8 + 32 * v10) ? (v16 = v8 + 32 * v9 + 24 >= v15) : (v16 = 1), v16))
  {
    v17 = (v14 + 2);
    do
    {
      OUTLINED_FUNCTION_35_7(v17);
    }

    while (v20 != -4);
    v14 = v19;
  }

  else
  {
    v18 = 0;
  }

  v21 = v18 + v9 - v10;
  v22 = (32 * v18 + 32 * v9 + v8 + 24);
  do
  {
    v23 = *v22;
    v22 += 4;
    *v14++ = v23;
    v16 = __CFADD__(v21++, 1);
  }

  while (!v16);
  v6 = v157;
  v24 = v156;
LABEL_21:
  v25 = (v6 + v11);
  LODWORD(v157) = v25;
  if (v25)
  {
    v26 = 0;
    v27 = 8 * v25;
    do
    {
      DefiningOp = mlir::Value::getDefiningOp(v24);
      if (DefiningOp)
      {
        v11 = DefiningOp;
        if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
        {
          v29 = *(DefiningOp + 36) ? DefiningOp - 16 : 0;
          NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v29, 0);
          if (OUTLINED_FUNCTION_162_0(*(NextResultAtOffset + 8)))
          {
            v31 = *(*(*(v11 + 72) + 24) + 8);
            v32 = *(v11 - 8);
            v140 = v26;
            v33 = llvm::DenseMapBase<llvm::SmallDenseMap<unsigned int,unsigned int,2u,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,unsigned int>>,unsigned int,unsigned int,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,unsigned int>>::try_emplace<unsigned int const&>(&v164, &v140, &v140 + 1, &__src);
            v41 = __src;
            if (v172[0])
            {
              v149 = 0;
              v150 = 0;
              LODWORD(v148) = v26;
              v42 = v167;
              if (v168 >= HIDWORD(v168))
              {
                if (v167 <= &v148 && v167 + 24 * v168 > &v148)
                {
                  OUTLINED_FUNCTION_135_1(v33, v34, v35, v36, v37, v38, v39, v40, v109, v110, v111, v112, v113, v114, v115, v117, &v148 - v167, v119, v120, v121, v122, v123, v124, v125, v126, v127, v128, v129, v130, v131, v132, v133, v134, v135, v136, v137, v138, v139, v140, v141, v142, v143, v144, v145, v146, v147, v148, v149, v150, v151, v152, v153, v154, v155, v156, v157, v158, v159, v160, v161, v162, v163, v164);
                  v42 = v167;
                }

                else
                {
                  OUTLINED_FUNCTION_135_1(v33, v34, v35, v36, v37, v38, v39, v40, v109, v110, v111, v112, v113, v114, v115, v117, v118, v119, v120, v121, v122, v123, v124, v125, v126, v127, v128, v129, v130, v131, v132, v133, v134, v135, v136, v137, v138, v139, v140, v141, v142, v143, v144, v145, v146, v147, v148, v149, v150, v151, v152, v153, v154, v155, v156, v157, v158, v159, v160, v161, v162, v163, v164);
                  v42 = v167;
                }
              }

              OUTLINED_FUNCTION_22_7(&v42[24 * v168]);
              v43 = v168;
              LODWORD(v168) = v168 + 1;
              v41[1] = v43;
            }

            else
            {
              v43 = *(__src + 1);
            }

            v44 = v167 + 24 * v43;
            *(v44 + 1) = v31 & 0xFFFFFFFFFFFFFFF8;
            *(v44 + 2) = v32 & 0xFFFFFFFFFFFFFFF8;
            *(v156 + v26) = *(*(v11 + 72) + 24);
          }
        }
      }

      ++v26;
      v24 = (v24 + 8);
      v27 -= 8;
    }

    while (v27);
  }

  if (v168)
  {
    v45 = *(v125 + 24);
    mlir::scf::ForallOp::getLoopLowerBounds(&v125, &__src);
    v148 = &v150;
    v149 = 0x600000000;
    v46 = v171;
    if (!v171)
    {
LABEL_56:
      if (v173 == 1)
      {
        OUTLINED_FUNCTION_65_4();
        if (!v85)
        {
          free(v49);
        }
      }

      mlir::scf::ForallOp::getLoopUpperBounds(&v125, &__src);
      v140 = &v142;
      v141 = 0x600000000;
      v50 = v171;
      if (!v171)
      {
LABEL_66:
        if (v173 == 1)
        {
          OUTLINED_FUNCTION_65_4();
          if (!v85)
          {
            free(v53);
          }
        }

        mlir::scf::ForallOp::getLoopSteps(&v125, &__src);
        OUTLINED_FUNCTION_151_1();
        v54 = v171;
        if (!v171)
        {
LABEL_76:
          if (v173 == 1)
          {
            OUTLINED_FUNCTION_65_4();
            if (!v85)
            {
              free(v57);
            }
          }

          v116 = v11;
          v58 = *(v125 + 16 * ((*(v125 + 44) >> 23) & 1) + 64);
          v122 = &v125;
          v123 = &v164;
          v124 = v119;
          v126 = v45;
          Context = mlir::Attribute::getContext(&v126);
          v60 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::scf::ForallOp,void>::id, Context);
          if ((v61 & 1) == 0)
          {
            v175 = 1283;
            v174[2] = "scf.forall";
            v174[3] = 10;
            LOWORD(v131) = 259;
            llvm::operator+(v174, &v127, &__src);
            llvm::report_fatal_error(&__src, 1);
          }

          mlir::OperationState::OperationState(&__src, v45, v60);
          v62 = v148;
          v63 = v149;
          v64 = v140;
          v65 = v141;
          v66 = v132;
          v67 = v133;
          mlir::ValueRange::ValueRange(v174, v156, v157);
          v68 = mlir::OpBuilder::create((v119 + 8), &__src);
          v69 = *(*(v68 + 48) + 16);
          mlir::OperationState::~OperationState(&__src);
          if (v69 == &mlir::detail::TypeIDResolver<mlir::scf::ForallOp,void>::id)
          {
            v70 = v68;
          }

          else
          {
            v70 = 0;
          }

          if (v132 != v116)
          {
            free(v132);
          }

          if (v140 != &v142)
          {
            free(v140);
          }

          if (v148 != &v150)
          {
            free(v148);
          }

          OUTLINED_FUNCTION_5_14();
          OUTLINED_FUNCTION_14_12();
          if (v85)
          {
            v73 = 0;
          }

          else
          {
            v73 = v72;
          }

          mlir::Block::getTerminator(v73, v71);
          OUTLINED_FUNCTION_87_3();
          OUTLINED_FUNCTION_8_11();
          OUTLINED_FUNCTION_14_12();
          if (v85)
          {
            v75 = 0;
          }

          else
          {
            v75 = v74;
          }

          v76 = v75 + 32;
          v77 = *(v75 + 40);
          OUTLINED_FUNCTION_14_12();
          if (v85)
          {
            v80 = 0;
          }

          else
          {
            v80 = v78;
          }

          v82 = *(v80 + 48);
          v81 = *(v80 + 56);
          __src = *(v79 + 8);
          mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&__src);
          v84 = v82 + 8 * v83;
          v85 = v77 == v76 || v84 == v81;
          if (!v85)
          {
            v86 = v84 + 8;
            do
            {
              __src = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v77, v83);
              mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&__src, 1u);
              OUTLINED_FUNCTION_107_2();
              v88 = *(v86 - 8);
              v89 = v87[1];
              if (v89)
              {
                v90 = *v87;
                *v89 = *v87;
                if (v90)
                {
                  *(v90 + 8) = v89;
                }
              }

              v87[3] = v88;
              v87[1] = v88;
              v91 = *v88;
              *v87 = *v88;
              if (v91)
              {
                *(v91 + 8) = v87;
              }

              *v88 = v87;
              v77 = *(v77 + 8);
              v92 = v77 == v76 || v86 == v81;
              v86 += 8;
            }

            while (!v92);
          }

          v93 = *(v70 + 16);
          v94 = *(MPSGraphDelegateCompiler.precompilationDescriptor.modify(v70, v83) + 8);
          *(v119 + 24) = v93;
          *(v119 + 32) = v94;
          v95 = *(v70 + 36);
          if (v95)
          {
            v96 = v70 - 16;
          }

          else
          {
            v96 = 0;
          }

          __src = v172;
          v171 = 0x600000000;
          if (v95 < 7)
          {
            if (!v95)
            {
              v101 = 0;
LABEL_123:
              v102 = v101 + v95;
              LODWORD(v171) = v102;
              if (v168)
              {
                v103 = v167;
                v104 = (v167 + 24 * v168);
                v105 = v167;
                do
                {
                  v106 = *v105;
                  v105 += 3;
                  v107 = (__src + 8 * v106);
                  *v107 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::Type &,mlir::Value &>((v119 + 8), v45, v103 + 2, v107) - 16;
                  v103 = v105;
                }

                while (v105 != v104);
                v102 = v171;
              }

              v108 = v125;
              mlir::ValueRange::ValueRange(&v148, __src, v102);
              (**v119)(v119, v108, v148, v149);
              if (__src != v172)
              {
                free(__src);
              }

              goto LABEL_41;
            }

            v97 = 0;
            v98 = v172;
          }

          else
          {
            OUTLINED_FUNCTION_137_1(&__src, v172);
            v97 = v171;
            v98 = __src;
          }

          v99 = 0;
          v100 = &v98[8 * v97];
          do
          {
            *&v100[8 * v99] = mlir::detail::OpResultImpl::getNextResultAtOffset(v96, v99);
            ++v99;
          }

          while (v95 != v99);
          v101 = v171;
          goto LABEL_123;
        }

        if (v171 < 7)
        {
          v56 = v11;
          v55 = v171;
        }

        else
        {
          OUTLINED_FUNCTION_124_2(&v132, v11);
          v55 = v171;
          if (!v171)
          {
LABEL_75:
            LODWORD(v133) = v54;
            goto LABEL_76;
          }

          v56 = v132;
        }

        memcpy(v56, __src, 8 * v55);
        goto LABEL_75;
      }

      if (v171 < 7)
      {
        v52 = &v142;
        v51 = v171;
      }

      else
      {
        OUTLINED_FUNCTION_124_2(&v140, &v142);
        v51 = v171;
        if (!v171)
        {
LABEL_65:
          LODWORD(v141) = v50;
          goto LABEL_66;
        }

        v52 = v140;
      }

      memcpy(v52, __src, 8 * v51);
      goto LABEL_65;
    }

    if (v171 < 7)
    {
      v48 = &v150;
      v47 = v171;
    }

    else
    {
      OUTLINED_FUNCTION_137_1(&v148, &v150);
      v47 = v171;
      if (!v171)
      {
LABEL_55:
        LODWORD(v149) = v46;
        goto LABEL_56;
      }

      v48 = v148;
    }

    memcpy(v48, __src, 8 * v47);
    goto LABEL_55;
  }

LABEL_41:
  if (v156 != v120)
  {
    free(v156);
  }

  if (v167 != v121)
  {
    free(v167);
  }

  if ((v164 & 1) == 0)
  {
    llvm::deallocate_buffer(v165, (8 * v166));
  }

  OUTLINED_FUNCTION_91_3();
}

void anonymous namespace::ForallOpControlOperandsFolder::matchAndRewrite()
{
  OUTLINED_FUNCTION_93_2();
  v1 = v0;
  v3 = v2;
  v188 = *MEMORY[0x1E69E9840];
  v136 = v2;
  mlir::scf::ForallOp::getLoopLowerBounds(&v136, &__src);
  v4 = &v156;
  v154 = &v156;
  v155 = 0x600000000;
  v5 = v163;
  if (v163)
  {
    if (v163 < 7)
    {
      v7 = &v156;
      v6 = v163;
    }

    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(&v154, &v156, v163, 8);
      v6 = v163;
      if (!v163)
      {
LABEL_7:
        LODWORD(v155) = v5;
        goto LABEL_8;
      }

      v7 = v154;
    }

    memcpy(v7, __src, 8 * v6);
    goto LABEL_7;
  }

LABEL_8:
  if (v170 == 1)
  {
    OUTLINED_FUNCTION_65_4();
    if (!v9)
    {
      free(v8);
    }
  }

  mlir::scf::ForallOp::getLoopUpperBounds(&v136, &__src);
  v10 = &v148;
  v146 = &v148;
  v147 = 0x600000000;
  v11 = v163;
  if (v163)
  {
    if (v163 < 7)
    {
      v13 = &v148;
      v12 = v163;
    }

    else
    {
      OUTLINED_FUNCTION_139_1(&v146, &v148);
      v12 = v163;
      if (!v163)
      {
LABEL_17:
        LODWORD(v147) = v11;
        goto LABEL_18;
      }

      v13 = v146;
    }

    memcpy(v13, __src, 8 * v12);
    goto LABEL_17;
  }

LABEL_18:
  if (v170 == 1)
  {
    OUTLINED_FUNCTION_65_4();
    if (!v9)
    {
      free(v14);
    }
  }

  mlir::scf::ForallOp::getLoopSteps(&v136, &__src);
  v15 = &v140;
  v138 = &v140;
  v139 = 0x600000000;
  v16 = v163;
  if (v163)
  {
    if (v163 < 7)
    {
      v18 = &v140;
      v17 = v163;
    }

    else
    {
      OUTLINED_FUNCTION_137_1(&v138, &v140);
      v17 = v163;
      if (!v163)
      {
LABEL_27:
        LODWORD(v139) = v16;
        goto LABEL_28;
      }

      v18 = v138;
    }

    memcpy(v18, __src, 8 * v17);
    goto LABEL_27;
  }

LABEL_28:
  if (v170 == 1)
  {
    OUTLINED_FUNCTION_65_4();
    if (!v9)
    {
      free(v19);
    }
  }

  if (mlir::foldDynamicIndexList(&v154, 0, 0) & 1) != 0 || (mlir::foldDynamicIndexList(&v146, 0, 0) & 1) != 0 || (mlir::foldDynamicIndexList(&v138, 0, 0))
  {
    ((*v1)[5])(v1, v3);
    __src = &v164;
    v163 = 0x600000000;
    v183 = v185;
    v184 = 0x600000000;
    v180 = v182;
    v181 = 0x600000000;
    v178[0] = v179;
    v178[1] = 0x600000000;
    v176[0] = v177;
    v176[1] = 0x600000000;
    v174[0] = v175;
    v174[1] = 0x600000000;
    mlir::dispatchIndexOpFoldResults(v154, v155, &__src, v178);
    v20 = *(v3 + 64 + 16 * ((*(v3 + 44) >> 23) & 1) + 32);
    OUTLINED_FUNCTION_146_1();
    v22 = *(v21 - 8);
    Context = mlir::Attribute::getContext((v3 + 24));
    v24 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, (v3 + 64 + 16 * ((*(v3 + 44) >> 23) & 1) + 32), 4);
    mlir::NamedAttribute::NamedAttribute(&v137, v22, v24);
    LODWORD(v186) = 0;
    v187 = v137;
    mlir::MutableOperandRange::MutableOperandRange(v171, v3, 0, v20, &v186, 1);
    mlir::ValueRange::ValueRange(&v186, __src, v163);
    mlir::MutableOperandRange::assign(v171, v186, v187);
    if (v172 != v173)
    {
      free(v172);
    }

    v25 = v136;
    v26 = mlir::Attribute::getContext((v136 + 24));
    OUTLINED_FUNCTION_128_2(v26, v27, v28, v29, v30, v31, v32, v33, v177, v179, v182, v185, &v164, &v140, &v148, &v156, v136, v137, *(&v137 + 1), v138, v139, v140, v141, v142, v143, v144, v145, v146, v147, v148, v149, v150, v151, v152, v153, v154, v155, v156, v157, v158, v159, v160, v161, __src, v163, v164, v165, v166, v167, v168, v169, v170, v26);
    OUTLINED_FUNCTION_26_8();
    *(v35 + 8) = v34;
    mlir::dispatchIndexOpFoldResults(v146, v147, &v183, v176);
    OUTLINED_FUNCTION_26_8();
    v37 = *(v36 + 32);
    v38 = *(v36 + 36);
    OUTLINED_FUNCTION_146_1();
    v40 = *(v39 - 8);
    mlir::Attribute::getContext((v25 + 24));
    OUTLINED_FUNCTION_26_8();
    v43 = mlir::detail::DenseArrayAttrImpl<int>::get(v42, (v41 + 32), 4);
    v44 = mlir::NamedAttribute::NamedAttribute(&v137, v40, v43);
    LODWORD(v186) = 1;
    OUTLINED_FUNCTION_148_1(v44, v45, v46, v47, v48, v49, v50, v51, v97, v102, v107, v112, v117, v121, v126, v131, v136, v52);
    mlir::MutableOperandRange::MutableOperandRange(v53, v25, v37, v38, &v186, 1);
    mlir::ValueRange::ValueRange(&v186, v183, v184);
    mlir::MutableOperandRange::assign(v171, v186, v187);
    if (v172 != v173)
    {
      free(v172);
    }

    v54 = mlir::Attribute::getContext((v25 + 24));
    OUTLINED_FUNCTION_128_2(v54, v55, v56, v57, v58, v59, v60, v61, v98, v103, v108, v113, v118, v122, v127, v132, v136, v137, *(&v137 + 1), v138, v139, v140, v141, v142, v143, v144, v145, v146, v147, v148, v149, v150, v151, v152, v153, v154, v155, v156, v157, v158, v159, v160, v161, __src, v163, v164, v165, v166, v167, v168, v169, v170, v54);
    OUTLINED_FUNCTION_26_8();
    *(v63 + 24) = v62;
    mlir::dispatchIndexOpFoldResults(v138, v139, &v180, v174);
    OUTLINED_FUNCTION_26_8();
    v65 = v64[8];
    v66 = v64[9];
    v67 = v64[10];
    OUTLINED_FUNCTION_146_1();
    v69 = *(v68 - 8);
    mlir::Attribute::getContext((v25 + 24));
    OUTLINED_FUNCTION_26_8();
    v72 = mlir::detail::DenseArrayAttrImpl<int>::get(v71, (v70 + 32), 4);
    v73 = mlir::NamedAttribute::NamedAttribute(&v137, v69, v72);
    LODWORD(v186) = 2;
    OUTLINED_FUNCTION_148_1(v73, v74, v75, v76, v77, v78, v79, v80, v99, v104, v109, v114, v119, v123, v128, v133, v136, v81);
    mlir::MutableOperandRange::MutableOperandRange(v82, v25, v66 + v65, v67, &v186, 1);
    mlir::ValueRange::ValueRange(&v186, v180, v181);
    mlir::MutableOperandRange::assign(v171, v186, v187);
    if (v172 != v173)
    {
      free(v172);
    }

    v83 = mlir::Attribute::getContext((v25 + 24));
    OUTLINED_FUNCTION_128_2(v83, v84, v85, v86, v87, v88, v89, v90, v100, v105, v110, v115, v120, v124, v129, v134, v136, v137, *(&v137 + 1), v138, v139, v140, v141, v142, v143, v144, v145, v146, v147, v148, v149, v150, v151, v152, v153, v154, v155, v156, v157, v158, v159, v160, v161, __src, v163, v164, v165, v166, v167, v168, v169, v170, v83);
    OUTLINED_FUNCTION_26_8();
    *(v92 + 16) = v91;
    v186 = __PAIR64__(v184, v163);
    *&v187 = __PAIR64__(*(v25 + 36), v181);
    DenseI32ArrayAttr = mlir::Builder::getDenseI32ArrayAttr(v1 + 1, &v186, 4);
    v94 = mlir::Attribute::getContext((v25 + 24));
    v173[0] = 261;
    v171[0] = "operandSegmentSizes";
    v171[1] = 19;
    v95 = mlir::StringAttr::get(v94, v171);
    mlir::Operation::setAttr(v25, v95, DenseI32ArrayAttr);
    v4 = v135;
    if (v174[0] != v175)
    {
      free(v174[0]);
    }

    v15 = v125;
    v10 = v130;
    if (v176[0] != v101)
    {
      free(v176[0]);
    }

    if (v178[0] != v106)
    {
      free(v178[0]);
    }

    if (v180 != v111)
    {
      free(v180);
    }

    if (v183 != v116)
    {
      free(v183);
    }

    OUTLINED_FUNCTION_153_1();
    if (!v9)
    {
      free(v96);
    }

    ((*v1)[6])(v1, v3);
  }

  if (v138 != v15)
  {
    free(v138);
  }

  if (v146 != v10)
  {
    free(v146);
  }

  if (v154 != v4)
  {
    free(v154);
  }

  OUTLINED_FUNCTION_91_3();
}

void anonymous namespace::RemoveLoopInvariantArgsFromBeforeBlock::matchAndRewrite()
{
  OUTLINED_FUNCTION_93_2();
  v98 = v0;
  v2 = v1;
  v122 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_117_2();
  OUTLINED_FUNCTION_5_14();
  OUTLINED_FUNCTION_86_3();
  if (v27)
  {
    v4 = 0;
  }

  else
  {
    v4 = v3;
  }

  OUTLINED_FUNCTION_14_12();
  if (v27)
  {
    v7 = 0;
  }

  else
  {
    v7 = v6;
  }

  v8 = *(v7 + 6);
  Terminator = mlir::Block::getTerminator(v7, v5);
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v11 = *(Terminator + 72);
  }

  else
  {
    v11 = 0;
  }

  v12 = mlir::Block::getTerminator(v4, v10);
  v13 = v12;
  if ((*(v12 + 46) & 0x80) != 0)
  {
    v14 = *(v12 + 72);
    v15 = *(v12 + 68);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(&v120, v14, v15);
  if ((*(v2 + 46) & 0x80) != 0)
  {
    v16 = *(v2 + 72);
    v17 = *(v2 + 68);
  }

  else
  {
    v16 = 0;
    v17 = 0;
  }

  v115 = 0;
  v116 = v16;
  v117 = 0;
  v118 = v120;
  v119 = 0;
  if (v17)
  {
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v21 = v11 + 32;
    v22 = v121;
    do
    {
      if (v19 == v22)
      {
        break;
      }

      v23 = *(v116 + 32 * v20 + 24);
      if (v23 != mlir::ValueRange::dereference_iterator(&v118, v19))
      {
        OUTLINED_FUNCTION_140_1();
        if (!v25 || *(v25 + 16) != v4)
        {
          continue;
        }

        v26 = *(v21 + 32 * *(v25 + 24) + 24);
        v27 = v26 == *(v8 + 8 * v18) || v26 == v23;
        if (!v27)
        {
          continue;
        }
      }

      v115 = &v117;
      v116 = 0x600000000;
      v112 = &v114;
      v113 = 0x600000000;
      v101[0] = 0;
      v101[1] = 0;
      v102 = 0;
      v109 = v111;
      v110 = 0x600000000;
      if ((*(v2 + 46) & 0x80) != 0)
      {
        v28 = *(v2 + 72);
        v29 = *(v2 + 68);
      }

      else
      {
        v28 = 0;
        v29 = 0;
      }

      v103.n128_u64[0] = 0;
      v103.n128_u64[1] = v28;
      v104 = 0;
      v105 = v120;
      v106 = 0;
      if (v29)
      {
        v30 = v121;
        if (v121)
        {
          v24 = 0;
          v31 = 0;
          v32 = 0;
          do
          {
            v33 = *(v103.n128_u64[1] + 32 * v32 + 24);
            v34 = mlir::ValueRange::dereference_iterator(&v105, v24);
            v108.n128_u64[0] = v33;
            v108.n128_u64[1] = v34;
            if (v33 == v34 || (OUTLINED_FUNCTION_140_1(), v35) && *(v35 + 16) == v4 && ((v36 = *(v21 + 32 * *(v35 + 24) + 24), v36 != v33) ? (v37 = v36 == *(v8 + 8 * v31)) : (v37 = 1), v37))
            {
              v99 = v31;
              v100 = v33;
              llvm::DenseMapBase<llvm::DenseMap<unsigned int,mlir::Value,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::Value>>,unsigned int,mlir::Value,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::Value>>::try_emplace<mlir::Value>(v101, &v99, &v100, &v107);
            }

            else
            {
              v38 = v116;
              if (v116 >= HIDWORD(v116))
              {
                llvm::SmallVectorTemplateBase<long long,true>::growAndEmplaceBack<long long>(&v115, &v108);
              }

              else
              {
                v115[v116] = v33;
                LODWORD(v116) = v38 + 1;
              }

              v39 = v113;
              if (v113 >= HIDWORD(v113))
              {
                llvm::SmallVectorTemplateBase<long long,true>::growAndEmplaceBack<long long>(&v112, &v108.n128_i64[1]);
              }

              else
              {
                v112[v113] = v108.n128_i64[1];
                LODWORD(v113) = v39 + 1;
              }

              v40 = *(*(v8 + 8 * v31) + 32);
              v107.n128_u64[0] = v40;
              if (v110 >= HIDWORD(v110))
              {
                llvm::SmallVectorTemplateBase<long long,true>::growAndEmplaceBack<long long>(&v109, &v107);
              }

              else
              {
                *(v109 + v110) = v40;
                LODWORD(v110) = v110 + 1;
              }
            }

            v31 = v103.n128_u32[0] + 1;
            v32 = v104 + 1;
            ++v103.n128_u64[0];
            v104 = v32;
            v24 = ++v106;
          }

          while (v32 != v29 && v24 != v30);
        }
      }

      v42 = (v98 + 3);
      v97 = *(v98 + 3);
      v43 = *(v13 + 16);
      v44 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v13, v24);
      v98[3] = v43;
      v98[4] = v44;
      v45 = mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>((v98 + 1), *(v13 + 24), &v112);
      v46 = (*(*v98 + 8))(v98, v13, v45);
      v54 = OUTLINED_FUNCTION_144_1(v46, v47, v48, v49, v50, v51, v52, v53, v97);
      if (v55)
      {
        *v42 = v54;
      }

      else
      {
        v42->n128_u64[0] = 0;
        v98[4] = 0;
      }

      v56 = *(v2 + 24);
      v57 = *(v2 + 36);
      v58 = v2 - 16;
      if (!v57)
      {
        v58 = 0;
      }

      v107.n128_u64[0] = v58;
      v107.n128_u64[1] = v57;
      mlir::OperandRange::getTypes(&v107, &v103);
      v59 = mlir::OpBuilder::create<mlir::scf::WhileOp,mlir::ValueTypeRange<mlir::ResultRange>,llvm::SmallVector<mlir::Value,6u> &>((v98 + 1), v56, &v103, &v115);
      OUTLINED_FUNCTION_87_3();
      OUTLINED_FUNCTION_6_13();
      v62 = v60 + 32 * v61;
      mlir::ValueRange::ValueRange(v108.n128_u64, v112, v113);
      mlir::ValueRange::getTypes(&v108, &v103);
      v64 = v103.n128_u64[1];
      v63 = v103.n128_u64[0];
      v65 = v105;
      v107 = v103;
      if (v103.n128_u64[1])
      {
        v63 = mlir::ValueRange::offset_base(&v107, v103.n128_i64[1]);
        v64 = v107.n128_u64[1];
      }

      mlir::TypeRange::TypeRange(v107.n128_u64, v63, v65 - v64);
      Block = mlir::OpBuilder::createBlock(v98 + 1, v62, 0, v107.n128_i64[0], v107.n128_i64[1], v109, v110);
      OUTLINED_FUNCTION_123_2();
      OUTLINED_FUNCTION_5_14();
      OUTLINED_FUNCTION_14_12();
      if (v27)
      {
        v68 = 0;
      }

      else
      {
        v68 = v67;
      }

      v69 = *(v68 + 56) - *(v68 + 48);
      v70 = v69 >> 3;
      v71 = (v69 >> 3);
      v103.n128_u64[0] = &v104;
      v103.n128_u64[1] = 0x600000000;
      if ((v69 >> 3))
      {
        if (v71 < 7)
        {
          v72 = 0;
        }

        else
        {
          OUTLINED_FUNCTION_124_2(&v103, &v104);
          v72 = v103.n128_u32[2];
        }

        if (v71 != v72)
        {
          OUTLINED_FUNCTION_134_1(v72);
        }

        v103.n128_u32[2] = v70;
        v73 = (*(v68 + 56) - *(v68 + 48)) >> 3;
      }

      else
      {
        v73 = v69 >> 3;
        LODWORD(v70) = 0;
      }

      v107.n128_u32[0] = 0;
      if (v73)
      {
        v74 = v102;
        if (v102)
        {
          v75 = 0;
          v76 = 0;
LABEL_75:
          v77 = *(v101[0] + 4 * ((v74 - 1) & (37 * v75)));
          if (v75 == v77)
          {
LABEL_76:
            v78 = llvm::DenseMapBase<llvm::DenseMap<unsigned int,mlir::Value,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::Value>>,unsigned int,mlir::Value,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::Value>>::operator[](v101, &v107);
            v75 = v107.n128_u32[0];
            v79 = v103.n128_u64[0];
            *(v103.n128_u64[0] + 8 * v107.n128_u32[0]) = *v78;
            goto LABEL_81;
          }

          while (v77 != -1)
          {
            OUTLINED_FUNCTION_157_1();
            v77 = *(v80 + v81);
            if (v75 == v77)
            {
              goto LABEL_76;
            }
          }

          while (1)
          {
            v82 = *(*(Block + 6) + 8 * v76++);
            v79 = v103.n128_u64[0];
            *(v103.n128_u64[0] + 8 * v75) = v82;
LABEL_81:
            v107.n128_u32[0] = ++v75;
            if (v75 >= v73)
            {
              break;
            }

            v74 = v102;
            if (v102)
            {
              goto LABEL_75;
            }
          }

          LODWORD(v70) = v103.n128_u32[2];
        }

        else
        {
          LODWORD(v83) = 0;
          v84 = 0;
          v85 = *(Block + 6);
          v79 = v103.n128_u64[0];
          if (v73 < 4)
          {
            goto LABEL_91;
          }

          if (v103.n128_u64[0] - v85 < 0x20)
          {
            goto LABEL_91;
          }

          v84 = v73 & 0xFFFFFFFC;
          LODWORD(v83) = v73 & 0xFFFFFFFC;
          v86 = (v103.n128_u64[0] + 16);
          v87 = (v85 + 16);
          v88 = v84;
          do
          {
            v89 = *v87;
            *(v86 - 1) = *(v87 - 1);
            *v86 = v89;
            v86 += 2;
            v87 += 2;
            v88 -= 4;
          }

          while (v88);
          if (v84 != v73)
          {
LABEL_91:
            v90 = (v85 + 8 * v84);
            v83 = v83;
            do
            {
              v91 = *v90++;
              *(v79 + 8 * v83++) = v91;
            }

            while (v83 < v73);
          }
        }
      }

      else
      {
        v79 = v103.n128_u64[0];
      }

      mlir::ValueRange::ValueRange(v107.n128_u64, v79, v70);
      mlir::RewriterBase::mergeBlocks(v98, v68, Block, v107.n128_i64[0], v107.n128_i64[1]);
      OUTLINED_FUNCTION_123_2();
      OUTLINED_FUNCTION_5_14();
      OUTLINED_FUNCTION_37_4();
      mlir::RewriterBase::inlineRegionBefore(v98, (v92 + 24), v93 + 24, *(v93 + 32));
      v94 = *(v59 + 36);
      if (v94)
      {
        v95 = v59 - 16;
      }

      else
      {
        v95 = 0;
      }

      mlir::ValueRange::ValueRange(v107.n128_u64, v95, v94);
      OUTLINED_FUNCTION_63();
      (*v96)(v98, v2);
      if (v103.n128_u64[0] != &v104)
      {
        free(v103.n128_u64[0]);
      }

      if (v109 != v111)
      {
        free(v109);
      }

      llvm::deallocate_buffer(v101[0], (16 * v102));
      v18 = v115 + 1;
      v20 = v117 + 1;
      v115 = (v115 + 1);
      v117 = v20;
      v19 = ++v119;
    }

    while (v20 != v17);
  }

  OUTLINED_FUNCTION_91_3();
}

uint64_t anonymous namespace::WhileConditionTruth::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_5_14();
  OUTLINED_FUNCTION_14_12();
  if (v29)
  {
    v6 = 0;
  }

  else
  {
    v6 = v5;
  }

  Terminator = mlir::Block::getTerminator(v6, v4);
  v8 = Terminator;
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v9 = *(Terminator + 68) - 1;
  }

  else
  {
    v9 = -1;
  }

  OUTLINED_FUNCTION_37_4();
  OUTLINED_FUNCTION_86_3();
  if (v29)
  {
    v13 = 0;
  }

  else
  {
    v13 = v11;
  }

  if (v9)
  {
    v14 = *(v13 + 48);
    v15 = *(v13 + 56);
    if (v14 != v15)
    {
      v12 = 0;
      v16 = 0;
      v17 = 0;
      v18 = v10 + 32;
      v32 = v9;
      do
      {
        if (*(v18 + 32 * v17 + 24) == *(*(v8 + 72) + 24))
        {
          v19 = **v14;
          if (v19)
          {
            if (v16 || (v20 = *(a2 + 24), OUTLINED_FUNCTION_121_1(), v34 = v21, BoolAttr = mlir::Builder::getBoolAttr((a3 + 8), 1), v16 = (mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::Type &,mlir::BoolAttr>((a3 + 8), v20, &v34, &BoolAttr) - 16), (v19 = **v14) != 0))
            {
              do
              {
                v22 = *v19;
                v23 = v19[2];
                OUTLINED_FUNCTION_104();
                (*(v24 + 40))(a3, v23);
                v25 = v19[1];
                if (v25)
                {
                  v26 = *v19;
                  *v25 = *v19;
                  if (v26)
                  {
                    v26[1] = v25;
                  }
                }

                v19[3] = v16;
                v27 = *v16;
                *v19 = *v16;
                v19[1] = v16;
                if (v27)
                {
                  *(v27 + 8) = v19;
                }

                *v16 = v19;
                OUTLINED_FUNCTION_104();
                (*(v28 + 48))(a3, v23);
                v19 = v22;
              }

              while (v22);
              v12 = 1;
              v9 = v32;
            }

            else
            {
              v12 = 1;
            }
          }
        }

        ++v17;
        ++v14;
        v29 = v17 == v9 || v14 == v15;
      }

      while (!v29);
    }
  }

  return v12 & 1;
}

void anonymous namespace::WhileUnusedResult::matchAndRewrite()
{
  OUTLINED_FUNCTION_93_2();
  v1 = v0;
  v3 = v2;
  v95[6] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_117_2();
  OUTLINED_FUNCTION_14_12();
  if (v17)
  {
    v6 = 0;
  }

  else
  {
    v6 = v5;
  }

  Terminator = mlir::Block::getTerminator(v6, v4);
  OUTLINED_FUNCTION_123_2();
  OUTLINED_FUNCTION_5_14();
  OUTLINED_FUNCTION_33_3();
  if (v17)
  {
    v10 = 0;
  }

  else
  {
    v10 = v9;
  }

  v73 = v1;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v11 = *(Terminator + 72);
    v12 = *(Terminator + 68) - 1;
  }

  else
  {
    v11 = 0;
    v12 = -1;
  }

  v13 = *(v10 + 48);
  v14 = *(v10 + 56);
  v93 = v95;
  v94 = 0xC00000000;
  v90 = v92;
  v91 = 0x600000000;
  v87 = v89;
  v88 = 0x600000000;
  v84 = v86;
  v15 = *(v3 + 36);
  if (v15)
  {
    v16 = v3 - 16;
  }

  else
  {
    v16 = 0;
  }

  v85 = 0x600000000;
  if (v15)
  {
    v17 = v13 == v14 || v12 == 0;
    if (!v17)
    {
      v72 = v3;
      v74 = 0;
      v18 = (v11 + 56);
      v19 = v13 + 8;
      v20 = 1;
      do
      {
        NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, v20 - 1);
        v23 = *v18;
        v76 = v20 - 1;
        v81 = NextResultAtOffset;
        v24 = *(v19 - 8);
        v79 = v23;
        if (*NextResultAtOffset || *v24)
        {
          if (v94 >= HIDWORD(v94))
          {
            llvm::SmallVectorTemplateBase<unsigned int,true>::growAndEmplaceBack<unsigned int &>(&v93, &v76);
          }

          else
          {
            v93[v94] = v20 - 1;
            LODWORD(v94) = v94 + 1;
          }

          v25 = v88;
          if (v88 >= HIDWORD(v88))
          {
            llvm::SmallVectorTemplateBase<long long,true>::growAndEmplaceBack<long long>(&v87, &v79);
          }

          else
          {
            v87[v88] = v79;
            LODWORD(v88) = v25 + 1;
          }

          OUTLINED_FUNCTION_121_1();
          v77 = v26;
          v27 = v91;
          if (v91 >= HIDWORD(v91))
          {
            llvm::SmallVectorTemplateBase<long long,true>::growAndEmplaceBack<long long>(&v90, &v77);
          }

          else
          {
            v90[v91] = v26;
            LODWORD(v91) = v27 + 1;
          }

          Loc = mlir::Value::getLoc(&v81);
          v77 = Loc;
          if (v85 >= HIDWORD(v85))
          {
            llvm::SmallVectorTemplateBase<long long,true>::growAndEmplaceBack<long long>(&v84, &v77);
          }

          else
          {
            v84[v85] = Loc;
            LODWORD(v85) = v85 + 1;
          }
        }

        else
        {
          v74 = 1;
        }

        v30 = v15 == v20 || v19 == v14 || v12 == v20;
        ++v20;
        v18 += 4;
        v19 += 8;
      }

      while (!v30);
      if (v74)
      {
        v31 = v73 + 3;
        v75 = *(v73 + 3);
        v32 = *(Terminator + 16);
        v33 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(Terminator, v22);
        v73[3] = v32;
        v73[4] = v33;
        v81 = *(*(Terminator + 72) + 24);
        v34 = mlir::OpBuilder::create<mlir::scf::ConditionOp,mlir::detail::TypedValue<mlir::IntegerType>,llvm::SmallVector<mlir::Value,6u> &>((v73 + 1), *(Terminator + 24), &v81, &v87);
        (*(*v73 + 8))(v73, Terminator, v34);
        if (v75)
        {
          *v31 = v75;
        }

        else
        {
          *v31 = 0;
          v73[4] = 0;
        }

        v35 = *(v72 + 24);
        if ((*(v72 + 46) & 0x80) != 0)
        {
          v36 = *(v72 + 68);
          v37 = *(v72 + 72);
        }

        else
        {
          OUTLINED_FUNCTION_84_2();
        }

        v81 = v37;
        v82 = v36;
        v38 = mlir::OpBuilder::create<mlir::scf::WhileOp,llvm::SmallVector<mlir::Type,6u> &,mlir::OperandRange>((v73 + 1), v35, &v90, &v81);
        OUTLINED_FUNCTION_87_3();
        OUTLINED_FUNCTION_6_13();
        v41 = v39 + 32 * v40;
        mlir::ValueRange::ValueRange(&v81, v90, v91);
        Block = mlir::OpBuilder::createBlock(v73 + 1, v41 + 24, 0, v81, v82, v84, v85);
        v43 = *(v72 + 36);
        v81 = v83;
        v82 = 0x600000000;
        if (v43)
        {
          if (v43 < 7)
          {
            v44 = 0;
          }

          else
          {
            OUTLINED_FUNCTION_137_1(&v81, v83);
            v44 = v82;
          }

          v45 = Block;
          if (v43 != v44)
          {
            OUTLINED_FUNCTION_134_1(v44);
          }

          LODWORD(v82) = v43;
          v46 = *(v72 + 36);
          OUTLINED_FUNCTION_150_1();
          if (v46)
          {
            if (v46 < 7)
            {
              v47 = 0;
            }

            else
            {
              OUTLINED_FUNCTION_124_2(&v79, v43);
              v47 = v80;
            }

            if (v46 != v47)
            {
              OUTLINED_FUNCTION_134_1(v47);
            }

            v80 = v46;
          }

          Block = v45;
        }

        else
        {
          OUTLINED_FUNCTION_150_1();
        }

        v48 = v94;
        if (v94)
        {
          v49 = v93;
          v50 = v81;
          v51 = *(Block + 6);
          v52 = v79;
          v53 = *v93;
          *(v81 + v53) = v38 - 16;
          v52[v53] = *v51;
          if (v48 != 1)
          {
            v54 = v49[1];
            v50[v54] = v38 - 32;
            v52[v54] = v51[1];
            if (v48 != 2)
            {
              v55 = v49[2];
              v50[v55] = v38 - 48;
              v52[v55] = v51[2];
              if (v48 != 3)
              {
                v56 = v49[3];
                v50[v56] = v38 - 64;
                v52[v56] = v51[3];
                if (v48 != 4)
                {
                  v57 = v49[4];
                  v50[v57] = v38 - 80;
                  v52[v57] = v51[4];
                  if (v48 != 5)
                  {
                    v58 = v49[5];
                    v50[v58] = v38 - 96;
                    v52[v58] = v51[5];
                    if (v48 != 6)
                    {
                      v59 = 4 * v48;
                      v60 = v49 + 6;
                      v61 = v51 + 6;
                      v62 = v59 - 24;
                      v63 = 0x100000001;
                      do
                      {
                        v65 = *v60++;
                        v64 = v65;
                        v50[v65] = v38 - 96 - 24 * v63;
                        v66 = *v61++;
                        v52[v64] = v66;
                        ++v63;
                        v62 -= 4;
                      }

                      while (v62);
                    }
                  }
                }
              }
            }
          }
        }

        OUTLINED_FUNCTION_6_13();
        OUTLINED_FUNCTION_6_13();
        mlir::RewriterBase::inlineRegionBefore(v73, v69, v67 + 32 * v68, *(v67 + 32 * v68 + 8));
        OUTLINED_FUNCTION_5_14();
        OUTLINED_FUNCTION_33_3();
        if (v17)
        {
          v71 = 0;
        }

        else
        {
          v71 = v70;
        }

        mlir::ValueRange::ValueRange(&v77, v79, v80);
        mlir::RewriterBase::mergeBlocks(v73, v71, Block, v77, v78);
        mlir::ValueRange::ValueRange(&v77, v81, v82);
        (**v73)(v73, v72, v77, v78);
        if (v79 != v43)
        {
          free(v79);
        }

        if (v81 != v83)
        {
          free(v81);
        }
      }
    }
  }

  if (v84 != v86)
  {
    free(v84);
  }

  if (v87 != v89)
  {
    free(v87);
  }

  if (v90 != v92)
  {
    free(v90);
  }

  if (v93 != v95)
  {
    free(v93);
  }

  OUTLINED_FUNCTION_91_3();
}

void anonymous namespace::WhileRemoveDuplicatedResults::matchAndRewrite()
{
  OUTLINED_FUNCTION_93_2();
  v1 = v0;
  v3 = v2;
  v119 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_117_2();
  OUTLINED_FUNCTION_5_14();
  OUTLINED_FUNCTION_14_12();
  if (v6)
  {
    v7 = 0;
  }

  else
  {
    v7 = v5;
  }

  Terminator = mlir::Block::getTerminator(v7, v4);
  v9 = Terminator;
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v10 = *(Terminator + 72);
    v11 = *(Terminator + 68) - 1;
  }

  else
  {
    v10 = 0;
    v11 = -1;
  }

  mlir::ValueRange::ValueRange(&v117, v10 + 32, v11);
  v93 = v97;
  v94 = v97;
  v95 = 8;
  v96 = 0;
  v12 = v118;
  v110 = v117;
  v111 = 0;
  if (!v118)
  {
    goto LABEL_19;
  }

  v13 = 0;
  do
  {
    v14 = mlir::ValueRange::dereference_iterator(&v110, v13);
    if (v94 != v93)
    {
LABEL_9:
      llvm::SmallPtrSetImplBase::insert_imp_big(&v93, v14);
      goto LABEL_10;
    }

    v15 = HIDWORD(v95);
    if (HIDWORD(v95))
    {
      v16 = 8 * HIDWORD(v95);
      v17 = v93;
      while (*v17 != v14)
      {
        ++v17;
        v16 -= 8;
        if (!v16)
        {
          goto LABEL_16;
        }
      }
    }

    else
    {
LABEL_16:
      if (HIDWORD(v95) >= v95)
      {
        goto LABEL_9;
      }

      ++HIDWORD(v95);
      v93[v15] = v14;
    }

LABEL_10:
    v13 = (v111 + 1);
    v111 = v13;
  }

  while (v13 != v12);
  v18 = v118;
  if (v118 == (HIDWORD(v95) - v96))
  {
LABEL_19:
    v110 = "No results to remove";
    v114 = 259;
    v107 = &v110;
    v19 = *(v1 + 16);
    if (v19 && mlir::RewriterBase::Listener::classof(v19))
    {
      (*(*v19 + 88))(v19, *(v3 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::scf::WhileOp &>(mlir::scf::WhileOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v107);
    }

    goto LABEL_91;
  }

  v110 = 1;
  v111 = -4096;
  v113 = -4096;
  v115 = -4096;
  v116 = -4096;
  v107 = v109;
  v108 = 0x600000000;
  if (v118 && (v20 = (4 * v118 / 3u + 1) | ((4 * v118 / 3u + 1) >> 1), v21 = v20 | (v20 >> 2) | ((v20 | (v20 >> 2)) >> 4), v22 = v21 | (v21 >> 8) | ((v21 | (v21 >> 8)) >> 16), v22 >= 4))
  {
    llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::grow(&v110, v22 + 1);
    v18 = v118;
    v23 = HIDWORD(v108);
  }

  else
  {
    v23 = 6;
  }

  if (v18 > v23)
  {
    OUTLINED_FUNCTION_139_1(&v107, v109);
    v18 = v118;
  }

  v101 = v117;
  v102 = 0;
  if (v18)
  {
    v24 = 0;
    while (1)
    {
      v25 = mlir::ValueRange::dereference_iterator(&v101, v24);
      v106.n128_u64[0] = v25;
      v26 = v110;
      if ((v110 & 1) == 0 && !v112)
      {
        goto LABEL_39;
      }

      OUTLINED_FUNCTION_53_3();
      v30 = *(v29 + 16 * ((v28 - 1) & (-348639895 * v27)));
      if (v30 != v25)
      {
        break;
      }

LABEL_34:
      v24 = v102 + 1;
      v102 = v24;
      if (v24 == v18)
      {
        goto LABEL_42;
      }
    }

    while (v30 != -4096)
    {
      OUTLINED_FUNCTION_157_1();
      v30 = *(v31 + v32);
      if (v30 == v25)
      {
        goto LABEL_34;
      }
    }

LABEL_39:
    v98 = v25;
    LODWORD(v99) = v26 >> 1;
    llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::try_emplace<unsigned int>(&v110, &v98, &v99, &v104);
    v33 = v108;
    if (v108 >= HIDWORD(v108))
    {
      llvm::SmallVectorTemplateBase<long long,true>::growAndEmplaceBack<long long>(&v107, &v106);
    }

    else
    {
      *(v107 + v108) = v106.n128_u64[0];
      LODWORD(v108) = v33 + 1;
    }

    goto LABEL_34;
  }

LABEL_42:
  mlir::ValueRange::ValueRange(v106.n128_u64, v107, v108);
  v34 = *(v3 + 24);
  mlir::ValueRange::getTypes(&v106, &v104);
  v91 = v3;
  if ((*(v3 + 46) & 0x80) != 0)
  {
    v35 = *(v3 + 68);
    v36 = *(v3 + 72);
  }

  else
  {
    OUTLINED_FUNCTION_84_2();
  }

  v101 = v36;
  v102 = v35;
  v98 = 0;
  v92 = 0;
  v90 = v1;
  mlir::OpBuilder::create<mlir::scf::WhileOp,mlir::ValueTypeRange<mlir::ValueRange>,mlir::OperandRange,decltype(nullptr),decltype(nullptr)>((v1 + 8), v34, v104.n128_u64, &v101);
  OUTLINED_FUNCTION_87_3();
  OUTLINED_FUNCTION_8_11();
  v40 = *(v39 + 8);
  v41 = v118;
  v98 = 0;
  v99 = v117;
  v6 = v40 == 0;
  v42 = v40 - 8;
  if (v6)
  {
    v43 = 0;
  }

  else
  {
    v43 = v42;
  }

  v44 = *(v39 + 32);
  v6 = v44 == 0;
  v45 = v44 - 8;
  v104.n128_u64[0] = &v105;
  if (v6)
  {
    v46 = 0;
  }

  else
  {
    v46 = v45;
  }

  v104.n128_u64[1] = 0x600000000;
  v89 = v43;
  v100 = 0;
  v101 = &v103;
  v102 = 0x600000000;
  if (v118)
  {
    v47 = v37;
    v38 = 0;
    v48 = v37 - 96;
    do
    {
      mlir::ValueRange::dereference_iterator(&v99, v38);
      if ((v110 & 1) != 0 || (v49 = v111, v112))
      {
        OUTLINED_FUNCTION_53_3();
        v56 = -348639895 * v55;
        v58 = v57 - 1;
        v59 = (v57 - 1) & v56;
        v60 = *(v53 + 16 * v59);
        if (v60 == v52)
        {
LABEL_57:
          v51 = (v53 + 16 * v59);
          goto LABEL_58;
        }

        v66 = 1;
        while (v60 != -4096)
        {
          v67 = v59 + v66++;
          v59 = v67 & v58;
          v60 = *(v53 + 16 * v59);
          if (v60 == v52)
          {
            goto LABEL_57;
          }
        }

        v51 = &v117;
        if (v54)
        {
          goto LABEL_58;
        }

        v49 = v111;
        v50 = v112;
      }

      else
      {
        v50 = 0;
      }

      v51 = (v49 + 16 * v50);
LABEL_58:
      v61 = *(v51 + 2);
      v62 = *(*(v46 + 48) + 8 * v61);
      v92 = v62;
      v63 = v104.n128_u32[2];
      if (v104.n128_u32[2] >= v104.n128_u32[3])
      {
        llvm::SmallVectorTemplateBase<long long,true>::growAndEmplaceBack<long long>(&v104, &v92);
      }

      else
      {
        *(v104.n128_u64[0] + 8 * v104.n128_u32[2]) = v62;
        v104.n128_u32[2] = v63 + 1;
      }

      v64 = v48 - 24 * (v61 - 5);
      if (v61 <= 5)
      {
        v64 = v47 - 16 * v61 - 16;
      }

      v92 = v64;
      v65 = v102;
      if (v102 >= HIDWORD(v102))
      {
        llvm::SmallVectorTemplateBase<long long,true>::growAndEmplaceBack<long long>(&v101, &v92);
      }

      else
      {
        v101[v102] = v64;
        LODWORD(v102) = v65 + 1;
      }

      v38 = v100 + 1;
      ++v98;
      v100 = v38;
    }

    while (v38 != v41);
  }

  v68 = (v90 + 24);
  v88 = *(v90 + 24);
  v69 = v9[2];
  v70 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v9, v38);
  *(v90 + 24) = v69;
  *(v90 + 32) = v70;
  v98 = *(v9[9] + 24);
  v71 = mlir::OpBuilder::create<mlir::scf::ConditionOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::ValueRange &>((v90 + 8), v9[3], &v98, &v106);
  (*(*v90 + 8))(v90, v9, v71);
  OUTLINED_FUNCTION_5_14();
  OUTLINED_FUNCTION_86_3();
  if (v6)
  {
    v73 = 0;
  }

  else
  {
    v73 = v72;
  }

  OUTLINED_FUNCTION_33_3();
  if (v6)
  {
    v75 = 0;
  }

  else
  {
    v75 = v74;
  }

  mlir::ValueRange::ValueRange(&v98, *(v89 + 48), (*(v89 + 56) - *(v89 + 48)) >> 3);
  mlir::RewriterBase::mergeBlocks(v90, v73, v89, v98, v99);
  mlir::ValueRange::ValueRange(&v98, v104.n128_i64[0], v104.n128_u32[2]);
  mlir::RewriterBase::mergeBlocks(v90, v75, v46, v98, v99);
  mlir::ValueRange::ValueRange(&v98, v101, v102);
  v76 = (**v90)(v90, v91, v98, v99);
  v84 = OUTLINED_FUNCTION_144_1(v76, v77, v78, v79, v80, v81, v82, v83, v88);
  if (v85)
  {
    *v68 = v84;
  }

  else
  {
    v68->n128_u64[0] = 0;
    *(v90 + 32) = 0;
  }

  OUTLINED_FUNCTION_153_1();
  if (!v6)
  {
    free(v86);
  }

  OUTLINED_FUNCTION_152_1();
  if (!v6)
  {
    free(v87);
  }

  if (v107 != v109)
  {
    free(v107);
  }

  if ((v110 & 1) == 0)
  {
    llvm::deallocate_buffer(v111, (16 * v112));
  }

LABEL_91:
  if (v94 != v93)
  {
    free(v94);
  }

  OUTLINED_FUNCTION_91_3();
}

uint64_t anonymous namespace::WhileOpAlignBeforeArgs::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v109 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_117_2();
  OUTLINED_FUNCTION_5_14();
  OUTLINED_FUNCTION_14_12();
  if (v16)
  {
    v7 = 0;
  }

  else
  {
    v7 = v6;
  }

  Terminator = mlir::Block::getTerminator(v7, v5);
  mlir::ValueRange::ValueRange(&v104, v7[6], (v7[7] - v7[6]) >> 3);
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v9 = *(Terminator + 72);
    v10 = *(Terminator + 68) - 1;
  }

  else
  {
    v9 = 0;
    v10 = -1;
  }

  mlir::ValueRange::ValueRange(&v102, v9 + 32, v10);
  v11 = v105;
  v12 = v103;
  if (v105 == v103)
  {
    __dst = v104;
    v97 = 0;
    v106 = v102;
    v107 = 0;
    if (v105)
    {
      v13 = 0;
      do
      {
        v14 = mlir::ValueRange::dereference_iterator(&__dst, v13);
        if (v14 != mlir::ValueRange::dereference_iterator(&v106, v107))
        {
          goto LABEL_17;
        }

        v97 = (v97 + 1);
        v13 = v97;
        v15 = ++v107;
        v16 = v97 == v11 || v15 == v11;
      }

      while (!v16);
      if (v97 != v11 || v15 != v11)
      {
LABEL_17:
        v12 = v103;
        goto LABEL_18;
      }
    }

    return 0;
  }

LABEL_18:
  __dst = 1;
  v97 = -4096;
  v98 = -4096;
  v99 = -4096;
  v100 = -4096;
  v93 = v102;
  v94 = 0;
  if (v12)
  {
    v17 = 0;
    while (1)
    {
      v90 = mlir::ValueRange::dereference_iterator(&v93, v17);
      llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Value,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::try_emplace<llvm::detail::DenseSetEmpty&>(&__dst, &v90, &v106);
      if (v108[0] != 1)
      {
        break;
      }

      v17 = v94 + 1;
      v94 = v17;
      if (v17 == v12)
      {
        goto LABEL_22;
      }
    }

    v18 = 1;
  }

  else
  {
LABEL_22:
    v18 = 0;
  }

  if ((__dst & 1) == 0)
  {
    llvm::deallocate_buffer(v97, (8 * v98));
  }

  if (v18)
  {
    return 0;
  }

  v20 = v105;
  if (v105 != v103)
  {
    v19 = 0;
    LOBYTE(__dst) = 0;
    v101 = 0;
    goto LABEL_109;
  }

  v21 = v104;
  v22 = v102;
  v106 = v108;
  v107 = 0xC00000000;
  if (!v105)
  {
    OUTLINED_FUNCTION_161_0();
    goto LABEL_34;
  }

  if (v105 < 0xD)
  {
    v23 = 0;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v106, v108, v105, 4);
    v23 = v107;
  }

  if (v20 != v23)
  {
    bzero(&v106[4 * v23], 4 * (v20 - v23));
  }

  v26 = 0;
  v27 = 0;
  LODWORD(v107) = v20;
  v93 = 0;
  v94 = v21;
  v95[0] = 0;
  while (2)
  {
    v28 = mlir::ValueRange::dereference_iterator(&v94, v27);
    v24 = 0;
    __dst = v22;
    v97 = 0;
    while (1)
    {
      v29 = mlir::ValueRange::dereference_iterator(&__dst, v24);
      v30 = v97;
      if (v28 == v29)
      {
        break;
      }

      v24 = v97 + 1;
      v97 = (v97 + 1);
      if ((v30 + 1) == v20)
      {
        goto LABEL_48;
      }
    }

    if (v97 == v20)
    {
LABEL_48:
      v25 = 0;
      LOBYTE(__dst) = 0;
      v101 = 0;
      goto LABEL_49;
    }

    *&v106[4 * v97] = v26;
    v26 = v93 + 1;
    v27 = v95[0] + 1;
    v93 = v93 + 1;
    v95[0] = v27;
    if (v27 != v20)
    {
      continue;
    }

    break;
  }

  v31 = v107;
  OUTLINED_FUNCTION_161_0();
  if (!v31)
  {
    goto LABEL_34;
  }

  if (v24 == v108)
  {
    if (v31 < 0xD)
    {
      v86 = v31;
    }

    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(&__dst, v32, v31, 4);
      v86 = v107;
      if (!v107)
      {
LABEL_119:
        LODWORD(v97) = v31;
        goto LABEL_120;
      }

      v24 = v106;
      v32 = __dst;
    }

    memcpy(v32, v24, 4 * v86);
    goto LABEL_119;
  }

  __dst = v24;
  v97 = __PAIR64__(HIDWORD(v107), v31);
  v106 = v108;
  HIDWORD(v107) = 0;
LABEL_120:
  LODWORD(v107) = 0;
LABEL_34:
  v25 = 1;
  v101 = 1;
LABEL_49:
  if (v106 == v108)
  {
    if (v25)
    {
      goto LABEL_51;
    }
  }

  else
  {
    free(v106);
    if (v101)
    {
LABEL_51:
      v33 = (a3 + 24);
      v87 = *(a3 + 24);
      v34 = *(Terminator + 16);
      v35 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(Terminator, v24);
      *(a3 + 24) = v34;
      *(a3 + 32) = v35;
      v106 = *(*(Terminator + 72) + 24);
      mlir::OpBuilder::create<mlir::scf::ConditionOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::ValueRange &>((a3 + 8), *(Terminator + 24), &v106, &v104);
      OUTLINED_FUNCTION_63();
      v37 = (*(v36 + 8))(a3, Terminator);
      v45 = OUTLINED_FUNCTION_144_1(v37, v38, v39, v40, v41, v42, v43, v44, v87);
      if (v46)
      {
        *v33 = v45;
      }

      else
      {
        v33->n128_u64[0] = 0;
        *(a3 + 32) = 0;
      }

      OUTLINED_FUNCTION_123_2();
      OUTLINED_FUNCTION_5_14();
      OUTLINED_FUNCTION_33_3();
      if (v16)
      {
        v48 = 0;
      }

      else
      {
        v48 = v47;
      }

      v88 = v48;
      v49 = v105;
      v106 = v108;
      v107 = 0x600000000;
      if (v105)
      {
        if (v105 < 7)
        {
          v50 = 0;
        }

        else
        {
          OUTLINED_FUNCTION_137_1(&v106, v108);
          v50 = v107;
        }

        if (v49 != v50)
        {
          OUTLINED_FUNCTION_134_1(v50);
        }

        LODWORD(v107) = v49;
      }

      v51 = v97;
      if (v97)
      {
        v52 = __dst;
        v53 = v106;
        *&v106[8 * *__dst] = *(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
        if (v51 != 1)
        {
          v53[v52[1]] = *(a2 - 24) & 0xFFFFFFFFFFFFFFF8;
          if (v51 != 2)
          {
            v53[v52[2]] = *(a2 - 40) & 0xFFFFFFFFFFFFFFF8;
            if (v51 != 3)
            {
              v53[v52[3]] = *(a2 - 56) & 0xFFFFFFFFFFFFFFF8;
              if (v51 != 4)
              {
                v53[v52[4]] = *(a2 - 72) & 0xFFFFFFFFFFFFFFF8;
                if (v51 != 5)
                {
                  v53[v52[5]] = *(a2 - 88) & 0xFFFFFFFFFFFFFFF8;
                  if (v51 != 6)
                  {
                    v54 = (v52 + 6);
                    v55 = 4 * v51 - 24;
                    v56 = 0x100000001;
                    do
                    {
                      v57 = *v54++;
                      v53[v57] = *(a2 - 96 - 24 * v56++ + 8) & 0xFFFFFFFFFFFFFFF8;
                      v55 -= 4;
                    }

                    while (v55);
                  }
                }
              }
            }
          }
        }
      }

      v58 = *(a2 + 24);
      if ((*(a2 + 46) & 0x80) != 0)
      {
        v59 = *(a2 + 68);
        v60 = *(a2 + 72);
      }

      else
      {
        OUTLINED_FUNCTION_84_2();
      }

      v93 = v60;
      v94 = v59;
      v90 = 0;
      v89 = 0;
      v61 = mlir::OpBuilder::create<mlir::scf::WhileOp,llvm::SmallVector<mlir::Type,6u> &,mlir::OperandRange,decltype(nullptr),decltype(nullptr)>((a3 + 8), v58, &v106, &v93);
      OUTLINED_FUNCTION_87_3();
      OUTLINED_FUNCTION_8_11();
      OUTLINED_FUNCTION_86_3();
      if (v16)
      {
        v63 = 0;
      }

      else
      {
        v63 = v62;
      }

      OUTLINED_FUNCTION_33_3();
      if (v16)
      {
        v65 = 0;
      }

      else
      {
        v65 = v64;
      }

      v66 = v105;
      v93 = v95;
      v94 = 0x600000000;
      if (v105)
      {
        if (v105 < 7)
        {
          v67 = 0;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v93, v95, v105, 8);
          v67 = v94;
        }

        if (v66 != v67)
        {
          OUTLINED_FUNCTION_134_1(v67);
        }

        LODWORD(v94) = v66;
        v68 = v105;
        v90 = v92;
        v91 = 0x600000000;
        if (v105)
        {
          if (v105 < 7)
          {
            v69 = 0;
          }

          else
          {
            OUTLINED_FUNCTION_139_1(&v90, v92);
            v69 = v91;
          }

          if (v68 != v69)
          {
            OUTLINED_FUNCTION_134_1(v69);
          }

          LODWORD(v91) = v68;
        }
      }

      else
      {
        v90 = v92;
        v91 = 0x600000000;
      }

      if (v97)
      {
        v70 = __dst;
        v71 = v93;
        v72 = *(v65 + 48);
        v73 = 4 * v97;
        v74 = v90;
        do
        {
          v76 = *v70++;
          v75 = v76;
          v77 = v61 - 96 - 24 * (v76 - 5);
          v78 = v61 - 16 * v76 - 16;
          if (v76 <= 5)
          {
            v77 = v78;
          }

          *v71++ = v77;
          *v74++ = *(v72 + 8 * v75);
          v73 -= 4;
        }

        while (v73);
      }

      v79 = v63[5];
      mlir::ValueRange::ValueRange(&v89, v63[6], (v63[7] - v63[6]) >> 3);
      OUTLINED_FUNCTION_63();
      (*(v80 + 32))(a3, v7, v63, v79);
      v81 = *(v65 + 40);
      mlir::ValueRange::ValueRange(&v89, v90, v91);
      OUTLINED_FUNCTION_63();
      (*(v82 + 32))(a3, v88, v65, v81);
      mlir::ValueRange::ValueRange(&v89, v93, v94);
      OUTLINED_FUNCTION_63();
      (*v83)(a3, a2);
      if (v90 != v92)
      {
        free(v90);
      }

      if (v93 != v95)
      {
        free(v93);
      }

      if (v106 != v108)
      {
        free(v106);
      }

      v19 = 1;
      goto LABEL_109;
    }
  }

  v19 = 0;
LABEL_109:
  if (v101 == 1)
  {
    OUTLINED_FUNCTION_65_4();
    if (!v16)
    {
      free(v84);
    }
  }

  return v19;
}

void mlir::scf::SCFDialect::initialize()
{
  {
    v0 = llvm::getTypeName<mlir::ValueBoundsOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ValueBoundsOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::declarePromisedInterfaces<mlir::bufferization::BufferDeallocationOpInterface,mlir::scf::InParallelOp,mlir::scf::ReduceReturnOp>()
{
  {
    v0 = llvm::getTypeName<mlir::bufferization::BufferDeallocationOpInterface>();
    mlir::detail::TypeIDResolver<mlir::bufferization::BufferDeallocationOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::declarePromisedInterfaces<mlir::bufferization::BufferizableOpInterface,mlir::scf::ConditionOp,mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ForallOp,mlir::scf::InParallelOp,mlir::scf::WhileOp,mlir::scf::YieldOp>()
{
  {
    v0 = llvm::getTypeName<mlir::bufferization::BufferizableOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_63_3(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::bufferization::BufferizableOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_63_3(v2);
  }
}

void mlir::scf::ForOp::verify(uint64_t *a1, BOOL *a2)
{
  v22 = *MEMORY[0x1E69E9840];
  v11 = "mismatch in number of loop-carried values and defined values";
  v12 = 259;
  mlir::OpState::emitOpError(a1, &v11, v13);
  *a2 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v13);
  if (v13[0])
  {
    mlir::InFlightDiagnostic::report(v13);
  }

  if (v21 == 1)
  {
    if (v20 != &v21)
    {
      free(v20);
    }

    v3 = __p;
    if (__p)
    {
      v4 = v19;
      v5 = __p;
      if (v19 != __p)
      {
        do
        {
          v4 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v4 - 1);
        }

        while (v4 != v3);
        v5 = __p;
      }

      v19 = v3;
      operator delete(v5);
    }

    v6 = v16;
    if (v16)
    {
      v7 = v17;
      v8 = v16;
      if (v17 != v16)
      {
        do
        {
          v10 = *--v7;
          v9 = v10;
          *v7 = 0;
          if (v10)
          {
            operator delete[](v9);
          }
        }

        while (v7 != v6);
        v8 = v16;
      }

      v17 = v6;
      operator delete(v8);
    }

    if (v14 != &v15)
    {
      free(v14);
    }
  }
}

void mlir::scf::ForOp::replaceWithAdditionalYields(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "scf.for";
  *(a2 + 24) = 7;
}

void mlir::OpBuilder::create<mlir::tensor::InsertSliceOp,mlir::Type,mlir::Value &,mlir::Value &,mlir::OperandRange,mlir::OperandRange,mlir::OperandRange,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.insert_slice";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "scf.yield";
  *(a2 + 24) = 9;
}

void mlir::scf::ForallOp::verify()
{
  {
    v0 = llvm::getTypeName<mlir::DeviceMappingAttrInterface>();
    mlir::detail::TypeIDResolver<mlir::DeviceMappingAttrInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::scf::ForallOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::scf::ForallOp::verifyInvariantsImpl()
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_94_0();
  v4 = *(v3 + 96);
  if ((v5 & 0x800000) != 0)
  {
    v6 = *(v2 + 72);
    if (v4)
    {
      goto LABEL_3;
    }
  }

  else
  {
    v6 = 0;
    if (v4)
    {
LABEL_3:
      v7 = 0;
      v8 = v6 + 24;
      do
      {
        v9 = OUTLINED_FUNCTION_8_6();
        result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v9, v10, v11, v12, v7);
        if ((result & 1) == 0)
        {
          goto LABEL_25;
        }

        ++v7;
        v8 += 32;
      }

      while (v4 != v7);
    }
  }

  mlir::pdl_interp::RecordMatchOp::getODSOperands(v1, 1u);
  if (v14)
  {
    do
    {
      v15 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v15, v16, v17, v18, v4);
      if ((result & 1) == 0)
      {
        goto LABEL_25;
      }

      OUTLINED_FUNCTION_55_1();
    }

    while (!v19);
  }

  mlir::pdl_interp::RecordMatchOp::getODSOperands(v1, 2u);
  if (v20)
  {
    do
    {
      v21 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v21, v22, v23, v24, v4);
      if ((result & 1) == 0)
      {
        goto LABEL_25;
      }

      OUTLINED_FUNCTION_55_1();
    }

    while (!v19);
  }

  mlir::pdl_interp::RecordMatchOp::getODSOperands(v1, 3u);
  if (v25)
  {
    while (1)
    {
      v26 = OUTLINED_FUNCTION_8_6();
      result = mlir::scf::__mlir_ods_local_type_constraint_SCFOps5(v26, v27, v28, v29, v4);
      if ((result & 1) == 0)
      {
        break;
      }

      OUTLINED_FUNCTION_55_1();
      if (v19)
      {
        goto LABEL_18;
      }
    }

LABEL_25:
    v36 = 0;
    goto LABEL_26;
  }

LABEL_18:
  v30 = *(*v1 + 36);
  if (*(*v1 + 36))
  {
    v31 = *v1 - 16;
  }

  else
  {
    v31 = 0;
  }

  if (v30)
  {
    for (i = 0; i != v30; ++i)
    {
      mlir::detail::OpResultImpl::getNextResultAtOffset(v31, i);
    }
  }

  OUTLINED_FUNCTION_87_3();
  OUTLINED_FUNCTION_10_14();
  result = mlir::scf::__mlir_ods_local_region_constraint_SCFOps2(v35, v33 + 32 * v34, "region", 6, 0);
  v36 = result & 1;
LABEL_26:
  *v0 = v36;
  return result;
}

void mlir::scf::IndexSwitchOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_116_2(v2);
  }
}

void mlir::scf::ParallelOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::scf::ConditionOp>,mlir::OpTrait::ZeroResults<mlir::scf::ConditionOp>,mlir::OpTrait::ZeroSuccessors<mlir::scf::ConditionOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::scf::ConditionOp>,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl<mlir::scf::ConditionOp>,mlir::OpTrait::OpInvariants<mlir::scf::ConditionOp>,mlir::RegionBranchTerminatorOpInterface::Trait<mlir::scf::ConditionOp>,mlir::ConditionallySpeculatable::Trait<mlir::scf::ConditionOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::scf::ConditionOp>,mlir::MemoryEffectOpInterface::Trait<mlir::scf::ConditionOp>,mlir::OpTrait::IsTerminator<mlir::scf::ConditionOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_115_1(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_113_2(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_145_1(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_112_2(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::OneRegion<mlir::scf::ExecuteRegionOp>,mlir::OpTrait::VariadicResults<mlir::scf::ExecuteRegionOp>,mlir::OpTrait::ZeroSuccessors<mlir::scf::ExecuteRegionOp>,mlir::OpTrait::ZeroOperands<mlir::scf::ExecuteRegionOp>,mlir::OpTrait::OpInvariants<mlir::scf::ExecuteRegionOp>,mlir::RegionBranchOpInterface::Trait<mlir::scf::ExecuteRegionOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_60_4(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_111_2(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_83_4(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_82_4(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::LoopLikeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_85_4(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<3u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_81_4(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::LoopLikeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::LoopLikeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_141_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_80_3(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::OneRegion<mlir::scf::ForallOp>,mlir::OpTrait::VariadicResults<mlir::scf::ForallOp>,mlir::OpTrait::ZeroSuccessors<mlir::scf::ForallOp>,mlir::OpTrait::VariadicOperands<mlir::scf::ForallOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::scf::ForallOp>,mlir::OpTrait::SingleBlock<mlir::scf::ForallOp>,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl<mlir::scf::ForallOp>,mlir::OpTrait::OpInvariants<mlir::scf::ForallOp>,mlir::BytecodeOpInterface::Trait<mlir::scf::ForallOp>,mlir::OpTrait::AutomaticAllocationScope<mlir::scf::ForallOp>,mlir::LoopLikeOpInterface::Trait<mlir::scf::ForallOp>,mlir::OpTrait::HasRecursiveMemoryEffects<mlir::scf::ForallOp>,mlir::RegionBranchOpInterface::Trait<mlir::scf::ForallOp>,mlir::DestinationStyleOpInterface::Trait<mlir::scf::ForallOp>,mlir::OpTrait::HasParallelRegion<mlir::scf::ForallOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::DestinationStyleOpInterface>();
    mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::OpTrait::HasParallelRegion>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::DestinationStyleOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DestinationStyleOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DestinationStyleOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParallelRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParallelRegion>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParallelRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParallelRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NRegions<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NRegions<2u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NRegions<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NRegions<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::OneRegion<mlir::scf::InParallelOp>,mlir::OpTrait::ZeroResults<mlir::scf::InParallelOp>,mlir::OpTrait::ZeroSuccessors<mlir::scf::InParallelOp>,mlir::OpTrait::ZeroOperands<mlir::scf::InParallelOp>,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl<mlir::scf::InParallelOp>,mlir::OpTrait::NoTerminator<mlir::scf::InParallelOp>,mlir::OpTrait::SingleBlock<mlir::scf::InParallelOp>,mlir::OpTrait::OpInvariants<mlir::scf::InParallelOp>,mlir::ConditionallySpeculatable::Trait<mlir::scf::InParallelOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::scf::InParallelOp>,mlir::MemoryEffectOpInterface::Trait<mlir::scf::InParallelOp>,mlir::OpTrait::IsTerminator<mlir::scf::InParallelOp>,mlir::ParallelCombiningOpInterface::Trait<mlir::scf::InParallelOp>,mlir::RegionKindInterface::Trait<mlir::scf::InParallelOp>,mlir::OpTrait::HasOnlyGraphRegion<mlir::scf::InParallelOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::ParallelCombiningOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ParallelCombiningOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ParallelCombiningOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ParallelCombiningOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ParallelCombiningOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ParallelCombiningOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNRegions<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNRegions<1u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNRegions<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNRegions<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasParallelRegion>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::ReduceOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::ReduceOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::ReduceOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::ReduceOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::VariadicRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchTerminatorOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::VariadicRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicRegions>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::WhileOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::WhileOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::WhileOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::WhileOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t anonymous namespace::SCFInlinerInterface::handleTerminator(uint64_t result, uint64_t a2, uint64_t a3)
{
  v19 = *MEMORY[0x1E69E9840];
  if ((*(result + 46) & 0x80) != 0)
  {
    v4 = *(result + 72);
    v5 = *(result + 68);
  }

  else
  {
    v4 = 0;
    v5 = 0;
  }

  v15 = a2;
  v16 = 0;
  v17 = v4;
  v18 = 0;
  if (a3 && v5)
  {
    v6 = 0;
    do
    {
      result = mlir::ValueRange::dereference_iterator(&v15, v6);
      v7 = v18;
      v8 = *result;
      if (*result)
      {
        v9 = *(v17 + 32 * v18 + 24);
        do
        {
          v10 = v8[1];
          if (v10)
          {
            v11 = *v8;
            *v10 = *v8;
            if (v11)
            {
              *(v11 + 8) = v10;
            }
          }

          v8[3] = v9;
          v12 = *v9;
          *v8 = *v9;
          v8[1] = v9;
          if (v12)
          {
            *(v12 + 8) = v8;
          }

          *v9 = v8;
          v8 = *result;
        }

        while (*result);
      }

      v6 = v16 + 1;
      v13 = v7 + 1;
      v16 = v6;
      v18 = v13;
    }

    while (v6 != a3 && v13 != v5);
  }

  return result;
}

mlir::Block *anonymous namespace::SimplifyTrivialLoops::matchAndRewrite(mlir::Operation **a1, uint64_t a2, char *a3)
{
  YieldedValues = mlir::detail::LoopLikeOpInterfaceTrait<mlir::scf::ForOp>::getYieldedValues(a1, a2);
  if (result)
  {
    v10 = 0;
  }

  else
  {
    v11 = *a1;
    mlir::detail::LoopLikeOpInterfaceTrait<mlir::scf::ForOp>::getYieldedValues(a1, v9);
    OUTLINED_FUNCTION_118_2();
    OUTLINED_FUNCTION_63();
    result = (*v12)(a2, v11);
    v10 = 1;
  }

  *a3 = v10;
  return result;
}

void mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::Type &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.cast";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::scf::ForallOp,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,mlir::OperandRange,std::nullopt_t const&,decltype(nullptr)>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "scf.forall";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::scf::IfOp,llvm::SmallVector<mlir::Type,6u> &,mlir::detail::TypedValue<mlir::IntegerType>,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "scf.if";
  *(a2 + 24) = 6;
}

void mlir::OpBuilder::create<mlir::scf::ParallelOp,llvm::SmallVector<mlir::Value,6u> &,llvm::SmallVector<mlir::Value,6u> &,llvm::SmallVector<mlir::Value,6u> &,mlir::OperandRange,decltype(nullptr)>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "scf.parallel";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::scf::WhileOp,mlir::ValueTypeRange<mlir::ResultRange>,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "scf.while";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::scf::ConditionOp,mlir::detail::TypedValue<mlir::IntegerType>,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "scf.condition";
  *(a2 + 24) = 13;
}

void mlir::wouldOpBeTriviallyDead()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_80_3(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffects::Allocate>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_3_15(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffects::Read>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1_21(v2);
  }
}

void std::__any_of[abi:nn200100]<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect> *,mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect> *,std::__identity,BOOL mlir::hasEffect<mlir::MemoryEffects::Allocate>(mlir::Operation *,mlir::Value)::{lambda(mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>&)#1}>()
{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffects::Allocate>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_3_15(v2);
  }
}

void std::__any_of[abi:nn200100]<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect> *,mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect> *,std::__identity,BOOL mlir::hasEffect<mlir::MemoryEffects::Free>(mlir::Operation *,mlir::Value)::{lambda(mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>&)#1}>()
{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffects::Free>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_2_17(v2);
  }
}

_BYTE *mlir::detail::StorageUniquerImpl::getOrCreate()
{
  OUTLINED_FUNCTION_0_14(v0, COERCE_DOUBLE(1));
  *result = 1;
  return result;
}

_BYTE *mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::get()
{
  v0 = mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::getStaticCache(void)::cache();
  OUTLINED_FUNCTION_0_14(v0, COERCE_DOUBLE(1));
  _tlv_atexit(mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::CacheType::~CacheType, v1);
  *result = 1;
  return result;
}

void mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID()
{
  if (__cxa_guard_acquire(&_MergedGlobals_46))
  {
    llvm::sys::RWMutexImpl::RWMutexImpl(&unk_1EE17C950);
    unk_1EE17C958 = 0u;
    qword_1EE17C968 = 0;
    unk_1EE17C970 = &unk_1EE17C980;
    qword_1EE17C978 = 0x400000000;
    qword_1EE17C9A0 = &qword_1EE17C9B0;
    unk_1EE17C9A8 = 0u;
    unk_1EE17C9B8 = 0u;
    *(&qword_1EE17C9C0 + 4) = 0u;

    __cxa_guard_release(&_MergedGlobals_46);
  }
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getOffsets(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 1u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getSizes(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 2u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStrides(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 3u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getOffsets(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 2u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getSizes(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 3u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStrides(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 4u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets(mlir::memref::ReinterpretCastOp *a1@<X0>, uint64_t a2@<X8>)
{
  v18[6] = *MEMORY[0x1E69E9840];
  Context = mlir::Attribute::getContext((*a1 + 24));
  StaticOffsets = mlir::memref::ReinterpretCastOp::getStaticOffsets(a1);
  v6 = v5;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(a1, 2u);
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    v8 = *(*a1 + 72);
  }

  else
  {
    v8 = 0;
  }

  mlir::ValueRange::ValueRange(v14, v8 + 32 * ODSOperandIndexAndLength, (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength) - ODSOperandIndexAndLength);
  mlir::getMixedValues(StaticOffsets, v6, v14[0], v14[1], &Context, &__src);
  *a2 = a2 + 16;
  *(a2 + 8) = 0x400000000;
  v9 = v16;
  v10 = __src;
  if (v16 && &__src != a2)
  {
    if (__src == v18)
    {
      v12 = v16;
      if (v16 < 5 || (llvm::SmallVectorBase<unsigned int>::grow_pod(a2, a2 + 16, v16, 8), v12 = v16, v10 = __src, v16))
      {
        memcpy(*a2, v10, 8 * v12);
        v10 = __src;
      }

      *(a2 + 8) = v9;
    }

    else
    {
      *a2 = __src;
      v11 = v17;
      *(a2 + 8) = v9;
      *(a2 + 12) = v11;
      __src = v18;
      v17 = 0;
      v10 = v18;
    }

    v16 = 0;
  }

  if (v10 != v18)
  {
    free(v10);
  }
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes(mlir::memref::ReinterpretCastOp *a1@<X0>, uint64_t a2@<X8>)
{
  v18[6] = *MEMORY[0x1E69E9840];
  Context = mlir::Attribute::getContext((*a1 + 24));
  StaticSizes = mlir::memref::ReinterpretCastOp::getStaticSizes(a1);
  v6 = v5;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(a1, 3u);
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    v8 = *(*a1 + 72);
  }

  else
  {
    v8 = 0;
  }

  mlir::ValueRange::ValueRange(v14, v8 + 32 * ODSOperandIndexAndLength, (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength) - ODSOperandIndexAndLength);
  mlir::getMixedValues(StaticSizes, v6, v14[0], v14[1], &Context, &__src);
  *a2 = a2 + 16;
  *(a2 + 8) = 0x400000000;
  v9 = v16;
  v10 = __src;
  if (v16 && &__src != a2)
  {
    if (__src == v18)
    {
      v12 = v16;
      if (v16 < 5 || (llvm::SmallVectorBase<unsigned int>::grow_pod(a2, a2 + 16, v16, 8), v12 = v16, v10 = __src, v16))
      {
        memcpy(*a2, v10, 8 * v12);
        v10 = __src;
      }

      *(a2 + 8) = v9;
    }

    else
    {
      *a2 = __src;
      v11 = v17;
      *(a2 + 8) = v9;
      *(a2 + 12) = v11;
      __src = v18;
      v17 = 0;
      v10 = v18;
    }

    v16 = 0;
  }

  if (v10 != v18)
  {
    free(v10);
  }
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides(mlir::memref::ReinterpretCastOp *a1@<X0>, uint64_t a2@<X8>)
{
  v18[6] = *MEMORY[0x1E69E9840];
  Context = mlir::Attribute::getContext((*a1 + 24));
  StaticStrides = mlir::memref::ReinterpretCastOp::getStaticStrides(a1);
  v6 = v5;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(a1, 4u);
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    v8 = *(*a1 + 72);
  }

  else
  {
    v8 = 0;
  }

  mlir::ValueRange::ValueRange(v14, v8 + 32 * ODSOperandIndexAndLength, (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength) - ODSOperandIndexAndLength);
  mlir::getMixedValues(StaticStrides, v6, v14[0], v14[1], &Context, &__src);
  *a2 = a2 + 16;
  *(a2 + 8) = 0x400000000;
  v9 = v16;
  v10 = __src;
  if (v16 && &__src != a2)
  {
    if (__src == v18)
    {
      v12 = v16;
      if (v16 < 5 || (llvm::SmallVectorBase<unsigned int>::grow_pod(a2, a2 + 16, v16, 8), v12 = v16, v10 = __src, v16))
      {
        memcpy(*a2, v10, 8 * v12);
        v10 = __src;
      }

      *(a2 + 8) = v9;
    }

    else
    {
      *a2 = __src;
      v11 = v17;
      *(a2 + 8) = v9;
      *(a2 + 12) = v11;
      __src = v18;
      v17 = 0;
      v10 = v18;
    }

    v16 = 0;
  }

  if (v10 != v18)
  {
    free(v10);
  }
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getOffsets(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 2u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getSizes(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 3u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStrides(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  ODSOperandIndexAndLength = mlir::memref::ReinterpretCastOp::getODSOperandIndexAndLength(&v5, 4u);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v3 = *(v5 + 72);
  }

  else
  {
    v3 = 0;
  }

  return v3 + 32 * ODSOperandIndexAndLength;
}

void mlir::tensor::TensorDialect::initialize()
{
  {
    v0 = llvm::getTypeName<mlir::SubsetExtractionOpInterface>();
    mlir::detail::TypeIDResolver<mlir::SubsetExtractionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::declarePromisedInterfaces<mlir::transform::FindPayloadReplacementOpInterface,mlir::tensor::CollapseShapeOp,mlir::tensor::ExpandShapeOp,mlir::tensor::ExtractSliceOp,mlir::tensor::InsertSliceOp,mlir::tensor::ReshapeOp>()
{
  {
    PayloadReplacementOp = llvm::getTypeName<mlir::transform::FindPayloadReplacementOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(PayloadReplacementOp, v1);
    OUTLINED_FUNCTION_24_8(v2);
  }
}

{
  {
    PayloadReplacementOp = llvm::getTypeName<mlir::transform::FindPayloadReplacementOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(PayloadReplacementOp, v1);
    OUTLINED_FUNCTION_24_8(v2);
  }
}

void mlir::Dialect::declarePromisedInterfaces<mlir::ReifyRankedShapedTypeOpInterface,mlir::tensor::ExpandShapeOp,mlir::tensor::CollapseShapeOp,mlir::tensor::PadOp>()
{
  {
    v0 = llvm::getTypeName<mlir::ReifyRankedShapedTypeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_15_12(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ReifyRankedShapedTypeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_15_12(v2);
  }
}

void mlir::Dialect::declarePromisedInterfaces<mlir::SubsetOpInterface,mlir::tensor::ExtractSliceOp,mlir::tensor::InsertSliceOp,mlir::tensor::ParallelInsertSliceOp>()
{
  {
    v0 = llvm::getTypeName<mlir::SubsetOpInterface>();
    mlir::detail::TypeIDResolver<mlir::SubsetOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::SubsetOpInterface>();
    mlir::detail::TypeIDResolver<mlir::SubsetOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::declarePromisedInterfaces<mlir::SubsetInsertionOpInterface,mlir::tensor::InsertSliceOp,mlir::tensor::ParallelInsertSliceOp>()
{
  {
    v0 = llvm::getTypeName<mlir::SubsetInsertionOpInterface>();
    mlir::detail::TypeIDResolver<mlir::SubsetInsertionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::SubsetInsertionOpInterface>();
    mlir::detail::TypeIDResolver<mlir::SubsetInsertionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::declarePromisedInterfaces<mlir::TilingInterface,mlir::tensor::PadOp,mlir::tensor::PackOp,mlir::tensor::UnPackOp>()
{
  {
    v0 = llvm::getTypeName<mlir::TilingInterface>();
    mlir::detail::TypeIDResolver<mlir::TilingInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::TilingInterface>();
    mlir::detail::TypeIDResolver<mlir::TilingInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::declarePromisedInterfaces<mlir::ValueBoundsOpInterface,mlir::tensor::CastOp,mlir::tensor::DimOp,mlir::tensor::EmptyOp,mlir::tensor::ExtractSliceOp,mlir::tensor::PadOp,mlir::tensor::RankOp>()
{
  {
    v0 = llvm::getTypeName<mlir::ValueBoundsOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_19_9(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ValueBoundsOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_19_9(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_22_8(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::tensor::CastOp>,mlir::OpTrait::OneResult<mlir::tensor::CastOp>,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::tensor::CastOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::CastOp>,mlir::OpTrait::OneOperand<mlir::tensor::CastOp>,mlir::OpTrait::OpInvariants<mlir::tensor::CastOp>,mlir::CastOpInterface::Trait<mlir::tensor::CastOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::CastOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::CastOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::tensor::CastOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::CastOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::OpAsmOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_9_12(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_8_12(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::tensor::CollapseShapeOp>,mlir::OpTrait::OneResult<mlir::tensor::CollapseShapeOp>,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::tensor::CollapseShapeOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::CollapseShapeOp>,mlir::OpTrait::OneOperand<mlir::tensor::CollapseShapeOp>,mlir::OpTrait::OpInvariants<mlir::tensor::CollapseShapeOp>,mlir::BytecodeOpInterface::Trait<mlir::tensor::CollapseShapeOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::CollapseShapeOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::CollapseShapeOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::tensor::CollapseShapeOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::CollapseShapeOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_14_13(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_13_15(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_12_12(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ReifyRankedShapedTypeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_16_12(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::tensor::DimOp>,mlir::OpTrait::OneResult<mlir::tensor::DimOp>,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<mlir::tensor::DimOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::DimOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::tensor::DimOp>,mlir::OpTrait::OpInvariants<mlir::tensor::DimOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::DimOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::DimOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::DimOp>,mlir::ShapedDimOpInterface::Trait<mlir::tensor::DimOp>,mlir::InferTypeOpInterface::Trait<mlir::tensor::DimOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_17_14(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_18_8(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_26_9(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::OffsetSizeAndStrideOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_20_9(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_25_9(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::tensor::InsertOp>,mlir::OpTrait::OneResult<mlir::tensor::InsertOp>,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::tensor::InsertOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::InsertOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::tensor::InsertOp>,mlir::OpTrait::OpInvariants<mlir::tensor::InsertOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::InsertOp>,mlir::DestinationStyleOpInterface::Trait<mlir::tensor::InsertOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::InsertOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::tensor::InsertOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::InsertOp>,mlir::InferTypeOpInterface::Trait<mlir::tensor::InsertOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::DestinationStyleOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_29_8(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_23_9(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::DestinationStyleOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DestinationStyleOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_28_8(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::tensor::foldTensorCast(mlir::tensor *this, mlir::Operation *a2)
{
  if ((*(this + 46) & 0x80) != 0 && (v2 = *(this + 17), v2))
  {
    v3 = 0;
    v4 = *(this + 9);
    v5 = 32 * v2;
    do
    {
      OUTLINED_FUNCTION_86_0();
      DefiningOp = mlir::Value::getDefiningOp(v6);
      if (DefiningOp)
      {
        v8 = DefiningOp;
        if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
        {
          if (mlir::tensor::preservesStaticInformation(*(DefiningOp - 8) & 0xFFFFFFFFFFFFFFF8, *(*(*(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
          {
            v9 = *(*(v8 + 72) + 24);
            v10 = v4[1];
            if (v10)
            {
              v11 = *v4;
              *v10 = *v4;
              if (v11)
              {
                *(v11 + 8) = v10;
              }
            }

            v4[3] = v9;
            v12 = *v9;
            *v4 = *v9;
            v4[1] = v9;
            if (v12)
            {
              *(v12 + 8) = v4;
            }

            *v9 = v4;
            v3 = 1;
          }
        }
      }

      v4 += 4;
      v5 -= 32;
    }

    while (v5);
  }

  else
  {
    v3 = 0;
  }

  return v3 & 1;
}

uint64_t mlir::tensor::ConcatOp::reifyResultShapes()
{
  OUTLINED_FUNCTION_147_0();
  v67[1] = *MEMORY[0x1E69E9840];
  v4 = *v3;
  if ((*(*v3 + 46) & 0x80) != 0)
  {
    v5 = *(v4 + 68);
    v6 = *(v4 + 72);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(v65.n128_u64, v6, v5);
  OUTLINED_FUNCTION_13_12();
  v66.n128_u64[0] = *(v7 + 64);
  mlir::IntegerAttr::getValue(&v66, &__p);
  if (__p.n128_u32[2] > 0x40)
  {
    v8 = *__p.n128_u64[0];
    operator delete[](__p.n128_u64[0]);
  }

  else
  {
    v8 = __p.n128_u64[0];
  }

  v59 = v8;
  mlir::ValueRange::getTypes(&v65, &__p);
  v10 = __p.n128_u64[1];
  v9 = __p.n128_u64[0];
  v11 = v64[1];
  v66 = __p;
  if (__p.n128_u64[1])
  {
    v9 = mlir::ValueRange::offset_base(&v66, __p.n128_i64[1]);
    v10 = v66.n128_u64[1];
  }

  mlir::TypeRange::TypeRange(v66.n128_u64, v9, v11 - v10);
  v58 = mlir::tensor::ConcatOp::inferResultType(v8, v66.n128_i64[0], v66.n128_u64[1]);
  v57 = mlir::ValueRange::dereference_iterator(&v65, 0);
  OUTLINED_FUNCTION_89_4();
  __p.n128_u64[0] = v12;
  mlir::ArrayAttr::getValue(&__p);
  v14 = v13;
  __p.n128_u64[0] = v64;
  __p.n128_u64[1] = 0x600000000;
  if (v13)
  {
    if (v13 < 7)
    {
      v15 = 0;
    }

    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(&__p, v64, v13, 8);
      v15 = __p.n128_u32[2];
    }

    if (v14 != v15)
    {
      bzero((__p.n128_u64[0] + 8 * v15), 8 * (v14 - v15));
    }

    __p.n128_u32[2] = v14;
  }

  v16 = *(v0 + 8);
  if (v16)
  {
    if (v16 != 1)
    {
      v17 = (*v0 + (v16 << 6) - 64);
      v18 = 64 - (v16 << 6);
      do
      {
        if (v17 + 2 != *v17)
        {
          free(*v17);
        }

        v17 -= 8;
        v18 += 64;
      }

      while (v18);
      *(v0 + 8) = 1;
    }
  }

  else
  {
    llvm::SmallVectorImpl<llvm::SmallVector<mlir::OpFoldResult,6u>>::append(v0, 1 - v16, &__p);
  }

  if (__p.n128_u64[0] != v64)
  {
    free(__p.n128_u64[0]);
  }

  __p.n128_u64[0] = 0;
  if (v14 >= 1)
  {
    for (i = 0; i < v14; __p.n128_u64[0] = i)
    {
      if (i != v8)
      {
        OUTLINED_FUNCTION_89_4();
        v66.n128_u64[0] = v20;
        if (*(mlir::ArrayAttr::getValue(&v66) + 8 * i) == 0x8000000000000000)
        {
          v21 = __p.n128_u32[0];
          if (*(mlir::ArrayAttr::getValue(&v58) + 8 * v21) == 0x8000000000000000)
          {
            Loc = mlir::Value::getLoc(&v57);
            v23 = mlir::OpBuilder::create<mlir::tensor::DimOp,mlir::Value &,long long &>(v1, Loc, &v57, &__p);
            ConstantIndexOp = OUTLINED_FUNCTION_14_10(v23);
          }

          else
          {
            v29 = *(*v2 + 24);
            v30 = __p.n128_u32[0];
            Value = mlir::ArrayAttr::getValue(&v58);
            IndexAttr = mlir::Builder::getIndexAttr(v1, *(Value + 8 * v30));
            ConstantIndexOp = mlir::getValueOrCreateConstantIndexOp(v1, v29, IndexAttr & 0xFFFFFFFFFFFFFFFBLL);
          }

          v28 = ConstantIndexOp | 4;
        }

        else
        {
          OUTLINED_FUNCTION_89_4();
          v66.n128_u64[0] = v25;
          v26 = __p.n128_u32[0];
          v27 = mlir::ArrayAttr::getValue(&v66);
          v28 = mlir::Builder::getIndexAttr(v1, *(v27 + 8 * v26)) & 0xFFFFFFFFFFFFFFFBLL;
        }

        *(**v0 + 8 * __p.n128_u64[0]) = v28;
      }

      i = __p.n128_u64[0] + 1;
    }
  }

  OUTLINED_FUNCTION_89_4();
  __p.n128_u64[0] = v33;
  if (*(mlir::ArrayAttr::getValue(&__p) + 8 * v8) == 0x8000000000000000)
  {
    AffineDimExpr = mlir::Builder::getAffineDimExpr(v1, 0, v34);
    v56 = AffineDimExpr;
    v36 = mlir::Value::getLoc(&v57);
    __p.n128_u64[0] = v64;
    __p.n128_u64[1] = 0x100000000;
    mlir::OpBuilder::createOrFold<mlir::tensor::DimOp,mlir::Value &,long long &>(v1, &__p, v36, &v57, &v59);
    v37 = *__p.n128_u64[0];
    if (__p.n128_u64[0] != v64)
    {
      free(__p.n128_u64[0]);
    }

    __p.n128_u64[0] = v64;
    v64[0] = v37 | 4;
    __p.n128_u64[1] = 0x600000001;
    v38 = v65.n128_u64[1];
    v39 = mlir::ValueRange::offset_base(&v65, 1);
    v60 = 0;
    v61 = v39;
    v62 = 0;
    v40 = v38 - 1;
    if (v40)
    {
      v41 = 0;
      for (j = 0; j != v40; v62 = j)
      {
        v55 = mlir::ValueRange::dereference_iterator(&v61, j);
        v44 = mlir::Builder::getAffineDimExpr(v1, (v41 + 1), v43);
        v56 = mlir::AffineExpr::operator+(&v56, v44);
        v45 = mlir::Value::getLoc(&v55);
        v66.n128_u64[0] = v67;
        v66.n128_u64[1] = 0x100000000;
        mlir::OpBuilder::createOrFold<mlir::tensor::DimOp,mlir::Value &,long long &>(v1, &v66, v45, &v55, &v59);
        v46 = *v66.n128_u64[0];
        if (v66.n128_u64[0] != v67)
        {
          free(v66.n128_u64[0]);
        }

        v47 = __p.n128_u32[2];
        if (__p.n128_u32[2] >= __p.n128_u32[3])
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&__p, v64, __p.n128_u32[2] + 1, 8);
          v47 = __p.n128_u32[2];
        }

        *(__p.n128_u64[0] + 8 * v47) = v46 | 4;
        v48 = ++__p.n128_u32[2];
        v41 = v60 + 1;
        j = v62 + 1;
        ++v60;
      }

      AffineDimExpr = v56;
    }

    else
    {
      v48 = __p.n128_u32[2];
    }

    v51 = *(*v2 + 24);
    ComposedFoldedAffineApply = mlir::affine::makeComposedFoldedAffineApply(v1, v51, AffineDimExpr, __p.n128_u64[0], v48);
    v53 = mlir::getValueOrCreateConstantIndexOp(v1, v51, ComposedFoldedAffineApply);
    *(**v0 + 8 * v59) = v53 | 4;
    if (__p.n128_u64[0] != v64)
    {
      free(__p.n128_u64[0]);
    }
  }

  else
  {
    OUTLINED_FUNCTION_89_4();
    __p.n128_u64[0] = v49;
    v50 = mlir::ArrayAttr::getValue(&__p);
    *(**v0 + 8 * v8) = mlir::Builder::getIndexAttr(v1, *(v50 + 8 * v8)) & 0xFFFFFFFFFFFFFFFBLL;
  }

  return 1;
}

uint64_t mlir::tensor::ConcatOp::fold(uint64_t *a1)
{
  v7[2] = *MEMORY[0x1E69E9840];
  v2 = *a1;
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    v3 = *(v2 + 68);
    v4 = *(v2 + 72);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(v7, v4, v3);
  if (v7[1] == 1 && (v5 = *(mlir::ValueRange::dereference_iterator(v7, 0) + 8), (*(OUTLINED_FUNCTION_28_4(*a1) + 8) ^ v5) <= 7))
  {
    return mlir::ValueRange::dereference_iterator(v7, 0) | 4;
  }

  else
  {
    return 0;
  }
}

BOOL mlir::tensor::EmptyOp::verify(mlir::tensor::EmptyOp *this)
{
  OUTLINED_FUNCTION_157_2(*MEMORY[0x1E69E9840]);
  OUTLINED_FUNCTION_28_4(v2);
  OUTLINED_FUNCTION_110_1();
  v87 = v3;
  mlir::ArrayAttr::getValue(&v87);
  if (v4)
  {
    OUTLINED_FUNCTION_90_5();
    if (v5)
    {
      *v7.i64 = OUTLINED_FUNCTION_24_9();
      do
      {
        *v7.i64 = OUTLINED_FUNCTION_31_8(v7, v8);
      }

      while (!v10);
      OUTLINED_FUNCTION_71_2(v7, *v8.i64, v9);
      if (v10)
      {
        goto LABEL_11;
      }
    }

    else
    {
      OUTLINED_FUNCTION_187_0();
    }

    OUTLINED_FUNCTION_185_0();
    do
    {
      OUTLINED_FUNCTION_102_3();
    }

    while (v11 != v12);
  }

  else
  {
    v6 = 0;
  }

LABEL_11:
  if ((*(*this + 46) & 0x80) != 0)
  {
    v13 = *(*this + 68);
  }

  else
  {
    v13 = 0;
  }

  if (v6 == v13)
  {
    return 1;
  }

  OUTLINED_FUNCTION_149_2("incorrect number of dynamic sizes, has ", v76);
  OUTLINED_FUNCTION_189_0();
  if (v16 < 0)
  {
    v17 = *(v15 + 68);
  }

  else
  {
    v17 = 0;
  }

  if (v87)
  {
    LODWORD(v84) = 5;
    v85 = v17;
    OUTLINED_FUNCTION_4_5();
    if (v5)
    {
      OUTLINED_FUNCTION_5_3();
      if (v58 <= v59 && (v57 & 1) != 0)
      {
        OUTLINED_FUNCTION_82_5(v49, v50, v51, v52, v53, v54, v55, v56, v77, v79, v80, v81, v82, v83);
        v18 = v90;
      }

      else
      {
        OUTLINED_FUNCTION_82_5(v49, v50, v51, v52, v53, v54, v55, v56, v77, v79, v80, v81, v82, v83);
        OUTLINED_FUNCTION_19_3();
      }
    }

    OUTLINED_FUNCTION_59_2(v18, v77, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91);
    LODWORD(v91) = v19 + 1;
    if (v87)
    {
      LODWORD(v84) = 3;
      OUTLINED_FUNCTION_133_2();
      if (v5)
      {
        OUTLINED_FUNCTION_13_4();
        if (v72 <= v74 && (v73 & 1) != 0)
        {
          v75 = &v84 - v72;
          OUTLINED_FUNCTION_164(v71, v77, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91);
          v20 = v90;
          v21 = &v75[v90];
        }

        else
        {
          OUTLINED_FUNCTION_164(v71, v77, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91);
          v21 = &v84;
          v20 = v90;
        }
      }

      OUTLINED_FUNCTION_2_7((v20 + 24 * v91), *v21);
    }
  }

  OUTLINED_FUNCTION_28_4(*this);
  OUTLINED_FUNCTION_110_1();
  OUTLINED_FUNCTION_198(v22, v77);
  if (v23)
  {
    OUTLINED_FUNCTION_90_5();
    if (v5)
    {
      *v25.i64 = OUTLINED_FUNCTION_24_9();
      do
      {
        *v25.i64 = OUTLINED_FUNCTION_31_8(v25, v26);
      }

      while (!v10);
      OUTLINED_FUNCTION_71_2(v25, *v26.i64, v27);
      if (v10)
      {
        goto LABEL_32;
      }
    }

    else
    {
      OUTLINED_FUNCTION_187_0();
    }

    OUTLINED_FUNCTION_185_0();
    do
    {
      OUTLINED_FUNCTION_102_3();
    }

    while (v28 != v29);
  }

  else
  {
    v24 = 0;
  }

LABEL_32:
  if (v87)
  {
    LODWORD(v84) = 5;
    v85 = v24;
    OUTLINED_FUNCTION_4_5();
    if (v5)
    {
      OUTLINED_FUNCTION_34_3();
      if (v69 <= v70 && (v68 & 1) != 0)
      {
        OUTLINED_FUNCTION_81_5(v60, v61, v62, v63, v64, v65, v66, v67, v78, v79, v80, v81, v82, v83);
        v30 = v90;
      }

      else
      {
        OUTLINED_FUNCTION_81_5(v60, v61, v62, v63, v64, v65, v66, v67, v78, v79, v80, v81, v82, v83);
        OUTLINED_FUNCTION_19_3();
      }
    }

    OUTLINED_FUNCTION_59_2(v30, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91);
    LODWORD(v91) = v31 + 1;
  }

  v14 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v87);
  if (v87)
  {
    mlir::InFlightDiagnostic::report(&v87);
  }

  if (v97 == 1)
  {
    v39 = v96;
    if (v96 != &v97)
    {
      free(v96);
    }

    v40 = __p;
    if (__p)
    {
      v41 = v95;
      v42 = __p;
      if (v95 != __p)
      {
        do
        {
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v41 - 1);
        }

        while (v41 != v40);
        v42 = __p;
      }

      v95 = v40;
      operator delete(v42);
    }

    v43 = v92;
    if (v92)
    {
      v44 = v93;
      v45 = v92;
      if (v93 != v92)
      {
        do
        {
          v46 = OUTLINED_FUNCTION_17_5();
          if (v46)
          {
            operator delete[](v46);
          }
        }

        while (v44 != v43);
        v45 = v92;
      }

      v93 = v43;
      operator delete(v45);
    }

    v47 = OUTLINED_FUNCTION_12_5(v39, v32, v33, v34, v35, v36, v37, v38, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89, v90);
    if (!v10)
    {
      free(v47);
    }
  }

  return v14;
}

BOOL mlir::tensor::ExtractOp::verify(mlir::tensor::ExtractOp *this)
{
  OUTLINED_FUNCTION_157_2(*MEMORY[0x1E69E9840]);
  OUTLINED_FUNCTION_27_5();
  v48 = v2 & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue(&v48);
  OUTLINED_FUNCTION_189_0();
  if (v5 < 0)
  {
    v6 = *(v4 + 68) - 1;
  }

  else
  {
    v6 = -1;
  }

  if (v3 == v6)
  {
    return 1;
  }

  v8 = OUTLINED_FUNCTION_56_4();
  mlir::OpState::emitOpError(v8, v9, v10);
  v11 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v49);
  v7 = v11;
  if (v49)
  {
    mlir::InFlightDiagnostic::report(&v49);
  }

  if (v73 == 1)
  {
    v19 = OUTLINED_FUNCTION_145_2(v11, v12, v13, v14, v15, v16, v17, v18, v36, v38, v40, v42, v44, v46, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, __p, v67, v68, v69, v70, v71, v72);
    if (!v27)
    {
      free(v19);
    }

    v28 = v69;
    if (v69)
    {
      v29 = OUTLINED_FUNCTION_143_0(v19, v20, v21, v22, v23, v24, v25, v26, v37, v39, v41, v43, v45, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, __p, v67, v68, v69, v70);
      if (!v27)
      {
        do
        {
          v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v29 - 8));
        }

        while (v29 != v28);
        v30 = v69;
      }

      v70 = v28;
      operator delete(v30);
    }

    v31 = __p;
    if (__p)
    {
      v32 = OUTLINED_FUNCTION_142_1();
      if (!v27)
      {
        do
        {
          v33 = OUTLINED_FUNCTION_17_5();
          if (v33)
          {
            operator delete[](v33);
          }
        }

        while (v1 != v31);
        v32 = __p;
      }

      v67 = v31;
      operator delete(v32);
    }

    v34 = OUTLINED_FUNCTION_103_2(v19, v20, v21, v22, v23, v24, v25, v26, v37, v39, v41, v43, v45, v47, v48, v49, v50, v51, v52);
    if (!v27)
    {
      free(v34);
    }
  }

  return v7;
}

BOOL mlir::tensor::InsertOp::verify(mlir::tensor::InsertOp *this)
{
  OUTLINED_FUNCTION_157_2(*MEMORY[0x1E69E9840]);
  OUTLINED_FUNCTION_144_2();
  v48 = v2 & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue(&v48);
  OUTLINED_FUNCTION_189_0();
  if (v5 < 0)
  {
    v6 = *(v4 + 68) - 2;
  }

  else
  {
    v6 = -2;
  }

  if (v3 == v6)
  {
    return 1;
  }

  v8 = OUTLINED_FUNCTION_56_4();
  mlir::OpState::emitOpError(v8, v9, v10);
  v11 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v49);
  v7 = v11;
  if (v49)
  {
    mlir::InFlightDiagnostic::report(&v49);
  }

  if (v73 == 1)
  {
    v19 = OUTLINED_FUNCTION_145_2(v11, v12, v13, v14, v15, v16, v17, v18, v36, v38, v40, v42, v44, v46, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, __p, v67, v68, v69, v70, v71, v72);
    if (!v27)
    {
      free(v19);
    }

    v28 = v69;
    if (v69)
    {
      v29 = OUTLINED_FUNCTION_143_0(v19, v20, v21, v22, v23, v24, v25, v26, v37, v39, v41, v43, v45, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, __p, v67, v68, v69, v70);
      if (!v27)
      {
        do
        {
          v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v29 - 8));
        }

        while (v29 != v28);
        v30 = v69;
      }

      v70 = v28;
      operator delete(v30);
    }

    v31 = __p;
    if (__p)
    {
      v32 = OUTLINED_FUNCTION_142_1();
      if (!v27)
      {
        do
        {
          v33 = OUTLINED_FUNCTION_17_5();
          if (v33)
          {
            operator delete[](v33);
          }
        }

        while (v1 != v31);
        v32 = __p;
      }

      v67 = v31;
      operator delete(v32);
    }

    v34 = OUTLINED_FUNCTION_103_2(v19, v20, v21, v22, v23, v24, v25, v26, v37, v39, v41, v43, v45, v47, v48, v49, v50, v51, v52);
    if (!v27)
    {
      free(v34);
    }
  }

  return v7;
}

BOOL mlir::tensor::GenerateOp::verify(mlir::tensor::GenerateOp *this)
{
  OUTLINED_FUNCTION_157_2(*MEMORY[0x1E69E9840]);
  v60 = *(v2 - 8) & 0xFFFFFFFFFFFFFFF8;
  if ((*(v2 + 46) & 0x80) != 0)
  {
    v3 = *(v2 + 68);
  }

  else
  {
    v3 = 0;
  }

  mlir::ArrayAttr::getValue(&v60);
  if (!v4)
  {
    v8 = 0;
    goto LABEL_13;
  }

  OUTLINED_FUNCTION_90_5();
  if (v7)
  {
    v10 = v5 + 1;
    v11 = 0uLL;
    v12 = vnegq_f64(0);
    v13.i64[0] = 0;
    do
    {
      *v11.i64 = OUTLINED_FUNCTION_40_4(v11, v12, *v13.i64, v10[-1]);
      v10 = v16 + 2;
    }

    while (v17 != 4);
    v8 = vaddvq_s64(vaddq_s64(v13, v11));
    if (v14 == v15)
    {
      goto LABEL_13;
    }
  }

  else
  {
    v8 = 0;
    v9 = v5;
  }

  do
  {
    v18 = *v9++;
    if (v18 == 0x8000000000000000)
    {
      ++v8;
    }
  }

  while (v9 != (v5 + 8 * v6));
LABEL_13:
  if (v8 == v3)
  {
    return 1;
  }

  v20 = OUTLINED_FUNCTION_56_4();
  mlir::OpState::emitError(v20, v21, v22);
  v23 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v61);
  v19 = v23;
  if (v61)
  {
    mlir::InFlightDiagnostic::report(&v61);
  }

  if (v85 == 1)
  {
    v31 = OUTLINED_FUNCTION_145_2(v23, v24, v25, v26, v27, v28, v29, v30, v48, v50, v52, v54, v56, v58, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, __p, v79, v80, v81, v82, v83, v84);
    if (!v39)
    {
      free(v31);
    }

    v40 = v81;
    if (v81)
    {
      v41 = OUTLINED_FUNCTION_143_0(v31, v32, v33, v34, v35, v36, v37, v38, v49, v51, v53, v55, v57, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, __p, v79, v80, v81, v82);
      if (!v39)
      {
        do
        {
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v41 - 8));
        }

        while (v41 != v40);
        v42 = v81;
      }

      v82 = v40;
      operator delete(v42);
    }

    v43 = __p;
    if (__p)
    {
      v44 = OUTLINED_FUNCTION_142_1();
      if (!v39)
      {
        do
        {
          v45 = OUTLINED_FUNCTION_17_5();
          if (v45)
          {
            operator delete[](v45);
          }
        }

        while (v1 != v43);
        v44 = __p;
      }

      v79 = v43;
      operator delete(v44);
    }

    v46 = OUTLINED_FUNCTION_103_2(v31, v32, v33, v34, v35, v36, v37, v38, v49, v51, v53, v55, v57, v59, v60, v61, v62, v63, v64);
    if (!v39)
    {
      free(v46);
    }
  }

  return v19;
}

uint64_t mlir::tensor::ExtractSliceOp::reifyResultShapes(uint64_t *a1, uint64_t a2, unsigned int *a3)
{
  v51[4] = *MEMORY[0x1E69E9840];
  v5 = a3[2];
  if (!v5)
  {
    if (a3[3])
    {
      v8 = 0;
    }

    else
    {
      llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::OpFoldResult,6u>,false>::grow(a3, 1uLL);
      v8 = a3[2];
      if (v8 == 1)
      {
        goto LABEL_18;
      }
    }

    v9 = *a3;
    v10 = *a3 + (v8 << 6);
    v11 = -v8;
    v12 = v10;
    v13 = v11 & 0x3FFFFFFFFFFFFFFLL;
    if (!v13)
    {
      goto LABEL_16;
    }

    v14 = v13 + 1;
    v12 = v10 + ((v14 & 0x7FFFFFFFFFFFFFELL) << 6);
    v15 = v10 + 80;
    v16 = v14 & 0x7FFFFFFFFFFFFFELL;
    do
    {
      *(v15 - 80) = v15 - 64;
      *(v15 - 16) = v15;
      *(v15 - 72) = 0x600000000;
      *(v15 - 8) = 0x600000000;
      v15 += 128;
      v16 -= 2;
    }

    while (v16);
    if (v14 != (v14 & 0x7FFFFFFFFFFFFFELL))
    {
LABEL_16:
      v17 = v12 + 16;
      do
      {
        v18 = v17 - 16;
        *(v17 - 16) = v17;
        *(v17 - 8) = 0x600000000;
        v17 += 64;
      }

      while (v18 != v9);
    }

    goto LABEL_18;
  }

  if (v5 == 1)
  {
    goto LABEL_19;
  }

  v6 = (*a3 + (v5 << 6) - 64);
  v7 = 64 - (v5 << 6);
  do
  {
    if (v6 + 2 != *v6)
    {
      free(*v6);
    }

    v6 -= 8;
    v7 += 64;
  }

  while (v7);
LABEL_18:
  a3[2] = 1;
LABEL_19:
  v19 = *a3;
  OUTLINED_FUNCTION_28_4(*a1);
  OUTLINED_FUNCTION_110_1();
  __dst = v20;
  mlir::ArrayAttr::getValue(&__dst);
  if (v21 > *(v19 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v19, v19 + 16, v21, 8);
  }

  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes(a1, &__src);
  __dst = v47;
  v46 = 0x600000000;
  v22 = v49;
  if (v49)
  {
    OUTLINED_FUNCTION_139_2();
    if (v25)
    {
      v26 = v22;
      if (v22 < 7 || (llvm::SmallVectorBase<unsigned int>::grow_pod(&__dst, v47, v22, 8), v26 = v49, v23 = __src, v49))
      {
        memcpy(__dst, v23, 8 * v26);
      }

      LODWORD(v46) = v22;
    }

    else
    {
      __dst = v23;
      v46 = __PAIR64__(v50, v22);
      __src = v24;
      v50 = 0;
    }

    v49 = 0;
  }

  OUTLINED_FUNCTION_139_2();
  if (!v25)
  {
    free(v27);
  }

  OUTLINED_FUNCTION_28_4(*a1);
  OUTLINED_FUNCTION_110_1();
  v44 = v28;
  mlir::ArrayAttr::getValue(&v44);
  OUTLINED_FUNCTION_153_2();
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes(a1, &__src);
  getDroppedDims(&__p, v22, &__src, __src, v49);
  if (__src != v51)
  {
    free(__src);
  }

  v29 = __p;
  if (!v46)
  {
    if (__p)
    {
      goto LABEL_47;
    }

    goto LABEL_43;
  }

  v30 = __dst;
  if ((__p & 1) == 0)
  {
    v31 = 0;
    v32 = 8 * v46;
    do
    {
      if (((*(*v29 + (v31 >> 6)) >> v31) & 1) == 0)
      {
        v33 = *a3;
        v34 = v30[v31];
        v35 = *(*a3 + 8);
        if (v35 >= *(*a3 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(*a3, v33 + 16, v35 + 1, 8);
          v35 = *(v33 + 8);
        }

        *(*v33 + 8 * v35) = v34;
        ++*(v33 + 8);
      }

      ++v31;
      v32 -= 8;
    }

    while (v32);
LABEL_43:
    if (v29)
    {
      if (*v29 != v29 + 2)
      {
        free(*v29);
      }

      operator delete(v29);
    }

    goto LABEL_47;
  }

  v37 = 0;
  v38 = 8 * v46;
  v39 = (__p >> 1) & ~(-1 << (__p >> 58));
  do
  {
    if ((v39 & (1 << v37)) == 0)
    {
      v40 = *a3;
      v41 = v30[v37];
      v42 = *(*a3 + 8);
      if (v42 >= *(*a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(*a3, v40 + 16, v42 + 1, 8);
        v42 = *(v40 + 8);
      }

      *(*v40 + 8 * v42) = v41;
      ++*(v40 + 8);
    }

    ++v37;
    v38 -= 8;
  }

  while (v38);
LABEL_47:
  if (__dst != v47)
  {
    free(__dst);
  }

  return 1;
}

uint64_t *mlir::tensor::PadOp::getMixedLowPad@<X0>(mlir::tensor::PadOp *this@<X0>, uint64_t a2@<X8>)
{
  v13[2] = *MEMORY[0x1E69E9840];
  v13[0] = *(*this + 16 * ((*(*this + 44) >> 23) & 1) + 80);
  v4 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(v13);
  v6 = v5;
  v7 = *(*this + 44);
  v8 = *this + 16 * ((v7 >> 23) & 1);
  v9 = *(v8 + 88);
  v10 = *(v8 + 92);
  if ((v7 & 0x800000) != 0)
  {
    v11 = *(*this + 72);
  }

  else
  {
    v11 = 0;
  }

  mlir::ValueRange::ValueRange(v13, v11 + 32 * v9, (v10 + v9) - v9);
  return mlir::tensor::PadOp::getMixedPadImpl(this, v4, v6, v13[0], v13[1], a2);
}

uint64_t *mlir::tensor::PadOp::getMixedHighPad@<X0>(mlir::tensor::PadOp *this@<X0>, uint64_t a2@<X8>)
{
  v14[2] = *MEMORY[0x1E69E9840];
  v14[0] = *(*this + 16 * ((*(*this + 44) >> 23) & 1) + 72);
  v4 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(v14);
  v6 = v5;
  v7 = *(*this + 44);
  v8 = (*this + 16 * ((v7 >> 23) & 1));
  v9 = v8[22];
  v10 = v8[23];
  v11 = v8[24];
  if ((v7 & 0x800000) != 0)
  {
    v12 = *(*this + 72);
  }

  else
  {
    v12 = 0;
  }

  mlir::ValueRange::ValueRange(v14, v12 + 32 * (v10 + v9), (v11 + v10 + v9) - (v10 + v9));
  return mlir::tensor::PadOp::getMixedPadImpl(this, v4, v6, v14[0], v14[1], a2);
}

BOOL mlir::tensor::SplatOp::verify(mlir::tensor::SplatOp *this)
{
  OUTLINED_FUNCTION_157_2(*MEMORY[0x1E69E9840]);
  v85 = *(v2 - 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue(&v85);
  if (v3)
  {
    OUTLINED_FUNCTION_90_5();
    if (v4)
    {
      *v6.i64 = OUTLINED_FUNCTION_24_9();
      do
      {
        *v6.i64 = OUTLINED_FUNCTION_31_8(v6, v7);
      }

      while (!v9);
      OUTLINED_FUNCTION_71_2(v6, *v7.i64, v8);
      if (v9)
      {
        goto LABEL_11;
      }
    }

    else
    {
      OUTLINED_FUNCTION_187_0();
    }

    OUTLINED_FUNCTION_185_0();
    do
    {
      OUTLINED_FUNCTION_102_3();
    }

    while (v10 != v11);
  }

  else
  {
    v5 = 0;
  }

LABEL_11:
  if ((*(*this + 46) & 0x80) != 0)
  {
    v12 = *(*this + 68) - 1;
  }

  else
  {
    v12 = -1;
  }

  if (v5 == v12)
  {
    return 1;
  }

  OUTLINED_FUNCTION_149_2("incorrect number of dynamic sizes, has ", v74);
  OUTLINED_FUNCTION_189_0();
  if (v15 < 0)
  {
    v16 = *(v14 + 68) - 1;
  }

  else
  {
    v16 = -1;
  }

  if (v85)
  {
    LODWORD(v82) = 5;
    v83 = v16;
    OUTLINED_FUNCTION_4_5();
    if (v4)
    {
      OUTLINED_FUNCTION_5_3();
      if (v56 <= v57 && (v55 & 1) != 0)
      {
        OUTLINED_FUNCTION_82_5(v47, v48, v49, v50, v51, v52, v53, v54, v75, v77, v78, v79, v80, v81);
        v17 = v88;
      }

      else
      {
        OUTLINED_FUNCTION_82_5(v47, v48, v49, v50, v51, v52, v53, v54, v75, v77, v78, v79, v80, v81);
        OUTLINED_FUNCTION_19_3();
      }
    }

    OUTLINED_FUNCTION_59_2(v17, v75, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89);
    LODWORD(v89) = v18 + 1;
    if (v85)
    {
      LODWORD(v82) = 3;
      OUTLINED_FUNCTION_133_2();
      if (v4)
      {
        OUTLINED_FUNCTION_13_4();
        if (v70 <= v72 && (v71 & 1) != 0)
        {
          v73 = &v82 - v70;
          OUTLINED_FUNCTION_164(v69, v75, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89);
          v19 = v88;
          v20 = &v73[v88];
        }

        else
        {
          OUTLINED_FUNCTION_164(v69, v75, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89);
          v20 = &v82;
          v19 = v88;
        }
      }

      OUTLINED_FUNCTION_2_7((v19 + 24 * v89), *v20);
    }
  }

  OUTLINED_FUNCTION_198(*(*this - 8) & 0xFFFFFFFFFFFFFFF8, v75);
  if (v21)
  {
    OUTLINED_FUNCTION_90_5();
    if (v4)
    {
      *v23.i64 = OUTLINED_FUNCTION_24_9();
      do
      {
        *v23.i64 = OUTLINED_FUNCTION_31_8(v23, v24);
      }

      while (!v9);
      OUTLINED_FUNCTION_71_2(v23, *v24.i64, v25);
      if (v9)
      {
        goto LABEL_32;
      }
    }

    else
    {
      OUTLINED_FUNCTION_187_0();
    }

    OUTLINED_FUNCTION_185_0();
    do
    {
      OUTLINED_FUNCTION_102_3();
    }

    while (v26 != v27);
  }

  else
  {
    v22 = 0;
  }

LABEL_32:
  if (v85)
  {
    LODWORD(v82) = 5;
    v83 = v22;
    OUTLINED_FUNCTION_4_5();
    if (v4)
    {
      OUTLINED_FUNCTION_34_3();
      if (v67 <= v68 && (v66 & 1) != 0)
      {
        OUTLINED_FUNCTION_81_5(v58, v59, v60, v61, v62, v63, v64, v65, v76, v77, v78, v79, v80, v81);
        v28 = v88;
      }

      else
      {
        OUTLINED_FUNCTION_81_5(v58, v59, v60, v61, v62, v63, v64, v65, v76, v77, v78, v79, v80, v81);
        OUTLINED_FUNCTION_19_3();
      }
    }

    OUTLINED_FUNCTION_59_2(v28, v76, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89);
    LODWORD(v89) = v29 + 1;
  }

  v13 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v85);
  if (v85)
  {
    mlir::InFlightDiagnostic::report(&v85);
  }

  if (v95 == 1)
  {
    v37 = v94;
    if (v94 != &v95)
    {
      free(v94);
    }

    v38 = __p;
    if (__p)
    {
      v39 = v93;
      v40 = __p;
      if (v93 != __p)
      {
        do
        {
          v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v39 - 1);
        }

        while (v39 != v38);
        v40 = __p;
      }

      v93 = v38;
      operator delete(v40);
    }

    v41 = v90;
    if (v90)
    {
      v42 = v91;
      v43 = v90;
      if (v91 != v90)
      {
        do
        {
          v44 = OUTLINED_FUNCTION_17_5();
          if (v44)
          {
            operator delete[](v44);
          }
        }

        while (v42 != v41);
        v43 = v90;
      }

      v91 = v41;
      operator delete(v43);
    }

    v45 = OUTLINED_FUNCTION_12_5(v37, v30, v31, v32, v33, v34, v35, v36, v76, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88);
    if (!v9)
    {
      free(v45);
    }
  }

  return v13;
}

uint64_t mlir::tensor::PackOp::getSpeculatability(mlir::tensor::PackOp *this)
{
  v1 = *this;
  v2 = *(v1 + 44);
  v3 = (v1 + 16 * ((v2 >> 23) & 1));
  v4 = v3[24];
  if ((v2 & 0x800000) != 0)
  {
    v5 = *(v1 + 72);
    if (!v4)
    {
      return areTilesAndTiledDimsAllConstant<mlir::tensor::PackOp>(v1);
    }
  }

  else
  {
    v5 = 0;
    if (!v4)
    {
      return areTilesAndTiledDimsAllConstant<mlir::tensor::PackOp>(v1);
    }
  }

  if (*(v5 + 32 * (v3[23] + v3[22]) + 24))
  {
    return 1;
  }

  return areTilesAndTiledDimsAllConstant<mlir::tensor::PackOp>(v1);
}

void mlir::tensor::ConcatOp::print(mlir::tensor::ConcatOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_79_0();
  (*(v6 + 16))(v7);
  OUTLINED_FUNCTION_13_3();
  if (v10)
  {
    llvm::raw_ostream::write(v8, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v8, v9);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v13 > 2)
  {
    *(v12 + 2) = 109;
    OUTLINED_FUNCTION_15_4(v11, v12);
  }

  else
  {
    llvm::raw_ostream::write(v11, "dim", 3uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v16)
  {
    llvm::raw_ostream::write(v14, "(", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v14, v15);
  }

  OUTLINED_FUNCTION_19_5();
  OUTLINED_FUNCTION_104();
  (*(v17 + 48))(v2);
  OUTLINED_FUNCTION_104();
  (*(v18 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v16)
  {
    llvm::raw_ostream::write(v19, ")", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v19, v20);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v10)
  {
    llvm::raw_ostream::write(v21, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v21, v22);
  }

  OUTLINED_FUNCTION_47_0();
  if (v23 < 0)
  {
    OUTLINED_FUNCTION_177_0();
  }

  else
  {
    OUTLINED_FUNCTION_99_3();
  }

  (*(*v2 + 16))(v2);
  if (v5)
  {
    OUTLINED_FUNCTION_104();
    (*(v24 + 160))(v2);
    v25 = v5 - 1;
    if (v25)
    {
      v26 = v4 + 56;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v16 & v10)
        {
          OUTLINED_FUNCTION_21_5(v27);
        }

        else
        {
          OUTLINED_FUNCTION_42_0();
        }

        v26 += 32;
        OUTLINED_FUNCTION_104();
        (*(v28 + 160))(v2);
        --v25;
      }

      while (v25);
    }
  }

  OUTLINED_FUNCTION_104_3();
  mlir::Operation::getAttrDictionary(*v3);
  OUTLINED_FUNCTION_154_1();
  mlir::ArrayAttr::getValue(v29);
  OUTLINED_FUNCTION_36_6();
  v30 = OUTLINED_FUNCTION_31_3();
  v31(v30);
  OUTLINED_FUNCTION_104();
  (*(v32 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v10)
  {
    llvm::raw_ostream::write(v33, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v33, v34);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v16)
  {
    llvm::raw_ostream::write(v35, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_6_11(v35, v36);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v10)
  {
    llvm::raw_ostream::write(v37, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v37, v38);
  }

  OUTLINED_FUNCTION_90_2();
  if (v39 < 0)
  {
    OUTLINED_FUNCTION_174_0();
  }

  else
  {
    OUTLINED_FUNCTION_90();
  }

  v41 = OUTLINED_FUNCTION_131_1(v40, v59);
  v49 = OUTLINED_FUNCTION_43_7(v41, v42, v43, v44, v45, v46, v47, v48, v60, v62, v64, v66, v68, v70, v72, v74, v76, v78, v80);
  v50 = OUTLINED_FUNCTION_130_3(v49);
  v58 = OUTLINED_FUNCTION_182_0(v50, v51, v52, v53, v54, v55, v56, v57, v61, v63, v65, v67, v69, v71, v73, v75, v77, v79, v81, v82);
  if (!v16)
  {
    free(v58);
  }
}

void mlir::tensor::ExpandShapeOp::print(mlir::tensor::ExpandShapeOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v105[4] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v6, v7);
  }

  OUTLINED_FUNCTION_12_7();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v10 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v11, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v11, v12);
  }

  OUTLINED_FUNCTION_19_5();
  OUTLINED_FUNCTION_104();
  (*(v13 + 48))(v2);
  OUTLINED_FUNCTION_104();
  (*(v14 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v15, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v15, v16);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v19 > 0xB)
  {
    *(v18 + 8) = 1701863784;
    OUTLINED_FUNCTION_192(v17, v18);
  }

  else
  {
    llvm::raw_ostream::write(v17, "output_shape", 0xCuLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v20, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v20, v21);
  }

  v22 = *v3;
  v23 = *(*v3 + 11);
  if ((v23 & 0x800000) != 0)
  {
    v24 = *(v22 + 9);
  }

  else
  {
    v24 = 0;
  }

  v25 = OUTLINED_FUNCTION_122_2(*(v22 + 2 * ((v23 >> 23) & 1) + 9), v81, v86, v91, v96, v100);
  v33 = OUTLINED_FUNCTION_26_10(v25, v26, v27, v28, v29, v30, v31, v32, v82, v87, v92, v97, v101, v104);
  mlir::ValueRange::ValueRange(v33, v34, v35);
  OUTLINED_FUNCTION_15_13();
  OUTLINED_FUNCTION_132_2(v36, v37, v24 + 32, v38, v39, v40, v41, v42, v83, v88, v93);
  v105[0] = "reassociation";
  v105[1] = 13;
  v105[2] = "static_output_shape";
  v105[3] = 19;
  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  OUTLINED_FUNCTION_162_1(AttrDictionary, v44, v45, v46, v47, v48, v49, v50, v84, v89, v94, v98, v102);
  OUTLINED_FUNCTION_14_14();
  v51 = OUTLINED_FUNCTION_31_3();
  v52(v51);
  OUTLINED_FUNCTION_104();
  (*(v53 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v54, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v54, v55);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v58)
  {
    llvm::raw_ostream::write(v56, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_6_11(v56, v57);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v59, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v59, v60);
  }

  OUTLINED_FUNCTION_11_5();
  v61 = OUTLINED_FUNCTION_12_4();
  v62(v61);
  OUTLINED_FUNCTION_104();
  (*(v63 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v64, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v64, v65);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_42_5();
  if (!v58 & v8)
  {
    OUTLINED_FUNCTION_20_10(v66, v67);
  }

  else
  {
    llvm::raw_ostream::write(v66, "into", 4uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v68, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v68, v69);
  }

  OUTLINED_FUNCTION_28_4(*v3);
  OUTLINED_FUNCTION_104();
  v70 = OUTLINED_FUNCTION_12_4();
  v72 = v71(v70);
  v80 = OUTLINED_FUNCTION_109_3(v72, v73, v74, v75, v76, v77, v78, v79, v85, v90, v95, v99, v103, v105);
  if (!v58)
  {
    free(v80);
  }
}

uint64_t mlir::tensor::ExtractOp::getODSOperandIndexAndLength(mlir::tensor::ExtractOp *this, unsigned int a2)
{
  v2 = &dword_1E097F5E1;
  if (a2)
  {
    v3 = a2;
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
      goto LABEL_14;
    }

    if (a2 >= 0x20)
    {
      *v6.i64 = OUTLINED_FUNCTION_22_4();
      do
      {
        *v6.i64 = OUTLINED_FUNCTION_14_8(v6);
      }

      while (!v14);
      OUTLINED_FUNCTION_26_5(v6, v7, v8, v9, v10, v11, v12, v13);
      if (v14)
      {
        goto LABEL_16;
      }

      if ((v3 & 0x1C) == 0)
      {
LABEL_14:
        v20 = v2 + v4;
        v21 = v3 - v4;
        do
        {
          v22 = *v20++;
          v5 += v22;
          --v21;
        }

        while (v21);
        goto LABEL_16;
      }
    }

    *v17.i32 = OUTLINED_FUNCTION_82_0();
    do
    {
      v19 = *v15++;
      v18.i32[0] = v19;
      v18 = vmovl_u8(v18).u64[0];
      v17 = vaddw_u16(v17, v18);
      v16 += 4;
    }

    while (v16);
    v5 = vaddvq_s32(v17);
    if (v4 != v3)
    {
      goto LABEL_14;
    }
  }

LABEL_16:
  OUTLINED_FUNCTION_87_0();
  if (!v14)
  {
    v23 = v24;
  }

  return OUTLINED_FUNCTION_78_0(v23);
}

void mlir::tensor::ExtractSliceOp::print(mlir::tensor::ExtractSliceOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v197[4] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v6, v7);
  }

  OUTLINED_FUNCTION_12_7();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_155();
  OUTLINED_FUNCTION_122_2(*(v10 + 64), v126, v138, v150, v162, v174);
  OUTLINED_FUNCTION_90_0();
  v19 = OUTLINED_FUNCTION_26_10(v11, v12, v13, v14, v15, v16, v17, v18, v127, v139, v151, v163, v175, v186);
  v22 = mlir::ValueRange::ValueRange(v19, v20, v21);
  OUTLINED_FUNCTION_15_7(v22, v23, v24, v25, v26, v27, v28, v29, v128, v140, v152, v164, v176, v187, v193);
  OUTLINED_FUNCTION_104();
  (*(v30 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v31, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v31, v32);
  }

  OUTLINED_FUNCTION_116_0();
  OUTLINED_FUNCTION_68_3();
  OUTLINED_FUNCTION_122_2(*(v33 + 8), v129, v141, v153, v165, v177);
  OUTLINED_FUNCTION_90_0();
  v42 = OUTLINED_FUNCTION_26_10(v34, v35, v36, v37, v38, v39, v40, v41, v130, v142, v154, v166, v178, v188);
  v45 = mlir::ValueRange::ValueRange(v42, v43, v44);
  OUTLINED_FUNCTION_15_7(v45, v46, v47, v48, v49, v50, v51, v52, v131, v143, v155, v167, v179, v189, v194);
  OUTLINED_FUNCTION_104();
  (*(v53 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v54, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v54, v55);
  }

  OUTLINED_FUNCTION_137_2();
  OUTLINED_FUNCTION_47_6();
  OUTLINED_FUNCTION_122_2(*(v56 + 80), v132, v144, v156, v168, v180);
  OUTLINED_FUNCTION_90_0();
  v65 = OUTLINED_FUNCTION_26_10(v57, v58, v59, v60, v61, v62, v63, v64, v133, v145, v157, v169, v181, v190);
  v68 = mlir::ValueRange::ValueRange(v65, v66, v67);
  v76 = OUTLINED_FUNCTION_15_7(v68, v69, v70, v71, v72, v73, v74, v75, v134, v146, v158, v170, v182, v191, v195);
  v197[0] = "operandSegmentSizes";
  v197[1] = 19;
  v197[2] = "static_offsets";
  v197[3] = 14;
  OUTLINED_FUNCTION_35_8(v76, v77, v78, v79, v80, v81, v82, v83, v135, v147, v159, v171, v183, v197, v196);
  OUTLINED_FUNCTION_66_4();
  *v84 = "static_sizes";
  v84[1] = 12;
  OUTLINED_FUNCTION_46_3();
  if (v8)
  {
    OUTLINED_FUNCTION_61_4(v85, v136, v148, v160, v172, v184);
  }

  OUTLINED_FUNCTION_113_3();
  OUTLINED_FUNCTION_38_8(v86);
  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  OUTLINED_FUNCTION_162_1(AttrDictionary, v88, v89, v90, v91, v92, v93, v94, v136, v148, v160, v172, v184);
  OUTLINED_FUNCTION_14_14();
  v95 = OUTLINED_FUNCTION_31_3();
  v96(v95);
  OUTLINED_FUNCTION_104();
  (*(v97 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v98, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v98, v99);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v102)
  {
    llvm::raw_ostream::write(v100, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_6_11(v100, v101);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v103, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v103, v104);
  }

  OUTLINED_FUNCTION_11_5();
  v105 = OUTLINED_FUNCTION_12_4();
  v106(v105);
  OUTLINED_FUNCTION_104();
  (*(v107 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v108, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v108, v109);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v112 > 1)
  {
    OUTLINED_FUNCTION_8_3(v110, v111);
  }

  else
  {
    llvm::raw_ostream::write(v110, "to", 2uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v113, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v113, v114);
  }

  OUTLINED_FUNCTION_28_4(*v3);
  OUTLINED_FUNCTION_104();
  v115 = OUTLINED_FUNCTION_12_4();
  v117 = v116(v115);
  v125 = OUTLINED_FUNCTION_109_3(v117, v118, v119, v120, v121, v122, v123, v124, v137, v149, v161, v173, v185, v192);
  if (!v102)
  {
    free(v125);
  }
}

void mlir::tensor::GatherOp::print(mlir::tensor::GatherOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v97[6] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v5 + 16))(v6);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v7, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v7, v8);
  }

  OUTLINED_FUNCTION_12_7();
  (*(v10 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v11 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v12, "[", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v12, v13);
  }

  OUTLINED_FUNCTION_38_1();
  (*(v15 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v16 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v17, "]", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v17, v18);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v19, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v19, v20);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v23 > 0xA)
  {
    *(v22 + 7) = 1936550244;
    *v22 = *"gather_dims";
    v21[4] += 11;
  }

  else
  {
    llvm::raw_ostream::write(v21, "gather_dims", 0xBuLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v24, "(", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v24, v25);
  }

  OUTLINED_FUNCTION_19_5();
  v97[0] = *(v26 + 64);
  OUTLINED_FUNCTION_104();
  if (((*(v27 + 56))(v2) & 1) == 0)
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_67_3();
    (*(v28 + 80))();
    OUTLINED_FUNCTION_34_9();
    v31 = v29 - v30;
    mlir::detail::DenseArrayAttrImpl<long long>::print(v97, v2);
    OUTLINED_FUNCTION_127_3();
    (*(v32 + 80))(v4);
    OUTLINED_FUNCTION_34_9();
    if (v31 == v33 - v34)
    {
      OUTLINED_FUNCTION_104();
      (*(v35 + 40))(v2);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v36, ")", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v36, v37);
  }

  OUTLINED_FUNCTION_19_5();
  if (*(v38 + 72))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v9)
    {
      llvm::raw_ostream::write(v39, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v39, v40);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v43 > 5)
    {
      *(v42 + 4) = 25973;
      OUTLINED_FUNCTION_105_3(v41, v42);
    }

    else
    {
      llvm::raw_ostream::write(v41, "unique", 6uLL);
    }
  }

  OUTLINED_FUNCTION_104_3();
  OUTLINED_FUNCTION_125_2();
  mlir::Operation::getAttrDictionary(*v3);
  OUTLINED_FUNCTION_154_1();
  mlir::ArrayAttr::getValue(v44);
  OUTLINED_FUNCTION_36_6();
  v45 = OUTLINED_FUNCTION_31_3();
  v46(v45);
  OUTLINED_FUNCTION_104();
  (*(v47 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v48, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v48, v49);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v50, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_6_11(v50, v51);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v52, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v52, v53);
  }

  OUTLINED_FUNCTION_90_2();
  if (v54 < 0)
  {
    OUTLINED_FUNCTION_174_0();
  }

  else
  {
    OUTLINED_FUNCTION_90();
  }

  v56 = OUTLINED_FUNCTION_131_1(v55, v74);
  v64 = OUTLINED_FUNCTION_43_7(v56, v57, v58, v59, v60, v61, v62, v63, v75, v77, v79, v81, v83, v85, v87, v89, v91, v93, v95);
  v65 = OUTLINED_FUNCTION_130_3(v64);
  v73 = OUTLINED_FUNCTION_182_0(v65, v66, v67, v68, v69, v70, v71, v72, v76, v78, v80, v82, v84, v86, v88, v90, v92, v94, v96, v97[0]);
  if (!v14)
  {
    free(v73);
  }
}

uint64_t mlir::tensor::InsertOp::getODSOperandIndexAndLength(mlir::tensor::InsertOp *this, unsigned int a2)
{
  v2 = &dword_1E097F5E1 + 2;
  if (!a2)
  {
    goto LABEL_16;
  }

  v3 = a2;
  if (a2 < 4)
  {
    v4 = 0;
    v5 = 0;
LABEL_14:
    v20 = &v2[v4];
    v21 = v3 - v4;
    do
    {
      v22 = *v20++;
      v5 += v22;
      --v21;
    }

    while (v21);
    goto LABEL_16;
  }

  if (a2 >= 0x20)
  {
    *v6.i64 = OUTLINED_FUNCTION_22_4();
    do
    {
      *v6.i64 = OUTLINED_FUNCTION_14_8(v6);
    }

    while (!v14);
    OUTLINED_FUNCTION_26_5(v6, v7, v8, v9, v10, v11, v12, v13);
    if (v14)
    {
      goto LABEL_16;
    }

    if ((v3 & 0x1C) == 0)
    {
      goto LABEL_14;
    }
  }

  *v17.i32 = OUTLINED_FUNCTION_82_0();
  do
  {
    v19 = *v15++;
    v18.i32[0] = v19;
    v18 = vmovl_u8(v18).u64[0];
    v17 = vaddw_u16(v17, v18);
    v16 += 4;
  }

  while (v16);
  v5 = vaddvq_s32(v17);
  if (v4 != v3)
  {
    goto LABEL_14;
  }

LABEL_16:
  if ((*(*this + 46) & 0x80) != 0)
  {
    v23 = *(*this + 68);
  }

  else
  {
    v23 = 0;
  }

  v14 = v2[a2] == 0;
  v24 = 0x100000000;
  if (!v14)
  {
    v24 = (v23 - 2) << 32;
  }

  return OUTLINED_FUNCTION_78_0(v24);
}

void mlir::tensor::PadOp::print(mlir::tensor::PadOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v6, v7);
  }

  OUTLINED_FUNCTION_12_7();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_19_5();
  if (*(v10 + 64))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v8)
    {
      llvm::raw_ostream::write(v11, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v11, v12);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v15 > 5)
    {
      *(v14 + 4) = 25708;
      OUTLINED_FUNCTION_105_3(v13, v14);
    }

    else
    {
      llvm::raw_ostream::write(v13, "nofold", 6uLL);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v16, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v16, v17);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v20 > 2)
  {
    *(v19 + 2) = 119;
    OUTLINED_FUNCTION_15_4(v18, v19);
  }

  else
  {
    llvm::raw_ostream::write(v18, "low", 3uLL);
  }

  OUTLINED_FUNCTION_155();
  OUTLINED_FUNCTION_88_3(v21, v126, v135, v144, v153, v162);
  OUTLINED_FUNCTION_90_0();
  v30 = OUTLINED_FUNCTION_26_10(v22, v23, v24, v25, v26, v27, v28, v29, v127, v136, v145, v154, v163, v171);
  v33 = mlir::ValueRange::ValueRange(v30, v31, v32);
  OUTLINED_FUNCTION_15_7(v33, v34, v35, v36, v37, v38, v39, v40, v128, v137, v146, v155, v164, v172, v177);
  OUTLINED_FUNCTION_104();
  (*(v41 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v42, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v42, v43);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_42_5();
  if (!v46 & v8)
  {
    *v45 = 1751607656;
    OUTLINED_FUNCTION_41_6(v44);
  }

  else
  {
    llvm::raw_ostream::write(v44, "high", 4uLL);
  }

  OUTLINED_FUNCTION_116_0();
  OUTLINED_FUNCTION_68_3();
  OUTLINED_FUNCTION_122_2(*(v47 + 8), v129, v138, v147, v156, v165);
  OUTLINED_FUNCTION_90_0();
  v56 = OUTLINED_FUNCTION_26_10(v48, v49, v50, v51, v52, v53, v54, v55, v130, v139, v148, v157, v166, v173);
  v59 = mlir::ValueRange::ValueRange(v56, v57, v58);
  OUTLINED_FUNCTION_15_7(v59, v60, v61, v62, v63, v64, v65, v66, v131, v140, v149, v158, v167, v174, v178);
  OUTLINED_FUNCTION_104();
  (*(v67 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v68, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v68, v69);
  }

  OUTLINED_FUNCTION_18_9();
  v73 = (v71 + 32 * v72);
  if (*v73 != v73)
  {
    v74 = OUTLINED_FUNCTION_195(v70, v73);
    if (v74)
    {
      mlir::Operation::getAttrDictionary(v74);
      OUTLINED_FUNCTION_154_1();
      mlir::AffineBinaryOpExpr::getLHS(v75);
    }
  }

  OUTLINED_FUNCTION_18_9();
  OUTLINED_FUNCTION_104();
  (*(v76 + 224))(v2);
  OUTLINED_FUNCTION_101_3();
  OUTLINED_FUNCTION_35_8(v77, v78, v79, v80, v81, v82, v83, v84, v132, v141, v150, v159, v168, v175, v179);
  OUTLINED_FUNCTION_66_4();
  *v85 = "static_low";
  v85[1] = 10;
  OUTLINED_FUNCTION_46_3();
  if (v8)
  {
    OUTLINED_FUNCTION_61_4(v86, v133, v142, v151, v160, v169);
  }

  OUTLINED_FUNCTION_113_3();
  OUTLINED_FUNCTION_38_8(v87);
  mlir::Attribute::getContext((*v3 + 24));
  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  OUTLINED_FUNCTION_162_1(AttrDictionary, v89, v90, v91, v92, v93, v94, v95, v133, v142, v151, v160, v169);
  OUTLINED_FUNCTION_14_14();
  v96 = OUTLINED_FUNCTION_31_3();
  v97(v96);
  OUTLINED_FUNCTION_104();
  (*(v98 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v99, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v99, v100);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v46)
  {
    llvm::raw_ostream::write(v101, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_6_11(v101, v102);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v103, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v103, v104);
  }

  OUTLINED_FUNCTION_11_5();
  v105 = OUTLINED_FUNCTION_12_4();
  v106(v105);
  OUTLINED_FUNCTION_104();
  (*(v107 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v108, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v108, v109);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v112 > 1)
  {
    OUTLINED_FUNCTION_8_3(v110, v111);
  }

  else
  {
    llvm::raw_ostream::write(v110, "to", 2uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v113, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v113, v114);
  }

  OUTLINED_FUNCTION_28_4(*v3);
  OUTLINED_FUNCTION_104();
  v115 = OUTLINED_FUNCTION_12_4();
  v117 = v116(v115);
  v125 = OUTLINED_FUNCTION_109_3(v117, v118, v119, v120, v121, v122, v123, v124, v134, v143, v152, v161, v170, v176);
  if (!v46)
  {
    free(v125);
  }
}

void mlir::tensor::ReshapeOp::print(mlir::tensor::ReshapeOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v6, v7);
  }

  OUTLINED_FUNCTION_12_7();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v10 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v11, "(", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v11, v12);
  }

  OUTLINED_FUNCTION_38_1();
  (*(v14 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v15 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v16, ")", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v16, v17);
  }

  OUTLINED_FUNCTION_104_3();
  mlir::Operation::getAttrDictionary(*v3);
  OUTLINED_FUNCTION_154_1();
  mlir::ArrayAttr::getValue(v18);
  OUTLINED_FUNCTION_36_6();
  v19 = OUTLINED_FUNCTION_31_3();
  v20(v19);
  OUTLINED_FUNCTION_104();
  (*(v21 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v22, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v22, v23);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v24, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_6_11(v24, v25);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v26, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v26, v27);
  }

  OUTLINED_FUNCTION_90_2();
  if (v28 < 0)
  {
    OUTLINED_FUNCTION_174_0();
  }

  else
  {
    OUTLINED_FUNCTION_90();
  }

  v30 = OUTLINED_FUNCTION_131_1(v29, v48);
  v38 = OUTLINED_FUNCTION_43_7(v30, v31, v32, v33, v34, v35, v36, v37, v49, v51, v53, v55, v57, v59, v61, v63, v65, v67, v69);
  v39 = OUTLINED_FUNCTION_130_3(v38);
  v47 = OUTLINED_FUNCTION_182_0(v39, v40, v41, v42, v43, v44, v45, v46, v50, v52, v54, v56, v58, v60, v62, v64, v66, v68, v70, v71);
  if (!v13)
  {
    free(v47);
  }
}

void mlir::tensor::ScatterOp::print(mlir::tensor::ScatterOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v105[6] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v5 + 16))(v6);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v7, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v7, v8);
  }

  OUTLINED_FUNCTION_12_7();
  (*(v10 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v11 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v12, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v12, v13);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_42_5();
  if (!v16 & v9)
  {
    OUTLINED_FUNCTION_20_10(v14, v15);
  }

  else
  {
    llvm::raw_ostream::write(v14, "into", 4uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v17, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v17, v18);
  }

  OUTLINED_FUNCTION_38_1();
  (*(v19 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v20 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v16)
  {
    llvm::raw_ostream::write(v21, "[", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v21, v22);
  }

  OUTLINED_FUNCTION_104();
  (*(v23 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v24 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v16)
  {
    llvm::raw_ostream::write(v25, "]", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v25, v26);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v27, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v27, v28);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v31 > 0xB)
  {
    *(v30 + 8) = 1936550244;
    OUTLINED_FUNCTION_192(v29, v30);
  }

  else
  {
    llvm::raw_ostream::write(v29, "scatter_dims", 0xCuLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v16)
  {
    llvm::raw_ostream::write(v32, "(", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v32, v33);
  }

  OUTLINED_FUNCTION_19_5();
  v105[0] = *(v34 + 64);
  OUTLINED_FUNCTION_104();
  if (((*(v35 + 56))(v2) & 1) == 0)
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_67_3();
    (*(v36 + 80))();
    OUTLINED_FUNCTION_34_9();
    v39 = v37 - v38;
    mlir::detail::DenseArrayAttrImpl<long long>::print(v105, v2);
    OUTLINED_FUNCTION_127_3();
    (*(v40 + 80))(v4);
    OUTLINED_FUNCTION_34_9();
    if (v39 == v41 - v42)
    {
      OUTLINED_FUNCTION_104();
      (*(v43 + 40))(v2);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v16)
  {
    llvm::raw_ostream::write(v44, ")", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v44, v45);
  }

  OUTLINED_FUNCTION_19_5();
  if (*(v46 + 72))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v9)
    {
      llvm::raw_ostream::write(v47, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v47, v48);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v51 > 5)
    {
      *(v50 + 4) = 25973;
      OUTLINED_FUNCTION_105_3(v49, v50);
    }

    else
    {
      llvm::raw_ostream::write(v49, "unique", 6uLL);
    }
  }

  OUTLINED_FUNCTION_104_3();
  OUTLINED_FUNCTION_125_2();
  mlir::Operation::getAttrDictionary(*v3);
  OUTLINED_FUNCTION_154_1();
  mlir::ArrayAttr::getValue(v52);
  OUTLINED_FUNCTION_36_6();
  v53 = OUTLINED_FUNCTION_31_3();
  v54(v53);
  OUTLINED_FUNCTION_104();
  (*(v55 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v56, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v56, v57);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v16)
  {
    llvm::raw_ostream::write(v58, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_6_11(v58, v59);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v60, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v60, v61);
  }

  OUTLINED_FUNCTION_90_2();
  if (v62 < 0)
  {
    OUTLINED_FUNCTION_174_0();
  }

  else
  {
    OUTLINED_FUNCTION_90();
  }

  v64 = OUTLINED_FUNCTION_131_1(v63, v82);
  v72 = OUTLINED_FUNCTION_43_7(v64, v65, v66, v67, v68, v69, v70, v71, v83, v85, v87, v89, v91, v93, v95, v97, v99, v101, v103);
  v73 = OUTLINED_FUNCTION_130_3(v72);
  v81 = OUTLINED_FUNCTION_182_0(v73, v74, v75, v76, v77, v78, v79, v80, v84, v86, v88, v90, v92, v94, v96, v98, v100, v102, v104, v105[0]);
  if (!v16)
  {
    free(v81);
  }
}

uint64_t mlir::tensor::UnPackOp::getODSOperands(mlir::tensor::UnPackOp *this, unsigned int a2, double a3, int32x4_t a4)
{
  if (a2)
  {
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
LABEL_14:
      v26 = a2 - v4;
      v27 = &dword_1E097F5E1 + v4 + 2;
      do
      {
        v28 = *v27++;
        v5 += v28;
        --v26;
      }

      while (v26);
      goto LABEL_16;
    }

    if (a2 >= 0x20)
    {
      v6 = 0uLL;
      v7 = "_120ChainedTensorBitcastE";
      v8 = 0uLL;
      v4 = a2 & 0xFFFFFFE0;
      v9 = v4;
      v10 = 0uLL;
      v11 = 0uLL;
      v12 = 0uLL;
      v13 = 0uLL;
      v14 = 0uLL;
      v15 = 0uLL;
      do
      {
        v16 = *v7[-2].i8;
        v17 = vmovl_u8(*v16.i8);
        v18 = vmovl_high_u8(v16);
        v19 = vmovl_u8(*v7);
        v20 = vmovl_high_u8(*v7->i8);
        v11 = vaddw_high_u16(v11, v18);
        v10 = vaddw_u16(v10, *v18.i8);
        v8 = vaddw_high_u16(v8, v17);
        v6 = vaddw_u16(v6, *v17.i8);
        v15 = vaddw_high_u16(v15, v20);
        v14 = vaddw_u16(v14, *v20.i8);
        v13 = vaddw_high_u16(v13, v19);
        v12 = vaddw_u16(v12, *v19.i8);
        v7 += 4;
        v9 -= 32;
      }

      while (v9);
      a4 = vaddq_s32(vaddq_s32(v13, v8), vaddq_s32(v15, v11));
      v5 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v12, v6), vaddq_s32(v14, v10)), a4));
      if (v4 == a2)
      {
        goto LABEL_16;
      }

      if ((a2 & 0x1C) == 0)
      {
        goto LABEL_14;
      }
    }

    else
    {
      v5 = 0;
      v4 = 0;
    }

    v21 = v4;
    v4 = a2 & 0xFFFFFFFC;
    v22 = v5;
    v23 = (&dword_1E097F5E1 + v21 + 2);
    v24 = v21 - v4;
    do
    {
      v25 = *v23++;
      a4.i32[0] = v25;
      a4.i64[0] = vmovl_u8(*a4.i8).u64[0];
      v22 = vaddw_u16(v22, *a4.i8);
      v24 += 4;
    }

    while (v24);
    v5 = vaddvq_s32(v22);
    if (v4 == a2)
    {
      goto LABEL_16;
    }

    goto LABEL_14;
  }

  v5 = 0;
LABEL_16:
  v29 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v30 = *(v29 + 68);
    v31 = *(v29 + 72);
  }

  else
  {
    v30 = 0;
    v31 = 0;
  }

  return v31 + 32 * (a2 + (v30 - 3) * v5);
}

uint64_t anonymous namespace::SingleInputConcatOp::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 1)
  {
    return 0;
  }

  if (*(a2 + 36))
  {
    v5 = a2 - 16;
  }

  else
  {
    v5 = 0;
  }

  v6 = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v12[0] = *(*(a2 + 72) + 24);
  v12[1] = v6;
  v7 = OUTLINED_FUNCTION_146_2();
  mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::RankedTensorType>>(v7, v8, v9, v12);
  OUTLINED_FUNCTION_140();
  (*(v10 + 8))(a3, a2);
  return 1;
}

uint64_t anonymous namespace::ReplaceEmptyTensorStaticShapeDims::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v22[6] = *MEMORY[0x1E69E9840];
  v21[0] = v22;
  v21[1] = 0x600000000;
  v5 = *(OUTLINED_FUNCTION_164_1(*(a2 + 36)) + 8);
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v6 = *(a2 + 68);
    v7 = *(a2 + 72);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(v20, v7, v6);
  v19 = foldDynamicToStaticDimSizes(v5 & 0xFFFFFFFFFFFFFFF8, v20[0], v20[1], v21);
  OUTLINED_FUNCTION_164_1(*(a2 + 36));
  OUTLINED_FUNCTION_110_1();
  if (v19 == v8)
  {
    v9 = 0;
  }

  else
  {
    v10 = OUTLINED_FUNCTION_184_0();
    v20[0] = mlir::OpBuilder::create<mlir::tensor::EmptyOp,mlir::RankedTensorType &,llvm::SmallVector<mlir::Value,6u> &>(v10, v11, v12, v13);
    OUTLINED_FUNCTION_164_1(*(a2 + 36));
    OUTLINED_FUNCTION_110_1();
    v14 = OUTLINED_FUNCTION_146_2();
    mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::RankedTensorType,mlir::tensor::EmptyOp &>(v14, v15, v16, v20);
    OUTLINED_FUNCTION_140();
    (*(v17 + 8))(a3, a2);
    v9 = 1;
  }

  if (v21[0] != v22)
  {
    free(v21[0]);
  }

  return v9;
}

uint64_t anonymous namespace::StaticTensorGenerate::matchAndRewrite(uint64_t a1, uint64_t a2, void *a3)
{
  v37[8] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_101_3();
  v37[1] = 0x600000000;
  v6 = *(v5 - 8);
  if ((*(v5 + 46) & 0x80) != 0)
  {
    v7 = *(a2 + 68);
    v8 = *(a2 + 72);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(&v35, v8, v7);
  v9 = foldDynamicToStaticDimSizes(v6 & 0xFFFFFFFFFFFFFFF8, v35, v36, v37);
  v34 = v9;
  if (v9 == (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = 0;
  }

  else
  {
    v18 = OUTLINED_FUNCTION_184_0();
    v35 = mlir::OpBuilder::create<mlir::tensor::GenerateOp,mlir::RankedTensorType &,llvm::SmallVector<mlir::Value,6u> &>(v18, v19, v20, v21);
    OUTLINED_FUNCTION_10_14();
    OUTLINED_FUNCTION_10_14();
    mlir::RewriterBase::inlineRegionBefore(a3, v24, v22 + 32 * v23, *(v22 + 32 * v23 + 8));
    v33 = *(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
    v25 = OUTLINED_FUNCTION_146_2();
    mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::RankedTensorType,mlir::tensor::EmptyOp &>(v25, v26, v27, &v35);
    OUTLINED_FUNCTION_140();
    v9 = (*(v28 + 8))(a3, a2);
    v17 = 1;
  }

  v29 = OUTLINED_FUNCTION_109_3(v9, v10, v11, v12, v13, v14, v15, v16, v32, v33, v34, v35, v36, v37[0]);
  if (!v30)
  {
    free(v29);
  }

  return v17;
}

uint64_t mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp,SliceReturnTypeCanonicalizer,SliceCanonicalizer>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v40[6] = *MEMORY[0x1E69E9840];
  v28 = a2;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedOffsets(&v28, &__src);
  v38 = v40;
  v39 = 0x600000000;
  v4 = v36;
  v5 = __src;
  if (v36)
  {
    if (__src == v37)
    {
      v6 = v36;
      if (v36 < 7 || (llvm::SmallVectorBase<unsigned int>::grow_pod(&v38, v40, v36, 8), v6 = v36, v5 = __src, v36))
      {
        memcpy(v38, v5, 8 * v6);
        v5 = __src;
      }

      LODWORD(v39) = v4;
    }

    else
    {
      v38 = __src;
      v39 = v36;
      __src = v37;
      HIDWORD(v36) = 0;
      v5 = v37;
    }

    LODWORD(v36) = 0;
  }

  if (v5 != v37)
  {
    free(v5);
  }

  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes(&v28, &__dst);
  __src = v37;
  v36 = 0x600000000;
  v7 = v33;
  v8 = __dst;
  if (v33)
  {
    if (__dst == v34)
    {
      v9 = v33;
      if (v33 < 7 || (llvm::SmallVectorBase<unsigned int>::grow_pod(&__src, v37, v33, 8), v9 = v33, v8 = __dst, v33))
      {
        memcpy(__src, v8, 8 * v9);
        v8 = __dst;
      }

      LODWORD(v36) = v7;
    }

    else
    {
      __src = __dst;
      v36 = v33;
      __dst = v34;
      HIDWORD(v33) = 0;
      v8 = v34;
    }

    LODWORD(v33) = 0;
  }

  if (v8 != v34)
  {
    free(v8);
  }

  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides(&v28, &v29);
  __dst = v34;
  v33 = 0x600000000;
  v10 = v30;
  v11 = v29;
  if (v30)
  {
    if (v29 == v31)
    {
      v12 = v30;
      if (v30 < 7 || (llvm::SmallVectorBase<unsigned int>::grow_pod(&__dst, v34, v30, 8), v12 = v30, v11 = v29, v30))
      {
        memcpy(__dst, v11, 8 * v12);
        v11 = v29;
      }

      LODWORD(v33) = v10;
    }

    else
    {
      __dst = v29;
      v33 = v30;
      v29 = v31;
      HIDWORD(v30) = 0;
      v11 = v31;
    }

    LODWORD(v30) = 0;
  }

  if (v11 != v31)
  {
    free(v11);
  }

  if (mlir::foldDynamicIndexList(&v38, 1, 0) & 1) != 0 || (mlir::foldDynamicIndexList(&__src, 1, 0) & 1) != 0 || (v13 = 0, (mlir::foldDynamicIndexList(&__dst, 0, 0)))
  {
    v14 = a3;
    v15 = v28;
    v16 = v38;
    v17 = v39;
    v18 = __src;
    v19 = v36;
    v20 = __dst;
    v21 = v33;
    if (*(v28 + 36))
    {
      v22 = v28 - 16;
    }

    else
    {
      v22 = 0;
    }

    v29 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v22, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    mlir::ArrayAttr::getValue(&v29);
    v29 = mlir::tensor::ExtractSliceOp::inferCanonicalRankReducedResultType(v23, (*(*(*(v15 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), v16, v17, v18, v19, v20, v21);
    if (v29)
    {
      v24 = *(v28 + 24);
      v27 = *(*(v28 + 72) + 24);
      v25 = mlir::OpBuilder::create<mlir::tensor::ExtractSliceOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,4u>,llvm::SmallVector<mlir::OpFoldResult,4u>&,llvm::SmallVector<mlir::OpFoldResult,4u>>((v14 + 8), v24, &v29, &v27, &v38, &__src, &__dst);
      SliceCanonicalizer::operator()(&v27, v14, v28, v25);
      v13 = 1;
    }

    else
    {
      v13 = 0;
    }
  }

  if (__dst != v34)
  {
    free(__dst);
  }

  if (__src != v37)
  {
    free(__src);
  }

  if (v38 != v40)
  {
    free(v38);
  }

  return v13;
}

uint64_t anonymous namespace::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_158_2(*MEMORY[0x1E69E9840]);
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets(v5, v6);
  v79 = v81;
  v80 = 0x600000000;
  v7 = v77;
  if (v77)
  {
    OUTLINED_FUNCTION_172();
    if (v16)
    {
      v17 = v77;
      if (v77 >= 7)
      {
        OUTLINED_FUNCTION_196();
        v17 = v77;
        v9 = __src;
      }

      memcpy(v79, v9, 8 * v17);
      LODWORD(v80) = v77;
    }

    else
    {
      OUTLINED_FUNCTION_126_3(v8, v9, v10, v11, v12, v13, v14, v15, v56, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, __dst, v69, v70, v71, v72, v73, v74, v75, __src, v77, v78);
    }

    v77 = 0;
  }

  OUTLINED_FUNCTION_172();
  if (!v16)
  {
    free(v18);
  }

  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes(&v61, &__dst);
  OUTLINED_FUNCTION_128_3();
  if (v3)
  {
    OUTLINED_FUNCTION_139_2();
    if (v16)
    {
      v20 = v3;
      if (v3 < 7 || (OUTLINED_FUNCTION_85_5(), llvm::SmallVectorBase<unsigned int>::grow_pod(v21, v22, v23, 8), v20 = v69, v19 = __dst, v69))
      {
        memcpy(__src, v19, 8 * v20);
      }

      v77 = v3;
    }

    else
    {
      OUTLINED_FUNCTION_123_3();
    }

    LODWORD(v69) = 0;
  }

  OUTLINED_FUNCTION_139_2();
  if (!v16)
  {
    free(v24);
  }

  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides(&v61, &v62);
  OUTLINED_FUNCTION_136_1();
  if (&__dst)
  {
    OUTLINED_FUNCTION_179_0();
    if (v16)
    {
      p_dst = &__dst;
      if (&__dst < 7 || (OUTLINED_FUNCTION_197(v25, v26, v27, v28, v29, v30, v31, v32, v56, v58, v59), LODWORD(p_dst) = v63, v26 = v62, v63))
      {
        memcpy(__dst, v26, 8 * p_dst);
      }

      LODWORD(v69) = &__dst;
    }

    else
    {
      OUTLINED_FUNCTION_129_3();
    }

    LODWORD(v63) = 0;
  }

  OUTLINED_FUNCTION_179_0();
  if (!v16)
  {
    free(v34);
  }

  if (mlir::foldDynamicOffsetSizeList(&v79) & 1) != 0 || (mlir::foldDynamicOffsetSizeList(&__src) & 1) != 0 || (mlir::foldDynamicStrideList(&__dst))
  {
    OUTLINED_FUNCTION_27_5();
    v60 = v35 & 0xFFFFFFFFFFFFFFF8;
    mlir::ArrayAttr::getValue(&v60);
    v37 = v36;
    OUTLINED_FUNCTION_28_4(v61);
    OUTLINED_FUNCTION_112_3();
    mlir::tensor::ExtractSliceOp::inferCanonicalRankReducedResultType(v37, v38, v39, v40, v41, v42, v43, v44);
    OUTLINED_FUNCTION_108_3();
    if (!v16)
    {
      v37 = (a3 + 24);
      v57 = *(a3 + 24);
      v60 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::RankedTensorType>>((a3 + 8), *(v45 + 24), &v62, &v60) - 16;
      if (v57)
      {
        *v37 = v57;
      }

      else
      {
        *v37 = 0;
        *(a3 + 32) = 0;
      }
    }

    v46 = OUTLINED_FUNCTION_93_3();
    mlir::OpBuilder::create<mlir::tensor::InsertSliceOp,mlir::Value &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(v46, v47, v48, v49, v50, v51, v52);
    OUTLINED_FUNCTION_140();
    (*(v53 + 8))(a3, v37);
    v54 = 1;
  }

  else
  {
    v54 = 0;
  }

  if (__dst != v3)
  {
    free(__dst);
  }

  if (__src != v7)
  {
    free(__src);
  }

  if (v79 != v81)
  {
    free(v79);
  }

  return v54;
}

uint64_t mlir::tensor::PadOp::hasZeroLowPad(mlir::tensor::PadOp *this)
{
  v21[2] = *MEMORY[0x1E69E9840];
  v18 = *(*this + 16 * ((*(*this + 44) >> 23) & 1) + 80);
  v2 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&v18);
  v4 = v3;
  v5 = *(*this + 44);
  v6 = *this + 16 * ((v5 >> 23) & 1);
  v7 = *(v6 + 88);
  v8 = *(v6 + 92);
  if ((v5 & 0x800000) != 0)
  {
    v9 = *(*this + 72);
  }

  else
  {
    v9 = 0;
  }

  mlir::ValueRange::ValueRange(v21, v9 + 32 * v7, (v8 + v7) - v7);
  mlir::tensor::PadOp::getMixedPadImpl(this, v2, v4, v21[0], v21[1], &v18);
  v10 = v18;
  if (v19)
  {
    v11 = 8 * v19 - 8;
    do
    {
      v12 = *v10++;
      v13 = mlir::getConstantIntValue(v12) == 0;
      v15 = v14 & v13;
      v16 = v15 != 1 || v11 == 0;
      v11 -= 8;
    }

    while (!v16);
    v10 = v18;
  }

  else
  {
    v15 = 1;
  }

  if (v10 != &v20)
  {
    free(v10);
  }

  return v15;
}

uint64_t mlir::tensor::PadOp::hasZeroHighPad(mlir::tensor::PadOp *this)
{
  v22[2] = *MEMORY[0x1E69E9840];
  v19 = *(*this + 16 * ((*(*this + 44) >> 23) & 1) + 72);
  v2 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&v19);
  v4 = v3;
  v5 = *(*this + 44);
  v6 = (*this + 16 * ((v5 >> 23) & 1));
  v7 = v6[22];
  v8 = v6[23];
  v9 = v6[24];
  if ((v5 & 0x800000) != 0)
  {
    v10 = *(*this + 72);
  }

  else
  {
    v10 = 0;
  }

  mlir::ValueRange::ValueRange(v22, v10 + 32 * (v8 + v7), (v9 + v8 + v7) - (v8 + v7));
  mlir::tensor::PadOp::getMixedPadImpl(this, v2, v4, v22[0], v22[1], &v19);
  v11 = v19;
  if (v20)
  {
    v12 = 8 * v20 - 8;
    do
    {
      v13 = *v11++;
      v14 = mlir::getConstantIntValue(v13) == 0;
      v16 = v15 & v14;
      v17 = v16 != 1 || v12 == 0;
      v12 -= 8;
    }

    while (!v17);
    v11 = v19;
  }

  else
  {
    v16 = 1;
  }

  if (v11 != &v21)
  {
    free(v11);
  }

  return v16;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::ExtractSliceOp>::hasUnitStride(mlir::memref::ReinterpretCastOp *a1)
{
  v11[4] = *MEMORY[0x1E69E9840];
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides(a1, &v9);
  v1 = v9;
  if (v10)
  {
    v2 = 8 * v10 - 8;
    do
    {
      v3 = *v1++;
      v4 = mlir::getConstantIntValue(v3) == 1;
      v6 = v5 & v4;
      v7 = v6 != 1 || v2 == 0;
      v2 -= 8;
    }

    while (!v7);
    v1 = v9;
  }

  else
  {
    v6 = 1;
  }

  if (v1 != v11)
  {
    free(v1);
  }

  return v6;
}

uint64_t anonymous namespace::InsertSliceOpConstantArgumentFolder<mlir::tensor::ParallelInsertSliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_158_2(*MEMORY[0x1E69E9840]);
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets(v5, v6);
  v84 = v86;
  v85 = 0x600000000;
  v7 = v82;
  if (v82)
  {
    OUTLINED_FUNCTION_172();
    if (v16)
    {
      v17 = v82;
      if (v82 >= 7)
      {
        OUTLINED_FUNCTION_196();
        v17 = v82;
        v9 = __src;
      }

      memcpy(v84, v9, 8 * v17);
      LODWORD(v85) = v82;
    }

    else
    {
      OUTLINED_FUNCTION_126_3(v8, v9, v10, v11, v12, v13, v14, v15, v61, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, __dst, v74, v75, v76, v77, v78, v79, v80, __src, v82, v83);
    }

    v82 = 0;
  }

  OUTLINED_FUNCTION_172();
  if (!v16)
  {
    free(v18);
  }

  p_dst = &__dst;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes(&v66, &__dst);
  OUTLINED_FUNCTION_128_3();
  if (v3)
  {
    OUTLINED_FUNCTION_139_2();
    if (v16)
    {
      v21 = v3;
      if (v3 < 7 || (OUTLINED_FUNCTION_85_5(), llvm::SmallVectorBase<unsigned int>::grow_pod(v22, v23, v24, 8), v21 = v74, v20 = __dst, v74))
      {
        memcpy(__src, v20, 8 * v21);
      }

      v82 = v3;
    }

    else
    {
      OUTLINED_FUNCTION_123_3();
    }

    LODWORD(v74) = 0;
  }

  OUTLINED_FUNCTION_139_2();
  if (!v16)
  {
    free(v25);
  }

  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides(&v66, &v67);
  OUTLINED_FUNCTION_136_1();
  if (&__dst)
  {
    OUTLINED_FUNCTION_179_0();
    if (v16)
    {
      v34 = &__dst;
      if (&__dst < 7 || (OUTLINED_FUNCTION_197(v26, v27, v28, v29, v30, v31, v32, v33, v61, v63, v64), LODWORD(v34) = v68, v27 = v67, v68))
      {
        memcpy(__dst, v27, 8 * v34);
      }

      LODWORD(v74) = &__dst;
    }

    else
    {
      OUTLINED_FUNCTION_129_3();
    }

    LODWORD(v68) = 0;
  }

  OUTLINED_FUNCTION_179_0();
  if (!v16)
  {
    free(v35);
  }

  if (mlir::foldDynamicOffsetSizeList(&v84) & 1) != 0 || (mlir::foldDynamicOffsetSizeList(&__src) & 1) != 0 || (mlir::foldDynamicStrideList(&__dst))
  {
    OUTLINED_FUNCTION_27_5();
    v65 = v36 & 0xFFFFFFFFFFFFFFF8;
    mlir::ArrayAttr::getValue(&v65);
    OUTLINED_FUNCTION_112_3();
    mlir::tensor::ExtractSliceOp::inferCanonicalRankReducedResultType(v37, v38, v39, v40, v41, v42, v43, v44);
    OUTLINED_FUNCTION_108_3();
    if (!v16)
    {
      v47 = (a3 + 24);
      v62 = *(a3 + 24);
      p_dst = (a3 + 8);
      ParentOp = *(v46 + 16);
      if (ParentOp)
      {
        ParentOp = mlir::Block::getParentOp(ParentOp);
      }

      v49 = *(ParentOp + 2);
      v50 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(ParentOp, v45);
      *(a3 + 24) = v49;
      *(a3 + 32) = v50;
      v65 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::RankedTensorType>>((a3 + 8), *(v66 + 24), &v67, &v65) - 16;
      if (v62)
      {
        *v47 = v62;
      }

      else
      {
        *v47 = 0;
        *(a3 + 32) = 0;
      }
    }

    v51 = OUTLINED_FUNCTION_93_3();
    mlir::OpBuilder::create<mlir::tensor::ParallelInsertSliceOp,mlir::Value &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(v51, v52, v53, v54, v55, v56, v57);
    OUTLINED_FUNCTION_140();
    (*(v58 + 8))(a3, p_dst);
    v59 = 1;
  }

  else
  {
    v59 = 0;
  }

  if (__dst != v3)
  {
    free(__dst);
  }

  if (__src != v7)
  {
    free(__src);
  }

  if (v84 != v86)
  {
    free(v84);
  }

  return v59;
}

uint64_t FoldTensorCastProducerOp::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v52[3] = *MEMORY[0x1E69E9840];
  v39[0] = a2;
  v39[1] = a3;
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::tensor::InsertSliceOp,void>::id && !mlir::OpInterface<mlir::LoopLikeOpInterface,mlir::detail::LoopLikeOpInterfaceInterfaceTraits>::getInterfaceFor(a2) && (*(a2 + 46) & 0x80) != 0)
  {
    v6 = *(a2 + 68);
    if (v6)
    {
      v7 = *(a2 + 72);
      v8 = 32 * v6;
      v9 = (v7 + 24);
      do
      {
        if ((~*(*v9 + 2) & 7) != 0)
        {
          v48 = *v9;
          DefiningOp = mlir::Value::getDefiningOp(&v48);
          if (DefiningOp)
          {
            if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id && (mlir::tensor::preservesStaticInformation(*(DefiningOp - 8) & 0xFFFFFFFFFFFFFFF8, *(*(*(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0)
            {
              v12 = *(v39[0] + 36);
              v13 = (v39[0] - 16);
              if (!v12)
              {
                v13 = 0;
              }

              v43 = v13;
              v44 = v12;
              mlir::OperandRange::getTypes(&v43, &v48);
              v43 = v45;
              v44 = 0x400000000;
              v14 = v48;
              v15 = v49;
              v16 = v51;
              v17 = v51 - v49;
              if (v51 - v49 < 5)
              {
                v18 = 0;
                v19 = 0;
              }

              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod(&v43, v45, v51 - v49, 8);
                v18 = v44;
                v19 = v44;
              }

              if (v16 != v15)
              {
                v20 = (v43 + 8 * v18);
                do
                {
                  *v20++ = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v14, v15++) + 8) & 0xFFFFFFFFFFFFFFF8;
                }

                while (v16 != v15);
                v19 = v44;
              }

              LODWORD(v44) = v19 + v17;
              v40 = v42;
              v41 = 0x400000000;
              v21 = v39[0];
              if ((*(v39[0] + 46) & 0x80) != 0)
              {
                v22 = *(v39[0] + 68);
                if (v22 < 5 || (llvm::SmallVectorBase<unsigned int>::grow_pod(&v40, v42, v22, 8), v21 = v39[0], (*(v39[0] + 46) & 0x80) != 0))
                {
                  v23 = *(v21 + 68);
                  if (v23)
                  {
                    v24 = 0;
                    v25 = 32 * v23;
                    v26 = (*(v21 + 72) + 24);
                    do
                    {
                      v48 = *v26;
                      v27 = mlir::Value::getDefiningOp(&v48);
                      if (v27 && (v28 = v27, *(*(v27 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id))
                      {
                        v38 = mlir::tensor::preservesStaticInformation(*(v27 - 8) & 0xFFFFFFFFFFFFFFF8, *(*(*(v27 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
                        v29 = v26;
                        if (v38)
                        {
                          v29 = (*(v28 + 72) + 24);
                        }
                      }

                      else
                      {
                        v29 = v26;
                      }

                      v30 = *v29;
                      v31 = v41;
                      if (v41 >= HIDWORD(v41))
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod(&v40, v42, v41 + 1, 8);
                        v31 = v41;
                      }

                      *(v40 + v31) = v30;
                      LODWORD(v41) = v41 + 1;
                      mlir::MapDynamicShapeOpInterface::mapDynamicShape(&v48, v39);
                      v32 = mlir::MutableOperandRange::operator mlir::OperandRange(&v48);
                      v34 = v33;
                      if (v50 != v52)
                      {
                        free(v50);
                      }

                      v46 = v32;
                      v47 = v34;
                      if (v34)
                      {
                        OperandNumber = mlir::OpOperand::getOperandNumber((v26 - 3));
                        if (OperandNumber >= mlir::OperandRange::getBeginOperandIndex(&v46))
                        {
                          BeginOperandIndex = mlir::OperandRange::getBeginOperandIndex(&v46);
                          if (v47 + BeginOperandIndex > OperandNumber)
                          {
                            v37 = *(*(v40 + v41 - 1) + 8) & 0xFFFFFFFFFFFFFFF8;
                            if (*(*v37 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
                            {
                              *(v43 + v24++) = v37;
                            }
                          }
                        }
                      }

                      v26 += 4;
                      v25 -= 32;
                    }

                    while (v25);
                    v21 = v39[0];
                  }
                }
              }

              mlir::ValueRange::ValueRange(&v48, v43, v44);
              mlir::ValueRange::ValueRange(&v46, v40, v41);
              mlir::clone((a4 + 8), v21, v48, v49, v46, v47);
            }
          }
        }

        v9 += 4;
        v8 -= 32;
      }

      while (v8);
    }
  }

  return 0;
}

void mlir::OpBuilder::create<mlir::tensor::EmptyOp,llvm::SmallVector<mlir::OpFoldResult,6u> &,mlir::Type>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.empty";
  *(a2 + 24) = 12;
}

void mlir::tensor::ConcatOp::verify(uint64_t *a1, BOOL *a2)
{
  v22 = *MEMORY[0x1E69E9840];
  v11 = "requires at least one input";
  v12 = 259;
  mlir::OpState::emitOpError(a1, &v11, v13);
  *a2 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v13);
  if (v13[0])
  {
    mlir::InFlightDiagnostic::report(v13);
  }

  if (v21 == 1)
  {
    if (v20 != &v21)
    {
      free(v20);
    }

    v3 = __p;
    if (__p)
    {
      v4 = v19;
      v5 = __p;
      if (v19 != __p)
      {
        do
        {
          v4 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v4 - 1);
        }

        while (v4 != v3);
        v5 = __p;
      }

      v19 = v3;
      operator delete(v5);
    }

    v6 = v16;
    if (v16)
    {
      v7 = v17;
      v8 = v16;
      if (v17 != v16)
      {
        do
        {
          v10 = *--v7;
          v9 = v10;
          *v7 = 0;
          if (v10)
          {
            operator delete[](v9);
          }
        }

        while (v7 != v6);
        v8 = v16;
      }

      v17 = v6;
      operator delete(v8);
    }

    if (v14 != &v15)
    {
      free(v14);
    }
  }
}

void mlir::tensor::DimOp::fold(uint64_t a1, mlir::IntegerAttr *a2, uint64_t *a3)
{
  OUTLINED_FUNCTION_14_10(a1);
  OUTLINED_FUNCTION_110_1();
  v25 = v6;
  if ((*(a1 + 46) & 0x80) != 0)
  {
    v7 = *(a1 + 72);
  }

  else
  {
    v7 = 0;
  }

  Value = mlir::ArrayAttr::getValue(&v25);
  v10 = v9;
  Int = mlir::IntegerAttr::getInt(a2);
  if (v10 >= Int)
  {
    v12 = Int;
  }

  else
  {
    v12 = v10;
  }

  if (!v12)
  {
    v13 = 0;
    goto LABEL_17;
  }

  if (((v12 - 1) & 0x1FFFFFFFFFFFFFFFLL) > 2)
  {
    v15 = Value + 16;
    v16 = 0uLL;
    v17 = vnegq_f64(0);
    v18.i64[0] = 0;
    do
    {
      *v16.i64 = OUTLINED_FUNCTION_40_4(v16, v17, *v18.i64, *(v15 - 16));
      v15 = v21 + 32;
    }

    while (v22 != 4);
    v13 = vaddvq_s64(vaddq_s64(v18, v16));
    if (v19 == v20)
    {
      goto LABEL_17;
    }
  }

  else
  {
    v13 = 0;
    v14 = Value;
  }

  v23 = (Value + 8 * v12);
  do
  {
    v24 = *v14++;
    if (v24 == 0x8000000000000000)
    {
      ++v13;
    }
  }

  while (v14 != v23);
LABEL_17:
  *a3 = *(v7 + 32 * v13 + 24) | 4;
}

void mlir::tensor::ExpandShapeOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_95_4(v2);
  }
}

void mlir::tensor::CollapseShapeOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_155_2(v2);
  }
}

void mlir::tensor::ExtractSliceOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_75_5(v2);
  }
}

void mlir::tensor::InsertSliceOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_62_3(v2);
  }
}

void mlir::tensor::PadOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_74_4(v2);
  }
}

void mlir::tensor::ParallelInsertSliceOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_76_4(v2);
  }
}

void mlir::tensor::PackOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_65_5(v2);
  }
}

void mlir::OpBuilder::create<mlir::tensor::PackOp,mlir::Value &,mlir::Value &,llvm::ArrayRef<long long>,llvm::SmallVector<mlir::OpFoldResult,6u>,mlir::Value,llvm::ArrayRef<long long>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.pack";
  *(a2 + 24) = 11;
}

void mlir::tensor::UnPackOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_73_2(v2);
  }
}

void mlir::OpBuilder::create<mlir::tensor::UnPackOp,mlir::Value &,mlir::Value &,llvm::ArrayRef<long long>,llvm::SmallVector<mlir::OpFoldResult,6u>,llvm::ArrayRef<long long>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.unpack";
  *(a2 + 24) = 13;
}

void mlir::tensor::ConcatOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::tensor::detail::ConcatOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_115_2(v2);
  }
}

uint64_t mlir::tensor::ConcatOp::verifyInvariantsImpl(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  OUTLINED_FUNCTION_14_10(a1);
  OUTLINED_FUNCTION_169();
  result = OUTLINED_FUNCTION_91_4("result", v4);
  *a3 = result & 1;
  return result;
}

uint64_t mlir::tensor::ExtractSliceOp::verifyInvariantsImpl()
{
  OUTLINED_FUNCTION_55_4();
  if ((v3 & 0x800000) != 0)
  {
    if (v2)
    {
      goto LABEL_3;
    }
  }

  else if (v2)
  {
LABEL_3:
    do
    {
      v4 = OUTLINED_FUNCTION_8_6();
      result = mlir::tensor::__mlir_ods_local_type_constraint_TensorOps3(v4, v5, v6, v7, 0);
      if ((result & 1) == 0)
      {
        goto LABEL_22;
      }

      OUTLINED_FUNCTION_57_1();
    }

    while (!v9);
  }

  mlir::memref::ReinterpretCastOp::getODSOperands(v1, 1u);
  if (v10)
  {
    OUTLINED_FUNCTION_123_0();
    do
    {
      v11 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v11, v12, v13, v14, v2);
      if ((result & 1) == 0)
      {
        goto LABEL_22;
      }

      OUTLINED_FUNCTION_55_1();
    }

    while (!v9);
  }

  mlir::memref::ReinterpretCastOp::getODSOperands(v1, 2u);
  if (v15)
  {
    OUTLINED_FUNCTION_123_0();
    do
    {
      v16 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v16, v17, v18, v19, v2);
      if ((result & 1) == 0)
      {
        goto LABEL_22;
      }

      OUTLINED_FUNCTION_55_1();
    }

    while (!v9);
  }

  mlir::memref::ReinterpretCastOp::getODSOperands(v1, 3u);
  if (v20)
  {
    OUTLINED_FUNCTION_123_0();
    while (1)
    {
      v21 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v21, v22, v23, v24, v2);
      if ((result & 1) == 0)
      {
        break;
      }

      OUTLINED_FUNCTION_55_1();
      if (v9)
      {
        goto LABEL_21;
      }
    }

LABEL_22:
    v26 = 0;
    goto LABEL_23;
  }

LABEL_21:
  OUTLINED_FUNCTION_28_4(*v1);
  OUTLINED_FUNCTION_169();
  result = OUTLINED_FUNCTION_91_4("result", v25);
  v26 = result & 1;
LABEL_23:
  *v0 = v26;
  return result;
}

void mlir::tensor::GatherOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_97_2(v2);
  }
}

uint64_t mlir::tensor::InsertOp::verifyInvariantsImpl(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  while (1)
  {
    v6 = OUTLINED_FUNCTION_8_6();
    if ((mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v6, v7, v8, v9, 2u) & 1) == 0)
    {
      break;
    }

    OUTLINED_FUNCTION_57_1();
    if (v10)
    {
      result = 0;
      *a4 = *a2;
      return result;
    }
  }

  return 1;
}

uint64_t mlir::tensor::PadOp::verifyInvariantsImpl()
{
  OUTLINED_FUNCTION_55_4();
  if ((v3 & 0x800000) != 0)
  {
    if (v2)
    {
      goto LABEL_3;
    }
  }

  else if (v2)
  {
LABEL_3:
    do
    {
      v4 = OUTLINED_FUNCTION_8_6();
      result = mlir::tensor::__mlir_ods_local_type_constraint_TensorOps3(v4, v5, v6, v7, 0);
      if ((result & 1) == 0)
      {
        goto LABEL_18;
      }

      OUTLINED_FUNCTION_57_1();
    }

    while (!v9);
  }

  mlir::memref::ReinterpretCastOp::getODSOperands(v1, 1u);
  if (v10)
  {
    OUTLINED_FUNCTION_123_0();
    do
    {
      v11 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v11, v12, v13, v14, v2);
      if ((result & 1) == 0)
      {
        goto LABEL_18;
      }

      OUTLINED_FUNCTION_55_1();
    }

    while (!v9);
  }

  mlir::memref::ReinterpretCastOp::getODSOperands(v1, 2u);
  if (v15)
  {
    OUTLINED_FUNCTION_123_0();
    do
    {
      v16 = OUTLINED_FUNCTION_8_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v16, v17, v18, v19, v2);
      if ((result & 1) == 0)
      {
        goto LABEL_18;
      }

      OUTLINED_FUNCTION_55_1();
    }

    while (!v9);
  }

  OUTLINED_FUNCTION_28_4(*v1);
  OUTLINED_FUNCTION_169();
  result = OUTLINED_FUNCTION_91_4("result", v20);
  if ((result & 1) == 0)
  {
LABEL_18:
    v24 = 0;
    goto LABEL_19;
  }

  OUTLINED_FUNCTION_10_14();
  result = mlir::scf::__mlir_ods_local_region_constraint_SCFOps2(v23, v21 + 32 * v22, "region", 6, 0);
  v24 = result & 1;
LABEL_19:
  *v0 = v24;
  return result;
}

uint64_t mlir::tensor::ParallelInsertSliceOp::verifyInvariantsImpl()
{
  OUTLINED_FUNCTION_55_4();
  if ((v6 & 0x800000) != 0)
  {
    v7 = *(v5 + 72);
    if (v2)
    {
      goto LABEL_3;
    }
  }

  else
  {
    v7 = 0;
    if (v2)
    {
LABEL_3:
      v3 = 0;
      v4 = v7 + 24;
      do
      {
        v8 = OUTLINED_FUNCTION_8_6();
        result = mlir::tensor::__mlir_ods_local_type_constraint_TensorOps3(v8, v9, v10, v11, 0);
        if ((result & 1) == 0)
        {
          goto LABEL_27;
        }

        OUTLINED_FUNCTION_57_1();
      }

      while (!v13);
    }
  }

  mlir::memref::ReinterpretCastOp::getODSOperands(v1, 1u);
  if (v14)
  {
    OUTLINED_FUNCTION_123_0();
    while (1)
    {
      v15 = OUTLINED_FUNCTION_8_6();
      result = mlir::tensor::__mlir_ods_local_type_constraint_TensorOps3(v15, v16, v17, v18, v2);
      if ((result & 1) == 0)
      {
        break;
      }

      OUTLINED_FUNCTION_55_1();
      if (v13)
      {
        goto LABEL_12;
      }
    }
  }

  else
  {
LABEL_12:
    mlir::memref::ReinterpretCastOp::getODSOperands(v1, 2u);
    if (v19)
    {
      OUTLINED_FUNCTION_123_0();
      while (1)
      {
        v20 = OUTLINED_FUNCTION_8_6();
        result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v20, v21, v22, v23, v2);
        if ((result & 1) == 0)
        {
          break;
        }

        OUTLINED_FUNCTION_55_1();
        if (v13)
        {
          goto LABEL_17;
        }
      }
    }

    else
    {
LABEL_17:
      mlir::memref::ReinterpretCastOp::getODSOperands(v1, 3u);
      if (v24)
      {
        OUTLINED_FUNCTION_123_0();
        while (1)
        {
          v25 = OUTLINED_FUNCTION_8_6();
          result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v25, v26, v27, v28, v2);
          if ((result & 1) == 0)
          {
            break;
          }

          OUTLINED_FUNCTION_55_1();
          if (v13)
          {
            goto LABEL_22;
          }
        }
      }

      else
      {
LABEL_22:
        result = mlir::memref::ReinterpretCastOp::getODSOperands(v1, 4u);
        if (!v29)
        {
          v34 = 1;
          goto LABEL_28;
        }

        OUTLINED_FUNCTION_123_0();
        while (1)
        {
          v30 = OUTLINED_FUNCTION_8_6();
          result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v30, v31, v32, v33, v2);
          if ((result & 1) == 0)
          {
            break;
          }

          ++v2;
          v4 += 32;
          v34 = 1;
          if (!--v3)
          {
            goto LABEL_28;
          }
        }
      }
    }
  }

LABEL_27:
  v34 = 0;
LABEL_28:
  *v0 = v34;
  return result;
}

void mlir::tensor::ScatterOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_96_3(v2);
  }
}

void *mlir::tensor::SplatOp::print(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  OUTLINED_FUNCTION_9_2();
  (*(*v5 + 16))(v5);
  OUTLINED_FUNCTION_17_2();
  if (v8)
  {
    llvm::raw_ostream::write(v6, "[", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v6, v7);
  }

  v9 = *a3;
  if ((*(*a3 + 46) & 0x80) != 0)
  {
    v10 = *(v9 + 72);
    v11 = *(v9 + 68) - 1;
  }

  else
  {
    v10 = 0;
    v11 = -1;
  }

  (*(*v3 + 16))(v3);
  if (v11)
  {
    (*(*v3 + 160))(v3, *(v10 + 56));
    v12 = v11 - 1;
    if (v12)
    {
      v13 = (v10 + 88);
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v8 & v15)
        {
          OUTLINED_FUNCTION_21_5(v14);
        }

        else
        {
          OUTLINED_FUNCTION_42_0();
        }

        v16 = *v13;
        v13 += 4;
        (*(*v3 + 160))(v3, v16);
        --v12;
      }

      while (v12);
    }
  }

  (*(*v3 + 16))(v3);
  OUTLINED_FUNCTION_17_2();
  if (!v8)
  {
    return OUTLINED_FUNCTION_4_1(v17, v18);
  }

  return llvm::raw_ostream::write(v17, "]", 1uLL);
}

void mlir::OpInterface<mlir::ParallelCombiningOpInterface,mlir::detail::ParallelCombiningOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::ParallelCombiningOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ParallelCombiningOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::DestinationStyleOpInterface,mlir::detail::DestinationStyleOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::DestinationStyleOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_169_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::DestinationStyleOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_169_0(v2);
  }
}

void mlir::OpBuilder::create<mlir::tensor::BitcastOp,mlir::TensorType &,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.bitcast";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::tensor::ExtractSliceOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,4u>,llvm::SmallVector<mlir::OpFoldResult,4u>&,llvm::SmallVector<mlir::OpFoldResult,4u>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.extract_slice";
  *(a2 + 24) = 20;
}

void mlir::OpBuilder::create<mlir::tensor::GenerateOp,mlir::RankedTensorType &,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.generate";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::tensor::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::TensorType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.expand_shape";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::tensor::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::TensorType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.collapse_shape";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::tensor::SplatOp,mlir::RankedTensorType,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.splat";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::affine::AffineApplyOp,mlir::AffineExpr,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "affine.apply";
  *(a2 + 24) = 12;
}

void anonymous namespace::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp>::matchAndRewrite(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26)
{
  OUTLINED_FUNCTION_151();
  a25 = v31;
  a26 = v32;
  OUTLINED_FUNCTION_147_0();
  v33 = 0;
  a16 = *MEMORY[0x1E69E9840];
  do
  {
    mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes(v28, &a10);
    mlir::getConstantIntValue(a10[v33]);
    OUTLINED_FUNCTION_153_2();
    if (a10 != &a12)
    {
      free(a10);
    }

    if (v30)
    {
      if (v29 < 0)
      {
        break;
      }

      *(*v27 + 8 * v33) = v29;
    }

    ++v33;
    mlir::ArrayAttr::getValue(v26);
  }

  while (v33 < v34);
  OUTLINED_FUNCTION_149();
}

void mlir::OpBuilder::create<mlir::tensor::PadOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>,mlir::OperandRange,mlir::OperandRange,BOOL,llvm::SmallVector<mlir::NamedAttribute,3u>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.pad";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::tensor::ParallelInsertSliceOp,mlir::Value &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "tensor.parallel_insert_slice";
  *(a2 + 24) = 28;
}

void mlir::MemoryEffectOpInterface::onlyHasEffect<mlir::MemoryEffects::Read>()
{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffects::Read>();
    mlir::detail::TypeIDResolver<mlir::MemoryEffects::Read,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::AnalysisMap::getAnalysisImpl<mlir::DominanceInfo,mlir::Operation *>()
{
  {
    v0 = llvm::getTypeName<mlir::DominanceInfo>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_0_15(v2);
  }
}

void mlir::detail::PreservedAnalyses::preserve<mlir::PostDominanceInfo>()
{
  {
    v0 = llvm::getTypeName<mlir::PostDominanceInfo>();
    mlir::detail::TypeIDResolver<mlir::PostDominanceInfo,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void anonymous namespace::InlinerPass::runOnOperation()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SymbolTable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SymbolTable>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SymbolTable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SymbolTable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::AnalysisMap::getAnalysisImpl<mlir::CallGraph,mlir::Operation *>()
{
  {
    v0 = llvm::getTypeName<mlir::CallGraph>();
    mlir::detail::TypeIDResolver<mlir::CallGraph,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::ConversionPattern::matchAndRewrite(mlir::ConversionPattern *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v17[4] = *MEMORY[0x1E69E9840];
  v6 = *(a3 + 5);
  v7 = v6[43];
  v6[43] = *(this + 12);
  v15 = v17;
  v16 = 0x400000000;
  v8 = *(a2 + 3);
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v9 = *(a2 + 9);
    v10 = *(a2 + 17);
  }

  else
  {
    v9 = 0;
    v10 = 0;
  }

  mlir::ValueRange::ValueRange(v14, v9, v10);
  if (mlir::detail::ConversionPatternRewriterImpl::remapValues(v6, "operand", 7, v8, 1, v11, v14[0], v14[1], &v15))
  {
    v12 = (*(*this + 56))(this, a2, v15, v16, a3);
  }

  else
  {
    v12 = 0;
  }

  if (v15 != v17)
  {
    free(v15);
  }

  v6[43] = v7;
  return v12;
}

void mlir::reconcileUnrealizedCasts(llvm::ArrayRef<mlir::UnrealizedConversionCastOp>,llvm::SmallVectorImpl<mlir::UnrealizedConversionCastOp> *)::$_0::operator()(uint64_t *a1, uint64_t a2)
{
  v17 = a2;
  ODSOperandIndexAndLength = mlir::UnrealizedConversionCastOp::getODSOperandIndexAndLength(&v17, 0);
  if ((*(v17 + 46) & 0x80) != 0)
  {
    v4 = *(v17 + 72);
  }

  else
  {
    v4 = 0;
  }

  v5 = (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength);
  v6 = v5 - ODSOperandIndexAndLength;
  if (v5 != ODSOperandIndexAndLength)
  {
    v7 = (v4 + 32 * ODSOperandIndexAndLength + 24);
    do
    {
      v16 = *v7;
      DefiningOp = mlir::Value::getDefiningOp(&v16);
      if (DefiningOp)
      {
        v9 = *(*(DefiningOp + 48) + 16);
        v10 = v9 == &mlir::detail::TypeIDResolver<mlir::UnrealizedConversionCastOp,void>::id;
        v11 = v9 == &mlir::detail::TypeIDResolver<mlir::UnrealizedConversionCastOp,void>::id ? DefiningOp : 0;
        v15 = v11;
        if (v10)
        {
          v12 = *a1;
          llvm::DenseMapBase<llvm::DenseMap<mlir::func::FuncOp,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::func::FuncOp,void>,llvm::detail::DenseSetPair<mlir::func::FuncOp>>,mlir::func::FuncOp,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::func::FuncOp,void>,llvm::detail::DenseSetPair<mlir::func::FuncOp>>::try_emplace<llvm::detail::DenseSetEmpty&>(*a1, &v15, v18);
          if (v18[16] == 1)
          {
            v13 = v15;
            v14 = *(v12 + 32);
            if (v14 >= *(v12 + 36))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(v12 + 24, v12 + 40, v14 + 1, 8);
              v14 = *(v12 + 32);
            }

            *(*(v12 + 24) + 8 * v14) = v13;
            ++*(v12 + 32);
          }
        }
      }

      v7 += 4;
      --v6;
    }

    while (v6);
  }
}

BOOL mlir::TypeConverter::isLegal(mlir::TypeConverter *this, mlir::Operation *a2)
{
  v28[1] = *MEMORY[0x1E69E9840];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v4 = *(a2 + 9);
    v5 = *(a2 + 17);
  }

  else
  {
    v4 = 0;
    v5 = 0;
  }

  v22 = v4;
  v23 = v5;
  mlir::OperandRange::getTypes(&v22, &v19);
  v6 = v21 - v20;
  if (v21 == v20)
  {
LABEL_12:
    v10 = *(a2 + 9);
    v11 = a2 - 16;
    if (!v10)
    {
      v11 = 0;
    }

    v26 = v11;
    v27 = v10;
    mlir::OperandRange::getTypes(&v26, &v22);
    v12 = v23;
    if (v23 == v25)
    {
      return 1;
    }

    else
    {
      v14 = v22;
      v15 = v25 - 1;
      do
      {
        v16 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v14, v12) + 8) & 0xFFFFFFFFFFFFFFF8);
        v26 = v28;
        v27 = 0x100000000;
        v17 = 0;
        if (mlir::TypeConverter::convertType(this, v16, &v26) && v27 == 1)
        {
          v17 = *v26;
        }

        if (v26 != v28)
        {
          free(v26);
        }

        result = v17 == v16;
      }

      while (v17 == v16 && v15 != v12++);
    }
  }

  else
  {
    v7 = v19 + 32 * v20 + 24;
    while (1)
    {
      v8 = (*(*v7 + 8) & 0xFFFFFFFFFFFFFFF8);
      v22 = &v24;
      v23 = 0x100000000;
      v9 = 0;
      if (mlir::TypeConverter::convertType(this, v8, &v22) && v23 == 1)
      {
        v9 = *v22;
      }

      if (v22 != &v24)
      {
        free(v22);
      }

      if (v9 != v8)
      {
        return 0;
      }

      v7 += 32;
      if (!--v6)
      {
        goto LABEL_12;
      }
    }
  }

  return result;
}

void anonymous namespace::UnresolvedMaterializationRewrite::rollback(_anonymous_namespace_::UnresolvedMaterializationRewrite *this)
{
  v1 = *(this + 3);
  if ((*(this + 4) & 6) == 2 && (*(v1 + 46) & 0x80) != 0)
  {
    v2 = *(v1 + 68);
    if (v2)
    {
      v3 = *(this + 2);
      v4 = v3[15].i32[0];
      if (v4)
      {
        v5 = 0;
        v6 = *(v1 + 72);
        v7 = v3[13];
        v8 = v4 - 1;
        do
        {
          v9 = *(v6 + 32 * v5 + 24);
          v10 = 0x9DDFEA08EB382D69 * ((8 * v9 - 0xAE502812AA7333) ^ HIDWORD(v9));
          v11 = 0x9DDFEA08EB382D69 * (HIDWORD(v9) ^ (v10 >> 47) ^ v10);
          v12 = (-348639895 * ((v11 >> 47) ^ v11)) & v8;
          v13 = *(*&v7 + 16 * v12);
          if (v13 == v9)
          {
LABEL_7:
            *(*&v7 + 16 * v12) = -8192;
            v3[14] = vadd_s32(v3[14], 0x1FFFFFFFFLL);
          }

          else
          {
            v14 = 1;
            while (v13 != -4096)
            {
              v15 = v12 + v14++;
              v12 = v15 & v8;
              v13 = *(*&v7 + 16 * v12);
              if (v13 == v9)
              {
                goto LABEL_7;
              }
            }
          }

          ++v5;
        }

        while (v5 != v2);
      }
    }
  }

  v16 = *(this + 2);
  v17 = v16[42].i32[0];
  if (v17)
  {
    v18 = v16[40];
    v19 = 0x9DDFEA08EB382D69 * ((8 * v1 - 0xAE502812AA7333) ^ HIDWORD(v1));
    v20 = 0x9DDFEA08EB382D69 * (HIDWORD(v1) ^ (v19 >> 47) ^ v19);
    LODWORD(v19) = -348639895 * ((v20 >> 47) ^ v20);
    v21 = v17 - 1;
    v22 = v19 & (v17 - 1);
    v23 = *(*&v18 + 16 * v22);
    if (v23 == v1)
    {
LABEL_16:
      *(*&v18 + 16 * v22) = -8192;
      v16[41] = vadd_s32(v16[41], 0x1FFFFFFFFLL);
      v1 = *(this + 3);
    }

    else
    {
      v24 = 1;
      while (v23 != -4096)
      {
        v25 = v22 + v24++;
        v22 = v25 & v21;
        v23 = *(*&v18 + 16 * v22);
        if (v23 == v1)
        {
          goto LABEL_16;
        }
      }
    }
  }

  mlir::Operation::erase(v1);
}

uint64_t mlir::reconcileUnrealizedCasts(mlir::UnrealizedConversionCastOp *a1, mlir::UnrealizedConversionCastOp *a2, void *a3)
{
  ODSResultIndexAndLength = mlir::UnrealizedConversionCastOp::getODSResultIndexAndLength(a1, 0);
  v7 = ODSResultIndexAndLength;
  if (*(*a1 + 36))
  {
    NextResultAtOffset = *a1 - 16;
  }

  else
  {
    NextResultAtOffset = 0;
  }

  v9 = ODSResultIndexAndLength;
  if (ODSResultIndexAndLength)
  {
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, ODSResultIndexAndLength);
  }

  v10 = (HIDWORD(v7) + v7);
  v11 = v10 - v7;
  ODSOperandIndexAndLength = mlir::UnrealizedConversionCastOp::getODSOperandIndexAndLength(a2, 0);
  if ((*(*a2 + 46) & 0x80) != 0)
  {
    v13 = *(*a2 + 72);
  }

  else
  {
    v13 = 0;
  }

  if (v11 != (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength) - ODSOperandIndexAndLength)
  {
    return 0;
  }

  if (v10 != v9)
  {
    v14 = 0;
    v15 = (v13 + 32 * ODSOperandIndexAndLength + 24);
    while (mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, v14) == *v15)
    {
      ++v14;
      v15 += 4;
      if (v11 == v14)
      {
        goto LABEL_13;
      }
    }

    return 0;
  }

LABEL_13:
  v16 = *a1;
  *a3 = *a1;
  if (v16)
  {
    return 2;
  }

  else
  {
    return 1;
  }
}

void mlir::OpBuilder::create<mlir::UnrealizedConversionCastOp,mlir::Type &,mlir::ValueRange &>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "builtin.unrealized_conversion_cast";
  *(a2 + 24) = 34;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

unint64_t getInsertionRegion(mlir::detail::DialectInterfaceCollectionBase *a1, mlir::Block *this)
{
  for (i = mlir::Block::getParent(this); i; i = mlir::Block::getParent(*(v4 + 16)))
  {
    v4 = *(i + 16);
    {
      v7 = llvm::getTypeName<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>>();
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v7, v8);
    }

    v5 = *(v4 + 48);
    if (v5[2] == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      break;
    }

    if ((*(*v5 + 4))(v5, mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID(void)::id))
    {
      break;
    }

    if (!*(v4 + 16))
    {
      break;
    }

    InterfaceFor = mlir::detail::DialectInterfaceCollectionBase::getInterfaceFor(a1, v4);
    if (InterfaceFor)
    {
      if ((*(*InterfaceFor + 24))(InterfaceFor, i))
      {
        break;
      }
    }
  }

  return i;
}

void anonymous namespace::GreedyPatternRewriteDriver::notifyOperationErased(int32x2_t *this, mlir::Operation *a2)
{
  v4 = this[18];
  if (v4)
  {
    (*(**&v4 + 64))(v4, a2);
  }

  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 17);
    if (v5)
    {
      v6 = 0;
      v7 = *(a2 + 9);
      do
      {
        v29 = *(v7 + 32 * v6 + 24);
        if (v29)
        {
          DefiningOp = mlir::Value::getDefiningOp(&v29);
          if (DefiningOp)
          {
            v9 = *v29;
            if (*v29)
            {
              v10 = 0;
              do
              {
                v11 = v9[2];
                if (v11 == a2 || v11 == v10)
                {
                  v11 = v10;
                }

                else if (v10)
                {
                  goto LABEL_19;
                }

                v9 = *v9;
                v10 = v11;
              }

              while (v9);
            }
          }
        }

LABEL_19:
        ++v6;
      }

      while (v6 != v5);
    }
  }

  v13 = this[12].u32[0];
  v14 = a2 >> 4;
  if (v13)
  {
    v15 = this[10];
    v16 = (v13 - 1) & (v14 ^ (a2 >> 9));
    v17 = *(*&v15 + 16 * v16);
    if (v17 == a2)
    {
LABEL_22:
      if (v16 != v13)
      {
        v18 = *&v15 + 16 * v16;
        *(*&this[7] + 8 * *(v18 + 8)) = 0;
        *v18 = -8192;
        this[11] = vadd_s32(this[11], 0x1FFFFFFFFLL);
      }
    }

    else
    {
      v25 = 1;
      while (v17 != -4096)
      {
        v26 = v16 + v25++;
        v16 = v26 & (v13 - 1);
        v17 = *(*&v15 + 16 * v16);
        if (v17 == a2)
        {
          goto LABEL_22;
        }
      }
    }
  }

  if (this[17].i32[0])
  {
    if (this[19].i8[0])
    {
      v20 = this + 20;
      v19 = 4;
    }

    else
    {
      v19 = this[21].i32[0];
      if (!v19)
      {
        return;
      }

      v20 = this[20];
    }

    v21 = v19 - 1;
    v22 = v21 & (v14 ^ (a2 >> 9));
    v23 = v20[v22];
    if (v23 == a2)
    {
LABEL_30:
      v20[v22] = -8192;
      v24 = this[19].i32[1] + 1;
      this[19].i32[0] -= 2;
      this[19].i32[1] = v24;
    }

    else
    {
      v27 = 1;
      while (v23 != -4096)
      {
        v28 = v22 + v27++;
        v22 = v28 & v21;
        v23 = v20[v22];
        if (v23 == a2)
        {
          goto LABEL_30;
        }
      }
    }
  }
}

void anonymous namespace::MultiOpPatternRewriteDriver::notifyOperationErased(int32x2_t *this, mlir::Operation *a2)
{
  v4 = this[32];
  if (v4)
  {
    v5 = *&v4 + 8;
    if (**&v4)
    {
      v6 = 4;
    }

    else
    {
      v6 = *(*&v4 + 16);
      if (!v6)
      {
        return;
      }

      v5 = *(*&v4 + 8);
    }

    v7 = v6 - 1;
    v8 = (v6 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    v9 = *(v5 + 8 * v8);
    if (v9 == a2)
    {
LABEL_7:
      *(v5 + 8 * v8) = -8192;
      v10 = *(*&v4 + 4) + 1;
      **&v4 -= 2;
      *(*&v4 + 4) = v10;
    }

    else
    {
      v11 = 1;
      while (v9 != -4096)
      {
        v12 = v8 + v11++;
        v8 = v12 & v7;
        v9 = *(v5 + 8 * v8);
        if (v9 == a2)
        {
          goto LABEL_7;
        }
      }
    }
  }
}

uint64_t **llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<remapInlinedOperands(llvm::iterator_range<llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Block,false,false,void,false,void>,false,false>>,mlir::IRMapping &)::$_0>(uint64_t **result, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 68);
    if (v2)
    {
      v3 = *(*result + 4);
      if (v3)
      {
        v4 = *(a2 + 72);
        v5 = &v4[4 * v2];
        v6 = **result;
        v7 = v3 - 1;
        do
        {
          v8 = v4[3];
          v9 = 0x9DDFEA08EB382D69 * ((8 * v8 - 0xAE502812AA7333) ^ HIDWORD(v8));
          v10 = 0x9DDFEA08EB382D69 * (HIDWORD(v8) ^ (v9 >> 47) ^ v9);
          v11 = (-348639895 * ((v10 >> 47) ^ v10)) & v7;
          result = *(v6 + 16 * v11);
          if (result == v8)
          {
LABEL_6:
            if (v11 != v3)
            {
              v12 = *(v6 + 16 * v11 + 8);
              if (v12)
              {
                v13 = v4[1];
                if (v13)
                {
                  result = *v4;
                  *v13 = *v4;
                  if (result)
                  {
                    result[1] = v13;
                  }
                }

                v4[3] = v12;
                v14 = *v12;
                *v4 = *v12;
                v4[1] = v12;
                if (v14)
                {
                  *(v14 + 8) = v4;
                }

                *v12 = v4;
              }
            }
          }

          else
          {
            v15 = 1;
            while (result != -4096)
            {
              v16 = v11 + v15++;
              v11 = v16 & v7;
              result = *(v6 + 16 * v11);
              if (result == v8)
              {
                goto LABEL_6;
              }
            }
          }

          v4 += 4;
        }

        while (v4 != v5);
      }
    }
  }

  return result;
}

void mlir::OpBuilder::create<mlir::anec::UnrealizedConversionCast,mlir::Type &,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.unrealized_conversion_cast";
  *(a2 + 24) = 31;
}

void mlir::OpInterface<mlir::silc::BufferizationInterface,mlir::silc::detail::BufferizationInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::silc::BufferizationInterface>();
    mlir::detail::TypeIDResolver<mlir::silc::BufferizationInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::silc::BufferizationInterface>();
    mlir::detail::TypeIDResolver<mlir::silc::BufferizationInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL,BOOL)::{lambda(mlir::Operation *)#1}::operator()()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_3_16(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::anec::VerifyAttributesWithFamilyInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::VerifyAttributesWithFamilyInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::anec::VerifyAttributesWithFamilyInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::VerifyAttributesWithFamilyInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::SupportConstantOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::anec::SupportConstantOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::ConstantFoldable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::anec::ConstantFoldable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::anec::VerifyAttributesWithFamilyInterface,mlir::anec::detail::VerifyAttributesWithFamilyInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::anec::VerifyAttributesWithFamilyInterface>();
    mlir::detail::TypeIDResolver<mlir::anec::VerifyAttributesWithFamilyInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::anec::VerifyAttributesWithFamilyInterface>();
    mlir::detail::TypeIDResolver<mlir::anec::VerifyAttributesWithFamilyInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZNS1_12_GLOBAL__N_19MPSToANEC12assignIOAttrEvENK3__0clENS1_4func6FuncOpEEUlNS1_9placement10RegionCallEE_SI_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESR_E4typeES4_OT1_EUlS4_E_EES2_lS4__cold_1()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_3_16(v2);
  }
}

void mlir::OpBuilder::create<mlir::anec::A12,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.A12";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::A13,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.A13";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::A14,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.A14";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::A15,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.A15";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::A16,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.A16";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::A17,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.A17";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::A18,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.A18";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::A11Legacy,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.A11Legacy";
  *(a2 + 24) = 14;
}

void mlir::getExtraSerializationDialectsForANEC()
{
  v0[6] = *MEMORY[0x1E69E9840];
  if (__cxa_guard_acquire(&_MergedGlobals_47))
  {
    v0[0] = &mlir::detail::TypeIDResolver<mlir::mpsx::MPSXDialect,void>::id;
    v0[1] = "mpsx";
    v0[2] = 4;
    v0[3] = &mlir::detail::TypeIDResolver<mlir::mps_spi::MPSSPIDialect,void>::id;
    v0[4] = "mps_spi";
    v0[5] = 7;
    llvm::SmallVector<mlir::mps::DialectInfo,2u>::SmallVector(&qword_1EE17C9E0, v0, 2);
    __cxa_atexit(llvm::SmallVector<mlir::mps::DialectInfo,2u>::~SmallVector, &qword_1EE17C9E0, &dword_1DF9BF000);
    __cxa_guard_release(&_MergedGlobals_47);
  }
}

uint64_t mlir::matchValueTypeThrough<mlir::BlockArgument,mlir::UnrealizedConversionCastOp>(uint64_t a1)
{
  v7 = a1;
  if (a1 && (~*(a1 + 8) & 7) == 0)
  {
    return 1;
  }

  result = mlir::Value::getDefiningOp(&v7);
  if (result)
  {
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::UnrealizedConversionCastOp,void>::id && (*(result + 46) & 0x80) != 0 && (v2 = *(result + 68), v2))
    {
      v3 = v2 - 1;
      v4 = (*(result + 72) + 24);
      do
      {
        v5 = v3;
        v6 = *v4;
        v4 += 4;
        result = mlir::matchValueTypeThrough<mlir::BlockArgument,mlir::UnrealizedConversionCastOp>(v6);
        if (result)
        {
          break;
        }

        v3 = v5 - 1;
      }

      while (v5);
    }

    else
    {
      return 0;
    }
  }

  return result;
}

uint64_t mlir::matchThrough<mlir::anec::TensorBufferToTensor,mlir::UnrealizedConversionCastOp>(uint64_t result, uint64_t *a2)
{
  if (result)
  {
    v3 = *(*(result + 48) + 16);
    if (a2 && v3 == &mlir::detail::TypeIDResolver<mlir::anec::TensorBufferToTensor,void>::id)
    {
      *a2 = result;
      return 1;
    }

    if (v3 == &mlir::detail::TypeIDResolver<mlir::anec::TensorBufferToTensor,void>::id)
    {
      return 1;
    }

    if (v3 == &mlir::detail::TypeIDResolver<mlir::UnrealizedConversionCastOp,void>::id && (*(result + 46) & 0x80) != 0 && (v4 = *(result + 68), v4))
    {
      v5 = v4 - 1;
      v6 = (*(result + 72) + 24);
      do
      {
        v7 = v5;
        v8 = *v6;
        v6 += 4;
        v10 = v8;
        DefiningOp = mlir::Value::getDefiningOp(&v10);
        result = mlir::matchThrough<mlir::anec::TensorBufferToTensor,mlir::UnrealizedConversionCastOp>(DefiningOp, a2);
        if (result)
        {
          break;
        }

        v5 = v7 - 1;
      }

      while (v7);
    }

    else
    {
      return 0;
    }
  }

  return result;
}

uint64_t mlir::detail::RecursivePatternMatcher<mlir::mps::DequantizeOp,mlir::detail::RecursivePatternMatcher<mlir::mps::QuantizeOp,mlir::detail::constant_op_matcher,mlir::detail::constant_op_matcher,mlir::detail::constant_op_matcher>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>>::match(mlir::Operation *)::{lambda(unsigned long,mlir::mps::DequantizeOp &)#1}::operator()<mlir::detail::RecursivePatternMatcher<mlir::mps::QuantizeOp,mlir::detail::constant_op_matcher,mlir::detail::constant_op_matcher,mlir::detail::constant_op_matcher>>(uint64_t a1, unsigned int a2)
{
  v18 = *(*(**(a1 + 8) + 72) + 32 * a2 + 24);
  result = mlir::Value::getDefiningOp(&v18);
  if (result && (v4 = result, *(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::QuantizeOp,void>::id) && (*(result + 46) & 0x80) != 0 && *(result + 68) == 3)
  {
    v18 = *(*(result + 72) + 24);
    DefiningOp = mlir::Value::getDefiningOp(&v18);
    if (DefiningOp)
    {
      {
        v10 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
        mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v10, v11);
      }

      LOBYTE(DefiningOp) = (*(**(DefiningOp + 48) + 32))(*(DefiningOp + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id);
    }

    v18 = *(*(v4 + 72) + 56);
    v6 = mlir::Value::getDefiningOp(&v18);
    if (v6)
    {
      {
        v17 = v6;
        v6 = v17;
        if (v12)
        {
          v13 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
          mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v13, v14);
          v6 = v17;
        }
      }

      LOBYTE(v6) = (*(**(v6 + 48) + 32))(*(v6 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id);
    }

    v7 = DefiningOp & v6;
    v18 = *(*(v4 + 72) + 88);
    result = mlir::Value::getDefiningOp(&v18);
    if (result)
    {
      v8 = result;
      {
        v15 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
        mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v15, v16);
      }

      result = (*(**(v8 + 48) + 32))(*(v8 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id);
    }

    v9 = v7 & result;
  }

  else
  {
    v9 = 0;
  }

  **a1 &= v9;
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::PermuteOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeLUTOp,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>::match(uint64_t **a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *(a2 + 72);
  v5 = *(v4 + 24);
  v6 = **a1;
  if (v6)
  {
    v7 = v6 == v5;
  }

  else
  {
    **a1 = v5;
    v4 = *(a2 + 72);
    v7 = 1;
  }

  v8 = a1[1];
  v16 = *(v4 + 56);
  DefiningOp = mlir::Value::getDefiningOp(&v16);
  if (DefiningOp)
  {
    v14 = mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::PermuteOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeLUTOp,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(v8, DefiningOp);
  }

  else
  {
    v10 = *v8;
    v17 = v16;
    v11 = mlir::Value::getDefiningOp(&v17);
    v13 = v11;
    if (v11)
    {
      v20 = v11;
      if (*(*(v11 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeLUTOp,void>::id && (*(v11 + 46) & 0x80) != 0 && *(v11 + 68) == 2)
      {
        v19 = 1;
        v18[0] = &v19;
        v18[1] = &v20;
        mlir::detail::enumerateImpl<std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeLUTOp,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul>(v10, v18);
        v12 = v19;
        if (v19 == 1)
        {
          *(v10 + 16) = v20;
        }
      }

      else
      {
        v12 = 0;
      }
    }

    v14 = (v13 != 0) & v12;
  }

  if ((v7 & v14) != 1)
  {
    return 0;
  }

  a1[2] = a2;
  return 1;
}

uint64_t mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::PermuteOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeLUTOp,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(uint64_t *a1, uint64_t a2)
{
  v5 = *(*(a2 + 48) + 16);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id)
  {
    v6 = *a1;
    v16 = a2;
    if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeLUTOp,void>::id && (*(a2 + 46) & 0x80) != 0 && *(a2 + 68) == 2)
    {
      v15 = 1;
      v13 = &v15;
      v14 = &v16;
      mlir::detail::enumerateImpl<std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeLUTOp,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul>(v6, &v13);
      result = v15;
      if (v15 == 1)
      {
        *(v6 + 16) = v16;
      }

      return result;
    }

    return 0;
  }

  if ((*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v8 = *a1;
  v13 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v13);
  v10 = DefiningOp;
  if (DefiningOp)
  {
    v16 = DefiningOp;
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeLUTOp,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2)
    {
      v15 = 1;
      v13 = &v15;
      v14 = &v16;
      mlir::detail::enumerateImpl<std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeLUTOp,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul>(v8, &v13);
      v2 = v15;
      if (v15 == 1)
      {
        *(v8 + 16) = v16;
      }
    }

    else
    {
      v2 = 0;
    }
  }

  v11 = v10 != 0;
  v12 = a1[1];
  v13 = *(*(a2 + 72) + 56);
  result = mlir::Value::getDefiningOp(&v13);
  if (result)
  {
    if (*(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id || *v12 && *v12 != result)
    {
      return 0;
    }

    *v12 = result;
    if ((v11 & v2) == 0)
    {
      return 0;
    }

    if ((a1[3] & 1) == 0)
    {
      *(a1 + 24) = 1;
    }

    a1[2] = a2;
    return 1;
  }

  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeLUTOp,mlir::detail::op_matcher_with_bind<mlir::mps::ReadDataFromFileOp>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::op_matcher_with_bind<mlir::mps::ReadDataFromFileOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>::match(uint64_t a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeLUTOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v5 = *a1;
  v11[0] = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(v11);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReadDataFromFileOp,void>::id && (*v5 ? (v7 = *v5 == DefiningOp) : (v7 = 1), v7))
    {
      *v5 = DefiningOp;
      v2 = 1;
    }

    else
    {
      v2 = 0;
    }
  }

  v8 = DefiningOp != 0;
  v9 = *(a1 + 8);
  v11[0] = *(*(a2 + 72) + 56);
  result = mlir::Value::getDefiningOp(v11);
  if (result)
  {
    v13 = result;
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 2)
    {
      v12 = 1;
      v11[0] = &v12;
      v11[1] = &v13;
      mlir::detail::enumerateImpl<std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::ReadDataFromFileOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::op_matcher_with_bind<mlir::mps::ReadDataFromFileOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::ReadDataFromFileOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul>(v9, v11);
      if (v12)
      {
        *(v9 + 16) = v13;
        if ((v8 & v2) != 0)
        {
          *(a1 + 16) = a2;
          return 1;
        }
      }
    }

    return 0;
  }

  return result;
}

uint64_t mlir::anonymous namespace::ConvertPalettizedConvPatternToFusionOp::patternMatch(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v66 = 0;
  v67[0] = 0;
  v69 = 0;
  v65 = 0;
  v60 = &v66;
  v61 = &v65;
  v62 = 0;
  v53 = &v60;
  v54 = &v69;
  LOBYTE(v55) = 0;
  v56 = 0;
  v57 = v67;
  v58 = &v53;
  v59 = 0;
  if (mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::PermuteOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeLUTOp,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>::match(&v57, a2) && (OUTLINED_FUNCTION_41_7(v59, v5, v6, v7, v8, v9, v10, v11, v53, v54, v55, v56) & 1) != 0)
  {
    v12 = v65;
    v13 = v66;
    v14 = v62;
    if (v56 != 1)
    {
      OUTLINED_FUNCTION_40_5();
      if (v38 <= 3)
      {
        v39 = OUTLINED_FUNCTION_22_9();
        llvm::SmallVectorBase<unsigned int>::grow_pod(v39, v40, 4uLL, 8);
      }

      OUTLINED_FUNCTION_39_6();
      *v44 = v13;
      v44[1] = v12;
      v44[2] = v14;
      v42 = v44 + 3;
      v43 = 4;
      goto LABEL_20;
    }

    v15 = v69;
    v16 = v55;
    OUTLINED_FUNCTION_40_5();
    if (v17 <= 5)
    {
      v18 = OUTLINED_FUNCTION_22_9();
      llvm::SmallVectorBase<unsigned int>::grow_pod(v18, v19, 6uLL, 8);
    }

    OUTLINED_FUNCTION_39_6();
    *v41 = v13;
    v41[1] = v12;
    v41[2] = v14;
    v41[3] = v15;
    v41[4] = v16;
  }

  else
  {
    v65 = 0;
    v66 = 0;
    v63 = 0;
    v64 = 0;
    v60 = &v64;
    v61 = &v63;
    v62 = 0;
    v57 = &v65;
    v58 = &v60;
    v59 = 0;
    v53 = &v57;
    v54 = &v66;
    LOBYTE(v55) = 0;
    v56 = 0;
    v69 = a2;
    if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
    {
      return 0;
    }

    if ((*(a2 + 46) & 0x80) == 0)
    {
      return 0;
    }

    if (*(a2 + 68) != 2)
    {
      return 0;
    }

    v67[0] = &v68;
    v67[1] = &v69;
    v68 = 1;
    mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::PermuteOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeLUTOp,mlir::detail::op_matcher_with_bind<mlir::mps::ReadDataFromFileOp>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::op_matcher_with_bind<mlir::mps::ReadDataFromFileOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>::match(mlir::Operation *)::{lambda(unsigned long,mlir::mps::Conv2DOp *)#1}::operator()<mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::mps::PermuteOp,0,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeLUTOp,mlir::detail::op_matcher_with_bind<mlir::mps::ReadDataFromFileOp>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::op_matcher_with_bind<mlir::mps::ReadDataFromFileOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(v67, 1u, &v53);
    if ((v68 & 1) == 0 || (OUTLINED_FUNCTION_41_7(v69, v20, v21, v22, v23, v24, v25, v26, v53, v54, v55, v56) & 1) == 0)
    {
      return 0;
    }

    v27 = v64;
    v28 = v65;
    v29 = v62;
    v30 = v63;
    v31 = v59;
    if (v56 == 1)
    {
      v32 = v66;
      v33 = v55;
      OUTLINED_FUNCTION_40_5();
      if (v34 <= 7)
      {
        v35 = OUTLINED_FUNCTION_22_9();
        llvm::SmallVectorBase<unsigned int>::grow_pod(v35, v36, 8uLL, 8);
      }

      OUTLINED_FUNCTION_39_6();
      *v52 = v28;
      v52[1] = v27;
      v52[2] = v30;
      v52[3] = v29;
      v52[4] = v31;
      v52[5] = v32;
      v52[6] = v33;
      v42 = v52 + 7;
      v43 = 8;
      goto LABEL_20;
    }

    OUTLINED_FUNCTION_40_5();
    if (v49 <= 5)
    {
      v50 = OUTLINED_FUNCTION_22_9();
      llvm::SmallVectorBase<unsigned int>::grow_pod(v50, v51, 6uLL, 8);
    }

    OUTLINED_FUNCTION_39_6();
    *v41 = v28;
    v41[1] = v27;
    v41[2] = v30;
    v41[3] = v29;
    v41[4] = v31;
  }

  v42 = v41 + 5;
  v43 = 6;
LABEL_20:
  *v42 = a2;
  *(a3 + 136) += v43;
  v45 = *(*(a2 + 72) + 24);
  *(a3 + 8) = 0;
  if (*(a3 + 12))
  {
    v46 = 0;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, a3 + 16, 1uLL, 8);
    v46 = *(a3 + 8);
  }

  *(*a3 + 8 * v46) = v45;
  ++*(a3 + 8);
  v47 = a2 - 16;
  *(a3 + 72) = 0;
  if (*(a3 + 76))
  {
    v48 = 0;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3 + 64, a3 + 80, 1uLL, 8);
    v48 = *(a3 + 72);
  }

  *(*(a3 + 64) + 8 * v48) = v47;
  ++*(a3 + 72);
  return 1;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>::match(uint64_t **a1, uint64_t a2)
{
  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id || (*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *(a2 + 72);
  v5 = *(v4 + 24);
  v6 = **a1;
  if (v6)
  {
    v7 = v6 == v5;
  }

  else
  {
    **a1 = v5;
    v4 = *(a2 + 72);
    v7 = 1;
  }

  v8 = a1[1];
  v10[0] = *(v4 + 56);
  result = mlir::Value::getDefiningOp(v10);
  if (result)
  {
    v12 = result;
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 4)
    {
      v11 = 1;
      v10[0] = &v11;
      v10[1] = &v12;
      mlir::detail::enumerateImpl<std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul,2ul,3ul>(v8, v10);
      if (v11)
      {
        v8[4] = v12;
        if (v7)
        {
          a1[2] = a2;
          return 1;
        }
      }
    }

    return 0;
  }

  return result;
}

void mlir::anonymous namespace::fusionOpCreationUtils::addConcatForRingBufferPattern(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v4 = *(a2 + 68);
    if (v4)
    {
      v5 = 0;
      v6 = *(a2 + 72);
      v7 = &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id;
      while (1)
      {
        v39 = *(v6 + 32 * v5 + 24);
        if (mlir::matchValueTypeThrough<mlir::BlockArgument,mlir::UnrealizedConversionCastOp>(v39))
        {
          goto LABEL_13;
        }

        DefiningOp = mlir::Value::getDefiningOp(&v39);
        v9 = DefiningOp;
        if (*(*(DefiningOp + 48) + 16) == v7 && (*(DefiningOp + 46) & 0x80) != 0)
        {
          v15 = *(DefiningOp + 68);
          if (v15)
          {
            break;
          }
        }

LABEL_7:
        v40 = v9;
        if (!*(a1 + 256))
        {
          goto LABEL_10;
        }

        OUTLINED_FUNCTION_15_14();
        if (v12 != v9)
        {
          while (v12 != -4096)
          {
            OUTLINED_FUNCTION_10_15();
            if (v12 == v9)
            {
              goto LABEL_9;
            }
          }

LABEL_10:
          llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>,mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>::try_emplace<llvm::detail::DenseSetEmpty&>(a1 + 240, &v40, v41);
          v13 = v40;
          v14 = *(a1 + 136);
          if (v14 >= *(a1 + 140))
          {
            OUTLINED_FUNCTION_20_11(v14);
            v14 = *(a1 + 136);
          }

          *(*(a1 + 128) + 8 * v14) = v13;
          OUTLINED_FUNCTION_17_16();
          goto LABEL_13;
        }

LABEL_9:
        if (v11 == v10)
        {
          goto LABEL_10;
        }

LABEL_13:
        if (++v5 == v4)
        {
          goto LABEL_37;
        }
      }

      v16 = 0;
      v37 = *(DefiningOp + 72);
      while (1)
      {
        v38 = *(v37 + 32 * v16 + 24);
        if (mlir::matchValueTypeThrough<mlir::BlockArgument,mlir::UnrealizedConversionCastOp>(v38))
        {
          goto LABEL_27;
        }

        v17 = v7;
        v18 = mlir::Value::getDefiningOp(&v38);
        {
          v26 = v18;
          v18 = v26;
          if (v27)
          {
            v28 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            v30 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v28, v29);
            OUTLINED_FUNCTION_5_10(v30);
            v18 = v26;
          }
        }

        v7 = v17;
        if (!(*(**(v18 + 48) + 32))(*(v18 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id))
        {
          goto LABEL_27;
        }

        v40 = mlir::Value::getDefiningOp(&v38);
        if (!*(a1 + 256))
        {
          goto LABEL_24;
        }

        OUTLINED_FUNCTION_15_14();
        if (v21 != v22)
        {
          break;
        }

LABEL_23:
        if (v20 == v19)
        {
          goto LABEL_24;
        }

LABEL_27:
        if (++v16 == v15)
        {
          goto LABEL_7;
        }
      }

      while (v21 != -4096)
      {
        OUTLINED_FUNCTION_10_15();
        if (v21 == v25)
        {
          goto LABEL_23;
        }
      }

LABEL_24:
      llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>,mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>::try_emplace<llvm::detail::DenseSetEmpty&>(a1 + 240, &v40, v41);
      v23 = v40;
      v24 = *(a1 + 136);
      if (v24 >= *(a1 + 140))
      {
        OUTLINED_FUNCTION_20_11(v24);
        v24 = *(a1 + 136);
      }

      *(*(a1 + 128) + 8 * v24) = v23;
      OUTLINED_FUNCTION_17_16();
      v7 = v17;
      goto LABEL_27;
    }
  }

LABEL_37:
  v40 = a2;
  v31 = a1 + 240;
  if (*(a1 + 256))
  {
    OUTLINED_FUNCTION_15_14();
    if (v34 == a2)
    {
LABEL_39:
      if (v33 != v32)
      {
        return;
      }
    }

    else
    {
      while (v34 != -4096)
      {
        OUTLINED_FUNCTION_10_15();
        if (v34 == a2)
        {
          goto LABEL_39;
        }
      }
    }
  }

  llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>,mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>::try_emplace<llvm::detail::DenseSetEmpty&>(v31, &v40, v41);
  v35 = v40;
  v36 = *(a1 + 136);
  if (v36 >= *(a1 + 140))
  {
    OUTLINED_FUNCTION_20_11(v36);
    LODWORD(v36) = *(a1 + 136);
  }

  *(*(a1 + 128) + 8 * v36) = v35;
  OUTLINED_FUNCTION_17_16();
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::VariableFromTensorOp,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceUpdateOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReadVariableOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::VariableFromTensorOp,mlir::detail::any_value_binder>>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AssignVariableOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::VariableFromTensorOp,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceUpdateOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReadVariableOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::VariableFromTensorOp,mlir::detail::any_value_binder>>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::VariableFromTensorOp,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceUpdateOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReadVariableOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::VariableFromTensorOp,mlir::detail::any_value_binder>>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  v4 = *a1;
  v15[0] = *(*(**(a2 + 8) + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(v15);
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::VariableFromTensorOp,void>::id || (*(DefiningOp + 46) & 0x80) == 0 || *(DefiningOp + 68) != 1)
    {
      goto LABEL_7;
    }

    v7 = *(*(DefiningOp + 72) + 24);
    v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        v6 = 0;
        goto LABEL_8;
      }
    }

    else
    {
      **v4 = v7;
    }

    v4[1] = DefiningOp;
    v6 = 1;
  }

LABEL_8:
  v9 = v6 & **a2;
  if (!DefiningOp)
  {
    v9 = 0;
  }

  **a2 = v9;
  v10 = a1[1];
  v15[0] = *(*(**(a2 + 8) + 72) + 56);
  result = mlir::Value::getDefiningOp(v15);
  v13 = result;
  if (result)
  {
    v17 = result;
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::StridedSliceUpdateOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 5)
    {
      v16 = 1;
      v15[0] = &v16;
      v15[1] = &v17;
      result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReadVariableOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::VariableFromTensorOp,mlir::detail::any_value_binder>> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::StridedSliceUpdateOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReadVariableOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::VariableFromTensorOp,mlir::detail::any_value_binder>>,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReadVariableOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::VariableFromTensorOp,mlir::detail::any_value_binder>> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul,2ul,3ul,4ul>(v10, v15);
      v12 = v16;
      if (v16 == 1)
      {
        *(v10 + 40) = v17;
      }
    }

    else
    {
      v12 = 0;
    }
  }

  v14 = v12 & **a2;
  if (!v13)
  {
    v14 = 0;
  }

  **a2 = v14;
  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReadVariableOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::VariableFromTensorOp,mlir::detail::any_value_binder>>>(uint64_t a1, unsigned int a2, uint64_t ***a3)
{
  v12 = *(*(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v12);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReadVariableOp,void>::id)
    {
      goto LABEL_11;
    }

    if ((*(DefiningOp + 46) & 0x80) == 0)
    {
      goto LABEL_11;
    }

    if (*(DefiningOp + 68) != 1)
    {
      goto LABEL_11;
    }

    v7 = *a3;
    v12 = *(*(DefiningOp + 72) + 24);
    v8 = mlir::Value::getDefiningOp(&v12);
    if (!v8 || *(*(v8 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::VariableFromTensorOp,void>::id || (*(v8 + 46) & 0x80) == 0 || *(v8 + 68) != 1)
    {
      goto LABEL_11;
    }

    v9 = *(*(v8 + 72) + 24);
    v10 = **v7;
    if (v10)
    {
      if (v10 != v9)
      {
LABEL_11:
        v5 = 0;
        return (v6 != 0) & v5;
      }
    }

    else
    {
      **v7 = v9;
    }

    v7[1] = v8;
    a3[1] = v6;
    v5 = 1;
  }

  return (v6 != 0) & v5;
}

uint64_t mlir::anonymous namespace::ConvertTensorBufferPatternToFusionOp::patternMatch(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::BufferToTensorOp,void>::id && (*(a2 + 46) & 0x80) != 0 && *(a2 + 68) == 1)
  {
    v22[0] = *(*(a2 + 72) + 24);
    result = mlir::Value::getDefiningOp(v22);
    if (!result)
    {
      return result;
    }

    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::TensorToBufferOp,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 1)
    {
      v6 = *(*(result + 72) + 24);
      v21 = result;
      if (*(a3 + 256))
      {
        OUTLINED_FUNCTION_15_14();
        if (v9 == result)
        {
LABEL_10:
          if (v8 != v7)
          {
            goto LABEL_14;
          }
        }

        else
        {
          while (v9 != -4096)
          {
            OUTLINED_FUNCTION_10_15();
            if (v9 == result)
            {
              goto LABEL_10;
            }
          }
        }
      }

      OUTLINED_FUNCTION_42_6(result);
      v10 = v21;
      v11 = *(a3 + 136);
      if (v11 >= *(a3 + 140))
      {
        v16 = OUTLINED_FUNCTION_22_9();
        v20 = v18;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v19, v17 + 1, 8);
        v10 = v20;
        v11 = *(a3 + 136);
      }

      *(*(a3 + 128) + 8 * v11) = v10;
      OUTLINED_FUNCTION_17_16();
      LODWORD(v7) = *(a3 + 256);
LABEL_14:
      if (v7)
      {
        OUTLINED_FUNCTION_15_14();
        if (v14 == a2)
        {
LABEL_16:
          if (v13 != v12)
          {
LABEL_20:
            return 1;
          }
        }

        else
        {
          while (v14 != -4096)
          {
            OUTLINED_FUNCTION_10_15();
            if (v14 == a2)
            {
              goto LABEL_16;
            }
          }
        }
      }

      OUTLINED_FUNCTION_42_6(result, v20);
      v15 = *(a3 + 136);
      if (v15 >= *(a3 + 140))
      {
        OUTLINED_FUNCTION_20_11(v15);
        LODWORD(v15) = *(a3 + 136);
      }

      *(*(a3 + 128) + 8 * v15) = a2;
      OUTLINED_FUNCTION_17_16();
      goto LABEL_20;
    }
  }

  return 0;
}

void mlir::OpBuilder::create<mlir::anec::GOC,mlir::MemRefType,mlir::Value &,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.gain_offset_control";
  *(a2 + 24) = 24;
}

void mlir::OpBuilder::create<mlir::mps::ReadDataFromFileOp,mlir::MemRefType &,mlir::StringAttr &,mlir::IntegerAttr &,mlir::StringAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.read_data_from_file";
  *(a2 + 24) = 23;
}

void mlir::anonymous namespace::ConvertCropResize::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::InFlightDiagnostic *a2, uint64_t a3)
{
  OUTLINED_FUNCTION_21_10(a1, a1, a3, "Invalid mps::CropResizeAlignmentMode for ANE, only defaultAlignment, alignCorners, and offsetCorners are supported");
  mlir::InFlightDiagnostic::~InFlightDiagnostic(a2);
  __break(1u);
}

{
  OUTLINED_FUNCTION_21_10(a1, a1, a3, "Invalid mps::CropResizeCoordinateMode for ANE, only cornersHeightFirst, cornersWidthFirst, centersHeightFirst, and centersWidthFirst are supported");
  mlir::InFlightDiagnostic::~InFlightDiagnostic(a2);
  __break(1u);
}

{
  OUTLINED_FUNCTION_21_10(a1, a1, a3, "Invalid mps::SamplingMode for ANE, only bilienar and nearest are supported");
  mlir::InFlightDiagnostic::~InFlightDiagnostic(a2);
  __break(1u);
}

void mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.reshape";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long &,int,int>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.input_view";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::anec::Concat,mlir::ValueRange,unsigned long long &,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.concat";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.broadcast";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::anec::CropResize,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.crop_resize";
  *(a2 + 24) = 16;
}

void mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,int,BOOL,decltype(nullptr),decltype(nullptr),decltype(nullptr),decltype(nullptr)>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.convolution";
  *(a2 + 24) = 16;
}

void mlir::OpBuilder::create<mlir::anec::State,mlir::ShapedType &,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.state";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::anec::ScaledElementWise,mlir::MemRefType &,mlir::Value,mlir::Value,mlir::StringAttr &,mlir::FloatAttr &,mlir::FloatAttr &,mlir::FloatAttr &,mlir::BoolAttr &,mlir::BoolAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.scaled_elementwise";
  *(a2 + 24) = 23;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,llvm::SmallVector<mlir::Value,2u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.add";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseMult,llvm::SmallVector<mlir::Value,2u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.mult";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseSub,llvm::SmallVector<mlir::Value,2u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.sub";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseMax,llvm::SmallVector<mlir::Value,2u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.max";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseMin,llvm::SmallVector<mlir::Value,2u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.min";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::ElementwisePower,llvm::SmallVector<mlir::Value,2u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.power";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseAbs,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.abs";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::Exp2,mlir::anec::ElementwiseMult &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.exp2";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::anec::Log2,mlir::Value,mlir::FloatAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.log2";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqualZero,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.not_equal_zero";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.equal_zero";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.invert";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.div";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.floor";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.matmul";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::anec::Linear,mlir::Value &,mlir::Value &,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseElementsAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.linear";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.transpose";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::anec::Degamma,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.degamma";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::anec::Dirac,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.dirac";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::anec::Gelu,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.gelu";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::anec::Relu,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.relu";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::anec::RoundNearest,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.round_nearest";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseSquare,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.square";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::anec::Sqrt,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.sqrt";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::anec::Swish,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.swish";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::anec::Tanh,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.tanh";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.equal";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.not_equal";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThan,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.greater_than";
  *(a2 + 24) = 17;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanZero,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.greater_than_zero";
  *(a2 + 24) = 22;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.greater_than_equal";
  *(a2 + 24) = 23;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqualZero,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.greater_than_equal_zero";
  *(a2 + 24) = 28;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseLessThan,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.less_than";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanZero,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.less_than_zero";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.less_than_equal";
  *(a2 + 24) = 20;
}

void mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqualZero,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.less_than_equal_zero";
  *(a2 + 24) = 25;
}

void mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.average_pool";
  *(a2 + 24) = 17;
}

void mlir::OpBuilder::create<mlir::anec::L2NormPool,mlir::Value &,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.l2norm_pool";
  *(a2 + 24) = 16;
}

void mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.max_pool";
  *(a2 + 24) = 13;
}

void mlir::OpBuilder::create<mlir::anec::Ceil,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.ceil";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::anec::Erf,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.erf";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::Sign,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.sign";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::anec::Trunc,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.trunc";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::anec::ReduceMax,mlir::Value,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.reduce_max";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::anec::ReduceAvg,mlir::Value,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.reduce_avg";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::anec::ReduceMin,mlir::Value,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.reduce_min";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::anec::ReduceSum,mlir::Value,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.reduce_sum";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::anec::Flatten,mlir::Value,mlir::anec::FlattenModeAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.flatten";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::anec::Unflatten,mlir::Value,mlir::anec::FlattenModeAttr &,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.unflatten";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::anec::Cast,mlir::Type &,mlir::anec::ElementwiseNotEqualZero &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.cast";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::anec::Softmax,mlir::Value,mlir::DenseIntElementsAttr &,BOOL &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.softmax";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.resize";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::anec::LayerNorm,mlir::Value &,mlir::DenseIntElementsAttr &,llvm::APFloat>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.layer_norm";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::anec::InstanceNorm,mlir::Value &,mlir::DenseIntElementsAttr &,llvm::APFloat>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.instance_norm";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::anec::GatherND,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.gather_nd";
  *(a2 + 24) = 14;
}

void mlir::anonymous namespace::ConvertSampleGrid::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, mlir::InFlightDiagnostic *a3)
{
  *a2 = "Invalid mps::SamplingMode for ANE, only bilienar and nearest are supported";
  *(a2 + 32) = 259;
  mlir::emitError(a1, a2, a3);
  mlir::InFlightDiagnostic::~InFlightDiagnostic(a3);
  __break(1u);
}

void mlir::OpBuilder::create<mlir::anec::Resample,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.resample";
  *(a2 + 24) = 13;
}

void mlir::OpBuilder::create<mlir::anec::ScaledDotProductAttention,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.sdpa";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::anec::PixelShuffle,mlir::Value,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.pixel_shuffle";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::anec::ChannelToSpace,mlir::Value,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.channel_to_space";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::anec::PixelUnshuffle,mlir::Value,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.pixel_unshuffle";
  *(a2 + 24) = 20;
}

void mlir::OpBuilder::create<mlir::anec::SpaceToChannel,mlir::Value,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.space_to_channel";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::anec::BatchToSpace,mlir::Value &,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.batch_to_space";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::anec::SpaceToBatch,mlir::Value &,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.space_to_batch";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::anec::Padding,mlir::Value const&,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.padding";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::anec::Cos,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.cos";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::Sin,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.sin";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::Rsqrt,mlir::Value &,llvm::APFloat &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.r_sqrt";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::anec::BatchNorm,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value,llvm::APFloat &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.batch_norm";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::anec::ArgMinMax,mlir::Value &,mlir::DenseIntElementsAttr,mlir::anec::ArgMinMaxMode &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.arg_min_max";
  *(a2 + 24) = 16;
}

void mlir::OpBuilder::create<mlir::anec::GlobalArgMinMax,mlir::Value &,long long &,mlir::anec::ArgMinMaxMode &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.global_arg_min_max";
  *(a2 + 24) = 23;
}

void mlir::OpBuilder::create<mlir::anec::Tile,mlir::Value,mlir::DenseIntElementsAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.tile";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::anec::RingBufferWriter,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::ValueRange &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.ring_buffer_writer";
  *(a2 + 24) = 23;
}

void mlir::OpBuilder::create<mlir::anec::RingBufferReader,mlir::ShapedType &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::ValueRange &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.ring_buffer_reader";
  *(a2 + 24) = 23;
}

void mlir::OpBuilder::create<mlir::anec::TensorToTensorBuffer,mlir::MemRefType &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.tensor_to_tensor_buffer";
  *(a2 + 24) = 28;
}

void mlir::OpBuilder::create<mlir::anec::TensorBufferToTensor,mlir::MemRefType &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.tensor_buffer_to_tensor";
  *(a2 + 24) = 28;
}

void mlir::OpBuilder::create<mlir::anec::Sigmoid,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.sigmoid";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::anec::HighPrecisionSigmoid,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.high_precision_sigmoid";
  *(a2 + 24) = 27;
}

void mlir::OpBuilder::create<mlir::anec::LeakyRelu,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.leaky_relu";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::anec::ClampedRelu,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.clamped_relu";
  *(a2 + 24) = 17;
}

void mlir::OpBuilder::create<mlir::anec::NRelu,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.n_relu";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::anec::Elu,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.elu";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::anec::DeQuant,mlir::ShapedType &,mlir::Value,llvm::APFloat,int &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.dequant";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::anec::Quant,mlir::ShapedType &,mlir::Value,llvm::APFloat,int &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.quant";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::anec::Deconvolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,unsigned long long &,BOOL const&,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseElementsAttr,mlir::DictionaryAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.deconvolution";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::silc::SilcAllSliceOp,mlir::MemRefType &,mlir::silc::ShardingAttr,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "silc.all_slice";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::silc::SilcAllGatherOp,mlir::MemRefType &,mlir::silc::ShardingAttr,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "silc.all_gather";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::silc::SilcAllReduceOp,mlir::MemRefType &,mlir::Value,mlir::Attribute,mlir::silc::TensorAxisRefAttr,mlir::silc::ReductionKind>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "silc.all_reduce";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::anec::RegionReturn,llvm::ArrayRef<mlir::Value> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.region_return";
  *(a2 + 24) = 18;
}

uint64_t mlir::affine::isValidDim()
{
  OUTLINED_FUNCTION_70_0();
  v18 = v2;
  OUTLINED_FUNCTION_86_0();
  result = mlir::Type::isIndex(v3);
  if (result)
  {
    if (mlir::affine::isValidSymbol(v1, v0))
    {
      return 1;
    }

    DefiningOp = mlir::Value::getDefiningOp(&v18);
    if (DefiningOp)
    {
      v6 = DefiningOp;
      if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::affine::AffineApplyOp,void>::id)
      {
        if ((*(DefiningOp + 46) & 0x80) == 0)
        {
          return 1;
        }

        v10 = *(DefiningOp + 68);
        if (!v10)
        {
          return 1;
        }

        v11 = v10 - 1;
        v12 = (*(DefiningOp + 72) + 24);
        do
        {
          v13 = *v12;
          v12 += 4;
          result = mlir::affine::isValidDim(v13, v0);
          v15 = v11-- != 0;
        }

        while (result && v15);
      }

      else
      {
        InterfaceFor = mlir::OpInterface<mlir::ShapedDimOpInterface,mlir::detail::ShapedDimOpInterfaceInterfaceTraits>::getInterfaceFor(DefiningOp);
        if (InterfaceFor)
        {
          InterfaceFor = mlir::OpInterface<mlir::ShapedDimOpInterface,mlir::detail::ShapedDimOpInterfaceInterfaceTraits>::getInterfaceFor(v6);
        }

        else
        {
          v6 = 0;
        }

        v17[0] = v6;
        v17[1] = InterfaceFor;
        if (v6)
        {
          CallableForCallee = mlir::CallOpInterface::getCallableForCallee(v17);
          return mlir::affine::isTopLevelValue(CallableForCallee);
        }

        else
        {
          return 0;
        }
      }
    }

    else
    {
      v8 = *(*(mlir::Block::getParentOp(*(v18 + 16)) + 48) + 16);
      return v8 == &mlir::detail::TypeIDResolver<mlir::affine::AffineForOp,void>::id || v8 == &mlir::detail::TypeIDResolver<mlir::affine::AffineParallelOp,void>::id;
    }
  }

  return result;
}

uint64_t mlir::affine::AffineApplyOp::print(mlir::affine::AffineApplyOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_17_2();
  if (v8)
  {
    llvm::raw_ostream::write(v6, " ", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v6, v7);
  }

  OUTLINED_FUNCTION_13_12();
  OUTLINED_FUNCTION_104();
  (*(v9 + 40))(v2);
  if ((*(*v3 + 11) & 0x800000) != 0)
  {
    OUTLINED_FUNCTION_143_1();
  }

  else
  {
    OUTLINED_FUNCTION_141_1();
  }

  OUTLINED_FUNCTION_21_11();
  OUTLINED_FUNCTION_86_0();
  mlir::AffineMapAttr::getValue(v10);
  OUTLINED_FUNCTION_38_10();
  NumDims = mlir::AffineMap::getNumDims(v11);
  OUTLINED_FUNCTION_117_3(NumDims);
  mlir::Operation::getAttrDictionary(*v3);
  OUTLINED_FUNCTION_38_10();
  mlir::ArrayAttr::getValue(v13);
  OUTLINED_FUNCTION_126_4();
  OUTLINED_FUNCTION_104();
  v14 = OUTLINED_FUNCTION_29_11();
  return v15(v14);
}

uint64_t mlir::affine::AffineApplyOp::verify(mlir::affine::AffineApplyOp *this)
{
  OUTLINED_FUNCTION_157_2(*MEMORY[0x1E69E9840]);
  OUTLINED_FUNCTION_13_17();
  v82 = OUTLINED_FUNCTION_134_2(v2, v52, v57, v62, v67, v72, v77, v82, v83);
  OUTLINED_FUNCTION_189_0();
  if (v4 < 0)
  {
    v5 = *(v3 + 68);
  }

  else
  {
    v5 = 0;
  }

  NumDims = mlir::AffineMap::getNumDims(&v82);
  if (v5 != mlir::AffineMap::getNumSymbols(&v82) + NumDims)
  {
    OUTLINED_FUNCTION_16_13();
    v7 = OUTLINED_FUNCTION_105_4();
    mlir::OpState::emitOpError(v7, v8, v9);
    mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v83);
    OUTLINED_FUNCTION_104_4();
    if (v10)
    {
      mlir::InFlightDiagnostic::report(&v83);
    }

    OUTLINED_FUNCTION_103_3();
    if (!v19)
    {
      return this;
    }

    v20 = OUTLINED_FUNCTION_145_2(v11, v12, v13, v14, v15, v16, v17, v18, v53, v58, v63, v68, v73, v78, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96, v97, v98, v99, __p, v101, v102, v103, v104, v105, v106);
    if (!v19)
    {
      free(v20);
    }

    v28 = v103;
    if (v103)
    {
      v29 = OUTLINED_FUNCTION_143_0(v20, v21, v22, v23, v24, v25, v26, v27, v54, v59, v64, v69, v74, v79, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96, v97, v98, v99, __p, v101, v102, v103, v104);
      if (!v19)
      {
        do
        {
          v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v29 - 8));
        }

        while (v29 != v28);
        v30 = v103;
      }

      OUTLINED_FUNCTION_135_2(v30, v55, v60, v65, v70, v75, v80, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96, v97, v98, v99, __p, v101, v102, v103, v104);
    }

    v31 = __p;
    if (!__p)
    {
LABEL_41:
      v50 = OUTLINED_FUNCTION_103_2(v20, v21, v22, v23, v24, v25, v26, v27, v54, v59, v64, v69, v74, v79, v82, v83, v84, v85, v86);
      if (!v19)
      {
        free(v50);
      }

      return this;
    }

    v32 = OUTLINED_FUNCTION_142_1();
    if (v19)
    {
LABEL_40:
      v101 = v31;
      operator delete(v32);
      goto LABEL_41;
    }

    do
    {
      v33 = OUTLINED_FUNCTION_17_5();
      if (v33)
      {
        operator delete[](v33);
      }
    }

    while (v5 != v31);
LABEL_39:
    v32 = __p;
    goto LABEL_40;
  }

  if (mlir::arith::FastMathFlagsAttr::getValue(&v82) == 1)
  {
    return 1;
  }

  OUTLINED_FUNCTION_16_13();
  v34 = OUTLINED_FUNCTION_105_4();
  mlir::OpState::emitOpError(v34, v35, v36);
  mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v83);
  OUTLINED_FUNCTION_104_4();
  if (v37)
  {
    mlir::InFlightDiagnostic::report(&v83);
  }

  OUTLINED_FUNCTION_103_3();
  if (v19)
  {
    v20 = OUTLINED_FUNCTION_145_2(v38, v39, v40, v41, v42, v43, v44, v45, v53, v58, v63, v68, v73, v78, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96, v97, v98, v99, __p, v101, v102, v103, v104, v105, v106);
    if (!v19)
    {
      free(v20);
    }

    v46 = v103;
    if (v103)
    {
      v47 = OUTLINED_FUNCTION_143_0(v20, v21, v22, v23, v24, v25, v26, v27, v54, v59, v64, v69, v74, v79, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96, v97, v98, v99, __p, v101, v102, v103, v104);
      if (!v19)
      {
        do
        {
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v47 - 8));
        }

        while (v47 != v46);
        v48 = v103;
      }

      OUTLINED_FUNCTION_135_2(v48, v56, v61, v66, v71, v76, v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96, v97, v98, v99, __p, v101, v102, v103, v104);
    }

    v31 = __p;
    if (!__p)
    {
      goto LABEL_41;
    }

    v32 = OUTLINED_FUNCTION_142_1();
    if (v19)
    {
      goto LABEL_40;
    }

    do
    {
      v49 = OUTLINED_FUNCTION_17_5();
      if (v49)
      {
        operator delete[](v49);
      }
    }

    while (v5 != v31);
    goto LABEL_39;
  }

  return this;
}

uint64_t mlir::affine::AffineDmaStartOp::print(mlir::affine::AffineDmaStartOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v115[2] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_17_2();
  if (v8)
  {
    llvm::raw_ostream::write(v6, " ", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v6, v7);
  }

  OUTLINED_FUNCTION_130_4();
  OUTLINED_FUNCTION_104();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v10 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v13)
  {
    llvm::raw_ostream::write(v11, 91);
  }

  else
  {
    OUTLINED_FUNCTION_23_11(v11, v12);
  }

  v116.var0 = "src_map";
  v116.var1 = 7;
  mlir::Operation::getInherentAttr(*v3, v116);
  v14 = *v3;
  if ((*(*v3 + 46) & 0x80) != 0)
  {
    v15 = *(v14 + 9);
  }

  else
  {
    v15 = 0;
  }

  v117.var0 = "src_map";
  v117.var1 = 7;
  mlir::Operation::getInherentAttr(v14, v117);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMapAttr::getValue(v16);
  OUTLINED_FUNCTION_38_10();
  NumInputs = mlir::AffineMap::getNumInputs(v17);
  mlir::ValueRange::ValueRange(v115, v15 + 32, NumInputs);
  OUTLINED_FUNCTION_104();
  v19 = OUTLINED_FUNCTION_88_2();
  v20(v19);
  OUTLINED_FUNCTION_104();
  (*(v21 + 16))(v2);
  OUTLINED_FUNCTION_26_12();
  if (!v8 & v13)
  {
    OUTLINED_FUNCTION_78_3(v23);
    OUTLINED_FUNCTION_15_4(v24, v25);
  }

  else
  {
    llvm::raw_ostream::write(v22, "], ", 3uLL);
  }

  v118.var0 = "src_map";
  v118.var1 = 7;
  mlir::Operation::getInherentAttr(*v3, v118);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMapAttr::getValue(v26);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMap::getNumInputs(v27);
  OUTLINED_FUNCTION_56_5();
  OUTLINED_FUNCTION_104();
  (*(v28 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v29 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v13)
  {
    llvm::raw_ostream::write(v30, 91);
  }

  else
  {
    OUTLINED_FUNCTION_23_11(v30, v31);
  }

  v119.var0 = "dst_map";
  v119.var1 = 7;
  mlir::Operation::getInherentAttr(*v3, v119);
  DstIndices = mlir::affine::AffineDmaStartOp::getDstIndices(v3);
  v40 = OUTLINED_FUNCTION_30_7(DstIndices, v33, v34, v35, v36, v37, v38, v39, v113, v115[0]);
  mlir::ValueRange::ValueRange(v40, v41, v42);
  OUTLINED_FUNCTION_104();
  v43 = OUTLINED_FUNCTION_88_2();
  v44(v43);
  OUTLINED_FUNCTION_104();
  (*(v45 + 16))(v2);
  OUTLINED_FUNCTION_26_12();
  if (!v8 & v13)
  {
    OUTLINED_FUNCTION_78_3(v47);
    OUTLINED_FUNCTION_15_4(v48, v49);
  }

  else
  {
    llvm::raw_ostream::write(v46, "], ", 3uLL);
  }

  v120.var0 = "src_map";
  v120.var1 = 7;
  mlir::Operation::getInherentAttr(*v3, v120);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMapAttr::getValue(v50);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMap::getNumInputs(v51);
  v121.var0 = "dst_map";
  v121.var1 = 7;
  mlir::Operation::getInherentAttr(*v3, v121);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMapAttr::getValue(v52);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMap::getNumInputs(v53);
  OUTLINED_FUNCTION_56_5();
  OUTLINED_FUNCTION_104();
  (*(v54 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v55 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v13)
  {
    llvm::raw_ostream::write(v56, 91);
  }

  else
  {
    OUTLINED_FUNCTION_23_11(v56, v57);
  }

  v122.var0 = "tag_map";
  v122.var1 = 7;
  mlir::Operation::getInherentAttr(*v3, v122);
  TagIndices = mlir::affine::AffineDmaStartOp::getTagIndices(v3);
  v66 = OUTLINED_FUNCTION_30_7(TagIndices, v59, v60, v61, v62, v63, v64, v65, v114, v115[0]);
  mlir::ValueRange::ValueRange(v66, v67, v68);
  OUTLINED_FUNCTION_104();
  v69 = OUTLINED_FUNCTION_88_2();
  v70(v69);
  OUTLINED_FUNCTION_104();
  (*(v71 + 16))(v2);
  OUTLINED_FUNCTION_26_12();
  if (!v8 & v13)
  {
    OUTLINED_FUNCTION_78_3(v73);
    OUTLINED_FUNCTION_15_4(v74, v75);
  }

  else
  {
    llvm::raw_ostream::write(v72, "], ", 3uLL);
  }

  mlir::affine::AffineDmaStartOp::getNumElements(v3);
  OUTLINED_FUNCTION_104();
  (*(v76 + 160))(v2);
  if (mlir::affine::AffineDmaStartOp::isStrided(v3))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_25_2();
    if (!v8 & v13)
    {
      OUTLINED_FUNCTION_18_11(v100, v101);
    }

    else
    {
      llvm::raw_ostream::write(v100, ", ", 2uLL);
    }

    if (mlir::affine::AffineDmaStartOp::isStrided(v3))
    {
      OUTLINED_FUNCTION_47_0();
      if (v103 < 0)
      {
        v104 = (*(v102 + 68) - 2);
      }

      else
      {
        v104 = 4294967294;
      }

      v105 = *(*(v102 + 72) + 32 * v104 + 24);
    }

    else
    {
      v105 = 0;
    }

    (*(*v2 + 160))(v2, v105);
    OUTLINED_FUNCTION_104();
    (*(v106 + 16))(v2);
    OUTLINED_FUNCTION_25_2();
    if (!v8 & v13)
    {
      OUTLINED_FUNCTION_18_11(v107, v108);
    }

    else
    {
      llvm::raw_ostream::write(v107, ", ", 2uLL);
    }

    if (mlir::affine::AffineDmaStartOp::isStrided(v3))
    {
      OUTLINED_FUNCTION_47_0();
      if (v110 < 0)
      {
        v111 = (*(v109 + 68) - 1);
      }

      else
      {
        v111 = 0xFFFFFFFFLL;
      }

      v112 = *(*(v109 + 72) + 32 * v111 + 24);
    }

    else
    {
      v112 = 0;
    }

    (*(*v2 + 160))(v2, v112);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_26_12();
  if (!v8 & v13)
  {
    OUTLINED_FUNCTION_78_3(v78);
    OUTLINED_FUNCTION_15_4(v79, v80);
  }

  else
  {
    llvm::raw_ostream::write(v77, " : ", 3uLL);
  }

  OUTLINED_FUNCTION_130_4();
  OUTLINED_FUNCTION_133_3();
  OUTLINED_FUNCTION_104();
  v81 = OUTLINED_FUNCTION_12_4();
  v82(v81);
  OUTLINED_FUNCTION_104();
  (*(v83 + 16))(v2);
  OUTLINED_FUNCTION_25_2();
  if (!v8 & v13)
  {
    OUTLINED_FUNCTION_18_11(v84, v85);
  }

  else
  {
    llvm::raw_ostream::write(v84, ", ", 2uLL);
  }

  v123.var0 = "src_map";
  v123.var1 = 7;
  mlir::Operation::getInherentAttr(*v3, v123);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMapAttr::getValue(v86);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMap::getNumInputs(v87);
  OUTLINED_FUNCTION_56_5();
  OUTLINED_FUNCTION_133_3();
  OUTLINED_FUNCTION_104();
  v88 = OUTLINED_FUNCTION_12_4();
  v89(v88);
  OUTLINED_FUNCTION_104();
  (*(v90 + 16))(v2);
  OUTLINED_FUNCTION_25_2();
  if (!v8 & v13)
  {
    OUTLINED_FUNCTION_18_11(v91, v92);
  }

  else
  {
    llvm::raw_ostream::write(v91, ", ", 2uLL);
  }

  v124.var0 = "src_map";
  v124.var1 = 7;
  mlir::Operation::getInherentAttr(*v3, v124);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMapAttr::getValue(v93);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMap::getNumInputs(v94);
  v125.var0 = "dst_map";
  v125.var1 = 7;
  mlir::Operation::getInherentAttr(*v3, v125);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMapAttr::getValue(v95);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMap::getNumInputs(v96);
  OUTLINED_FUNCTION_56_5();
  OUTLINED_FUNCTION_133_3();
  OUTLINED_FUNCTION_104();
  v97 = OUTLINED_FUNCTION_12_4();
  return v98(v97);
}

uint64_t mlir::affine::AffineDmaStartOp::getDstIndices(mlir::Operation **this)
{
  v2 = *this;
  if ((*(v2 + 46) & 0x80) != 0)
  {
    v3 = *(v2 + 9);
  }

  else
  {
    v3 = 0;
  }

  v7.var0 = "src_map";
  v7.var1 = 7;
  InherentAttr = mlir::Operation::getInherentAttr(v2, v7);
  InherentAttr = mlir::AffineMapAttr::getValue(&InherentAttr);
  v4 = mlir::AffineMap::getNumInputs(&InherentAttr) + 1;
  v8.var0 = "src_map";
  v8.var1 = 7;
  InherentAttr = mlir::Operation::getInherentAttr(*this, v8);
  InherentAttr = mlir::AffineMapAttr::getValue(&InherentAttr);
  mlir::AffineMap::getNumInputs(&InherentAttr);
  v9.var0 = "dst_map";
  v9.var1 = 7;
  InherentAttr = mlir::Operation::getInherentAttr(*this, v9);
  InherentAttr = mlir::AffineMapAttr::getValue(&InherentAttr);
  mlir::AffineMap::getNumInputs(&InherentAttr);
  return v3 + 32 * v4 + 32;
}

uint64_t mlir::affine::AffineDmaStartOp::getTagIndices(mlir::Operation **this)
{
  v2 = *this;
  if ((*(v2 + 46) & 0x80) != 0)
  {
    v3 = *(v2 + 9);
  }

  else
  {
    v3 = 0;
  }

  v8.var0 = "src_map";
  v8.var1 = 7;
  InherentAttr = mlir::Operation::getInherentAttr(v2, v8);
  InherentAttr = mlir::AffineMapAttr::getValue(&InherentAttr);
  NumInputs = mlir::AffineMap::getNumInputs(&InherentAttr);
  v9.var0 = "dst_map";
  v9.var1 = 7;
  InherentAttr = mlir::Operation::getInherentAttr(*this, v9);
  InherentAttr = mlir::AffineMapAttr::getValue(&InherentAttr);
  v5 = NumInputs + mlir::AffineMap::getNumInputs(&InherentAttr) + 2;
  v10.var0 = "src_map";
  v10.var1 = 7;
  InherentAttr = mlir::Operation::getInherentAttr(*this, v10);
  InherentAttr = mlir::AffineMapAttr::getValue(&InherentAttr);
  mlir::AffineMap::getNumInputs(&InherentAttr);
  v11.var0 = "dst_map";
  v11.var1 = 7;
  InherentAttr = mlir::Operation::getInherentAttr(*this, v11);
  InherentAttr = mlir::AffineMapAttr::getValue(&InherentAttr);
  mlir::AffineMap::getNumInputs(&InherentAttr);
  v12.var0 = "tag_map";
  v12.var1 = 7;
  InherentAttr = mlir::Operation::getInherentAttr(*this, v12);
  InherentAttr = mlir::AffineMapAttr::getValue(&InherentAttr);
  mlir::AffineMap::getNumInputs(&InherentAttr);
  return v3 + 32 * v5 + 32;
}

BOOL mlir::affine::AffineDmaStartOp::isStrided(mlir::Operation **this)
{
  v2 = *this;
  if ((*(v2 + 46) & 0x80) != 0)
  {
    v3 = *(v2 + 17);
  }

  else
  {
    v3 = 0;
  }

  v8.var0 = "src_map";
  v8.var1 = 7;
  InherentAttr = mlir::Operation::getInherentAttr(v2, v8);
  InherentAttr = mlir::AffineMapAttr::getValue(&InherentAttr);
  NumInputs = mlir::AffineMap::getNumInputs(&InherentAttr);
  v9.var0 = "dst_map";
  v9.var1 = 7;
  InherentAttr = mlir::Operation::getInherentAttr(*this, v9);
  InherentAttr = mlir::AffineMapAttr::getValue(&InherentAttr);
  v5 = mlir::AffineMap::getNumInputs(&InherentAttr);
  v10.var0 = "tag_map";
  v10.var1 = 7;
  InherentAttr = mlir::Operation::getInherentAttr(*this, v10);
  InherentAttr = mlir::AffineMapAttr::getValue(&InherentAttr);
  return v3 != NumInputs + v5 + mlir::AffineMap::getNumInputs(&InherentAttr) + 4;
}

void mlir::affine::AffineDmaWaitOp::print(mlir::affine::AffineDmaWaitOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v62[2] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_17_2();
  if (v8)
  {
    llvm::raw_ostream::write(v6, " ", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v6, v7);
  }

  OUTLINED_FUNCTION_130_4();
  OUTLINED_FUNCTION_104();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v10 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v25)
  {
    llvm::raw_ostream::write(v11, 91);
  }

  else
  {
    OUTLINED_FUNCTION_23_11(v11, v12);
  }

  v13 = *v3;
  if ((*(*v3 + 46) & 0x80) != 0)
  {
    v14 = *(v13 + 9);
  }

  else
  {
    v14 = 0;
  }

  v63.var0 = "tag_map";
  v63.var1 = 7;
  mlir::Operation::getInherentAttr(v13, v63);
  OUTLINED_FUNCTION_88_4();
  Value = mlir::AffineMapAttr::getValue(v15);
  NumInputs = mlir::AffineMap::getNumInputs(&Value);
  v17 = NumInputs;
  Value = v62;
  v61 = 0x200000000;
  if (NumInputs < 3)
  {
    if (!NumInputs)
    {
      v30 = 0;
      goto LABEL_24;
    }

    v21 = 0;
    v22 = v62;
  }

  else
  {
    OUTLINED_FUNCTION_85_5();
    llvm::SmallVectorBase<unsigned int>::grow_pod(v18, v19, v20, 8);
    v21 = v61;
    v22 = Value;
  }

  v23 = &v22[v21];
  if (v17 >= 0xF)
  {
    v24 = &v22[v21 + v17];
    v25 = v23 >= v14 + 32 * v17 + 32 || v14 + 56 >= v24;
    if (v25)
    {
      v26 = (v23 + 2);
      do
      {
        OUTLINED_FUNCTION_35_7(v26);
      }

      while (v28 != 4);
      v23 = v27;
    }
  }

  do
  {
    OUTLINED_FUNCTION_107_3(v23);
  }

  while (v29 != 1);
  v30 = v61;
LABEL_24:
  LODWORD(v61) = v30 + v17;
  v64.var0 = "tag_map";
  v64.var1 = 7;
  InherentAttr = mlir::Operation::getInherentAttr(*v3, v64);
  v39 = OUTLINED_FUNCTION_112_4(InherentAttr, v32, v33, v34, v35, v36, v37, v38, v58, v59);
  mlir::ValueRange::ValueRange(v39, v40, v41);
  OUTLINED_FUNCTION_104();
  (*(v42 + 240))(v2, InherentAttr);
  OUTLINED_FUNCTION_104();
  (*(v43 + 16))(v2);
  OUTLINED_FUNCTION_26_12();
  if (!v8 && v25)
  {
    OUTLINED_FUNCTION_78_3(v45);
    OUTLINED_FUNCTION_15_4(v46, v47);
  }

  else
  {
    llvm::raw_ostream::write(v44, "], ", 3uLL);
  }

  v65.var0 = "tag_map";
  v65.var1 = 7;
  mlir::Operation::getInherentAttr(*v3, v65);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMapAttr::getValue(v48);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMap::getNumInputs(v49);
  OUTLINED_FUNCTION_56_5();
  OUTLINED_FUNCTION_104();
  (*(v50 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v51 + 16))(v2);
  OUTLINED_FUNCTION_26_12();
  if (!v8 && v25)
  {
    OUTLINED_FUNCTION_78_3(v53);
    OUTLINED_FUNCTION_15_4(v54, v55);
  }

  else
  {
    llvm::raw_ostream::write(v52, " : ", 3uLL);
  }

  OUTLINED_FUNCTION_130_4();
  OUTLINED_FUNCTION_133_3();
  OUTLINED_FUNCTION_104();
  v56 = OUTLINED_FUNCTION_12_4();
  v57(v56);
  if (Value != v62)
  {
    free(Value);
  }
}

uint64_t mlir::affine::AffineForOp::print(mlir::affine::AffineForOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v131 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v5 + 16))(v6);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v7, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v7, v8);
  }

  OUTLINED_FUNCTION_44_6();
  OUTLINED_FUNCTION_8_14();
  OUTLINED_FUNCTION_104();
  (*(v10 + 152))(v2);
  OUTLINED_FUNCTION_104();
  (*(v11 + 16))(v2);
  OUTLINED_FUNCTION_26_12();
  if (!v14 & v9)
  {
    OUTLINED_FUNCTION_78_3(v13);
    OUTLINED_FUNCTION_15_4(v15, v16);
  }

  else
  {
    llvm::raw_ostream::write(v12, " = ", 3uLL);
  }

  OUTLINED_FUNCTION_48_6();
  if ((v19 & 0x800000) != 0)
  {
    v20 = *(v17 + 72);
  }

  else
  {
    v20 = 0;
  }

  printBound(*(v18 + 64), v20, *(v18 + 88), "max", v2);
  OUTLINED_FUNCTION_104();
  (*(v21 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v24 > 3)
  {
    OUTLINED_FUNCTION_160(v23);
    *(v26 + 32) = v25 + 4;
  }

  else
  {
    llvm::raw_ostream::write(v22, " to ", 4uLL);
  }

  v27 = *(*v3 + 11);
  v28 = *v3 + 16 * ((v27 >> 23) & 1);
  v29 = *(v28 + 80);
  v30 = *(v28 + 88);
  v31 = *(v28 + 92);
  if ((v27 & 0x800000) != 0)
  {
    v32 = *(*v3 + 9);
  }

  else
  {
    v32 = 0;
  }

  printBound(v29, v32 + 32 * v30, (v31 + v30) - v30, "min", v2);
  OUTLINED_FUNCTION_13_12();
  OUTLINED_FUNCTION_154_2(v33, v117, v119, v121);
  if (v124 > 0x40)
  {
    v4 = *__p;
    operator delete[](__p);
LABEL_18:
    if (v4 == 1)
    {
      goto LABEL_26;
    }

    goto LABEL_19;
  }

  if (v124)
  {
    v4 = (__p << -v124) >> -v124;
    goto LABEL_18;
  }

LABEL_19:
  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v36 > 5)
  {
    *(v35 + 4) = 8304;
    OUTLINED_FUNCTION_105_3(v34, v35);
  }

  else
  {
    llvm::raw_ostream::write(v34, " step ", 6uLL);
  }

  OUTLINED_FUNCTION_13_12();
  OUTLINED_FUNCTION_154_2(v37, v118, v120, v121);
  if (v124 > 0x40)
  {
    v4 = *__p;
    operator delete[](__p);
  }

  else
  {
    OUTLINED_FUNCTION_121_2();
  }

  v38 = (*(*v2 + 16))(v2);
  llvm::raw_ostream::operator<<(v38, v4);
LABEL_26:
  OUTLINED_FUNCTION_13_17();
  OUTLINED_FUNCTION_82_6();
  __p = mlir::AffineMapAttr::getValue(v39);
  OUTLINED_FUNCTION_13_12();
  v121 = *(v40 + 80);
  v122[0] = mlir::AffineMapAttr::getValue(&v121);
  OUTLINED_FUNCTION_47_0();
  if (v42 < 0)
  {
    v43 = *(v41 + 68);
  }

  else
  {
    v43 = 0;
  }

  NumInputs = mlir::AffineMap::getNumInputs(&__p);
  if (v43 == mlir::AffineMap::getNumInputs(v122) + NumInputs)
  {
    goto LABEL_63;
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v47 > 0xA)
  {
    *(v46 + 7) = 678651762;
    *v46 = *" iter_args(";
    v45[4] += 11;
  }

  else
  {
    llvm::raw_ostream::write(v45, " iter_args(", 0xBuLL);
  }

  v48 = *(*v3 + 11);
  v49 = (*v3 + 16 * ((v48 >> 23) & 1));
  v50 = *(((v49 + ((v48 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(*v3 + 10) + 8);
  if (v50)
  {
    v51 = v50 - 8;
  }

  else
  {
    v51 = 0;
  }

  v52 = *(v51 + 48);
  v53 = *(v51 + 56) - v52;
  v54 = v53 >> 3;
  v55 = (v53 >> 3) - 1;
  if ((v48 & 0x800000) != 0)
  {
    v56 = *(*v3 + 9);
    if (v53 >> 3 != 1)
    {
LABEL_37:
      v57 = v49[24];
      if (v57)
      {
        v58 = (v49[23] + v49[22]);
        v59 = v56 + 32 * v58;
        OUTLINED_FUNCTION_104();
        (*(v60 + 160))(v2);
        OUTLINED_FUNCTION_104();
        (*(v61 + 16))(v2);
        OUTLINED_FUNCTION_26_12();
        if (!v14 & v9)
        {
          OUTLINED_FUNCTION_78_3(v63);
          OUTLINED_FUNCTION_15_4(v64, v65);
        }

        else
        {
          llvm::raw_ostream::write(v62, " = ", 3uLL);
        }

        v66 = OUTLINED_FUNCTION_88_2();
        v67(v66);
        if (v55 != 1)
        {
          v68 = (v57 + v58);
          v69 = v52 + 16;
          v70 = 8 * v54 - 16;
          v71 = (v59 + 56);
          v72 = ~v58 + v68;
          do
          {
            if (!v72)
            {
              break;
            }

            (*(*v2 + 16))(v2);
            OUTLINED_FUNCTION_25_2();
            if (!v14 & v9)
            {
              OUTLINED_FUNCTION_18_11(v73, v74);
            }

            else
            {
              llvm::raw_ostream::write(v73, ", ", 2uLL);
            }

            v75 = *v71;
            OUTLINED_FUNCTION_104();
            (*(v76 + 160))(v2);
            OUTLINED_FUNCTION_104();
            (*(v77 + 16))(v2);
            OUTLINED_FUNCTION_26_12();
            if (!v14 & v9)
            {
              OUTLINED_FUNCTION_78_3(v79);
              OUTLINED_FUNCTION_15_4(v80, v81);
            }

            else
            {
              llvm::raw_ostream::write(v78, " = ", 3uLL);
            }

            (*(*v2 + 160))(v2, v75);
            v69 += 8;
            v71 += 4;
            --v72;
            v70 -= 8;
          }

          while (v70);
        }
      }
    }
  }

  else
  {
    v56 = 0;
    if (v53 >> 3 != 1)
    {
      goto LABEL_37;
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v84 > 5)
  {
    OUTLINED_FUNCTION_116_4(v83);
    OUTLINED_FUNCTION_105_3(v85, v86);
  }

  else
  {
    llvm::raw_ostream::write(v82, ") -> (", 6uLL);
  }

  OUTLINED_FUNCTION_34_2();
  v122[0] = v87;
  v122[1] = v88;
  mlir::OperandRange::getTypes(v122, &__p);
  v89 = v124;
  v90 = v126;
  if (v124 != v126)
  {
    v91 = OUTLINED_FUNCTION_38_4();
    mlir::detail::OpResultImpl::getNextResultAtOffset(v91, v92);
    OUTLINED_FUNCTION_104();
    v93 = OUTLINED_FUNCTION_12_4();
    v94(v93);
    for (i = v89 + 1; v90 != i; ++i)
    {
      (*(*v2 + 16))(v2);
      OUTLINED_FUNCTION_25_2();
      if (!v14 & v9)
      {
        *v97 = 8236;
        OUTLINED_FUNCTION_24_2(v96);
      }

      else
      {
        llvm::raw_ostream::write(v96, ", ", 2uLL);
      }

      v98 = OUTLINED_FUNCTION_38_4();
      mlir::detail::OpResultImpl::getNextResultAtOffset(v98, v99);
      OUTLINED_FUNCTION_104();
      v100 = OUTLINED_FUNCTION_12_4();
      v101(v100);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v102, ")", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v102, v103);
  }

LABEL_63:
  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v104, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v104, v105);
  }

  OUTLINED_FUNCTION_44_6();
  OUTLINED_FUNCTION_104();
  v106 = OUTLINED_FUNCTION_113_4();
  v107(v106);
  __p = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(&__p);
  OUTLINED_FUNCTION_108_2();
  OUTLINED_FUNCTION_82_6();
  __p = mlir::OpaqueAttr::getAttrData(v108);
  v124 = v109;
  OUTLINED_FUNCTION_108_2();
  v121 = *(v110 + 16);
  AttrData = mlir::OpaqueAttr::getAttrData(&v121);
  v126 = v111;
  OUTLINED_FUNCTION_108_2();
  OUTLINED_FUNCTION_86_0();
  v127 = mlir::OpaqueAttr::getAttrData(v112);
  v128 = v113;
  v129 = "operandSegmentSizes";
  v130 = 19;
  OUTLINED_FUNCTION_104();
  v114 = OUTLINED_FUNCTION_88_2();
  return v115(v114);
}

uint64_t mlir::affine::AffineForOp::fold(void **a1, uint64_t a2, uint64_t a3)
{
  v87[4] = *MEMORY[0x1E69E9840];
  v82 = *a1;
  v80 = &v82;
  OUTLINED_FUNCTION_13_17();
  Value = v4;
  Value = mlir::AffineMapAttr::getValue(&Value);
  if (mlir::AffineMap::isSingleConstant(&Value))
  {
    v5 = 0;
  }

  else
  {
    v5 = foldLoopBounds(mlir::affine::AffineForOp)::$_0::operator()(&v80, 1);
  }

  OUTLINED_FUNCTION_13_12();
  Value = *(v6 + 80);
  Value = mlir::AffineMapAttr::getValue(&Value);
  if (!mlir::AffineMap::isSingleConstant(&Value))
  {
    v5 |= foldLoopBounds(mlir::affine::AffineForOp)::$_0::operator()(&v80, 0);
  }

  v7 = *a1;
  v79 = v7;
  v8 = (v7 + 8);
  v9 = *(v7 + 11);
  v10 = (v9 >> 23) & 1;
  v11 = LODWORD(v7[2 * v10 + 11]);
  if ((v9 & 0x800000) != 0)
  {
    v12 = v7[9];
  }

  else
  {
    v12 = 0;
  }

  Value = v87;
  v86 = 0x400000000;
  if (v11 < 5)
  {
    if (!v11)
    {
      v22 = 0;
      goto LABEL_23;
    }

    v13 = 0;
    v14 = v87;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&Value, v87, v11, 8);
    v13 = v86;
    v14 = Value;
  }

  v15 = &v14[v13];
  if (v11 >= 0xD)
  {
    v16 = &v14[v13 + v11];
    v17 = v15 >= v12 + 32 * v11 || v12 + 24 >= v16;
    if (v17)
    {
      v18 = (v15 + 2);
      do
      {
        OUTLINED_FUNCTION_35_7(v18);
      }

      while (v20 != 4);
      v15 = v19;
    }
  }

  do
  {
    OUTLINED_FUNCTION_107_3(v15);
  }

  while (v21 != 1);
  v22 = v86;
  v9 = *(v7 + 11);
  v10 = (v9 >> 23) & 1;
LABEL_23:
  v23 = v9 & 0x800000;
  LODWORD(v86) = v22 + v11;
  v24 = &v8[16 * v10];
  v26 = *(v24 + 6);
  v25 = *(v24 + 7);
  if (v23)
  {
    v27 = v7[9];
  }

  else
  {
    v27 = 0;
  }

  v28 = (v25 + v26);
  v29 = v28 - v26;
  v82 = v84;
  v83 = 0x400000000;
  if ((v28 - v26) < 5)
  {
    if (!v25)
    {
      goto LABEL_40;
    }

    v30 = 0;
    v31 = v84;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v82, v84, v28 - v26, 8);
    v30 = v83;
    v31 = v82;
  }

  v32 = &v31[8 * v30];
  if (v29 >= 0x13)
  {
    v33 = &v31[8 * (v30 + v28 - v26)];
    if (v32 >= v27 + 32 * v28 || v27 + 32 * v26 + 24 >= v33)
    {
      OUTLINED_FUNCTION_115_3();
      do
      {
        OUTLINED_FUNCTION_35_7(v35);
      }

      while (v37 != -4);
      v32 = v36;
    }
  }

  do
  {
    OUTLINED_FUNCTION_107_3(v32);
  }

  while (v38 != -1);
  v25 = v83;
  v10 = (*(v7 + 11) >> 23) & 1;
LABEL_40:
  LODWORD(v83) = v25 + v29;
  v80 = *&v8[16 * v10];
  v39 = mlir::AffineMapAttr::getValue(&v80);
  v78 = v39;
  v80 = *&v8[16 * ((*(v7 + 11) >> 23) & 1) + 16];
  v40 = mlir::AffineMapAttr::getValue(&v80);
  v77 = v40;
  composeAffineMapAndOperands(&v78, &Value);
  mlir::affine::canonicalizeMapAndOperands(&v78, &Value);
  simplifyMinOrMaxExprWithOperands(&v78, Value, v86, 1);
  simplifyMinOrMaxExprWithOperands(&v77, v82, v83, 0);
  v78 = mlir::removeDuplicateExprs(v78);
  composeAffineMapAndOperands(&v77, &v82);
  mlir::affine::canonicalizeMapAndOperands(&v77, &v82);
  v41 = mlir::removeDuplicateExprs(v77);
  v77 = v41;
  v42 = v78 == v39 && v41 == v40;
  v43 = !v42;
  if (!v42)
  {
    if (v78 != v39)
    {
      mlir::ValueRange::ValueRange(&v80, Value, v86);
      mlir::affine::AffineForOp::setLowerBound(&v79, v80, v81, v78);
      v41 = v77;
    }

    if (v41 != v40)
    {
      mlir::ValueRange::ValueRange(&v80, v82, v83);
      mlir::affine::AffineForOp::setUpperBound(&v79, v80, v81, v77);
    }
  }

  if (v82 != v84)
  {
    free(v82);
  }

  if (Value != v87)
  {
    free(Value);
  }

  v44 = v5 | v43;
  if ((v46 & 1) != 0 && !TrivialConstantTripCount)
  {
    v47 = *a1;
    if (*(*a1 + 9))
    {
      v48 = *(v47 + 11);
      v49 = &v47[2 * ((v48 >> 23) & 1)];
      v50 = v49[24];
      if ((v48 & 0x800000) != 0)
      {
        v51 = v47[9];
      }

      else
      {
        v51 = 0;
      }

      v52 = a3;
      v53 = (v49[23] + v49[22]);
      v54 = (v50 + v53);
      v55 = v54 - v53;
      *(a3 + 8) = 0;
      if (v54 - v53 <= *(a3 + 12))
      {
        v56 = 0;
        v57 = 0;
        if (!v50)
        {
LABEL_82:
          *(v52 + 8) = v57 + v55;
          v44 = 1;
          return v44 & 1;
        }
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, a3 + 16, v54 - v53, 8);
        v52 = a3;
        v56 = *(a3 + 8);
        v57 = *(a3 + 8);
        if (!v50)
        {
          goto LABEL_82;
        }
      }

      v58 = (*v52 + 8 * v56);
      if (v55 >= 0x11 && ((v59 = *v52 + 8 * (v56 + v54 - v53), v60 = v51 + 32 * v53, v58 < v51 + 32 * v54) ? (v61 = v60 + 24 >= v59) : (v61 = 1), v61))
      {
        if ((v55 & 3) != 0)
        {
          v62 = v55 & 3;
        }

        else
        {
          v62 = 4;
        }

        v63 = v55 - v62;
        v64 = (v58 + 8 * (v55 - v62));
        v65 = (v60 + 88);
        v66 = v58 + 1;
        v67 = v62 + v53 - v54;
        do
        {
          v68 = v65 - 8;
          v69 = vld4q_f64(v68);
          v70 = vld4q_f64(v65);
          v71 = vdupq_n_s64(4uLL);
          v66[-1] = vorrq_s8(v69, v71);
          *v66 = vorrq_s8(v70, v71);
          v65 += 16;
          v66 += 2;
          v67 += 4;
        }

        while (v67);
        v58 = v64;
      }

      else
      {
        v63 = 0;
      }

      v72 = v63 + v53 - v54;
      v73 = (32 * v63 + 32 * v53 + v51 + 24);
      do
      {
        v74 = *v73;
        v73 += 4;
        v58->i64[0] = v74 | 4;
        v58 = (v58 + 8);
        v17 = __CFADD__(v72++, 1);
      }

      while (!v17);
      v57 = *(v52 + 8);
      goto LABEL_82;
    }
  }

  return v44 & 1;
}

double mlir::affine::AffineForOp::replaceWithAdditionalYields@<D0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, unint64_t a4@<X3>, int a5@<W4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  v113[3] = *MEMORY[0x1E69E9840];
  v11 = (a2 + 24);
  v98 = *(a2 + 24);
  v12 = *a1;
  v13 = *(v12 + 16);
  v14 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v12, a2);
  *v11 = v13;
  v11[1] = v14;
  OUTLINED_FUNCTION_81_6();
  v19 = *(v18 + 96);
  if ((v20 & 0x800000) != 0)
  {
    v21 = *(v17 + 72);
  }

  else
  {
    v21 = 0;
  }

  v22 = (v16 + v15);
  v23 = (v19 + v22);
  v24 = v23 - v22;
  v105 = v107;
  v106 = 0x600000000;
  if ((v23 - v22) < 7)
  {
    if (!v19)
    {
      v34 = 6;
      goto LABEL_18;
    }

    v25 = 0;
    v26 = v107;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v105, v107, v23 - v22, 8);
    v25 = v106;
    v26 = v105;
  }

  v27 = &v26[8 * v25];
  if (v24 >= 0x13)
  {
    v28 = &v26[8 * (v25 + v23 - v22)];
    if (v27 >= &v21[4 * v23] || &v21[4 * v22 + 3] >= v28)
    {
      OUTLINED_FUNCTION_115_3();
      do
      {
        OUTLINED_FUNCTION_35_7(v30);
      }

      while (v32 != -4);
      v27 = v31;
    }
  }

  do
  {
    OUTLINED_FUNCTION_107_3(v27);
  }

  while (v33 != -1);
  v19 = v106;
  v34 = HIDWORD(v106);
LABEL_18:
  v35 = (v19 + v24);
  LODWORD(v106) = v35;
  if (a4 + v35 > v34)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v105, v107, a4 + v35, 8);
    v35 = v106;
  }

  __p = a3;
  v103 = 0;
  if (a4)
  {
    v36 = 0;
    v21 = (v105 + 8 * v35);
    do
    {
      *v21++ = mlir::ValueRange::dereference_iterator(&__p, v36);
      v36 = v103 + 1;
      v103 = v36;
    }

    while (v36 != a4);
    LODWORD(v35) = v106;
  }

  v93 = a3;
  LODWORD(v106) = v35 + a4;
  v37 = *a1;
  v38 = *(*a1 + 44);
  v39 = *a1 + 16 * ((v38 >> 23) & 1);
  v40 = *(v39 + 88);
  if ((v38 & 0x800000) != 0)
  {
    v41 = *(v37 + 72);
  }

  else
  {
    v41 = 0;
  }

  v42 = *(v37 + 24);
  v110 = v41;
  v111 = v40;
  __p = *(v39 + 64);
  Value = mlir::AffineMapAttr::getValue(&__p);
  OUTLINED_FUNCTION_81_6();
  if ((v47 & 0x800000) != 0)
  {
    v48 = *(v46 + 72);
  }

  else
  {
    v48 = 0;
  }

  v108 = v48 + 32 * v44;
  v109 = (v45 + v44) - v44;
  __p = *(v43 + 80);
  v99 = mlir::AffineMapAttr::getValue(&__p);
  OUTLINED_FUNCTION_13_12();
  v101 = *(v49 + 72);
  mlir::IntegerAttr::getValue(&v101, &__p);
  if (v103 > 0x40)
  {
    v21 = *__p;
    operator delete[](__p);
  }

  else
  {
    OUTLINED_FUNCTION_121_2();
  }

  __p = v21;
  mlir::OpBuilder::create<mlir::affine::AffineForOp,mlir::OperandRange,mlir::AffineMap,mlir::OperandRange,mlir::AffineMap,long long,llvm::SmallVector<mlir::Value,6u> &>((v11 - 2), v42, &v110, &Value, &v108, &v99, &__p, &v105);
  OUTLINED_FUNCTION_44_6();
  v101 = v50;
  OUTLINED_FUNCTION_8_14();
  if (v82)
  {
    v53 = 0;
  }

  else
  {
    v53 = v52;
  }

  Terminator = mlir::Block::getTerminator(v53, v51);
  OUTLINED_FUNCTION_10_14();
  OUTLINED_FUNCTION_147_1();
  if (v82)
  {
    v58 = 0;
  }

  else
  {
    v58 = v57;
  }

  v59 = *(v58 + 48);
  v60 = (*(v58 + 56) - v59) >> 3;
  if (v60 <= a4)
  {
    v61 = v59;
  }

  else
  {
    v61 = &v59[v60 - a4];
  }

  if (v60 >= a4)
  {
    v62 = a4;
  }

  else
  {
    v62 = v60;
  }

  v94 = *(a2 + 24);
  v63 = *(v55 + 16);
  v64 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v55, v56);
  *(a2 + 24) = v63;
  *(a2 + 32) = v64;
  v108 = *(*a1 + 24);
  v110 = v61;
  v111 = v62;
  v65 = *(a6 + 24);
  if (!v65)
  {
    std::__throw_bad_function_call[abi:nn200100]();
  }

  (*(*v65 + 48))(&__p);
  OUTLINED_FUNCTION_63();
  (*(v66 + 40))(a2, Terminator);
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v67 = *(Terminator + 68);
  }

  else
  {
    v67 = 0;
  }

  mlir::MutableOperandRange::MutableOperandRange(&v110, Terminator, 0, v67, 0, 0);
  mlir::ValueRange::ValueRange(&v108, __p, v103);
  mlir::MutableOperandRange::append(&v110, v108, v109);
  if (v112 != v113)
  {
    free(v112);
  }

  (*(*a2 + 48))(a2, Terminator);
  OUTLINED_FUNCTION_65_4();
  if (!v82)
  {
    free(v68);
  }

  if (v94)
  {
    *v11 = v94;
  }

  else
  {
    *v11 = 0;
    v11[1] = 0;
  }

  OUTLINED_FUNCTION_44_6();
  OUTLINED_FUNCTION_8_14();
  if (v82)
  {
    v70 = 0;
  }

  else
  {
    v70 = v69;
  }

  v71 = v101;
  OUTLINED_FUNCTION_10_14();
  OUTLINED_FUNCTION_147_1();
  if (v82)
  {
    v73 = 0;
  }

  else
  {
    v73 = v72;
  }

  v74 = *(v73 + 48);
  v75 = (*(v70 + 56) - *(v70 + 48)) >> 3;
  if ((*(v73 + 56) - v74) >> 3 >= v75)
  {
    v76 = v75;
  }

  else
  {
    v76 = (*(v73 + 56) - v74) >> 3;
  }

  mlir::ValueRange::ValueRange(&__p, v74, v76);
  mlir::RewriterBase::mergeBlocks(a2, v70, v73, __p, v103);
  if (a5)
  {
    __p = v93;
    v103 = 0;
    v104 = v61;
    if (a4)
    {
      if (v62)
      {
        v77 = 0;
        v78 = &v61[v62];
        do
        {
          v79 = mlir::ValueRange::dereference_iterator(&__p, v77);
          v80 = *v104;
          v110 = &v101;
          mlir::RewriterBase::replaceUsesWithIf(a2, v79, v80, llvm::function_ref<BOOL ()(mlir::OpOperand &)>::callback_fn<mlir::affine::AffineForOp::replaceWithAdditionalYields(mlir::RewriterBase &,mlir::ValueRange,BOOL,std::function<llvm::SmallVector<mlir::Value,6u> ()(mlir::OpBuilder &,mlir::Location,llvm::ArrayRef<mlir::BlockArgument>)> const&)::$_1>, &v110, 0);
          v77 = v103 + 1;
          v81 = v104 + 1;
          v103 = v77;
          ++v104;
          v82 = v77 == a4 || v81 == v78;
        }

        while (!v82);
        v71 = v101;
      }
    }
  }

  v83 = *a1;
  v84 = *(v71 + 36);
  if (v84)
  {
    v85 = v71 - 16;
  }

  else
  {
    v85 = 0;
  }

  v86 = *(v83 + 36);
  if (v84 >= v86)
  {
    v87 = v86;
  }

  else
  {
    v87 = v84;
  }

  mlir::ValueRange::ValueRange(&__p, v85, v87);
  OUTLINED_FUNCTION_63();
  (*v88)(a2, v83);
  v89 = v101;
  if (v101)
  {
    InterfaceFor = mlir::OpInterface<mlir::LoopLikeOpInterface,mlir::detail::LoopLikeOpInterfaceInterfaceTraits>::getInterfaceFor(v101);
  }

  else
  {
    InterfaceFor = 0;
  }

  v91 = v98;
  *a7 = v89;
  *(a7 + 8) = InterfaceFor;
  *(a7 + 16) = 1;
  if (v105 != v107)
  {
    free(v105);
    v91 = v98;
  }

  if (v91)
  {
    *v11 = v91;
  }

  else
  {
    *v11 = 0;
    v11[1] = 0;
  }

  return *&v91;
}

uint64_t mlir::affine::AffineIfOp::print(mlir::affine::AffineIfOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v5 = *v4;
  if (!*(*v4 + 47) || (v46.var0 = "condition", v46.var1 = 9, InherentAttr = mlir::Operation::getInherentAttr(*v4, v46), (v7 & 1) == 0))
  {
    v47.var0 = "condition";
    v47.var1 = 9;
    InherentAttr = mlir::DictionaryAttr::get((v5 + 56), v47);
  }

  if (InherentAttr)
  {
    OUTLINED_FUNCTION_24_6();
    if (v9 == &mlir::detail::TypeIDResolver<mlir::IntegerSetAttr,void>::id)
    {
      v10 = v8;
    }

    else
    {
      v10 = 0;
    }
  }

  else
  {
    v10 = 0;
  }

  v44 = v10;
  OUTLINED_FUNCTION_104();
  (*(v11 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v12, " ", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v12, v13);
  }

  v15 = OUTLINED_FUNCTION_88_2();
  v16(v15);
  OUTLINED_FUNCTION_47_0();
  if (v17 < 0)
  {
    OUTLINED_FUNCTION_143_1();
  }

  else
  {
    OUTLINED_FUNCTION_141_1();
  }

  mlir::AffineMapAttr::getValue(&v44);
  OUTLINED_FUNCTION_38_10();
  NumDims = mlir::AffineMap::getNumDims(v18);
  OUTLINED_FUNCTION_117_3(NumDims);
  OUTLINED_FUNCTION_34_2();
  v45[0] = v20;
  v45[1] = v21;
  mlir::OperandRange::getTypes(v45, &v41);
  if (v42 != v43)
  {
    v22 = OUTLINED_FUNCTION_105_4();
    mlir::AsmPrinter::printArrowTypeList<mlir::ValueTypeRange<mlir::ResultRange> &>(v22, v23);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v26)
  {
    llvm::raw_ostream::write(v24, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v24, v25);
  }

  OUTLINED_FUNCTION_48_6();
  OUTLINED_FUNCTION_77_3();
  v27 = OUTLINED_FUNCTION_113_4();
  v28(v27);
  OUTLINED_FUNCTION_10_14();
  if (*(v30 + 32 * v31 + 24) != v30 + 32 * v31 + 24)
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v34 > 5)
    {
      *(v33 + 4) = 8293;
      OUTLINED_FUNCTION_105_3(v32, v33);
    }

    else
    {
      llvm::raw_ostream::write(v32, " else ", 6uLL);
    }

    v35 = OUTLINED_FUNCTION_88_2();
    v36(v35);
    v29 = *v3;
  }

  mlir::Operation::getAttrDictionary(v29);
  OUTLINED_FUNCTION_38_10();
  mlir::ArrayAttr::getValue(v37);
  OUTLINED_FUNCTION_126_4();
  v41 = "condition";
  v42 = 9;
  OUTLINED_FUNCTION_104();
  v38 = OUTLINED_FUNCTION_29_11();
  return v39(v38);
}

uint64_t mlir::affine::AffineMinOp::verify(mlir::affine::AffineMinOp *this)
{
  OUTLINED_FUNCTION_157_2(*MEMORY[0x1E69E9840]);
  v96 = v2;
  if ((*(v2 + 44) & 0x800000) != 0)
  {
    v3 = *(v2 + 68);
  }

  else
  {
    v3 = 0;
  }

  OUTLINED_FUNCTION_21_11();
  OUTLINED_FUNCTION_134_2(v4, v52, v61, v68, v75, v82, v89, v96, v103);
  OUTLINED_FUNCTION_38_10();
  NumDims = mlir::AffineMap::getNumDims(v5);
  OUTLINED_FUNCTION_13_17();
  OUTLINED_FUNCTION_134_2(v7, v53, v62, v69, v76, v83, v90, v97, v103);
  OUTLINED_FUNCTION_144_3();
  if (v3 != mlir::AffineMap::getNumSymbols(v8) + NumDims)
  {
    OUTLINED_FUNCTION_16_13();
    OUTLINED_FUNCTION_155_3(v11, v54);
    mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v103);
    OUTLINED_FUNCTION_104_4();
    if (v12)
    {
      mlir::InFlightDiagnostic::report(&v103);
    }

    OUTLINED_FUNCTION_103_3();
    if (!v21)
    {
      return NumDims;
    }

    v22 = OUTLINED_FUNCTION_145_2(v13, v14, v15, v16, v17, v18, v19, v20, v56, v63, v70, v77, v84, v91, v98, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, v116, v117, v118, v119, __p, v121, v122, v123, v124, v125, v126);
    if (!v21)
    {
      free(v22);
    }

    v30 = v123;
    if (v123)
    {
      v31 = OUTLINED_FUNCTION_143_0(v22, v23, v24, v25, v26, v27, v28, v29, v57, v65, v72, v79, v86, v93, v100, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, v116, v117, v118, v119, __p, v121, v122, v123, v124);
      if (!v21)
      {
        do
        {
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v31 - 8));
        }

        while (v31 != v30);
        v32 = v123;
      }

      OUTLINED_FUNCTION_135_2(v32, v58, v66, v73, v80, v87, v94, v101, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, v116, v117, v118, v119, __p, v121, v122, v123, v124);
    }

    v33 = __p;
    if (!__p)
    {
LABEL_41:
      v50 = OUTLINED_FUNCTION_103_2(v22, v23, v24, v25, v26, v27, v28, v29, v57, v65, v72, v79, v86, v93, v100, v103, v104, v105, v106);
      if (!v21)
      {
        free(v50);
      }

      return NumDims;
    }

    v34 = OUTLINED_FUNCTION_142_1();
    if (v21)
    {
LABEL_40:
      v121 = v33;
      operator delete(v34);
      goto LABEL_41;
    }

    do
    {
      v35 = OUTLINED_FUNCTION_17_5();
      if (v35)
      {
        operator delete[](v35);
      }
    }

    while (v1 != v33);
LABEL_39:
    v34 = __p;
    goto LABEL_40;
  }

  OUTLINED_FUNCTION_13_17();
  OUTLINED_FUNCTION_134_2(v9, v54, v63, v70, v77, v84, v91, v98, v103);
  OUTLINED_FUNCTION_144_3();
  if (mlir::arith::FastMathFlagsAttr::getValue(v10))
  {
    return 1;
  }

  OUTLINED_FUNCTION_16_13();
  OUTLINED_FUNCTION_155_3(v36, v55);
  mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v103);
  OUTLINED_FUNCTION_104_4();
  if (v37)
  {
    mlir::InFlightDiagnostic::report(&v103);
  }

  OUTLINED_FUNCTION_103_3();
  if (v21)
  {
    v22 = OUTLINED_FUNCTION_145_2(v38, v39, v40, v41, v42, v43, v44, v45, v59, v64, v71, v78, v85, v92, v99, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, v116, v117, v118, v119, __p, v121, v122, v123, v124, v125, v126);
    if (!v21)
    {
      free(v22);
    }

    v46 = v123;
    if (v123)
    {
      v47 = OUTLINED_FUNCTION_143_0(v22, v23, v24, v25, v26, v27, v28, v29, v57, v65, v72, v79, v86, v93, v100, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, v116, v117, v118, v119, __p, v121, v122, v123, v124);
      if (!v21)
      {
        do
        {
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v47 - 8));
        }

        while (v47 != v46);
        v48 = v123;
      }

      OUTLINED_FUNCTION_135_2(v48, v60, v67, v74, v81, v88, v95, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, v116, v117, v118, v119, __p, v121, v122, v123, v124);
    }

    v33 = __p;
    if (!__p)
    {
      goto LABEL_41;
    }

    v34 = OUTLINED_FUNCTION_142_1();
    if (v21)
    {
      goto LABEL_40;
    }

    do
    {
      v49 = OUTLINED_FUNCTION_17_5();
      if (v49)
      {
        operator delete[](v49);
      }
    }

    while (v1 != v33);
    goto LABEL_39;
  }

  return NumDims;
}

uint64_t mlir::affine::AffineMinOp::print(mlir::affine::AffineMinOp *this, mlir::OpAsmPrinter *a2)
{
  v5 = *this;
  OUTLINED_FUNCTION_79_0();
  (*(v6 + 16))(v7);
  OUTLINED_FUNCTION_13_3();
  if (v10)
  {
    v11 = llvm::raw_ostream::write(v8, 32);
  }

  else
  {
    v11 = OUTLINED_FUNCTION_5_2(v8, v9);
  }

  if (!*(v5 + 47) || (v12.var0 = "map", v11 = OUTLINED_FUNCTION_157_3(v11, v12), (v12.var0 & 1) == 0))
  {
    v12.var0 = "map";
    OUTLINED_FUNCTION_156_1(v11, v12);
  }

  OUTLINED_FUNCTION_104();
  v13 = OUTLINED_FUNCTION_120_2();
  v14(v13);
  if ((*(v5 + 44) & 0x800000) != 0)
  {
    v2 = *(v5 + 68);
    v3 = *(v5 + 72);
  }

  else
  {
    OUTLINED_FUNCTION_141_1();
  }

  OUTLINED_FUNCTION_86_0();
  mlir::AffineMapAttr::getValue(v15);
  OUTLINED_FUNCTION_38_10();
  NumDims = mlir::AffineMap::getNumDims(v16);
  OUTLINED_FUNCTION_104();
  (*(v18 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v10)
  {
    llvm::raw_ostream::write(v19, 40);
  }

  else
  {
    OUTLINED_FUNCTION_7_2(v19, v20);
    *v21 = 40;
  }

  if (v2 >= NumDims)
  {
    v22 = NumDims;
  }

  else
  {
    v22 = v2;
  }

  (*(*a2 + 16))(a2);
  if (v22)
  {
    OUTLINED_FUNCTION_104();
    (*(v23 + 160))(a2);
    v24 = v22 - 1;
    if (v22 != 1)
    {
      v25 = v3 + 56;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v27 & v10)
        {
          *v26 = 8236;
          OUTLINED_FUNCTION_29_2();
        }

        else
        {
          v28 = OUTLINED_FUNCTION_38_4();
          llvm::raw_ostream::write(v28, v29, 2uLL);
        }

        v25 += 32;
        OUTLINED_FUNCTION_104();
        (*(v30 + 160))(a2);
        --v24;
      }

      while (v24);
    }
  }

  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v10)
  {
    llvm::raw_ostream::write(v31, 41);
  }

  else
  {
    OUTLINED_FUNCTION_7_2(v31, v32);
    OUTLINED_FUNCTION_96_4(v33);
  }

  if (v2 != NumDims)
  {
    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v10)
    {
      llvm::raw_ostream::write(v34, 91);
    }

    else
    {
      OUTLINED_FUNCTION_23_11(v34, v35);
    }

    v36 = v3 + 32 * NumDims;
    OUTLINED_FUNCTION_104();
    (*(v37 + 16))(a2);
    OUTLINED_FUNCTION_104();
    (*(v38 + 160))(a2);
    if (v2 - NumDims != 1)
    {
      v39 = ~NumDims + v2;
      v40 = v36 + 56;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v27 & v10)
        {
          *v41 = 8236;
          OUTLINED_FUNCTION_29_2();
        }

        else
        {
          v42 = OUTLINED_FUNCTION_38_4();
          llvm::raw_ostream::write(v42, v43, 2uLL);
        }

        v40 += 32;
        OUTLINED_FUNCTION_104();
        (*(v44 + 160))(a2);
        --v39;
      }

      while (v39);
    }

    (*(*a2 + 16))(a2);
    OUTLINED_FUNCTION_13_3();
    if (v10)
    {
      llvm::raw_ostream::write(v45, 93);
    }

    else
    {
      OUTLINED_FUNCTION_7_2(v45, v46);
      *v47 = 93;
    }
  }

  mlir::Operation::getAttrDictionary(v5);
  OUTLINED_FUNCTION_38_10();
  mlir::ArrayAttr::getValue(v48);
  OUTLINED_FUNCTION_126_4();
  OUTLINED_FUNCTION_104();
  v49 = OUTLINED_FUNCTION_29_11();
  return v50(v49);
}

uint64_t mlir::affine::AffineParallelOp::getUpperBoundsOperands(mlir::affine::AffineParallelOp *this)
{
  OUTLINED_FUNCTION_66_5();
  if ((v2 & 0x800000) != 0)
  {
    v3 = *(v1 + 72);
  }

  else
  {
    v3 = 0;
  }

  OUTLINED_FUNCTION_25_11();
  OUTLINED_FUNCTION_86_0();
  mlir::AffineMapAttr::getValue(v4);
  OUTLINED_FUNCTION_38_10();
  return v3 + 32 * mlir::AffineMap::getNumInputs(v5);
}

uint64_t mlir::affine::AffineParallelOp::getLowerBoundsValueMap(mlir::affine::AffineParallelOp *this)
{
  v25[2] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_13_12();
  OUTLINED_FUNCTION_82_6();
  mlir::AffineMapAttr::getValue(v2);
  v3 = *this;
  if ((*(*this + 44) & 0x800000) != 0)
  {
    v4 = *(v3 + 72);
    v5 = *(v3 + 68);
  }

  else
  {
    v4 = 0;
    v5 = 0;
  }

  OUTLINED_FUNCTION_25_11();
  OUTLINED_FUNCTION_82_6();
  mlir::AffineMapAttr::getValue(v6);
  OUTLINED_FUNCTION_88_4();
  NumInputs = mlir::AffineMap::getNumInputs(v7);
  if (v5 >= NumInputs)
  {
    v9 = NumInputs;
  }

  else
  {
    v9 = v5;
  }

  mlir::ValueRange::ValueRange(v25, v4, v9);
  OUTLINED_FUNCTION_44_0();
  v13 = mlir::ValueRange::ValueRange(v10, v11, v12);
  return OUTLINED_FUNCTION_153_3(v13, v14, v15, v16, v17, v18, v19, v20, v22, v23, v24, v25[0], v25[1]);
}

uint64_t mlir::affine::AffineParallelOp::getUpperBoundsValueMap(mlir::affine::AffineParallelOp *this)
{
  v24[2] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_13_12();
  OUTLINED_FUNCTION_82_6();
  mlir::AffineMapAttr::getValue(v2);
  v3 = *this;
  if ((*(*this + 44) & 0x800000) != 0)
  {
    v4 = *(v3 + 72);
    v5 = *(v3 + 68);
  }

  else
  {
    v4 = 0;
    v5 = 0;
  }

  OUTLINED_FUNCTION_25_11();
  OUTLINED_FUNCTION_82_6();
  mlir::AffineMapAttr::getValue(v6);
  OUTLINED_FUNCTION_88_4();
  NumInputs = mlir::AffineMap::getNumInputs(v7);
  mlir::ValueRange::ValueRange(v24, v4 + 32 * NumInputs, v5 - NumInputs);
  OUTLINED_FUNCTION_44_0();
  v12 = mlir::ValueRange::ValueRange(v9, v10, v11);
  return OUTLINED_FUNCTION_153_3(v12, v13, v14, v15, v16, v17, v18, v19, v21, v22, v23, v24[0], v24[1]);
}

void mlir::affine::AffineParallelOp::setLowerBounds(uint64_t **a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  v41 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_66_5();
  if ((v9 & 0x800000) != 0)
  {
    v10 = *(v8 + 72);
    v11 = *(v8 + 68);
  }

  else
  {
    v10 = 0;
    v11 = 0;
  }

  OUTLINED_FUNCTION_25_11();
  OUTLINED_FUNCTION_86_0();
  Value = mlir::AffineMapAttr::getValue(v12);
  NumInputs = mlir::AffineMap::getNumInputs(&Value);
  v14 = v11 - NumInputs;
  Value = v38;
  v37 = 0x400000000;
  if (a3 < 5)
  {
    v18 = 0;
    v39 = a2;
    v40 = 0;
    v19 = v38;
    if (!a3)
    {
      v23 = 0;
      v22 = 4;
      goto LABEL_9;
    }
  }

  else
  {
    OUTLINED_FUNCTION_85_5();
    llvm::SmallVectorBase<unsigned int>::grow_pod(v15, v16, v17, 8);
    v18 = v37;
    v19 = Value;
    v39 = a2;
    v40 = 0;
  }

  v20 = 0;
  v21 = &v19[8 * v18];
  do
  {
    *v21++ = mlir::ValueRange::dereference_iterator(&v39, v20);
    v20 = v40 + 1;
    v40 = v20;
  }

  while (v20 != a3);
  v23 = v37;
  v22 = HIDWORD(v37);
LABEL_9:
  v24 = (v23 + a3);
  LODWORD(v37) = v24;
  if (v14 + v24 > v22)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&Value, v38, v14 + v24, 8);
    v24 = v37;
  }

  v25 = Value;
  if (v11 != NumInputs)
  {
    v26 = Value + 8 * v24;
    if (v14 >= 0x13)
    {
      v27 = Value + 8 * (v24 + v11 - NumInputs);
      if (v26 >= v10 + 32 * v11 || v10 + 32 * NumInputs + 24 >= v27)
      {
        OUTLINED_FUNCTION_115_3();
        do
        {
          OUTLINED_FUNCTION_35_7(v29);
        }

        while (v31 != -4);
        v26 = v30;
      }
    }

    do
    {
      OUTLINED_FUNCTION_107_3(v26);
    }

    while (v32 != -1);
    LODWORD(v24) = v37;
    v25 = Value;
  }

  LODWORD(v37) = v24 + v14;
  v33 = *a1;
  mlir::ValueRange::ValueRange(&v39, v25, (v24 + v14));
  mlir::Operation::setOperands(v33, v39, v40);
  mlir::AffineMapAttr::get(a4);
  OUTLINED_FUNCTION_13_12();
  *(v35 + 72) = v34;
  if (Value != v38)
  {
    free(Value);
  }
}

void mlir::affine::AffineParallelOp::setUpperBounds(uint64_t **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v39 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_66_5();
  if ((v9 & 0x800000) != 0)
  {
    v10 = *(v8 + 72);
    v11 = *(v8 + 68);
  }

  else
  {
    v10 = 0;
    v11 = 0;
  }

  OUTLINED_FUNCTION_25_11();
  OUTLINED_FUNCTION_86_0();
  Value = mlir::AffineMapAttr::getValue(v12);
  NumInputs = mlir::AffineMap::getNumInputs(&Value);
  if (v11 >= NumInputs)
  {
    v14 = NumInputs;
  }

  else
  {
    v14 = v11;
  }

  Value = v36;
  v35 = 0x400000000;
  if (v14 < 5)
  {
    if (!v14)
    {
      v25 = 0;
      v24 = 4;
      goto LABEL_21;
    }

    v15 = 0;
    v16 = v36;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&Value, v36, v14, 8);
    v15 = v35;
    v16 = Value;
  }

  v17 = &v16[8 * v15];
  if (v14 >= 0xD)
  {
    v18 = &v16[8 * v15 + 8 * v14];
    if (v17 >= v10 + 32 * v14 || v10 + 24 >= v18)
    {
      v20 = (v17 + 2);
      do
      {
        OUTLINED_FUNCTION_35_7(v20);
      }

      while (v22 != 4);
      v17 = v21;
    }
  }

  do
  {
    OUTLINED_FUNCTION_107_3(v17);
  }

  while (v23 != 1);
  v25 = v35;
  v24 = HIDWORD(v35);
LABEL_21:
  v26 = (v25 + v14);
  LODWORD(v35) = v26;
  if (a3 + v26 > v24)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&Value, v36, a3 + v26, 8);
    v26 = v35;
  }

  v27 = Value;
  v37 = a2;
  v38 = 0;
  if (a3)
  {
    v28 = 0;
    v29 = (Value + 8 * v26);
    do
    {
      *v29++ = mlir::ValueRange::dereference_iterator(&v37, v28);
      v28 = v38 + 1;
      v38 = v28;
    }

    while (v28 != a3);
    LODWORD(v26) = v35;
    v27 = Value;
  }

  v30 = (v26 + a3);
  LODWORD(v35) = v26 + a3;
  v31 = *a1;
  mlir::ValueRange::ValueRange(&v37, v27, v30);
  mlir::Operation::setOperands(v31, v37, v38);
  mlir::AffineMapAttr::get(a4);
  OUTLINED_FUNCTION_13_12();
  *(v33 + 104) = v32;
  if (Value != v36)
  {
    free(Value);
  }
}

uint64_t mlir::affine::AffineParallelOp::fold()
{
  OUTLINED_FUNCTION_157_2(*MEMORY[0x1E69E9840]);
  v30 = v0;
  mlir::affine::AffineParallelOp::getLowerBoundsValueMap(v34, &v30);
  v1 = mlir::affine::AffineValueMap::canonicalize(v34);
  mlir::affine::AffineParallelOp::getUpperBoundsValueMap(v33, &v30);
  v2 = mlir::affine::AffineValueMap::canonicalize(v33);
  v3 = v2;
  if (v1 & 1) != 0 || (v2)
  {
    if (v1)
    {
      Operands = mlir::affine::AffineValueMap::getOperands(v34);
      v14 = OUTLINED_FUNCTION_30_7(Operands, v7, v8, v9, v10, v11, v12, v13, v30, v31);
      mlir::ValueRange::ValueRange(v14, v15, v16);
      AffineMap = mlir::affine::AffineValueMap::getAffineMap(v34);
      mlir::affine::AffineParallelOp::setLowerBounds(&v30, v31, v32, AffineMap);
      if ((v3 & 1) == 0)
      {
        goto LABEL_6;
      }
    }

    else if ((v2 & 1) == 0)
    {
LABEL_6:
      v4 = 1;
      goto LABEL_7;
    }

    v18 = mlir::affine::AffineValueMap::getOperands(v33);
    v26 = OUTLINED_FUNCTION_30_7(v18, v19, v20, v21, v22, v23, v24, v25, v30, v31);
    mlir::ValueRange::ValueRange(v26, v27, v28);
    v29 = mlir::affine::AffineValueMap::getAffineMap(v33);
    mlir::affine::AffineParallelOp::setUpperBounds(&v30, v31, v32, v29);
    goto LABEL_6;
  }

  v4 = 0;
LABEL_7:
  mlir::affine::AffineValueMap::~AffineValueMap(v33);
  mlir::affine::AffineValueMap::~AffineValueMap(v34);
  return v4;
}

void mlir::affine::AffineParallelOp::print(mlir::affine::AffineParallelOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v137 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_25_2();
  if (!v9 & v8)
  {
    *v7 = 10272;
    OUTLINED_FUNCTION_24_2(v6);
  }

  else
  {
    llvm::raw_ostream::write(v6, " (", 2uLL);
  }

  OUTLINED_FUNCTION_44_6();
  OUTLINED_FUNCTION_8_14();
  if (v9)
  {
    v11 = 0;
  }

  else
  {
    v11 = v10;
  }

  v12 = *(v11 + 48);
  v13 = *(v11 + 56);
  OUTLINED_FUNCTION_104();
  (*(v14 + 16))(v2);
  if (v13 != v12)
  {
    OUTLINED_FUNCTION_104();
    (*(v15 + 160))(v2);
    if (v13 - v12 != 8)
    {
      v16 = v12 + 8;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v9 & v8)
        {
          *v17 = 8236;
          OUTLINED_FUNCTION_29_2();
        }

        else
        {
          v18 = OUTLINED_FUNCTION_38_4();
          llvm::raw_ostream::write(v18, v19, 2uLL);
        }

        v16 += 8;
        OUTLINED_FUNCTION_104();
        (*(v20 + 160))(v2);
      }

      while (v16 != v13);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v23 > 4)
  {
    *(v22 + 4) = 40;
    OUTLINED_FUNCTION_160(v22);
    *(v25 + 32) = v24 + 5;
  }

  else
  {
    llvm::raw_ostream::write(v21, ") = (", 5uLL);
  }

  OUTLINED_FUNCTION_48_6();
  v28 = *(v27 + 64);
  v29 = *(v27 + 72);
  if ((v30 & 0x800000) != 0)
  {
    v31 = *(v26 + 72);
    v32 = *(v26 + 68);
  }

  else
  {
    v31 = 0;
    v32 = 0;
  }

  v123 = *(v27 + 72);
  mlir::AffineMapAttr::getValue(&v123);
  OUTLINED_FUNCTION_88_4();
  NumInputs = mlir::AffineMap::getNumInputs(v33);
  if (v32 >= NumInputs)
  {
    v35 = NumInputs;
  }

  else
  {
    v35 = v32;
  }

  mlir::ValueRange::ValueRange(&v123, v31, v35);
  printMinMaxBound(v2, v29, v28, v123, v124, "max", 3uLL);
  OUTLINED_FUNCTION_104();
  (*(v36 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v39 > 5)
  {
    OUTLINED_FUNCTION_116_4(v38);
    OUTLINED_FUNCTION_105_3(v40, v41);
  }

  else
  {
    llvm::raw_ostream::write(v37, ") to (", 6uLL);
  }

  v42 = *v3;
  v43 = *(*v3 + 44);
  v44 = *(*v3 + 64 + 16 * ((v43 >> 23) & 1) + 32);
  if ((v43 & 0x800000) != 0)
  {
    v45 = *(v42 + 72);
    v46 = *(v42 + 68);
  }

  else
  {
    v45 = 0;
    v46 = 0;
  }

  OUTLINED_FUNCTION_82_6();
  mlir::AffineMapAttr::getValue(v47);
  OUTLINED_FUNCTION_88_4();
  v49 = mlir::AffineMap::getNumInputs(v48);
  mlir::ValueRange::ValueRange(&v123, v45 + 32 * v49, v46 - v49);
  v50 = OUTLINED_FUNCTION_88_2();
  printMinMaxBound(v50, v51, v44, v52, v53, v54, 3uLL);
  OUTLINED_FUNCTION_104();
  (*(v55 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v56, 41);
  }

  else
  {
    OUTLINED_FUNCTION_7_2(v56, v57);
    OUTLINED_FUNCTION_96_4(v58);
  }

  mlir::affine::AffineParallelOp::getSteps(v3, &v135);
  if (v136)
  {
    v59 = v135;
    v60 = 8 * v136;
    while (*v59 == 1)
    {
      ++v59;
      v60 -= 8;
      if (!v60)
      {
        goto LABEL_48;
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v63 > 6)
    {
      *(v62 + 3) = 673214565;
      OUTLINED_FUNCTION_160(v62);
      *(v65 + 32) = v64 + 7;
    }

    else
    {
      llvm::raw_ostream::write(v61, " step (", 7uLL);
    }

    v66 = v136;
    if (v136)
    {
      v67 = v135;
      OUTLINED_FUNCTION_104();
      v69 = (*(v68 + 16))(v2);
      llvm::raw_ostream::operator<<(v69, *v67);
      if (v66 != 1)
      {
        v70 = v67 + 1;
        v71 = 8 * v66 - 8;
        do
        {
          (*(*v2 + 16))(v2);
          OUTLINED_FUNCTION_25_2();
          if (!v9 & v8)
          {
            *v73 = 8236;
            OUTLINED_FUNCTION_24_2(v72);
          }

          else
          {
            llvm::raw_ostream::write(v72, ", ", 2uLL);
          }

          v74 = (*(*v2 + 16))(v2);
          v75 = *v70++;
          llvm::raw_ostream::operator<<(v74, v75);
          v71 -= 8;
        }

        while (v71);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v8)
    {
      llvm::raw_ostream::write(v76, 41);
    }

    else
    {
      OUTLINED_FUNCTION_7_2(v76, v77);
      OUTLINED_FUNCTION_96_4(v78);
    }
  }

LABEL_48:
  if (*(*v3 + 36))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v81 > 8)
    {
      *(v80 + 8) = 40;
      *v80 = *" reduce (";
      v79[4] += 9;
    }

    else
    {
      llvm::raw_ostream::write(v79, " reduce (", 9uLL);
    }

    OUTLINED_FUNCTION_13_12();
    OUTLINED_FUNCTION_86_0();
    Value = mlir::ArrayAttr::getValue(v82);
    v84 = mlir::ArrayAttr::getValue(v122);
    v86 = (v84 + 8 * v85);
    v123 = v2;
    if (v86 != Value)
    {
      v88 = *Value;
      v87 = Value + 1;
      mlir::affine::AffineParallelOp::print(mlir::OpAsmPrinter &)::$_1::operator()<mlir::Attribute const>(&v123, v88);
      while (v87 != v86)
      {
        (*(*v2 + 16))(v2);
        OUTLINED_FUNCTION_25_2();
        if (!v9 & v8)
        {
          *v90 = 8236;
          OUTLINED_FUNCTION_24_2(v89);
        }

        else
        {
          llvm::raw_ostream::write(v89, ", ", 2uLL);
        }

        v91 = *v87++;
        mlir::affine::AffineParallelOp::print(mlir::OpAsmPrinter &)::$_1::operator()<mlir::Attribute const>(&v123, v91);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v94 > 5)
    {
      OUTLINED_FUNCTION_116_4(v93);
      OUTLINED_FUNCTION_105_3(v95, v96);
    }

    else
    {
      llvm::raw_ostream::write(v92, ") -> (", 6uLL);
    }

    OUTLINED_FUNCTION_34_2();
    v122[0] = v97;
    v122[1] = v98;
    mlir::OperandRange::getTypes(v122, &v123);
    v99 = v124;
    v100 = v126;
    if (v124 != v126)
    {
      v101 = OUTLINED_FUNCTION_38_4();
      mlir::detail::OpResultImpl::getNextResultAtOffset(v101, v102);
      OUTLINED_FUNCTION_104();
      v103 = OUTLINED_FUNCTION_12_4();
      v104(v103);
      for (i = v99 + 1; v100 != i; ++i)
      {
        (*(*v2 + 16))(v2);
        OUTLINED_FUNCTION_25_2();
        if (!v9 & v8)
        {
          *v107 = 8236;
          OUTLINED_FUNCTION_24_2(v106);
        }

        else
        {
          llvm::raw_ostream::write(v106, ", ", 2uLL);
        }

        v108 = OUTLINED_FUNCTION_38_4();
        mlir::detail::OpResultImpl::getNextResultAtOffset(v108, v109);
        OUTLINED_FUNCTION_104();
        v110 = OUTLINED_FUNCTION_12_4();
        v111(v110);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v9)
    {
      llvm::raw_ostream::write(v112, ")", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v112, v113);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v114, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v114, v115);
  }

  OUTLINED_FUNCTION_48_6();
  OUTLINED_FUNCTION_77_3();
  v116 = OUTLINED_FUNCTION_113_4();
  v117(v116);
  mlir::Operation::getAttrDictionary(*v3);
  OUTLINED_FUNCTION_88_4();
  mlir::ArrayAttr::getValue(v118);
  OUTLINED_FUNCTION_126_4();
  v123 = "reductions";
  v124 = 10;
  v125 = "lowerBoundsMap";
  v126 = 14;
  v127 = "lowerBoundsGroups";
  v128 = 17;
  v129 = "upperBoundsMap";
  v130 = 14;
  v131 = "upperBoundsGroups";
  v132 = 17;
  v133 = "steps";
  v134 = 5;
  OUTLINED_FUNCTION_104();
  v119 = OUTLINED_FUNCTION_120_2();
  v120(v119);
  OUTLINED_FUNCTION_65_4();
  if (!v9)
  {
    free(v121);
  }
}

BOOL mlir::affine::AffineYieldOp::verify(mlir::affine::AffineYieldOp *this)
{
  v89 = *MEMORY[0x1E69E9840];
  v2 = *this;
  ParentOp = *(*this + 16);
  if (ParentOp)
  {
    ParentOp = mlir::Block::getParentOp(ParentOp);
    v2 = *this;
  }

  v4 = *(ParentOp + 36);
  v5 = *(v2 + 44);
  if ((v5 & 0x800000) != 0)
  {
    v6 = *(v2 + 68);
    v7 = *(v2 + 72);
  }

  else
  {
    v7 = 0;
    v6 = 0;
  }

  v8 = *(*(ParentOp + 48) + 16);
  if (v8 != &mlir::detail::TypeIDResolver<mlir::affine::AffineParallelOp,void>::id && v8 != &mlir::detail::TypeIDResolver<mlir::affine::AffineIfOp,void>::id && v8 != &mlir::detail::TypeIDResolver<mlir::affine::AffineForOp,void>::id)
  {
    LOWORD(v73) = 257;
    v29 = OUTLINED_FUNCTION_105_4();
    mlir::OpState::emitOpError(v29, v30, v31);
    if (v77)
    {
      LODWORD(v74) = 3;
      OUTLINED_FUNCTION_55_5();
      if (v21)
      {
        OUTLINED_FUNCTION_5_3();
        OUTLINED_FUNCTION_82_5(v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73);
        v32 = v80;
      }

      OUTLINED_FUNCTION_24_11(v32, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81);
    }

    v16 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v77);
    if (v77)
    {
      mlir::InFlightDiagnostic::report(&v77);
    }

    if (v88 != 1)
    {
      return v16;
    }

    if (v87 != &v88)
    {
      free(v87);
    }

    v33 = __p;
    if (__p)
    {
      v34 = v86;
      v35 = __p;
      if (v86 != __p)
      {
        do
        {
          v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v34 - 1);
        }

        while (v34 != v33);
        v35 = __p;
      }

      v86 = v33;
      operator delete(v35);
    }

    v25 = v83;
    if (!v83)
    {
      goto LABEL_63;
    }

    v36 = v84;
    v27 = v83;
    if (v84 == v83)
    {
LABEL_62:
      v84 = v25;
      operator delete(v27);
LABEL_63:
      v38 = v80;
      if (v80 != v82)
      {
LABEL_64:
        free(v38);
      }

      return v16;
    }

    do
    {
      v37 = OUTLINED_FUNCTION_17_5();
      if (v37)
      {
        operator delete[](v37);
      }
    }

    while (v36 != v25);
LABEL_61:
    v27 = v83;
    goto LABEL_62;
  }

  if ((v5 & 0x800000) != 0)
  {
    v11 = *(v2 + 68);
  }

  else
  {
    v11 = 0;
  }

  if (v4 != v11)
  {
    LOWORD(v73) = 257;
    v17 = OUTLINED_FUNCTION_105_4();
    mlir::OpState::emitOpError(v17, v18, v19);
    if (v77)
    {
      LODWORD(v74) = 3;
      OUTLINED_FUNCTION_55_5();
      if (v21)
      {
        OUTLINED_FUNCTION_5_3();
        OUTLINED_FUNCTION_82_5(v52, v53, v54, v55, v56, v57, v58, v59, v68, v69, v70, v71, v72, v73);
        v20 = v80;
      }

      OUTLINED_FUNCTION_24_11(v20, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81);
    }

    v16 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v77);
    if (v77)
    {
      mlir::InFlightDiagnostic::report(&v77);
    }

    if (v88 != 1)
    {
      return v16;
    }

    if (v87 != &v88)
    {
      free(v87);
    }

    v22 = __p;
    if (__p)
    {
      v23 = v86;
      v24 = __p;
      if (v86 != __p)
      {
        do
        {
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v23 - 1);
        }

        while (v23 != v22);
        v24 = __p;
      }

      v86 = v22;
      operator delete(v24);
    }

    v25 = v83;
    if (!v83)
    {
      goto LABEL_63;
    }

    v26 = v84;
    v27 = v83;
    if (v84 == v83)
    {
      goto LABEL_62;
    }

    do
    {
      v28 = OUTLINED_FUNCTION_17_5();
      if (v28)
      {
        operator delete[](v28);
      }
    }

    while (v26 != v25);
    goto LABEL_61;
  }

  if (v4)
  {
    v12 = 0;
    v13 = v7 + 24;
    while (v6 != v12)
    {
      v14 = OUTLINED_FUNCTION_38_4();
      if ((*(*v13 + 8) ^ *(mlir::detail::OpResultImpl::getNextResultAtOffset(v14, v15) + 8)) >= 8)
      {
        LOWORD(v73) = 257;
        v40 = OUTLINED_FUNCTION_105_4();
        mlir::OpState::emitOpError(v40, v41, v42);
        if (v77)
        {
          LODWORD(v74) = 3;
          OUTLINED_FUNCTION_55_5();
          if (v21)
          {
            OUTLINED_FUNCTION_5_3();
            OUTLINED_FUNCTION_152_3();
            v43 = v80;
          }

          OUTLINED_FUNCTION_24_11(v43, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81);
        }

        v16 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v77);
        if (v77)
        {
          mlir::InFlightDiagnostic::report(&v77);
        }

        if (v88)
        {
          if (v87 != &v88)
          {
            free(v87);
          }

          v44 = __p;
          if (__p)
          {
            v45 = v86;
            v46 = __p;
            if (v86 != __p)
            {
              do
              {
                v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v45 - 1);
              }

              while (v45 != v44);
              v46 = __p;
            }

            v86 = v44;
            operator delete(v46);
          }

          v47 = v83;
          if (v83)
          {
            v48 = v84;
            v49 = v83;
            if (v84 != v83)
            {
              do
              {
                v51 = *--v48;
                v50 = v51;
                *v48 = 0;
                if (v51)
                {
                  operator delete[](v50);
                }
              }

              while (v48 != v47);
              v49 = v83;
            }

            v84 = v47;
            operator delete(v49);
          }

          v38 = v80;
          if (v80 != v82)
          {
            goto LABEL_64;
          }
        }

        return v16;
      }

      ++v12;
      v13 += 32;
      if (v4 == v12)
      {
        return 1;
      }
    }
  }

  return 1;
}

uint64_t mlir::affine::AffineVectorLoadOp::verify(mlir::affine::AffineVectorLoadOp *this, StringRef a2)
{
  v2 = this;
  v3 = *this;
  v4 = *(*(*(*this + 72) + 24) + 8);
  if (!*(*this + 47) || (a2.var0 = "map", this = OUTLINED_FUNCTION_157_3(this, a2), (a2.var0 & 1) == 0))
  {
    a2.var0 = "map";
    this = OUTLINED_FUNCTION_156_1(this, a2);
  }

  if (this)
  {
    OUTLINED_FUNCTION_24_6();
    OUTLINED_FUNCTION_148_3();
  }

  OUTLINED_FUNCTION_189_0();
  if (v6 < 0)
  {
    OUTLINED_FUNCTION_125_3();
  }

  else
  {
    v8 = -1;
    v9 = -1;
    v7 = 32;
  }

  if ((verifyMemoryOpIndexing(v3, v5, v7, v8, v4 & 0xFFFFFFFFFFFFFFF8, v9) & 1) == 0)
  {
    return 0;
  }

  v10 = *v2;
  if (*(v10 + 36))
  {
    v11 = v10 - 16;
  }

  else
  {
    v11 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  return verifyVectorMemoryOp(v10, v4 & 0xFFFFFFFFFFFFFFF8, *(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8) & 1;
}

uint64_t mlir::affine::AffineVectorStoreOp::verify(mlir::affine **this, StringRef a2)
{
  v2 = *this;
  v3 = *(*(*(*this + 9) + 56) + 8);
  if (!*(*this + 47) || (a2.var0 = "map", this = OUTLINED_FUNCTION_157_3(this, a2), (a2.var0 & 1) == 0))
  {
    a2.var0 = "map";
    this = OUTLINED_FUNCTION_156_1(this, a2);
  }

  if (this)
  {
    OUTLINED_FUNCTION_24_6();
    OUTLINED_FUNCTION_148_3();
  }

  OUTLINED_FUNCTION_189_0();
  if (v5 < 0)
  {
    OUTLINED_FUNCTION_124_3();
  }

  else
  {
    v7 = -2;
    v8 = -2;
    v6 = 64;
  }

  if ((verifyMemoryOpIndexing(v2, v4, v6, v7, v3 & 0xFFFFFFFFFFFFFFF8, v8) & 1) == 0)
  {
    return 0;
  }

  OUTLINED_FUNCTION_133_3();
  return verifyVectorMemoryOp(v10, v3 & 0xFFFFFFFFFFFFFFF8, v9 & 0xFFFFFFFFFFFFFFF8) & 1;
}

void mlir::affine::AffineDelinearizeIndexOp::print(mlir::affine::AffineDelinearizeIndexOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v64[4] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_79_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v6, v7);
  }

  OUTLINED_FUNCTION_130_4();
  OUTLINED_FUNCTION_104();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v10 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v11, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v11, v12);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v15 > 3)
  {
    OUTLINED_FUNCTION_160(v14);
    *(v17 + 32) = v16 + 4;
  }

  else
  {
    llvm::raw_ostream::write(v13, "into", 4uLL);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v18, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v18, v19);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v22)
  {
    llvm::raw_ostream::write(v20, "(", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v20, v21);
  }

  OUTLINED_FUNCTION_47_0();
  if (v24 < 0)
  {
    v25 = *(v23 + 72);
    v26 = *(v23 + 68) - 1;
  }

  else
  {
    v25 = 0;
    v26 = -1;
  }

  (*(*v2 + 16))(v2);
  if (v26)
  {
    OUTLINED_FUNCTION_104();
    (*(v27 + 160))(v2);
    v28 = v26 - 1;
    if (v28)
    {
      v29 = v25 + 88;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v22 & v8)
        {
          *v30 = 8236;
          OUTLINED_FUNCTION_29_2();
        }

        else
        {
          v31 = OUTLINED_FUNCTION_38_4();
          llvm::raw_ostream::write(v31, v32, 2uLL);
        }

        v29 += 32;
        OUTLINED_FUNCTION_104();
        (*(v33 + 160))(v2);
        --v28;
      }

      while (v28);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v22)
  {
    llvm::raw_ostream::write(v34, ")", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v34, v35);
  }

  v62 = v64;
  v63 = 0x200000000;
  mlir::Operation::getAttrDictionary(*v3);
  OUTLINED_FUNCTION_88_4();
  mlir::ArrayAttr::getValue(v36);
  OUTLINED_FUNCTION_104();
  v37 = OUTLINED_FUNCTION_120_2();
  v38(v37);
  OUTLINED_FUNCTION_104();
  (*(v39 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v40, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v40, v41);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v22)
  {
    llvm::raw_ostream::write(v42, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v42, v43);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v44, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v44, v45);
  }

  OUTLINED_FUNCTION_34_2();
  v58[0] = v46;
  v58[1] = v47;
  mlir::OperandRange::getTypes(v58, &v59);
  v48 = v60;
  v49 = v61;
  if (v60 != v61)
  {
    v50 = v59;
    mlir::detail::OpResultImpl::getNextResultAtOffset(v59, v60);
    OUTLINED_FUNCTION_104();
    v51 = OUTLINED_FUNCTION_12_4();
    v52(v51);
    for (i = v48 + 1; v49 != i; ++i)
    {
      (*(*v2 + 16))(v2);
      OUTLINED_FUNCTION_25_2();
      if (!v22 & v8)
      {
        *v55 = 8236;
        OUTLINED_FUNCTION_24_2(v54);
      }

      else
      {
        llvm::raw_ostream::write(v54, ", ", 2uLL);
      }

      mlir::detail::OpResultImpl::getNextResultAtOffset(v50, i);
      OUTLINED_FUNCTION_104();
      v56 = OUTLINED_FUNCTION_12_4();
      v57(v56);
    }
  }

  if (v62 != v64)
  {
    free(v62);
  }
}

uint64_t mlir::affine::AffinePrefetchOp::getODSOperands(mlir::affine::AffinePrefetchOp *this, unsigned int a2, double a3, int32x4_t a4)
{
  if (a2)
  {
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
LABEL_14:
      v26 = a2 - v4;
      v27 = &byte_1E0982C48[v4];
      do
      {
        v28 = *v27++;
        v5 += v28;
        --v26;
      }

      while (v26);
      goto LABEL_16;
    }

    if (a2 >= 0x20)
    {
      v6 = 0uLL;
      v7 = "3AffineDialectE";
      v8 = 0uLL;
      v4 = a2 & 0xFFFFFFE0;
      v9 = v4;
      v10 = 0uLL;
      v11 = 0uLL;
      v12 = 0uLL;
      v13 = 0uLL;
      v14 = 0uLL;
      v15 = 0uLL;
      do
      {
        v16 = *v7[-2].i8;
        v17 = vmovl_u8(*v16.i8);
        v18 = vmovl_high_u8(v16);
        v19 = vmovl_u8(*v7);
        v20 = vmovl_high_u8(*v7->i8);
        v11 = vaddw_high_u16(v11, v18);
        v10 = vaddw_u16(v10, *v18.i8);
        v8 = vaddw_high_u16(v8, v17);
        v6 = vaddw_u16(v6, *v17.i8);
        v15 = vaddw_high_u16(v15, v20);
        v14 = vaddw_u16(v14, *v20.i8);
        v13 = vaddw_high_u16(v13, v19);
        v12 = vaddw_u16(v12, *v19.i8);
        v7 += 4;
        v9 -= 32;
      }

      while (v9);
      a4 = vaddq_s32(vaddq_s32(v13, v8), vaddq_s32(v15, v11));
      v5 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v12, v6), vaddq_s32(v14, v10)), a4));
      if (v4 == a2)
      {
        goto LABEL_16;
      }

      if ((a2 & 0x1C) == 0)
      {
        goto LABEL_14;
      }
    }

    else
    {
      v5 = 0;
      v4 = 0;
    }

    v21 = v4;
    v4 = a2 & 0xFFFFFFFC;
    v22 = v5;
    v23 = &byte_1E0982C48[v21];
    v24 = v21 - v4;
    do
    {
      v25 = *v23;
      v23 += 4;
      a4.i32[0] = v25;
      a4.i64[0] = vmovl_u8(*a4.i8).u64[0];
      v22 = vaddw_u16(v22, *a4.i8);
      v24 += 4;
    }

    while (v24);
    v5 = vaddvq_s32(v22);
    if (v4 == a2)
    {
      goto LABEL_16;
    }

    goto LABEL_14;
  }

  v5 = 0;
LABEL_16:
  v29 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v30 = *(v29 + 68);
    v31 = *(v29 + 72);
  }

  else
  {
    v30 = 0;
    v31 = 0;
  }

  return v31 + 32 * (a2 + (v30 - 2) * v5);
}

void mlir::affine::AffineYieldOp::print(mlir::affine::AffineYieldOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v51[4] = *MEMORY[0x1E69E9840];
  v49 = v51;
  v50 = 0x200000000;
  mlir::Operation::getAttrDictionary(*v4);
  OUTLINED_FUNCTION_88_4();
  mlir::ArrayAttr::getValue(v5);
  OUTLINED_FUNCTION_104();
  v6 = OUTLINED_FUNCTION_120_2();
  v7(v6);
  OUTLINED_FUNCTION_47_0();
  if (v9 < 0 && *(v8 + 68))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v12)
    {
      llvm::raw_ostream::write(v10, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v10, v11);
    }

    OUTLINED_FUNCTION_47_0();
    if (v14 < 0)
    {
      v15 = *(v13 + 68);
      v16 = *(v13 + 72);
    }

    else
    {
      v16 = 0;
      v15 = 0;
    }

    (*(*v2 + 16))(v2);
    if (v15)
    {
      OUTLINED_FUNCTION_104();
      (*(v17 + 160))(v2);
      v18 = v15 - 1;
      if (v18)
      {
        v19 = v16 + 56;
        do
        {
          OUTLINED_FUNCTION_30_2();
          if (!v21 & v12)
          {
            *v20 = 8236;
            OUTLINED_FUNCTION_29_2();
          }

          else
          {
            v22 = OUTLINED_FUNCTION_38_4();
            llvm::raw_ostream::write(v22, v23, 2uLL);
          }

          v19 += 32;
          OUTLINED_FUNCTION_104();
          (*(v24 + 160))(v2);
          --v18;
        }

        while (v18);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v12)
    {
      llvm::raw_ostream::write(v25, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v25, v26);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v21)
    {
      llvm::raw_ostream::write(v27, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v27, v28);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v12)
    {
      llvm::raw_ostream::write(v29, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v29, v30);
    }

    v31 = *v3;
    if ((*(*v3 + 46) & 0x80) != 0)
    {
      v32 = *(v31 + 68);
      v33 = *(v31 + 72);
    }

    else
    {
      v33 = 0;
      v32 = 0;
    }

    v45[0] = v33;
    v45[1] = v32;
    mlir::OperandRange::getTypes(v45, &v46);
    v34 = v47;
    v35 = v48;
    if (v47 != v48)
    {
      v36 = v46 + 32 * v47;
      OUTLINED_FUNCTION_104();
      v37 = OUTLINED_FUNCTION_12_4();
      v38(v37);
      if (v34 + 1 != v35)
      {
        v39 = ~v34 + v35;
        v40 = v36 + 56;
        do
        {
          (*(*v2 + 16))(v2);
          OUTLINED_FUNCTION_25_2();
          if (!v21 & v12)
          {
            *v42 = 8236;
            OUTLINED_FUNCTION_24_2(v41);
          }

          else
          {
            llvm::raw_ostream::write(v41, ", ", 2uLL);
          }

          v40 += 32;
          OUTLINED_FUNCTION_104();
          v43 = OUTLINED_FUNCTION_12_4();
          v44(v43);
          --v39;
        }

        while (v39);
      }
    }
  }

  if (v49 != v51)
  {
    free(v49);
  }
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::affine::AffineDmaStartOp,mlir::OpTrait::MemRefsNormalizable,mlir::OpTrait::VariadicOperands,mlir::OpTrait::ZeroResults,mlir::OpTrait::OpInvariants,mlir::affine::AffineMapAccessInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::affine::AffineDmaStartOp::print(&v8, a3);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::affine::AffineDmaWaitOp,mlir::OpTrait::MemRefsNormalizable,mlir::OpTrait::VariadicOperands,mlir::OpTrait::ZeroResults,mlir::OpTrait::OpInvariants,mlir::affine::AffineMapAccessInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::affine::AffineDmaWaitOp::print(&v7, a3);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::affine::AffineApplyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::affine::AffineApplyOp::print(&v8, a3);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::affine::AffineDelinearizeIndexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::affine::AffineDelinearizeIndexOp::print(&v7, a3);
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::affine::AffineForOp>::getYieldedValuesMutable(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v10[3] = *MEMORY[0x1E69E9840];
  v3 = *(((a1 + 16 * ((*(a1 + 44) >> 23) & 1) + ((*(a1 + 44) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a1 + 40) + 8);
  if (v3)
  {
    v4 = (v3 - 8);
  }

  else
  {
    v4 = 0;
  }

  Terminator = mlir::Block::getTerminator(v4, a1);
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v6 = *(Terminator + 68);
  }

  else
  {
    v6 = 0;
  }

  mlir::MutableOperandRange::MutableOperandRange(v8, Terminator, 0, v6, 0, 0);
  *a2 = mlir::MutableOperandRange::operator mlir::OperandRange(v8);
  *(a2 + 8) = v7;
  *(a2 + 16) = 1;
  if (v9 != v10)
  {
    free(v9);
  }
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::affine::AffineForOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 44);
  v3 = a2 + 16 * ((v2 >> 23) & 1);
  if ((v2 & 0x800000) != 0)
  {
    v4 = *(a2 + 72);
  }

  else
  {
    v4 = 0;
  }

  return v4 + 32 * (*(v3 + 92) + *(v3 + 88));
}

uint64_t llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::affine::AffineForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::affine::AffineYieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::LoopLikeOpInterface::Trait,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  v22[4] = *MEMORY[0x1E69E9840];
  v8 = *(a2 + 44);
  v9 = a2 + 16 * ((v8 >> 23) & 1);
  v10 = *(v9 + 80);
  v19 = *(v9 + 64);
  v20 = v10;
  v12 = *(a2 + 48);
  v11 = *(a2 + 56);
  v17[0] = a2;
  v17[1] = v11;
  v17[2] = v12;
  v18 = 1;
  v21 = *(v9 + 96);
  v13 = v8 & 0x7FFFFF;
  if ((v8 & 0x7FFFFF) != 0)
  {
    v14 = ((v9 + 64 + ((v8 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 40);
  }

  else
  {
    v14 = 0;
    v13 = 0;
  }

  mlir::ValueRange::ValueRange(v22, v14, v13);
  v22[2] = a3;
  v22[3] = a4;
  return mlir::affine::AffineForOp::fold(v17, v15, a5);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::affine::AffineForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::affine::AffineYieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::LoopLikeOpInterface::Trait,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::affine::AffineForOp::print(&v8, a3);
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::affine::AffineIfOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
    v3 = *(a2 + 68);
  }

  else
  {
    v2 = 0;
    v3 = 0;
  }

  return v2 + 32 * v3;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::affine::AffineIfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::affine::AffineYieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::RecursivelySpeculatableImplTrait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::affine::AffineIfOp::print(&v8, a3);
}

uint64_t mlir::affine::detail::AffineReadOpInterfaceInterfaceTraits::Model<mlir::affine::AffineLoadOp>::getMapOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
  }

  else
  {
    v2 = 0;
  }

  return v2 + 32;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::affine::AffineMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::affine::AffineMinOp::print(&v8, a3);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::affine::AffineMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v8 = a2;
  return mlir::affine::AffineMinOp::print(&v8, a3);
}

uint64_t llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::affine::AffineParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::affine::AffineYieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::RecursivelySpeculatableImplTrait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  v10[4] = *MEMORY[0x1E69E9840];
  v6 = *(a2 + 44);
  v7 = v6 & 0x7FFFFF;
  if ((v6 & 0x7FFFFF) != 0)
  {
    v8 = ((a2 + 16 * ((v6 >> 23) & 1) + 64 + ((v6 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 40);
  }

  else
  {
    v8 = 0;
    v7 = 0;
  }

  mlir::ValueRange::ValueRange(v10, v8, v7);
  v10[2] = a3;
  v10[3] = a4;
  return mlir::affine::AffineParallelOp::fold();
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::affine::AffineParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::affine::AffineYieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::RecursivelySpeculatableImplTrait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::affine::AffineParallelOp::print(&v7, a3);
}

uint64_t mlir::affine::detail::AffineWriteOpInterfaceInterfaceTraits::Model<mlir::affine::AffineStoreOp>::getMapOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
  }

  else
  {
    v2 = 0;
  }

  return v2 + 64;
}

uint64_t mlir::affine::detail::AffineReadOpInterfaceInterfaceTraits::Model<mlir::affine::AffineVectorLoadOp>::getMapOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
  }

  else
  {
    v2 = 0;
  }

  return v2 + 32;
}

uint64_t mlir::affine::detail::AffineWriteOpInterfaceInterfaceTraits::Model<mlir::affine::AffineVectorStoreOp>::getMapOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
  }

  else
  {
    v2 = 0;
  }

  return v2 + 64;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::affine::AffineYieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::MemRefsNormalizable>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::affine::AffineYieldOp::print(&v7, a3);
}

uint64_t MergeAffineMinMaxOp<mlir::affine::AffineMinOp>::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::IndexType **a3)
{
  v95 = *MEMORY[0x1E69E9840];
  *&v89 = *(a2 + 16 * ((*(a2 + 44) >> 23) & 1) + 64);
  Value = mlir::AffineMapAttr::getValue(&v89);
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 68);
    v6 = *(a2 + 72);
  }

  else
  {
    v6 = 0;
    v5 = 0;
  }

  mlir::ValueRange::ValueRange(&v89, v6, v5);
  v7 = v89;
  NumDims = mlir::AffineMap::getNumDims(&Value);
  if (*(&v7 + 1) < NumDims)
  {
    NumDims = *(&v7 + 1);
  }

  v93 = v7;
  v94 = NumDims;
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v9 = *(a2 + 68);
    v10 = *(a2 + 72);
  }

  else
  {
    v10 = 0;
    v9 = 0;
  }

  mlir::ValueRange::ValueRange(&v89, v10, v9);
  NumSymbols = mlir::AffineMap::getNumSymbols(&Value);
  if (*(&v89 + 1) <= NumSymbols)
  {
    v12 = *(&v89 + 1);
    v13 = v89;
  }

  else
  {
    v12 = NumSymbols;
    v13 = mlir::ValueRange::offset_base(&v89, *(&v89 + 1) - NumSymbols);
  }

  v91 = v13;
  v92 = v12;
  v14 = v93;
  v15 = v94;
  *&v89 = v90;
  *(&v89 + 1) = 0x800000000;
  if (v94 < 9)
  {
    v16 = 0;
    v86 = v93;
    v87 = 0;
    v17 = v90;
    if (!v94)
    {
      v20 = 0;
      goto LABEL_16;
    }
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v89, v90, v94, 8);
    v16 = DWORD2(v89);
    v17 = v89;
    v86 = v14;
    v87 = 0;
  }

  v18 = 0;
  v19 = &v17[8 * v16];
  do
  {
    *v19++ = mlir::ValueRange::dereference_iterator(&v86, v18);
    v18 = v87 + 1;
    v87 = v18;
  }

  while (v18 != v15);
  v20 = DWORD2(v89);
  v13 = v91;
  v12 = v92;
LABEL_16:
  DWORD2(v89) = v20 + v15;
  v86 = v88;
  v87 = 0x800000000;
  if (v12 < 9)
  {
    v21 = 0;
    v77 = v13;
    v78 = 0;
    v22 = v88;
    if (!v12)
    {
      v25 = 0;
      goto LABEL_22;
    }
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v86, v88, v12, 8);
    v21 = v87;
    v22 = v86;
    v77 = v13;
    v78 = 0;
  }

  v23 = 0;
  v24 = &v22[8 * v21];
  do
  {
    *v24++ = mlir::ValueRange::dereference_iterator(&v77, v23);
    v23 = v78 + 1;
    v78 = v23;
  }

  while (v23 != v12);
  v25 = v87;
LABEL_22:
  LODWORD(v87) = v25 + v12;
  v83 = v85;
  v84 = 0x400000000;
  v80 = v82;
  v81 = 0x400000000;
  Results = mlir::AffineMap::getResults(&Value);
  if (v27)
  {
    v28 = Results;
    for (i = 8 * v27; i; i -= 8)
    {
      v30 = *v28;
      v77 = *v28;
      if (mlir::arith::FastMathFlagsAttr::getValue(&v77) == 7)
      {
        v31 = v30;
      }

      else
      {
        v31 = 0;
      }

      mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v77, v31);
      v75.i64[0] = v77;
      if (v77)
      {
        Position = mlir::AffineDimExpr::getPosition(&v75);
        v33 = &v91;
      }

      else
      {
        v77 = v30;
        if (mlir::arith::FastMathFlagsAttr::getValue(&v77) == 6)
        {
          v34 = v30;
        }

        else
        {
          v34 = 0;
        }

        mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v77, v34);
        v74[0].i64[0] = v77;
        if (!v77)
        {
          goto LABEL_36;
        }

        Position = mlir::AffineDimExpr::getPosition(v74);
        v33 = &v93;
      }

      v77 = mlir::ValueRange::dereference_iterator(v33, Position);
      DefiningOp = mlir::Value::getDefiningOp(&v77);
      if (DefiningOp)
      {
        v36 = DefiningOp;
        if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::affine::AffineMinOp,void>::id)
        {
          v38 = v81;
          if (v81 >= HIDWORD(v81))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(&v80, v82, v81 + 1, 8);
            v38 = v81;
          }

          *(v80 + v38) = v36;
          LODWORD(v81) = v81 + 1;
          goto LABEL_42;
        }
      }

LABEL_36:
      v37 = v84;
      if (v84 >= HIDWORD(v84))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v83, v85, v84 + 1, 8);
        v37 = v84;
      }

      *(v83 + v37) = v30;
      LODWORD(v84) = v84 + 1;
LABEL_42:
      ++v28;
    }
  }

  if (v81)
  {
    v70 = a3;
    v71 = a2;
    v39 = mlir::AffineMap::getNumDims(&Value);
    v40 = mlir::AffineMap::getNumSymbols(&Value);
    if (v81)
    {
      v41 = v80;
      v42 = v80 + 8 * v81;
      do
      {
        v43 = *v41;
        v77 = *(*v41 + 16 * ((*(*v41 + 44) >> 23) & 1) + 64);
        v75.i64[0] = mlir::AffineMapAttr::getValue(&v77);
        v44 = mlir::AffineMap::getNumDims(&v75);
        v45 = mlir::AffineMap::getNumSymbols(&v75);
        if ((*(v43 + 46) & 0x80) != 0)
        {
          v46 = *(v43 + 68);
          v47 = *(v43 + 72);
        }

        else
        {
          v47 = 0;
          v46 = 0;
        }

        mlir::ValueRange::ValueRange(&v77, v47, v46);
        v48 = v77;
        if (v78 >= v44)
        {
          v49 = v44;
        }

        else
        {
          v49 = v78;
        }

        if ((*(v43 + 46) & 0x80) != 0)
        {
          v50 = *(v43 + 68);
          v51 = *(v43 + 72);
        }

        else
        {
          v51 = 0;
          v50 = 0;
        }

        mlir::ValueRange::ValueRange(&v77, v51, v50);
        v52 = v77;
        v53 = v78;
        if (v78 > v45)
        {
          v53 = v45;
          v52 = mlir::ValueRange::offset_base(&v77, v78 - v45);
        }

        v54 = DWORD2(v89);
        if (v49 + DWORD2(v89) > HIDWORD(v89))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v89, v90, v49 + DWORD2(v89), 8);
          v54 = DWORD2(v89);
        }

        v77 = v48;
        v78 = 0;
        if (v49)
        {
          v55 = 0;
          v56 = (v89 + 8 * v54);
          do
          {
            *v56++ = mlir::ValueRange::dereference_iterator(&v77, v55);
            v55 = v78 + 1;
            v78 = v55;
          }

          while (v55 != v49);
          LODWORD(v54) = DWORD2(v89);
        }

        DWORD2(v89) = v54 + v49;
        v57 = v87;
        v58 = v53 + v87;
        if (v58 > HIDWORD(v87))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v86, v88, v58, 8);
          v57 = v87;
        }

        v77 = v52;
        v78 = 0;
        if (v53)
        {
          v59 = 0;
          v60 = (v86 + 8 * v57);
          do
          {
            *v60++ = mlir::ValueRange::dereference_iterator(&v77, v59);
            v59 = v78 + 1;
            v78 = v59;
          }

          while (v59 != v53);
          LODWORD(v57) = v87;
        }

        LODWORD(v87) = v57 + v53;
        v61 = mlir::AffineMap::getResults(&v75);
        if (v62)
        {
          v63 = v61;
          v64 = 8 * v62;
          do
          {
            v77 = *v63;
            v74[0].i64[0] = mlir::AffineExpr::shiftDims(&v77, v44, v39, 0);
            v65 = mlir::AffineExpr::shiftSymbols(v74, v45, v40, 0);
            v66 = v84;
            if (v84 >= HIDWORD(v84))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(&v83, v85, v84 + 1, 8);
              v66 = v84;
            }

            *(v83 + v66) = v65;
            LODWORD(v84) = v84 + 1;
            ++v63;
            v64 -= 8;
          }

          while (v64);
        }

        v39 += v44;
        v40 += v45;
        v41 += 8;
      }

      while (v41 != v42);
    }

    v72 = mlir::AffineMap::get(v39, v40, v83, v84, v70[1]);
    v76.i64[1] = v86 + 8 * v87;
    v77 = v79;
    v78 = 0x800000000;
    v75.i64[0] = v89;
    v75.i64[1] = v86;
    v76.i64[0] = v89 + 8 * DWORD2(v89);
    v74[0] = v76;
    v74[1] = v76;
    llvm::SmallVectorImpl<mlir::Value>::append<llvm::concat_iterator<mlir::Value,mlir::Value*,mlir::Value*>,void>(&v77, &v75, v74);
    v67 = mlir::OpBuilder::create<mlir::affine::AffineMinOp,mlir::AffineMap &,llvm::SmallVector<mlir::Value,8u> &>(v70 + 1, *(v71 + 24), &v72, &v77);
    (*(*v70 + 1))(v70, v71, v67);
    if (v77 != v79)
    {
      free(v77);
    }

    v68 = 1;
  }

  else
  {
    v68 = 0;
  }

  if (v80 != v82)
  {
    free(v80);
  }

  if (v83 != v85)
  {
    free(v83);
  }

  if (v86 != v88)
  {
    free(v86);
  }

  if (v89 != v90)
  {
    free(v89);
  }

  return v68;
}

uint64_t anonymous namespace::SimplifyAffineOp<mlir::affine::AffineMinOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v79 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_82_6();
  Value = mlir::AffineMapAttr::getValue(v5);
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v7 = *(a2 + 68);
    v8 = *(a2 + 72);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  v9 = mlir::ValueRange::ValueRange(&v74, v8, v7);
  v18 = v74;
  v17 = v75;
  v74 = v76;
  v75 = 0x800000000;
  if (v17 < 9)
  {
    v22 = 0;
    v77 = v18;
    v78 = 0;
    v23 = v76;
    if (!v17)
    {
      v25 = 0;
      goto LABEL_9;
    }
  }

  else
  {
    OUTLINED_FUNCTION_85_5();
    llvm::SmallVectorBase<unsigned int>::grow_pod(v19, v20, v21, 8);
    v22 = v75;
    v23 = v74;
    v77 = v18;
    v78 = 0;
  }

  v10 = 0;
  v24 = &v23[8 * v22];
  do
  {
    *v24++ = mlir::ValueRange::dereference_iterator(&v77, v10);
    OUTLINED_FUNCTION_69_4();
  }

  while (v10 != v17);
  v25 = v75;
LABEL_9:
  LODWORD(v75) = v25 + v17;
  v26 = OUTLINED_FUNCTION_149_3(v9, v10, v11, v12, v13, v14, v15, v16, v66, Value);
  composeAffineMapAndOperands(v26, v27);
  v36 = OUTLINED_FUNCTION_149_3(v28, v29, v30, v31, v32, v33, v34, v35, v67, v70);
  mlir::affine::canonicalizeMapAndOperands(v36, v37);
  v46 = OUTLINED_FUNCTION_112_4(v38, v39, v40, v41, v42, v43, v44, v45, v68, v71);
  simplifyMapWithOperands(v46, v47, v48);
  if (v72 != Value)
  {
LABEL_10:
    v57 = OUTLINED_FUNCTION_85_6(v49, v50, v51, v52, v53, v54, v55, v56, v69, v72, v73, v74, v75);
    mlir::OpBuilder::create<mlir::affine::AffineMinOp,mlir::AffineMap &,llvm::ArrayRef<mlir::Value> &>(v57, v58, v59, v60);
    OUTLINED_FUNCTION_63();
    (*(v61 + 8))(a3, a2);
    v62 = 1;
    goto LABEL_16;
  }

  v63 = v74;
  v77 = v18;
  v78 = 0;
  if (v17)
  {
    v64 = 0;
    do
    {
      v49 = mlir::ValueRange::dereference_iterator(&v77, v64);
      if (*v63 != v49)
      {
        goto LABEL_10;
      }

      OUTLINED_FUNCTION_69_4();
      ++v63;
    }

    while (v64 != v17);
  }

  v62 = 0;
LABEL_16:
  if (v74 != v76)
  {
    free(v74);
  }

  return v62;
}

uint64_t MergeAffineMinMaxOp<mlir::affine::AffineMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::IndexType **a3)
{
  v95 = *MEMORY[0x1E69E9840];
  *&v89 = *(a2 + 16 * ((*(a2 + 44) >> 23) & 1) + 64);
  Value = mlir::AffineMapAttr::getValue(&v89);
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 68);
    v6 = *(a2 + 72);
  }

  else
  {
    v6 = 0;
    v5 = 0;
  }

  mlir::ValueRange::ValueRange(&v89, v6, v5);
  v7 = v89;
  NumDims = mlir::AffineMap::getNumDims(&Value);
  if (*(&v7 + 1) < NumDims)
  {
    NumDims = *(&v7 + 1);
  }

  v93 = v7;
  v94 = NumDims;
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v9 = *(a2 + 68);
    v10 = *(a2 + 72);
  }

  else
  {
    v10 = 0;
    v9 = 0;
  }

  mlir::ValueRange::ValueRange(&v89, v10, v9);
  NumSymbols = mlir::AffineMap::getNumSymbols(&Value);
  if (*(&v89 + 1) <= NumSymbols)
  {
    v12 = *(&v89 + 1);
    v13 = v89;
  }

  else
  {
    v12 = NumSymbols;
    v13 = mlir::ValueRange::offset_base(&v89, *(&v89 + 1) - NumSymbols);
  }

  v91 = v13;
  v92 = v12;
  v14 = v93;
  v15 = v94;
  *&v89 = v90;
  *(&v89 + 1) = 0x800000000;
  if (v94 < 9)
  {
    v16 = 0;
    v86 = v93;
    v87 = 0;
    v17 = v90;
    if (!v94)
    {
      v20 = 0;
      goto LABEL_16;
    }
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v89, v90, v94, 8);
    v16 = DWORD2(v89);
    v17 = v89;
    v86 = v14;
    v87 = 0;
  }

  v18 = 0;
  v19 = &v17[8 * v16];
  do
  {
    *v19++ = mlir::ValueRange::dereference_iterator(&v86, v18);
    v18 = v87 + 1;
    v87 = v18;
  }

  while (v18 != v15);
  v20 = DWORD2(v89);
  v13 = v91;
  v12 = v92;
LABEL_16:
  DWORD2(v89) = v20 + v15;
  v86 = v88;
  v87 = 0x800000000;
  if (v12 < 9)
  {
    v21 = 0;
    v77 = v13;
    v78 = 0;
    v22 = v88;
    if (!v12)
    {
      v25 = 0;
      goto LABEL_22;
    }
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v86, v88, v12, 8);
    v21 = v87;
    v22 = v86;
    v77 = v13;
    v78 = 0;
  }

  v23 = 0;
  v24 = &v22[8 * v21];
  do
  {
    *v24++ = mlir::ValueRange::dereference_iterator(&v77, v23);
    v23 = v78 + 1;
    v78 = v23;
  }

  while (v23 != v12);
  v25 = v87;
LABEL_22:
  LODWORD(v87) = v25 + v12;
  v83 = v85;
  v84 = 0x400000000;
  v80 = v82;
  v81 = 0x400000000;
  Results = mlir::AffineMap::getResults(&Value);
  if (v27)
  {
    v28 = Results;
    for (i = 8 * v27; i; i -= 8)
    {
      v30 = *v28;
      v77 = *v28;
      if (mlir::arith::FastMathFlagsAttr::getValue(&v77) == 7)
      {
        v31 = v30;
      }

      else
      {
        v31 = 0;
      }

      mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v77, v31);
      v75.i64[0] = v77;
      if (v77)
      {
        Position = mlir::AffineDimExpr::getPosition(&v75);
        v33 = &v91;
      }

      else
      {
        v77 = v30;
        if (mlir::arith::FastMathFlagsAttr::getValue(&v77) == 6)
        {
          v34 = v30;
        }

        else
        {
          v34 = 0;
        }

        mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v77, v34);
        v74[0].i64[0] = v77;
        if (!v77)
        {
          goto LABEL_36;
        }

        Position = mlir::AffineDimExpr::getPosition(v74);
        v33 = &v93;
      }

      v77 = mlir::ValueRange::dereference_iterator(v33, Position);
      DefiningOp = mlir::Value::getDefiningOp(&v77);
      if (DefiningOp)
      {
        v36 = DefiningOp;
        if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::affine::AffineMaxOp,void>::id)
        {
          v38 = v81;
          if (v81 >= HIDWORD(v81))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(&v80, v82, v81 + 1, 8);
            v38 = v81;
          }

          *(v80 + v38) = v36;
          LODWORD(v81) = v81 + 1;
          goto LABEL_42;
        }
      }

LABEL_36:
      v37 = v84;
      if (v84 >= HIDWORD(v84))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v83, v85, v84 + 1, 8);
        v37 = v84;
      }

      *(v83 + v37) = v30;
      LODWORD(v84) = v84 + 1;
LABEL_42:
      ++v28;
    }
  }

  if (v81)
  {
    v70 = a3;
    v71 = a2;
    v39 = mlir::AffineMap::getNumDims(&Value);
    v40 = mlir::AffineMap::getNumSymbols(&Value);
    if (v81)
    {
      v41 = v80;
      v42 = v80 + 8 * v81;
      do
      {
        v43 = *v41;
        v77 = *(*v41 + 16 * ((*(*v41 + 44) >> 23) & 1) + 64);
        v75.i64[0] = mlir::AffineMapAttr::getValue(&v77);
        v44 = mlir::AffineMap::getNumDims(&v75);
        v45 = mlir::AffineMap::getNumSymbols(&v75);
        if ((*(v43 + 46) & 0x80) != 0)
        {
          v46 = *(v43 + 68);
          v47 = *(v43 + 72);
        }

        else
        {
          v47 = 0;
          v46 = 0;
        }

        mlir::ValueRange::ValueRange(&v77, v47, v46);
        v48 = v77;
        if (v78 >= v44)
        {
          v49 = v44;
        }

        else
        {
          v49 = v78;
        }

        if ((*(v43 + 46) & 0x80) != 0)
        {
          v50 = *(v43 + 68);
          v51 = *(v43 + 72);
        }

        else
        {
          v51 = 0;
          v50 = 0;
        }

        mlir::ValueRange::ValueRange(&v77, v51, v50);
        v52 = v77;
        v53 = v78;
        if (v78 > v45)
        {
          v53 = v45;
          v52 = mlir::ValueRange::offset_base(&v77, v78 - v45);
        }

        v54 = DWORD2(v89);
        if (v49 + DWORD2(v89) > HIDWORD(v89))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v89, v90, v49 + DWORD2(v89), 8);
          v54 = DWORD2(v89);
        }

        v77 = v48;
        v78 = 0;
        if (v49)
        {
          v55 = 0;
          v56 = (v89 + 8 * v54);
          do
          {
            *v56++ = mlir::ValueRange::dereference_iterator(&v77, v55);
            v55 = v78 + 1;
            v78 = v55;
          }

          while (v55 != v49);
          LODWORD(v54) = DWORD2(v89);
        }

        DWORD2(v89) = v54 + v49;
        v57 = v87;
        v58 = v53 + v87;
        if (v58 > HIDWORD(v87))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v86, v88, v58, 8);
          v57 = v87;
        }

        v77 = v52;
        v78 = 0;
        if (v53)
        {
          v59 = 0;
          v60 = (v86 + 8 * v57);
          do
          {
            *v60++ = mlir::ValueRange::dereference_iterator(&v77, v59);
            v59 = v78 + 1;
            v78 = v59;
          }

          while (v59 != v53);
          LODWORD(v57) = v87;
        }

        LODWORD(v87) = v57 + v53;
        v61 = mlir::AffineMap::getResults(&v75);
        if (v62)
        {
          v63 = v61;
          v64 = 8 * v62;
          do
          {
            v77 = *v63;
            v74[0].i64[0] = mlir::AffineExpr::shiftDims(&v77, v44, v39, 0);
            v65 = mlir::AffineExpr::shiftSymbols(v74, v45, v40, 0);
            v66 = v84;
            if (v84 >= HIDWORD(v84))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(&v83, v85, v84 + 1, 8);
              v66 = v84;
            }

            *(v83 + v66) = v65;
            LODWORD(v84) = v84 + 1;
            ++v63;
            v64 -= 8;
          }

          while (v64);
        }

        v39 += v44;
        v40 += v45;
        v41 += 8;
      }

      while (v41 != v42);
    }

    v72 = mlir::AffineMap::get(v39, v40, v83, v84, v70[1]);
    v76.i64[1] = v86 + 8 * v87;
    v77 = v79;
    v78 = 0x800000000;
    v75.i64[0] = v89;
    v75.i64[1] = v86;
    v76.i64[0] = v89 + 8 * DWORD2(v89);
    v74[0] = v76;
    v74[1] = v76;
    llvm::SmallVectorImpl<mlir::Value>::append<llvm::concat_iterator<mlir::Value,mlir::Value*,mlir::Value*>,void>(&v77, &v75, v74);
    v67 = mlir::OpBuilder::create<mlir::affine::AffineMaxOp,mlir::AffineMap &,llvm::SmallVector<mlir::Value,8u> &>(v70 + 1, *(v71 + 24), &v72, &v77);
    (*(*v70 + 1))(v70, v71, v67);
    if (v77 != v79)
    {
      free(v77);
    }

    v68 = 1;
  }

  else
  {
    v68 = 0;
  }

  if (v80 != v82)
  {
    free(v80);
  }

  if (v83 != v85)
  {
    free(v83);
  }

  if (v86 != v88)
  {
    free(v86);
  }

  if (v89 != v90)
  {
    free(v89);
  }

  return v68;
}

uint64_t anonymous namespace::SimplifyAffineOp<mlir::affine::AffineMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v79 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_82_6();
  Value = mlir::AffineMapAttr::getValue(v5);
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v7 = *(a2 + 68);
    v8 = *(a2 + 72);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  v9 = mlir::ValueRange::ValueRange(&v74, v8, v7);
  v18 = v74;
  v17 = v75;
  v74 = v76;
  v75 = 0x800000000;
  if (v17 < 9)
  {
    v22 = 0;
    v77 = v18;
    v78 = 0;
    v23 = v76;
    if (!v17)
    {
      v25 = 0;
      goto LABEL_9;
    }
  }

  else
  {
    OUTLINED_FUNCTION_85_5();
    llvm::SmallVectorBase<unsigned int>::grow_pod(v19, v20, v21, 8);
    v22 = v75;
    v23 = v74;
    v77 = v18;
    v78 = 0;
  }

  v10 = 0;
  v24 = &v23[8 * v22];
  do
  {
    *v24++ = mlir::ValueRange::dereference_iterator(&v77, v10);
    OUTLINED_FUNCTION_69_4();
  }

  while (v10 != v17);
  v25 = v75;
LABEL_9:
  LODWORD(v75) = v25 + v17;
  v26 = OUTLINED_FUNCTION_149_3(v9, v10, v11, v12, v13, v14, v15, v16, v66, Value);
  composeAffineMapAndOperands(v26, v27);
  v36 = OUTLINED_FUNCTION_149_3(v28, v29, v30, v31, v32, v33, v34, v35, v67, v70);
  mlir::affine::canonicalizeMapAndOperands(v36, v37);
  v46 = OUTLINED_FUNCTION_112_4(v38, v39, v40, v41, v42, v43, v44, v45, v68, v71);
  simplifyMapWithOperands(v46, v47, v48);
  if (v72 != Value)
  {
LABEL_10:
    v57 = OUTLINED_FUNCTION_85_6(v49, v50, v51, v52, v53, v54, v55, v56, v69, v72, v73, v74, v75);
    mlir::OpBuilder::create<mlir::affine::AffineMaxOp,mlir::AffineMap &,llvm::ArrayRef<mlir::Value> &>(v57, v58, v59, v60);
    OUTLINED_FUNCTION_63();
    (*(v61 + 8))(a3, a2);
    v62 = 1;
    goto LABEL_16;
  }

  v63 = v74;
  v77 = v18;
  v78 = 0;
  if (v17)
  {
    v64 = 0;
    do
    {
      v49 = mlir::ValueRange::dereference_iterator(&v77, v64);
      if (*v63 != v49)
      {
        goto LABEL_10;
      }

      OUTLINED_FUNCTION_69_4();
      ++v63;
    }

    while (v64 != v17);
  }

  v62 = 0;
LABEL_16:
  if (v74 != v76)
  {
    free(v74);
  }

  return v62;
}

uint64_t anonymous namespace::DropDelinearizeOfSingleLoop::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v38 = *MEMORY[0x1E69E9840];
  v24 = a2;
  if ((*(a2 + 46) & 0x80) == 0 || *(a2 + 68) != 2)
  {
    return 0;
  }

  v4 = *(a2 + 72);
  v5 = *(v4 + 24);
  if ((~*(v5 + 8) & 7) != 0)
  {
    v5 = 0;
  }

  v23 = v5;
  if (!v5)
  {
    return 0;
  }

  v7 = *(mlir::Value::getParentRegion(&v23) + 2);
  InterfaceFor = mlir::OpInterface<mlir::LoopLikeOpInterface,mlir::detail::LoopLikeOpInterfaceInterfaceTraits>::getInterfaceFor(v7);
  if (InterfaceFor)
  {
    InterfaceFor = v7 ? mlir::OpInterface<mlir::LoopLikeOpInterface,mlir::detail::LoopLikeOpInterfaceInterfaceTraits>::getInterfaceFor(v7) : 0;
  }

  else
  {
    v7 = 0;
  }

  v22[0] = v7;
  v22[1] = InterfaceFor;
  if (!v7)
  {
    return 0;
  }

  mlir::LoopLikeOpInterface::getLoopInductionVars(&v35, v22);
  v9 = v37 == 1 && v36 == 1;
  if (v9 && *v35 == v23)
  {
    mlir::LoopLikeOpInterface::getLoopUpperBounds(&v31, v22);
    v14 = v34 == 1 && v32 == 1;
    if (v14 && (v15 = *v31, v15 == mlir::getAsOpFoldResult(*(v4 + 56))))
    {
      mlir::LoopLikeOpInterface::getLoopLowerBounds(&v28, v22);
      v16 = v30 == 1 && v29 == 1;
      if (v16 && mlir::isZeroIndex(*v28))
      {
        mlir::LoopLikeOpInterface::getLoopSteps(&v25, v22);
        v17 = v27 == 1 && v26 == 1;
        if (v17 && (mlir::isConstantIntValue(*v25, 1) & 1) != 0)
        {
          OUTLINED_FUNCTION_104();
          v11 = 1;
          (*v18)(a3);
        }

        else
        {
          v11 = mlir::RewriterBase::notifyMatchFailure<mlir::affine::AffineDelinearizeIndexOp &>(a3, &v24, "loop step is not one");
        }

        if (v27 == 1)
        {
          OUTLINED_FUNCTION_65_4();
          if (!v9)
          {
            free(v21);
          }
        }
      }

      else
      {
        v11 = mlir::RewriterBase::notifyMatchFailure<mlir::affine::AffineDelinearizeIndexOp &>(a3, &v24, "loop lower bound is not zero");
      }

      if (v30 == 1)
      {
        OUTLINED_FUNCTION_65_4();
        if (!v9)
        {
          free(v20);
        }
      }
    }

    else
    {
    }

    if (v34 == 1)
    {
      OUTLINED_FUNCTION_65_4();
      if (!v9)
      {
        free(v19);
      }
    }
  }

  else
  {
    v33 = 259;
    v28 = &v31;
    v10 = *(a3 + 16);
    if (v10 && mlir::RewriterBase::Listener::classof(v10))
    {
      (*(*v10 + 88))(v10, *(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::affine::AffineDelinearizeIndexOp &>(mlir::affine::AffineDelinearizeIndexOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    }

    v11 = 0;
  }

  if (v37 == 1)
  {
    OUTLINED_FUNCTION_65_4();
    if (!v9)
    {
      free(v12);
    }
  }

  return v11;
}

void mlir::Dialect::declarePromisedInterfaces<mlir::ValueBoundsOpInterface,mlir::affine::AffineApplyOp,mlir::affine::AffineMaxOp,mlir::affine::AffineMinOp>()
{
  {
    v0 = llvm::getTypeName<mlir::ValueBoundsOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ValueBoundsOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::affine::isTopLevelValue()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_129_4(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_129_4(v2);
  }
}

void mlir::affine::AffineDmaStartOp::getEffects()
{
  {
    mlir::MemoryEffects::Read::Read(&mlir::SideEffects::Effect::get<mlir::MemoryEffects::Read>(void)::instance);
  }
}

uint64_t mlir::affine::AffineForOp::verifyRegions(uint64_t a1)
{
  v1 = *(*a1 + 16 * ((*(*a1 + 44) >> 23) & 1) + 88);
  OUTLINED_FUNCTION_86_0();
  mlir::AffineMapAttr::getValue(v2);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMap::getNumDims(v3);
  v4 = OUTLINED_FUNCTION_88_2();
  return verifyDimAndSymbolIdentifiers<mlir::affine::AffineForOp>(v4, v5, v1, v6) & 1;
}

uint64_t mlir::affine::AffineForOp::verifyRegions(mlir::affine **a1)
{
  OUTLINED_FUNCTION_81_6();
  if ((v5 & 0x800000) != 0)
  {
    v6 = *(v4 + 72);
  }

  else
  {
    v6 = 0;
  }

  v7 = (v6 + 32 * v2);
  v8 = (v3 + v2) - v2;
  OUTLINED_FUNCTION_86_0();
  mlir::AffineMapAttr::getValue(v9);
  OUTLINED_FUNCTION_38_10();
  NumDims = mlir::AffineMap::getNumDims(v10);
  return verifyDimAndSymbolIdentifiers<mlir::affine::AffineForOp>(a1, v7, v8, NumDims) & 1;
}

void mlir::OpBuilder::create<mlir::affine::AffineForOp,mlir::OperandRange,mlir::AffineMap,mlir::OperandRange,mlir::AffineMap,long long,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "affine.for";
  *(a2 + 24) = 10;
}

uint64_t mlir::affine::AffineLoadOp::verify()
{
  OUTLINED_FUNCTION_120_4();
  if (!v3 || (v12.var0 = "map", v12.var1 = 3, InherentAttr = mlir::Operation::getInherentAttr(v1, v12), (v5 & 1) == 0))
  {
    v13.var0 = "map";
    v13.var1 = 3;
    InherentAttr = mlir::DictionaryAttr::get((v1 + 56), v13);
  }

  if (InherentAttr)
  {
    OUTLINED_FUNCTION_24_6();
    OUTLINED_FUNCTION_148_3();
  }

  else
  {
    v6 = 0;
  }

  if ((*(*v2 + 46) & 0x80) != 0)
  {
    OUTLINED_FUNCTION_125_3();
  }

  else
  {
    v8 = -1;
    v9 = -1;
    v7 = 32;
  }

  v10 = verifyMemoryOpIndexing(v1, v6, v7, v8, *v0, v9);
  return OUTLINED_FUNCTION_93_4(v10);
}

void mlir::affine::AffineStoreOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::affine::detail::AffineStoreOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::affine::detail::AffineStoreOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::affine::AffineStoreOp::verify()
{
  OUTLINED_FUNCTION_120_4();
  if (!v3 || (v12.var0 = "map", v12.var1 = 3, InherentAttr = mlir::Operation::getInherentAttr(v1, v12), (v5 & 1) == 0))
  {
    v13.var0 = "map";
    v13.var1 = 3;
    InherentAttr = mlir::DictionaryAttr::get((v1 + 56), v13);
  }

  if (InherentAttr)
  {
    OUTLINED_FUNCTION_24_6();
    OUTLINED_FUNCTION_148_3();
  }

  else
  {
    v6 = 0;
  }

  if ((*(*v2 + 46) & 0x80) != 0)
  {
    OUTLINED_FUNCTION_124_3();
  }

  else
  {
    v8 = -2;
    v9 = -2;
    v7 = 64;
  }

  v10 = verifyMemoryOpIndexing(v1, v6, v7, v8, *v0, v9);
  return OUTLINED_FUNCTION_93_4(v10);
}

void mlir::affine::AffinePrefetchOp::verify(uint64_t *a1, BOOL *a2)
{
  v40 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_118_4(a1, "too few operands", v22, v24, v26, v28, v30, v32, v33[0]);
  *a2 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v33);
  if (v33[0])
  {
    mlir::InFlightDiagnostic::report(v33);
  }

  if (v39 == 1)
  {
    v11 = v38;
    if (v38 != (v2 + 200))
    {
      free(v38);
    }

    v12 = __p;
    if (__p)
    {
      v13 = v37;
      v14 = __p;
      if (v37 != __p)
      {
        do
        {
          v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v13 - 1);
        }

        while (v13 != v12);
        v14 = __p;
      }

      v37 = v12;
      operator delete(v14);
    }

    v15 = v34;
    if (v34)
    {
      v16 = v35;
      v17 = v34;
      if (v35 != v34)
      {
        do
        {
          v19 = *--v16;
          v18 = v19;
          *v16 = 0;
          if (v19)
          {
            operator delete[](v18);
          }
        }

        while (v16 != v15);
        v17 = v34;
      }

      v35 = v15;
      operator delete(v17);
    }

    v20 = OUTLINED_FUNCTION_89_0(v11, v4, v5, v6, v7, v8, v9, v10, v23, v25, v27, v29, v31, v33[0], v33[1], v33[2], v33[3]);
    if (!v21)
    {
      free(v20);
    }
  }
}

uint64_t mlir::affine::AffineParallelOp::verify()
{
  OUTLINED_FUNCTION_70_0();
  mlir::affine::AffineParallelOp::getUpperBoundsOperands(v0);
  OUTLINED_FUNCTION_13_12();
  OUTLINED_FUNCTION_86_0();
  mlir::AffineMapAttr::getValue(v1);
  OUTLINED_FUNCTION_38_10();
  mlir::AffineMap::getNumDims(v2);
  OUTLINED_FUNCTION_85_5();
  v7 = verifyDimAndSymbolIdentifiers<mlir::affine::AffineForOp>(v3, v4, v5, v6);
  return OUTLINED_FUNCTION_93_4(v7);
}

void mlir::affine::AffineDelinearizeIndexOp::verify(uint64_t *a1, BOOL *a2)
{
  v40 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_118_4(a1, "should return an index for each basis element", v22, v24, v26, v28, v30, v32, v33[0]);
  *a2 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v33);
  if (v33[0])
  {
    mlir::InFlightDiagnostic::report(v33);
  }

  if (v39 == 1)
  {
    v11 = v38;
    if (v38 != (v2 + 200))
    {
      free(v38);
    }

    v12 = __p;
    if (__p)
    {
      v13 = v37;
      v14 = __p;
      if (v37 != __p)
      {
        do
        {
          v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v13 - 1);
        }

        while (v13 != v12);
        v14 = __p;
      }

      v37 = v12;
      operator delete(v14);
    }

    v15 = v34;
    if (v34)
    {
      v16 = v35;
      v17 = v34;
      if (v35 != v34)
      {
        do
        {
          v19 = *--v16;
          v18 = v19;
          *v16 = 0;
          if (v19)
          {
            operator delete[](v18);
          }
        }

        while (v16 != v15);
        v17 = v34;
      }

      v35 = v15;
      operator delete(v17);
    }

    v20 = OUTLINED_FUNCTION_89_0(v11, v4, v5, v6, v7, v8, v9, v10, v23, v25, v27, v29, v31, v33[0], v33[1], v33[2], v33[3]);
    if (!v21)
    {
      free(v20);
    }
  }
}

void mlir::affine::AffineApplyOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::affine::detail::AffineApplyOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_76_5(v2);
  }
}

uint64_t mlir::affine::AffineApplyOp::verifyInvariantsImpl(uint64_t a1)
{
  OUTLINED_FUNCTION_52_2(a1);
  v2 = OUTLINED_FUNCTION_100_4("result", *v1);
  return OUTLINED_FUNCTION_93_4(v2);
}

void mlir::affine::AffineForOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::affine::detail::AffineForOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::affine::AffineForOp::verifyInvariantsImpl()
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_66_5();
  v5 = *(v3 + 16 * ((v4 >> 23) & 1) + 88);
  if ((v4 & 0x800000) != 0)
  {
    v6 = *(v3 + 72);
    if (v5)
    {
      goto LABEL_3;
    }
  }

  else
  {
    v6 = 0;
    if (v5)
    {
LABEL_3:
      v7 = 0;
      v8 = v6 + 24;
      v2 = "operand";
      do
      {
        OUTLINED_FUNCTION_49_6();
        result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v9, v10, v11, v12, v7);
        if ((result & 1) == 0)
        {
          goto LABEL_14;
        }

        ++v7;
        v8 += 32;
      }

      while (v5 != v7);
    }
  }

  ODSOperands = mlir::memref::ReinterpretCastOp::getODSOperands(v1, 1u);
  if (v15)
  {
    v16 = v15;
    v17 = ODSOperands + 24;
    v2 = "operand";
    while (1)
    {
      OUTLINED_FUNCTION_49_6();
      result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v18, v19, v20, v21, v5);
      if ((result & 1) == 0)
      {
        break;
      }

      LODWORD(v5) = v5 + 1;
      v17 += 32;
      if (!--v16)
      {
        goto LABEL_10;
      }
    }

LABEL_14:
    v28 = 0;
    goto LABEL_15;
  }

LABEL_10:
  mlir::memref::ReinterpretCastOp::getODSOperands(v1, 2u);
  OUTLINED_FUNCTION_138_3();
  if (v2)
  {
    v22 = 0;
    do
    {
      v23 = OUTLINED_FUNCTION_38_4();
      mlir::detail::OpResultImpl::getNextResultAtOffset(v23, v24);
      ++v22;
    }

    while (v2 != v22);
  }

  OUTLINED_FUNCTION_10_14();
  result = mlir::scf::__mlir_ods_local_region_constraint_SCFOps2(v27, v25 + 32 * v26, "region", 6, 0);
  v28 = result & 1;
LABEL_15:
  *v0 = v28;
  return result;
}

void mlir::affine::AffineLoadOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::affine::detail::AffineLoadOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_106_2(v2);
  }
}

void mlir::affine::AffineMaxOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::affine::detail::AffineMaxOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_73_3(v2);
  }
}

void mlir::affine::AffineMinOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::affine::detail::AffineMinOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_71_3(v2);
  }
}

void mlir::affine::AffineParallelOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::affine::detail::AffineParallelOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_57_3(v2);
  }
}

uint64_t mlir::affine::AffineParallelOp::verifyInvariantsImpl()
{
  OUTLINED_FUNCTION_138_3();
  if (v0)
  {
    v1 = 0;
    do
    {
      v2 = OUTLINED_FUNCTION_38_4();
      mlir::detail::OpResultImpl::getNextResultAtOffset(v2, v3);
      ++v1;
    }

    while (v0 != v1);
  }

  OUTLINED_FUNCTION_10_14();
  v7 = mlir::scf::__mlir_ods_local_region_constraint_SCFOps2(v6, v4 + 32 * v5, "region", 6, 0);
  return OUTLINED_FUNCTION_93_4(v7);
}

void mlir::affine::AffinePrefetchOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::affine::detail::AffinePrefetchOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_51_6(v2);
  }
}

uint64_t mlir::affine::AffineStoreOp::verifyInvariantsImpl()
{
  OUTLINED_FUNCTION_123_4();
  while (1)
  {
    OUTLINED_FUNCTION_49_6();
    result = mlir::memref::__mlir_ods_local_type_constraint_MemRefOps4(v4, v5, v6, v7, v2);
    if ((result & 1) == 0)
    {
      break;
    }

    ++v2;
    v3 += 32;
    if (v1 == v2)
    {
      v9 = 1;
      goto LABEL_6;
    }
  }

  v9 = 0;
LABEL_6:
  *v0 = v9;
  return result;
}

void mlir::affine::AffineVectorLoadOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::affine::detail::AffineVectorLoadOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_102_4(v2);
  }
}

void mlir::affine::AffineVectorStoreOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::affine::detail::AffineVectorStoreOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::ShapedDimOpInterface,mlir::detail::ShapedDimOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::ShapedDimOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ShapedDimOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::RegisteredOperationName::Model<mlir::affine::AffineDmaStartOp>::Model()
{
  {
    started = llvm::getTypeName<mlir::affine::AffineDmaStartOp>();
    mlir::detail::TypeIDResolver<mlir::affine::AffineDmaStartOp,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(started, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::MemRefsNormalizable<mlir::affine::AffineDmaStartOp>,mlir::OpTrait::VariadicOperands<mlir::affine::AffineDmaStartOp>,mlir::OpTrait::ZeroResults<mlir::affine::AffineDmaStartOp>,mlir::OpTrait::OpInvariants<mlir::affine::AffineDmaStartOp>,mlir::affine::AffineMapAccessInterface::Trait<mlir::affine::AffineDmaStartOp>,mlir::MemoryEffectOpInterface::Trait<mlir::affine::AffineDmaStartOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::affine::AffineMapAccessInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_92_4(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::MemRefsNormalizable,mlir::OpTrait::VariadicOperands,mlir::OpTrait::ZeroResults,mlir::OpTrait::OpInvariants,mlir::affine::AffineMapAccessInterface::Trait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::MemRefsNormalizable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::MemRefsNormalizable>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_83_5(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::affine::AffineMapAccessInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::affine::AffineMapAccessInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_101_4(v2);
  }
}

void mlir::RegisteredOperationName::Model<mlir::affine::AffineDmaWaitOp>::Model()
{
  {
    v0 = llvm::getTypeName<mlir::affine::AffineDmaWaitOp>();
    mlir::detail::TypeIDResolver<mlir::affine::AffineDmaWaitOp,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::affine::AffineMapAccessInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_92_4(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::affine::AffineApplyOp>,mlir::OpTrait::OneResult<mlir::affine::AffineApplyOp>,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<mlir::affine::AffineApplyOp>,mlir::OpTrait::ZeroSuccessors<mlir::affine::AffineApplyOp>,mlir::OpTrait::VariadicOperands<mlir::affine::AffineApplyOp>,mlir::OpTrait::OpInvariants<mlir::affine::AffineApplyOp>,mlir::BytecodeOpInterface::Trait<mlir::affine::AffineApplyOp>,mlir::ConditionallySpeculatable::Trait<mlir::affine::AffineApplyOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::affine::AffineApplyOp>,mlir::MemoryEffectOpInterface::Trait<mlir::affine::AffineApplyOp>,mlir::InferTypeOpInterface::Trait<mlir::affine::AffineApplyOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_68_4(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_150_2(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_97_3(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_146_3(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_145_3(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::OneRegion<mlir::affine::AffineForOp>,mlir::OpTrait::VariadicResults<mlir::affine::AffineForOp>,mlir::OpTrait::ZeroSuccessors<mlir::affine::AffineForOp>,mlir::OpTrait::VariadicOperands<mlir::affine::AffineForOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::affine::AffineForOp>,mlir::OpTrait::SingleBlock<mlir::affine::AffineForOp>,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::affine::AffineYieldOp>::Impl<mlir::affine::AffineForOp>,mlir::OpTrait::OpInvariants<mlir::affine::AffineForOp>,mlir::BytecodeOpInterface::Trait<mlir::affine::AffineForOp>,mlir::OpTrait::AutomaticAllocationScope<mlir::affine::AffineForOp>,mlir::ConditionallySpeculatable::Trait<mlir::affine::AffineForOp>,mlir::OpTrait::HasRecursiveMemoryEffects<mlir::affine::AffineForOp>,mlir::LoopLikeOpInterface::Trait<mlir::affine::AffineForOp>,mlir::RegionBranchOpInterface::Trait<mlir::affine::AffineForOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_132_3(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::affine::AffineForOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::LoopLikeOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_122_3(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::affine::AffineYieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::LoopLikeOpInterface::Trait,mlir::RegionBranchOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::affine::AffineYieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::affine::AffineYieldOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::affine::AffineYieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::affine::AffineYieldOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::LoopLikeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::LoopLikeOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::LoopLikeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::affine::AffineYieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::RecursivelySpeculatableImplTrait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::RecursivelySpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RecursivelySpeculatableImplTrait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::RecursivelySpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RecursivelySpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::affine::AffineLoadOp>,mlir::OpTrait::OneResult<mlir::affine::AffineLoadOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::affine::AffineLoadOp>,mlir::OpTrait::ZeroSuccessors<mlir::affine::AffineLoadOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::affine::AffineLoadOp>,mlir::OpTrait::OpInvariants<mlir::affine::AffineLoadOp>,mlir::BytecodeOpInterface::Trait<mlir::affine::AffineLoadOp>,mlir::affine::AffineReadOpInterface::Trait<mlir::affine::AffineLoadOp>,mlir::affine::AffineMapAccessInterface::Trait<mlir::affine::AffineLoadOp>,mlir::OpTrait::MemRefsNormalizable<mlir::affine::AffineLoadOp>,mlir::MemoryEffectOpInterface::Trait<mlir::affine::AffineLoadOp>>()
{
  {
    Op = llvm::getTypeName<mlir::affine::AffineReadOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Op, v1);
    OUTLINED_FUNCTION_128_4(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::affine::AffineReadOpInterface::Trait,mlir::affine::AffineMapAccessInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::affine::AffineReadOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::affine::AffineReadOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::affine::AffineReadOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::affine::AffineReadOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::affine::AffineStoreOp>,mlir::OpTrait::ZeroResults<mlir::affine::AffineStoreOp>,mlir::OpTrait::ZeroSuccessors<mlir::affine::AffineStoreOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::affine::AffineStoreOp>,mlir::OpTrait::OpInvariants<mlir::affine::AffineStoreOp>,mlir::BytecodeOpInterface::Trait<mlir::affine::AffineStoreOp>,mlir::affine::AffineWriteOpInterface::Trait<mlir::affine::AffineStoreOp>,mlir::affine::AffineMapAccessInterface::Trait<mlir::affine::AffineStoreOp>,mlir::OpTrait::MemRefsNormalizable<mlir::affine::AffineStoreOp>,mlir::MemoryEffectOpInterface::Trait<mlir::affine::AffineStoreOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::affine::AffineWriteOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_127_4(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::affine::AffineWriteOpInterface::Trait,mlir::affine::AffineMapAccessInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::affine::AffineWriteOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::affine::AffineWriteOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::affine::AffineWriteOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::affine::AffineWriteOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::VectorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::affine::AffineReadOpInterface::Trait,mlir::affine::AffineMapAccessInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::VectorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::VectorType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::VectorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::VectorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::affine::AffineReadOpInterface,mlir::affine::detail::AffineReadOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    Op = llvm::getTypeName<mlir::affine::AffineReadOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Op, v1);
    OUTLINED_FUNCTION_128_4(v2);
  }
}

void mlir::OpInterface<mlir::affine::AffineWriteOpInterface,mlir::affine::detail::AffineWriteOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::affine::AffineWriteOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_127_4(v2);
  }
}

void mlir::OpBuilder::create<mlir::affine::AffineLoadOp,mlir::Value,mlir::AffineMap &,llvm::ArrayRef<mlir::Value> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "affine.load";
  *(a2 + 24) = 11;
}

void mlir::OpBuilder::create<mlir::affine::AffineStoreOp,mlir::Value,mlir::Value,mlir::AffineMap &,llvm::ArrayRef<mlir::Value> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "affine.store";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::affine::AffineMinOp,mlir::AffineMap &,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "affine.min";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::affine::AffineMaxOp,mlir::AffineMap &,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "affine.max";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::affine::AffinePrefetchOp,mlir::detail::TypedValue<mlir::MemRefType>,mlir::AffineMap &,llvm::ArrayRef<mlir::Value> &,BOOL,unsigned int,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "affine.prefetch";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::affine::AffineVectorLoadOp,mlir::VectorType,mlir::Value,mlir::AffineMap &,llvm::ArrayRef<mlir::Value> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "affine.vector_load";
  *(a2 + 24) = 18;
}

void mlir::OpBuilder::create<mlir::affine::AffineVectorStoreOp,mlir::Value,mlir::Value,mlir::AffineMap &,llvm::ArrayRef<mlir::Value> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "affine.vector_store";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::affine::AffineDelinearizeIndexOp,mlir::detail::TypedValue<mlir::IndexType>,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "affine.delinearize_index";
  *(a2 + 24) = 24;
}

BOOL mlir::mpsx::QuantizedMatMulOp::isInputAffneQuantized(mlir::mpsx::QuantizedMatMulOp *this)
{
  OUTLINED_FUNCTION_13_18();
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(v1, 1);
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  return v3 != 0;
}

BOOL mlir::mpsx::QuantizedMatMulOp::isWeightsAffineQuantized(mlir::mpsx::QuantizedMatMulOp *this)
{
  OUTLINED_FUNCTION_13_18();
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(v1, 5);
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  if (!v3)
  {
    return 0;
  }

  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v6, 9);
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 1;
  }

  OUTLINED_FUNCTION_7_13();
  return v4 == 0;
}

BOOL mlir::mpsx::QuantizedMatMulOp::isWeightsDoubleAffineQuantized(mlir::mpsx::QuantizedMatMulOp *this)
{
  OUTLINED_FUNCTION_13_18();
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(v1, 9);
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  return v3 != 0;
}

BOOL mlir::mpsx::QuantizedMatMulOp::verify(mlir::Operation **this)
{
  v323[1] = *MEMORY[0x1E69E9840];
  v3 = *this;
  v296 = v3;
  TransposeLhsAttr = v3;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&TransposeLhsAttr, 1);
  OUTLINED_FUNCTION_41_3();
  if (v50 || (OUTLINED_FUNCTION_7_13(), !v4))
  {
    mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 1);
    OUTLINED_FUNCTION_35_10();
    OUTLINED_FUNCTION_41_3();
    if (!v50 && (OUTLINED_FUNCTION_7_13(), v32) || (mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 2), OUTLINED_FUNCTION_35_10(), OUTLINED_FUNCTION_41_3(), !v50) && (OUTLINED_FUNCTION_7_13(), v33))
    {
      OUTLINED_FUNCTION_9_14("no input quantization parameters must be set when input isn't quantized", InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr);
      mlir::InFlightDiagnostic::operator llvm::LogicalResult(&TransposeLhsAttr);
      OUTLINED_FUNCTION_119_2();
      if (v34)
      {
        mlir::InFlightDiagnostic::report(&TransposeLhsAttr);
      }

      OUTLINED_FUNCTION_54_4();
      if (v50)
      {
        v18 = OUTLINED_FUNCTION_24_12(v35, v36, v37, v38, v39, v40, v41, v42, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320, v321, v322);
        if (!v50)
        {
          free(v18);
        }

        v43 = v319;
        if (v319)
        {
          v44 = OUTLINED_FUNCTION_23_12(v18, v19, v20, v21, v22, v23, v24, v25, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320);
          if (!v50)
          {
            do
            {
              v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v44 - 8));
            }

            while (v44 != v43);
            v45 = v319;
          }

          OUTLINED_FUNCTION_69_5(v45, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320);
        }

        v29 = __p;
        if (!__p)
        {
          goto LABEL_130;
        }

        v30 = OUTLINED_FUNCTION_22_10();
        if (v50)
        {
          goto LABEL_129;
        }

        do
        {
          v46 = OUTLINED_FUNCTION_35_1();
          if (v46)
          {
            operator delete[](v46);
          }
        }

        while (v1 != v29);
        goto LABEL_128;
      }

      goto LABEL_132;
    }

    ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 0);
    v48 = OUTLINED_FUNCTION_2_19(ODSOperandIndexAndLength, v296);
    v49 = *(*mlir::getElementTypeOrSelf(v48) + 136);
    v50 = v49 == &mlir::detail::TypeIDResolver<mlir::Float4E2M1FNType,void>::id || v49 == &mlir::detail::TypeIDResolver<mlir::Float6E2M3FNType,void>::id;
    if (!v50 && v49 != &mlir::detail::TypeIDResolver<mlir::Float6E3M2FNType,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3Type,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::Float8E3M4Type,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id && v49 != &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
    {
      OUTLINED_FUNCTION_9_14("unquantized input must be float type", InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr);
      mlir::InFlightDiagnostic::operator llvm::LogicalResult(&TransposeLhsAttr);
      OUTLINED_FUNCTION_119_2();
      if (v66)
      {
        mlir::InFlightDiagnostic::report(&TransposeLhsAttr);
      }

      OUTLINED_FUNCTION_54_4();
      if (v50)
      {
        v18 = OUTLINED_FUNCTION_24_12(v67, v68, v69, v70, v71, v72, v73, v74, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320, v321, v322);
        if (!v50)
        {
          free(v18);
        }

        v75 = v319;
        if (v319)
        {
          v76 = OUTLINED_FUNCTION_23_12(v18, v19, v20, v21, v22, v23, v24, v25, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320);
          if (!v50)
          {
            do
            {
              v76 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v76 - 8));
            }

            while (v76 != v75);
            v77 = v319;
          }

          OUTLINED_FUNCTION_69_5(v77, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320);
        }

        v29 = __p;
        if (!__p)
        {
          goto LABEL_130;
        }

        v30 = OUTLINED_FUNCTION_22_10();
        if (v50)
        {
          goto LABEL_129;
        }

        do
        {
          v78 = OUTLINED_FUNCTION_35_1();
          if (v78)
          {
            operator delete[](v78);
          }
        }

        while (v1 != v29);
        goto LABEL_128;
      }

      goto LABEL_132;
    }
  }

  else
  {
    TransposeLhsAttr = v3;
    mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&TransposeLhsAttr, 1);
    mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 1);
    OUTLINED_FUNCTION_35_10();
    OUTLINED_FUNCTION_41_3();
    if (v50 || (OUTLINED_FUNCTION_7_13(), !v5) || (mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 2), OUTLINED_FUNCTION_35_10(), OUTLINED_FUNCTION_41_3(), v50) || (OUTLINED_FUNCTION_7_13(), !v6))
    {
      OUTLINED_FUNCTION_9_14("quantization parameters missing for affine quantized input", InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr);
      mlir::InFlightDiagnostic::operator llvm::LogicalResult(&TransposeLhsAttr);
      OUTLINED_FUNCTION_119_2();
      if (v79)
      {
        mlir::InFlightDiagnostic::report(&TransposeLhsAttr);
      }

      OUTLINED_FUNCTION_54_4();
      if (v50)
      {
        v18 = OUTLINED_FUNCTION_24_12(v80, v81, v82, v83, v84, v85, v86, v87, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320, v321, v322);
        if (!v50)
        {
          free(v18);
        }

        v88 = v319;
        if (v319)
        {
          v89 = OUTLINED_FUNCTION_23_12(v18, v19, v20, v21, v22, v23, v24, v25, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320);
          if (!v50)
          {
            do
            {
              v89 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v89 - 8));
            }

            while (v89 != v88);
            v90 = v319;
          }

          OUTLINED_FUNCTION_69_5(v90, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320);
        }

        v29 = __p;
        if (!__p)
        {
          goto LABEL_130;
        }

        v30 = OUTLINED_FUNCTION_22_10();
        if (v50)
        {
          goto LABEL_129;
        }

        do
        {
          v91 = OUTLINED_FUNCTION_35_1();
          if (v91)
          {
            operator delete[](v91);
          }
        }

        while (v1 != v29);
        goto LABEL_128;
      }

      goto LABEL_132;
    }

    v7 = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 0);
    LOBYTE(v3) = v296;
    v8 = OUTLINED_FUNCTION_3_18(v7, *(v296 + 72));
    mlir::getElementTypeOrSelf(v8);
    OUTLINED_FUNCTION_40_6();
    if (!v50)
    {
      OUTLINED_FUNCTION_9_14("quantized input must be quantized type", InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr);
      mlir::InFlightDiagnostic::operator llvm::LogicalResult(&TransposeLhsAttr);
      OUTLINED_FUNCTION_119_2();
      if (v9)
      {
        mlir::InFlightDiagnostic::report(&TransposeLhsAttr);
      }

      OUTLINED_FUNCTION_54_4();
      if (!v50)
      {
        goto LABEL_132;
      }

      v18 = OUTLINED_FUNCTION_24_12(v10, v11, v12, v13, v14, v15, v16, v17, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320, v321, v322);
      if (!v50)
      {
        free(v18);
      }

      v26 = v319;
      if (v319)
      {
        v27 = OUTLINED_FUNCTION_23_12(v18, v19, v20, v21, v22, v23, v24, v25, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320);
        if (!v50)
        {
          do
          {
            v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v27 - 8));
          }

          while (v27 != v26);
          v28 = v319;
        }

        OUTLINED_FUNCTION_69_5(v28, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320);
      }

      v29 = __p;
      if (!__p)
      {
LABEL_130:
        v92 = OUTLINED_FUNCTION_154_0(v18, v19, v20, v21, v22, v23, v24, v25, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302);
        if (!v50)
        {
          free(v92);
        }

        goto LABEL_132;
      }

      v30 = OUTLINED_FUNCTION_22_10();
      if (v50)
      {
LABEL_129:
        v317 = v29;
        operator delete(v30);
        goto LABEL_130;
      }

      do
      {
        v31 = OUTLINED_FUNCTION_35_1();
        if (v31)
        {
          operator delete[](v31);
        }
      }

      while (v1 != v29);
LABEL_128:
      v30 = __p;
      goto LABEL_129;
    }

    mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 0);
    OUTLINED_FUNCTION_7_14();
    OUTLINED_FUNCTION_78_4();
    mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(v135, 1);
    OUTLINED_FUNCTION_35_10();
    OUTLINED_FUNCTION_41_3();
    if (v50)
    {
      v1 = 0;
    }

    else
    {
      OUTLINED_FUNCTION_88_0();
      v1 = *(v136 + 24);
    }

    mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 2);
    OUTLINED_FUNCTION_35_10();
    OUTLINED_FUNCTION_41_3();
    if (!v50)
    {
      OUTLINED_FUNCTION_88_0();
    }

    mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 3);
    OUTLINED_FUNCTION_35_10();
    OUTLINED_FUNCTION_41_3();
    if (v50)
    {
      v138 = 0;
    }

    else
    {
      OUTLINED_FUNCTION_88_0();
      v138 = *(v137 + 24);
    }

    InputQuantParamsAxisAttr = mlir::mpsx::QuantizedMatMulOp::getInputQuantParamsAxisAttr(&v296);
    if (InputQuantParamsAxisAttr)
    {
      mlir::IntegerAttr::getValue(&InputQuantParamsAxisAttr, &TransposeLhsAttr);
      if (v300 > 0x40)
      {
        operator delete[](TransposeLhsAttr);
      }

      else
      {
        OUTLINED_FUNCTION_77_4();
      }
    }

    v139 = OUTLINED_FUNCTION_28_10();
    {
      return 0;
    }
  }

  isWeightsQuantized = mlir::mpsx::QuantizedMatMulOp::isWeightsQuantized(&v296);
  if (!isWeightsQuantized)
  {
    OUTLINED_FUNCTION_89_5(isWeightsQuantized, v145, v146, v147, v148, v149, v150, v151, InputQuantParamsAxisAttr, v287);
    OUTLINED_FUNCTION_35_10();
    OUTLINED_FUNCTION_41_3();
    if (!v50 && (OUTLINED_FUNCTION_7_13(), v182) || (mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 6), OUTLINED_FUNCTION_35_10(), OUTLINED_FUNCTION_41_3(), !v50) && (OUTLINED_FUNCTION_7_13(), v183) || (mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 8), OUTLINED_FUNCTION_35_10(), OUTLINED_FUNCTION_41_3(), !v50) && (OUTLINED_FUNCTION_7_13(), v184) || (mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 9), OUTLINED_FUNCTION_35_10(), OUTLINED_FUNCTION_41_3(), !v50) && (OUTLINED_FUNCTION_7_13(), v185) || mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsZeroPoint(&v296))
    {
      OUTLINED_FUNCTION_9_14("no weight quantization parameters must be set when weight isn't quantized", InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr);
      mlir::InFlightDiagnostic::operator llvm::LogicalResult(&TransposeLhsAttr);
      OUTLINED_FUNCTION_119_2();
      if (v186)
      {
        mlir::InFlightDiagnostic::report(&TransposeLhsAttr);
      }

      OUTLINED_FUNCTION_54_4();
      if (v50)
      {
        v18 = OUTLINED_FUNCTION_24_12(v187, v188, v189, v190, v191, v192, v193, v194, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320, v321, v322);
        if (!v50)
        {
          free(v18);
        }

        v195 = v319;
        if (v319)
        {
          v196 = OUTLINED_FUNCTION_23_12(v18, v19, v20, v21, v22, v23, v24, v25, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320);
          if (!v50)
          {
            do
            {
              v196 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v196 - 8));
            }

            while (v196 != v195);
            v197 = v319;
          }

          OUTLINED_FUNCTION_69_5(v197, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320);
        }

        v29 = __p;
        if (!__p)
        {
          goto LABEL_130;
        }

        v30 = OUTLINED_FUNCTION_22_10();
        if (v50)
        {
          goto LABEL_129;
        }

        do
        {
          v198 = OUTLINED_FUNCTION_35_1();
          if (v198)
          {
            operator delete[](v198);
          }
        }

        while (v1 != v29);
        goto LABEL_128;
      }

      goto LABEL_132;
    }

    v233 = OUTLINED_FUNCTION_67_4(0, v226, v227, v228, v229, v230, v231, v232, InputQuantParamsAxisAttr, v287);
    v234 = OUTLINED_FUNCTION_2_19(v233, v296);
    if (isFPType)
    {
      goto LABEL_133;
    }

    v243 = "unquantized weights must be float type";
    goto LABEL_271;
  }

  TransposeLhsAttr = v296;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&TransposeLhsAttr, 5);
  OUTLINED_FUNCTION_41_3();
  v3 = "quantized weights must be quantized type";
  if (!v50)
  {
    OUTLINED_FUNCTION_7_13();
    if (v152)
    {
      mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&TransposeLhsAttr, 9);
      OUTLINED_FUNCTION_41_3();
      if (v50 || (OUTLINED_FUNCTION_7_13(), !v161))
      {
        OUTLINED_FUNCTION_89_5(v153, v154, v155, v156, v157, v158, v159, v160, InputQuantParamsAxisAttr, v287);
        OUTLINED_FUNCTION_35_10();
        OUTLINED_FUNCTION_41_3();
        if (v50 || (OUTLINED_FUNCTION_7_13(), !v224) || (WeightsZeroPoint = mlir::mpsx::QuantizedMatMulOp::getWeightsZeroPoint(&v296)) == 0)
        {
          v181 = "quantization parameters missing for affine quantized weights";
LABEL_263:
          OUTLINED_FUNCTION_71_4(WeightsZeroPoint, v173, v174, v175, v176, v177, v178, v179, v181, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr);
          mlir::InFlightDiagnostic::operator llvm::LogicalResult(&TransposeLhsAttr);
          OUTLINED_FUNCTION_119_2();
          if (v225)
          {
            mlir::InFlightDiagnostic::report(&TransposeLhsAttr);
          }

          OUTLINED_FUNCTION_54_4();
          if (v50)
          {
            mlir::Diagnostic::~Diagnostic(&v300);
          }

          goto LABEL_132;
        }

        isFPType = mlir::mpsx::QuantizedMatMulOp::getWeightsPaletteLut(&v296);
        if (!isFPType)
        {
          isFPType = mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsScale(&v296);
          if (!isFPType)
          {
            isFPType = mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsZeroPoint(&v296);
            if (!isFPType)
            {
              v262 = OUTLINED_FUNCTION_67_4(0, v236, v237, v238, v239, v240, v241, v242, InputQuantParamsAxisAttr, v287);
              v263 = OUTLINED_FUNCTION_2_19(v262, v296);
              mlir::getElementTypeOrSelf(v263);
              OUTLINED_FUNCTION_40_6();
              if (!v50)
              {
                goto LABEL_286;
              }

              WeightsScale = mlir::mpsx::QuantizedMatMulOp::getWeightsScale(&v296);
              v265 = OUTLINED_FUNCTION_85_7(WeightsScale);
              if ((isFPType & 1) == 0)
              {
                v243 = "weights affine quantization scale must be float";
                goto LABEL_271;
              }

              OUTLINED_FUNCTION_67_4(isFPType, v236, v237, v238, v239, v240, v241, v242, InputQuantParamsAxisAttr, v287);
              OUTLINED_FUNCTION_7_14();
              OUTLINED_FUNCTION_78_4();
              mlir::mpsx::QuantizedMatMulOp::getWeightsScale(v283);
              OUTLINED_FUNCTION_86_4();
              mlir::mpsx::QuantizedMatMulOp::getWeightsZeroPoint(v284);
              WeightsMin = mlir::mpsx::QuantizedMatMulOp::getWeightsMin(&v296);
              mlir::mpsx::QuantizedMatMulOp::getWeightsQuantParamsAxis(&v296);
              v277 = OUTLINED_FUNCTION_28_10();
              v282 = WeightsMin;
              goto LABEL_297;
            }
          }
        }

        v243 = "extra quantization parameters set when weight is affine quantized";
LABEL_271:
        InputQuantParamsAxisAttr = v243;
LABEL_272:
        OUTLINED_FUNCTION_71_4(isFPType, v236, v237, v238, v239, v240, v241, v242, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr);
        LOBYTE(v3) = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&TransposeLhsAttr);
        mlir::InFlightDiagnostic::~InFlightDiagnostic(&TransposeLhsAttr);
        goto LABEL_132;
      }
    }
  }

  v162 = v296;
  TransposeLhsAttr = v296;
  mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&TransposeLhsAttr, 8);
  OUTLINED_FUNCTION_41_3();
  if (!v50)
  {
    OUTLINED_FUNCTION_7_13();
    if (v171)
    {
      OUTLINED_FUNCTION_89_5(v163, v164, v165, v166, v167, v168, v169, v170, InputQuantParamsAxisAttr, v287);
      OUTLINED_FUNCTION_35_10();
      OUTLINED_FUNCTION_41_3();
      if (v50 || (OUTLINED_FUNCTION_7_13(), !v180))
      {
        WeightsZeroPoint = mlir::mpsx::QuantizedMatMulOp::getWeightsZeroPoint(&v296);
        if (!WeightsZeroPoint)
        {
          WeightsZeroPoint = mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsScale(&v296);
          if (!WeightsZeroPoint)
          {
            WeightsZeroPoint = mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsZeroPoint(&v296);
            if (!WeightsZeroPoint)
            {
              v244 = OUTLINED_FUNCTION_67_4(0, v173, v174, v175, v176, v177, v178, v179, InputQuantParamsAxisAttr, v287);
              v245 = OUTLINED_FUNCTION_2_19(v244, v296);
              mlir::getElementTypeOrSelf(v245);
              OUTLINED_FUNCTION_40_6();
              if (v50)
              {
                v246 = v296;
                OUTLINED_FUNCTION_67_4(isFPType, v236, v237, v238, v239, v240, v241, v242, InputQuantParamsAxisAttr, v287);
                OUTLINED_FUNCTION_7_14();
                OUTLINED_FUNCTION_78_4();
                mlir::mpsx::QuantizedMatMulOp::getWeightsPaletteLut(v247);
                OUTLINED_FUNCTION_86_4();
                WeightsQuantParamsAxis = mlir::mpsx::QuantizedMatMulOp::getWeightsQuantParamsAxis(v248);
                if ((mlir::mps::verifyDequantLUT(v246, v162, v1, WeightsQuantParamsAxis & 0xFFFFFFFFFFLL) & 1) == 0)
                {
                  return 0;
                }

                goto LABEL_133;
              }

              goto LABEL_286;
            }
          }
        }
      }

      v181 = "extra quantization parameters set when weight is LUT quantized";
      goto LABEL_263;
    }
  }

  TransposeLhsAttr = v296;
  v199 = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&TransposeLhsAttr, 9);
  OUTLINED_FUNCTION_89_5(v199, v200, v201, v202, v203, v204, v205, v206, InputQuantParamsAxisAttr, v287);
  OUTLINED_FUNCTION_35_10();
  OUTLINED_FUNCTION_41_3();
  if (!v50)
  {
    OUTLINED_FUNCTION_7_13();
    if (v207)
    {
      mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 6);
      OUTLINED_FUNCTION_35_10();
      OUTLINED_FUNCTION_41_3();
      if (!v50)
      {
        OUTLINED_FUNCTION_7_13();
        if (v208)
        {
          mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 9);
          OUTLINED_FUNCTION_35_10();
          OUTLINED_FUNCTION_41_3();
          if (!v50)
          {
            OUTLINED_FUNCTION_7_13();
            if (v209)
            {
              mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v296, 10);
              OUTLINED_FUNCTION_35_10();
              OUTLINED_FUNCTION_41_3();
              if (!v50)
              {
                OUTLINED_FUNCTION_7_13();
                if (v210)
                {
                  isFPType = mlir::mpsx::QuantizedMatMulOp::getWeightsPaletteLut(&v296);
                  if (isFPType)
                  {
                    v243 = "extra quantization parameters set when weight is double affine quantized";
                    goto LABEL_271;
                  }

                  v260 = OUTLINED_FUNCTION_67_4(0, v236, v237, v238, v239, v240, v241, v242, InputQuantParamsAxisAttr, v287);
                  v261 = OUTLINED_FUNCTION_2_19(v260, v296);
                  mlir::getElementTypeOrSelf(v261);
                  OUTLINED_FUNCTION_40_6();
                  if (!v50)
                  {
LABEL_286:
                    InputQuantParamsAxisAttr = "quantized weights must be quantized type";
                    goto LABEL_272;
                  }

                  v266 = mlir::mpsx::QuantizedMatMulOp::getWeightsScale(&v296);
                  v267 = OUTLINED_FUNCTION_85_7(v266);
                  mlir::getElementTypeOrSelf(v267);
                  OUTLINED_FUNCTION_40_6();
                  if (!v50)
                  {
                    v243 = "weights double affine quantization scale must be quantized";
                    goto LABEL_271;
                  }

                  OUTLINED_FUNCTION_67_4(isFPType, v236, v237, v238, v239, v240, v241, v242, InputQuantParamsAxisAttr, v287);
                  OUTLINED_FUNCTION_7_14();
                  OUTLINED_FUNCTION_78_4();
                  mlir::mpsx::QuantizedMatMulOp::getWeightsScale(v268);
                  OUTLINED_FUNCTION_86_4();
                  mlir::mpsx::QuantizedMatMulOp::getWeightsZeroPoint(v269);
                  v270 = mlir::mpsx::QuantizedMatMulOp::getWeightsMin(&v296);
                  mlir::mpsx::QuantizedMatMulOp::getWeightsQuantParamsAxis(&v296);
                  v271 = OUTLINED_FUNCTION_28_10();
                  {
                    return 0;
                  }

                  mlir::mpsx::QuantizedMatMulOp::getWeightsScale(&v296);
                  mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsScale(&v296);
                  OUTLINED_FUNCTION_86_4();
                  mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsZeroPoint(v276);
                  mlir::mpsx::QuantizedMatMulOp::getWeightsQuantParamsAxis(&v296);
                  v277 = OUTLINED_FUNCTION_28_10();
                  v282 = 0;
LABEL_297:
                  {
                    return 0;
                  }

                  goto LABEL_133;
                }
              }
            }
          }
        }
      }
    }
  }

  OUTLINED_FUNCTION_9_14("quantization parameters missing for double affine quantized weights", InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr);
  mlir::InFlightDiagnostic::operator llvm::LogicalResult(&TransposeLhsAttr);
  OUTLINED_FUNCTION_119_2();
  if (v211)
  {
    mlir::InFlightDiagnostic::report(&TransposeLhsAttr);
  }

  OUTLINED_FUNCTION_54_4();
  if (v50)
  {
    v18 = OUTLINED_FUNCTION_24_12(v212, v213, v214, v215, v216, v217, v218, v219, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320, v321, v322);
    if (!v50)
    {
      free(v18);
    }

    v220 = v319;
    if (v319)
    {
      v221 = OUTLINED_FUNCTION_23_12(v18, v19, v20, v21, v22, v23, v24, v25, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320);
      if (!v50)
      {
        do
        {
          v221 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v221 - 8));
        }

        while (v221 != v220);
        v222 = v319;
      }

      OUTLINED_FUNCTION_69_5(v222, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, __p, v317, v318, v319, v320);
    }

    v29 = __p;
    if (!__p)
    {
      goto LABEL_130;
    }

    v30 = OUTLINED_FUNCTION_22_10();
    if (v50)
    {
      goto LABEL_129;
    }

    do
    {
      v223 = OUTLINED_FUNCTION_35_1();
      if (v223)
      {
        operator delete[](v223);
      }
    }

    while (v1 != v29);
    goto LABEL_128;
  }

LABEL_132:
  if ((v3 & 1) == 0)
  {
    return 0;
  }

LABEL_133:
  v295 = *this;
  InputDequantizedType = mlir::mpsx::QuantizedMatMulOp::getInputDequantizedType(&v295);
  v293 = InputDequantizedType;
  v294 = v94;
  WeightsDequantizedType = mlir::mpsx::QuantizedMatMulOp::getWeightsDequantizedType(&v295);
  v291 = WeightsDequantizedType;
  v292 = v96;
  if (*(*InputDequantizedType + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id || *(*WeightsDequantizedType + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    return 1;
  }

  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v293);
  v99 = v98;
  v101 = mlir::CallableOpInterface::getArgAttrsAttr(&v291);
  v102 = v100;
  if (v99)
  {
    if (v99 != 1)
    {
      v103 = &ArgAttrsAttr[v99];
      TransposeLhsAttr = mlir::mpsx::QuantizedMatMulOp::getTransposeLhsAttr(&v295);
      Value = mlir::BoolAttr::getValue(&TransposeLhsAttr);
      v105 = 0x1FFFFFFFFFFFFFFFLL;
      if (Value)
      {
        v105 = 0x1FFFFFFFFFFFFFFELL;
      }

      ArgAttrsAttr = &v103[v105];
    }

    v106 = *ArgAttrsAttr;
    if (v102)
    {
      goto LABEL_141;
    }

LABEL_147:
    v110 = 1;
    goto LABEL_148;
  }

  v106 = 1;
  if (!v100)
  {
    goto LABEL_147;
  }

LABEL_141:
  if (v102 != 1)
  {
    v107 = &v101[v102];
    TransposeLhsAttr = mlir::mpsx::QuantizedMatMulOp::getTransposeRhsAttr(&v295);
    v108 = mlir::BoolAttr::getValue(&TransposeLhsAttr);
    v109 = 0x1FFFFFFFFFFFFFFELL;
    if (v108)
    {
      v109 = 0x1FFFFFFFFFFFFFFFLL;
    }

    v101 = &v107[v109];
  }

  v110 = *v101;
LABEL_148:
  if (v106 == 0x8000000000000000 || v110 == 0x8000000000000000 || v106 == v110)
  {
    return 1;
  }

  InputQuantParamsAxisAttr = "contracting dimensions differ ";
  LOWORD(v290) = 259;
  mlir::OpState::emitOpError(&v295, &InputQuantParamsAxisAttr, &TransposeLhsAttr);
  if (TransposeLhsAttr)
  {
    LODWORD(v296) = 2;
    v297 = v106;
    v113 = v302;
    if (v303 >= HIDWORD(v303))
    {
      OUTLINED_FUNCTION_5_3();
      OUTLINED_FUNCTION_70_4(v250, v251, v252, v253, v254, v255, v256, v257, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302, v303, v304);
      v113 = v302;
    }

    OUTLINED_FUNCTION_22_7((v113 + 24 * v303));
    LODWORD(v303) = v303 + 1;
  }

  mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(&TransposeLhsAttr, " & ");
  v115 = v114;
  if (*v114)
  {
    v116 = *(v114 + 24);
    LODWORD(v296) = 2;
    v297 = v110;
    if (*(v114 + 32) >= *(v114 + 36))
    {
      OUTLINED_FUNCTION_5_3();
      llvm::SmallVectorBase<unsigned int>::grow_pod(v259, v115 + 40, v258 + 1, 24);
      v116 = *(v115 + 24);
    }

    OUTLINED_FUNCTION_22_7((v116 + 24 * *(v115 + 32)));
    ++*(v115 + 32);
  }

  v117 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v115);
  if (TransposeLhsAttr)
  {
    mlir::InFlightDiagnostic::report(&TransposeLhsAttr);
  }

  OUTLINED_FUNCTION_54_4();
  if (v50)
  {
    v125 = v322;
    if (v322 != v323)
    {
      free(v322);
    }

    v126 = v319;
    if (v319)
    {
      v127 = v320;
      v128 = v319;
      if (v320 != v319)
      {
        do
        {
          v127 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v127 - 1);
        }

        while (v127 != v126);
        v128 = v319;
      }

      v320 = v126;
      operator delete(v128);
    }

    v129 = __p;
    if (__p)
    {
      v130 = v317;
      v131 = OUTLINED_FUNCTION_16_5();
      if (!v50)
      {
        do
        {
          v132 = OUTLINED_FUNCTION_17_5();
          if (v132)
          {
            operator delete[](v132);
          }
        }

        while (v130 != v129);
        v131 = __p;
      }

      v317 = v129;
      operator delete(v131);
    }

    v133 = OUTLINED_FUNCTION_154_0(v125, v118, v119, v120, v121, v122, v123, v124, InputQuantParamsAxisAttr, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v297, v298, TransposeLhsAttr, v300, v301, v302);
    if (!v50)
    {
      free(v133);
    }
  }

  return v117;
}

BOOL mlir::mpsx::QuantizedConv2DOp::isWeightsAffineQuantized(mlir::mpsx::QuantizedConv2DOp *this)
{
  OUTLINED_FUNCTION_13_18();
  mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(v1, 5);
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  if (!v3)
  {
    return 0;
  }

  mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v6, 9);
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 1;
  }

  OUTLINED_FUNCTION_7_13();
  return v4 == 0;
}

BOOL mlir::mpsx::QuantizedConv2DOp::verify(mlir::mpsx::QuantizedConv2DOp *this)
{
  v329 = *MEMORY[0x1E69E9840];
  v3 = *this;
  v304 = v3;
  v305 = v3;
  mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v305, 1);
  OUTLINED_FUNCTION_41_3();
  if (v58 || (OUTLINED_FUNCTION_7_13(), !v4))
  {
    mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 1);
    OUTLINED_FUNCTION_36_8();
    OUTLINED_FUNCTION_41_3();
    if (!v58 && (OUTLINED_FUNCTION_7_13(), v32) || (mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 2), OUTLINED_FUNCTION_36_8(), OUTLINED_FUNCTION_41_3(), !v58) && (OUTLINED_FUNCTION_7_13(), v33))
    {
      OUTLINED_FUNCTION_10_16("no input quantization parameters must be set when input isn't quantized", v280);
      mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v305);
      OUTLINED_FUNCTION_104_4();
      if (v34)
      {
        mlir::InFlightDiagnostic::report(&v305);
      }

      OUTLINED_FUNCTION_103_3();
      if (v58)
      {
        v43 = OUTLINED_FUNCTION_145_2(v35, v36, v37, v38, v39, v40, v41, v42, v284, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326, v327, v328);
        if (!v58)
        {
          free(v43);
        }

        v51 = v325;
        if (v325)
        {
          v52 = OUTLINED_FUNCTION_143_0(v43, v44, v45, v46, v47, v48, v49, v50, v285, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326);
          if (!v58)
          {
            do
            {
              v52 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v52 - 8));
            }

            while (v52 != v51);
            v53 = v325;
          }

          OUTLINED_FUNCTION_135_2(v53, v286, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326);
        }

        v29 = __p;
        if (!__p)
        {
          goto LABEL_130;
        }

        v30 = OUTLINED_FUNCTION_142_1();
        if (v58)
        {
          goto LABEL_129;
        }

        do
        {
          v54 = OUTLINED_FUNCTION_17_5();
          if (v54)
          {
            operator delete[](v54);
          }
        }

        while (v2 != v29);
        goto LABEL_128;
      }

      return (v3 & 1) != 0;
    }

    ODSOperandIndexAndLength = mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 0);
    v56 = OUTLINED_FUNCTION_2_19(ODSOperandIndexAndLength, v304);
    v57 = *(*mlir::getElementTypeOrSelf(v56) + 136);
    v58 = v57 == &mlir::detail::TypeIDResolver<mlir::Float4E2M1FNType,void>::id || v57 == &mlir::detail::TypeIDResolver<mlir::Float6E2M3FNType,void>::id;
    if (!v58 && v57 != &mlir::detail::TypeIDResolver<mlir::Float6E3M2FNType,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3Type,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::Float8E3M4Type,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id && v57 != &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
    {
      OUTLINED_FUNCTION_10_16("unquantized input must be float type", v280);
      mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v305);
      OUTLINED_FUNCTION_104_4();
      if (v74)
      {
        mlir::InFlightDiagnostic::report(&v305);
      }

      OUTLINED_FUNCTION_103_3();
      if (v58)
      {
        v83 = OUTLINED_FUNCTION_145_2(v75, v76, v77, v78, v79, v80, v81, v82, v287, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326, v327, v328);
        if (!v58)
        {
          free(v83);
        }

        v91 = v325;
        if (v325)
        {
          v92 = OUTLINED_FUNCTION_143_0(v83, v84, v85, v86, v87, v88, v89, v90, v288, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326);
          if (!v58)
          {
            do
            {
              v92 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v92 - 8));
            }

            while (v92 != v91);
            v93 = v325;
          }

          OUTLINED_FUNCTION_135_2(v93, v289, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326);
        }

        v29 = __p;
        if (!__p)
        {
          goto LABEL_130;
        }

        v30 = OUTLINED_FUNCTION_142_1();
        if (v58)
        {
          goto LABEL_129;
        }

        do
        {
          v94 = OUTLINED_FUNCTION_17_5();
          if (v94)
          {
            operator delete[](v94);
          }
        }

        while (v2 != v29);
        goto LABEL_128;
      }

      return (v3 & 1) != 0;
    }
  }

  else
  {
    v305 = v3;
    mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v305, 1);
    mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 1);
    OUTLINED_FUNCTION_36_8();
    OUTLINED_FUNCTION_41_3();
    if (v58 || (OUTLINED_FUNCTION_7_13(), !v5) || (mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 2), OUTLINED_FUNCTION_36_8(), OUTLINED_FUNCTION_41_3(), v58) || (OUTLINED_FUNCTION_7_13(), !v6))
    {
      OUTLINED_FUNCTION_10_16("quantization parameters missing for affine quantized input", v280);
      mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v305);
      OUTLINED_FUNCTION_104_4();
      if (v95)
      {
        mlir::InFlightDiagnostic::report(&v305);
      }

      OUTLINED_FUNCTION_103_3();
      if (v58)
      {
        v104 = OUTLINED_FUNCTION_145_2(v96, v97, v98, v99, v100, v101, v102, v103, v290, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326, v327, v328);
        if (!v58)
        {
          free(v104);
        }

        v112 = v325;
        if (v325)
        {
          v113 = OUTLINED_FUNCTION_143_0(v104, v105, v106, v107, v108, v109, v110, v111, v291, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326);
          if (!v58)
          {
            do
            {
              v113 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v113 - 8));
            }

            while (v113 != v112);
            v114 = v325;
          }

          OUTLINED_FUNCTION_135_2(v114, v292, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326);
        }

        v29 = __p;
        if (!__p)
        {
          goto LABEL_130;
        }

        v30 = OUTLINED_FUNCTION_142_1();
        if (v58)
        {
          goto LABEL_129;
        }

        do
        {
          v115 = OUTLINED_FUNCTION_17_5();
          if (v115)
          {
            operator delete[](v115);
          }
        }

        while (v2 != v29);
        goto LABEL_128;
      }

      return (v3 & 1) != 0;
    }

    v7 = mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 0);
    LOBYTE(v3) = v304;
    v8 = OUTLINED_FUNCTION_3_18(v7, *(v304 + 72));
    mlir::getElementTypeOrSelf(v8);
    OUTLINED_FUNCTION_39_7();
    if (!v58)
    {
      OUTLINED_FUNCTION_10_16("quantized input must be quantized type", v280);
      mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v305);
      OUTLINED_FUNCTION_104_4();
      if (v9)
      {
        mlir::InFlightDiagnostic::report(&v305);
      }

      OUTLINED_FUNCTION_103_3();
      if (!v58)
      {
        return (v3 & 1) != 0;
      }

      v18 = OUTLINED_FUNCTION_145_2(v10, v11, v12, v13, v14, v15, v16, v17, v281, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326, v327, v328);
      if (!v58)
      {
        free(v18);
      }

      v26 = v325;
      if (v325)
      {
        v27 = OUTLINED_FUNCTION_143_0(v18, v19, v20, v21, v22, v23, v24, v25, v282, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326);
        if (!v58)
        {
          do
          {
            v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v27 - 8));
          }

          while (v27 != v26);
          v28 = v325;
        }

        OUTLINED_FUNCTION_135_2(v28, v283, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326);
      }

      v29 = __p;
      if (!__p)
      {
LABEL_130:
        if (v308 != &v310)
        {
          free(v308);
        }

        return (v3 & 1) != 0;
      }

      v30 = OUTLINED_FUNCTION_142_1();
      if (v58)
      {
LABEL_129:
        v323 = v29;
        operator delete(v30);
        goto LABEL_130;
      }

      do
      {
        v31 = OUTLINED_FUNCTION_17_5();
        if (v31)
        {
          operator delete[](v31);
        }
      }

      while (v2 != v29);
LABEL_128:
      v30 = __p;
      goto LABEL_129;
    }

    mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 0);
    OUTLINED_FUNCTION_8_15();
    OUTLINED_FUNCTION_84_5();
    mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(v117, 1);
    OUTLINED_FUNCTION_36_8();
    OUTLINED_FUNCTION_41_3();
    if (v58)
    {
      v2 = 0;
    }

    else
    {
      OUTLINED_FUNCTION_88_0();
      v2 = *(v118 + 24);
    }

    mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 2);
    OUTLINED_FUNCTION_36_8();
    OUTLINED_FUNCTION_41_3();
    if (!v58)
    {
      OUTLINED_FUNCTION_88_0();
    }

    mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 3);
    OUTLINED_FUNCTION_36_8();
    OUTLINED_FUNCTION_41_3();
    if (v58)
    {
      v120 = 0;
    }

    else
    {
      OUTLINED_FUNCTION_88_0();
      v120 = *(v119 + 24);
    }

    InputQuantParamsAxisAttr = mlir::mpsx::QuantizedConv2DOp::getInputQuantParamsAxisAttr(&v304);
    if (InputQuantParamsAxisAttr)
    {
      mlir::IntegerAttr::getValue(&InputQuantParamsAxisAttr, &v305);
      if (v306 > 0x40)
      {
        operator delete[](v305);
      }

      else
      {
        OUTLINED_FUNCTION_77_4();
      }
    }

    v121 = OUTLINED_FUNCTION_29_12();
    {
      return 0;
    }
  }

  isWeightsQuantized = mlir::mpsx::QuantizedConv2DOp::isWeightsQuantized(&v304);
  if (isWeightsQuantized)
  {
    LOBYTE(v3) = v304;
    v305 = v304;
    mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v305, 5);
    OUTLINED_FUNCTION_41_3();
    if (!v58 && (OUTLINED_FUNCTION_7_13(), v132) && ((mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v305, 9), OUTLINED_FUNCTION_41_3(), v58) || (OUTLINED_FUNCTION_7_13(), !v139)))
    {
      OUTLINED_FUNCTION_90_6(v133, v134, v135, v136, v137, v138);
      OUTLINED_FUNCTION_36_8();
      OUTLINED_FUNCTION_41_3();
      if (v58 || (OUTLINED_FUNCTION_7_13(), !v205) || !mlir::mpsx::QuantizedConv2DOp::getWeightsZeroPoint(&v304))
      {
        v148 = "quantization parameters missing for affine quantized weights";
LABEL_212:
        OUTLINED_FUNCTION_62_4(v148, v280);
        mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v305);
        OUTLINED_FUNCTION_104_4();
        if (v206)
        {
          mlir::InFlightDiagnostic::report(&v305);
        }

        OUTLINED_FUNCTION_103_3();
        if (v58)
        {
          mlir::Diagnostic::~Diagnostic(&v306);
        }

        return (v3 & 1) != 0;
      }

      if (mlir::mpsx::QuantizedConv2DOp::getWeightsPaletteLut(&v304) || mlir::mpsx::QuantizedConv2DOp::getBiquantWeightsScale(&v304) || mlir::mpsx::QuantizedConv2DOp::getBiquantWeightsZeroPoint(&v304))
      {
        v214 = "extra quantization parameters set when weight is affine quantized";
LABEL_220:
        OUTLINED_FUNCTION_62_4(v214, v280);
        LOBYTE(v3) = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v305);
        mlir::InFlightDiagnostic::~InFlightDiagnostic(&v305);
        return (v3 & 1) != 0;
      }

      v244 = OUTLINED_FUNCTION_68_5(0, v239, v240, v241, v242, v243);
      v245 = OUTLINED_FUNCTION_2_19(v244, v304);
      mlir::getElementTypeOrSelf(v245);
      OUTLINED_FUNCTION_39_7();
      if (!v58)
      {
LABEL_234:
        v214 = "quantized weights must be quantized type";
        goto LABEL_220;
      }

      WeightsScale = mlir::mpsx::QuantizedConv2DOp::getWeightsScale(&v304);
      v247 = OUTLINED_FUNCTION_85_7(WeightsScale);
      if (!isFPType)
      {
        v214 = "weights affine quantization scale must be float";
        goto LABEL_220;
      }

      OUTLINED_FUNCTION_68_5(isFPType, v249, v250, v251, v252, v253);
      OUTLINED_FUNCTION_8_15();
      OUTLINED_FUNCTION_84_5();
      mlir::mpsx::QuantizedConv2DOp::getWeightsScale(v277);
      OUTLINED_FUNCTION_81_7();
      mlir::mpsx::QuantizedConv2DOp::getWeightsZeroPoint(v278);
      WeightsMin = mlir::mpsx::QuantizedConv2DOp::getWeightsMin(&v304);
      mlir::mpsx::QuantizedConv2DOp::getWeightsQuantParamsAxis(&v304);
      v271 = OUTLINED_FUNCTION_29_12();
      v276 = WeightsMin;
    }

    else
    {
      LOBYTE(v3) = v304;
      v305 = v304;
      mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v305, 8);
      OUTLINED_FUNCTION_41_3();
      if (!v58)
      {
        OUTLINED_FUNCTION_7_13();
        if (v146)
        {
          OUTLINED_FUNCTION_90_6(v140, v141, v142, v143, v144, v145);
          OUTLINED_FUNCTION_36_8();
          OUTLINED_FUNCTION_41_3();
          if (v58 || (OUTLINED_FUNCTION_7_13(), !v147))
          {
            if (!mlir::mpsx::QuantizedConv2DOp::getWeightsZeroPoint(&v304) && !mlir::mpsx::QuantizedConv2DOp::getBiquantWeightsScale(&v304) && !mlir::mpsx::QuantizedConv2DOp::getBiquantWeightsZeroPoint(&v304))
            {
              v220 = OUTLINED_FUNCTION_68_5(0, v215, v216, v217, v218, v219);
              v221 = OUTLINED_FUNCTION_2_19(v220, v304);
              mlir::getElementTypeOrSelf(v221);
              OUTLINED_FUNCTION_39_7();
              if (v58)
              {
                v228 = v304;
                OUTLINED_FUNCTION_68_5(v222, v223, v224, v225, v226, v227);
                OUTLINED_FUNCTION_8_15();
                OUTLINED_FUNCTION_84_5();
                mlir::mpsx::QuantizedConv2DOp::getWeightsPaletteLut(v229);
                OUTLINED_FUNCTION_81_7();
                WeightsQuantParamsAxis = mlir::mpsx::QuantizedConv2DOp::getWeightsQuantParamsAxis(v230);
                return (mlir::mps::verifyDequantLUT(v228, v1, v2, WeightsQuantParamsAxis & 0xFFFFFFFFFFLL) & 1) != 0;
              }

              goto LABEL_234;
            }
          }

          v148 = "extra quantization parameters set when weight is LUT quantized";
          goto LABEL_212;
        }
      }

      v305 = v304;
      v174 = mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v305, 9);
      OUTLINED_FUNCTION_90_6(v174, v175, v176, v177, v178, v179);
      OUTLINED_FUNCTION_36_8();
      OUTLINED_FUNCTION_41_3();
      if (v58 || (OUTLINED_FUNCTION_7_13(), !v180) || (mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 6), OUTLINED_FUNCTION_36_8(), OUTLINED_FUNCTION_41_3(), v58) || (OUTLINED_FUNCTION_7_13(), !v181) || (mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 9), OUTLINED_FUNCTION_36_8(), OUTLINED_FUNCTION_41_3(), v58) || (OUTLINED_FUNCTION_7_13(), !v182) || (mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 10), OUTLINED_FUNCTION_36_8(), OUTLINED_FUNCTION_41_3(), v58) || (OUTLINED_FUNCTION_7_13(), !v183))
      {
        OUTLINED_FUNCTION_10_16("quantization parameters missing for double affine quantized weights", v280);
        mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v305);
        OUTLINED_FUNCTION_104_4();
        if (v184)
        {
          mlir::InFlightDiagnostic::report(&v305);
        }

        OUTLINED_FUNCTION_103_3();
        if (v58)
        {
          v193 = OUTLINED_FUNCTION_145_2(v185, v186, v187, v188, v189, v190, v191, v192, v296, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326, v327, v328);
          if (!v58)
          {
            free(v193);
          }

          v201 = v325;
          if (v325)
          {
            v202 = OUTLINED_FUNCTION_143_0(v193, v194, v195, v196, v197, v198, v199, v200, v297, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326);
            if (!v58)
            {
              do
              {
                v202 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v202 - 8));
              }

              while (v202 != v201);
              v203 = v325;
            }

            OUTLINED_FUNCTION_135_2(v203, v298, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326);
          }

          v29 = __p;
          if (!__p)
          {
            goto LABEL_130;
          }

          v30 = OUTLINED_FUNCTION_142_1();
          if (v58)
          {
            goto LABEL_129;
          }

          do
          {
            v204 = OUTLINED_FUNCTION_17_5();
            if (v204)
            {
              operator delete[](v204);
            }
          }

          while (v2 != v29);
          goto LABEL_128;
        }

        return (v3 & 1) != 0;
      }

      if (mlir::mpsx::QuantizedConv2DOp::getWeightsPaletteLut(&v304))
      {
        v214 = "extra quantization parameters set when weight is double affine quantized";
        goto LABEL_220;
      }

      v237 = OUTLINED_FUNCTION_68_5(0, v232, v233, v234, v235, v236);
      v238 = OUTLINED_FUNCTION_2_19(v237, v304);
      mlir::getElementTypeOrSelf(v238);
      OUTLINED_FUNCTION_39_7();
      if (!v58)
      {
        goto LABEL_234;
      }

      v254 = mlir::mpsx::QuantizedConv2DOp::getWeightsScale(&v304);
      v255 = OUTLINED_FUNCTION_85_7(v254);
      mlir::getElementTypeOrSelf(v255);
      OUTLINED_FUNCTION_39_7();
      if (!v58)
      {
        v214 = "weights double affine quantization scale must be quantized";
        goto LABEL_220;
      }

      OUTLINED_FUNCTION_68_5(v256, v257, v258, v259, v260, v261);
      OUTLINED_FUNCTION_8_15();
      OUTLINED_FUNCTION_84_5();
      mlir::mpsx::QuantizedConv2DOp::getWeightsScale(v262);
      OUTLINED_FUNCTION_81_7();
      mlir::mpsx::QuantizedConv2DOp::getWeightsZeroPoint(v263);
      v264 = mlir::mpsx::QuantizedConv2DOp::getWeightsMin(&v304);
      mlir::mpsx::QuantizedConv2DOp::getWeightsQuantParamsAxis(&v304);
      v265 = OUTLINED_FUNCTION_29_12();
      {
        return 0;
      }

      mlir::mpsx::QuantizedConv2DOp::getWeightsScale(&v304);
      mlir::mpsx::QuantizedConv2DOp::getBiquantWeightsScale(&v304);
      OUTLINED_FUNCTION_81_7();
      mlir::mpsx::QuantizedConv2DOp::getBiquantWeightsZeroPoint(v270);
      mlir::mpsx::QuantizedConv2DOp::getWeightsQuantParamsAxis(&v304);
      v271 = OUTLINED_FUNCTION_29_12();
      v276 = 0;
    }
  }

  OUTLINED_FUNCTION_90_6(isWeightsQuantized, v127, v128, v129, v130, v131);
  OUTLINED_FUNCTION_36_8();
  OUTLINED_FUNCTION_41_3();
  if (v58 || (OUTLINED_FUNCTION_7_13(), !v149))
  {
    mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 6);
    OUTLINED_FUNCTION_36_8();
    OUTLINED_FUNCTION_41_3();
    if (v58 || (OUTLINED_FUNCTION_7_13(), !v150))
    {
      mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 8);
      OUTLINED_FUNCTION_36_8();
      OUTLINED_FUNCTION_41_3();
      if (v58 || (OUTLINED_FUNCTION_7_13(), !v151))
      {
        mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v304, 9);
        OUTLINED_FUNCTION_36_8();
        OUTLINED_FUNCTION_41_3();
        if (v58 || (OUTLINED_FUNCTION_7_13(), !v152))
        {
          if (!mlir::mpsx::QuantizedConv2DOp::getBiquantWeightsZeroPoint(&v304))
          {
            v212 = OUTLINED_FUNCTION_68_5(0, v207, v208, v209, v210, v211);
            v213 = OUTLINED_FUNCTION_2_19(v212, v304);
            {
              return 1;
            }

            v214 = "unquantized weights must be float type";
            goto LABEL_220;
          }
        }
      }
    }
  }

  OUTLINED_FUNCTION_10_16("no weight quantization parameters must be set when weight isn't quantized", v280);
  mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v305);
  OUTLINED_FUNCTION_104_4();
  if (v153)
  {
    mlir::InFlightDiagnostic::report(&v305);
  }

  OUTLINED_FUNCTION_103_3();
  if (v58)
  {
    v162 = OUTLINED_FUNCTION_145_2(v154, v155, v156, v157, v158, v159, v160, v161, v293, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326, v327, v328);
    if (!v58)
    {
      free(v162);
    }

    v170 = v325;
    if (v325)
    {
      v171 = OUTLINED_FUNCTION_143_0(v162, v163, v164, v165, v166, v167, v168, v169, v294, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326);
      if (!v58)
      {
        do
        {
          v171 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v171 - 8));
        }

        while (v171 != v170);
        v172 = v325;
      }

      OUTLINED_FUNCTION_135_2(v172, v295, InputQuantParamsAxisAttr, v300, v301, v302, v303, v304, v305, v306, v307, v308, v309, v310, v311, v312, v313, v314, v315, v316, v317, v318, v319, v320, v321, __p, v323, v324, v325, v326);
    }

    v29 = __p;
    if (!__p)
    {
      goto LABEL_130;
    }

    v30 = OUTLINED_FUNCTION_142_1();
    if (v58)
    {
      goto LABEL_129;
    }

    do
    {
      v173 = OUTLINED_FUNCTION_17_5();
      if (v173)
      {
        operator delete[](v173);
      }
    }

    while (v2 != v29);
    goto LABEL_128;
  }

  return (v3 & 1) != 0;
}

uint64_t mlir::mpsx::QuantizedGatherOp::getZeroPoint(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedGatherOp::getODSOperandIndexAndLength(this, 4);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mpsx::QuantizedGatherOp::getMin(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedGatherOp::getODSOperandIndexAndLength(this, 5);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t *mlir::mpsx::UseMemrefOp::verify(mlir::mpsx::UseMemrefOp *this)
{
  v1 = this;
  v191 = *MEMORY[0x1E69E9840];
  ParentOp = *(*this + 16);
  if (ParentOp)
  {
    ParentOp = mlir::Block::getParentOp(ParentOp);
  }

  v3 = *(ParentOp + 44);
  if ((v3 & 0x800000) != 0)
  {
    v4 = *(ParentOp + 68);
  }

  else
  {
    v4 = 0;
  }

  v5 = *v1;
  v6 = *(*v1 + 44);
  if ((v6 & 0x800000) != 0)
  {
    v7 = *(v5 + 68);
  }

  else
  {
    v7 = 0;
  }

  if (v4 == v7)
  {
    if ((v3 & 0x800000) != 0)
    {
      v8 = *(ParentOp + 72);
      v9 = *(ParentOp + 68);
      if ((v6 & 0x800000) != 0)
      {
        goto LABEL_10;
      }
    }

    else
    {
      v8 = 0;
      v9 = 0;
      if ((v6 & 0x800000) != 0)
      {
LABEL_10:
        v10 = *(v5 + 72);
        if (v9)
        {
LABEL_11:
          v11 = 0;
          v143 = &v171;
          while (1)
          {
            v12 = *(v10 + 32 * v11 + 24);
            v13 = (*(*(v8 + 32 * v11 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
            v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
            if (v14)
            {
              v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
            }

            else
            {
              v13 = 0;
            }

            v159 = v13;
            v160 = v14;
            v15 = (*(v12 + 8) & 0xFFFFFFFFFFFFFFF8);
            v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8);
            if (v16)
            {
              v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8);
            }

            else
            {
              v15 = 0;
            }

            v157 = v15;
            v158 = v16;
            if (!v159 || !v15)
            {
              goto LABEL_46;
            }

            ArgOperands = mlir::CallOpInterface::getArgOperands(&v159);
            if (ArgOperands != mlir::CallOpInterface::getArgOperands(&v157))
            {
              OUTLINED_FUNCTION_11_12("Type mismatch (hasRank) in UseMemrefOp vs corresponding MemrefBackedOp", &v171, v157, v158, v159, v160);
              mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v166);
              OUTLINED_FUNCTION_63_4();
              if (v76)
              {
                mlir::InFlightDiagnostic::report(&v166);
              }

              OUTLINED_FUNCTION_79_4();
              if (!v23)
              {
                return v1;
              }

              v85 = OUTLINED_FUNCTION_53_4(v77, v78, v79, v80, v81, v82, v83, v84, v148, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187, v188, v189);
              if (!v23)
              {
                free(v85);
              }

              v93 = v186;
              if (v186)
              {
                v94 = OUTLINED_FUNCTION_38_11(v85, v86, v87, v88, v89, v90, v91, v92, v149, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187);
                if (!v23)
                {
                  do
                  {
                    v94 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v94 - 8));
                  }

                  while (v94 != v93);
                  v95 = v186;
                }

                OUTLINED_FUNCTION_73_4(v95, v150, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187);
              }

              v53 = __p;
              if (!__p)
              {
                goto LABEL_66;
              }

              v96 = v184;
              v55 = OUTLINED_FUNCTION_16_5();
              if (v23)
              {
                goto LABEL_65;
              }

              do
              {
                v97 = OUTLINED_FUNCTION_17_5();
                if (v97)
                {
                  operator delete[](v97);
                }
              }

              while (v96 != v53);
LABEL_64:
              v55 = __p;
              goto LABEL_65;
            }

            if (mlir::CallOpInterface::getArgOperands(&v159))
            {
              ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v159);
              if (v19)
              {
                v20 = 8 * v19 - 8;
                do
                {
                  v21 = *ArgAttrsAttr++;
                  v22 = v21 != 0x8000000000000000;
                  v23 = v21 == 0x8000000000000000 || v20 == 0;
                  v20 -= 8;
                }

                while (!v23);
              }

              else
              {
                v22 = 1;
              }
            }

            else
            {
              v22 = 0;
            }

            if (!mlir::CallOpInterface::getArgOperands(&v157))
            {
              goto LABEL_39;
            }

            v24 = mlir::CallableOpInterface::getArgAttrsAttr(&v157);
            if (v25)
            {
              break;
            }

LABEL_37:
            if (!v22)
            {
              goto LABEL_105;
            }

LABEL_40:
            isSplat = mlir::ElementsAttr::isSplat(&v159);
            if (isSplat != mlir::ElementsAttr::isSplat(&v157))
            {
              OUTLINED_FUNCTION_11_12("Type mismatch (getElementType) in UseMemrefOp vs corresponding MemrefBackedOp", &v171, v157, v158, v159, v160);
              mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v166);
              OUTLINED_FUNCTION_63_4();
              if (v120)
              {
                mlir::InFlightDiagnostic::report(&v166);
              }

              OUTLINED_FUNCTION_79_4();
              if (!v23)
              {
                return v1;
              }

              v129 = OUTLINED_FUNCTION_53_4(v121, v122, v123, v124, v125, v126, v127, v128, v154, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187, v188, v189);
              if (!v23)
              {
                free(v129);
              }

              v137 = v186;
              if (v186)
              {
                v138 = OUTLINED_FUNCTION_38_11(v129, v130, v131, v132, v133, v134, v135, v136, v155, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187);
                if (!v23)
                {
                  do
                  {
                    v138 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v138 - 8));
                  }

                  while (v138 != v137);
                  v139 = v186;
                }

                OUTLINED_FUNCTION_73_4(v139, v156, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187);
              }

              v53 = __p;
              if (!__p)
              {
                goto LABEL_66;
              }

              v140 = v184;
              v55 = OUTLINED_FUNCTION_16_5();
              if (v23)
              {
                goto LABEL_65;
              }

              do
              {
                v141 = OUTLINED_FUNCTION_17_5();
                if (v141)
                {
                  operator delete[](v141);
                }
              }

              while (v140 != v53);
              goto LABEL_64;
            }

            if (mlir::CallOpInterface::getArgOperands(&v157))
            {
              mlir::CallableOpInterface::getArgAttrsAttr(&v157);
              if (v28 >= 1)
              {
                v29 = 0;
                while (1)
                {
                  v30 = 8 * v29;
                  v31 = *(mlir::CallableOpInterface::getArgAttrsAttr(&v159) + v30);
                  if (v31 != *(mlir::CallableOpInterface::getArgAttrsAttr(&v157) + v30))
                  {
                    break;
                  }

                  ++v29;
                  mlir::CallableOpInterface::getArgAttrsAttr(&v157);
                  if (v29 >= v32)
                  {
                    goto LABEL_46;
                  }
                }

                v161 = "Type mismatch (getDimSize) in UseMemrefOp vs corresponding MemrefBackedOp";
                LOWORD(v165) = 259;
                mlir::OpState::emitOpError(v1, &v161, &v166);
                mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v166);
                OUTLINED_FUNCTION_63_4();
                if (v66)
                {
                  mlir::InFlightDiagnostic::report(&v166);
                }

                if (v190)
                {
                  v67 = v189;
                  if (v189 != &v190)
                  {
                    free(v189);
                  }

                  v68 = v186;
                  if (v186)
                  {
                    v69 = OUTLINED_FUNCTION_38_11(v67, v59, v60, v61, v62, v63, v64, v65, &v171, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187);
                    if (!v23)
                    {
                      do
                      {
                        v69 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v69 - 8));
                      }

                      while (v69 != v68);
                      v70 = v186;
                    }

                    OUTLINED_FUNCTION_73_4(v70, v147, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187);
                  }

                  v71 = __p;
                  if (__p)
                  {
                    v72 = v184;
                    v73 = __p;
                    if (v184 != __p)
                    {
                      do
                      {
                        v74 = OUTLINED_FUNCTION_35_1();
                        if (v74)
                        {
                          operator delete[](v74);
                        }
                      }

                      while (v72 != v71);
                      v73 = __p;
                    }

                    v184 = v71;
                    operator delete(v73);
                  }

                  v57 = v169;
                  v58 = v143;
                  goto LABEL_85;
                }

                return v1;
              }
            }

LABEL_46:
            if (++v11 == v9)
            {
              return 1;
            }
          }

          v26 = 8 * v25;
          while (*v24 != 0x8000000000000000)
          {
            ++v24;
            v26 -= 8;
            if (!v26)
            {
              goto LABEL_37;
            }
          }

LABEL_39:
          if (v22)
          {
LABEL_105:
            OUTLINED_FUNCTION_11_12("Type mismatch (hasStaticShape) in UseMemrefOp vs corresponding MemrefBackedOp", &v171, v157, v158, v159, v160);
            mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v166);
            OUTLINED_FUNCTION_63_4();
            if (v98)
            {
              mlir::InFlightDiagnostic::report(&v166);
            }

            OUTLINED_FUNCTION_79_4();
            if (!v23)
            {
              return v1;
            }

            v107 = OUTLINED_FUNCTION_53_4(v99, v100, v101, v102, v103, v104, v105, v106, v151, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187, v188, v189);
            if (!v23)
            {
              free(v107);
            }

            v115 = v186;
            if (v186)
            {
              v116 = OUTLINED_FUNCTION_38_11(v107, v108, v109, v110, v111, v112, v113, v114, v152, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187);
              if (!v23)
              {
                do
                {
                  v116 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v116 - 8));
                }

                while (v116 != v115);
                v117 = v186;
              }

              OUTLINED_FUNCTION_73_4(v117, v153, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187);
            }

            v53 = __p;
            if (!__p)
            {
              goto LABEL_66;
            }

            v118 = v184;
            v55 = OUTLINED_FUNCTION_16_5();
            if (v23)
            {
              goto LABEL_65;
            }

            do
            {
              v119 = OUTLINED_FUNCTION_17_5();
              if (v119)
              {
                operator delete[](v119);
              }
            }

            while (v118 != v53);
            goto LABEL_64;
          }

          goto LABEL_40;
        }

        return 1;
      }
    }

    v10 = 0;
    if (v9)
    {
      goto LABEL_11;
    }

    return 1;
  }

  OUTLINED_FUNCTION_11_12("Number of operands mismatch in UseMemrefOp vs corresponding MemrefBackedOp", v142, v157, v158, v159, v160);
  mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v166);
  OUTLINED_FUNCTION_63_4();
  if (v33)
  {
    mlir::InFlightDiagnostic::report(&v166);
  }

  OUTLINED_FUNCTION_79_4();
  if (v23)
  {
    v42 = OUTLINED_FUNCTION_53_4(v34, v35, v36, v37, v38, v39, v40, v41, v144, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187, v188, v189);
    if (!v23)
    {
      free(v42);
    }

    v50 = v186;
    if (v186)
    {
      v51 = OUTLINED_FUNCTION_38_11(v42, v43, v44, v45, v46, v47, v48, v49, v145, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187);
      if (!v23)
      {
        do
        {
          v51 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v51 - 8));
        }

        while (v51 != v50);
        v52 = v186;
      }

      OUTLINED_FUNCTION_73_4(v52, v146, v157, v158, v159, v160, v161, v162, v163, v164, v165, v166, v167, v168, v169, v170, v171, v172, v173, v174, v175, v176, v177, v178, v179, v180, v181, v182, __p, v184, v185, v186, v187);
    }

    v53 = __p;
    if (__p)
    {
      v54 = v184;
      v55 = OUTLINED_FUNCTION_16_5();
      if (!v23)
      {
        do
        {
          v56 = OUTLINED_FUNCTION_17_5();
          if (v56)
          {
            operator delete[](v56);
          }
        }

        while (v54 != v53);
        goto LABEL_64;
      }

LABEL_65:
      v184 = v53;
      operator delete(v55);
    }

LABEL_66:
    v57 = v169;
    v58 = &v171;
LABEL_85:
    if (v57 != v58)
    {
      free(v57);
    }
  }

  return v1;
}

void mlir::mpsx::FusionOp::build(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, uint64_t a5, mlir::IRMapping *a6, void *a7, unint64_t a8, uint64_t a9, unint64_t a10, mlir::Operation **a11, uint64_t a12)
{
  v89 = *MEMORY[0x1E69E9840];
  mlir::OperationState::addOperands(a2, a7, a8);
  v18 = *(*(*(a2 + 8) + 96) + 8);
  v19 = *a1;
  AttributeUniquer = mlir::MLIRContext::getAttributeUniquer(*a1);
  v79 = &mlir::detail::TypeIDResolver<mlir::mpsx::FusionTypeAttr,void>::id;
  v80 = v19;
  v75 = _ZN4llvm12function_refIFvPN4mlir4mpsx6detail21FusionTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_14FusionTypeAttrEJNS2_10FusionTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_;
  v76 = &v79;
  LODWORD(v74[0]) = a3;
  v21 = a3 ^ 0xFF51AFD7ED558CCDLL;
  v22 = 0x9DDFEA08EB382D69 * (((8 * a3) | 4) ^ v21);
  v85 = v74;
  v82 = v74;
  v83 = &v75;
  ParametricStorageTypeImpl = mlir::StorageUniquer::getParametricStorageTypeImpl(AttributeUniquer, &mlir::detail::TypeIDResolver<mlir::mpsx::FusionTypeAttr,void>::id, -348639895 * ((((0x9DDFEA08EB382D69 * (v21 ^ (v22 >> 47) ^ v22)) >> 32) >> 15) ^ (-348639895 * (v21 ^ (v22 >> 47) ^ v22))), llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::mpsx::detail::FusionTypeAttrStorage * mlir::StorageUniquer::get<mlir::mpsx::detail::FusionTypeAttrStorage,mlir::mpsx::FusionType>(llvm::function_ref<void ()(mlir::mpsx::detail::FusionTypeAttrStorage *)>,mlir::TypeID,mlir::mpsx::FusionType &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, &v85, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::mpsx::detail::FusionTypeAttrStorage * mlir::StorageUniquer::get<mlir::mpsx::detail::FusionTypeAttrStorage,mlir::mpsx::FusionType>(llvm::function_ref<void ()(mlir::mpsx::detail::FusionTypeAttrStorage *)>,mlir::TypeID,mlir::mpsx::FusionType &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, &v82);
  mlir::NamedAttribute::NamedAttribute(&v75, v18, ParametricStorageTypeImpl);
  mlir::NamedAttrList::push_back(a2 + 112, v75, v76);
  if (a5)
  {
    v24 = **(*(a2 + 8) + 96);
    v25 = *a1;
    v78 = 261;
    v75 = a4;
    v76 = a5;
    v26 = mlir::StringAttr::get(v25, &v75);
    mlir::NamedAttribute::NamedAttribute(&v82, v24, v26);
    mlir::NamedAttrList::push_back(a2 + 112, v82, v83);
  }

  v27 = mlir::OperationState::addRegion(a2);
  v28 = operator new(0x48uLL);
  *v28 = 0u;
  v28[1] = 0u;
  *(v28 + 4) = v28 + 2;
  *(v28 + 5) = v28 + 2;
  *(v28 + 7) = 0;
  *(v28 + 8) = 0;
  *(v28 + 6) = 0;
  v82 = v84;
  v83 = 0x400000000;
  v29 = v81;
  v79 = v81;
  v80 = 0x400000000;
  v75 = a7;
  v76 = 0;
  if (a8)
  {
    v30 = 0;
    do
    {
      v85 = mlir::ValueRange::dereference_iterator(&v75, v30);
      Loc = mlir::Value::getLoc(&v85);
      v32 = v83;
      if (v83 >= HIDWORD(v83))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v82, v84, v83 + 1, 8);
        v32 = v83;
      }

      *(v82 + v32) = Loc;
      LODWORD(v83) = v83 + 1;
      v33 = v85[1];
      v34 = v80;
      if (v80 >= HIDWORD(v80))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v79, v81, v80 + 1, 8);
        v34 = v80;
      }

      *(v79 + v34) = v33 & 0xFFFFFFFFFFFFFFF8;
      v35 = (v80 + 1);
      LODWORD(v80) = v80 + 1;
      v30 = v76 + 1;
      v76 = v30;
    }

    while (v30 != a8);
    v29 = v79;
  }

  else
  {
    v35 = 0;
  }

  mlir::ValueRange::ValueRange(&v75, v29, v35);
  mlir::Block::addArguments(v28, v75, v76, v82, v83);
  llvm::ilist_traits<mlir::Block>::addNodeToList(v27, v28);
  v36 = *v27;
  *(v28 + 2) = v27;
  *(v28 + 1) = v36;
  *(v36 + 8) = v28 + 8;
  *v27 = v28 + 8;
  v37 = a1 + 16;
  v72 = *(a1 + 16);
  v39 = *(v28 + 5);
  v38 = *(v28 + 6);
  *(a1 + 16) = v28;
  *(a1 + 24) = v39;
  v40 = *(v28 + 7);
  v75 = a7;
  v76 = 0;
  v77[0] = v38;
  if (a8 && v38 != v40)
  {
    v41 = 0;
    do
    {
      v42 = mlir::ValueRange::dereference_iterator(&v75, v41);
      v43 = *v77[0];
      v85 = v42;
      *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::operator[](a6, &v85) = v43;
      v41 = v76 + 1;
      v44 = v77[0] + 8;
      v76 = v41;
      v77[0] += 8;
      v45 = v41 == a8 || v44 == v40;
    }

    while (!v45);
  }

  if (a12)
  {
    v47 = 8 * a12;
    do
    {
      v48 = *a11++;
      mlir::OpBuilder::clone(a1, v48, a6);
      v47 -= 8;
    }

    while (v47);
  }

  v75 = v77;
  v76 = 0x600000000;
  if (a10 < 7)
  {
    v49 = 0;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v75, v77, a10, 8);
    v49 = v76;
  }

  v85 = a9;
  v86 = 0;
  v87 = a6;
  LOBYTE(v88) = 1;
  if (a10)
  {
    v50 = 0;
    v51 = (v75 + 8 * v49);
    do
    {
      v52 = mlir::ValueRange::dereference_iterator(&v85, v50);
      if (*(v87 + 4))
      {
        OUTLINED_FUNCTION_76_6();
        if (v45)
        {
LABEL_31:
          if (v55 != v53)
          {
            v52 = *(v54 + 16 * v55 + 8);
          }
        }

        else
        {
          while (v56 != -4096)
          {
            OUTLINED_FUNCTION_76_6();
            if (v45)
            {
              goto LABEL_31;
            }
          }
        }
      }

      *v51++ = v52;
      v50 = v86 + 1;
      v86 = v50;
    }

    while (v50 != a10);
    v49 = v76;
  }

  LODWORD(v76) = v49 + a10;
  v57 = mlir::OpBuilder::create<mlir::mpsx::FusionReturnOp,llvm::SmallVector<mlir::Value,6u> &>(a1, *a2, &v75);
  if ((*(v57 + 46) & 0x80) != 0)
  {
    v58 = *(v57 + 72);
    v59 = *(v57 + 68);
  }

  else
  {
    v58 = 0;
    v59 = 0;
  }

  v74[0] = v58;
  v74[1] = v59;
  mlir::OperandRange::getTypes(v74, &v85);
  v60 = v85;
  v61 = v86;
  v62 = v88;
  v63 = v88 - v86;
  v64 = *(a2 + 72);
  v65 = v88 - v86 + v64;
  if (v65 > *(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, a2 + 80, v65, 8);
    v64 = *(a2 + 72);
  }

  v66 = v62 - v61;
  v67 = v72;
  if (v62 != v61)
  {
    v68 = (*(a2 + 64) + 8 * v64);
    v69 = (v60 + 32 * v61 + 24);
    do
    {
      v70 = *v69;
      v69 += 4;
      *v68++ = *(v70 + 8) & 0xFFFFFFFFFFFFFFF8;
      --v66;
    }

    while (v66);
    LODWORD(v64) = *(a2 + 72);
  }

  *(a2 + 72) = v64 + v63;
  if (v75 != v77)
  {
    free(v75);
    v67 = v72;
  }

  if (v67)
  {
    *v37 = v67;
  }

  else
  {
    *v37 = 0;
    *(v37 + 8) = 0;
  }

  if (v79 != v81)
  {
    free(v79);
  }

  if (v82 != v84)
  {
    free(v82);
  }
}

uint64_t mlir::mpsx::QuantizedConv2DOp::getODSOperands(mlir::Operation **this, int a2)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(this, a2);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v4 = *(*this + 9);
  }

  else
  {
    v4 = 0;
  }

  return v4 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::mpsx::QuantizedGatherOp::getODSOperands(mlir::Operation **this, int a2)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedGatherOp::getODSOperandIndexAndLength(this, a2);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v4 = *(*this + 9);
  }

  else
  {
    v4 = 0;
  }

  return v4 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::mpsx::QuantizedMatMulOp::getODSOperands(mlir::Operation **this, int a2)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(this, a2);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v4 = *(*this + 9);
  }

  else
  {
    v4 = 0;
  }

  return v4 + 32 * ODSOperandIndexAndLength;
}

uint64_t mlir::mpsx::UseMemrefOp::verifyInvariantsImpl(mlir::mpsx::UseMemrefOp *this)
{
  v50 = *MEMORY[0x1E69E9840];
  v1 = *this;
  if ((*(*this + 46) & 0x80) == 0)
  {
    return 1;
  }

  v2 = *(v1 + 68);
  if (!v2)
  {
    return 1;
  }

  v4 = 0;
  v5 = *(v1 + 72);
  while (1)
  {
    v6 = *this;
    v7 = *(*(v5 + 32 * v4 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
    v37 = v7;
    v8 = *(*v7 + 136);
    v9 = v8 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id || v8 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
    if (!v9)
    {
      break;
    }

    v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v7 + 8);
    v41[0] = v7;
    v41[1] = v10;
    mlir::ElementsAttr::isSplat(v41);
LABEL_40:
    if (++v4 == v2)
    {
      return 1;
    }
  }

  if (mlir::Type::isSignlessInteger(&v37, 1))
  {
    goto LABEL_40;
  }

  v36 = 261;
  v35[0] = "operand";
  v35[1] = 7;
  mlir::Operation::emitOpError(v6, v35, v41);
  mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v41, " #");
  v12 = v11;
  if (*v11)
  {
    v13 = *(v11 + 24);
    v38 = 5;
    v39 = v4;
    if (*(v11 + 32) >= *(v11 + 36))
    {
      OUTLINED_FUNCTION_21_12();
      OUTLINED_FUNCTION_32_10();
      v13 = *(v12 + 24);
    }

    OUTLINED_FUNCTION_22_7((v13 + 24 * *(v12 + 32)));
    v14 = *(v12 + 32) + 1;
    *(v12 + 32) = v14;
    if (*v12)
    {
      v38 = 3;
      v39 = " must be variadic of tensor of any type values or 1-bit signless integer, but got ";
      v40 = 82;
      v15 = *(v12 + 24);
      if (v14 >= *(v12 + 36))
      {
        OUTLINED_FUNCTION_21_12();
        OUTLINED_FUNCTION_32_10();
        v15 = *(v12 + 24);
      }

      OUTLINED_FUNCTION_22_7((v15 + 24 * *(v12 + 32)));
      ++*(v12 + 32);
      if (*v12)
      {
        v16 = &v38;
        mlir::DiagnosticArgument::DiagnosticArgument(&v38, v37);
        v17 = *(v12 + 24);
        if (*(v12 + 32) >= *(v12 + 36))
        {
          OUTLINED_FUNCTION_21_12();
          if (!(!v9 & v32) && (v30 & 1) != 0)
          {
            v33 = v31 - v29;
            OUTLINED_FUNCTION_32_10();
            v17 = *(v12 + 24);
            v16 = (v17 + v33);
          }

          else
          {
            OUTLINED_FUNCTION_32_10();
            v17 = *(v12 + 24);
            v16 = &v38;
          }
        }

        v18 = v17 + 24 * *(v12 + 32);
        v19 = *v16;
        *(v18 + 16) = *(v16 + 2);
        *v18 = v19;
        ++*(v12 + 32);
      }
    }
  }

  v20 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v12);
  if (v41[0])
  {
    mlir::InFlightDiagnostic::report(v41);
  }

  if (v49 == 1)
  {
    if (v48 != &v49)
    {
      free(v48);
    }

    v21 = __p;
    if (__p)
    {
      v22 = v47;
      v23 = __p;
      if (v47 != __p)
      {
        do
        {
          v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v22 - 1);
        }

        while (v22 != v21);
        v23 = __p;
      }

      v47 = v21;
      operator delete(v23);
    }

    v24 = v44;
    if (v44)
    {
      v25 = v45;
      v26 = v44;
      if (v45 != v44)
      {
        do
        {
          v28 = *--v25;
          v27 = v28;
          *v25 = 0;
          if (v28)
          {
            operator delete[](v27);
          }
        }

        while (v25 != v24);
        v26 = v44;
      }

      v45 = v24;
      operator delete(v26);
    }

    if (v42 != &v43)
    {
      free(v42);
    }
  }

  if (v20)
  {
    goto LABEL_40;
  }

  return 0;
}

BOOL mlir::mpsx::QuantizedMatMulOp::isWeightsQuantized(mlir::mpsx::QuantizedMatMulOp *this)
{
  if (mlir::mpsx::QuantizedMatMulOp::isWeightsAffineQuantized(this))
  {
    return 1;
  }

  v9 = *this;
  v2 = v9;
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v9, 8);
  v4 = (*(v2 + 46) & 0x80) != 0 ? *(v2 + 9) : 0;
  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength != ODSOperandIndexAndLength && *(v4 + 32 * ODSOperandIndexAndLength + 24))
  {
    return 1;
  }

  v6 = *this;
  v9 = v6;
  v7 = mlir::mpsx::QuantizedMatMulOp::getODSOperandIndexAndLength(&v9, 9);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v8 = *(v6 + 72);
  }

  else
  {
    v8 = 0;
  }

  return HIDWORD(v7) + v7 != v7 && *(v8 + 32 * v7 + 24) != 0;
}

uint64_t mlir::mpsx::QuantizedConv2DOp::getWeightsScale(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(this, 5);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mpsx::QuantizedConv2DOp::getBiquantWeightsScale(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(this, 9);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mpsx::QuantizedConv2DOp::getWeightsPaletteLut(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(this, 8);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

BOOL mlir::mpsx::QuantizedConv2DOp::isWeightsQuantized(mlir::mpsx::QuantizedConv2DOp *this)
{
  if (mlir::mpsx::QuantizedConv2DOp::isWeightsAffineQuantized(this))
  {
    return 1;
  }

  v9 = *this;
  v2 = v9;
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v9, 8);
  v4 = (*(v2 + 46) & 0x80) != 0 ? *(v2 + 9) : 0;
  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength != ODSOperandIndexAndLength && *(v4 + 32 * ODSOperandIndexAndLength + 24))
  {
    return 1;
  }

  v6 = *this;
  v9 = v6;
  v7 = mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(&v9, 9);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v8 = *(v6 + 72);
  }

  else
  {
    v8 = 0;
  }

  return HIDWORD(v7) + v7 != v7 && *(v8 + 32 * v7 + 24) != 0;
}

uint64_t mlir::mpsx::QuantizedConv2DOp::getWeightsZeroPoint(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(this, 6);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mpsx::QuantizedConv2DOp::getBiquantWeightsZeroPoint(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(this, 10);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

uint64_t mlir::mpsx::QuantizedConv2DOp::getWeightsMin(mlir::Operation **this)
{
  ODSOperandIndexAndLength = mlir::mpsx::QuantizedConv2DOp::getODSOperandIndexAndLength(this, 7);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 9);
  }

  else
  {
    v3 = 0;
  }

  if (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength == ODSOperandIndexAndLength)
  {
    return 0;
  }

  else
  {
    return *(v3 + 32 * ODSOperandIndexAndLength + 24);
  }
}

void mlir::mpsx::MPSXDialect::initialize()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeDialectInterface>();
    mlir::detail::TypeIDResolver<mlir::BytecodeDialectInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::mpsx::detail::TypeWithStaticSubtypesImpl<mlir::mpsx::ListType,1u>::get()
{
  {
    v0 = llvm::getTypeName<mlir::mpsx::ListType>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_51_7(v2);
  }
}

void mlir::OpBuilder::create<mlir::mpsx::FusionReturnOp,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.fusion_return";
  *(a2 + 24) = 18;
}

uint64_t mlir::mpsx::FusionOp::verifyInvariantsImpl(uint64_t result, uint64_t *a2, char *a3)
{
  v4 = *(result + 36);
  if (*(result + 36))
  {
    v5 = result - 16;
  }

  else
  {
    v5 = 0;
  }

  if (v4)
  {
    v7 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, v7);
      result = mlir::placement::__mlir_ods_local_type_constraint_PlacementOps5(*a2, (*(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), "result", 6, v7);
      if ((result & 1) == 0)
      {
        break;
      }

      if (v4 == ++v7)
      {
        goto LABEL_8;
      }
    }

    v9 = 0;
  }

  else
  {
LABEL_8:
    v9 = 1;
  }

  *a3 = v9;
  return result;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::mpsx::ANEOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::SymbolOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_75_6(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::mpsx::ANEOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::CallableOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_74_5(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_88_5(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_87_4(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::TargetLegalizerInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::TargetLegalizerInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::TargetLegalizerInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::TargetLegalizerInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::FormableRegionOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::FormableRegionOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::FormableRegionOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::FormableRegionOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mpsx::BufferToTensorOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::CompatibleReturnTypesInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_42_7(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_66_6(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_48_7(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_47_7(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_65_6(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::mpsx::FusionReturnOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::HasRecursiveMemoryEffects>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::mpsx::FusionReturnOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::mpsx::FusionReturnOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::mpsx::FusionReturnOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::mpsx::FusionReturnOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::mpsx::FusionOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::mpsx::FusionOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::mpsx::FusionOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::mpsx::FusionOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::mpsx::FusionOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNOperands<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<4u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<4u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::mpsx::StitchedOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::mpsx::StitchedOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::mpsx::StitchedOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::mpsx::StitchedOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::mpsx::StitchedOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<5u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<5u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<5u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<5u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::mpsx::MemrefBackedOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::mpsx::MemrefBackedOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::mpsx::MemrefBackedOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::mpsx::MemrefBackedOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::mpsx::MemrefBackedOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::Dialect::addType<mlir::mpsx::ListType>()
{
  {
    v0 = llvm::getTypeName<mlir::mpsx::ListType>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_51_7(v2);
  }
}

void mlir::mps_spi::StridedArrayViewOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v139[4] = *MEMORY[0x1E69E9840];
  (*(*a2 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v4, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v4, v5);
  }

  OUTLINED_FUNCTION_104();
  (*(v7 + 160))(a2);
  OUTLINED_FUNCTION_104();
  (*(v8 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v9, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v9, v10);
  }

  OUTLINED_FUNCTION_104();
  (*(v11 + 16))(a2);
  OUTLINED_FUNCTION_72_0();
  if (v14 > 1)
  {
    OUTLINED_FUNCTION_9_15(v12, v13);
  }

  else
  {
    llvm::raw_ostream::write(v12, "to", 2uLL);
  }

  OUTLINED_FUNCTION_104();
  (*(v15 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v16, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v16, v17);
  }

  OUTLINED_FUNCTION_104();
  (*(v18 + 16))(a2);
  OUTLINED_FUNCTION_72_0();
  if (v21 > 5)
  {
    *(v20 + 4) = 29797;
    *v20 = 1936090735;
    v19[4] += 6;
  }

  else
  {
    llvm::raw_ostream::write(v19, "offset", 6uLL);
  }

  OUTLINED_FUNCTION_104();
  (*(v22 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v25)
  {
    llvm::raw_ostream::write(v23, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v23, v24);
  }

  OUTLINED_FUNCTION_104();
  (*(v26 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v27, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v27, v28);
  }

  AttrDictionary = *(*this + 2 * ((*(*this + 11) >> 23) & 1) + 8);
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&AttrDictionary);
  OUTLINED_FUNCTION_44_0();
  v32 = mlir::ValueRange::ValueRange(v29, v30, v31);
  OUTLINED_FUNCTION_15_7(v32, v33, v34, v35, v36, v37, v38, v39, v124, v127, v130, v133, AttrDictionary, v137, v138);
  OUTLINED_FUNCTION_104();
  (*(v40 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v25)
  {
    llvm::raw_ostream::write(v41, ",", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v41, v42);
  }

  OUTLINED_FUNCTION_104();
  (*(v43 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v44, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v44, v45);
  }

  OUTLINED_FUNCTION_104();
  (*(v46 + 16))(a2);
  OUTLINED_FUNCTION_72_0();
  if (v49 > 4)
  {
    *(v48 + 4) = 115;
    *v48 = 1702521203;
    v47[4] += 5;
  }

  else
  {
    llvm::raw_ostream::write(v47, "sizes", 5uLL);
  }

  OUTLINED_FUNCTION_104();
  (*(v50 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v25)
  {
    llvm::raw_ostream::write(v51, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v51, v52);
  }

  OUTLINED_FUNCTION_104();
  (*(v53 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v54, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v54, v55);
  }

  AttrDictionary = *(*this + 2 * ((*(*this + 11) >> 23) & 1) + 9);
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&AttrDictionary);
  OUTLINED_FUNCTION_44_0();
  v59 = mlir::ValueRange::ValueRange(v56, v57, v58);
  OUTLINED_FUNCTION_15_7(v59, v60, v61, v62, v63, v64, v65, v66, v125, v128, v131, v134, AttrDictionary, v137, v138);
  OUTLINED_FUNCTION_104();
  (*(v67 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v25)
  {
    llvm::raw_ostream::write(v68, ",", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v68, v69);
  }

  OUTLINED_FUNCTION_104();
  (*(v70 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v71, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v71, v72);
  }

  OUTLINED_FUNCTION_104();
  (*(v73 + 16))(a2);
  OUTLINED_FUNCTION_72_0();
  if (v76 > 6)
  {
    *(v75 + 3) = 1936024681;
    *v75 = 1769108595;
    v74[4] += 7;
  }

  else
  {
    llvm::raw_ostream::write(v74, "strides", 7uLL);
  }

  OUTLINED_FUNCTION_104();
  (*(v77 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v25)
  {
    llvm::raw_ostream::write(v78, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v78, v79);
  }

  OUTLINED_FUNCTION_104();
  (*(v80 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v81, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v81, v82);
  }

  AttrDictionary = *(*this + 2 * ((*(*this + 11) >> 23) & 1) + 10);
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&AttrDictionary);
  OUTLINED_FUNCTION_44_0();
  v86 = mlir::ValueRange::ValueRange(v83, v84, v85);
  OUTLINED_FUNCTION_15_7(v86, v87, v88, v89, v90, v91, v92, v93, v126, v129, v132, v135, AttrDictionary, v137, v138);
  v137 = v139;
  v139[0] = "operandSegmentSizes";
  v139[1] = 19;
  v139[2] = "static_offsets";
  v139[3] = 14;
  v138 = 0x200000002;
  llvm::SmallVectorBase<unsigned int>::grow_pod(&v137, v139, 3uLL, 16);
  v94 = v137 + 16 * v138;
  *v94 = "static_sizes";
  v94[1] = 12;
  v95 = (v138 + 1);
  LODWORD(v138) = v95;
  if (v95 >= HIDWORD(v138))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v137, v139, v95 + 1, 16);
    LODWORD(v95) = v138;
  }

  v96 = v137 + 16 * v95;
  *v96 = "static_strides";
  v96[1] = 14;
  LODWORD(v138) = v138 + 1;
  AttrDictionary = mlir::Operation::getAttrDictionary(*this);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_104();
  (*(v97 + 192))(a2, v98, v99);
  OUTLINED_FUNCTION_104();
  (*(v100 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v101, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v101, v102);
  }

  OUTLINED_FUNCTION_104();
  (*(v103 + 16))(a2);
  OUTLINED_FUNCTION_17_2();
  if (v25)
  {
    llvm::raw_ostream::write(v104, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v104, v105);
  }

  OUTLINED_FUNCTION_104();
  (*(v106 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v107, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v107, v108);
  }

  OUTLINED_FUNCTION_104();
  (*(v109 + 32))(a2, v110 & 0xFFFFFFFFFFFFFFF8);
  OUTLINED_FUNCTION_104();
  (*(v111 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v112, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v112, v113);
  }

  OUTLINED_FUNCTION_104();
  (*(v114 + 16))(a2);
  OUTLINED_FUNCTION_72_0();
  if (v117 > 1)
  {
    OUTLINED_FUNCTION_9_15(v115, v116);
  }

  else
  {
    llvm::raw_ostream::write(v115, "to", 2uLL);
  }

  OUTLINED_FUNCTION_104();
  (*(v118 + 16))(a2);
  OUTLINED_FUNCTION_13_3();
  if (v6)
  {
    llvm::raw_ostream::write(v119, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v119, v120);
  }

  if (*(*this + 9))
  {
    v121 = *this - 16;
  }

  else
  {
    v121 = 0;
  }

  mlir::detail::OpResultImpl::getNextResultAtOffset(v121, 0);
  OUTLINED_FUNCTION_104();
  (*(v122 + 32))(a2, v123 & 0xFFFFFFFFFFFFFFF8);
  if (v137 != v139)
  {
    free(v137);
  }
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::mps_spi::StridedArrayViewOp>::getOffsets(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 44);
  v3 = *(a2 + 16 * ((v2 >> 23) & 1) + 88);
  if ((v2 & 0x800000) != 0)
  {
    v4 = *(a2 + 72);
  }

  else
  {
    v4 = 0;
  }

  return v4 + 32 * v3;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::mps_spi::StridedArrayViewOp>::getSizes(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 44);
  v3 = a2 + 16 * ((v2 >> 23) & 1);
  if ((v2 & 0x800000) != 0)
  {
    v4 = *(a2 + 72);
  }

  else
  {
    v4 = 0;
  }

  return v4 + 32 * (*(v3 + 92) + *(v3 + 88));
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::mps_spi::StridedArrayViewOp>::getStrides(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 44);
  v3 = (a2 + 16 * ((v2 >> 23) & 1));
  if ((v2 & 0x800000) != 0)
  {
    v4 = *(a2 + 72);
  }

  else
  {
    v4 = 0;
  }

  return v4 + 32 * (v3[23] + v3[22] + v3[24]);
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::mps_spi::StridedArrayViewOp>::getMixedOffsets(uint64_t a1@<X0>, void *a2@<X8>)
{
  v16[6] = *MEMORY[0x1E69E9840];
  Context = mlir::Attribute::getContext((*a1 + 24));
  v14 = *(*a1 + 16 * ((*(*a1 + 44) >> 23) & 1) + 64);
  v4 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&v14);
  v6 = v5;
  v7 = *(*a1 + 44);
  v8 = *a1 + 16 * ((v7 >> 23) & 1);
  v9 = *(v8 + 88);
  v10 = *(v8 + 92);
  if ((v7 & 0x800000) != 0)
  {
    v11 = *(*a1 + 72);
  }

  else
  {
    v11 = 0;
  }

  mlir::ValueRange::ValueRange(v13, v11 + 32 * v9, (v10 + v9) - v9);
  mlir::getMixedValues(v4, v6, v13[0], v13[1], &Context, &v14);
  *a2 = a2 + 2;
  a2[1] = 0x400000000;
  if (v15)
  {
    llvm::SmallVectorImpl<unsigned long long>::operator=(a2, &v14);
  }

  if (v14 != v16)
  {
    free(v14);
  }
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::mps_spi::StridedArrayViewOp>::getMixedSizes(uint64_t a1@<X0>, void *a2@<X8>)
{
  v17[6] = *MEMORY[0x1E69E9840];
  Context = mlir::Attribute::getContext((*a1 + 24));
  v15 = *(*a1 + 16 * ((*(*a1 + 44) >> 23) & 1) + 72);
  v4 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&v15);
  v6 = v5;
  v7 = *(*a1 + 44);
  v8 = (*a1 + 16 * ((v7 >> 23) & 1));
  v9 = v8[22];
  v10 = v8[23];
  v11 = v8[24];
  if ((v7 & 0x800000) != 0)
  {
    v12 = *(*a1 + 72);
  }

  else
  {
    v12 = 0;
  }

  mlir::ValueRange::ValueRange(v14, v12 + 32 * (v10 + v9), (v11 + v10 + v9) - (v10 + v9));
  mlir::getMixedValues(v4, v6, v14[0], v14[1], &Context, &v15);
  *a2 = a2 + 2;
  a2[1] = 0x400000000;
  if (v16)
  {
    llvm::SmallVectorImpl<unsigned long long>::operator=(a2, &v15);
  }

  if (v15 != v17)
  {
    free(v15);
  }
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::mps_spi::StridedArrayViewOp>::getMixedStrides(uint64_t a1@<X0>, void *a2@<X8>)
{
  v18[6] = *MEMORY[0x1E69E9840];
  Context = mlir::Attribute::getContext((*a1 + 24));
  v16 = *(*a1 + 16 * ((*(*a1 + 44) >> 23) & 1) + 80);
  v4 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&v16);
  v6 = v5;
  v7 = *(*a1 + 44);
  v8 = (*a1 + 16 * ((v7 >> 23) & 1));
  v9 = v8[22];
  v10 = v8[23];
  v12 = v8[24];
  v11 = v8[25];
  if ((v7 & 0x800000) != 0)
  {
    v13 = *(*a1 + 72);
  }

  else
  {
    v13 = 0;
  }

  mlir::ValueRange::ValueRange(v15, v13 + 32 * (v10 + v9 + v12), (v11 + v10 + v9 + v12) - (v10 + v9 + v12));
  mlir::getMixedValues(v4, v6, v15[0], v15[1], &Context, &v16);
  *a2 = a2 + 2;
  a2[1] = 0x400000000;
  if (v17)
  {
    llvm::SmallVectorImpl<unsigned long long>::operator=(a2, &v16);
  }

  if (v16 != v18)
  {
    free(v16);
  }
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps_spi::StridedArrayViewOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::ViewLikeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::mps_spi::StridedArrayViewOp::print(&v7, a3);
}

void mlir::OperationState::getOrAddProperties<mlir::mps_spi::detail::StridedArrayViewOpGenericAdaptorBase::Properties>()
{
  {
    v0 = llvm::getTypeName<mlir::mps_spi::detail::StridedArrayViewOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::mps_spi::detail::StridedArrayViewOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps_spi::RMSNormOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::DowngraderInterface>();
    mlir::detail::TypeIDResolver<mlir::DowngraderInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::DowngraderInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DowngraderInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::DowngraderInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DowngraderInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::mps_spi::StridedArrayViewOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::OffsetSizeAndStrideOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_14_16(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::ViewLikeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::ViewLikeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ViewLikeOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ViewLikeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ViewLikeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::impl::foldCastInterfaceOp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(a1 + 46) & 0x80) == 0)
  {
    return 0;
  }

  v4 = *(a1 + 68);
  v40 = *(a1 + 72);
  v41 = v4;
  if (!v4)
  {
    return 0;
  }

  v6 = *(a1 + 36);
  v7 = a1 - 16;
  if (!v6)
  {
    v7 = 0;
  }

  v39[0] = v7;
  v39[1] = v6;
  mlir::OperandRange::getTypes(&v40, &v36);
  mlir::OperandRange::getTypes(v39, &v33);
  v8 = v38 - v37;
  v9 = v34;
  if (v38 - v37 != v35 - v34)
  {
    return 0;
  }

  if (v38 != v37)
  {
    v10 = v33;
    v11 = v36 + 32 * v37 + 24;
    do
    {
      v12 = *(*v11 + 8);
      if ((*(mlir::detail::OpResultImpl::getNextResultAtOffset(v10, v9) + 8) ^ v12) > 7)
      {
        return 0;
      }

      ++v9;
      v11 += 32;
    }

    while (--v8);
  }

  v14 = v40;
  v13 = v41;
  v15 = *(a4 + 8);
  if (v41 + v15 > *(a4 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a4, a4 + 16, v41 + v15, 8);
    v15 = *(a4 + 8);
  }

  if (v13)
  {
    v16 = (*a4 + 8 * v15);
    if (v13 >= 0xB && ((v17 = *a4 + 8 * (v15 + v13), v16 < v14 + 32 * v13) ? (v18 = v14 + 24 >= v17) : (v18 = 1), v18))
    {
      v19 = v13 & 3;
      if ((v13 & 3) == 0)
      {
        v19 = 4;
      }

      v20 = v13 - v19;
      v21 = (v16 + 8 * v20);
      v22 = (v14 + 88);
      v23 = v16 + 1;
      v24 = v20;
      do
      {
        v25 = v22 - 8;
        v26 = vld4q_f64(v25);
        v27 = vld4q_f64(v22);
        v28 = vdupq_n_s64(4uLL);
        v23[-1] = vorrq_s8(v26, v28);
        *v23 = vorrq_s8(v27, v28);
        v22 += 16;
        v23 += 2;
        v24 -= 4;
      }

      while (v24);
      v16 = v21;
    }

    else
    {
      v20 = 0;
    }

    v30 = v13 - v20;
    v31 = (v14 + 32 * v20 + 24);
    do
    {
      v32 = *v31;
      v31 += 4;
      v16->i64[0] = v32 | 4;
      v16 = (v16 + 8);
      --v30;
    }

    while (v30);
    LODWORD(v15) = *(a4 + 8);
  }

  *(a4 + 8) = v15 + v13;
  return 1;
}

BOOL mlir::mps::executionCost(uint64_t a1, uint64_t a2, void *a3)
{
  {
    v63 = llvm::getTypeName<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v63, v64);
  }

  OUTLINED_FUNCTION_5_16();
  v5 = (*(v4 + 32))();
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v6 = *(a2 + 68);
    if (v6)
    {
      v7 = v5;
      v8 = 0;
      v9 = (*(a2 + 72) + 24);
      do
      {
        v69 = *v9;
        DefiningOp = mlir::Value::getDefiningOp(&v69);
        if (((DefiningOp != 0) & v7) != 1)
        {
          goto LABEL_39;
        }

        v11 = DefiningOp;
        {
          v31 = llvm::getTypeName<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>>();
          mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v31, v32);
        }

        OUTLINED_FUNCTION_5_16();
        if (((*(v12 + 32))() & 1) == 0)
        {
          v13 = *(*(v11 + 48) + 16);
          v14 = v13 == &mlir::detail::TypeIDResolver<mlir::mps::FastFourierTransformOp,void>::id || v13 == &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id;
          v15 = v14 || v13 == &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id;
          v16 = v15 || v13 == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id;
          v17 = v16 || v13 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
          v18 = v17 || v13 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionProdOp,void>::id;
          v19 = v18 || v13 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMinOp,void>::id;
          v20 = v19 || v13 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id;
          v21 = v20 || v13 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id;
          v22 = v21 || v13 == &mlir::detail::TypeIDResolver<mlir::mps::IdentityOp,void>::id;
          if (!v22 && v13 != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
          {
LABEL_39:
            v24 = (*(v69 + 8) & 0xFFFFFFFFFFFFFFF8);
            v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v24 + 8);
            if (v25)
            {
              v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v24 + 8);
            }

            else
            {
              v24 = 0;
            }

            v70 = v24;
            v71 = v25;
            ElementBitWidth = mlir::mps::getElementBitWidth(v24);
            ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v70);
            NumElements = mlir::ShapedType::getNumElements(ArgAttrsAttr, v28);
            if (ElementBitWidth)
            {
              v30 = NumElements;
            }

            else
            {
              v30 = 0;
            }

            v8 += v30;
          }
        }

        v9 += 4;
        --v6;
      }

      while (v6);
    }
  }

  {
    v65 = llvm::getTypeName<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v65, v66);
  }

  OUTLINED_FUNCTION_5_16();
  v68 = (*(v33 + 32))();
  v34 = *(a2 + 36);
  if (v34)
  {
    v35 = a2 - 16;
  }

  else
  {
    v35 = 0;
  }

  v36 = 0;
  if (v34)
  {
    for (i = 0; i != v34; ++i)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v35, i);
      if (!*NextResultAtOffset || **NextResultAtOffset)
      {
        goto LABEL_92;
      }

      {
        v58 = llvm::getTypeName<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>>();
        mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v58, v59);
      }

      OUTLINED_FUNCTION_5_16();
      if ((*(v39 + 32))())
      {
        if (v68)
        {
          continue;
        }

        v40 = *(*(a2 + 48) + 16);
        v41 = v40 == &mlir::detail::TypeIDResolver<mlir::mps::FastFourierTransformOp,void>::id || v40 == &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id;
        v42 = v41 || v40 == &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id;
        v43 = v42 || v40 == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id;
        v44 = v43 || v40 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
        v45 = v44 || v40 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionProdOp,void>::id;
        v46 = v45 || v40 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMinOp,void>::id;
        v47 = v46 || v40 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id;
        v48 = v47 || v40 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id;
        v49 = v48 || v40 == &mlir::detail::TypeIDResolver<mlir::mps::IdentityOp,void>::id;
        if (v49 || v40 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
        {
          continue;
        }
      }

LABEL_92:
      v51 = (NextResultAtOffset[1] & 0xFFFFFFFFFFFFFFF8);
      v52 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v51 + 8);
      if (v52)
      {
        v52 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v51 + 8);
      }

      else
      {
        v51 = 0;
      }

      v70 = v51;
      v71 = v52;
      v53 = mlir::mps::getElementBitWidth(v51);
      v54 = mlir::CallableOpInterface::getArgAttrsAttr(&v70);
      v56 = mlir::ShapedType::getNumElements(v54, v55);
      if (v53)
      {
        v57 = v56;
      }

      else
      {
        v57 = 0;
      }

      v36 += v57;
    }
  }

  v70 = a3;
  do
  {
    v60 = *(a2 + 16);
    if (!v60)
    {
      break;
    }

    ParentOp = mlir::Block::getParentOp(v60);
    if (!ParentOp)
    {
      break;
    }

    a2 = ParentOp;
  }

  while (*(*(ParentOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::GPUOp,void>::id);
  result = mlir::Type::isF16(&v70);
  if (!result)
  {
    return mlir::Type::isF32(&v70);
  }

  return result;
}

void mlir::mps::MPSCostModel::computeCostLSTMOp(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  v39 = a2;
  ODSOperandIndexAndLength = mlir::mps::GRUOp::getODSOperandIndexAndLength(&v39, 0);
  v5 = *(*(v39 + 72) + 32 * ODSOperandIndexAndLength + 24);
  v6 = mlir::mps::GRUOp::getODSOperandIndexAndLength(&v39, 4u);
  if ((*(v39 + 46) & 0x80) != 0)
  {
    v7 = *(v39 + 72);
  }

  else
  {
    v7 = 0;
  }

  v8 = HIDWORD(v6) + v6 == v6 || *(v7 + 32 * v6 + 24) == 0;
  v9 = *(v5 + 8) & 0xFFFFFFFFFFFFFFF8;
  v10 = OUTLINED_FUNCTION_6_15();
  if (v10)
  {
    v10 = OUTLINED_FUNCTION_6_15();
  }

  else
  {
    v9 = 0;
  }

  v38[0] = v9;
  v38[1] = v10;
  v40[0] = v9;
  v40[1] = v10;
  if (v9 && mlir::CallOpInterface::getArgOperands(v40))
  {
    ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v40);
    if (v12)
    {
      v13 = 8 * v12;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v13 -= 8;
        if (!v13)
        {
          goto LABEL_15;
        }
      }
    }

    else
    {
LABEL_15:
      v14 = mlir::CallableOpInterface::getArgAttrsAttr(v38);
      v15 = *(v14 + 8);
      v16 = *(v14 + 16) / 4;
      isSplat = mlir::ElementsAttr::isSplat(v38);
      v40[0] = mlir::ElementsAttr::isSplat(v38);
      v18 = v16 * (mlir::Type::getIntOrFloatBitWidth(v40) >> 3);
      if (!v8)
      {
        v19 = v39;
        v40[0] = isSplat;
        while (1)
        {
          v20 = *(v19 + 16);
          if (!v20 || !mlir::Block::getParentOp(v20))
          {
            break;
          }

          OUTLINED_FUNCTION_2_20();
          if (v21)
          {
            v22 = 1;
            goto LABEL_25;
          }
        }

        v22 = 0;
LABEL_25:
        v23 = v22 | *a3;
        if (mlir::Type::isF16(v40))
        {
          v24 = 8;
          if (v23)
          {
            v24 = 24;
          }
        }

        else
        {
          isF32 = mlir::Type::isF32(v40);
          v24 = 12;
          if (v23)
          {
            v24 = 28;
          }

          v26 = 4;
          if (v23)
          {
            v26 = 20;
          }

          if (isF32)
          {
            v24 = v26;
          }
        }

        v27 = OUTLINED_FUNCTION_3_19(*&a3[v24], 1.0e12);
        v28 = 16;
        if (v23)
        {
          v28 = 32;
        }

        OUTLINED_FUNCTION_4_14(v27, (2 * v18 * v15) / (*&a3[v28] * 1000000000.0));
      }

      mlir::mps::GRUOp::getTraining(&v39);
      v29 = v39;
      while (1)
      {
        v30 = *(v29 + 16);
        if (!v30 || !mlir::Block::getParentOp(v30))
        {
          break;
        }

        OUTLINED_FUNCTION_2_20();
        if (v21)
        {
          goto LABEL_45;
        }
      }

      if ((*a3 & 1) == 0)
      {
        goto LABEL_46;
      }

LABEL_45:
      pow(((((4 * v16) + 2.0) * v15) * 3.0), 0.25);
LABEL_46:
      v31 = v39;
      v40[0] = isSplat;
      while (1)
      {
        v32 = *(v31 + 16);
        if (!v32 || !mlir::Block::getParentOp(v32))
        {
          break;
        }

        OUTLINED_FUNCTION_2_20();
        if (v21)
        {
          v33 = 1;
          goto LABEL_53;
        }
      }

      v33 = 0;
LABEL_53:
      v34 = v33 | *a3;
      if (mlir::Type::isF16(v40))
      {
        v35 = 8;
        if (v34)
        {
          v35 = 24;
        }
      }

      else
      {
        v36 = mlir::Type::isF32(v40);
        v35 = 12;
        if (v34)
        {
          v35 = 28;
        }

        v37 = 4;
        if (v34)
        {
          v37 = 20;
        }

        if (v36)
        {
          v35 = v37;
        }
      }

      OUTLINED_FUNCTION_3_19(*&a3[v35], 1.0e12);
    }
  }
}

void mlir::mps::MPSCostModel::computeCostConcatOp(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  v51 = *MEMORY[0x1E69E9840];
  v44 = a2;
  ODSOperandIndexAndLength = mlir::mps::ConcatOp::getODSOperandIndexAndLength(&v44, 0);
  if ((*(v44 + 46) & 0x80) != 0)
  {
    v5 = *(v44 + 72);
  }

  else
  {
    v5 = 0;
  }

  mlir::ValueRange::ValueRange(&v49, v5 + 32 * ODSOperandIndexAndLength, (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength) - ODSOperandIndexAndLength);
  if (*(v44 + 36))
  {
    v6 = v44 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v8 = OUTLINED_FUNCTION_6_15();
  if (v8)
  {
    v8 = OUTLINED_FUNCTION_6_15();
  }

  else
  {
    v7 = 0;
  }

  v43[0] = v7;
  v43[1] = v8;
  v45 = v7;
  v46 = v8;
  if (v7 && mlir::CallOpInterface::getArgOperands(&v45))
  {
    ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v45);
    if (v10)
    {
      v11 = 8 * v10;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v11 -= 8;
        if (!v11)
        {
          goto LABEL_15;
        }
      }
    }

    else
    {
LABEL_15:
      v12 = v50;
      v47 = v49;
      v48 = 0;
      if (v50)
      {
        v13 = 0;
        v14 = 0;
        while (1)
        {
          v15 = (*(mlir::ValueRange::dereference_iterator(&v47, v13) + 8) & 0xFFFFFFFFFFFFFFF8);
          v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8);
          if (v16)
          {
            v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8);
          }

          else
          {
            v15 = 0;
          }

          v42[0] = v15;
          v42[1] = v16;
          v45 = v15;
          v46 = v16;
          if (!v15 || !mlir::CallOpInterface::getArgOperands(&v45))
          {
            break;
          }

          v17 = mlir::CallableOpInterface::getArgAttrsAttr(&v45);
          if (v18)
          {
            v19 = 8 * v18;
            while (*v17 != 0x8000000000000000)
            {
              ++v17;
              v19 -= 8;
              if (!v19)
              {
                goto LABEL_26;
              }
            }

            return;
          }

LABEL_26:
          ElementBitWidth = mlir::mps::getElementBitWidth(v42[0]);
          v21 = mlir::CallableOpInterface::getArgAttrsAttr(v42);
          NumElements = mlir::ShapedType::getNumElements(v21, v22);
          if (ElementBitWidth)
          {
            v24 = NumElements;
          }

          else
          {
            v24 = 0;
          }

          v14 += v24;
          v13 = v48 + 1;
          v48 = v13;
          if (v13 == v12)
          {
            goto LABEL_33;
          }
        }
      }

      else
      {
        v14 = 0;
LABEL_33:
        v25 = mlir::mps::getElementBitWidth(v7);
        v26 = mlir::CallableOpInterface::getArgAttrsAttr(v43);
        v28 = mlir::ShapedType::getNumElements(v26, v27);
        if (v25)
        {
          v29 = v28;
        }

        else
        {
          v29 = 0;
        }

        v30 = mlir::CallableOpInterface::getArgAttrsAttr(v43);
        mlir::ShapedType::getNumElements(v30, v31);
        isSplat = mlir::ElementsAttr::isSplat(v43);
        ParentOp = v44;
        v45 = isSplat;
        while (1)
        {
          v34 = *(ParentOp + 16);
          if (!v34)
          {
            break;
          }

          ParentOp = mlir::Block::getParentOp(v34);
          if (!ParentOp)
          {
            break;
          }

          if (*(*(ParentOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::GPUOp,void>::id)
          {
            v35 = 1;
            goto LABEL_42;
          }
        }

        v35 = 0;
LABEL_42:
        v36 = v35 | *a3;
        if (mlir::Type::isF16(&v45))
        {
          v37 = 8;
          if (v36)
          {
            v37 = 24;
          }
        }

        else
        {
          isF32 = mlir::Type::isF32(&v45);
          v37 = 12;
          if (v36)
          {
            v37 = 28;
          }

          v39 = 4;
          if (v36)
          {
            v39 = 20;
          }

          if (isF32)
          {
            v37 = v39;
          }
        }

        v40 = OUTLINED_FUNCTION_3_19(*&a3[v37], 1.0e12);
        v41 = 16;
        if (v36)
        {
          v41 = 32;
        }

        OUTLINED_FUNCTION_4_14(v40, (v29 + v14) / (*&a3[v41] * 1000000000.0));
      }
    }
  }
}

void mlir::mps::detail::MPSAbstractCostModel::computeCost()
{
  if (__cxa_guard_acquire(&_MergedGlobals_48))
  {
    OUTLINED_FUNCTION_1_23();
    OUTLINED_FUNCTION_0_16(v0, v1, &dword_1DF9BF000);

    __cxa_guard_release(&_MergedGlobals_48);
  }
}

{
  if (__cxa_guard_acquire(&_MergedGlobals_48))
  {
    OUTLINED_FUNCTION_1_23();
    OUTLINED_FUNCTION_0_16(v0, v1, &dword_1DF9BF000);
    __cxa_guard_release(&_MergedGlobals_48);
  }
}

BOOL mlir::mps::getMathOpExecutionCost(uint64_t a1, mlir::CallableOpInterface *this, uint64_t a3, _DWORD *a4)
{
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(this);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v9);
  isSplat = mlir::ElementsAttr::isSplat(this);
  result = mlir::mps::executionCost(a1, a3, isSplat);
  *a4 = v12;
  return result;
}

uint64_t mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace::CanonicalizeConcatOp>::externalCanonicalize(uint64_t a1, uint64_t a2, uint64_t **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v26[1] = *MEMORY[0x1E69E9840];
  v9 = OUTLINED_FUNCTION_13_19(a1, a2, a3, a4, a5, a6, a7, a8, v21, v22, v23, a2);
  mlir::mps::ConcatOp::getODSOperandIndexAndLength(v9, v10);
  OUTLINED_FUNCTION_12_14();
  if (v12 + v11 - v11 != 1)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  v23 = v13;
  v14 = *(v13 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (v14)
  {
    v15 = OUTLINED_FUNCTION_17_17();
    v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v15);
  }

  else
  {
    v16 = 0;
  }

  v21 = v14;
  v22 = v16;
  result = mlir::CallOpInterface::getArgOperands(&v21);
  if (result)
  {
    mlir::CallableOpInterface::getArgAttrsAttr(&v21);
    if (v18)
    {
      return 0;
    }

    v19 = v24;
    v26[0] = 1;
    v25[0] = v26;
    v25[1] = 0x100000001;
    v20 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>(a3 + 1, *(v24 + 24), &v23, v25);
    ((*a3)[1])(a3, v19, v20);
    if (v25[0] != v26)
    {
      free(v25[0]);
    }

    return 1;
  }

  return result;
}

uint64_t mlir::detail::ExternalFoldInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace::FoldReduction<mlir::mps::ReductionAndOp>>::externalFold()
{
  OUTLINED_FUNCTION_6_16();
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v0, v1);
  OUTLINED_FUNCTION_12_14();
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  if (!v11)
  {
    return 0;
  }

  v12 = OUTLINED_FUNCTION_9_16(v3, v4, v5, v6, v7, v8, v9, v10, v35, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v12, v13);
  OUTLINED_FUNCTION_0_17();
  if (v2)
  {
    v22 = 0;
  }

  else
  {
    v21 = OUTLINED_FUNCTION_10_17();
    v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v21);
  }

  if (!OUTLINED_FUNCTION_16_14(v22, v14, v15, v16, v17, v18, v19, v20, v36, v38, v39))
  {
    return 0;
  }

  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v38);
  if (!v24)
  {
    return 0;
  }

  while (*ArgAttrsAttr)
  {
    ArgAttrsAttr = OUTLINED_FUNCTION_11_13(ArgAttrsAttr);
    if (v2)
    {
      return 0;
    }
  }

  v32 = OUTLINED_FUNCTION_13_19(ArgAttrsAttr, v24, v25, v26, v27, v28, v29, v30, v37, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v32, v33);
  OUTLINED_FUNCTION_1_24();
  return v34 | 4;
}

uint64_t mlir::detail::ExternalFoldInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace::FoldReduction<mlir::mps::ReductionArgMaxOp>>::externalFold()
{
  OUTLINED_FUNCTION_6_16();
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v0, v1);
  OUTLINED_FUNCTION_12_14();
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  if (!v11)
  {
    return 0;
  }

  v12 = OUTLINED_FUNCTION_9_16(v3, v4, v5, v6, v7, v8, v9, v10, v35, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v12, v13);
  OUTLINED_FUNCTION_0_17();
  if (v2)
  {
    v22 = 0;
  }

  else
  {
    v21 = OUTLINED_FUNCTION_10_17();
    v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v21);
  }

  if (!OUTLINED_FUNCTION_16_14(v22, v14, v15, v16, v17, v18, v19, v20, v36, v38, v39))
  {
    return 0;
  }

  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v38);
  if (!v24)
  {
    return 0;
  }

  while (*ArgAttrsAttr)
  {
    ArgAttrsAttr = OUTLINED_FUNCTION_11_13(ArgAttrsAttr);
    if (v2)
    {
      return 0;
    }
  }

  v32 = OUTLINED_FUNCTION_13_19(ArgAttrsAttr, v24, v25, v26, v27, v28, v29, v30, v37, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v32, v33);
  OUTLINED_FUNCTION_1_24();
  return v34 | 4;
}

uint64_t mlir::detail::ExternalFoldInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace::FoldReduction<mlir::mps::ReductionArgMinOp>>::externalFold()
{
  OUTLINED_FUNCTION_6_16();
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v0, v1);
  OUTLINED_FUNCTION_12_14();
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  if (!v11)
  {
    return 0;
  }

  v12 = OUTLINED_FUNCTION_9_16(v3, v4, v5, v6, v7, v8, v9, v10, v35, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v12, v13);
  OUTLINED_FUNCTION_0_17();
  if (v2)
  {
    v22 = 0;
  }

  else
  {
    v21 = OUTLINED_FUNCTION_10_17();
    v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v21);
  }

  if (!OUTLINED_FUNCTION_16_14(v22, v14, v15, v16, v17, v18, v19, v20, v36, v38, v39))
  {
    return 0;
  }

  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v38);
  if (!v24)
  {
    return 0;
  }

  while (*ArgAttrsAttr)
  {
    ArgAttrsAttr = OUTLINED_FUNCTION_11_13(ArgAttrsAttr);
    if (v2)
    {
      return 0;
    }
  }

  v32 = OUTLINED_FUNCTION_13_19(ArgAttrsAttr, v24, v25, v26, v27, v28, v29, v30, v37, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v32, v33);
  OUTLINED_FUNCTION_1_24();
  return v34 | 4;
}

uint64_t mlir::detail::ExternalFoldInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace::FoldReduction<mlir::mps::ReductionLogSumExpOp>>::externalFold()
{
  OUTLINED_FUNCTION_6_16();
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v0, v1);
  OUTLINED_FUNCTION_12_14();
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  if (!v11)
  {
    return 0;
  }

  v12 = OUTLINED_FUNCTION_9_16(v3, v4, v5, v6, v7, v8, v9, v10, v35, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v12, v13);
  OUTLINED_FUNCTION_0_17();
  if (v2)
  {
    v22 = 0;
  }

  else
  {
    v21 = OUTLINED_FUNCTION_10_17();
    v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v21);
  }

  if (!OUTLINED_FUNCTION_16_14(v22, v14, v15, v16, v17, v18, v19, v20, v36, v38, v39))
  {
    return 0;
  }

  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v38);
  if (!v24)
  {
    return 0;
  }

  while (*ArgAttrsAttr)
  {
    ArgAttrsAttr = OUTLINED_FUNCTION_11_13(ArgAttrsAttr);
    if (v2)
    {
      return 0;
    }
  }

  v32 = OUTLINED_FUNCTION_13_19(ArgAttrsAttr, v24, v25, v26, v27, v28, v29, v30, v37, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v32, v33);
  OUTLINED_FUNCTION_1_24();
  return v34 | 4;
}

uint64_t mlir::detail::ExternalFoldInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace::FoldReduction<mlir::mps::ReductionMaxOp>>::externalFold()
{
  OUTLINED_FUNCTION_6_16();
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v0, v1);
  OUTLINED_FUNCTION_12_14();
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  if (!v11)
  {
    return 0;
  }

  v12 = OUTLINED_FUNCTION_9_16(v3, v4, v5, v6, v7, v8, v9, v10, v35, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v12, v13);
  OUTLINED_FUNCTION_0_17();
  if (v2)
  {
    v22 = 0;
  }

  else
  {
    v21 = OUTLINED_FUNCTION_10_17();
    v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v21);
  }

  if (!OUTLINED_FUNCTION_16_14(v22, v14, v15, v16, v17, v18, v19, v20, v36, v38, v39))
  {
    return 0;
  }

  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v38);
  if (!v24)
  {
    return 0;
  }

  while (*ArgAttrsAttr)
  {
    ArgAttrsAttr = OUTLINED_FUNCTION_11_13(ArgAttrsAttr);
    if (v2)
    {
      return 0;
    }
  }

  v32 = OUTLINED_FUNCTION_13_19(ArgAttrsAttr, v24, v25, v26, v27, v28, v29, v30, v37, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v32, v33);
  OUTLINED_FUNCTION_1_24();
  return v34 | 4;
}

uint64_t mlir::detail::ExternalFoldInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace::FoldReduction<mlir::mps::ReductionMeanOp>>::externalFold()
{
  OUTLINED_FUNCTION_6_16();
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v0, v1);
  OUTLINED_FUNCTION_12_14();
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  if (!v11)
  {
    return 0;
  }

  v12 = OUTLINED_FUNCTION_9_16(v3, v4, v5, v6, v7, v8, v9, v10, v35, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v12, v13);
  OUTLINED_FUNCTION_0_17();
  if (v2)
  {
    v22 = 0;
  }

  else
  {
    v21 = OUTLINED_FUNCTION_10_17();
    v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v21);
  }

  if (!OUTLINED_FUNCTION_16_14(v22, v14, v15, v16, v17, v18, v19, v20, v36, v38, v39))
  {
    return 0;
  }

  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v38);
  if (!v24)
  {
    return 0;
  }

  while (*ArgAttrsAttr)
  {
    ArgAttrsAttr = OUTLINED_FUNCTION_11_13(ArgAttrsAttr);
    if (v2)
    {
      return 0;
    }
  }

  v32 = OUTLINED_FUNCTION_13_19(ArgAttrsAttr, v24, v25, v26, v27, v28, v29, v30, v37, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v32, v33);
  OUTLINED_FUNCTION_1_24();
  return v34 | 4;
}

uint64_t mlir::detail::ExternalFoldInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace::FoldReduction<mlir::mps::ReductionMinOp>>::externalFold()
{
  OUTLINED_FUNCTION_6_16();
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v0, v1);
  OUTLINED_FUNCTION_12_14();
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  if (!v11)
  {
    return 0;
  }

  v12 = OUTLINED_FUNCTION_9_16(v3, v4, v5, v6, v7, v8, v9, v10, v35, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v12, v13);
  OUTLINED_FUNCTION_0_17();
  if (v2)
  {
    v22 = 0;
  }

  else
  {
    v21 = OUTLINED_FUNCTION_10_17();
    v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v21);
  }

  if (!OUTLINED_FUNCTION_16_14(v22, v14, v15, v16, v17, v18, v19, v20, v36, v38, v39))
  {
    return 0;
  }

  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v38);
  if (!v24)
  {
    return 0;
  }

  while (*ArgAttrsAttr)
  {
    ArgAttrsAttr = OUTLINED_FUNCTION_11_13(ArgAttrsAttr);
    if (v2)
    {
      return 0;
    }
  }

  v32 = OUTLINED_FUNCTION_13_19(ArgAttrsAttr, v24, v25, v26, v27, v28, v29, v30, v37, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v32, v33);
  OUTLINED_FUNCTION_1_24();
  return v34 | 4;
}

uint64_t mlir::detail::ExternalFoldInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace::FoldReduction<mlir::mps::ReductionOrOp>>::externalFold()
{
  OUTLINED_FUNCTION_6_16();
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v0, v1);
  OUTLINED_FUNCTION_12_14();
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  if (!v11)
  {
    return 0;
  }

  v12 = OUTLINED_FUNCTION_9_16(v3, v4, v5, v6, v7, v8, v9, v10, v35, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v12, v13);
  OUTLINED_FUNCTION_0_17();
  if (v2)
  {
    v22 = 0;
  }

  else
  {
    v21 = OUTLINED_FUNCTION_10_17();
    v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v21);
  }

  if (!OUTLINED_FUNCTION_16_14(v22, v14, v15, v16, v17, v18, v19, v20, v36, v38, v39))
  {
    return 0;
  }

  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v38);
  if (!v24)
  {
    return 0;
  }

  while (*ArgAttrsAttr)
  {
    ArgAttrsAttr = OUTLINED_FUNCTION_11_13(ArgAttrsAttr);
    if (v2)
    {
      return 0;
    }
  }

  v32 = OUTLINED_FUNCTION_13_19(ArgAttrsAttr, v24, v25, v26, v27, v28, v29, v30, v37, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v32, v33);
  OUTLINED_FUNCTION_1_24();
  return v34 | 4;
}

uint64_t mlir::detail::ExternalFoldInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace::FoldReduction<mlir::mps::ReductionSumOp>>::externalFold()
{
  OUTLINED_FUNCTION_6_16();
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v0, v1);
  OUTLINED_FUNCTION_12_14();
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  if (!v11)
  {
    return 0;
  }

  v12 = OUTLINED_FUNCTION_9_16(v3, v4, v5, v6, v7, v8, v9, v10, v35, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v12, v13);
  OUTLINED_FUNCTION_0_17();
  if (v2)
  {
    v22 = 0;
  }

  else
  {
    v21 = OUTLINED_FUNCTION_10_17();
    v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v21);
  }

  if (!OUTLINED_FUNCTION_16_14(v22, v14, v15, v16, v17, v18, v19, v20, v36, v38, v39))
  {
    return 0;
  }

  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v38);
  if (!v24)
  {
    return 0;
  }

  while (*ArgAttrsAttr)
  {
    ArgAttrsAttr = OUTLINED_FUNCTION_11_13(ArgAttrsAttr);
    if (v2)
    {
      return 0;
    }
  }

  v32 = OUTLINED_FUNCTION_13_19(ArgAttrsAttr, v24, v25, v26, v27, v28, v29, v30, v37, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v32, v33);
  OUTLINED_FUNCTION_1_24();
  return v34 | 4;
}

uint64_t mlir::detail::ExternalFoldInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace::FoldReduction<mlir::mps::ReductionVarianceOp>>::externalFold()
{
  OUTLINED_FUNCTION_6_16();
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v0, v1);
  OUTLINED_FUNCTION_12_14();
  OUTLINED_FUNCTION_41_3();
  if (v2)
  {
    return 0;
  }

  OUTLINED_FUNCTION_7_13();
  if (!v11)
  {
    return 0;
  }

  v12 = OUTLINED_FUNCTION_9_16(v3, v4, v5, v6, v7, v8, v9, v10, v35, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v12, v13);
  OUTLINED_FUNCTION_0_17();
  if (v2)
  {
    v22 = 0;
  }

  else
  {
    v21 = OUTLINED_FUNCTION_10_17();
    v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v21);
  }

  if (!OUTLINED_FUNCTION_16_14(v22, v14, v15, v16, v17, v18, v19, v20, v36, v38, v39))
  {
    return 0;
  }

  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v38);
  if (!v24)
  {
    return 0;
  }

  while (*ArgAttrsAttr)
  {
    ArgAttrsAttr = OUTLINED_FUNCTION_11_13(ArgAttrsAttr);
    if (v2)
    {
      return 0;
    }
  }

  v32 = OUTLINED_FUNCTION_13_19(ArgAttrsAttr, v24, v25, v26, v27, v28, v29, v30, v37, v38, v39, v40);
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(v32, v33);
  OUTLINED_FUNCTION_1_24();
  return v34 | 4;
}

uint64_t mlir::detail::ExternalFoldInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace::FoldReductionProdOp>::externalFold(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v79 = *MEMORY[0x1E69E9840];
  v72 = a2;
  v66 = a2;
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(&v66, 1u);
  OUTLINED_FUNCTION_41_3();
  if (!v4)
  {
    OUTLINED_FUNCTION_7_13();
    if (v5)
    {
      mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(&v66, 1u);
      OUTLINED_FUNCTION_3_20();
      v7 = (v6 & 0xFFFFFFFFFFFFFFF8);
      if ((v6 & 0xFFFFFFFFFFFFFFF8) != 0)
      {
        v8 = OUTLINED_FUNCTION_17_17();
        v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v8);
      }

      else
      {
        v9 = 0;
      }

      __b = v7;
      v74 = v9;
      if (mlir::CallOpInterface::getArgOperands(&__b))
      {
        ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&__b);
        if (v11)
        {
          while (*ArgAttrsAttr)
          {
            ArgAttrsAttr = OUTLINED_FUNCTION_11_13(ArgAttrsAttr);
            if (v4)
            {
              goto LABEL_14;
            }
          }

          mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(&v66, 0);
          OUTLINED_FUNCTION_7_13();
          if (v12 > 7)
          {
            return v12 | 4;
          }
        }
      }
    }
  }

LABEL_14:
  ElementTypeOrSelf = mlir::getElementTypeOrSelf((*(v72 - 8) & 0xFFFFFFFFFFFFFFF8));
  if (*(*ElementTypeOrSelf + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    v15 = ElementTypeOrSelf;
  }

  else
  {
    v15 = 0;
  }

  v71 = v15;
  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(&v72, 1u);
  OUTLINED_FUNCTION_41_3();
  if (v4)
  {
    if (!v71)
    {
      return 0;
    }
  }

  else
  {
    v13 = 0;
    OUTLINED_FUNCTION_7_13();
    if (v16 || !v71)
    {
      return v13;
    }
  }

  Width = mlir::IntegerType::getWidth(&v71);
  v70 = Width;
  if (Width > 0x40)
  {
    llvm::APInt::initSlowCase(&__p, 1, 0);
  }

  else
  {
    __p = (Width != 0);
  }

  mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(&v72, 0);
  OUTLINED_FUNCTION_3_20();
  v19 = (v18 & 0xFFFFFFFFFFFFFFF8);
  v20 = OUTLINED_FUNCTION_17_17();
  v21 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v20);
  if (v21)
  {
    v22 = OUTLINED_FUNCTION_17_17();
    v21 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v22);
  }

  else
  {
    v19 = 0;
  }

  __b = v19;
  v74 = v21;
  if (!v19)
  {
LABEL_35:
    v25 = *a3;
    if (*a3)
    {
      v26 = OUTLINED_FUNCTION_17_17();
      v27 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(v26);
      v66 = v25;
      v67 = v27;
      mlir::ElementsAttr::getValues<llvm::APInt>(&v66, &__b);
      LOWORD(v66) = __b;
      if (__b == 1)
      {
        v67 = v74;
      }

      else
      {
        OUTLINED_FUNCTION_5_16();
        (*(v28 + 16))(&v67);
      }

      v29 = v75;
      v68 = v75;
      LOWORD(v63) = v76;
      if (v76 == 1)
      {
        v64 = v77;
      }

      else
      {
        OUTLINED_FUNCTION_5_16();
        (*(v30 + 16))();
        v29 = v68;
      }

      v31 = v78;
      v65 = v78;
      while (v29 != v31)
      {
        if (BYTE1(v66))
        {
          v32 = 0;
        }

        else
        {
          v32 = v29;
        }

        if (v66 == 1)
        {
          v33 = v67 + 16 * v32;
          v62 = *(v33 + 8);
          if (v62 > 0x40)
          {
            llvm::APInt::initSlowCase(&v61, v33);
          }

          else
          {
            v61 = *v33;
          }
        }

        else
        {
          OUTLINED_FUNCTION_5_16();
          (*(v34 + 24))(&v61);
        }

        llvm::APInt::operator*=(&__p, &v61);
        if (v62 >= 0x41)
        {
          if (v61)
          {
            operator delete[](v61);
          }
        }

        v29 = ++v68;
        v31 = v65;
      }

      if ((v63 & 1) == 0)
      {
        v35 = v64;
        v64 = 0;
        if (v35)
        {
          OUTLINED_FUNCTION_5_16();
          (*(v36 + 8))();
        }
      }

      if ((v66 & 1) == 0)
      {
        v37 = v67;
        v67 = 0;
        if (v37)
        {
          OUTLINED_FUNCTION_5_16();
          (*(v38 + 8))();
        }
      }

      if ((v76 & 1) == 0)
      {
        v39 = v77;
        v77 = 0;
        if (v39)
        {
          OUTLINED_FUNCTION_5_16();
          (*(v40 + 8))();
        }
      }

      if ((__b & 1) == 0)
      {
        v41 = v74;
        v74 = 0;
        if (v41)
        {
          OUTLINED_FUNCTION_5_16();
          (*(v42 + 8))();
        }
      }

      __b = &v75;
      v74 = 0x400000000;
      if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes(&v72))
      {
        v46 = __b;
        LODWORD(v47) = v74;
        goto LABEL_93;
      }

      v43 = *a3;
      if (v43)
      {
        v44 = OUTLINED_FUNCTION_10_17();
        v45 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(v44);
      }

      else
      {
        v45 = 0;
      }

      v63 = v43;
      v64 = v45;
      Type = mlir::ElementsAttr::getType(&v63);
      v52 = Type;
      if (Type)
      {
        v53 = OUTLINED_FUNCTION_10_17();
        Type = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v53);
      }

      v66 = v52;
      v67 = Type;
      mlir::CallableOpInterface::getArgAttrsAttr(&v66);
      v47 = v54;
      if (v54 <= HIDWORD(v74))
      {
        v46 = __b;
        v57 = v74;
        if (v74 >= v54)
        {
          v58 = v54;
        }

        else
        {
          v58 = v74;
        }

        if (v58)
        {
          memset_pattern16(__b, &unk_1E096FAE0, 8 * v58);
        }

        v56 = v47 - v57;
        if (v47 <= v57)
        {
          goto LABEL_92;
        }

        v55 = &v46[v57];
      }

      else
      {
        LODWORD(v74) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&__b, &v75, v54, 8);
        v55 = __b;
        v56 = v47;
        v46 = __b;
      }

      memset_pattern16(v55, &unk_1E096FAE0, 8 * v56);
LABEL_92:
      LODWORD(v74) = v47;
LABEL_93:
      v59 = mlir::RankedTensorType::get(v46, v47, v71, 0);
      v13 = mlir::createElementsAttr(v59, &__p, 1uLL) & 0xFFFFFFFFFFFFFFFBLL;
      if (__b != &v75)
      {
        free(__b);
      }

      goto LABEL_97;
    }

    if (v70 >= 0x41 && __p)
    {
      operator delete[](__p);
    }

    return 0;
  }

  if (mlir::CallOpInterface::getArgOperands(&__b))
  {
    v23 = mlir::CallableOpInterface::getArgAttrsAttr(&__b);
    if (v24)
    {
      while (*v23)
      {
        v23 = OUTLINED_FUNCTION_11_13(v23);
        if (v4)
        {
          goto LABEL_35;
        }
      }

      v48 = mlir::RankedTensorType::get(0, 0, v71, 0);
      if (v48)
      {
        v49 = OUTLINED_FUNCTION_10_17();
        v50 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v49);
      }

      else
      {
        v50 = 0;
      }

      v13 = mlir::DenseElementsAttr::get(v48, v50, &__p, 1) & 0xFFFFFFFFFFFFFFFBLL;
      goto LABEL_97;
    }

    goto LABEL_35;
  }

  v13 = 0;
LABEL_97:
  if (v70 >= 0x41 && __p)
  {
    operator delete[](__p);
  }

  return v13;
}

void mlir::mps::registerExternalCanonicalizeExternalModels(mlir::DialectRegistry &)::$_0::__invoke()
{
  {
    v0 = llvm::getTypeName<mlir::ExternalCanonicalizeInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_8_16(v2);
  }
}

void mlir::OpBuilder::create<mlir::mps::QuantizeOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::TypeAttr,mlir::IntegerAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.quantize";
  *(a2 + 24) = 12;
}

void mlir::mps::registerExternalFoldExternalModels(mlir::DialectRegistry &)::$_0::operator()()
{
  {
    v0 = llvm::getTypeName<mlir::ExternalFoldInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_7_15(v2);
  }
}

void mlir::ElementsAttr::value_begin<llvm::APFloat>(llvm *a1, uint64_t *a2)
{
  v3 = llvm::errs(a1);
  v4 = llvm::getTypeName<llvm::APFloat>();
  v6 = OUTLINED_FUNCTION_16_7(v4, v5);
  v8 = mlir::operator<<(v7, *a2);
  llvm::raw_ostream::operator<<(v8, "\n");
  __break(1u);
}

void mlir::OpBuilder::create<mlir::mps::serialization::ModuleOp>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.module";
  *(a2 + 24) = 10;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

BOOL mlir::anonymous namespace::checkAndCollectANEResults(uint64_t a1, mlir::Block *this, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  v6 = this;
  v219[1] = *MEMORY[0x1E69E9840];
  if (a5)
  {
    v8 = *a4;
  }

  else
  {
    v8 = 0;
  }

  Terminator = mlir::Block::getTerminator(this, this);
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v11 = 0;
    v12 = 0;
    v13 = v8 - 96;
    v189 = &v207;
    v187 = v219;
    v188 = &v202;
    v14 = &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id;
    while (v11 < *(Terminator + 68))
    {
      v15 = *(mlir::Block::getTerminator(v6, v10) + 72) + 32 * v11;
      v16 = (*(*(v15 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (*(*v16 + 136) != v14)
      {
        v16 = 0;
      }

      v199 = v16;
      if (!v16)
      {
        OUTLINED_FUNCTION_1_25();
        mlir::Operation::emitOpError(a1, v137, v138);
        if (RawStringData)
        {
          v146 = &v217;
          v147 = mlir::DiagnosticArgument::DiagnosticArgument(&v217, *(*(v15 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
          v148 = v208;
          if (v209 >= HIDWORD(v209))
          {
            if (v208 <= &v217 && v208 + 24 * v209 > &v217)
            {
              v183 = &v217 - v208;
              OUTLINED_FUNCTION_3_21(v147, v139, v140, v141, v142, v143, v144, v145, v184, v187, v188, v189, CallableForCallee, v191, AffineDimExpr, v193, v194, v195, v196, v197, v198, v199, v200, v201, v202, v203, v204, RawStringData, v206, v207, v208, v209, v210);
              v148 = v208;
              v146 = &v183[v208];
            }

            else
            {
              OUTLINED_FUNCTION_3_21(v147, v139, v140, v141, v142, v143, v144, v145, v184, v187, v188, v189, CallableForCallee, v191, AffineDimExpr, v193, v194, v195, v196, v197, v198, v199, v200, v201, v202, v203, v204, RawStringData, v206, v207, v208, v209, v210);
              v148 = v208;
            }
          }

          v149 = v148 + 24 * v209;
          v150 = *v146;
          *(v149 + 16) = *(v146 + 2);
          *v149 = v150;
          LODWORD(v209) = v209 + 1;
          if (RawStringData)
          {
            mlir::InFlightDiagnostic::report(&RawStringData);
          }
        }

        if (v216 == 1)
        {
          v151 = v215;
          if (v215 != &mlir::detail::TypeIDResolver<mlir::tensor::ConcatOp,void>::id)
          {
            free(v215);
          }

          v152 = __p;
          if (__p)
          {
            v153 = v214;
            v154 = __p;
            if (v214 != __p)
            {
              do
              {
                v153 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v153 - 1);
              }

              while (v153 != v152);
              v154 = __p;
            }

            v214 = v152;
            operator delete(v154);
          }

          v155 = v211;
          if (v211)
          {
            v156 = v212;
            v157 = v211;
            if (v212 != v211)
            {
              do
              {
                v159 = *--v156;
                v158 = v159;
                *v156 = 0;
                if (v159)
                {
                  operator delete[](v158);
                }
              }

              while (v156 != v155);
              v157 = v211;
            }

            v212 = v155;
            operator delete(v157);
          }

          v160 = OUTLINED_FUNCTION_5_17(v151, v139, v140, v141, v142, v143, v144, v145, v184, v187, v188, v189, CallableForCallee, v191, AffineDimExpr, v193, v194, v195, v196, v197, v198, v199, v200, v201, v202, v203, v204, RawStringData, v206, v207, v208);
          if (!v161)
          {
            free(v160);
          }
        }

        return 0;
      }

      mlir::ArrayAttr::getValue(&v199);
      if (v17 != 4)
      {
        mlir::ArrayAttr::getValue(&v199);
        if (v18 != 5)
        {
          OUTLINED_FUNCTION_1_25();
          mlir::Operation::emitOpError(v163, v164, v165);
          v136 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&RawStringData);
          if (RawStringData)
          {
            mlir::InFlightDiagnostic::report(&RawStringData);
          }

          if (v216 == 1)
          {
            v173 = v215;
            if (v215 != &mlir::detail::TypeIDResolver<mlir::tensor::ConcatOp,void>::id)
            {
              free(v215);
            }

            v174 = __p;
            if (__p)
            {
              v175 = v214;
              v176 = __p;
              if (v214 != __p)
              {
                do
                {
                  v175 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v175 - 1);
                }

                while (v175 != v174);
                v176 = __p;
              }

              v214 = v174;
              operator delete(v176);
            }

            v177 = v211;
            if (v211)
            {
              v178 = v212;
              v179 = v211;
              if (v212 != v211)
              {
                do
                {
                  v181 = *--v178;
                  v180 = v181;
                  *v178 = 0;
                  if (v181)
                  {
                    operator delete[](v180);
                  }
                }

                while (v178 != v177);
                v179 = v211;
              }

              v212 = v177;
              operator delete(v179);
            }

            v182 = OUTLINED_FUNCTION_5_17(v173, v166, v167, v168, v169, v170, v171, v172, v184, v187, v188, v189, CallableForCallee, v191, AffineDimExpr, v193, v194, v195, v196, v197, v198, v199, v200, v201, v202, v203, v204, RawStringData, v206, v207, v208);
            if (!v161)
            {
              free(v182);
            }
          }

          return v136;
        }
      }

      {
        return 0;
      }

      if (v8)
      {
        v19 = (v13 - 24 * (v12 - 5));
        if (v12 <= 5)
        {
          v19 = (v8 - 16 * (v12 + 1));
        }

        do
        {
          do
          {
            v19 = *v19;
            v20 = v19[2];
          }

          while (!v20);
        }

        while (*(*(v20 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id);
        v21 = *(v20 - 16);
        if (v21)
        {
          v22 = *(v20 - 16);
          do
          {
            v23 = v22[2];
            if (v23 && *(*(v23 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::TensorToBufferOp,void>::id)
            {
              v200 = (*(v23 - 8) & 0xFFFFFFFFFFFFFFF8);
              RawStringData = mlir::DenseElementsAttr::getRawStringData(&v200);
              v206 = v30;
              CallableForCallee = mlir::CallOpInterface::getCallableForCallee(&RawStringData);
              v191 = v15;
              v31 = v13;
              v32 = v6;
              v33 = a1;
              v34 = v8;
              v35 = a3;
              Value = mlir::ArrayAttr::getValue(&v199);
              v37 = v14;
              v39 = v38;
              RHS = mlir::AffineBinaryOpExpr::getRHS(&v199);
              v41 = Value;
              a3 = v35;
              v8 = v34;
              a1 = v33;
              v6 = v32;
              v13 = v31;
              v42 = v39;
              v14 = v37;
              mlir::MemRefType::get(v41, v42, RHS, CallableForCallee, 0);
              v29 = v191;
              goto LABEL_36;
            }

            v22 = *v22;
          }

          while (v22);
          while (v21)
          {
            v24 = v21[2];
            if (v24 && *(*(v24 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
            {
              v25 = *(v24 - 16);
              if (!v25)
              {
                break;
              }

              while (1)
              {
                v26 = v25[2];
                if (v26)
                {
                  if (*(*(v26 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::TensorToBufferOp,void>::id)
                  {
                    break;
                  }
                }

                v25 = *v25;
                if (!v25)
                {
                  goto LABEL_32;
                }
              }

              CallableForCallee = a3;
              v191 = v15;
              v198 = *(v26 - 8) & 0xFFFFFFFFFFFFFFF8;
              RawStringData = mlir::DenseElementsAttr::getRawStringData(&v198);
              v206 = v44;
              v197 = mlir::CallOpInterface::getCallableForCallee(&RawStringData);
              mlir::ArrayAttr::getValue(&v198);
              v46 = v45;
              RawStringData = v189;
              v206 = 0x300000000;
              v200 = v188;
              v201 = 0x100000000;
              Results = mlir::AffineMap::getResults(&v197);
              v48 = *Results;
              if (*Results)
              {
                v217 = *Results;
                v49 = v187;
                if (mlir::arith::FastMathFlagsAttr::getValue(&v217) < 5)
                {
                  v53 = v48;
                }

                else
                {
                  v53 = 0;
                }

                mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v217, v53);
                v52 = v217;
              }

              else
              {
                v50 = OUTLINED_FUNCTION_2_21();
                mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(v50, v51);
                v52 = v217;
                v49 = v187;
              }

              v196 = v52;
              LHS = mlir::AffineBinaryOpExpr::getLHS(&v196);
              if (LHS && OUTLINED_FUNCTION_0_18(LHS) < 5)
              {
                v55 = OUTLINED_FUNCTION_6_17();
              }

              else
              {
                v55 = OUTLINED_FUNCTION_2_21();
              }

              mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(v55, v56);
              v57 = v217;
              v58 = mlir::AffineBinaryOpExpr::getRHS(&v196);
              if (v58 && OUTLINED_FUNCTION_0_18(v58) < 5)
              {
                v59 = OUTLINED_FUNCTION_6_17();
              }

              else
              {
                v59 = OUTLINED_FUNCTION_2_21();
              }

              mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(v59, v60);
              v195 = v217;
              if (v217 && mlir::arith::FastMathFlagsAttr::getValue(&v195) == 2)
              {
                v61 = mlir::AffineBinaryOpExpr::getRHS(&v195);
                v62 = v201;
                if (v201 >= HIDWORD(v201))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod(&v200, v188, v201 + 1, 8);
                  v62 = v201;
                }

                *(v200 + v62) = v61;
                LODWORD(v201) = v201 + 1;
                v196 = v57;
              }

              if (v46 - 1 >= 1)
              {
                do
                {
                  v63 = mlir::AffineBinaryOpExpr::getLHS(&v196);
                  if (v63 && OUTLINED_FUNCTION_0_18(v63) < 5)
                  {
                    v64 = OUTLINED_FUNCTION_6_17();
                  }

                  else
                  {
                    v64 = OUTLINED_FUNCTION_2_21();
                  }

                  mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(v64, v65);
                  v66 = v217;
                  v67 = mlir::AffineBinaryOpExpr::getRHS(&v196);
                  if (v67 && OUTLINED_FUNCTION_0_18(v67) < 5)
                  {
                    v68 = OUTLINED_FUNCTION_6_17();
                  }

                  else
                  {
                    v68 = OUTLINED_FUNCTION_2_21();
                  }

                  mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(v68, v69);
                  v195 = v217;
                  if (v217 && mlir::arith::FastMathFlagsAttr::getValue(&v195) == 1)
                  {
                    AffineConstantExpr = mlir::AffineBinaryOpExpr::getRHS(&v195);
                  }

                  else
                  {
                    Context = mlir::Attribute::getContext(&v199);
                    AffineConstantExpr = mlir::getAffineConstantExpr(1, Context, v72);
                  }

                  v73 = AffineConstantExpr;
                  v74 = v206;
                  if (v206 >= HIDWORD(v206))
                  {
                    OUTLINED_FUNCTION_7_16(v206, v184, v187, v188, v189, CallableForCallee, v191, AffineDimExpr, v193, v194, v195, v196, v197, v198, v199, v200, v201, v202, v203, v204, RawStringData);
                    v74 = v206;
                  }

                  *(RawStringData + v74) = v73;
                  LODWORD(v206) = v206 + 1;
                  v196 = v66;
                  --v46;
                }

                while (v46 > 1);
              }

              v75 = mlir::AffineBinaryOpExpr::getRHS(&v196);
              v76 = v206;
              if (v206 >= HIDWORD(v206))
              {
                OUTLINED_FUNCTION_7_16(v206, v184, v187, v188, v189, CallableForCallee, v191, AffineDimExpr, v193, v194, v195, v196, v197, v198, v199, v200, v201, v202, v203, v204, RawStringData);
                v76 = v206;
              }

              *(RawStringData + v76) = v75;
              LODWORD(v206) = v206 + 1;
              if (v201 == 1)
              {
                v77 = *v200;
                if (*v200 && (v217 = *v200, mlir::arith::FastMathFlagsAttr::getValue(&v217) == 5))
                {
                  v78 = &v217;
                  v79 = v77;
                }

                else
                {
                  v78 = OUTLINED_FUNCTION_2_21();
                }

                v81 = mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(v78, v79);
                v80 = mlir::AffineBinaryOpExpr::getLHS(v81);
              }

              else
              {
                v80 = 1;
              }

              v217 = v49;
              v218 = 0x100000000;
              v82 = mlir::Attribute::getContext(&v199);
              AffineDimExpr = mlir::getAffineDimExpr(0, v82, v83);
              v193 = mlir::AffineExpr::operator*(&AffineDimExpr, *(RawStringData + 2));
              v84 = mlir::ArrayAttr::getValue(&v199);
              v194 = mlir::AffineExpr::operator*(&v193, *(v84 + 8) / v80);
              v85 = mlir::Attribute::getContext(&v199);
              v193 = mlir::getAffineDimExpr(1, v85, v86);
              if (v201 == 1)
              {
                v193 = mlir::AffineExpr::floorDiv(&v193, *v200);
              }

              v87 = mlir::AffineExpr::operator*(&v193, *(RawStringData + 2));
              v194 = OUTLINED_FUNCTION_8_17(v87, v88, v89, v90, v91, v92, v93, v94, v184);
              v95 = mlir::Attribute::getContext(&v199);
              AffineDimExpr = mlir::getAffineDimExpr(2, v95, v96);
              v97 = mlir::AffineExpr::operator*(&AffineDimExpr, *(RawStringData + 1));
              v194 = OUTLINED_FUNCTION_8_17(v97, v98, v99, v100, v101, v102, v103, v104, v185);
              v105 = mlir::Attribute::getContext(&v199);
              AffineDimExpr = mlir::getAffineDimExpr(3, v105, v106);
              v107 = mlir::AffineExpr::operator*(&AffineDimExpr, *RawStringData);
              v115 = OUTLINED_FUNCTION_8_17(v107, v108, v109, v110, v111, v112, v113, v114, v186);
              v194 = v115;
              if (v201 == 1)
              {
                v116 = mlir::Attribute::getContext(&v199);
                AffineDimExpr = mlir::getAffineDimExpr(1, v116, v117);
                v118 = mlir::AffineExpr::operator%(&AffineDimExpr, *v200);
                v115 = OUTLINED_FUNCTION_8_17(v118, v119, v120, v121, v122, v123, v124, v125, v184);
                v194 = v115;
              }

              v126 = v218;
              if (v218 >= HIDWORD(v218))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod(&v217, v49, v218 + 1, 8);
                v126 = v218;
              }

              v217[v126] = v115;
              LODWORD(v218) = v218 + 1;
              v127 = v218;
              v128 = v217;
              v129 = mlir::Attribute::getContext(&v199);
              v130 = mlir::AffineMap::get(4, 0, v128, v127, v129);
              v131 = mlir::ArrayAttr::getValue(&v199);
              v133 = v132;
              v134 = mlir::AffineBinaryOpExpr::getRHS(&v199);
              mlir::MemRefType::get(v131, v133, v134, v130, 0);
              OperandNumber = mlir::OpOperand::getOperandNumber(v191);
              a3 = CallableForCallee;
              OUTLINED_FUNCTION_4_15(OperandNumber);
              if (v217 != v49)
              {
                free(v217);
              }

              v14 = &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id;
              if (v200 != v188)
              {
                free(v200);
              }

              if (RawStringData != v189)
              {
                free(RawStringData);
              }

              ++v12;
              goto LABEL_37;
            }

            v21 = *v21;
          }
        }
      }

LABEL_32:
      {
        if (v199 != CanonicalMemRefType)
        {
          v29 = v15;
LABEL_36:
          v43 = mlir::OpOperand::getOperandNumber(v29);
          OUTLINED_FUNCTION_4_15(v43);
        }
      }

LABEL_37:
      v11 = ++v12;
      Terminator = mlir::Block::getTerminator(v6, v27);
      if ((*(Terminator + 46) & 0x80) == 0)
      {
        return 1;
      }
    }
  }

  return 1;
}

void mlir::OpBuilder::create<mlir::placement::RegionCall,llvm::SmallVector<mlir::Type,4u> &,mlir::FlatSymbolRefAttr,mlir::placement::RegionTypeAttr,llvm::SmallVector<mlir::Value,4u> &>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "placement.region_call";
  *(a2 + 24) = 21;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

void mlir::mps::arithmeticBinaryTileKernelType<(mlir::mps::arithmeticOp)0>(mlir::Type *a1)
{
  printf("%s: Unsupported sources data type \n", "arithmeticBinaryTileKernelType");
  mlir::Type::dump(a1);
  putchar(10);
  __break(1u);
}

void mlir::mps::arithmeticUnaryTileKernelType<(mlir::mps::arithmeticOp)17>(mlir::Type *a1)
{
  printf("%s: Unsupported sources data type \n", "arithmeticUnaryTileKernelType");
  mlir::Type::dump(a1);
  putchar(10);
  __break(1u);
}

mlir::Block *llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::ShapeEquivalence::compute(mlir::FunctionOpInterface)::$_0>(uint64_t a1, uint64_t a2, void *a3)
{
  v6 = a1;
  while (1)
  {
    result = *(v6 + 2);
    if (!result)
    {
      break;
    }

    result = mlir::Block::getParentOp(result);
    v6 = result;
    if (!result || *(*(result + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
      goto LABEL_7;
    }
  }

  v6 = 0;
LABEL_7:
  for (i = 0; ; ++i)
  {
    v9 = (*(a2 + 2) & 0x80) != 0 ? *(a1 + 68) : 0;
    if (i == v9)
    {
      break;
    }

    v10 = *(*(a1 + 72) + 32 * i + 24);
    v11 = v6 - 24 * i + 24;
    v12 = i + 1;
    if (i > 5)
    {
      v14 = v11;
    }

    else
    {
      v14 = v6 - 16 * v12;
    }

    result = mlir::ShapeEquivalence::makeEquivalent(a3, v10, v14);
  }

  return result;
}

BOOL mlir::mps::SingleGateRNNGradientOp::verify(mlir::mps::SingleGateRNNGradientOp *this)
{
  OUTLINED_FUNCTION_24_13();
  v3 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type,llvm::CastInfo<mlir::ShapedType,mlir::Type,void>>::doCastIfPossible((v2 & 0xFFFFFFFFFFFFFFF8));
  v5 = v4;
  v6 = OUTLINED_FUNCTION_23_13(*this);
  v8 = v7;
  v9 = OUTLINED_FUNCTION_23_13(*this);
  v11 = v10;
  v12 = OUTLINED_FUNCTION_211();
  v15 = *(v14 + 92);
  v17 = v16 & 0x800000;
  if ((v16 & 0x800000) != 0)
  {
    if (!v15)
    {
      goto LABEL_6;
    }
  }

  else if (!v15)
  {
    goto LABEL_6;
  }

  OUTLINED_FUNCTION_26_13();
  if (v18)
  {
    v19 = OUTLINED_FUNCTION_22_11(v12);
    v21 = v20;
    v12 = OUTLINED_FUNCTION_21_13();
    goto LABEL_7;
  }

LABEL_6:
  v21 = 0;
  v19 = 0;
LABEL_7:
  v22 = *(v12 + 16 * v13 + 96);
  if (v17)
  {
    if (!v22)
    {
LABEL_12:
      OUTLINED_FUNCTION_209();
    }
  }

  else if (!v22)
  {
    goto LABEL_12;
  }

  OUTLINED_FUNCTION_185_1();
  if (!v25)
  {
    goto LABEL_12;
  }

  OUTLINED_FUNCTION_54_5(*(v23 + 72) + 32 * v24);
  v26 = OUTLINED_FUNCTION_210();
}

BOOL mlir::mps::SingleGateRNNOp::verify(mlir::mps::SingleGateRNNOp *this)
{
  OUTLINED_FUNCTION_24_13();
  if ((v2 & 0xFFFFFFFFFFFFFFF8) != 0)
  {
    {
      v87 = v2 & 0xFFFFFFFFFFFFFFF8;
      v88 = v1;
      {
        v69 = llvm::getTypeName<mlir::ShapedType>();
        v71 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v69, v70);
        OUTLINED_FUNCTION_48(v71);
      }
    }

    OUTLINED_FUNCTION_184_1();
    if (v3)
    {
      OUTLINED_FUNCTION_183_0();
      do
      {
        v8 = v7 >> 1;
        v9 = &v5[2 * (v7 >> 1)];
        v11 = *v9;
        v10 = v9 + 2;
        v7 += v6 ^ (v7 >> 1);
        if (v11 < v4)
        {
          v5 = v10;
        }

        else
        {
          v7 = v8;
        }
      }

      while (v7);
    }
  }

  OUTLINED_FUNCTION_27_9();
  v18 = v17 & 0xFFFFFFFFFFFFFFF8;
  if ((v17 & 0xFFFFFFFFFFFFFFF8) == 0)
  {
    goto LABEL_21;
  }

  if ((atomic_load_explicit(v16, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(v72))
    {
      v73 = llvm::getTypeName<mlir::ShapedType>();
      v75 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v73, v74);
      OUTLINED_FUNCTION_48(v75);
    }
  }

  OUTLINED_FUNCTION_184_1();
  if (v21)
  {
    OUTLINED_FUNCTION_183_0();
    do
    {
      v26 = v25 >> 1;
      v27 = &v22[2 * (v25 >> 1)];
      v29 = *v27;
      v28 = v27 + 2;
      v25 += v24 ^ (v25 >> 1);
      if (v29 < v19)
      {
        v22 = v28;
      }

      else
      {
        v25 = v26;
      }
    }

    while (v25);
  }

  else
  {
    v23 = 0;
    v22 = v20;
  }

  if (v22 != &v20[2 * v23] && *v22 == v19)
  {
    v30 = v22[1];
  }

  else
  {
LABEL_21:
    v30 = 0;
  }

  v31 = *(*v12 + 44);
  v32 = (*v12 + 16 * ((v31 >> 23) & 1));
  v33 = v32[22];
  if ((v31 & 0x800000) != 0)
  {
    v34 = *(*v12 + 72);
    if (!v33)
    {
LABEL_41:
      v49 = 0;
      v37 = 0;
      goto LABEL_42;
    }
  }

  else
  {
    v34 = 0;
    if (!v33)
    {
      goto LABEL_41;
    }
  }

  if (!*(v34 + 32 * (v32[21] + v32[20]) + 24))
  {
    goto LABEL_41;
  }

  OUTLINED_FUNCTION_27_9();
  v37 = v36 & 0xFFFFFFFFFFFFFFF8;
  if ((v36 & 0xFFFFFFFFFFFFFFF8) == 0)
  {
    goto LABEL_38;
  }

  if ((atomic_load_explicit(v35, memory_order_acquire) & 1) == 0)
  {
    __cxa_guard_acquire(v76);
    OUTLINED_FUNCTION_168_1();
    if (v77)
    {
      v78 = llvm::getTypeName<mlir::ShapedType>();
      v80 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v78, v79);
      OUTLINED_FUNCTION_48(v80);
      OUTLINED_FUNCTION_168_1();
    }
  }

  OUTLINED_FUNCTION_184_1();
  if (v40)
  {
    OUTLINED_FUNCTION_183_0();
    do
    {
      v45 = v44 >> 1;
      v46 = &v41[2 * (v44 >> 1)];
      v48 = *v46;
      v47 = v46 + 2;
      v15 = v43 ^ (v44 >> 1);
      v44 += v15;
      if (v48 < v38)
      {
        v41 = v47;
      }

      else
      {
        v44 = v45;
      }
    }

    while (v44);
  }

  else
  {
    v42 = 0;
    v41 = v39;
  }

  if (v41 != &v39[2 * v42] && *v41 == v38)
  {
    v49 = v41[1];
  }

  else
  {
LABEL_38:
    v49 = 0;
  }

LABEL_42:
  v50 = *(*v12 + 44);
  v51 = *(*v12 + 16 * ((v50 >> 23) & 1) + 92);
  if ((v50 & 0x800000) != 0)
  {
    if (!v51)
    {
LABEL_60:
      v67 = 0;
      v56 = 0;
    }
  }

  else if (!v51)
  {
    goto LABEL_60;
  }

  OUTLINED_FUNCTION_182_1();
  if (!v52)
  {
    goto LABEL_60;
  }

  OUTLINED_FUNCTION_27_9();
  v56 = (v55 & 0xFFFFFFFFFFFFFFF8);
  if ((v55 & 0xFFFFFFFFFFFFFFF8) == 0)
  {
    goto LABEL_57;
  }

  v57 = *v56;
  if ((atomic_load_explicit(v54, memory_order_acquire) & 1) == 0)
  {
    __cxa_guard_acquire(v81);
    OUTLINED_FUNCTION_168_1();
    v83 = v82;
    v13 = v87;
    v12 = v88;
    if (v83)
    {
      v84 = llvm::getTypeName<mlir::ShapedType>();
      v86 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v84, v85);
      OUTLINED_FUNCTION_48(v86);
      OUTLINED_FUNCTION_168_1();
      v13 = v87;
      v12 = v88;
    }
  }

  v58 = *(v53 + 2056);
  v59 = *(v57 + 8);
  v60 = *(v57 + 16);
  if (v60)
  {
    v61 = v59;
    v62 = v60;
    do
    {
      v63 = v62 >> 1;
      v64 = &v61[2 * (v62 >> 1)];
      v66 = *v64;
      v65 = v64 + 2;
      v15 = ~(v62 >> 1);
      v62 += v15;
      if (v66 < v58)
      {
        v61 = v65;
      }

      else
      {
        v62 = v63;
      }
    }

    while (v62);
  }

  else
  {
    v60 = 0;
    v61 = v59;
  }

  if (v61 != &v59[2 * v60] && *v61 == v58)
  {
    v67 = v61[1];
  }

  else
  {
LABEL_57:
    v67 = 0;
  }
}

BOOL mlir::mps::LSTMOp::verify(mlir::mps::LSTMOp *this)
{
  OUTLINED_FUNCTION_24_13();
  v34 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type,llvm::CastInfo<mlir::ShapedType,mlir::Type,void>>::doCastIfPossible((v4 & 0xFFFFFFFFFFFFFFF8));
  v6 = v5;
  OUTLINED_FUNCTION_23_13(*this);
  v7 = OUTLINED_FUNCTION_213();
  v9 = (v8 >> 23) & 1;
  v10 = *(v7 + 16 * v9 + 128);
  v11 = v8 & 0x800000;
  if ((v8 & 0x800000) != 0)
  {
    if (!v10)
    {
      goto LABEL_6;
    }
  }

  else if (!v10)
  {
    goto LABEL_6;
  }

  OUTLINED_FUNCTION_208();
  if (v12)
  {
    v13 = OUTLINED_FUNCTION_22_11(v7);
    v15 = v14;
    v7 = OUTLINED_FUNCTION_21_13();
    goto LABEL_7;
  }

LABEL_6:
  v15 = 0;
  v13 = 0;
LABEL_7:
  v16 = *(v7 + 16 * v9 + 132);
  if (v11)
  {
    if (!v16)
    {
      goto LABEL_12;
    }
  }

  else if (!v16)
  {
    goto LABEL_12;
  }

  OUTLINED_FUNCTION_26_13();
  if (v17)
  {
    v18 = OUTLINED_FUNCTION_22_11(v7);
    v20 = v19;
    v7 = OUTLINED_FUNCTION_21_13();
    goto LABEL_13;
  }

LABEL_12:
  v20 = 0;
  v18 = 0;
LABEL_13:
  v21 = *(v7 + 16 * v9 + 136);
  if (v11)
  {
    if (!v21)
    {
      goto LABEL_18;
    }
  }

  else if (!v21)
  {
    goto LABEL_18;
  }

  OUTLINED_FUNCTION_26_13();
  if (v22)
  {
    v23 = OUTLINED_FUNCTION_22_11(v7);
    v25 = v24;
    v7 = OUTLINED_FUNCTION_21_13();
    goto LABEL_19;
  }

LABEL_18:
  v25 = 0;
  v23 = 0;
LABEL_19:
  v26 = *(v7 + 16 * v9 + 140);
  if (v11)
  {
    if (!v26)
    {
LABEL_24:
      OUTLINED_FUNCTION_209();
    }
  }

  else if (!v26)
  {
    goto LABEL_24;
  }

  OUTLINED_FUNCTION_185_1();
  if (!v29)
  {
    goto LABEL_24;
  }

  OUTLINED_FUNCTION_54_5(*(v27 + 72) + 32 * v28);
  v30 = OUTLINED_FUNCTION_210();
}

BOOL mlir::mps::LSTMGradientOp::verify(mlir::mps::LSTMGradientOp *this)
{
  OUTLINED_FUNCTION_24_13();
  v3 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type,llvm::CastInfo<mlir::ShapedType,mlir::Type,void>>::doCastIfPossible((v2 & 0xFFFFFFFFFFFFFFF8));
  v48 = v4;
  v49 = v3;
  v47 = OUTLINED_FUNCTION_23_13(*this);
  v46 = v5;
  v6 = OUTLINED_FUNCTION_23_13(*this);
  v44 = v7;
  v45 = v6;
  v43 = OUTLINED_FUNCTION_23_13(*this);
  v9 = v8;
  v10 = OUTLINED_FUNCTION_211();
  v13 = *(v12 + 128);
  v15 = v14 & 0x800000;
  if ((v14 & 0x800000) != 0)
  {
    if (!v13)
    {
      goto LABEL_6;
    }
  }

  else if (!v13)
  {
    goto LABEL_6;
  }

  OUTLINED_FUNCTION_26_13();
  if (v16)
  {
    v17 = OUTLINED_FUNCTION_22_11(v10);
    v19 = v18;
    v10 = OUTLINED_FUNCTION_21_13();
    goto LABEL_7;
  }

LABEL_6:
  v19 = 0;
  v17 = 0;
LABEL_7:
  v20 = *(v10 + 16 * v11 + 132);
  if (v15)
  {
    if (!v20)
    {
      goto LABEL_12;
    }
  }

  else if (!v20)
  {
    goto LABEL_12;
  }

  OUTLINED_FUNCTION_207();
  OUTLINED_FUNCTION_26_13();
  if (v21)
  {
    v22 = OUTLINED_FUNCTION_22_11(v10);
    v24 = v23;
    v10 = OUTLINED_FUNCTION_21_13();
    goto LABEL_13;
  }

LABEL_12:
  v24 = 0;
  v22 = 0;
LABEL_13:
  v25 = *(v10 + 16 * v11 + 136);
  if (v15)
  {
    if (!v25)
    {
      goto LABEL_18;
    }
  }

  else if (!v25)
  {
    goto LABEL_18;
  }

  OUTLINED_FUNCTION_207();
  OUTLINED_FUNCTION_26_13();
  if (v26)
  {
    v27 = OUTLINED_FUNCTION_22_11(v10);
    v29 = v28;
    v10 = OUTLINED_FUNCTION_21_13();
    goto LABEL_19;
  }

LABEL_18:
  v29 = 0;
  v27 = 0;
LABEL_19:
  v30 = *(v10 + 16 * v11 + 140);
  if (v15)
  {
    if (!v30)
    {
      goto LABEL_24;
    }
  }

  else if (!v30)
  {
    goto LABEL_24;
  }

  OUTLINED_FUNCTION_26_13();
  if (v31)
  {
    v32 = OUTLINED_FUNCTION_22_11(v10);
    v34 = v33;
    v10 = OUTLINED_FUNCTION_21_13();
    goto LABEL_25;
  }

LABEL_24:
  v34 = 0;
  v32 = 0;
LABEL_25:
  v35 = *(v10 + 16 * v11 + 148);
  if (v15)
  {
    if (!v35)
    {
LABEL_30:
      OUTLINED_FUNCTION_209();
    }
  }

  else if (!v35)
  {
    goto LABEL_30;
  }

  OUTLINED_FUNCTION_185_1();
  if (!v38)
  {
    goto LABEL_30;
  }

  OUTLINED_FUNCTION_54_5(*(v36 + 72) + 32 * v37);
  v39 = OUTLINED_FUNCTION_210();
}

BOOL mlir::mps::GRUOp::verify(mlir::mps::GRUOp *this)
{
  OUTLINED_FUNCTION_24_13();
  v5 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type,llvm::CastInfo<mlir::ShapedType,mlir::Type,void>>::doCastIfPossible((v4 & 0xFFFFFFFFFFFFFFF8));
  v7 = v6;
  OUTLINED_FUNCTION_23_13(*this);
  v8 = OUTLINED_FUNCTION_213();
  v11 = (v10 >> 23) & 1;
  v12 = *(v8 + 16 * v11 + 128);
  v13 = v10 & 0x800000;
  if ((v10 & 0x800000) != 0)
  {
    if (!v12)
    {
      goto LABEL_6;
    }
  }

  else if (!v12)
  {
    goto LABEL_6;
  }

  OUTLINED_FUNCTION_208();
  if (v14)
  {
    v15 = OUTLINED_FUNCTION_22_11(v8);
    v17 = v16;
    v8 = OUTLINED_FUNCTION_212();
    goto LABEL_7;
  }

LABEL_6:
  v17 = 0;
  v15 = 0;
LABEL_7:
  v18 = *(v8 + 16 * v11 + 132);
  if (v13)
  {
    if (!v18)
    {
      goto LABEL_12;
    }
  }

  else if (!v18)
  {
    goto LABEL_12;
  }

  OUTLINED_FUNCTION_26_13();
  if (v19)
  {
    v20 = OUTLINED_FUNCTION_22_11(v8);
    v22 = v21;
    v8 = OUTLINED_FUNCTION_212();
    goto LABEL_13;
  }

LABEL_12:
  v22 = 0;
  v20 = 0;
LABEL_13:
  v23 = (v8 + 16 * v11);
  v24 = v23[34];
  if (v13)
  {
    v25 = *(v8 + 72);
    if (v24)
    {
      goto LABEL_15;
    }

LABEL_19:
    OUTLINED_FUNCTION_209();
  }

  v25 = 0;
  if (!v24)
  {
    goto LABEL_19;
  }

LABEL_15:
  v26 = *(v25 + 32 * (v23[31] + v23[30] + v23[32] + v23[33]) + 24);
  if (v26)
  {
    OUTLINED_FUNCTION_22_11(v8);
    v8 = OUTLINED_FUNCTION_210();
    v11 = (*(v8 + 44) >> 23) & 1;
  }

  else
  {
    v27 = 0;
  }
}

BOOL mlir::mps::GRUGradientOp::verify(mlir::mps::GRUGradientOp *this)
{
  v93 = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_24_13();
  v3 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type,llvm::CastInfo<mlir::ShapedType,mlir::Type,void>>::doCastIfPossible((v2 & 0xFFFFFFFFFFFFFFF8));
  v81 = v3;
  v82 = v4;
  v5 = OUTLINED_FUNCTION_23_13(*this);
  v79 = v5;
  v80 = v6;
  v7 = OUTLINED_FUNCTION_23_13(*this);
  v9 = v8;
  v11 = OUTLINED_FUNCTION_23_13(*this);
  v13 = v12;
  v14 = *this;
  v15 = *(*this + 44);
  v16 = (v15 >> 23) & 1;
  v17 = *(*this + 16 * v16 + 128);
  v18 = v15 & 0x800000;
  if ((v15 & 0x800000) != 0)
  {
    if (!v17)
    {
LABEL_6:
      v71 = 0;
      v72 = 0;
      goto LABEL_7;
    }
  }

  else if (!v17)
  {
    goto LABEL_6;
  }

  OUTLINED_FUNCTION_182_1();
  if (!v19)
  {
    goto LABEL_6;
  }

  OUTLINED_FUNCTION_27_9();
  v71 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type,llvm::CastInfo<mlir::ShapedType,mlir::Type,void>>::doCastIfPossible((v20 & 0xFFFFFFFFFFFFFFF8));
  v72 = v21;
  OUTLINED_FUNCTION_206();
LABEL_7:
  v73 = v9;
  if (*(v14 + 16 * v16 + 132) && (OUTLINED_FUNCTION_182_1(), v22))
  {
    OUTLINED_FUNCTION_27_9();
    v24 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type,llvm::CastInfo<mlir::ShapedType,mlir::Type,void>>::doCastIfPossible((v23 & 0xFFFFFFFFFFFFFFF8));
    v26 = v25;
    OUTLINED_FUNCTION_206();
  }

  else
  {
    v26 = 0;
    v24 = 0;
  }

  v27 = (v14 + 16 * v16);
  if (v18)
  {
    v28 = *(v14 + 72);
  }

  else
  {
    v28 = 0;
  }

  v29 = v13;
  if (v27[34] && *(v28 + 32 * (v27[29] + v27[28] + v27[30] + v27[31] + v27[32] + v27[33]) + 24))
  {
    v30 = OUTLINED_FUNCTION_23_13(v14);
    v32 = v31;
    if (!v3)
    {
    }
  }

  else
  {
    v32 = 0;
    v30 = 0;
    if (!v3)
    {
    }
  }

  if (!mlir::CallOpInterface::getArgOperands(&v81) || !v5 || !mlir::CallOpInterface::getArgOperands(&v79))
  {
  }

  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v81);
  v35 = v34;
  v36 = mlir::CallableOpInterface::getArgAttrsAttr(&v79);
  v38 = v35 == v37;
  if (v35 && v35 == v37)
  {
    v39 = v35 - 1;
    do
    {
      v41 = *ArgAttrsAttr++;
      v40 = v41;
      v43 = *v36++;
      v42 = v43;
      v38 = v40 == 0x8000000000000000 || v40 == v42 || v42 == 0x8000000000000000;
      v46 = v39-- != 0;
    }

    while (v46 && v38);
  }

  if (v38)
  {
  }

  LOWORD(v78) = 259;
  mlir::OpState::emitOpError(this, &v74, &v86);
  if (v86)
  {
    LODWORD(v83) = 3;
    v85 = 28;
    v57 = &v83;
    v58 = v89;
    if (v90 >= HIDWORD(v90))
    {
      if (v89 <= &v83 && v89 + 24 * v90 > &v83)
      {
        v61 = &v83 - v89;
        OUTLINED_FUNCTION_198_0(v49, v50, v51, v52, v53, v54, v55, v56, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91);
        v58 = v89;
        v57 = &v61[v89];
      }

      else
      {
        OUTLINED_FUNCTION_198_0(v49, v50, v51, v52, v53, v54, v55, v56, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91);
        v57 = &v83;
        v58 = v89;
      }
    }

    v59 = v58 + 24 * v90;
    v60 = *v57;
    *(v59 + 16) = v57[2];
    *v59 = v60;
    LODWORD(v90) = v90 + 1;
  }

  v47 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v86);
  if (v86)
  {
    mlir::InFlightDiagnostic::report(&v86);
  }

  if (v92 == 1)
  {
    mlir::Diagnostic::~Diagnostic(&v87);
  }

  return v47;
}

uint64_t mlir::mps::checkInputTensors<mlir::mps::PoolMaxGradientOp>(uint64_t a1)
{
  v36 = *MEMORY[0x1E69E9840];
  v26 = a1;
  v1 = *(a1 + 44);
  v2 = (a1 + 16 * ((v1 >> 23) & 1));
  v3 = v2[34];
  v4 = v2[35];
  if ((v1 & 0x800000) != 0)
  {
    v5 = *(a1 + 72);
    if (v4)
    {
LABEL_3:
      v6 = *(v5 + 32 * v3 + 24);
      goto LABEL_6;
    }
  }

  else
  {
    v5 = 0;
    if (v4)
    {
      goto LABEL_3;
    }
  }

  v6 = 0;
LABEL_6:
  v7 = v4 + v3;
  v8 = v2[36];
  if ((v1 & 0x800000) != 0)
  {
    v9 = *(a1 + 72);
    if (v8)
    {
LABEL_8:
      v10 = *(v9 + 32 * v7 + 24) == 0;
      goto LABEL_11;
    }
  }

  else
  {
    v9 = 0;
    if (v8)
    {
      goto LABEL_8;
    }
  }

  v10 = 1;
LABEL_11:
  v11 = v2[37];
  if ((v1 & 0x800000) != 0)
  {
    v12 = *(a1 + 72);
    if (v11)
    {
      goto LABEL_13;
    }

LABEL_18:
    v13 = 0;
    if (v10)
    {
      goto LABEL_14;
    }

LABEL_19:
    if (!v13 || v6)
    {
      goto LABEL_22;
    }

    return 1;
  }

  v12 = 0;
  if (!v11)
  {
    goto LABEL_18;
  }

LABEL_13:
  v13 = *(v12 + 32 * (v8 + v7) + 24);
  if (!v10)
  {
    goto LABEL_19;
  }

LABEL_14:
  if (v6 && !v13)
  {
    return 1;
  }

LABEL_22:
  v24 = "op supports only (gradient && input) || (gradient && indices && ouput_shape) as parameters";
  v25 = 259;
  mlir::OpState::emitOpError(&v26, &v24, v27);
  v14 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v27);
  if (v27[0])
  {
    mlir::InFlightDiagnostic::report(v27);
  }

  if (v35 == 1)
  {
    if (v34 != &v35)
    {
      free(v34);
    }

    v15 = __p;
    if (__p)
    {
      v16 = v33;
      v17 = __p;
      if (v33 != __p)
      {
        do
        {
          v16 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v16 - 1);
        }

        while (v16 != v15);
        v17 = __p;
      }

      v33 = v15;
      operator delete(v17);
    }

    v18 = v30;
    if (v30)
    {
      v19 = v31;
      v20 = v30;
      if (v31 != v30)
      {
        do
        {
          v22 = *--v19;
          v21 = v22;
          *v19 = 0;
          if (v22)
          {
            operator delete[](v21);
          }
        }

        while (v19 != v18);
        v20 = v30;
      }

      v31 = v18;
      operator delete(v20);
    }

    if (v28 != &v29)
    {
      free(v28);
    }
  }

  return v14;
}

uint64_t mlir::mps::ConcatOp::getODSOperandIndexAndLength(mlir::mps::ConcatOp *this, unsigned int a2)
{
  v2 = "\x01";
  if (a2)
  {
    v3 = a2;
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
      goto LABEL_15;
    }

    if (a2 >= 0x20)
    {
      *v6.i64 = OUTLINED_FUNCTION_22_4();
      do
      {
        *v6.i64 = OUTLINED_FUNCTION_14_8(v6);
      }

      while (!v14);
      OUTLINED_FUNCTION_26_5(v6, v7, v8, v9, v10, v11, v12, v13);
      if (v14)
      {
        goto LABEL_17;
      }

      if ((v3 & 0x1C) == 0)
      {
LABEL_15:
        v17 = &v2[v4];
        v18 = v3 - v4;
        do
        {
          v19 = *v17++;
          v5 += v19;
          --v18;
        }

        while (v18);
        goto LABEL_17;
      }
    }

    *v15.i32 = OUTLINED_FUNCTION_82_0();
    do
    {
      *v15.i64 = OUTLINED_FUNCTION_184(v15, v16);
    }

    while (!v14);
    v5 = vaddvq_s32(v15);
    if (v4 != v3)
    {
      goto LABEL_15;
    }
  }

LABEL_17:
  OUTLINED_FUNCTION_87_0();
  if (!v14)
  {
    v20 = v21;
  }

  return OUTLINED_FUNCTION_78_0(v20);
}

uint64_t mlir::mps::Conv2DDataGradientOp::getODSOperandIndexAndLength(mlir::mps::Conv2DDataGradientOp *this, unsigned int a2)
{
  v2 = &dword_1E09845DA;
  if (a2)
  {
    v3 = a2;
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
      goto LABEL_15;
    }

    if (a2 >= 0x20)
    {
      *v6.i64 = OUTLINED_FUNCTION_22_4();
      do
      {
        *v6.i64 = OUTLINED_FUNCTION_14_8(v6);
      }

      while (!v14);
      OUTLINED_FUNCTION_26_5(v6, v7, v8, v9, v10, v11, v12, v13);
      if (v14)
      {
        goto LABEL_17;
      }

      if ((v3 & 0x1C) == 0)
      {
LABEL_15:
        v17 = v2 + v4;
        v18 = v3 - v4;
        do
        {
          v19 = *v17++;
          v5 += v19;
          --v18;
        }

        while (v18);
        goto LABEL_17;
      }
    }

    *v15.i32 = OUTLINED_FUNCTION_82_0();
    do
    {
      *v15.i64 = OUTLINED_FUNCTION_184(v15, v16);
    }

    while (!v14);
    v5 = vaddvq_s32(v15);
    if (v4 != v3)
    {
      goto LABEL_15;
    }
  }

LABEL_17:
  OUTLINED_FUNCTION_135_3();
  if (!v14)
  {
    v20 = v21;
  }

  return OUTLINED_FUNCTION_78_0(v20);
}

uint64_t mlir::mps::Conv2DDataGradientOp::getODSOperands(mlir::mps::Conv2DDataGradientOp *this, unsigned int a2, double a3, int32x4_t a4)
{
  if (a2)
  {
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
LABEL_14:
      v26 = a2 - v4;
      v27 = &dword_1E09845DA + v4;
      do
      {
        v28 = *v27++;
        v5 += v28;
        --v26;
      }

      while (v26);
      goto LABEL_16;
    }

    if (a2 >= 0x20)
    {
      v6 = 0uLL;
      v7 = "0MPSDialectE";
      v8 = 0uLL;
      v4 = a2 & 0xFFFFFFE0;
      v9 = v4;
      v10 = 0uLL;
      v11 = 0uLL;
      v12 = 0uLL;
      v13 = 0uLL;
      v14 = 0uLL;
      v15 = 0uLL;
      do
      {
        v16 = *v7[-2].i8;
        v17 = vmovl_u8(*v16.i8);
        v18 = vmovl_high_u8(v16);
        v19 = vmovl_u8(*v7);
        v20 = vmovl_high_u8(*v7->i8);
        v11 = vaddw_high_u16(v11, v18);
        v10 = vaddw_u16(v10, *v18.i8);
        v8 = vaddw_high_u16(v8, v17);
        v6 = vaddw_u16(v6, *v17.i8);
        v15 = vaddw_high_u16(v15, v20);
        v14 = vaddw_u16(v14, *v20.i8);
        v13 = vaddw_high_u16(v13, v19);
        v12 = vaddw_u16(v12, *v19.i8);
        v7 += 4;
        v9 -= 32;
      }

      while (v9);
      a4 = vaddq_s32(vaddq_s32(v13, v8), vaddq_s32(v15, v11));
      v5 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v12, v6), vaddq_s32(v14, v10)), a4));
      if (v4 == a2)
      {
        goto LABEL_16;
      }

      if ((a2 & 0x1C) == 0)
      {
        goto LABEL_14;
      }
    }

    else
    {
      v5 = 0;
      v4 = 0;
    }

    v21 = v4;
    v4 = a2 & 0xFFFFFFFC;
    v22 = v5;
    v23 = (&dword_1E09845DA + v21);
    v24 = v21 - v4;
    do
    {
      v25 = *v23++;
      a4.i32[0] = v25;
      a4.i64[0] = vmovl_u8(*a4.i8).u64[0];
      v22 = vaddw_u16(v22, *a4.i8);
      v24 += 4;
    }

    while (v24);
    v5 = vaddvq_s32(v22);
    if (v4 == a2)
    {
      goto LABEL_16;
    }

    goto LABEL_14;
  }

  v5 = 0;
LABEL_16:
  v29 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v30 = *(v29 + 68);
    v31 = *(v29 + 72);
  }

  else
  {
    v30 = 0;
    v31 = 0;
  }

  return v31 + 32 * (a2 + (v30 - 3) * v5);
}

uint64_t mlir::mps::DynamicShapeCastOp::getODSOperandIndexAndLength(mlir::mps::DynamicShapeCastOp *this, unsigned int a2)
{
  v2 = &dword_1E09845DA + 3;
  if (a2)
  {
    v3 = a2;
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
      goto LABEL_15;
    }

    if (a2 >= 0x20)
    {
      *v6.i64 = OUTLINED_FUNCTION_22_4();
      do
      {
        *v6.i64 = OUTLINED_FUNCTION_14_8(v6);
      }

      while (!v14);
      OUTLINED_FUNCTION_26_5(v6, v7, v8, v9, v10, v11, v12, v13);
      if (v14)
      {
        goto LABEL_17;
      }

      if ((v3 & 0x1C) == 0)
      {
LABEL_15:
        v17 = &v2[v4];
        v18 = v3 - v4;
        do
        {
          v19 = *v17++;
          v5 += v19;
          --v18;
        }

        while (v18);
        goto LABEL_17;
      }
    }

    *v15.i32 = OUTLINED_FUNCTION_82_0();
    do
    {
      *v15.i64 = OUTLINED_FUNCTION_184(v15, v16);
    }

    while (!v14);
    v5 = vaddvq_s32(v15);
    if (v4 != v3)
    {
      goto LABEL_15;
    }
  }

LABEL_17:
  OUTLINED_FUNCTION_87_0();
  if (!v14)
  {
    v20 = v21;
  }

  return OUTLINED_FUNCTION_78_0(v20);
}

uint64_t mlir::mps::GRUGradientOp::getODSOperands(mlir::mps::GRUGradientOp *this, unsigned int a2)
{
  v2 = *this;
  v3 = *(*this + 44);
  v4 = (v3 >> 23) & 1;
  if (!a2)
  {
    v7 = 0;
    goto LABEL_11;
  }

  if (a2 > 7)
  {
    v5 = a2 & 0xFFFFFFF8;
    v8 = (*this + 16 * v4 + 128);
    v9 = 0uLL;
    v10 = v5;
    v11 = 0uLL;
    do
    {
      v9 = vaddq_s32(v8[-1], v9);
      v11 = vaddq_s32(*v8, v11);
      v8 += 2;
      v10 -= 8;
    }

    while (v10);
    v6 = vaddvq_s32(vaddq_s32(v11, v9));
    if (v5 == a2)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v5 = 0;
    v6 = 0;
  }

  v12 = a2 - v5;
  v13 = (16 * v4 + 4 * v5 + v2 + 112);
  do
  {
    v14 = *v13++;
    v6 += v14;
    --v12;
  }

  while (v12);
LABEL_10:
  v7 = v6;
LABEL_11:
  if ((v3 & 0x800000) != 0)
  {
    v15 = *(v2 + 72);
  }

  else
  {
    v15 = 0;
  }

  return v15 + 32 * v7;
}

uint64_t mlir::mps::GRUOp::getODSOperands(mlir::mps::GRUOp *this, unsigned int a2)
{
  v2 = *this;
  v3 = *(*this + 44);
  v4 = (v3 >> 23) & 1;
  if (!a2)
  {
    v7 = 0;
    goto LABEL_11;
  }

  if (a2 > 7)
  {
    v5 = a2 & 0xFFFFFFF8;
    v8 = (*this + 16 * v4 + 136);
    v9 = 0uLL;
    v10 = v5;
    v11 = 0uLL;
    do
    {
      v9 = vaddq_s32(v8[-1], v9);
      v11 = vaddq_s32(*v8, v11);
      v8 += 2;
      v10 -= 8;
    }

    while (v10);
    v6 = vaddvq_s32(vaddq_s32(v11, v9));
    if (v5 == a2)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v5 = 0;
    v6 = 0;
  }

  v12 = a2 - v5;
  v13 = (16 * v4 + 4 * v5 + v2 + 120);
  do
  {
    v14 = *v13++;
    v6 += v14;
    --v12;
  }

  while (v12);
LABEL_10:
  v7 = v6;
LABEL_11:
  if ((v3 & 0x800000) != 0)
  {
    v15 = *(v2 + 72);
  }

  else
  {
    v15 = 0;
  }

  return v15 + 32 * v7;
}

uint64_t mlir::mps::GetCoordOpAdaptor::GetCoordOpAdaptor()
{
  OUTLINED_FUNCTION_9_2();
  OUTLINED_FUNCTION_30_8();
  if (v1 < 0)
  {
    OUTLINED_FUNCTION_29_13();
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(v8, v2, v3);
  OUTLINED_FUNCTION_0_19();
  if (v4)
  {
    OUTLINED_FUNCTION_6_18();
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange((v0 + 32), v5, v6);
  OUTLINED_FUNCTION_42_8();
  return v0;
}

uint64_t mlir::mps::NonMaximumSuppressionOp::getODSOperandIndexAndLength(mlir::mps::NonMaximumSuppressionOp *this, unsigned int a2)
{
  v2 = &dword_1E09845D5;
  if (a2)
  {
    v3 = a2;
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
      goto LABEL_15;
    }

    if (a2 >= 0x20)
    {
      *v6.i64 = OUTLINED_FUNCTION_22_4();
      do
      {
        *v6.i64 = OUTLINED_FUNCTION_14_8(v6);
      }

      while (!v14);
      OUTLINED_FUNCTION_26_5(v6, v7, v8, v9, v10, v11, v12, v13);
      if (v14)
      {
        goto LABEL_17;
      }

      if ((v3 & 0x1C) == 0)
      {
LABEL_15:
        v17 = v2 + v4;
        v18 = v3 - v4;
        do
        {
          v19 = *v17++;
          v5 += v19;
          --v18;
        }

        while (v18);
        goto LABEL_17;
      }
    }

    *v15.i32 = OUTLINED_FUNCTION_82_0();
    do
    {
      *v15.i64 = OUTLINED_FUNCTION_184(v15, v16);
    }

    while (!v14);
    v5 = vaddvq_s32(v15);
    if (v4 != v3)
    {
      goto LABEL_15;
    }
  }

LABEL_17:
  OUTLINED_FUNCTION_135_3();
  if (!v14)
  {
    v20 = v21;
  }

  return OUTLINED_FUNCTION_78_0(v20);
}

uint64_t mlir::mps::NonMaximumSuppressionOp::getODSOperands(mlir::mps::NonMaximumSuppressionOp *this, unsigned int a2, double a3, int32x4_t a4)
{
  if (a2)
  {
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
LABEL_14:
      v26 = a2 - v4;
      v27 = &dword_1E09845D5 + v4;
      do
      {
        v28 = *v27++;
        v5 += v28;
        --v26;
      }

      while (v26);
      goto LABEL_16;
    }

    if (a2 >= 0x20)
    {
      v6 = 0uLL;
      v7 = "3mps10MPSDialectE";
      v8 = 0uLL;
      v4 = a2 & 0xFFFFFFE0;
      v9 = v4;
      v10 = 0uLL;
      v11 = 0uLL;
      v12 = 0uLL;
      v13 = 0uLL;
      v14 = 0uLL;
      v15 = 0uLL;
      do
      {
        v16 = *v7[-2].i8;
        v17 = vmovl_u8(*v16.i8);
        v18 = vmovl_high_u8(v16);
        v19 = vmovl_u8(*v7);
        v20 = vmovl_high_u8(*v7->i8);
        v11 = vaddw_high_u16(v11, v18);
        v10 = vaddw_u16(v10, *v18.i8);
        v8 = vaddw_high_u16(v8, v17);
        v6 = vaddw_u16(v6, *v17.i8);
        v15 = vaddw_high_u16(v15, v20);
        v14 = vaddw_u16(v14, *v20.i8);
        v13 = vaddw_high_u16(v13, v19);
        v12 = vaddw_u16(v12, *v19.i8);
        v7 += 4;
        v9 -= 32;
      }

      while (v9);
      a4 = vaddq_s32(vaddq_s32(v13, v8), vaddq_s32(v15, v11));
      v5 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v12, v6), vaddq_s32(v14, v10)), a4));
      if (v4 == a2)
      {
        goto LABEL_16;
      }

      if ((a2 & 0x1C) == 0)
      {
        goto LABEL_14;
      }
    }

    else
    {
      v5 = 0;
      v4 = 0;
    }

    v21 = v4;
    v4 = a2 & 0xFFFFFFFC;
    v22 = v5;
    v23 = (&dword_1E09845D5 + v21);
    v24 = v21 - v4;
    do
    {
      v25 = *v23++;
      a4.i32[0] = v25;
      a4.i64[0] = vmovl_u8(*a4.i8).u64[0];
      v22 = vaddw_u16(v22, *a4.i8);
      v24 += 4;
    }

    while (v24);
    v5 = vaddvq_s32(v22);
    if (v4 == a2)
    {
      goto LABEL_16;
    }

    goto LABEL_14;
  }

  v5 = 0;
LABEL_16:
  v29 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v30 = *(v29 + 68);
    v31 = *(v29 + 72);
  }

  else
  {
    v30 = 0;
    v31 = 0;
  }

  return v31 + 32 * (a2 + (v30 - 5) * v5);
}

uint64_t mlir::mps::PoolMaxGradientOp::getODSOperands(mlir::mps::PoolMaxGradientOp *this, unsigned int a2)
{
  v2 = *this;
  v3 = *(*this + 44);
  v4 = (v3 >> 23) & 1;
  if (!a2)
  {
    v7 = 0;
    goto LABEL_11;
  }

  if (a2 > 7)
  {
    v5 = a2 & 0xFFFFFFF8;
    v8 = (*this + 16 * v4 + 152);
    v9 = 0uLL;
    v10 = v5;
    v11 = 0uLL;
    do
    {
      v9 = vaddq_s32(v8[-1], v9);
      v11 = vaddq_s32(*v8, v11);
      v8 += 2;
      v10 -= 8;
    }

    while (v10);
    v6 = vaddvq_s32(vaddq_s32(v11, v9));
    if (v5 == a2)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v5 = 0;
    v6 = 0;
  }

  v12 = a2 - v5;
  v13 = (16 * v4 + 4 * v5 + v2 + 136);
  do
  {
    v14 = *v13++;
    v6 += v14;
    --v12;
  }

  while (v12);
LABEL_10:
  v7 = v6;
LABEL_11:
  if ((v3 & 0x800000) != 0)
  {
    v15 = *(v2 + 72);
  }

  else
  {
    v15 = 0;
  }

  return v15 + 32 * v7;
}

uint64_t mlir::mps::SingleGateRNNGradientOp::getODSOperands(mlir::mps::SingleGateRNNGradientOp *this, unsigned int a2)
{
  v2 = *this;
  v3 = *(*this + 44);
  v4 = (v3 >> 23) & 1;
  if (!a2)
  {
    v7 = 0;
    goto LABEL_11;
  }

  if (a2 > 7)
  {
    v5 = a2 & 0xFFFFFFF8;
    v8 = (*this + 16 * v4 + 96);
    v9 = 0uLL;
    v10 = v5;
    v11 = 0uLL;
    do
    {
      v9 = vaddq_s32(v8[-1], v9);
      v11 = vaddq_s32(*v8, v11);
      v8 += 2;
      v10 -= 8;
    }

    while (v10);
    v6 = vaddvq_s32(vaddq_s32(v11, v9));
    if (v5 == a2)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v5 = 0;
    v6 = 0;
  }

  v12 = a2 - v5;
  v13 = (16 * v4 + 4 * v5 + v2 + 80);
  do
  {
    v14 = *v13++;
    v6 += v14;
    --v12;
  }

  while (v12);
LABEL_10:
  v7 = v6;
LABEL_11:
  if ((v3 & 0x800000) != 0)
  {
    v15 = *(v2 + 72);
  }

  else
  {
    v15 = 0;
  }

  return v15 + 32 * v7;
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::mps::CallOp>::getArgOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    return *(a2 + 72);
  }

  else
  {
    return 0;
  }
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::mps::CallOp>::getArgOperandsMutable@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if ((*(a1 + 46) & 0x80) != 0)
  {
    v2 = *(a1 + 68);
  }

  else
  {
    v2 = 0;
  }

  return mlir::MutableOperandRange::MutableOperandRange(a2, a1, 0, v2, 0, 0);
}

BOOL mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyOneResult(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, 1) && (v7 = a1, mlir::mps::ReductionAndOp::verifyInvariantsImpl(&v7)))
  {
  }

  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyOneResult(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, 1) && (v7 = a1, mlir::mps::ReductionArgMaxOp::verifyInvariantsImpl(&v7)))
  {
  }

  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyOneResult(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, 1) && (v7 = a1, mlir::mps::ReductionArgMaxOp::verifyInvariantsImpl(&v7)))
  {
  }

  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyOneResult(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, 1) && (v7 = a1, mlir::mps::ReductionAndOp::verifyInvariantsImpl(&v7)))
  {
  }

  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyOneResult(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, 1) && (v7 = a1, mlir::mps::ReductionMaxOp::verifyInvariantsImpl(&v7)))
  {
  }

  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyOneResult(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, 1) && (v7 = a1, mlir::mps::ReductionMeanOp::verifyInvariantsImpl(&v7)))
  {
  }

  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyOneResult(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, 1) && (v7 = a1, mlir::mps::ReductionMaxOp::verifyInvariantsImpl(&v7)))
  {
  }

  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyOneResult(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, 1) && (v7 = a1, mlir::mps::ReductionAndOp::verifyInvariantsImpl(&v7)))
  {
  }

  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyOneResult(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, 1) && (v7 = a1, mlir::mps::ReductionMeanOp::verifyInvariantsImpl(&v7)))
  {
  }

  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyOneResult(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, 1) && (v7 = a1, mlir::mps::ReductionMeanOp::verifyInvariantsImpl(&v7)))
  {
  }

  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyOneResult(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, 1) && (v7 = a1, mlir::mps::ReductionAndOp::verifyInvariantsImpl(&v7)))
  {
  }

  else
  {
    return 0;
  }
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::mps::serialization::IfOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
    v3 = *(a2 + 68);
  }

  else
  {
    v2 = 0;
    v3 = 0;
  }

  return v2 + 32 * v3;
}

uint64_t *mlir::mps::MPSInlinerInterface::handleTerminator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v30[2] = *MEMORY[0x1E69E9840];
  v30[0] = a3;
  v30[1] = a4;
  v29[0] = mlir::Attribute::getContext((a2 + 24));
  v29[1] = 0;
  v6 = *(a2 + 16);
  result = MPSGraphDelegateCompiler.precompilationDescriptor.modify(a2, v7);
  v29[2] = v6;
  v29[3] = result;
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v9 = *(a2 + 68);
    if (v9)
    {
      v10 = 0;
      v11 = *(a2 + 72);
      do
      {
        v12 = *(v11 + 32 * v10 + 24);
        v13 = v12[1];
        if ((*(mlir::ValueRange::dereference_iterator(v30, v10) + 8) ^ v13) > 7)
        {
          v18 = mlir::ValueRange::dereference_iterator(v30, v10);
          v19 = mlir::mps::MPSInlinerInterface::materializeCallConversion(a1, v29, v12, (*(v18 + 8) & 0xFFFFFFFFFFFFFFF8), *(a2 + 24));
          result = mlir::ValueRange::dereference_iterator(v30, v10);
          if (v19)
          {
            v20 = *result;
            if (*result)
            {
              v21 = (v19 - 16);
              do
              {
                v22 = v20[1];
                if (v22)
                {
                  v23 = *v20;
                  *v22 = *v20;
                  if (v23)
                  {
                    *(v23 + 8) = v22;
                  }
                }

                v20[3] = v21;
                v24 = *v21;
                *v20 = *v21;
                v20[1] = v21;
                if (v24)
                {
                  *(v24 + 8) = v20;
                }

                *v21 = v20;
                v20 = *result;
              }

              while (*result);
            }
          }

          else
          {
            while (1)
            {
              v28 = *result;
              if (!*result)
              {
                break;
              }

              v25 = v28[1];
              if (v25)
              {
                v26 = *v28;
                *v25 = *v28;
                if (v26)
                {
                  *(v26 + 8) = v25;
                }
              }

              v28[3] = v12;
              v27 = *v12;
              *v28 = *v12;
              v28[1] = v12;
              if (v27)
              {
                *(v27 + 8) = v28;
              }

              *v12 = v28;
            }
          }
        }

        else
        {
          result = mlir::ValueRange::dereference_iterator(v30, v10);
          while (1)
          {
            v14 = *result;
            if (!*result)
            {
              break;
            }

            v15 = v14[1];
            if (v15)
            {
              v16 = *v14;
              *v15 = *v14;
              if (v16)
              {
                *(v16 + 8) = v15;
              }
            }

            v14[3] = v12;
            v17 = *v12;
            *v14 = *v12;
            v14[1] = v12;
            if (v17)
            {
              *(v17 + 8) = v14;
            }

            *v12 = v14;
          }
        }

        ++v10;
      }

      while (v10 != v9);
    }
  }

  return result;
}

void mlir::mps::getBufferTensorAttrWithKey()
{
  {
    v0 = llvm::getTypeName<mlir::mps::MPSDialectResourceBlobHandle>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_204(v2);
  }
}

void mlir::mps::MPSDialect::convertUnregisteredOperation(mlir::Block **a1, _BYTE *a2)
{
  v22 = *MEMORY[0x1E69E9840];
  v11 = "incorrect number of operands";
  v12 = 259;
  mlir::Operation::emitError(a1, &v11, v13);
  *a2 = 0;
  a2[16] = 0;
  if (v13[0])
  {
    mlir::InFlightDiagnostic::report(v13);
  }

  if (v21 == 1)
  {
    if (v20 != &v21)
    {
      free(v20);
    }

    v3 = __p;
    if (__p)
    {
      v4 = v19;
      v5 = __p;
      if (v19 != __p)
      {
        do
        {
          v4 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v4 - 1);
        }

        while (v4 != v3);
        v5 = __p;
      }

      v19 = v3;
      operator delete(v5);
    }

    v6 = v16;
    if (v16)
    {
      v7 = v17;
      v8 = v16;
      if (v17 != v16)
      {
        do
        {
          v10 = *--v7;
          v9 = v10;
          *v7 = 0;
          if (v10)
          {
            operator delete[](v9);
          }
        }

        while (v7 != v6);
        v8 = v16;
      }

      v17 = v6;
      operator delete(v8);
    }

    if (v14 != &v15)
    {
      free(v14);
    }
  }
}

void mlir::mps::ConstantOp::getAsAttribute()
{
  {
    v0 = llvm::getTypeName<mlir::ElementsAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_55_6(v2);
  }
}

void mlir::mps::GetCoordOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::GetCoordOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_178_0(v2);
  }
}

void mlir::mps::PoolAvgOpAdaptor::verify()
{
  {
    v0 = llvm::getTypeName<mlir::ElementsAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_55_6(v2);
  }
}

void mlir::mps::CallOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_177_1(v2);
  }
}

void mlir::OpBuilder::create<mlir::mps::SoftplusParametricOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.softplus_parametric";
  *(a2 + 24) = 23;
}

void mlir::mps::BatchToSpaceOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_167(v2);
  }
}

void mlir::mps::BiasAddGradOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_166_0(v2);
  }
}

void mlir::mps::BiasAddOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_165_1(v2);
  }
}

uint64_t mlir::mps::CallOp::verifyInvariantsImpl(uint64_t result, uint64_t a2, char *a3)
{
  v4 = *(a2 + 36);
  if (*(a2 + 36))
  {
    v5 = a2 - 16;
  }

  else
  {
    v5 = 0;
  }

  if (v4)
  {
    v6 = result;
    v7 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, v7);
      result = mlir::mps::__mlir_ods_local_type_constraint_MPSOps9(*v6, *(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, "result", 6, v7);
      if ((result & 1) == 0)
      {
        break;
      }

      if (v4 == ++v7)
      {
        goto LABEL_8;
      }
    }

    v9 = 0;
  }

  else
  {
LABEL_8:
    v9 = 1;
  }

  *a3 = v9;
  return result;
}

void mlir::mps::CastOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_164_2(v2);
  }
}

void mlir::mps::ColToImOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_83_6(v2);
  }
}

void mlir::mps::ConcatOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_163_1(v2);
  }
}

void mlir::mps::ConstantOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::mps::ConstantOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::mps::ConstantProperty>();
    mlir::detail::TypeIDResolver<mlir::mps::ConstantProperty,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::mps::Conv2DDataGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_70_5(v2);
  }
}

void mlir::mps::Conv2DOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_69_6(v2);
  }
}

void mlir::mps::Conv2DWeightsGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_68_6(v2);
  }
}

void mlir::mps::Conv3DDataGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_67_5(v2);
  }
}

void mlir::mps::Conv3DOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_66_7(v2);
  }
}

void mlir::mps::Conv3DWeightsGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_65_7(v2);
  }
}

void mlir::mps::CostVolumeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_64_3(v2);
  }
}

void mlir::mps::CreateTextureTensorOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_125_4(v2);
  }
}

void mlir::mps::CropResizeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_63_5(v2);
  }
}

void mlir::mps::CumulativeMaximumOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_124_4(v2);
  }
}

void mlir::mps::CumulativeMinimumOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_123_5(v2);
  }
}

void mlir::mps::CumulativeProductOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_122_4(v2);
  }
}

void mlir::mps::CumulativeSumOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_121_3(v2);
  }
}

void mlir::mps::DepthToSpace2DOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_120_5(v2);
  }
}

void mlir::mps::DepthwiseConv2DDataGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_75_7(v2);
  }
}

void mlir::mps::DepthwiseConv2DOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_74_6(v2);
  }
}

void mlir::mps::DepthwiseConv2DWeightsGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_73_5(v2);
  }
}

void mlir::mps::DepthwiseConv3DDataGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_82_7(v2);
  }
}

void mlir::mps::DepthwiseConv3DOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_81_8(v2);
  }
}

void mlir::mps::DepthwiseConv3DWeightsGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_80_4(v2);
  }
}

void mlir::mps::DequantizeLUTOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_176_0(v2);
  }
}

void mlir::mps::DequantizeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_119_4(v2);
  }
}

void mlir::mps::DynamicShapeCastOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_162_2(v2);
  }
}

void mlir::mps::FastFourierTransformOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_118_5(v2);
  }
}

void mlir::mps::GRUGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_62_5(v2);
  }
}

void mlir::mps::GRUOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_53_5(v2);
  }
}

void mlir::mps::GatherAlongAxisOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_161_1(v2);
  }
}

void mlir::mps::GatherNDOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_117_4(v2);
  }
}

void mlir::mps::GatherOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_116_5(v2);
  }
}

void mlir::mps::HammingDistanceOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_160_2(v2);
  }
}

void mlir::mps::HermiteanToRealFFTOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_100_5(v2);
  }
}

void mlir::mps::ImToColOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_79_5(v2);
  }
}

void mlir::mps::InstanceNormOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_159_0(v2);
  }
}

void mlir::mps::LSTMGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_61_5(v2);
  }
}

void mlir::mps::LSTMOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_52_3(v2);
  }
}

void mlir::mps::LocalConvolutionDataGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::LocalConvolutionDataGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_99_5(v2);
  }
}

void mlir::mps::LocalConvolutionOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::LocalConvolutionOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_98_3(v2);
  }
}

void mlir::mps::LocalConvolutionWeightGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::LocalConvolutionWeightGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_97_4(v2);
  }
}

void mlir::mps::MatMulOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::MatMulOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_115_4(v2);
  }
}

void mlir::mps::MaterializeSparseTensorOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::MaterializeSparseTensorOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_175(v2);
  }
}

void mlir::mps::NonMaximumSuppressionOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::NonMaximumSuppressionOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_96_5(v2);
  }
}

void mlir::mps::NormalizationOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::NormalizationOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_158_3(v2);
  }
}

void mlir::mps::OneHotOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::OneHotOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_157_4(v2);
  }
}

void mlir::mps::PadGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::PadGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_156_2(v2);
  }
}

void mlir::mps::PadOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::PadOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_155_4(v2);
  }
}

void mlir::mps::PoolAvgGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::PoolAvgGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_60_5(v2);
  }
}

void mlir::mps::PoolAvgOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::PoolAvgOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_59_3(v2);
  }
}

void mlir::mps::PoolL2NormGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::PoolL2NormGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_58_3(v2);
  }
}

void mlir::mps::PoolL2NormOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::PoolL2NormOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_57_4(v2);
  }
}

void mlir::mps::PoolMaxGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::PoolMaxGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_46_4(v2);
  }
}

void mlir::mps::PoolMaxOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::PoolMaxOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_49_7(v2);
  }
}

void mlir::mps::PruningGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::PruningGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_95_5(v2);
  }
}

void mlir::mps::PruningOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::PruningOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_94_3(v2);
  }
}

void mlir::mps::QuantizeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::QuantizeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_114_2(v2);
  }
}

void mlir::mps::RandomNormalOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::RandomNormalOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_89_6(v2);
  }
}

void mlir::mps::RandomTruncatedNormalOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::RandomTruncatedNormalOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_72_3(v2);
  }
}

void mlir::mps::RandomUniformOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::RandomUniformOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_154_3(v2);
  }
}

void mlir::mps::ReadDataFromFileOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReadDataFromFileOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_128_5(v2);
  }
}

void mlir::mps::RealToHermiteanFFTOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::RealToHermiteanFFTOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_113_5(v2);
  }
}

void mlir::mps::ReductionAndOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReductionAndOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_153_4(v2);
  }
}

void mlir::mps::ReductionArgMaxOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReductionArgMaxOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_152_4(v2);
  }
}

void mlir::mps::ReductionArgMinOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReductionArgMinOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_151_2(v2);
  }
}

void mlir::mps::ReductionLogSumExpOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReductionLogSumExpOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_150_3(v2);
  }
}

void mlir::mps::ReductionMaxOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReductionMaxOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_112_5(v2);
  }
}

void mlir::mps::ReductionMeanOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReductionMeanOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_149_4(v2);
  }
}

void mlir::mps::ReductionMinOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReductionMinOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_111_3(v2);
  }
}

void mlir::mps::ReductionOrOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReductionOrOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_148_4(v2);
  }
}

void mlir::mps::ReductionProdOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReductionProdOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_147_2(v2);
  }
}

void mlir::mps::ReductionSumOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReductionSumOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_146_4(v2);
  }
}

void mlir::mps::ReductionVarianceOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReductionVarianceOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_145_4(v2);
  }
}

void mlir::mps::ReinterpretCastOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReinterpretCastOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_144_4(v2);
  }
}

void mlir::mps::ReshapeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ReshapeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_143_2(v2);
  }
}

void mlir::mps::ResizeGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ResizeGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_78_5(v2);
  }
}

void mlir::mps::ResizeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ResizeOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_77_5(v2);
  }
}

void mlir::mps::SampleGridDataGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::SampleGridDataGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_88_6(v2);
  }
}

void mlir::mps::SampleGridOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::SampleGridOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_56_6(v2);
  }
}

void mlir::mps::ScatterAlongAxisOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ScatterAlongAxisOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_142_2(v2);
  }
}

void mlir::mps::ScatterNDOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ScatterNDOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_110_2(v2);
  }
}

void mlir::mps::ScatterOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::ScatterOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_141_2(v2);
  }
}

void mlir::mps::SingleGateRNNGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::SingleGateRNNGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_93_5(v2);
  }
}

void mlir::mps::SingleGateRNNOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::SingleGateRNNOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_92_5(v2);
  }
}

void mlir::mps::SortOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::SortOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_140_2(v2);
  }
}

void mlir::mps::SpaceToBatchOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::SpaceToBatchOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_139_3(v2);
  }
}

void mlir::mps::SpaceToDepth2DOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::SpaceToDepth2DOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_109_4(v2);
  }
}

void mlir::mps::SplitOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::SplitOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_195_0(v2);
  }
}

void mlir::mps::StencilOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::StencilOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_51_8(v2);
  }
}

void mlir::mps::StridedSliceGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::StridedSliceGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_87_5(v2);
  }
}

void mlir::mps::StridedSliceOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::StridedSliceOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_86_5(v2);
  }
}

void mlir::mps::StridedSliceUpdateOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::StridedSliceUpdateOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_85_8(v2);
  }
}

void mlir::mps::TopKGradientOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::TopKGradientOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_138_4(v2);
  }
}

void mlir::mps::TopKOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::TopKOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_137_3(v2);
  }
}

void mlir::mps::TypeConstraintOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::detail::TypeConstraintOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_136_2(v2);
  }
}

void mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::ExternalCanonicalizeInterface>();
    mlir::detail::TypeIDResolver<mlir::ExternalCanonicalizeInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ExternalCanonicalizeInterface>();
    mlir::detail::TypeIDResolver<mlir::ExternalCanonicalizeInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsAndResultElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_170_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_132_4(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_103_4(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_102_5(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_169_1(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::mps::AssignVariableOp>,mlir::OpTrait::ZeroResults<mlir::mps::AssignVariableOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::AssignVariableOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::AssignVariableOp>,mlir::OpTrait::OpInvariants<mlir::mps::AssignVariableOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::AssignVariableOp>,mlir::DowngraderInterface::Trait<mlir::mps::AssignVariableOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::DowngraderInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_108_4(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::DowngraderInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DowngraderInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_127_5(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_194(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<4u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_173_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_71_5(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::mps::BiasAddOp>,mlir::OpTrait::OneResult<mlir::mps::BiasAddOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::BiasAddOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::BiasAddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::BiasAddOp>,mlir::OpTrait::OpInvariants<mlir::mps::BiasAddOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::BiasAddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::BiasAddOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::BiasAddOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::BiasAddOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::BiasAddOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::mps::MixedPrecisionInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_101_5(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::mps::MixedPrecisionInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::mps::MixedPrecisionInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::mps::MixedPrecisionInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::mps::MixedPrecisionInterface,mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::mps::MixedPrecisionInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_101_5(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::mps::CallOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::CallOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_203(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::DowngraderInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_193(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::TypeChanger,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::TypeChanger<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::TypeChanger>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_191_0(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_172_0(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_190_0(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_189_1(v2);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::mps::GRUGradientOp>,mlir::OpTrait::AtLeastNResults<3u>::Impl<mlir::mps::GRUGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::GRUGradientOp>,mlir::OpTrait::AtLeastNOperands<4u>::Impl<mlir::mps::GRUGradientOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::GRUGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::GRUGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::GRUGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::GRUGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::GRUGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::GRUGradientOp>,mlir::OpAsmOpInterface::Trait<mlir::mps::GRUGradientOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::OpAsmOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_107_4(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNResults<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNResults<3u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNResults<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNResults<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_171_0(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_126_5(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNResults<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNResults<1u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNResults<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNResults<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNResults<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNResults<4u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNResults<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNResults<4u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NResults<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NResults<3u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NResults<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NResults<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpAsmOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NResults<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NResults<2u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_202(v2);
  }
}

uint64_t mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, _BYTE *a2)
{
  v3 = *(a1 + 44);
  v4 = a1 + 16 * ((v3 >> 23) & 1);
  v5 = *(v4 + 140);
  if ((v3 & 0x800000) == 0)
  {
    v6 = 0;
    if (v5)
    {
      goto LABEL_3;
    }

LABEL_5:
    v7 = 0;
    goto LABEL_6;
  }

  v6 = *(a1 + 72);
  if (!v5)
  {
    goto LABEL_5;
  }

LABEL_3:
  v7 = *(v6 + 32 * *(v4 + 136) + 24);
LABEL_6:
  result = mlir::mps::verifyPooling4D<mlir::mps::PoolMaxGradientOp>(a1, v7, *(*(a1 + 72) + 24));
  *a2 = result & 1;
  return result;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::mps::SoftplusParametricOp>,mlir::OpTrait::OneResult<mlir::mps::SoftplusParametricOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::SoftplusParametricOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::SoftplusParametricOp>,mlir::OpTrait::NOperands<4u>::Impl<mlir::mps::SoftplusParametricOp>,mlir::OpTrait::OpInvariants<mlir::mps::SoftplusParametricOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::SoftplusParametricOp>,mlir::OpTrait::Stitchable<mlir::mps::SoftplusParametricOp>,mlir::DowngraderInterface::Trait<mlir::mps::SoftplusParametricOp>,mlir::UpgraderInterface::Trait<mlir::mps::SoftplusParametricOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::SoftplusParametricOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::SoftplusParametricOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::UpgraderInterface>();
    mlir::detail::TypeIDResolver<mlir::UpgraderInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::UpgraderInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::UpgraderInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::UpgraderInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::UpgraderInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::mps::serialization::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::mps::serialization::WhileOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::mps::serialization::WhileOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::mps::serialization::WhileOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::mps::serialization::WhileOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::mps::serialization::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::HasRecursiveMemoryEffects>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::mps::serialization::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::mps::serialization::YieldOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::mps::serialization::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::mps::serialization::YieldOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::NRegions<2u>::Impl<mlir::mps::serialization::IfOp>,mlir::OpTrait::VariadicResults<mlir::mps::serialization::IfOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::serialization::IfOp>,mlir::OpTrait::OneOperand<mlir::mps::serialization::IfOp>,mlir::OpTrait::SingleBlock<mlir::mps::serialization::IfOp>,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::mps::serialization::YieldOp>::Impl<mlir::mps::serialization::IfOp>,mlir::OpTrait::NoRegionArguments<mlir::mps::serialization::IfOp>,mlir::OpTrait::OpInvariants<mlir::mps::serialization::IfOp>,mlir::RegionBranchOpInterface::Trait<mlir::mps::serialization::IfOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::serialization::IfOp>,mlir::OpTrait::HasRecursiveMemoryEffects<mlir::mps::serialization::IfOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_201(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::mps::serialization::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::mps::serialization::FuncOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::mps::serialization::FuncOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::mps::serialization::FuncOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::mps::serialization::FuncOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::mps::serialization::ForOp,mlir::mps::serialization::IfOp,mlir::mps::serialization::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::mps::serialization::ForOp,mlir::mps::serialization::IfOp,mlir::mps::serialization::WhileOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::mps::serialization::ForOp,mlir::mps::serialization::IfOp,mlir::mps::serialization::WhileOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::mps::serialization::ForOp,mlir::mps::serialization::IfOp,mlir::mps::serialization::WhileOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::mps::serialization::ForOp,mlir::mps::serialization::IfOp,mlir::mps::serialization::WhileOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::mps::MPSBufferTensorAttr>::getValueImpl<unsigned short,unsigned int,unsigned long long,signed char,short,int,long long,half,float,__emulated_bf16,complex_support::complex_fp<float,(void *)0>,complex_support::complex_fp<half,(void *)0>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<unsigned short>();
    mlir::detail::TypeIDResolver<unsigned short,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::mps::MPSBufferTensorAttr>::getValueImpl<unsigned int,unsigned long long,signed char,short,int,long long,half,float,__emulated_bf16,complex_support::complex_fp<float,(void *)0>,complex_support::complex_fp<half,(void *)0>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<unsigned int>();
    mlir::detail::TypeIDResolver<unsigned int,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::mps::MPSBufferTensorAttr>::getValueImpl<short,int,long long,half,float,__emulated_bf16,complex_support::complex_fp<float,(void *)0>,complex_support::complex_fp<half,(void *)0>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<short>();
    mlir::detail::TypeIDResolver<short,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::mps::MPSBufferTensorAttr>::getValueImpl<int,long long,half,float,__emulated_bf16,complex_support::complex_fp<float,(void *)0>,complex_support::complex_fp<half,(void *)0>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<int>();
    mlir::detail::TypeIDResolver<int,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::mps::MPSBufferTensorAttr>::getValueImpl<half,float,__emulated_bf16,complex_support::complex_fp<float,(void *)0>,complex_support::complex_fp<half,(void *)0>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<half>();
    mlir::detail::TypeIDResolver<half,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::mps::MPSBufferTensorAttr>::getValueImpl<__emulated_bf16,complex_support::complex_fp<float,(void *)0>,complex_support::complex_fp<half,(void *)0>,std::integral_constant<BOOL,true>>()
{
  {
    Type = llvm::getTypeName<__emulated_bf16>();
    mlir::detail::TypeIDResolver<__emulated_bf16,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(Type, v1);
  }
}

void mlir::detail::ElementsAttrTrait<mlir::mps::MPSBufferTensorAttr>::getValueImpl<complex_support::complex_fp<float,(void *)0>,complex_support::complex_fp<half,(void *)0>,std::integral_constant<BOOL,true>>()
{
  {
    v0 = llvm::getTypeName<complex_support::complex_fp<float,(void *)0>>();
    mlir::detail::TypeIDResolver<complex_support::complex_fp<float,(void *)0>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void _ZNK4mlir6detail17ElementsAttrTraitINS_3mps19MPSBufferTensorAttrEE12getValueImplIN15complex_support10complex_fpIDhLPv0EEEJENSt3__117integral_constantIbLb1EEEEEDaNS_6TypeIDET1__cold_1()
{
  {
    v0 = llvm::getTypeName<complex_support::complex_fp<half,(void *)0>>();
    mlir::detail::TypeIDResolver<complex_support::complex_fp<half,(void *)0>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::mps::MPSOpAsmInterface::declareResource()
{
  {
    v0 = llvm::getTypeName<mlir::mps::MPSDialectResourceBlobHandle>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_204(v2);
  }
}

void mlir::DialectBytecodeReader::readResourceHandle<mlir::mps::MPSDialectResourceBlobHandle>()
{
  {
    v0 = llvm::getTypeName<mlir::mps::MPSDialectResourceBlobHandle>();
    mlir::detail::TypeIDResolver<mlir::mps::MPSDialectResourceBlobHandle,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::mps::serialization::WhileOp::print(mlir::mps::serialization::WhileOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v47[4] = *MEMORY[0x1E69E9840];
  OUTLINED_FUNCTION_54_3();
  v6 = *(v5 + 48);
  v7 = (*(v5 + 56) - v6) >> 3;
  if ((v8 & 0x800000) != 0)
  {
    v9 = *(v4 + 68);
    v10 = *(v4 + 72);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(v47, v10, v9);
  printInitializationList(v2, v6, v7, v47[0], v47[1], " ", 1uLL);
  OUTLINED_FUNCTION_104();
  (*(v11 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v14 > 2)
  {
    *(v13 + 2) = 32;
    OUTLINED_FUNCTION_15_4(v12, v13);
  }

  else
  {
    llvm::raw_ostream::write(v12, " : ", 3uLL);
  }

  OUTLINED_FUNCTION_90_2();
  if (v16 < 0)
  {
    v17 = *(v15 + 68);
    v18 = *(v15 + 72);
  }

  else
  {
    v18 = 0;
    v17 = 0;
  }

  v46[0] = v18;
  v46[1] = v17;
  Types = mlir::OperandRange::getTypes(v46, v47);
  v27 = *v3 - 16;
  if (!*(*v3 + 9))
  {
    LOBYTE(v27) = 0;
  }

  v28 = OUTLINED_FUNCTION_51_2(Types, v20, v21, v22, v23, v24, v25, v26, v44, v27);
  mlir::OperandRange::getTypes(v28, v29);
  mlir::AsmPrinter::printFunctionalType<mlir::ValueTypeRange<mlir::OperandRange>,mlir::ValueTypeRange<mlir::ResultRange>>(v2, v47, v45);
  OUTLINED_FUNCTION_104();
  (*(v30 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v33)
  {
    llvm::raw_ostream::write(v31, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v31, v32);
  }

  OUTLINED_FUNCTION_18_9();
  OUTLINED_FUNCTION_104();
  (*(v34 + 224))(v2);
  OUTLINED_FUNCTION_104();
  (*(v35 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v38 > 3)
  {
    OUTLINED_FUNCTION_54_6(v36, v37);
  }

  else
  {
    llvm::raw_ostream::write(v36, " do ", 4uLL);
  }

  OUTLINED_FUNCTION_18_9();
  OUTLINED_FUNCTION_104();
  (*(v39 + 224))(v2, v40 + 24, 1, 1, 0);
  v47[0] = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(v47);
  OUTLINED_FUNCTION_104();
  v41 = OUTLINED_FUNCTION_52_4();
  return v42(v41);
}

uint64_t mlir::mps::serialization::ForOp::print(mlir::mps::serialization::ForOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_59_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_17_2();
  if (v8)
  {
    llvm::raw_ostream::write(v6, " ", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v6, v7);
  }

  OUTLINED_FUNCTION_18_9();
  OUTLINED_FUNCTION_46_5();
  OUTLINED_FUNCTION_104();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v10 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v13 > 2)
  {
    *(v12 + 2) = 32;
    OUTLINED_FUNCTION_15_4(v11, v12);
  }

  else
  {
    llvm::raw_ostream::write(v11, " = ", 3uLL);
  }

  OUTLINED_FUNCTION_130_4();
  OUTLINED_FUNCTION_104();
  (*(v14 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v15 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v18 > 3)
  {
    OUTLINED_FUNCTION_54_6(v16, v17);
  }

  else
  {
    llvm::raw_ostream::write(v16, " to ", 4uLL);
  }

  OUTLINED_FUNCTION_130_4();
  OUTLINED_FUNCTION_104();
  (*(v19 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v20 + 16))(v2);
  OUTLINED_FUNCTION_72_0();
  if (v23 > 5)
  {
    *(v22 + 4) = 8304;
    *v22 = 1702130464;
    v21[4] += 6;
  }

  else
  {
    llvm::raw_ostream::write(v21, " step ", 6uLL);
  }

  OUTLINED_FUNCTION_130_4();
  OUTLINED_FUNCTION_104();
  (*(v24 + 160))(v2);
  OUTLINED_FUNCTION_54_3();
  v27 = *(v26 + 48);
  v28 = ((*(v26 + 56) - v27) >> 3) - 1;
  if ((v29 & 0x800000) != 0)
  {
    v30 = *(v25 + 72);
    v31 = *(v25 + 68) - 3;
  }

  else
  {
    v30 = 0;
    v31 = -3;
  }

  mlir::ValueRange::ValueRange(&AttrDictionary, v30 + 96, v31);
  printInitializationList(v2, (v27 + 8), v28, AttrDictionary, v81, " iter_args", 0xAuLL);
  OUTLINED_FUNCTION_47_0();
  if ((v33 & 0x80) == 0 || *(v32 + 68) != 3)
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v36 > 4)
    {
      *(v35 + 4) = 40;
      *v35 = 540945696;
      v34[4] += 5;
    }

    else
    {
      llvm::raw_ostream::write(v34, " -> (", 5uLL);
    }

    OUTLINED_FUNCTION_90_2();
    if (v46 < 0)
    {
      v47 = *(v45 + 72);
    }

    else
    {
      LOBYTE(v47) = 0;
    }

    v48 = OUTLINED_FUNCTION_51_2(v37, v38, v39, v40, v41, v42, v43, v44, v79, v47 + 96);
    mlir::OperandRange::getTypes(v48, v49);
    v50 = v81;
    v51 = v82;
    if (v81 != v82)
    {
      v52 = AttrDictionary + 32 * v81;
      OUTLINED_FUNCTION_29_4();
      v53 = OUTLINED_FUNCTION_12_4();
      v54(v53);
      if (v50 + 1 != v51)
      {
        v55 = ~v50 + v51;
        v56 = v52 + 56;
        do
        {
          (*(*v2 + 16))(v2);
          OUTLINED_FUNCTION_72_0();
          if (v59 > 1)
          {
            OUTLINED_FUNCTION_11_10(v57, v58);
          }

          else
          {
            llvm::raw_ostream::write(v57, ", ", 2uLL);
          }

          v56 += 32;
          OUTLINED_FUNCTION_29_4();
          v60 = OUTLINED_FUNCTION_12_4();
          v61(v60);
          --v55;
        }

        while (v55);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v64)
    {
      llvm::raw_ostream::write(v62, 41);
    }

    else
    {
      *(v62 + 4) = v63 + 1;
      *v63 = 41;
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v64)
  {
    llvm::raw_ostream::write(v65, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v65, v66);
  }

  OUTLINED_FUNCTION_18_9();
  OUTLINED_FUNCTION_46_5();
  AttrDictionary = *(*v67 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!mlir::Type::isIndex(&AttrDictionary))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_72_0();
    if (v70 > 2)
    {
      *(v69 + 2) = 32;
      OUTLINED_FUNCTION_15_4(v68, v69);
    }

    else
    {
      llvm::raw_ostream::write(v68, " : ", 3uLL);
    }

    OUTLINED_FUNCTION_104();
    (*(v71 + 32))(v2);
    OUTLINED_FUNCTION_104();
    (*(v72 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v64)
    {
      llvm::raw_ostream::write(v73, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v73, v74);
    }
  }

  OUTLINED_FUNCTION_104();
  (*(v75 + 224))(v2);
  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_104();
  v76 = OUTLINED_FUNCTION_52_4();
  return v77(v76);
}

BOOL mlir::mps::serialization::ExtractOp::verify(mlir::mps::serialization::ExtractOp *this)
{
  v26 = *MEMORY[0x1E69E9840];
  v16 = *(*(*(*this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue(&v16);
  if ((*(*this + 46) & 0x80) != 0)
  {
    v3 = *(*this + 68) - 1;
  }

  else
  {
    v3 = -1;
  }

  if (v2 == v3)
  {
    return 1;
  }

  v14 = "incorrect number of indices for extract_element";
  v15 = 259;
  mlir::OpState::emitOpError(this, &v14, v17);
  v4 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v17);
  if (v17[0])
  {
    mlir::InFlightDiagnostic::report(v17);
  }

  if (v25 == 1)
  {
    if (v24 != &v25)
    {
      free(v24);
    }

    v5 = __p;
    if (__p)
    {
      v6 = v23;
      v7 = __p;
      if (v23 != __p)
      {
        do
        {
          v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v6 - 1);
        }

        while (v6 != v5);
        v7 = __p;
      }

      v23 = v5;
      operator delete(v7);
    }

    v8 = v20;
    if (v20)
    {
      v9 = v21;
      v10 = v20;
      if (v21 != v20)
      {
        do
        {
          v12 = *--v9;
          v11 = v12;
          *v9 = 0;
          if (v12)
          {
            operator delete[](v11);
          }
        }

        while (v9 != v8);
        v10 = v20;
      }

      v21 = v8;
      operator delete(v10);
    }

    if (v18 != &v19)
    {
      free(v18);
    }
  }

  return v4;
}

uint64_t mlir::mps::serialization::ConditionOp::getODSOperandIndexAndLength(mlir::mps::serialization::ConditionOp *this, unsigned int a2)
{
  v2 = byte_1E0998D51;
  if (!a2)
  {
    goto LABEL_16;
  }

  v3 = a2;
  if (a2 < 4)
  {
    v4 = 0;
    v5 = 0;
LABEL_14:
    v20 = &v2[v4];
    v21 = v3 - v4;
    do
    {
      v22 = *v20++;
      v5 += v22;
      --v21;
    }

    while (v21);
    goto LABEL_16;
  }

  if (a2 >= 0x20)
  {
    *v6.i64 = OUTLINED_FUNCTION_22_4();
    do
    {
      *v6.i64 = OUTLINED_FUNCTION_14_8(v6);
    }

    while (!v14);
    OUTLINED_FUNCTION_26_5(v6, v7, v8, v9, v10, v11, v12, v13);
    if (v14)
    {
      goto LABEL_16;
    }

    if ((v3 & 0x1C) == 0)
    {
      goto LABEL_14;
    }
  }

  *v17.i32 = OUTLINED_FUNCTION_82_0();
  do
  {
    v19 = *v15++;
    v18.i32[0] = v19;
    v18 = vmovl_u8(v18).u64[0];
    v17 = vaddw_u16(v17, v18);
    v16 += 4;
  }

  while (v16);
  v5 = vaddvq_s32(v17);
  if (v4 != v3)
  {
    goto LABEL_14;
  }

LABEL_16:
  if ((*(*this + 46) & 0x80) != 0)
  {
    v23 = *(*this + 68);
  }

  else
  {
    v23 = 0;
  }

  v14 = v2[a2] == 0;
  v24 = 0x100000000;
  if (!v14)
  {
    v24 = (v23 - 1) << 32;
  }

  return OUTLINED_FUNCTION_78_0(v24);
}

uint64_t mlir::mps::serialization::ForOp::getODSOperandIndexAndLength(mlir::mps::serialization::ForOp *this, unsigned int a2)
{
  v2 = &dword_1E097EB2C;
  if (!a2)
  {
    goto LABEL_16;
  }

  v3 = a2;
  if (a2 < 4)
  {
    v4 = 0;
    v5 = 0;
LABEL_14:
    v20 = v2 + v4;
    v21 = v3 - v4;
    do
    {
      v22 = *v20++;
      v5 += v22;
      --v21;
    }

    while (v21);
    goto LABEL_16;
  }

  if (a2 >= 0x20)
  {
    *v6.i64 = OUTLINED_FUNCTION_22_4();
    do
    {
      *v6.i64 = OUTLINED_FUNCTION_14_8(v6);
    }

    while (!v14);
    OUTLINED_FUNCTION_26_5(v6, v7, v8, v9, v10, v11, v12, v13);
    if (v14)
    {
      goto LABEL_16;
    }

    if ((v3 & 0x1C) == 0)
    {
      goto LABEL_14;
    }
  }

  *v17.i32 = OUTLINED_FUNCTION_82_0();
  do
  {
    v19 = *v15++;
    v18.i32[0] = v19;
    v18 = vmovl_u8(v18).u64[0];
    v17 = vaddw_u16(v17, v18);
    v16 += 4;
  }

  while (v16);
  v5 = vaddvq_s32(v17);
  if (v4 != v3)
  {
    goto LABEL_14;
  }

LABEL_16:
  if ((*(*this + 46) & 0x80) != 0)
  {
    v23 = *(*this + 68);
  }

  else
  {
    v23 = 0;
  }

  v14 = *(v2 + a2) == 0;
  v24 = 0x100000000;
  if (!v14)
  {
    v24 = (v23 - 3) << 32;
  }

  return OUTLINED_FUNCTION_78_0(v24);
}

void mlir::mps::serialization::ExtractOp::print(mlir::mps::serialization::ExtractOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_59_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v6, v7);
  }

  OUTLINED_FUNCTION_130_4();
  OUTLINED_FUNCTION_104();
  (*(v9 + 160))(v2);
  OUTLINED_FUNCTION_104();
  (*(v10 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v11, "[", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v11, v12);
  }

  OUTLINED_FUNCTION_47_0();
  if (v15 < 0)
  {
    v16 = *(v14 + 72);
    v17 = *(v14 + 68) - 1;
  }

  else
  {
    v16 = 0;
    v17 = -1;
  }

  (*(*v2 + 16))(v2);
  if (v17)
  {
    OUTLINED_FUNCTION_104();
    (*(v18 + 160))(v2);
    v19 = v17 - 1;
    if (v19)
    {
      v20 = v16 + 88;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v13 & v8)
        {
          *v21 = 8236;
          OUTLINED_FUNCTION_29_2();
        }

        else
        {
          OUTLINED_FUNCTION_42_0();
        }

        v20 += 32;
        OUTLINED_FUNCTION_104();
        (*(v22 + 160))(v2);
        --v19;
      }

      while (v19);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v23, "]", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v23, v24);
  }

  v37 = v39;
  v38 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_81_0();
  OUTLINED_FUNCTION_104();
  v25 = OUTLINED_FUNCTION_31_3();
  v26(v25);
  OUTLINED_FUNCTION_104();
  (*(v27 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v28, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v28, v29);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v13)
  {
    llvm::raw_ostream::write(v30, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v30, v31);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v32, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v32, v33);
  }

  OUTLINED_FUNCTION_130_4();
  OUTLINED_FUNCTION_29_4();
  v34 = OUTLINED_FUNCTION_12_4();
  v35(v34);
  if (v37 != v39)
  {
    free(v37);
  }
}

void mlir::mps::serialization::FromElementsOp::print(mlir::mps::serialization::FromElementsOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_59_0();
  (*(v4 + 16))(v5);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v6, v7);
  }

  OUTLINED_FUNCTION_47_0();
  if (v10 < 0)
  {
    v11 = *(v9 + 68);
    v12 = *(v9 + 72);
  }

  else
  {
    v12 = 0;
    v11 = 0;
  }

  (*(*v2 + 16))(v2);
  if (v11)
  {
    OUTLINED_FUNCTION_104();
    (*(v13 + 160))(v2);
    v14 = v11 - 1;
    if (v14)
    {
      v15 = v12 + 56;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v17 & v8)
        {
          *v16 = 8236;
          OUTLINED_FUNCTION_29_2();
        }

        else
        {
          OUTLINED_FUNCTION_42_0();
        }

        v15 += 32;
        OUTLINED_FUNCTION_104();
        (*(v18 + 160))(v2);
        --v14;
      }

      while (v14);
    }
  }

  v32 = v34;
  v33 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_81_0();
  OUTLINED_FUNCTION_104();
  v19 = OUTLINED_FUNCTION_31_3();
  v20(v19);
  OUTLINED_FUNCTION_104();
  (*(v21 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v22, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v22, v23);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v17)
  {
    llvm::raw_ostream::write(v24, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v24, v25);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v8)
  {
    llvm::raw_ostream::write(v26, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v26, v27);
  }

  if (*(*v3 + 9))
  {
    v28 = *v3 - 16;
  }

  else
  {
    v28 = 0;
  }

  mlir::detail::OpResultImpl::getNextResultAtOffset(v28, 0);
  OUTLINED_FUNCTION_104();
  v29 = OUTLINED_FUNCTION_12_4();
  v30(v29);
  if (v32 != v34)
  {
    free(v32);
  }
}

void mlir::mps::serialization::ReturnOp::print(mlir::mps::serialization::ReturnOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  OUTLINED_FUNCTION_64_4(*MEMORY[0x1E69E9840]);
  v58 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(*v4);
  mlir::ArrayAttr::getValue(&AttrDictionary);
  OUTLINED_FUNCTION_81_0();
  OUTLINED_FUNCTION_104();
  v5 = OUTLINED_FUNCTION_31_3();
  v6(v5);
  OUTLINED_FUNCTION_47_0();
  if (v8 < 0 && *(v7 + 68))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v11)
    {
      llvm::raw_ostream::write(v9, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v9, v10);
    }

    OUTLINED_FUNCTION_47_0();
    if (v13 < 0)
    {
      v14 = *(v12 + 68);
      v15 = *(v12 + 72);
    }

    else
    {
      v15 = 0;
      v14 = 0;
    }

    (*(*v2 + 16))(v2);
    if (v14)
    {
      OUTLINED_FUNCTION_104();
      (*(v16 + 160))(v2);
      v17 = v14 - 1;
      if (v17)
      {
        v18 = v15 + 56;
        do
        {
          OUTLINED_FUNCTION_30_2();
          if (!v20 & v11)
          {
            *v19 = 8236;
            OUTLINED_FUNCTION_29_2();
          }

          else
          {
            OUTLINED_FUNCTION_42_0();
          }

          v18 += 32;
          OUTLINED_FUNCTION_104();
          (*(v21 + 160))(v2);
          --v17;
        }

        while (v17);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v11)
    {
      llvm::raw_ostream::write(v22, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v22, v23);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v20)
    {
      llvm::raw_ostream::write(v24, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v24, v25);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v11)
    {
      llvm::raw_ostream::write(v26, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v26, v27);
    }

    OUTLINED_FUNCTION_90_2();
    if (v37 < 0)
    {
      v38 = *(v36 + 72);
    }

    else
    {
      LOBYTE(v38) = 0;
    }

    v39 = OUTLINED_FUNCTION_51_2(v28, v29, v30, v31, v32, v33, v34, v35, v53, v38);
    mlir::OperandRange::getTypes(v39, v40);
    v41 = v55;
    v42 = v56;
    if (v55 != v56)
    {
      v43 = AttrDictionary + 32 * v55;
      OUTLINED_FUNCTION_29_4();
      v44 = OUTLINED_FUNCTION_12_4();
      v45(v44);
      if (v41 + 1 != v42)
      {
        v46 = ~v41 + v42;
        v47 = v43 + 56;
        do
        {
          (*(*v2 + 16))(v2);
          OUTLINED_FUNCTION_72_0();
          if (v50 > 1)
          {
            OUTLINED_FUNCTION_11_10(v48, v49);
          }

          else
          {
            llvm::raw_ostream::write(v48, ", ", 2uLL);
          }

          v47 += 32;
          OUTLINED_FUNCTION_29_4();
          v51 = OUTLINED_FUNCTION_12_4();
          v52(v51);
          --v46;
        }

        while (v46);
      }
    }
  }

  if (v57 != v3)
  {
    free(v57);
  }
}

void mlir::mps::serialization::FuncOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::serialization::detail::FuncOpGenericAdaptorBase::Properties>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_20_12(v2);
  }
}

void mlir::mps::serialization::ModuleOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::mps::serialization::detail::ModuleOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::mps::serialization::detail::ModuleOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::mps::MPSSerializationPass::runOnOperation(void)::{lambda(mlir::func::FuncOp)#1}::operator() const(mlir::func::FuncOp)::{lambda(mlir::func::ReturnOp)#1}::operator()(mlir::OpBuilder **a1, mlir::Operation *a2)
{
  v36[6] = *MEMORY[0x1E69E9840];
  v33 = a2;
  v4 = *a1;
  v5 = *(a2 + 2);
  v6 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(a2, a2);
  *(v4 + 2) = v5;
  *(v4 + 3) = v6;
  v7 = *a1;
  v8 = *(a2 + 3);
  ODSOperandIndexAndLength = mlir::func::ReturnOp::getODSOperandIndexAndLength(&v33, 0);
  if ((*(v33 + 46) & 0x80) != 0)
  {
    v10 = *(v33 + 9);
  }

  else
  {
    v10 = 0;
  }

  v11 = ODSOperandIndexAndLength;
  v12 = (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength);
  v13 = v12 - ODSOperandIndexAndLength;
  v34 = v36;
  v35 = 0x600000000;
  if (v13 < 7)
  {
    if (v12 == ODSOperandIndexAndLength)
    {
      v16 = 0;
      goto LABEL_25;
    }

    v14 = 0;
    v15 = v36;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v34, v36, v13, 8);
    v14 = v35;
    v15 = v34;
  }

  v17 = &v15[v14];
  if (v13 >= 0x13 && ((v18 = &v15[v14 + v12 - v11], v19 = v10 + 32 * v11, v17 < v10 + 32 * v12) ? (v20 = v19 + 24 >= v18) : (v20 = 1), v20))
  {
    if ((v13 & 3) != 0)
    {
      v21 = v13 & 3;
    }

    else
    {
      v21 = 4;
    }

    v22 = v13 - v21;
    v23 = &v17[v13 - v21];
    v24 = (v19 + 88);
    v25 = (v17 + 2);
    v26 = v21 + v11 - v12;
    do
    {
      v27 = v24 - 8;
      v28 = vld4q_f64(v27);
      v29 = vld4q_f64(v24);
      *(v25 - 1) = v28;
      *v25 = v29;
      v24 += 16;
      v25 += 2;
      v26 += 4;
    }

    while (v26);
    v17 = v23;
  }

  else
  {
    v22 = 0;
  }

  v30 = v22 + v11 - v12;
  v31 = (32 * v22 + 32 * v11 + v10 + 24);
  do
  {
    v32 = *v31;
    v31 += 4;
    *v17++ = v32;
    v20 = __CFADD__(v30++, 1);
  }

  while (!v20);
  v16 = v35;
LABEL_25:
  LODWORD(v35) = v16 + v13;
  mlir::OpBuilder::create<mlir::mps::serialization::ReturnOp,llvm::SmallVector<mlir::Value,6u>>(v7, v8, &v34);
  if (v34 != v36)
  {
    free(v34);
  }

  mlir::Operation::erase(v33);
}

void mlir::mps::MPSDeserializationPass::runOnOperation(void)::{lambda(mlir::mps::serialization::FuncOp)#1}::operator() const(mlir::mps::serialization::FuncOp)::{lambda(mlir::mps::serialization::ReturnOp)#1}::operator()(mlir::OpBuilder **a1, mlir::Operation *a2)
{
  v36[6] = *MEMORY[0x1E69E9840];
  v33 = a2;
  v4 = *a1;
  v5 = *(a2 + 2);
  v6 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(a2, a2);
  *(v4 + 2) = v5;
  *(v4 + 3) = v6;
  v7 = *a1;
  v8 = *(a2 + 3);
  ODSOperandIndexAndLength = mlir::func::ReturnOp::getODSOperandIndexAndLength(&v33, 0);
  if ((*(v33 + 46) & 0x80) != 0)
  {
    v10 = *(v33 + 9);
  }

  else
  {
    v10 = 0;
  }

  v11 = ODSOperandIndexAndLength;
  v12 = (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength);
  v13 = v12 - ODSOperandIndexAndLength;
  v34 = v36;
  v35 = 0x600000000;
  if (v13 < 7)
  {
    if (v12 == ODSOperandIndexAndLength)
    {
      v16 = 0;
      goto LABEL_25;
    }

    v14 = 0;
    v15 = v36;
  }

  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v34, v36, v13, 8);
    v14 = v35;
    v15 = v34;
  }

  v17 = &v15[v14];
  if (v13 >= 0x13 && ((v18 = &v15[v14 + v12 - v11], v19 = v10 + 32 * v11, v17 < v10 + 32 * v12) ? (v20 = v19 + 24 >= v18) : (v20 = 1), v20))
  {
    if ((v13 & 3) != 0)
    {
      v21 = v13 & 3;
    }

    else
    {
      v21 = 4;
    }

    v22 = v13 - v21;
    v23 = &v17[v13 - v21];
    v24 = (v19 + 88);
    v25 = (v17 + 2);
    v26 = v21 + v11 - v12;
    do
    {
      v27 = v24 - 8;
      v28 = vld4q_f64(v27);
      v29 = vld4q_f64(v24);
      *(v25 - 1) = v28;
      *v25 = v29;
      v24 += 16;
      v25 += 2;
      v26 += 4;
    }

    while (v26);
    v17 = v23;
  }

  else
  {
    v22 = 0;
  }

  v30 = v22 + v11 - v12;
  v31 = (32 * v22 + 32 * v11 + v10 + 24);
  do
  {
    v32 = *v31;
    v31 += 4;
    *v17++ = v32;
    v20 = __CFADD__(v30++, 1);
  }

  while (!v20);
  v16 = v35;
LABEL_25:
  LODWORD(v35) = v16 + v13;
  mlir::OpBuilder::create<mlir::func::ReturnOp,llvm::SmallVector<mlir::Value,2u> &>(v7, v8, &v34);
  if (v34 != v36)
  {
    free(v34);
  }

  mlir::Operation::erase(v33);
}

void mlir::OpBuilder::create<mlir::mps::serialization::FuncOp,llvm::StringRef,mlir::FunctionType,llvm::ArrayRef<mlir::NamedAttribute>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.func";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::mps::serialization::ReturnOp,llvm::SmallVector<mlir::Value,6u>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.return";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::mps::serialization::ForOp,mlir::Value,mlir::Value,mlir::Value,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.for";
  *(a2 + 24) = 7;
}

void mlir::OpBuilder::create<mlir::mps::serialization::WhileOp,mlir::TypeRange,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.while";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::mps::serialization::IfOp,mlir::TypeRange,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.if";
  *(a2 + 24) = 6;
}

void mlir::OpBuilder::create<mlir::mps::serialization::ConditionOp,mlir::TypeRange,mlir::Value,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.condition";
  *(a2 + 24) = 13;
}

void mlir::OpBuilder::create<mlir::mps::serialization::YieldOp,mlir::TypeRange,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.yield";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::mps::serialization::FromElementsOp,mlir::RankedTensorType,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.from_elements";
  *(a2 + 24) = 17;
}

void mlir::OpBuilder::create<mlir::mps::serialization::ExtractOp,mlir::Type,mlir::Value,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.extract";
  *(a2 + 24) = 11;
}

void mlir::mps::MPSResourceBlobManagerInterface::MPSResourceBlobManagerInterface()
{
  {
    v0 = llvm::getTypeName<mlir::mps::MPSResourceBlobManagerInterface>();
    mlir::detail::TypeIDResolver<mlir::mps::MPSResourceBlobManagerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::mps::MPSResourceBlobManagerInterface::insert()
{
  {
    v0 = llvm::getTypeName<mlir::mps::MPSDialectResourceBlobHandle>();
    mlir::detail::TypeIDResolver<mlir::mps::MPSDialectResourceBlobHandle,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::createRawElementsAttr()
{
  {
    v0 = llvm::getTypeName<mlir::ElementsAttr>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_1_26(v2);
  }
}

void mlir::OpInterface<mlir::UpgraderInterface,mlir::detail::UpgraderInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::UpgraderInterface>();
    mlir::detail::TypeIDResolver<mlir::UpgraderInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::DowngraderInterface,mlir::detail::DowngraderInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::DowngraderInterface>();
    mlir::detail::TypeIDResolver<mlir::DowngraderInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::mps::mixed_precision::defaultMixedPrecisionCheck(mlir::mps::mixed_precision *this, mlir::Operation *a2, char a3)
{
  v4 = a2;
  v20 = *MEMORY[0x1E69E9840];
  v6 = *(this + 9);
  v7 = this - 16;
  if (!v6)
  {
    v7 = 0;
  }

  v18 = v7;
  v19 = v6;
  mlir::OperandRange::getTypes(&v18, &v13);
  NextResultAtOffset = v13;
  v9 = v14;
  v10 = v15;
  if (v14)
  {
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v13, v14);
  }

  mlir::ValueRange::ValueRange(&v18, NextResultAtOffset, v10 - v9);
  mlir::TypeRange::TypeRange(v17, v18, v19);
  if ((*(this + 46) & 0x80) != 0)
  {
    v11 = *(this + 9);
    v12 = *(this + 17);
  }

  else
  {
    v11 = 0;
    v12 = 0;
  }

  v18 = v11;
  v19 = v12;
  mlir::OperandRange::getTypes(&v18, &v13);
  mlir::ValueRange::ValueRange(&v18, v13 + 32 * v14, v15 - v14);
  mlir::TypeRange::TypeRange(v16, v18, v19);
  mlir::mps::mixed_precision::defaultMixedPrecisionCheck(this, v17[0], v17[1], v16[0], v16[1], v4, a3);
}

unint64_t *mlir::detail::verifyLoopLikeOpInterface(mlir::OpOperand **a1)
{
  v2 = OUTLINED_FUNCTION_0_20(a1);
  if ((*(v1 + 46) & 0x80) != 0)
  {
    v3 = *(v1 + 72);
  }

  else
  {
    v3 = 0;
  }

  return OUTLINED_FUNCTION_1_27(v2, v3);
}

BOOL mlir::anec::anonymous namespace::executionCost(uint64_t a1, uint64_t a2, void *a3)
{
  v5 = 0.0;
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v6 = *(a2 + 68);
    if (v6)
    {
      v7 = *(a2 + 72) + 24;
      do
      {
        v8 = (*(*v7 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (v8)
        {
          v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v8 + 8);
        }

        else
        {
          v9 = 0;
        }

        v22 = v8;
        v23 = v9;
        isSplat = mlir::ElementsAttr::isSplat(&v22);
        v10 = mlir::Type::getIntOrFloatBitWidth(&isSplat) >> 3;
        ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v22);
        v5 = v5 + (mlir::ShapedType::getNumElements(ArgAttrsAttr, v12) * v10);
        v7 += 32;
        --v6;
      }

      while (v6);
    }
  }

  v13 = *(a2 + 36);
  if (v13)
  {
    v14 = a2 - 16;
  }

  else
  {
    v14 = 0;
  }

  if (v13)
  {
    for (i = 0; i != v13; ++i)
    {
      v16 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v14, i) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (v16)
      {
        v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v16 + 8);
      }

      else
      {
        v17 = 0;
      }

      v22 = v16;
      v23 = v17;
      isSplat = mlir::ElementsAttr::isSplat(&v22);
      v18 = mlir::Type::getIntOrFloatBitWidth(&isSplat) >> 3;
      v19 = mlir::CallableOpInterface::getArgAttrsAttr(&v22);
      v5 = v5 + (mlir::ShapedType::getNumElements(v19, v20) * v18);
    }
  }

  v22 = a3;
  return mlir::Type::isF16(&v22);
}

float mlir::anec::getPoolExecutionCost<mlir::anec::MaxPool>(uint64_t a1, mlir::Operation *this)
{
  v32[6] = *MEMORY[0x1E69E9840];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  Value = mlir::ArrayAttr::getValue(&AttrDictionary);
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = mlir::ArrayAttr::getValue(&AttrDictionary);
  v7 = mlir::impl::getAttrFromSortedRange<mlir::NamedAttribute const*,mlir::StringAttr>(Value, (v5 + 16 * v6 - 32), **(*(this + 6) + 96));
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v8 = mlir::ArrayAttr::getValue(&AttrDictionary);
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v9 = mlir::ArrayAttr::getValue(&AttrDictionary);
  mlir::impl::getAttrFromSortedRange<mlir::NamedAttribute const*,mlir::StringAttr>((v8 + 32), (v9 + 16 * v10), *(*(*(this + 6) + 96) + 16));
  AttrDictionary = v32;
  v31 = 0x600000000;
  mlir::getValues<unsigned long>(v7, &AttrDictionary);
  if (!v31)
  {
    goto LABEL_8;
  }

  v11 = (v31 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v11)
  {
    v14 = v11 + 1;
    v15 = (v11 + 1) & 0x3FFFFFFFFFFFFFFELL;
    v13 = (AttrDictionary + 8 * v15);
    v16 = AttrDictionary + 8;
    v17 = 1;
    v18 = v15;
    v19 = 1;
    do
    {
      v17 *= *(v16 - 1);
      v19 *= *v16;
      v16 += 2;
      v18 -= 2;
    }

    while (v18);
    v12 = v19 * v17;
    if (v14 == v15)
    {
      goto LABEL_8;
    }
  }

  else
  {
    v12 = 1;
    v13 = AttrDictionary;
  }

  do
  {
    v20 = *v13++;
    v12 *= v20;
  }

  while (v13 != (AttrDictionary + 8 * v31));
LABEL_8:
  v21 = (*(this - 1) & 0xFFFFFFFFFFFFFFF8);
  if (v21)
  {
    v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
  }

  else
  {
    v22 = 0;
  }

  v29[0] = v21;
  v29[1] = v22;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v29);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v24);
  isSplat = mlir::ElementsAttr::isSplat(v29);
  v27 = v26;
  if (AttrDictionary != v32)
  {
    free(AttrDictionary);
  }

  return v27;
}

float mlir::anec::getPoolExecutionCost<mlir::anec::AveragePool>(uint64_t a1, mlir::Operation *this)
{
  v32[6] = *MEMORY[0x1E69E9840];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  Value = mlir::ArrayAttr::getValue(&AttrDictionary);
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = mlir::ArrayAttr::getValue(&AttrDictionary);
  v7 = mlir::impl::getAttrFromSortedRange<mlir::NamedAttribute const*,mlir::StringAttr>(Value, (v5 + 16 * v6 - 32), *(*(*(this + 6) + 96) + 8));
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v8 = mlir::ArrayAttr::getValue(&AttrDictionary);
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v9 = mlir::ArrayAttr::getValue(&AttrDictionary);
  mlir::impl::getAttrFromSortedRange<mlir::NamedAttribute const*,mlir::StringAttr>((v8 + 32), (v9 + 16 * v10), *(*(*(this + 6) + 96) + 24));
  AttrDictionary = v32;
  v31 = 0x600000000;
  mlir::getValues<unsigned long>(v7, &AttrDictionary);
  if (!v31)
  {
    goto LABEL_8;
  }

  v11 = (v31 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v11)
  {
    v14 = v11 + 1;
    v15 = (v11 + 1) & 0x3FFFFFFFFFFFFFFELL;
    v13 = (AttrDictionary + 8 * v15);
    v16 = AttrDictionary + 8;
    v17 = 1;
    v18 = v15;
    v19 = 1;
    do
    {
      v17 *= *(v16 - 1);
      v19 *= *v16;
      v16 += 2;
      v18 -= 2;
    }

    while (v18);
    v12 = v19 * v17;
    if (v14 == v15)
    {
      goto LABEL_8;
    }
  }

  else
  {
    v12 = 1;
    v13 = AttrDictionary;
  }

  do
  {
    v20 = *v13++;
    v12 *= v20;
  }

  while (v13 != (AttrDictionary + 8 * v31));
LABEL_8:
  v21 = (*(this - 1) & 0xFFFFFFFFFFFFFFF8);
  if (v21)
  {
    v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
  }

  else
  {
    v22 = 0;
  }

  v29[0] = v21;
  v29[1] = v22;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v29);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v24);
  isSplat = mlir::ElementsAttr::isSplat(v29);
  v27 = v26;
  if (AttrDictionary != v32)
  {
    free(AttrDictionary);
  }

  return v27;
}

BOOL mlir::anec::MatMul::getExecutionCost()
{
  OUTLINED_FUNCTION_54_7();
  v3 = *(v2 + 56);
  v4 = *(*(v2 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (v4)
  {
    v5 = OUTLINED_FUNCTION_89_7();
  }

  else
  {
    v5 = 0;
  }

  v14[0] = v4;
  v14[1] = v5;
  v6 = *(v3 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (v6)
  {
    v7 = OUTLINED_FUNCTION_32_9();
  }

  else
  {
    v7 = 0;
  }

  v13[0] = v6;
  v13[1] = v7;
  mlir::CallableOpInterface::getArgAttrsAttr(v14);
  mlir::CallableOpInterface::getArgAttrsAttr(v13);
  mlir::CallableOpInterface::getArgAttrsAttr(v14);
  v9 = v8;
  mlir::anec::getIndexFromDim(0, v8);
  mlir::anec::getIndexFromDim(1, v9);
  mlir::anec::getIndexFromDim(3, v9);
  mlir::anec::getIndexFromDim(4, v9);
  v10 = *v1;
  isSplat = mlir::ElementsAttr::isSplat(v14);
}

uint64_t mlir::anec::RegionReturn::verifyInvariantsImpl(mlir::anec::RegionReturn *this)
{
  v62 = *MEMORY[0x1E69E9840];
  v1 = *this;
  if ((*(*this + 46) & 0x80) == 0)
  {
    return 1;
  }

  v2 = *(v1 + 68);
  if (!v2)
  {
    return 1;
  }

  v4 = 0;
  v5 = *(v1 + 72);
  v6 = &v61;
  while (1)
  {
    if ((v7 = *this, v8 = (*(*(v5 + 32 * v4 + 24) + 8) & 0xFFFFFFFFFFFFFFF8), *(*v8 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) || (v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v8 + 8), v53[0] = v8, v53[1] = v9, isSplat = mlir::ElementsAttr::isSplat(v53), !mlir::Type::isF16(&isSplat)) && !mlir::Type::isUnsignedInteger(&isSplat, 16) && !mlir::Type::isSignedInteger(&isSplat, 16) && !mlir::Type::isUnsignedInteger(&isSplat, 8) && !mlir::Type::isSignedInteger(&isSplat, 8) && !mlir::Type::isSignedInteger(&isSplat, 4) || (v10 = OUTLINED_FUNCTION_32_9(), v45 = v8, v46 = v10, !mlir::CallOpInterface::getArgOperands(&v45)) || (v11 = OUTLINED_FUNCTION_32_9(), v50 = v8, v51 = v11, mlir::CallableOpInterface::getArgAttrsAttr(&v50), v12 != 4) && (v13 = OUTLINED_FUNCTION_32_9(), v48[0] = v8, v48[1] = v13, mlir::CallableOpInterface::getArgAttrsAttr(v48), v14 != 5))
    {
      v47 = 261;
      v45 = "operand";
      v46 = 7;
      mlir::Operation::emitOpError(v7, &v45, v53);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v53, " #");
      v16 = v15;
      if (*v15)
      {
        v17 = *(v15 + 24);
        LODWORD(v50) = 5;
        v51 = v4;
        if (*(v15 + 32) >= *(v15 + 36))
        {
          OUTLINED_FUNCTION_31_10();
          if (!(!v34 & v33) && (v32 & 1) != 0)
          {
            OUTLINED_FUNCTION_59_4();
            v6 = (v40 - v39);
            OUTLINED_FUNCTION_55_7();
            OUTLINED_FUNCTION_52_5();
          }

          else
          {
            OUTLINED_FUNCTION_55_7();
            v17 = *(v16 + 24);
          }
        }

        OUTLINED_FUNCTION_0_3(v17);
        v18 = *(v16 + 32) + 1;
        *(v16 + 32) = v18;
        if (*v16)
        {
          LODWORD(v50) = 3;
          v51 = " must be variadic of 4D/5D memref of 16-bit float or 16-bit unsigned integer or 16-bit signed integer or 8-bit unsigned integer or 8-bit signed integer or 4-bit signed integer values, but got ";
          v52 = 192;
          v19 = *(v16 + 24);
          if (v18 >= *(v16 + 36))
          {
            OUTLINED_FUNCTION_31_10();
            if (!(!v34 & v33) && (v35 & 1) != 0)
            {
              OUTLINED_FUNCTION_59_4();
              v6 = (v42 - v41);
              OUTLINED_FUNCTION_55_7();
              OUTLINED_FUNCTION_52_5();
            }

            else
            {
              OUTLINED_FUNCTION_55_7();
              v19 = *(v16 + 24);
            }
          }

          OUTLINED_FUNCTION_0_3(v19);
          ++*(v16 + 32);
          if (*v16)
          {
            OUTLINED_FUNCTION_59_4();
            v6 = &v50;
            mlir::DiagnosticArgument::DiagnosticArgument(&v50, v8);
            v20 = *(v16 + 24);
            if (*(v16 + 32) >= *(v16 + 36))
            {
              OUTLINED_FUNCTION_31_10();
              if (!(!v34 & v33) && (v37 & 1) != 0)
              {
                v43 = v38 - v36;
                OUTLINED_FUNCTION_55_7();
                v20 = *(v16 + 24);
                v6 = (v20 + v43);
              }

              else
              {
                OUTLINED_FUNCTION_55_7();
                v20 = *(v16 + 24);
                v6 = &v50;
              }
            }

            v21 = v20 + 24 * *(v16 + 32);
            v22 = *v6;
            *(v21 + 16) = v6[2];
            *v21 = v22;
            ++*(v16 + 32);
            OUTLINED_FUNCTION_52_5();
          }
        }
      }

      v23 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v16);
      if (v53[0])
      {
        mlir::InFlightDiagnostic::report(v53);
      }

      if (v61 == 1)
      {
        if (v60 != v6)
        {
          free(v60);
        }

        v24 = __p;
        if (__p)
        {
          v25 = v59;
          v26 = __p;
          if (v59 != __p)
          {
            do
            {
              v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v25 - 1);
            }

            while (v25 != v24);
            v26 = __p;
          }

          v59 = v24;
          operator delete(v26);
        }

        v27 = v56;
        if (v56)
        {
          v28 = v57;
          v29 = v56;
          if (v57 != v56)
          {
            do
            {
              v31 = *--v28;
              v30 = v31;
              *v28 = 0;
              if (v31)
              {
                operator delete[](v30);
              }
            }

            while (v28 != v27);
            v29 = v56;
          }

          v57 = v27;
          operator delete(v29);
        }

        if (v54 != &v55)
        {
          free(v54);
        }
      }

      if (!v23)
      {
        break;
      }
    }

    if (++v4 == v2)
    {
      return 1;
    }
  }

  return 0;
}

uint64_t mlir::anec::RingBufferReader::getODSOperandIndexAndLength(mlir::anec::RingBufferReader *this, unsigned int a2, double a3, uint8x8_t a4)
{
  v4 = &xmmword_1E09999F8;
  if (a2)
  {
    v5 = a2;
    if (a2 < 4)
    {
      v6 = 0;
      v7 = 0;
LABEL_15:
      v22 = v4 + v6;
      v23 = v5 - v6;
      do
      {
        v24 = *v22++;
        v7 += v24;
        --v23;
      }

      while (v23);
      goto LABEL_17;
    }

    if (a2 >= 0x20)
    {
      *v8.i64 = OUTLINED_FUNCTION_22_4();
      do
      {
        *v8.i64 = OUTLINED_FUNCTION_14_8(v8);
      }

      while (!v16);
      OUTLINED_FUNCTION_26_5(v8, v9, v10, v11, v12, v13, v14, v15);
      if (v16)
      {
        goto LABEL_17;
      }

      if ((v5 & 0x1C) == 0)
      {
        goto LABEL_15;
      }
    }

    else
    {
      v7 = 0;
      v6 = 0;
    }

    v17 = v6;
    v6 = v5 & 0xFFFFFFFC;
    v18 = v7;
    v19 = (v4 + v17);
    v20 = v17 - v6;
    do
    {
      v21 = *v19++;
      a4.i32[0] = v21;
      a4 = vmovl_u8(a4).u64[0];
      v18 = vaddw_u16(v18, a4);
      v20 += 4;
    }

    while (v20);
    v7 = vaddvq_s32(v18);
    if (v6 == v5)
    {
      goto LABEL_17;
    }

    goto LABEL_15;
  }

  v7 = 0;
LABEL_17:
  if ((*(*this + 46) & 0x80) != 0)
  {
    v25 = *(*this + 68);
  }

  else
  {
    v25 = 0;
  }

  v26 = (v25 - 1);
  v27 = a2 + (v25 - 2) * v7;
  v28 = v26 << 32;
  v16 = *(v4 + a2) == 0;
  v29 = 0x100000000;
  if (!v16)
  {
    v29 = v28;
  }

  return v29 | v27;
}

uint64_t mlir::anec::RingBufferReader::getODSOperands(mlir::anec::RingBufferReader *this, unsigned int a2, double a3, int32x4_t a4)
{
  if (a2)
  {
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
LABEL_14:
      v26 = a2 - v4;
      v27 = &xmmword_1E09999F8 + v4;
      do
      {
        v28 = *v27++;
        v5 += v28;
        --v26;
      }

      while (v26);
      goto LABEL_16;
    }

    if (a2 >= 0x20)
    {
      v6 = 0uLL;
      v7 = &unk_1E0999A08;
      v8 = 0uLL;
      v4 = a2 & 0xFFFFFFE0;
      v9 = v4;
      v10 = 0uLL;
      v11 = 0uLL;
      v12 = 0uLL;
      v13 = 0uLL;
      v14 = 0uLL;
      v15 = 0uLL;
      do
      {
        v16 = *v7[-2].i8;
        v17 = vmovl_u8(*v16.i8);
        v18 = vmovl_high_u8(v16);
        v19 = vmovl_u8(*v7);
        v20 = vmovl_high_u8(*v7->i8);
        v11 = vaddw_high_u16(v11, v18);
        v10 = vaddw_u16(v10, *v18.i8);
        v8 = vaddw_high_u16(v8, v17);
        v6 = vaddw_u16(v6, *v17.i8);
        v15 = vaddw_high_u16(v15, v20);
        v14 = vaddw_u16(v14, *v20.i8);
        v13 = vaddw_high_u16(v13, v19);
        v12 = vaddw_u16(v12, *v19.i8);
        v7 += 4;
        v9 -= 32;
      }

      while (v9);
      a4 = vaddq_s32(vaddq_s32(v13, v8), vaddq_s32(v15, v11));
      v5 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v12, v6), vaddq_s32(v14, v10)), a4));
      if (v4 == a2)
      {
        goto LABEL_16;
      }

      if ((a2 & 0x1C) == 0)
      {
        goto LABEL_14;
      }
    }

    else
    {
      v5 = 0;
      v4 = 0;
    }

    v21 = v4;
    v4 = a2 & 0xFFFFFFFC;
    v22 = v5;
    v23 = (&xmmword_1E09999F8 + v21);
    v24 = v21 - v4;
    do
    {
      v25 = *v23++;
      a4.i32[0] = v25;
      a4.i64[0] = vmovl_u8(*a4.i8).u64[0];
      v22 = vaddw_u16(v22, *a4.i8);
      v24 += 4;
    }

    while (v24);
    v5 = vaddvq_s32(v22);
    if (v4 == a2)
    {
      goto LABEL_16;
    }

    goto LABEL_14;
  }

  v5 = 0;
LABEL_16:
  v29 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v30 = *(v29 + 68);
    v31 = *(v29 + 72);
  }

  else
  {
    v30 = 0;
    v31 = 0;
  }

  return v31 + 32 * (a2 + (v30 - 2) * v5);
}

uint64_t mlir::anec::RingBufferWriter::getODSOperandIndexAndLength(mlir::anec::RingBufferWriter *this, unsigned int a2, double a3, uint8x8_t a4)
{
  v4 = &xmmword_1E09999F8 + 2;
  if (a2)
  {
    v5 = a2;
    if (a2 < 4)
    {
      v6 = 0;
      v7 = 0;
LABEL_15:
      v22 = &v4[v6];
      v23 = v5 - v6;
      do
      {
        v24 = *v22++;
        v7 += v24;
        --v23;
      }

      while (v23);
      goto LABEL_17;
    }

    if (a2 >= 0x20)
    {
      *v8.i64 = OUTLINED_FUNCTION_22_4();
      do
      {
        *v8.i64 = OUTLINED_FUNCTION_14_8(v8);
      }

      while (!v16);
      OUTLINED_FUNCTION_26_5(v8, v9, v10, v11, v12, v13, v14, v15);
      if (v16)
      {
        goto LABEL_17;
      }

      if ((v5 & 0x1C) == 0)
      {
        goto LABEL_15;
      }
    }

    else
    {
      v7 = 0;
      v6 = 0;
    }

    v17 = v6;
    v6 = v5 & 0xFFFFFFFC;
    v18 = v7;
    v19 = &v4[v17];
    v20 = v17 - v6;
    do
    {
      v21 = *v19;
      v19 += 4;
      a4.i32[0] = v21;
      a4 = vmovl_u8(a4).u64[0];
      v18 = vaddw_u16(v18, a4);
      v20 += 4;
    }

    while (v20);
    v7 = vaddvq_s32(v18);
    if (v6 == v5)
    {
      goto LABEL_17;
    }

    goto LABEL_15;
  }

  v7 = 0;
LABEL_17:
  if ((*(*this + 46) & 0x80) != 0)
  {
    v25 = *(*this + 68);
  }

  else
  {
    v25 = 0;
  }

  v26 = (v25 - 2);
  v27 = a2 + (v25 - 3) * v7;
  v28 = v26 << 32;
  v16 = v4[a2] == 0;
  v29 = 0x100000000;
  if (!v16)
  {
    v29 = v28;
  }

  return v29 | v27;
}

uint64_t mlir::anec::RingBufferWriter::getODSOperands(mlir::anec::RingBufferWriter *this, unsigned int a2, double a3, int32x4_t a4)
{
  if (a2)
  {
    if (a2 < 4)
    {
      v4 = 0;
      v5 = 0;
LABEL_14:
      v26 = a2 - v4;
      v27 = &xmmword_1E09999F8 + v4 + 2;
      do
      {
        v28 = *v27++;
        v5 += v28;
        --v26;
      }

      while (v26);
      goto LABEL_16;
    }

    if (a2 >= 0x20)
    {
      v6 = 0uLL;
      v7 = &unk_1E0999A0A;
      v8 = 0uLL;
      v4 = a2 & 0xFFFFFFE0;
      v9 = v4;
      v10 = 0uLL;
      v11 = 0uLL;
      v12 = 0uLL;
      v13 = 0uLL;
      v14 = 0uLL;
      v15 = 0uLL;
      do
      {
        v16 = *v7[-2].i8;
        v17 = vmovl_u8(*v16.i8);
        v18 = vmovl_high_u8(v16);
        v19 = vmovl_u8(*v7);
        v20 = vmovl_high_u8(*v7->i8);
        v11 = vaddw_high_u16(v11, v18);
        v10 = vaddw_u16(v10, *v18.i8);
        v8 = vaddw_high_u16(v8, v17);
        v6 = vaddw_u16(v6, *v17.i8);
        v15 = vaddw_high_u16(v15, v20);
        v14 = vaddw_u16(v14, *v20.i8);
        v13 = vaddw_high_u16(v13, v19);
        v12 = vaddw_u16(v12, *v19.i8);
        v7 += 4;
        v9 -= 32;
      }

      while (v9);
      a4 = vaddq_s32(vaddq_s32(v13, v8), vaddq_s32(v15, v11));
      v5 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v12, v6), vaddq_s32(v14, v10)), a4));
      if (v4 == a2)
      {
        goto LABEL_16;
      }

      if ((a2 & 0x1C) == 0)
      {
        goto LABEL_14;
      }
    }

    else
    {
      v5 = 0;
      v4 = 0;
    }

    v21 = v4;
    v4 = a2 & 0xFFFFFFFC;
    v22 = v5;
    v23 = (&xmmword_1E09999F8 + v21 + 2);
    v24 = v21 - v4;
    do
    {
      v25 = *v23++;
      a4.i32[0] = v25;
      a4.i64[0] = vmovl_u8(*a4.i8).u64[0];
      v22 = vaddw_u16(v22, *a4.i8);
      v24 += 4;
    }

    while (v24);
    v5 = vaddvq_s32(v22);
    if (v4 == a2)
    {
      goto LABEL_16;
    }

    goto LABEL_14;
  }

  v5 = 0;
LABEL_16:
  v29 = *this;
  if ((*(*this + 46) & 0x80) != 0)
  {
    v30 = *(v29 + 68);
    v31 = *(v29 + 72);
  }

  else
  {
    v30 = 0;
    v31 = 0;
  }

  return v31 + 32 * (a2 + (v30 - 3) * v5);
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::anec::MatMul,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  v14 = *(*(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v14);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::MatMul,void>::id && (*(DefiningOp + 46) & 0x80) != 0 && *(DefiningOp + 68) == 2 && ((v7 = *(DefiningOp + 72), v8 = *(v7 + 24), (v9 = **a3) == 0) ? (**a3 = v8, v7 = *(DefiningOp + 72), v10 = 1) : (v10 = v9 == v8), (v11 = a3[1], v14 = *(v7 + 56), (v12 = mlir::Value::getDefiningOp(&v14)) != 0) && *(*(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id && (!*v11 || *v11 == v12) && (*v11 = v12, v10)))
    {
      a3[2] = v6;
      v5 = 1;
    }

    else
    {
      v5 = 0;
    }
  }

  return (v6 != 0) & v5;
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ArgMinMax>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::BatchToSpace>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ChannelToSpace>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Concat>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

uint64_t mlir::OpTrait::anec::SameOperandsRank<mlir::anec::Convolution>::verifyTrait(uint64_t a1)
{
  v38 = *MEMORY[0x1E69E9840];
  if ((*(a1 + 46) & 0x80) == 0)
  {
    return 1;
  }

  v2 = *(a1 + 68);
  if (v2 < 2)
  {
    return 1;
  }

  v3 = *(a1 + 72);
  v4 = (*(*(v3 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v5 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v4 + 8);
  if (v5)
  {
    v5 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v4 + 8);
  }

  else
  {
    v4 = 0;
  }

  v28[0] = v4;
  v28[1] = v5;
  v6 = v3 + 56;
  v7 = v2 - 1;
  while (1)
  {
    v8 = (*(*v6 + 8) & 0xFFFFFFFFFFFFFFF8);
    v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v8 + 8);
    if (v9)
    {
      v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v8 + 8);
    }

    else
    {
      v8 = 0;
    }

    v27[0] = v8;
    v27[1] = v9;
    if (!v28[0] && !v8)
    {
      goto LABEL_25;
    }

    v10 = v8 ? 0 : -1;
    if (v28[0])
    {
      if (mlir::CallOpInterface::getArgOperands(v28))
      {
        mlir::CallableOpInterface::getArgAttrsAttr(v28);
        v12 = v11;
      }

      else
      {
        v12 = 0;
      }

      if (!v27[0])
      {
        goto LABEL_24;
      }
    }

    else
    {
      v12 = -1;
      if (!v8)
      {
        goto LABEL_24;
      }
    }

    if (mlir::CallOpInterface::getArgOperands(v27))
    {
      mlir::CallableOpInterface::getArgAttrsAttr(v27);
      v10 = v13;
    }

LABEL_24:
    if (v12 != v10)
    {
      break;
    }

LABEL_25:
    v6 += 32;
    if (!--v7)
    {
      return 1;
    }
  }

  v26 = 257;
  mlir::Operation::emitOpError(a1, &v25, v29);
  mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v29, "requires the same rank for all operands");
  v14 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v16);
  if (v29[0])
  {
    mlir::InFlightDiagnostic::report(v29);
  }

  if (v37)
  {
    if (v36 != &v37)
    {
      free(v36);
    }

    v17 = __p;
    if (__p)
    {
      v18 = v35;
      v19 = __p;
      if (v35 != __p)
      {
        do
        {
          v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v18 - 1);
        }

        while (v18 != v17);
        v19 = __p;
      }

      v35 = v17;
      operator delete(v19);
    }

    v20 = v32;
    if (v32)
    {
      v21 = v33;
      v22 = v32;
      if (v33 != v32)
      {
        do
        {
          v24 = *--v21;
          v23 = v24;
          *v21 = 0;
          if (v24)
          {
            operator delete[](v23);
          }
        }

        while (v21 != v20);
        v22 = v32;
      }

      v33 = v20;
      operator delete(v22);
    }

    if (v30 != &v31)
    {
      free(v30);
    }
  }

  return v14;
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::CropResize>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::DeQuant>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseAbs>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseAdd>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseDiv>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseEqual>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseEqualZero>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseGreaterThan>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseGreaterThanEqual>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseGreaterThanEqualZero>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseGreaterThanZero>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Padding>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Quant>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Resample>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::RingBufferReader>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v9[0] = v5;
  v9[1] = v6;
  isSplat = mlir::ElementsAttr::isSplat(v9);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::RingBufferWriter>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v9[0] = v5;
  v9[1] = v6;
  isSplat = mlir::ElementsAttr::isSplat(v9);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ScaledElementWise>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = (*(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }

  else
  {
    v6 = 0;
  }

  v11[0] = v5;
  v11[1] = v6;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v11);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(a2 + 36))
  {
    v5 = a2 - 16;
  }

  else
  {
    v5 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  v7 = 0;
  v8 = (*(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v8)
  {
    v7 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v8 + 8);
  }

  v11[0] = v8;
  v11[1] = v7;
  isSplat = mlir::ElementsAttr::isSplat(v11);
}

uint64_t mlir::detail::enumerate<mlir::detail::RecursivePatternMatcher<mlir::anec::GOC,mlir::detail::op_matcher<mlir::anec::Convolution>,mlir::detail::AnyValueMatcher,mlir::detail::AnyValueMatcher>,mlir::detail::RecursivePatternTraitMatcher<mlir::OpTrait::anec::NeuronOpTrait,mlir::detail::RecursivePatternMatcher<mlir::anec::GOC,mlir::detail::op_matcher<mlir::anec::Convolution>,mlir::detail::AnyValueMatcher,mlir::detail::AnyValueMatcher>>::match(mlir::Operation *)::{lambda(unsigned long,mlir::detail::RecursivePatternMatcher<mlir::anec::GOC,mlir::detail::op_matcher<mlir::anec::Convolution>,mlir::detail::AnyValueMatcher,mlir::detail::AnyValueMatcher> &)#1}>(uint64_t a1, uint64_t a2)
{
  v5 = *(*(**(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp(&v5);
  v4 = result && *(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id && (*(result + 46) & 0x80) != 0 && *(result + 68) == 3 && (v5 = *(*(result + 72) + 24), (result = mlir::Value::getDefiningOp(&v5)) != 0) && *(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id;
  **a2 &= v4;
  return result;
}

void mlir::anec::getOpMinimumFamilyImpl<(mlir::anec::Family)0>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_34_11(v2);
  }
}

void mlir::anec::getOpMinimumFamily()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)7>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)7>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)7>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)7>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)6>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)6>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_109_5(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)5>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)5>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_98_4(v2);
  }
}

void mlir::anec::anonymous namespace::defaultVerifyANECOp()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::SupportConstantOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_71_6(v2);
  }
}

void mlir::anec::anonymous namespace::defaultVerifyANECOp(mlir::Block **a1, BOOL *a2)
{
  v7 = *MEMORY[0x1E69E9840];
  v3 = "Found unsupported constant operand";
  v4 = 259;
  mlir::Operation::emitError(a1, &v3, &v5);
  *a2 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v5);
  if (v5)
  {
    mlir::InFlightDiagnostic::report(&v5);
  }

  if (v6[192] == 1)
  {
    mlir::Diagnostic::~Diagnostic(v6);
  }
}

void mlir::anec::anonymous namespace::getANECDimension()
{
  v1 = *MEMORY[0x1E69E9840];
  if (__cxa_guard_acquire(&_MergedGlobals_49))
  {
    memcpy(__dst, &unk_1E86D3818, sizeof(__dst));
    std::map<ZinIrDimension,__CFString const*>::map[abi:nn200100](&qword_1EE17CA48, __dst, 6);
    __cxa_atexit(std::map<ZinIrDimension,__CFString const*>::~map[abi:nn200100], &qword_1EE17CA48, &dword_1DF9BF000);
    __cxa_guard_release(&_MergedGlobals_49);
  }
}

void mlir::anec::Unflatten::verifyAttributesWithFamily()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::NeuronOpTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::NeuronOpTrait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_97_5(v2);
  }
}

uint64_t mlir::anec::Concat::verifyInvariantsImpl(uint64_t a1, uint64_t *a2, _BYTE *a3)
{
  if (*(a1 + 36))
  {
    v5 = a1 - 16;
  }

  else
  {
    v5 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  result = mlir::anec::__mlir_ods_local_type_constraint_ANECOps1(*a2, (*(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), "result", 6, 0);
  *a3 = result & 1;
  return result;
}

void mlir::anec::RingBufferReader::getEffects()
{
  {
    mlir::MemoryEffects::Read::Read(&mlir::SideEffects::Effect::get<mlir::MemoryEffects::Read>(void)::instance);
  }
}

{
  {
    v0 = mlir::SideEffects::DefaultResource::DefaultResource(mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance);
    OUTLINED_FUNCTION_8_2(v0, v1, &dword_1DF9BF000);
  }
}

void mlir::anec::RingBufferWriter::getEffects()
{
  {
    mlir::MemoryEffects::Write::Write(&mlir::SideEffects::Effect::get<mlir::MemoryEffects::Write>(void)::instance);
  }
}

void mlir::anec::RegionReturn::addOpToNetwork(uint64_t *a1)
{
  v28 = *MEMORY[0x1E69E9840];
  LOWORD(v20) = 257;
  mlir::OpState::emitOpError(a1, v19, v21);
  mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v21, "RegionReturn has no operand, this is a no-op!\n");
  if (v21[0])
  {
    mlir::InFlightDiagnostic::report(v21);
  }

  if (v27 == 1)
  {
    v8 = v26;
    if (v26 != &v27)
    {
      free(v26);
    }

    v9 = __p;
    if (__p)
    {
      v10 = v25;
      v11 = __p;
      if (v25 != __p)
      {
        do
        {
          v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v10 - 1);
        }

        while (v10 != v9);
        v11 = __p;
      }

      v25 = v9;
      operator delete(v11);
    }

    v12 = v22;
    if (v22)
    {
      v13 = v23;
      v14 = v22;
      if (v23 != v22)
      {
        do
        {
          v16 = *--v13;
          v15 = v16;
          *v13 = 0;
          if (v16)
          {
            operator delete[](v15);
          }
        }

        while (v13 != v12);
        v14 = v22;
      }

      v23 = v12;
      operator delete(v14);
    }

    v17 = OUTLINED_FUNCTION_89_0(v8, v1, v2, v3, v4, v5, v6, v7, v19[0], v19[1], v19[2], v19[3], v20, v21[0], v21[1], v21[2], v21[3]);
    if (!v18)
    {
      free(v17);
    }
  }
}

void mlir::anec::RegionReturn::addOpToNetwork(uint64_t a1)
{
  OUTLINED_FUNCTION_111_4(a1);
  OUTLINED_FUNCTION_106_3();
  if (v3)
  {
    OUTLINED_FUNCTION_5_3();
    OUTLINED_FUNCTION_94_4(v5);
    v2 = *(v1 + 3);
  }

  OUTLINED_FUNCTION_0_3(v2);
  OUTLINED_FUNCTION_105_5();
  if (v4)
  {
    mlir::InFlightDiagnostic::report(v1);
  }
}

{
  OUTLINED_FUNCTION_111_4(a1);
  OUTLINED_FUNCTION_106_3();
  if (v3)
  {
    OUTLINED_FUNCTION_5_3();
    OUTLINED_FUNCTION_94_4(v5);
    v2 = *(v1 + 3);
  }

  OUTLINED_FUNCTION_0_3(v2);
  OUTLINED_FUNCTION_105_5();
  if (v4)
  {
    mlir::InFlightDiagnostic::report(v1);
  }
}

void mlir::anec::RegionReturn::addOpToNetwork(mlir::Block ***a1, BOOL *a2)
{
  v30 = *MEMORY[0x1E69E9840];
  v21[0] = "network should not be nullptr";
  LOWORD(v22) = 259;
  mlir::OpState::emitError(a1, v21, v23);
  *a2 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v23);
  if (v23[0])
  {
    mlir::InFlightDiagnostic::report(v23);
  }

  if (v29)
  {
    v10 = v28;
    if (v28 != &v29)
    {
      free(v28);
    }

    v11 = __p;
    if (__p)
    {
      v12 = v27;
      v13 = __p;
      if (v27 != __p)
      {
        do
        {
          v12 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v12 - 1);
        }

        while (v12 != v11);
        v13 = __p;
      }

      v27 = v11;
      operator delete(v13);
    }

    v14 = v24;
    if (v24)
    {
      v15 = v25;
      v16 = v24;
      if (v25 != v24)
      {
        do
        {
          v18 = *--v15;
          v17 = v18;
          *v15 = 0;
          if (v18)
          {
            operator delete[](v17);
          }
        }

        while (v15 != v14);
        v16 = v24;
      }

      v25 = v14;
      operator delete(v16);
    }

    v19 = OUTLINED_FUNCTION_89_0(v10, v3, v4, v5, v6, v7, v8, v9, v21[0], v21[1], v21[2], v21[3], v22, v23[0], v23[1], v23[2], v23[3]);
    if (!v20)
    {
      free(v19);
    }
  }
}

void mlir::anec::parentIsAtLeast<(mlir::anec::Family)2>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::RegionOp<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RegionOp>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_33_5(v2);
  }
}

void mlir::Operation::getParentWithTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_56_7(v2);
  }
}

void mlir::OpInterface<mlir::anec::ANECompilerVerifierInterface,mlir::anec::detail::ANECompilerVerifierInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::anec::ANECompilerVerifierInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_23_14(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::anec::ANECompilerVerifierInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_23_14(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::A11Legacy>>()
{
  {
    v0 = llvm::getTypeName<mlir::SymbolOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_69_7(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::A11Legacy>>()
{
  {
    v0 = llvm::getTypeName<mlir::CallableOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_68_7(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::TargetLegalizerInterfaceInterfaceTraits::Model<mlir::anec::A11Legacy>>()
{
  {
    v0 = llvm::getTypeName<mlir::TargetLegalizerInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_87_6(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::FormableRegionOpInterfaceInterfaceTraits::Model<mlir::anec::A11Legacy>>()
{
  {
    v0 = llvm::getTypeName<mlir::FormableRegionOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_86_6(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::anec::detail::RegionPerformanceInterfaceInterfaceTraits::Model<mlir::anec::A11Legacy>>()
{
  {
    v0 = llvm::getTypeName<mlir::anec::RegionPerformanceInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_85_9(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::A11Legacy>>()
{
  {
    v0 = llvm::getTypeName<mlir::ExecutionCostOpInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_22_12(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)1>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)5>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)6>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)7>::Impl,mlir::ExecutionCostOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_84_6(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::SymbolOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_82_8(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::CallableOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallableOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_81_9(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::FunctionOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::FunctionOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_80_5(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_79_6(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::TargetLegalizerInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::TargetLegalizerInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_78_6(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::FormableRegionOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::FormableRegionOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_77_6(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::anec::RegionPerformanceInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::RegionPerformanceInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_76_7(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)1>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)1>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_67_6(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_66_8(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_75_8(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_35_11(v2);
  }
}

void mlir::detail::SymbolOpInterfaceTrait<mlir::anec::A11Legacy>::verifyTrait()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SymbolTable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SymbolTable>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_74_7(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ArgMinMax>>()
{
  {
    v0 = llvm::getTypeName<mlir::anec::ZinIrUnitInfoInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_32_11(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ArgMinMax>>()
{
  {
    v0 = llvm::getTypeName<mlir::anec::PlistGeneratorInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_24_14(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::anec::detail::VerifyAttributesWithFamilyInterfaceInterfaceTraits::Model<mlir::anec::ArgMinMax>>()
{
  {
    v0 = llvm::getTypeName<mlir::anec::VerifyAttributesWithFamilyInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_25_12(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ArgMinMax>>()
{
  {
    v0 = llvm::getTypeName<mlir::anec::InferReturnTypesInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_28_11(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::VerifyAttributesWithFamilyInterface::Trait,mlir::anec::ANECompilerVerifierInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_43_9(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_50_6(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_40_7(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::anec::VerifyAttributesWithFamilyInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::VerifyAttributesWithFamilyInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_44_7(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::anec::ANECompilerVerifierInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ANECompilerVerifierInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_42_9(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_46_6(v2);
  }
}

void mlir::Op<mlir::anec::ArgMinMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::VerifyAttributesWithFamilyInterface::Trait,mlir::anec::ANECompilerVerifierInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::RegionOp<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RegionOp>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_33_5(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ANECompilerVerifierInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::SupportConstantOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_71_6(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Ceil>>()
{
  {
    v0 = llvm::getTypeName<mlir::anec::ReshapeSwapInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_38_12(v2);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Ceil>>()
{
  {
    v0 = llvm::getTypeName<mlir::anec::TransposeSwapInterface>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_49_8(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ANECompilerVerifierInterface::Trait,mlir::anec::VerifyAttributesWithFamilyInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::anec::ReshapeSwapInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ReshapeSwapInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_64_5(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::anec::TransposeSwapInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::TransposeSwapInterface::Trait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_99_6(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::NeuronOpTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::NeuronOpTrait>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_97_5(v2);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::SameOperandsRank,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::VerifyAttributesWithFamilyInterface::Trait,mlir::anec::ANECompilerVerifierInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_63_6(v2);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::HasWeights<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::HasWeights>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::anec::HasWeights<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::HasWeights>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::SameOperandsRank<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::SameOperandsRank>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::anec::SameOperandsRank<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::SameOperandsRank>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ANECompilerVerifierInterface::Trait,mlir::anec::VerifyAttributesWithFamilyInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::anec::ConstantFoldable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable>(void)::Empty>>();
    v2 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
    OUTLINED_FUNCTION_108_5(v2);
  }
}

uint64_t mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, char *a2)
{
  v12 = a1;
  result = mlir::anec::RegionReturn::verifyInvariantsImpl(&v12);
  if ((result & 1) == 0)
  {
    goto LABEL_7;
  }

  result = mlir::OpTrait::impl::verifyIsTerminator(a1, v5);
  if ((result & 1) == 0)
  {
    goto LABEL_7;
  }

  v6 = 0x1ECE6D000uLL;
  {
    v6 = 0x1ECE6D000;
    if (v8)
    {
      v9 = llvm::getTypeName<mlir::OpTrait::RegionOp<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RegionOp>(void)::Empty>>();
      v11 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v9, v10);
      OUTLINED_FUNCTION_33_5(v11);
      v6 = 0x1ECE6D000;
    }
  }

  result = (*(**(a1 + 6) + 32))(*(a1 + 6), *(v6 + 4088));
  if (result || (result = mlir::Operation::getParentWithTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(a1)) != 0)
  {
    v7 = 1;
  }

  else
  {
LABEL_7:
    v7 = 0;
  }

  *a2 = v7;
  return result;
}

void mlir::Op<mlir::anec::ScaledElementWise,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ANECompilerVerifierInterface::Trait,mlir::anec::VerifyAttributesWithFamilyInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, _BYTE *a2)
{
  v8[2] = *MEMORY[0x1E69E9840];
  v6[0] = v7;
  v6[1] = 0x600000000;
  if ((*(a1 + 46) & 0x80) != 0)
  {
    v3 = *(a1 + 72);
    v4 = *(a1 + 68);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(v8, v3, v4);
  v5 = mlir::anec::validateAndBroadcastShapes(v8[0], v8[1], v6);
  if (v6[0] != v7)
  {
    free(v6[0]);
  }

  *a2 = v5 & 1;
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::anec::anonymous namespace::CanonicalizeConcat::matchAndRewrite(uint64_t a1, mlir::Operation *a2, mlir::Float32Type **a3)
{
  v166[6] = *MEMORY[0x1E69E9840];
  v148 = a2;
  v4 = *(a2 + 3);
  ODSOperandIndexAndLength = mlir::func::ReturnOp::getODSOperandIndexAndLength(&v148, 0);
  if ((*(v148 + 46) & 0x80) != 0)
  {
    v6 = *(v148 + 9);
  }

  else
  {
    v6 = 0;
  }

  if (*(v148 + 9))
  {
    v7 = v148 - 16;
  }

  else
  {
    v7 = 0;
  }

  v8 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v8)
  {
    v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v8 + 8);
  }

  else
  {
    v9 = 0;
  }

  v146 = v8;
  v147 = v9;
  Axis = mlir::anec::Concat::getAxis(&v148);
  if (mlir::anec::Softmax::getSubtractMax(&v148))
  {
    __p = operator new(0x30uLL);
    v135 = xmmword_1E0982960;
    OUTLINED_FUNCTION_4_16(__p, "failed: interleaved concat not supported");
    *(v12 + 32) = *(v11 + 32);
    *(v12 + 40) = 0;
    goto LABEL_29;
  }

  __p = mlir::ElementsAttr::isSplat(&v146);
  if (!mlir::Type::isF16(&__p))
  {
    v20 = operator new(0x28uLL);
    __p = v20;
    v135 = xmmword_1E09826C0;
    v20[8] = 909198880;
    OUTLINED_FUNCTION_4_16(v20, "failed: operation output must be F16");
    *(v21 + 36) = 0;
    goto LABEL_29;
  }

  if (Axis != 1)
  {
    __p = operator new(0x40uLL);
    v135 = xmmword_1E09829B0;
    OUTLINED_FUNCTION_4_16(__p, "failed: only works when concat is applied on the channel axis");
    *(v23 + 32) = *(v22 + 32);
    *(v23 + 45) = *(v22 + 45);
    *(v23 + 61) = 0;
LABEL_29:
    matched = mlir::logMatchFailure(&__p, *(v148 + 3), a3);
    if (SHIBYTE(v135) < 0)
    {
      operator delete(__p);
    }

    return matched;
  }

  v13 = (HIDWORD(ODSOperandIndexAndLength) + ODSOperandIndexAndLength);
  v14 = ODSOperandIndexAndLength;
  v15 = v13 - ODSOperandIndexAndLength;
  v116 = v4;
  v118 = v6 + 32 * ODSOperandIndexAndLength;
  if (v13 != ODSOperandIndexAndLength)
  {
    v24 = (v118 + 24);
    v25 = v13 - ODSOperandIndexAndLength;
    while (1)
    {
      __p = *v24;
      DefiningOp = mlir::Value::getDefiningOp(&__p);
      if (!DefiningOp)
      {
        break;
      }

      v27 = DefiningOp;
      if (*(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id || *(*mlir::getElementTypeOrSelf((*(*(*(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8)) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      {
        break;
      }

      v28 = *(v27 + 36) ? v27 - 16 : 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v28, 0);
      ElementTypeOrSelf = mlir::getElementTypeOrSelf((*(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!mlir::Type::isF16(&ElementTypeOrSelf))
      {
        break;
      }

      v24 += 4;
      if (!--v25)
      {
        goto LABEL_14;
      }
    }

    __p = operator new(0x28uLL);
    v135 = xmmword_1E0982950;
    OUTLINED_FUNCTION_4_16(__p, "failed: all inputs must be compatible");
    *(v31 + 29) = *(v30 + 29);
    *(v31 + 37) = 0;
    goto LABEL_29;
  }

LABEL_14:
  mlir::CallableOpInterface::getArgAttrsAttr(&v146);
  v17 = v16;
  v163 = v166;
  v165 = 6;
  v18 = 8 * v16;
  if (v16 < 7)
  {
    if (!v16)
    {
      goto LABEL_35;
    }

    v19 = v166;
  }

  else
  {
    v164 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v163, v166, v16, 8);
    v19 = v163;
  }

  memset_pattern16(v19, &unk_1E096FAE0, v18);
LABEL_35:
  v164 = v17;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(&v146);
  v35 = v163;
  v163[1] = *(ArgAttrsAttr + 8);
  v36 = v164;
  F32Type = mlir::Builder::getF32Type(a3 + 1, v37);
  v39 = mlir::RankedTensorType::get(v35, v36, F32Type, 0);
  v40 = v163;
  v41 = v164;
  F16Type = mlir::Builder::getF16Type(a3 + 1, v42);
  v145 = mlir::MemRefType::get(v40, v41, F16Type, 0, 0, 0);
  if (v39)
  {
    v44 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v39 + 8);
    mlir::mps::CPUNDArray::CPUNDArray(&__p, v39, v44, 0);
    v45 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v39 + 8);
  }

  else
  {
    mlir::mps::CPUNDArray::CPUNDArray(&__p, 0, 0, 0);
    v45 = 0;
  }

  mlir::mps::CPUNDArray::CPUNDArray(&ElementTypeOrSelf, v39, v45, 0);
  v46 = v138;
  v47 = v127;
  v160 = v162;
  v161 = 0x600000000;
  if (v13 != v14)
  {
    for (i = 0; i != v15; ++i)
    {
      v121 = *(v118 + 32 * i + 24);
      v67 = (*(v121 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (v67)
      {
        v68 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v67 + 8);
      }

      else
      {
        v68 = 0;
      }

      v157 = v67;
      v158 = v68;
      v69 = *(mlir::CallableOpInterface::getArgAttrsAttr(&v157) + 8);
      v70 = mlir::Value::getDefiningOp(&v121);
      v71 = *(*(v70 + 72) + 24);
      v72 = v161;
      if (v161 >= HIDWORD(v161))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v160, v162, v161 + 1, 8);
        v72 = v161;
      }

      v160[v72] = v71;
      LODWORD(v161) = v161 + 1;
      v157 = v159;
      v158 = 0xC00000000;
      v149 = &v151;
      v150 = 0xC00000000;
      mlir::matchConstantWithFloatVector<float>(*(*(v70 + 72) + 56), &v157);
      mlir::matchConstantWithFloatVector<float>(*(*(v70 + 72) + 88), &v149);
      v74 = v158;
      if (v158 == 1)
      {
        if (v69 < 1)
        {
          goto LABEL_70;
        }

        v73.i32[0] = *v157;
        if (v69 < 8)
        {
          v75 = 0;
          v76 = v46;
LABEL_68:
          v92 = v69 - v75;
          v46 = v76;
          do
          {
            v46->i32[0] = v73.i32[0];
            v46 = (v46 + 4);
            --v92;
          }

          while (v92);
          goto LABEL_70;
        }

        v75 = v69 & 0x7FFFFFFFFFFFFFF8;
        v76 = (v46 + 4 * (v69 & 0x7FFFFFFFFFFFFFF8));
        v89 = vdupq_lane_s32(*v73.i8, 0);
        v90 = v46 + 1;
        v91 = v69 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v90[-1] = v89;
          *v90 = v89;
          v90 += 2;
          v91 -= 8;
        }

        while (v91);
        v46 = (v46 + 4 * (v69 & 0x7FFFFFFFFFFFFFF8));
        if (v69 != v75)
        {
          goto LABEL_68;
        }
      }

      else
      {
        if (!v158)
        {
          goto LABEL_70;
        }

        v77 = v157;
        v78 = (v158 - 1) & 0x3FFFFFFFFFFFFFFFLL;
        if (v78 < 7 || (v46 - v157) < 0x20)
        {
          v81 = v46;
          v82 = v157;
LABEL_62:
          v87 = &v77[4 * v74];
          v46 = v81;
          do
          {
            v88 = *v82;
            v82 += 4;
            v46->i32[0] = v88;
            v46 = (v46 + 4);
          }

          while (v82 != v87);
          goto LABEL_70;
        }

        v79 = v78 + 1;
        v80 = (v78 + 1) & 0x7FFFFFFFFFFFFFF8;
        v81 = (v46 + 4 * v80);
        v82 = v157 + 4 * v80;
        v83 = (v157 + 16);
        v84 = v46 + 1;
        v85 = v80;
        do
        {
          v73 = v83[-1];
          v86 = *v83;
          v84[-1] = v73;
          *v84 = v86;
          v83 += 2;
          v84 += 2;
          v85 -= 8;
        }

        while (v85);
        v46 = (v46 + 4 * v80);
        if (v79 != v80)
        {
          goto LABEL_62;
        }
      }

LABEL_70:
      v93 = v150;
      v94 = v149;
      if (v150 == 1)
      {
        if (v69 >= 1)
        {
          v73.i32[0] = *v149;
          if (v69 >= 8)
          {
            v95 = v69 & 0x7FFFFFFFFFFFFFF8;
            v96 = (v47 + 4 * (v69 & 0x7FFFFFFFFFFFFFF8));
            v108 = vdupq_lane_s32(*v73.i8, 0);
            v109 = v47 + 1;
            v110 = v69 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              v109[-1] = v108;
              *v109 = v108;
              v109 += 2;
              v110 -= 8;
            }

            while (v110);
            v47 = (v47 + 4 * (v69 & 0x7FFFFFFFFFFFFFF8));
            if (v69 == v95)
            {
              goto LABEL_90;
            }
          }

          else
          {
            v95 = 0;
            v96 = v47;
          }

          v111 = v69 - v95;
          v47 = v96;
          do
          {
            v47->i32[0] = v73.i32[0];
            v47 = (v47 + 4);
            --v111;
          }

          while (v111);
        }
      }

      else if (v150)
      {
        v97 = (v150 - 1) & 0x3FFFFFFFFFFFFFFFLL;
        if (v97 < 7 || (v47 - v149) < 0x20)
        {
          v100 = v47;
          v101 = v149;
        }

        else
        {
          v98 = v97 + 1;
          v99 = (v97 + 1) & 0x7FFFFFFFFFFFFFF8;
          v100 = (v47 + 4 * v99);
          v101 = (v149 + 4 * v99);
          v102 = (v149 + 16);
          v103 = v47 + 1;
          v104 = v99;
          do
          {
            v105 = *v102;
            v103[-1] = v102[-1];
            *v103 = v105;
            v102 += 2;
            v103 += 2;
            v104 -= 8;
          }

          while (v104);
          v47 = (v47 + 4 * v99);
          if (v98 == v99)
          {
            goto LABEL_90;
          }
        }

        v106 = v94 + v93;
        v47 = v100;
        do
        {
          v107 = *v101++;
          v47->i32[0] = v107;
          v47 = (v47 + 4);
        }

        while (v101 != v106);
      }

LABEL_90:
      if (v94 != &v151)
      {
        free(v94);
      }

      if (v157 != v159)
      {
        free(v157);
      }
    }
  }

  v157 = mlir::anec::Concat::getAxis(&v148);
  LOBYTE(v121) = mlir::anec::Softmax::getSubtractMax(&v148);
  v149 = mlir::OpBuilder::create<mlir::anec::Concat,llvm::SmallVector<mlir::Value,6u> &,unsigned long long,BOOL>(a3 + 1, v116, &v160, &v157, &v121);
  ElementsAttr = mlir::mps::CPUNDArray::getElementsAttr(&__p, 0, 1);
  v121 = OUTLINED_FUNCTION_1_28(ElementsAttr, v49, v50, v51, v52, v53, v54, v55, v166, v162, v116, v118, v120, v121, ElementTypeOrSelf, v123, v124, v125, v126, v127, v128, v129, v130, v131, v132, v133, __p, v135, *(&v135 + 1), v136, v137, v138, v139, v140, v141, v142, v143, v144, v145, v146, v147, v148, v149, v150, v151, v152, v153, v154, v155, v156, v157, v158);
  v56 = mlir::mps::CPUNDArray::getElementsAttr(&ElementTypeOrSelf, 0, 1);
  v120 = OUTLINED_FUNCTION_1_28(v56, v57, v58, v59, v60, v61, v62, v63, v112, v114, v117, v119, v120, v121, ElementTypeOrSelf, v123, v124, v125, v126, v127, v128, v129, v130, v131, v132, v133, __p, v135, *(&v135 + 1), v136, v137, v138, v139, v140, v141, v142, v143, v144, v145, v146, v147, v148, v149, v150, v151, v152, v153, v154, v155, v156, v157, v158);
  v64 = v148;
  v65 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::anec::Concat &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>((a3 + 1), *(v148 + 3), &v146, &v149, &v121, &v120);
  (*(*a3 + 1))(a3, v64, v65);
  if (v160 != v115)
  {
    free(v160);
  }

  mlir::mps::CPUNDArray::~CPUNDArray(&ElementTypeOrSelf);
  mlir::mps::CPUNDArray::~CPUNDArray(&__p);
  if (v163 != v113)
  {
    free(v163);
  }

  return 1;
}

uint64_t mlir::anec::anonymous namespace::ANEC_PadDeconvFolding::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_PadDeconvFolding *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v50[4] = *MEMORY[0x1E69E9840];
  v44 = 0;
  v45 = 0;
  v43 = 0;
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
    v6 = *(a2 + 17);
  }

  else
  {
    v5 = 0;
    v6 = 0;
  }

  v42[0] = v5;
  v42[1] = v6;
  v41 = 0;
  v48 = v50;
  v50[0] = a2;
  v49 = 0x400000001;
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id)
  {
    v7 = a2;
  }

  else
  {
    v7 = 0;
  }

  v47[0] = *(*(v7 + 9) + 24);
  DefiningOp = mlir::Value::getDefiningOp(v47);
  if (!DefiningOp)
  {
    v36 = *(a3 + 2);
    if (v36 && mlir::RewriterBase::Listener::classof(*(a3 + 2)))
    {
    }

    goto LABEL_79;
  }

  v9 = DefiningOp;
  {
    goto LABEL_79;
  }

  v10 = v49;
  if (v49 >= HIDWORD(v49))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v48, v50, v49 + 1, 8);
    v10 = v49;
  }

  *(v48 + v10) = v9;
  LODWORD(v49) = v49 + 1;
  if (!*(a2 + 47) || (v51.var0 = "stride", v51.var1 = 6, InherentAttr = mlir::Operation::getInherentAttr(a2, v51), (v12 & 1) == 0))
  {
    v52.var0 = "stride";
    v52.var1 = 6;
    InherentAttr = mlir::DictionaryAttr::get((a2 + 56), v52);
  }

  if (!InherentAttr || !mlir::DenseIntElementsAttr::classof(InherentAttr))
  {
    v37 = *(a3 + 2);
    if (!v37 || !mlir::RewriterBase::Listener::classof(v37))
    {
      goto LABEL_79;
    }

    v38 = *(a2 + 3);
LABEL_78:
    (*(*v37 + 88))(v37, v38, v39, v47);
    goto LABEL_79;
  }

  if (!*(a2 + 47) || (v53.var0 = "dilation", v53.var1 = 8, v13 = mlir::Operation::getInherentAttr(a2, v53), (v14 & 1) == 0))
  {
    v54.var0 = "dilation";
    v54.var1 = 8;
    v13 = mlir::DictionaryAttr::get((a2 + 56), v54);
  }

  if (!v13 || !mlir::DenseIntElementsAttr::classof(v13))
  {
    v37 = *(a3 + 2);
    if (!v37 || !mlir::RewriterBase::Listener::classof(v37))
    {
      goto LABEL_79;
    }

    v38 = *(a2 + 3);
    goto LABEL_78;
  }

  if (!*(a2 + 47) || (v55.var0 = "padding", v55.var1 = 7, v15 = mlir::Operation::getInherentAttr(a2, v55), (v16 & 1) == 0))
  {
    v56.var0 = "padding";
    v56.var1 = 7;
    v15 = mlir::DictionaryAttr::get((a2 + 56), v56);
  }

  if (!v15 || !mlir::DenseIntElementsAttr::classof(v15))
  {
    v37 = *(a3 + 2);
    if (!v37 || !mlir::RewriterBase::Listener::classof(v37))
    {
      goto LABEL_79;
    }

    v38 = *(a2 + 3);
    goto LABEL_78;
  }

  if (!*(a2 + 47) || (v57.var0 = "padding_mode", v57.var1 = 12, v17 = mlir::Operation::getInherentAttr(a2, v57), (v18 & 1) == 0))
  {
    v58.var0 = "padding_mode";
    v58.var1 = 12;
    v17 = mlir::DictionaryAttr::get((a2 + 56), v58);
  }

  if (!v17 || (mlir::anec::PaddingModeAttr::classof(v17) & 1) == 0)
  {
    mlir::arith::AtomicRMWKindAttr::get(*(a3 + 1), 0);
  }

  if (!*(a2 + 47) || (v59.var0 = "groups", v59.var1 = 6, v19 = mlir::Operation::getInherentAttr(a2, v59), (v20 & 1) == 0))
  {
    v60.var0 = "groups";
    v60.var1 = 6;
    v19 = mlir::DictionaryAttr::get((a2 + 56), v60);
  }

  if (!v19 || *(*v19 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    IntegerType = mlir::Builder::getIntegerType(a3 + 1, 64, 0);
    mlir::Builder::getIntegerAttr(a3 + 8, IntegerType, 1);
  }

  if (!*(a2 + 47) || (v61.var0 = "channel_wise", v61.var1 = 12, mlir::Operation::getInherentAttr(a2, v61), (v22 & 1) == 0))
  {
    v62.var0 = "channel_wise";
    v62.var1 = 12;
    mlir::DictionaryAttr::get((a2 + 56), v62);
  }

  if (!*(a2 + 47) || (v63.var0 = "kernel_scale", v63.var1 = 12, v23 = mlir::Operation::getInherentAttr(a2, v63), (v24 & 1) == 0))
  {
    v64.var0 = "kernel_scale";
    v64.var1 = 12;
    v23 = mlir::DictionaryAttr::get((a2 + 56), v64);
  }

  if (v23)
  {
    mlir::DenseFPElementsAttr::classof(v23);
  }

  if (!*(a2 + 47) || (v65.var0 = "kernel_zero_point", v65.var1 = 17, v25 = mlir::Operation::getInherentAttr(a2, v65), (v26 & 1) == 0))
  {
    v66.var0 = "kernel_zero_point";
    v66.var1 = 17;
    v25 = mlir::DictionaryAttr::get((a2 + 56), v66);
  }

  if (v25)
  {
    mlir::DenseIntElementsAttr::classof(v25);
  }

  if (!*(a2 + 47) || (v67.var0 = "kernel_palettized_LUT", v67.var1 = 21, v27 = mlir::Operation::getInherentAttr(a2, v67), (v28 & 1) == 0))
  {
    v68.var0 = "kernel_palettized_LUT";
    v68.var1 = 21;
    v27 = mlir::DictionaryAttr::get((a2 + 56), v68);
  }

  if (v27)
  {
    mlir::DenseElementsAttr::classof(v27);
  }

  if (!*(a2 + 47) || (v69.var0 = "kernel_mutable_palettized_LUT", v69.var1 = 29, mlir::Operation::getInherentAttr(a2, v69), (v29 & 1) == 0))
  {
    v70.var0 = "kernel_mutable_palettized_LUT";
    v70.var1 = 29;
    mlir::DictionaryAttr::get((a2 + 56), v70);
  }

  if (*(v7 + 9))
  {
    v30 = v7 - 16;
  }

  else
  {
    v30 = 0;
  }

  v47[0] = mlir::detail::OpResultImpl::getNextResultAtOffset(v30, 0);
  v31 = mlir::Value::getDefiningOp(v47);
  if (*(v41 + 9))
  {
    v32 = v41 - 16;
  }

  else
  {
    v32 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v32, 0);
  v33 = mlir::Value::getDefiningOp(&NextResultAtOffset);
  v34 = OUTLINED_FUNCTION_0_21();
  {
    v35 = *(*(v48 + 1) + 24);
    v47[0] = *(*v48 + 24);
    v47[1] = v35;
    mlir::Builder::getFusedLoc(a3 + 1, v47, 2, 0);
  }

  v37 = *(a3 + 2);
  if (v37 && mlir::RewriterBase::Listener::classof(v37))
  {
    v38 = *(a2 + 3);
    goto LABEL_78;
  }

LABEL_79:
  if (v48 != v50)
  {
    free(v48);
  }

  return 0;
}

void mlir::OpBuilder::create<mlir::anec::Deconvolution,mlir::detail::TypedValue<mlir::MemRefType>,mlir::detail::TypedValue<mlir::MemRefType>,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::anec::PaddingMode &,unsigned long long,BOOL,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseElementsAttr,mlir::DictionaryAttr>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "anec.deconvolution";
  *(a2 + 24) = 18;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

uint64_t mlir::anec::anonymous namespace::ANEC_GOCFolding::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_GOCFolding *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v27[4] = *MEMORY[0x1E69E9840];
  v25 = v27;
  v27[0] = a2;
  v26 = 0x400000001;
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
  {
    v5 = a2;
  }

  else
  {
    v5 = 0;
  }

  if ((*(v5 + 46) & 0x80) != 0)
  {
    v6 = *(v5 + 9);
    v7 = v6 + 32;
  }

  else
  {
    v6 = 0;
    v7 = 32;
  }

  v24 = *(v6 + 24);
  if (!mlir::Value::getDefiningOp(&v24))
  {
    goto LABEL_16;
  }

  {
    v18 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v18, v19);
  }

  v8 = OUTLINED_FUNCTION_1_29();
  if (((*(v9 + 32))(v8) & 1) == 0)
  {
LABEL_16:
    v14 = *(a3 + 2);
    if (!v14 || !mlir::RewriterBase::Listener::classof(v14))
    {
      goto LABEL_26;
    }

    v15 = *(a2 + 3);
LABEL_25:
    (*(*v14 + 88))(v14, v15, v16, &v24);
    goto LABEL_26;
  }

  v24 = *(v7 + 24);
  if (!mlir::Value::getDefiningOp(&v24))
  {
    goto LABEL_19;
  }

  {
    v20 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v20, v21);
  }

  v10 = OUTLINED_FUNCTION_1_29();
  if (((*(v11 + 32))(v10) & 1) == 0)
  {
LABEL_19:
    v14 = *(a3 + 2);
    if (!v14 || !mlir::RewriterBase::Listener::classof(v14))
    {
      goto LABEL_26;
    }

    v15 = *(a2 + 3);
    goto LABEL_25;
  }

  v24 = *(v6 + 88);
  if (mlir::Value::getDefiningOp(&v24))
  {
    {
      v22 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v22, v23);
    }

    v12 = OUTLINED_FUNCTION_1_29();
    if ((*(v13 + 32))(v12))
    {
      v24 = *(*v25 + 24);
      mlir::Builder::getFusedLoc(a3 + 1, &v24, 1, 0);
    }
  }

  v14 = *(a3 + 2);
  if (v14 && mlir::RewriterBase::Listener::classof(v14))
  {
    v15 = *(a2 + 3);
    goto LABEL_25;
  }

LABEL_26:
  if (v25 != v27)
  {
    free(v25);
  }

  return 0;
}

uint64_t mlir::anec::anonymous namespace::ANEC_InvertFolding::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_InvertFolding *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v27 = *MEMORY[0x1E69E9840];
  v20 = 0;
  v21 = v23;
  v23[0] = a2;
  v22 = 0x400000001;
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Invert,void>::id)
  {
    v5 = a2;
  }

  else
  {
    v5 = 0;
  }

  if ((*(v5 + 46) & 0x80) != 0)
  {
    v6 = *(v5 + 9);
  }

  else
  {
    v6 = 0;
  }

  if (!*(a2 + 47) || (v28.var0 = "epsilon", v28.var1 = 7, InherentAttr = mlir::Operation::getInherentAttr(a2, v28), (v8 & 1) == 0))
  {
    v29.var0 = "epsilon";
    v29.var1 = 7;
    InherentAttr = mlir::DictionaryAttr::get((a2 + 56), v29);
  }

  if (InherentAttr && *(*InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    v20 = InherentAttr;
    Value = mlir::FloatAttr::getValue(&v20, &ElementTypeOrSelf);
    v14 = v25[0];
    if (llvm::APFloatBase::PPCDoubleDouble(Value) == v14)
    {
      v15 = *(v25[1] + 28) & 7;
      llvm::detail::DoubleAPFloat::~DoubleAPFloat(v25);
    }

    else
    {
      v15 = v26 & 7;
      llvm::detail::IEEEFloat::~IEEEFloat(v25);
    }

    if (v15 == 3)
    {
      ElementTypeOrSelf = mlir::getElementTypeOrSelf((*(*(v6 + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
      if (mlir::Type::isF16(&ElementTypeOrSelf))
      {
        ElementTypeOrSelf = *(v6 + 24);
        if (mlir::Value::getDefiningOp(&ElementTypeOrSelf))
        {
          {
            v18 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v18, v19);
          }

          v16 = OUTLINED_FUNCTION_1_29();
          if ((*(v17 + 32))(v16))
          {
            ElementTypeOrSelf = *(*v21 + 24);
            mlir::Builder::getFusedLoc(a3 + 1, &ElementTypeOrSelf, 1, 0);
          }
        }

        v9 = a3[2];
        if (v9 && mlir::RewriterBase::Listener::classof(v9))
        {
          v10 = *(a2 + 3);
          goto LABEL_14;
        }
      }

      else
      {
        v9 = a3[2];
        if (v9 && mlir::RewriterBase::Listener::classof(v9))
        {
          v10 = *(a2 + 3);
          goto LABEL_14;
        }
      }
    }

    else
    {
      v9 = a3[2];
      if (v9 && mlir::RewriterBase::Listener::classof(v9))
      {
        v10 = *(a2 + 3);
        goto LABEL_14;
      }
    }
  }

  else
  {
    v9 = a3[2];
    if (v9 && mlir::RewriterBase::Listener::classof(v9))
    {
      v10 = *(a2 + 3);
LABEL_14:
      (*(*v9 + 88))(v9, v10, v11, &ElementTypeOrSelf);
    }
  }

  if (v21 != v23)
  {
    free(v21);
  }

  return 0;
}

uint64_t mlir::anec::anonymous namespace::ANEC_MulFolding::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_MulFolding *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x1E69E9840];
  v30 = v32;
  v32[0] = a2;
  v31 = 0x400000001;
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id)
  {
    v5 = a2;
  }

  else
  {
    v5 = 0;
  }

  if ((*(v5 + 46) & 0x80) != 0)
  {
    v6 = *(v5 + 9);
  }

  else
  {
    v6 = 0;
  }

  if (*(v5 + 9))
  {
    v7 = v5 - 16;
  }

  else
  {
    v7 = 0;
  }

  v28[0] = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
  v8 = (*(*(*(mlir::Value::getDefiningOp(v28) + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v8)
  {
    v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v8 + 8);
  }

  else
  {
    v9 = 0;
  }

  v29[0] = v8;
  v29[1] = v9;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v29);
  if (v11)
  {
    v12 = 0;
    v13 = 8 * v11;
    v14 = -1;
    while (1)
    {
      if (*(ArgAttrsAttr + 8 * v12) != 1)
      {
        v15 = v14 == -1;
        v14 = v12;
        if (!v15)
        {
          break;
        }
      }

      ++v12;
      v13 -= 8;
      if (!v13)
      {
        goto LABEL_18;
      }
    }

    v20 = *(a3 + 2);
    if (v20 && mlir::RewriterBase::Listener::classof(v20))
    {
      v21 = *(a2 + 3);
      goto LABEL_34;
    }
  }

  else
  {
LABEL_18:
    v29[0] = *(v6 + 24);
    if (!mlir::Value::getDefiningOp(v29))
    {
      goto LABEL_25;
    }

    {
      v24 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v24, v25);
    }

    v16 = OUTLINED_FUNCTION_1_29();
    if ((*(v17 + 32))(v16))
    {
      v29[0] = *(v6 + 56);
      if (mlir::Value::getDefiningOp(v29))
      {
        {
          v26 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
          mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v26, v27);
        }

        v18 = OUTLINED_FUNCTION_1_29();
        if ((*(v19 + 32))(v18))
        {
          v29[0] = *(*v30 + 24);
          mlir::Builder::getFusedLoc(a3 + 1, v29, 1, 0);
        }
      }

      v20 = *(a3 + 2);
      if (v20 && mlir::RewriterBase::Listener::classof(v20))
      {
        v21 = *(a2 + 3);
        goto LABEL_34;
      }
    }

    else
    {
LABEL_25:
      v20 = *(a3 + 2);
      if (v20 && mlir::RewriterBase::Listener::classof(v20))
      {
        v21 = *(a2 + 3);
LABEL_34:
        (*(*v20 + 88))(v20, v21, v22, v29);
      }
    }
  }

  if (v30 != v32)
  {
    free(v30);
  }

  return 0;
}

uint64_t mlir::detail::RecursivePatternMatcherBinder<mlir::anec::Transpose,mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::anec::Transpose,0,mlir::detail::op_matcher_with_bind<mlir::anec::Linear>>>::match(mlir::Operation *)::{lambda(unsigned long,mlir::anec::Transpose *)#1}::operator()<mlir::detail::RecursivePatternOptionalMatcherBinder<mlir::anec::Transpose,0,mlir::detail::op_matcher_with_bind<mlir::anec::Linear>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  v15 = *(*(**(a1 + 8) + 72) + 32 * a2 + 24);
  result = mlir::Value::getDefiningOp(&v15);
  if (result)
  {
    v6 = result;
    v7 = *(*(result + 48) + 16);
    if (v7 == &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id)
    {
      if ((*(result + 46) & 0x80) == 0 || *(result + 68) != 1 || (v14 = *a3, v16 = *(*(result + 72) + 24), (result = mlir::Value::getDefiningOp(&v16)) == 0) || *(*(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::Linear,void>::id || *v14 && *v14 != result)
      {
LABEL_25:
        v10 = 0;
        goto LABEL_28;
      }

      *v14 = result;
      if ((a3[2] & 1) == 0)
      {
        *(a3 + 16) = 1;
      }

      a3[1] = v6;
    }

    else
    {
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Linear,void>::id)
      {
        goto LABEL_25;
      }

      v8 = **a3;
      if (v8 && v8 != result)
      {
        goto LABEL_25;
      }

      **a3 = result;
    }

    v10 = 1;
  }

  else
  {
    v11 = *a3;
    v16 = v15;
    result = mlir::Value::getDefiningOp(&v16);
    if (result)
    {
      if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Linear,void>::id && (*v11 ? (v13 = *v11 == result) : (v13 = 1), v13))
      {
        *v11 = result;
        v12 = 1;
      }

      else
      {
        v12 = 0;
      }
    }

    v10 = (result != 0) & v12;
  }

LABEL_28:
  **a1 &= v10;
  return result;
}

uint64_t mlir::anec::anonymous namespace::InsertDummyMulForScaledEWSquare::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  v48 = a2;
  Mode = mlir::anec::ScaledElementWise::getMode(&v48);
  if (!v5)
  {
    return 0;
  }

  v6 = v5;
  if (v5 >= 3)
  {
    v7 = 3;
  }

  else
  {
    v7 = v5;
  }

  v8 = memcmp(Mode, "mul", v7);
  result = 0;
  if (v6 == 3 && !v8)
  {
    if ((*(v48 + 46) & 0x80) == 0)
    {
      return 0;
    }

    if (*(v48 + 17) != 2)
    {
      return 0;
    }

    v10 = *(v48 + 9);
    if (*(v10 + 24) != *(v10 + 56))
    {
      return 0;
    }

    v42[0] = *(v10 + 24);
    result = mlir::Value::getDefiningOp(v42);
    if (result)
    {
      v11 = *(*(result + 48) + 16);
      v12 = v11 == &mlir::detail::TypeIDResolver<mlir::anec::ScaledElementWise,void>::id;
      if (v11 == &mlir::detail::TypeIDResolver<mlir::anec::ScaledElementWise,void>::id)
      {
        v13 = result;
      }

      else
      {
        v13 = 0;
      }

      v47 = v13;
      if (!v12)
      {
        return 0;
      }

      v14 = mlir::anec::ScaledElementWise::getMode(&v47);
      if (!v15)
      {
        return 0;
      }

      v16 = v15;
      if (v15 >= 3)
      {
        v17 = 3;
      }

      else
      {
        v17 = v15;
      }

      v19 = memcmp(v14, "add", v17);
      result = 0;
      if (v16 == 3 && !v19)
      {
        v20 = (a3 + 24);
        v36 = *(a3 + 24);
        v21 = *(v47 + 2);
        v22 = *(MPSGraphDelegateCompiler.precompilationDescriptor.modify(v47, v18) + 8);
        *(a3 + 24) = v21;
        *(a3 + 32) = v22;
        v23 = *(v48 + 3);
        v24 = *(OUTLINED_FUNCTION_28_4(v47) + 8) & 0xFFFFFFFFFFFFFFF8;
        if (v24)
        {
          v25 = OUTLINED_FUNCTION_112_6();
        }

        else
        {
          v25 = 0;
        }

        v27 = *(v48 + 3);
        v49 = (*(OUTLINED_FUNCTION_28_4(v47) + 8) & 0xFFFFFFFFFFFFFFF8);
        v46 = OUTLINED_FUNCTION_28_4(v47);
        if (*(ScalarConst + 36))
        {
          v28 = ScalarConst - 16;
        }

        else
        {
          v28 = 0;
        }

        NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v28, 0);
        v43 = 261;
        v42[0] = "mul";
        v42[1] = 3;
        StringAttr = mlir::Builder::getStringAttr((a3 + 8), v42);
        F32FloatAttr = mlir::Builder::getF32FloatAttr((a3 + 8), 1.0, v29);
        v40 = mlir::Builder::getF32FloatAttr((a3 + 8), 1.0, v30);
        v39 = mlir::Builder::getF32FloatAttr((a3 + 8), 0.0, v31);
        BoolAttr = mlir::Builder::getBoolAttr((a3 + 8), 0);
        v37 = mlir::Builder::getBoolAttr((a3 + 8), 0);
        v32 = mlir::OpBuilder::create<mlir::anec::ScaledElementWise,mlir::MemRefType &,mlir::Value,mlir::Value,mlir::StringAttr &,mlir::FloatAttr &,mlir::FloatAttr &,mlir::FloatAttr &,mlir::BoolAttr &,mlir::BoolAttr &>((a3 + 8), v27, &v49, &v46, &NextResultAtOffset, &StringAttr, &F32FloatAttr, &v40, &v39, &BoolAttr, &v37);
        v33 = OUTLINED_FUNCTION_28_4(v47);
        if (*(v32 + 36))
        {
          v34 = v32 - 16;
        }

        else
        {
          v34 = 0;
        }

        v35 = mlir::detail::OpResultImpl::getNextResultAtOffset(v34, 0);
        v42[0] = v32;
        v49 = v42;
        mlir::RewriterBase::replaceUsesWithIf(a3, v33, v35, llvm::function_ref<BOOL ()(mlir::OpOperand &)>::callback_fn<mlir::RewriterBase::replaceAllUsesExcept(mlir::Value,mlir::Value,mlir::Operation *)::{lambda(mlir::OpOperand &)#1}>, &v49, 0);
        if (v36)
        {
          *v20 = v36;
        }

        else
        {
          *v20 = 0;
          *(a3 + 32) = 0;
        }

        return 1;
      }
    }
  }

  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mpsx::TensorToBufferOp,mlir::detail::RecursivePatternMatcherBinder<mlir::placement::MemrefToTensor,mlir::detail::any_value_binder>>>(uint64_t a1, unsigned int a2, uint64_t ***a3)
{
  v12 = *(*(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v12);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::TensorToBufferOp,void>::id)
    {
      goto LABEL_11;
    }

    if ((*(DefiningOp + 46) & 0x80) == 0)
    {
      goto LABEL_11;
    }

    if (*(DefiningOp + 68) != 1)
    {
      goto LABEL_11;
    }

    v7 = *a3;
    v12 = *(*(DefiningOp + 72) + 24);
    v8 = mlir::Value::getDefiningOp(&v12);
    if (!v8 || *(*(v8 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id || (*(v8 + 46) & 0x80) == 0 || *(v8 + 68) != 1)
    {
      goto LABEL_11;
    }

    v9 = *(*(v8 + 72) + 24);
    v10 = **v7;
    if (v10)
    {
      if (v10 != v9)
      {
LABEL_11:
        v5 = 0;
        return (v6 != 0) & v5;
      }
    }

    else
    {
      **v7 = v9;
    }

    v7[1] = v8;
    a3[1] = v6;
    v5 = 1;
  }

  return (v6 != 0) & v5;
}

void mlir::anec::anonymous namespace::CanonicalizePlacementRegionEnter::matchAndRewrite()
{
  __p = OUTLINED_FUNCTION_2_23();
  *v0 = OUTLINED_FUNCTION_1_30(__p, "failed: bufferToTensor op needs to have shape attribute", v1);
  operator delete(__p);
}

void mlir::OpBuilder::create<mlir::mpsx::InterleaveOp,mlir::Value &,mlir::IntegerAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mpsx.interleave";
  *(a2 + 24) = 15;
}

void mlir::OpInterface<mlir::anec::PlistGeneratorInterface,mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::anec::PlistGeneratorInterface>();
    mlir::detail::TypeIDResolver<mlir::anec::PlistGeneratorInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::anec::PlistGeneratorInterface>();
    mlir::detail::TypeIDResolver<mlir::anec::PlistGeneratorInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::silc::PlistGeneratorInterface,mlir::silc::detail::PlistGeneratorInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::silc::PlistGeneratorInterface>();
    mlir::detail::TypeIDResolver<mlir::silc::PlistGeneratorInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::silc::PlistGeneratorInterface>();
    mlir::detail::TypeIDResolver<mlir::silc::PlistGeneratorInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::anec::anonymous namespace::MakeInputsUnique::matchAndRewrite(uint64_t a1, uint64_t a2, llvm *a3, llvm *a4)
{
  v8[3] = *MEMORY[0x1E69E9840];
  v7[3] = a3;
  v7[4] = a4;
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 72);
    v6 = *(a2 + 68);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(v8, v5, v6);
}

void mlir::anec::anonymous namespace::ANECRegionCallOpRewritePatternBase::removeInputsAndOutputs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6)
{
  v34 = *MEMORY[0x1E69E9840];
  v26[1] = a3;
  v26[2] = a1;
  v26[0] = a2;
  BodyBlock = mlir::TargetLegalizerInterface::getBodyBlock(v26);
  Terminator = mlir::Block::getTerminator(BodyBlock, v10);
  v12 = Terminator;
  if (*(a6 + 8))
  {
    if ((*(Terminator + 46) & 0x80) != 0)
    {
      v13 = *(Terminator + 72);
      v14 = *(Terminator + 68);
    }

    else
    {
      OUTLINED_FUNCTION_44_0();
    }

    mlir::ValueRange::ValueRange(v28, v13, v14);
    OUTLINED_FUNCTION_1_31();
  }

  v15 = mlir::TargetLegalizerInterface::getBodyBlock(v26);
  v29 = a5;
  v16 = *(a4 + 8);
  v17 = mlir::TargetLegalizerInterface::getBodyBlock(v26);
  ArgumentTypes = mlir::Block::getArgumentTypes(v17);
  mlir::ValueRange::ValueRange(&v29, ArgumentTypes, (v19 - ArgumentTypes) >> 3);
  mlir::TypeRange::TypeRange(v28, v29, v30);
  if ((*(v12 + 46) & 0x80) != 0)
  {
    v20 = *(v12 + 72);
    v21 = *(v12 + 68);
  }

  else
  {
    v20 = 0;
    v21 = 0;
  }

  v32 = v20;
  v33 = v21;
  mlir::OperandRange::getTypes(&v32, &v29);
  mlir::ValueRange::ValueRange(&v32, v29 + 32 * v30, v31 - v30);
  mlir::TypeRange::TypeRange(v27, v32, v33);
  v25 = mlir::FunctionType::get(v16, v28[0], v28[1], v27[0], v27[1]);
  mlir::TargetLegalizerInterface::setFunctionType(v26, v25);
  if ((*(a1 + 46) & 0x80) != 0)
  {
    v22 = *(a1 + 72);
    v23 = *(a1 + 68);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(v28, v22, v23);
  OUTLINED_FUNCTION_1_31();
}

void mlir::anec::anonymous namespace::MakeOutputsUnique::apply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[3] = *MEMORY[0x1E69E9840];
  v9[0] = a2;
  v9[1] = a3;
  BodyBlock = mlir::TargetLegalizerInterface::getBodyBlock(v9);
  Terminator = mlir::Block::getTerminator(BodyBlock, v4);
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v6 = *(Terminator + 72);
    v7 = *(Terminator + 68);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(v10, v6, v7);
}

void mlir::anec::anonymous namespace::RemovePassthroughValues::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v11[3] = *MEMORY[0x1E69E9840];
  v9[0] = a3;
  v9[1] = a4;
  BodyBlock = mlir::TargetLegalizerInterface::getBodyBlock(v9);
  Terminator = mlir::Block::getTerminator(BodyBlock, v5);
  if ((*(Terminator + 46) & 0x80) != 0)
  {
    v7 = *(Terminator + 72);
    v8 = *(Terminator + 68);
  }

  else
  {
    OUTLINED_FUNCTION_44_0();
  }

  mlir::ValueRange::ValueRange(v11, v7, v8);
}

void mlir::silc::SilcAllGatherOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::silc::detail::SilcAllGatherOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::silc::detail::SilcAllGatherOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::silc::SilcAllReduceOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::silc::detail::SilcAllReduceOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::silc::detail::SilcAllReduceOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::silc::SilcAllSliceOp::build()
{
  {
    v0 = llvm::getTypeName<mlir::silc::detail::SilcAllSliceOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::silc::detail::SilcAllSliceOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::mps::FloorDivideOp,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.floor_divide";
  *(a2 + 24) = 16;
}

void mlir::OpBuilder::create<mlir::mps::CosOp,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.cos";
  *(a2 + 24) = 7;
}

void mlir::OpBuilder::create<mlir::mps::SinOp,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.sin";
  *(a2 + 24) = 7;
}

void mlir::OpBuilder::create<mlir::mps::TanhOp,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.tanh";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::mps::AndOp,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.and";
  *(a2 + 24) = 7;
}

void mlir::OpBuilder::create<mlir::mps::OrOp,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.or";
  *(a2 + 24) = 6;
}

void mlir::OpBuilder::create<mlir::mps::NotOp,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.not";
  *(a2 + 24) = 7;
}

void mlir::OpBuilder::create<mlir::mps::GeluOp,mlir::Value>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.gelu";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::mps::ReductionOrOp,mlir::Value,mlir::Value,BOOL &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reduction_or";
  *(a2 + 24) = 16;
}

void mlir::OpBuilder::create<mlir::mps::ReductionAndOp,mlir::Value,mlir::Value,BOOL &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.reduction_and";
  *(a2 + 24) = 17;
}

void mlir::ElementsAttr::value_begin<int>(llvm *a1, uint64_t *a2)
{
  v3 = llvm::errs(a1);
  Type = llvm::getTypeName<int>();
  v7 = llvm::raw_ostream::operator<<(v4, Type, v6);
  v9 = mlir::operator<<(v8, *a2);
  llvm::raw_ostream::operator<<(v9, "\n");
  __break(1u);
}

void mlir::OpBuilder::create<mlir::mps::StridedSliceUpdateOp,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value,int,int,int,BOOL>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.strided_slice_update";
  *(a2 + 24) = 24;
}

void mlir::OpBuilder::create<mlir::mps::ScatterNDOp,mlir::Value,mlir::Value,mlir::Value,int,mlir::mps::ScatterMode>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.scatter_nd";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::mps::SplitOp,mlir::Value,mlir::Value,mlir::Value,mlir::IntegerAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.split";
  *(a2 + 24) = 9;
}

void mlir::OpBuilder::create<mlir::mps::TileOp,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.tile";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::mps::NonZeroOp,mlir::ValueRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.non_zero";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::mps::CallOp,mlir::ValueTypeRange<mlir::ResultRange>,mlir::ValueRange,llvm::StringRef,mlir::mps::CallInlineMode>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.call";
  *(a2 + 24) = 8;
}

void mlir::OpBuilder::create<mlir::mps::DequantizeLUTOp,mlir::Value &,mlir::Value &,mlir::IntegerAttr &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "mps.dequantize_lut";
  *(a2 + 24) = 18;
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::ODIE::Compiler::CoreML::CallOp>::getArgOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    return *(a2 + 72);
  }

  else
  {
    return 0;
  }
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::ODIE::Compiler::CoreML::IfOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 72);
    v3 = *(a2 + 68);
  }

  else
  {
    v2 = 0;
    v3 = 0;
  }

  return v2 + 32 * v3;
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::ODIE::Compiler::CoreML::InvokeOp>::getArgOperands(uint64_t a1, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    return *(a2 + 72);
  }

  else
  {
    return 0;
  }
}

void mlir::ODIE::Compiler::CoreML::CoreInlinerInterface::handleTerminator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v21 = *MEMORY[0x1E69E9840];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 72);
    v6 = *(a2 + 68);
  }

  else
  {
    v5 = 0;
    v6 = 0;
  }

  v17 = a3;
  v18 = 0;
  v19 = v5;
  v20 = 0;
  if (a4 && v6)
  {
    v7 = 0;
    do
    {
      v8 = mlir::ValueRange::dereference_iterator(&v17, v7);
      v9 = v20;
      v10 = *v8;
      if (*v8)
      {
        v11 = *(v19 + 32 * v20 + 24);
        do
        {
          v12 = v10[1];
          if (v12)
          {
            v13 = *v10;
            *v12 = *v10;
            if (v13)
            {
              *(v13 + 8) = v12;
            }
          }

          v10[3] = v11;
          v14 = *v11;
          *v10 = *v11;
          v10[1] = v11;
          if (v14)
          {
            *(v14 + 8) = v10;
          }

          *v11 = v10;
          v10 = *v8;
        }

        while (*v8);
      }

      v7 = v18 + 1;
      v15 = v9 + 1;
      v18 = v7;
      v20 = v15;
    }

    while (v7 != a4 && v15 != v6);
  }
}

void mlir::Dialect::addInterfaces<mlir::ODIE::Compiler::CoreML::CoreInlinerInterface,mlir::ODIE::Compiler::CoreML::CoreMLBytecodeInterface>()
{
  {
    v0 = llvm::getTypeName<mlir::DialectInlinerInterface>();
    mlir::detail::TypeIDResolver<mlir::DialectInlinerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::BytecodeDialectInterface>();
    mlir::detail::TypeIDResolver<mlir::BytecodeDialectInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::CoreMLDialect::materializeConstant()
{
  {
    v0 = llvm::getTypeName<mlir::TypedAttr>();
    mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ConstantOp,mlir::Type &,mlir::TypedAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.constant";
  *(a2 + 24) = 15;
}

void mlir::ODIE::Compiler::CoreML::createElementsAttr()
{
  {
    v0 = llvm::getTypeName<mlir::DialectResourceBlobHandle<mlir::BuiltinDialect>>();
    mlir::detail::TypeIDResolver<mlir::DialectResourceBlobHandle<mlir::BuiltinDialect>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ElementsAttr>();
    mlir::detail::TypeIDResolver<mlir::ElementsAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::ODIE::Compiler::CoreML::AddOp>,mlir::OpTrait::OneResult<mlir::ODIE::Compiler::CoreML::AddOp>,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::ODIE::Compiler::CoreML::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::ODIE::Compiler::CoreML::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::ODIE::Compiler::CoreML::AddOp>,mlir::OpTrait::OpInvariants<mlir::ODIE::Compiler::CoreML::AddOp>,mlir::OpTrait::IsCommutative<mlir::ODIE::Compiler::CoreML::AddOp>,mlir::ODIE::Compiler::CoreML::ComplexDecompositionOpInterface::Trait<mlir::ODIE::Compiler::CoreML::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::ODIE::Compiler::CoreML::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::ODIE::Compiler::CoreML::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::ODIE::Compiler::CoreML::AddOp>,mlir::OpTrait::Elementwise<mlir::ODIE::Compiler::CoreML::AddOp>,mlir::OpTrait::SameOperandsAndResultShape<mlir::ODIE::Compiler::CoreML::AddOp>,mlir::InferShapedTypeOpInterface::Trait<mlir::ODIE::Compiler::CoreML::AddOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::ComplexDecompositionOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ComplexDecompositionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable>();
    mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffectOpInterface>();
    mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferShapedTypeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::InferShapedTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::ODIE::Compiler::CoreML::ComplexDecompositionOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::OpTrait::SameOperandsAndResultShape,mlir::InferShapedTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsCommutative<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsCommutative>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::IsCommutative<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsCommutative>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::ComplexDecompositionOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::CoreML::ComplexDecompositionOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ComplexDecompositionOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::CoreML::ComplexDecompositionOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsAndResultShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultShape>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferShapedTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferShapedTypeOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::InferShapedTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferShapedTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::ODIE::Compiler::CoreML::AllOp>,mlir::OpTrait::OneResult<mlir::ODIE::Compiler::CoreML::AllOp>,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::ODIE::Compiler::CoreML::AllOp>,mlir::OpTrait::ZeroSuccessors<mlir::ODIE::Compiler::CoreML::AllOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::ODIE::Compiler::CoreML::AllOp>,mlir::OpTrait::OpInvariants<mlir::ODIE::Compiler::CoreML::AllOp>,mlir::ConditionallySpeculatable::Trait<mlir::ODIE::Compiler::CoreML::AllOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::ODIE::Compiler::CoreML::AllOp>,mlir::MemoryEffectOpInterface::Trait<mlir::ODIE::Compiler::CoreML::AllOp>,mlir::ODIE::Compiler::CoreML::KernelTypeInference::Trait<mlir::ODIE::Compiler::CoreML::AllOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::KernelTypeInference>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::KernelTypeInference,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ODIE::Compiler::CoreML::KernelTypeInference::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::KernelTypeInference::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::CoreML::KernelTypeInference::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::KernelTypeInference::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::CoreML::KernelTypeInference::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::ODIE::Compiler::CoreML::AndOp>,mlir::OpTrait::OneResult<mlir::ODIE::Compiler::CoreML::AndOp>,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::ODIE::Compiler::CoreML::AndOp>,mlir::OpTrait::ZeroSuccessors<mlir::ODIE::Compiler::CoreML::AndOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::ODIE::Compiler::CoreML::AndOp>,mlir::OpTrait::OpInvariants<mlir::ODIE::Compiler::CoreML::AndOp>,mlir::ConditionallySpeculatable::Trait<mlir::ODIE::Compiler::CoreML::AndOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::ODIE::Compiler::CoreML::AndOp>,mlir::MemoryEffectOpInterface::Trait<mlir::ODIE::Compiler::CoreML::AndOp>,mlir::OpTrait::Elementwise<mlir::ODIE::Compiler::CoreML::AndOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::ODIE::Compiler::CoreML::AndOp>,mlir::ODIE::Compiler::CoreML::KernelTypeInference::Trait<mlir::ODIE::Compiler::CoreML::AndOp>,mlir::InferTypeOpInterface::Trait<mlir::ODIE::Compiler::CoreML::AndOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::OpTrait::SameOperandsAndResultType,mlir::ODIE::Compiler::CoreML::KernelTypeInference::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<7u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ODIE::Compiler::CoreML::KernelTypeInference::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<7u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<7u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<7u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<7u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<6u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ODIE::Compiler::CoreML::KernelTypeInference::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<6u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<6u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<6u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<6u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::ODIE::Compiler::CoreML::CallOp>,mlir::OpTrait::VariadicResults<mlir::ODIE::Compiler::CoreML::CallOp>,mlir::OpTrait::ZeroSuccessors<mlir::ODIE::Compiler::CoreML::CallOp>,mlir::OpTrait::VariadicOperands<mlir::ODIE::Compiler::CoreML::CallOp>,mlir::OpTrait::OpInvariants<mlir::ODIE::Compiler::CoreML::CallOp>,mlir::BytecodeOpInterface::Trait<mlir::ODIE::Compiler::CoreML::CallOp>,mlir::CallOpInterface::Trait<mlir::ODIE::Compiler::CoreML::CallOp>,mlir::SymbolUserOpInterface::Trait<mlir::ODIE::Compiler::CoreML::CallOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::SymbolUserOpInterface>();
    mlir::detail::TypeIDResolver<mlir::SymbolUserOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::ODIE::Compiler::CoreML::CallOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::CallOpInterface>();
    mlir::detail::TypeIDResolver<mlir::CallOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::CallOp::setCalleeFromCallable()
{
  {
    v0 = llvm::getTypeName<mlir::TypedAttr>();
    mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::SymbolUserOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::CallOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::CallOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::SymbolUserOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolUserOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::SymbolUserOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolUserOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::OneRegion<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::OpTrait::ZeroResults<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::OpTrait::ZeroSuccessors<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::OpTrait::ZeroOperands<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::OpTrait::NoRegionArguments<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::OpTrait::NoTerminator<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::OpTrait::SingleBlock<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::OpTrait::OpInvariants<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::BytecodeOpInterface::Trait<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::OpTrait::IsIsolatedFromAbove<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::OpTrait::SymbolTable<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::SymbolOpInterface::Trait<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::OpAsmOpInterface::Trait<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface::Trait<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::RegionKindInterface::Trait<mlir::ODIE::Compiler::CoreML::ClassOp>,mlir::OpTrait::HasOnlyGraphRegion<mlir::ODIE::Compiler::CoreML::ClassOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::OpAsmOpInterface>();
    mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::RegionKindInterface>();
    mlir::detail::TypeIDResolver<mlir::RegionKindInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::Compiler::CoreML::ClassOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::SymbolOpInterface>();
    mlir::detail::TypeIDResolver<mlir::SymbolOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::ODIE::Compiler::CoreML::detail::ParamScopeOpInterfaceInterfaceTraits::Model<mlir::ODIE::Compiler::CoreML::ClassOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpInterface<mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface,mlir::ODIE::Compiler::CoreML::detail::ParamScopeOpInterfaceInterfaceTraits>::getInterfaceFor()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::SymbolTable,mlir::SymbolOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NoRegionArguments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NoRegionArguments>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NoRegionArguments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NoRegionArguments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NoTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NoTerminator>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NoTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NoTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SymbolTable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SymbolTable>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SymbolTable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SymbolTable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::SymbolOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::SymbolOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::RegionKindInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionKindInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::RegionKindInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionKindInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasOnlyGraphRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasOnlyGraphRegion>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasOnlyGraphRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasOnlyGraphRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::ODIE::Compiler::CoreML::ConditionOp>,mlir::OpTrait::ZeroResults<mlir::ODIE::Compiler::CoreML::ConditionOp>,mlir::OpTrait::ZeroSuccessors<mlir::ODIE::Compiler::CoreML::ConditionOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::ODIE::Compiler::CoreML::ConditionOp>,mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::WhileOp>::Impl<mlir::ODIE::Compiler::CoreML::ConditionOp>,mlir::OpTrait::OpInvariants<mlir::ODIE::Compiler::CoreML::ConditionOp>,mlir::RegionBranchTerminatorOpInterface::Trait<mlir::ODIE::Compiler::CoreML::ConditionOp>,mlir::ConditionallySpeculatable::Trait<mlir::ODIE::Compiler::CoreML::ConditionOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::ODIE::Compiler::CoreML::ConditionOp>,mlir::MemoryEffectOpInterface::Trait<mlir::ODIE::Compiler::CoreML::ConditionOp>,mlir::OpTrait::IsTerminator<mlir::ODIE::Compiler::CoreML::ConditionOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchTerminatorOpInterface>();
    mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::WhileOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::WhileOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::WhileOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::WhileOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchTerminatorOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchTerminatorOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchTerminatorOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ODIE::Compiler::CoreML::TokenType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::InferTypeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::ODIE::Compiler::CoreML::TokenType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ODIE::Compiler::CoreML::TokenType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ODIE::Compiler::CoreML::TokenType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ODIE::Compiler::CoreML::TokenType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::ODIE::Compiler::CoreML::DelegateOp>,mlir::OpTrait::VariadicResults<mlir::ODIE::Compiler::CoreML::DelegateOp>,mlir::OpTrait::ZeroSuccessors<mlir::ODIE::Compiler::CoreML::DelegateOp>,mlir::OpTrait::VariadicOperands<mlir::ODIE::Compiler::CoreML::DelegateOp>,mlir::OpTrait::OpInvariants<mlir::ODIE::Compiler::CoreML::DelegateOp>,mlir::BytecodeOpInterface::Trait<mlir::ODIE::Compiler::CoreML::DelegateOp>,mlir::ConditionallySpeculatable::Trait<mlir::ODIE::Compiler::CoreML::DelegateOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::ODIE::Compiler::CoreML::DelegateOp>,mlir::MemoryEffectOpInterface::Trait<mlir::ODIE::Compiler::CoreML::DelegateOp>,mlir::ODIE::Compiler::CoreML::ConditionallyFoldable::Trait<mlir::ODIE::Compiler::CoreML::DelegateOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::ConditionallyFoldable>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ConditionallyFoldable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ODIE::Compiler::CoreML::ConditionallyFoldable::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::ConditionallyFoldable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::CoreML::ConditionallyFoldable::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ConditionallyFoldable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::CoreML::ConditionallyFoldable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::InferTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::SameOperandsAndResultShape,mlir::ODIE::Compiler::CoreML::KernelTypeInference::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SameOperandsElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsElementType>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsElementType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::RegisteredOperationName::Model<mlir::ODIE::Compiler::CoreML::ErrorOp>::Model()
{
  {
    v0 = llvm::getTypeName<mlir::BytecodeOpInterface>();
    mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::ODIE::Compiler::CoreML::FuncOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::CallableOpInterface>();
    mlir::detail::TypeIDResolver<mlir::CallableOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::ODIE::Compiler::CoreML::FuncOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::FunctionOpInterface>();
    mlir::detail::TypeIDResolver<mlir::FunctionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::CallableOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallableOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::CallableOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallableOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::FunctionOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::FunctionOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::FunctionOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::FunctionOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::OneRegion<mlir::ODIE::Compiler::CoreML::GraphOp>,mlir::OpTrait::ZeroResults<mlir::ODIE::Compiler::CoreML::GraphOp>,mlir::OpTrait::ZeroSuccessors<mlir::ODIE::Compiler::CoreML::GraphOp>,mlir::OpTrait::ZeroOperands<mlir::ODIE::Compiler::CoreML::GraphOp>,mlir::OpTrait::OpInvariants<mlir::ODIE::Compiler::CoreML::GraphOp>,mlir::BytecodeOpInterface::Trait<mlir::ODIE::Compiler::CoreML::GraphOp>,mlir::OpTrait::IsIsolatedFromAbove<mlir::ODIE::Compiler::CoreML::GraphOp>,mlir::SymbolOpInterface::Trait<mlir::ODIE::Compiler::CoreML::GraphOp>,mlir::CallableOpInterface::Trait<mlir::ODIE::Compiler::CoreML::GraphOp>,mlir::FunctionOpInterface::Trait<mlir::ODIE::Compiler::CoreML::GraphOp>,mlir::OpAsmOpInterface::Trait<mlir::ODIE::Compiler::CoreML::GraphOp>,mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface::Trait<mlir::ODIE::Compiler::CoreML::GraphOp>,mlir::ODIE::Compiler::CoreML::ImportableOpInterface::Trait<mlir::ODIE::Compiler::CoreML::GraphOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::ImportableOpInterface>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ImportableOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ODIE::Compiler::CoreML::ParamScopeOpInterface::Trait,mlir::ODIE::Compiler::CoreML::ImportableOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::ImportableOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::CoreML::ImportableOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ImportableOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::CoreML::ImportableOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::NRegions<2u>::Impl<mlir::ODIE::Compiler::CoreML::IfOp>,mlir::OpTrait::VariadicResults<mlir::ODIE::Compiler::CoreML::IfOp>,mlir::OpTrait::ZeroSuccessors<mlir::ODIE::Compiler::CoreML::IfOp>,mlir::OpTrait::OneOperand<mlir::ODIE::Compiler::CoreML::IfOp>,mlir::OpTrait::SingleBlock<mlir::ODIE::Compiler::CoreML::IfOp>,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::ODIE::Compiler::CoreML::YieldOp>::Impl<mlir::ODIE::Compiler::CoreML::IfOp>,mlir::OpTrait::NoRegionArguments<mlir::ODIE::Compiler::CoreML::IfOp>,mlir::OpTrait::OpInvariants<mlir::ODIE::Compiler::CoreML::IfOp>,mlir::RegionBranchOpInterface::Trait<mlir::ODIE::Compiler::CoreML::IfOp>,mlir::OpTrait::HasRecursiveMemoryEffects<mlir::ODIE::Compiler::CoreML::IfOp>>()
{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchOpInterface>();
    mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::ODIE::Compiler::CoreML::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NRegions<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NRegions<2u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NRegions<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NRegions<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::ODIE::Compiler::CoreML::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::ODIE::Compiler::CoreML::YieldOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::ODIE::Compiler::CoreML::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::ODIE::Compiler::CoreML::YieldOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchOpInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::ClassOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::ClassOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::ClassOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::ClassOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::ClassOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ODIE::Compiler::CoreML::KernelNotImplemented>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ODIE::Compiler::CoreML::KernelNotImplemented<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ODIE::Compiler::CoreML::KernelNotImplemented>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ODIE::Compiler::CoreML::KernelNotImplemented<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ODIE::Compiler::CoreML::KernelNotImplemented>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::GraphOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::GraphOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::GraphOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::GraphOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::GraphOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NResults<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NResults<2u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NResults<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NResults<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::FuncOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::FuncOp>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::FuncOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::ODIE::Compiler::CoreML::FuncOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ODIE::Compiler::CoreML::KernelTypeInference::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<4u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<4u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ODIE::Compiler::CoreML::KernelTypeInference::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::NOperands<5u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<5u>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<5u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<5u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::RegisteredOperationName::Model<mlir::ODIE::Compiler::CoreML::YieldOp>::Model()
{
  {
    v0 = llvm::getTypeName<mlir::RegionBranchTerminatorOpInterface>();
    mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::CastOp,mlir::Type &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.cast";
  *(a2 + 24) = 11;
}

void mlir::detail::InterfaceMap::get<mlir::ODIE::Compiler::KeywordPrintableAttr::Trait<mlir::ODIE::Compiler::CoreML::TorchLocationExtrasAttr>,mlir::ODIE::Compiler::ODIXSerializableAttr::Trait<mlir::ODIE::Compiler::CoreML::TorchLocationExtrasAttr>>()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::KeywordPrintableAttr>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::KeywordPrintableAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::ODIXSerializableAttr>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIXSerializableAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::storage_user_base_impl::hasTrait<mlir::ODIE::Compiler::KeywordPrintableAttr::Trait,mlir::ODIE::Compiler::ODIXSerializableAttr::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::KeywordPrintableAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::KeywordPrintableAttr::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::KeywordPrintableAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::KeywordPrintableAttr::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::ODIXSerializableAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::ODIXSerializableAttr::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIXSerializableAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::ODIXSerializableAttr::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::AbstractAttribute::get<mlir::ODIE::Compiler::CoreML::ExternAttr>()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::KeywordPrintableAttr>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::KeywordPrintableAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::AbstractAttribute::get<mlir::ODIE::Compiler::CoreML::TensorEncodingAttr>()
{
  {
    v0 = llvm::getTypeName<mlir::VerifiableTensorEncoding>();
    mlir::detail::TypeIDResolver<mlir::VerifiableTensorEncoding,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::StorageUserBase<mlir::ODIE::Compiler::CoreML::TensorEncodingAttr,mlir::Attribute,mlir::ODIE::Compiler::CoreML::detail::TensorEncodingAttrStorage,mlir::detail::AttributeUniquer,mlir::VerifiableTensorEncoding::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke()
{
  {
    v0 = llvm::getTypeName<mlir::VerifiableTensorEncoding::Trait<mlir::TypeID mlir::TypeID::get<mlir::VerifiableTensorEncoding::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::VerifiableTensorEncoding::Trait<mlir::TypeID mlir::TypeID::get<mlir::VerifiableTensorEncoding::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::ODIE::Compiler::detail::ParamAttrInterfaceInterfaceTraits::Model<mlir::ODIE::Compiler::CoreML::ParamDeclAttr>>()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::ParamAttrInterface>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ParamAttrInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::detail::storage_user_base_impl::hasTrait<mlir::TypedAttr::Trait,mlir::ODIE::Compiler::ParamAttrInterface::Trait>()
{
  {
    v0 = llvm::getTypeName<mlir::TypedAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::TypedAttr::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::TypedAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::TypedAttr::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::ParamAttrInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::ParamAttrInterface::Trait>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ParamAttrInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::Compiler::ParamAttrInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::AbstractAttribute::get<mlir::ODIE::Compiler::CoreML::ApproximateAttr>()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::ODIXSerializableAttr>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIXSerializableAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

uint64_t mlir::ODIE::Compiler::CoreML::YieldOp::getMutableSuccessorOperands@<X0>(uint64_t a1@<X8>)
{
  v1 = OUTLINED_FUNCTION_168(a1);
  if (v3 < 0)
  {
    v4 = *(v2 + 68);
  }

  else
  {
    v4 = 0;
  }

  return OUTLINED_FUNCTION_7_6(v1, v2, 0, v4);
}

uint64_t mlir::ODIE::Compiler::CoreML::WhileOp::getEntrySuccessorOperands(uint64_t a1)
{
  if ((*(*a1 + 46) & 0x80) != 0)
  {
    return *(*a1 + 72);
  }

  else
  {
    return 0;
  }
}

uint64_t mlir::ODIE::Compiler::CoreML::FuncOp::verifySufficientMatch(uint64_t a1)
{
  v235 = OUTLINED_FUNCTION_66_9(a1, *MEMORY[0x1E69E9840], v202, v213, v224, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);
  mlir::ODIE::Compiler::CoreML::CallOp::getCalleeAttr(&v236);
  OUTLINED_FUNCTION_24_6();
  if (v11 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ParamBindAttr,void>::id)
  {
    v12 = v10;
  }

  else
  {
    v12 = 0;
  }

  v225 = v12;
  if (v12)
  {
    mlir::ODIE::Compiler::CoreML::detail::ParamScopeOpInterfaceTrait<mlir::ODIE::Compiler::CoreML::FuncOp>::getAllParamDecls(&v237, &v238);
    OUTLINED_FUNCTION_84_7();
    OUTLINED_FUNCTION_89_8(v13, v14, v15, v16, v17, v18, v19, v20, v203, v214, v225, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);
    if (v289 == v1)
    {
      (*(*v289 + 32))(v289);
    }

    else if (v289)
    {
      (*(*v289 + 40))(v289);
    }

    v21 = mlir::AttrTypeReplacer::replace(&v264, v235);
    OUTLINED_FUNCTION_90_7(v21, v22, v23, v24, v25, v26, v27, v28, v204, v215, v226, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, __p, v268, v269, v270, v271, v272);
  }

  mlir::FunctionType::getInputs(&v235);
  OUTLINED_FUNCTION_103_5();
  if ((*(v236 + 46) & 0x80) != 0)
  {
    v29 = *(v236 + 72);
  }

  else
  {
    v29 = 0;
  }

  OUTLINED_FUNCTION_86_7(v29, v203, v214, 0, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);
  if (v2)
  {
    OUTLINED_FUNCTION_47_8();
    while (v30)
    {
      OUTLINED_FUNCTION_79_7();
      if (!v39)
      {
        OUTLINED_FUNCTION_70_6(v31, v32, v33, v34, v35, v36, v37, v38);
        if (v238)
        {
          OUTLINED_FUNCTION_98_5();
          OUTLINED_FUNCTION_20_13("expected an argument of type ");
          if (v60)
          {
            OUTLINED_FUNCTION_5_3();
            if (v178 <= v179 && (v180 & 1) != 0)
            {
              v200 = v179 - v178;
              OUTLINED_FUNCTION_45_4(v8 + 24);
              v58 = v241;
              v59 = (v241 + v200);
            }

            else
            {
              OUTLINED_FUNCTION_45_4(v8 + 24);
              OUTLINED_FUNCTION_61_6();
            }
          }

          OUTLINED_FUNCTION_7_19((v58 + 24 * v242), *v59);
          if (v238)
          {
            v61 = OUTLINED_FUNCTION_60_7();
            mlir::DiagnosticArgument::DiagnosticArgument(v61, v62);
            OUTLINED_FUNCTION_19_11();
            if (v60)
            {
              OUTLINED_FUNCTION_88_1();
              if (v185 <= v3 && (v184 & 1) != 0)
              {
                OUTLINED_FUNCTION_95_7();
                OUTLINED_FUNCTION_33_6();
                OUTLINED_FUNCTION_96_7();
              }

              else
              {
                OUTLINED_FUNCTION_33_6();
                v63 = v241;
              }
            }

            OUTLINED_FUNCTION_6_20(v63);
            OUTLINED_FUNCTION_39_8();
            if (v64)
            {
              OUTLINED_FUNCTION_49_9();
              v287 = " but got ";
              v288 = v65;
              OUTLINED_FUNCTION_38_13();
              if (v60)
              {
                OUTLINED_FUNCTION_13_4();
                if (v189 <= v190 && (v191 & 1) != 0)
                {
                  v3 = (v190 - v189);
                  OUTLINED_FUNCTION_44_8(v8 + 24, v188);
                  OUTLINED_FUNCTION_93_7();
                }

                else
                {
                  OUTLINED_FUNCTION_44_8(v8 + 24, v188);
                  OUTLINED_FUNCTION_59_5();
                }
              }

              OUTLINED_FUNCTION_7_19((v66 + 24 * v242), *v67);
              if (v238)
              {
                v68 = OUTLINED_FUNCTION_60_7();
                mlir::DiagnosticArgument::DiagnosticArgument(v68, v2);
                OUTLINED_FUNCTION_19_11();
                if (v60)
                {
                  OUTLINED_FUNCTION_88_1();
                  if (v197 <= v3 && (v196 & 1) != 0)
                  {
                    OUTLINED_FUNCTION_94_5();
                    OUTLINED_FUNCTION_33_6();
                    OUTLINED_FUNCTION_97_6();
                  }

                  else
                  {
                    OUTLINED_FUNCTION_33_6();
                    v69 = v241;
                  }
                }

                OUTLINED_FUNCTION_6_20(v69);
                OUTLINED_FUNCTION_16_15();
              }
            }
          }
        }

        OUTLINED_FUNCTION_116_6(v50, v51, v52, v53, v54, v55, v56, v57, v205, v216, v227, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);
        if (v238)
        {
          mlir::InFlightDiagnostic::report(&v238);
        }

        OUTLINED_FUNCTION_92_7();
        if (v39)
        {
          v77 = v261;
          if (v261 != v7)
          {
            free(v261);
          }

          v78 = v258;
          if (v258)
          {
            v79 = OUTLINED_FUNCTION_48_8(v77, v70, v71, v72, v73, v74, v75, v76, v207, v218, v229, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259);
            if (!v39)
            {
              do
              {
                v79 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v79 - 8));
              }

              while (v79 != v78);
              v80 = v258;
            }

            OUTLINED_FUNCTION_118_6(v80, v208, v219, v230, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259);
          }

          v81 = v255;
          if (v255)
          {
            v82 = OUTLINED_FUNCTION_58_4();
            if (!v39)
            {
              do
              {
                v83 = OUTLINED_FUNCTION_17_5();
                if (v83)
                {
                  operator delete[](v83);
                }
              }

              while (v3 != v81);
              v82 = v255;
            }

            v256 = v81;
            operator delete(v82);
          }

          v84 = OUTLINED_FUNCTION_114_3(v77, v70, v71, v72, v73, v74, v75, v76, v207, v218, v229, v235, v236, v237, v238, v239, v240, v241);
          if (!v39)
          {
            free(v84);
          }
        }

        OUTLINED_FUNCTION_113_6();
        mlir::Diagnostic::attachNote((v6 + 8), v85, 1);
        OUTLINED_FUNCTION_26_14();
        OUTLINED_FUNCTION_25_13();
        if (v60)
        {
          OUTLINED_FUNCTION_5_3();
          if (v168 <= v170 && (v169 & 1) != 0)
          {
            v3 = &v238 - v168;
            OUTLINED_FUNCTION_34_12();
            OUTLINED_FUNCTION_108_6();
          }

          else
          {
            OUTLINED_FUNCTION_34_12();
            OUTLINED_FUNCTION_111_5();
          }
        }

        OUTLINED_FUNCTION_0_3(v86);
        OUTLINED_FUNCTION_24_15();
        OUTLINED_FUNCTION_72_5(v87, v88, v89, v90, v91, v92);
        OUTLINED_FUNCTION_57_5();
        if (v60)
        {
          OUTLINED_FUNCTION_88_1();
          if (v171 <= v3 && (v172 & 1) != 0)
          {
            v3 = &v238 - v171;
            OUTLINED_FUNCTION_35_12();
            OUTLINED_FUNCTION_110_3();
          }

          else
          {
            OUTLINED_FUNCTION_35_12();
            OUTLINED_FUNCTION_109_6();
          }
        }

        OUTLINED_FUNCTION_6_20(v93);
        OUTLINED_FUNCTION_24_15();
        mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v264);
        OUTLINED_FUNCTION_107_5();
        if (v94)
        {
          mlir::InFlightDiagnostic::report(&v264);
        }

        OUTLINED_FUNCTION_106_4();
        if (v39)
        {
          v102 = v286;
          if (v286 != v5)
          {
            free(v286);
          }

          v103 = v284;
          if (v284)
          {
            v104 = OUTLINED_FUNCTION_56_8(v102, v95, v96, v97, v98, v99, v100, v101, v207, v218, v229, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, __p, v268, v269, v270, v271, v272, v273, v274, v275, v276, v277, v278, v279, v280, v281, v282, v283, v284, v285);
            if (!v39)
            {
              do
              {
                v104 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v104 - 8));
              }

              while (v104 != v103);
              v105 = v284;
            }

            OUTLINED_FUNCTION_117_5(v105, v209, v220, v231, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, __p, v268, v269, v270, v271, v272, v273, v274, v275, v276, v277, v278, v279, v280, v281, v282, v283, v284, v285);
          }

          v106 = v281;
          if (v281)
          {
            v107 = OUTLINED_FUNCTION_55_8();
            if (!v39)
            {
              do
              {
                v108 = OUTLINED_FUNCTION_17_5();
                if (v108)
                {
                  operator delete[](v108);
                }
              }

              while (v3 != v106);
              v107 = v281;
            }

            v282 = v106;
            operator delete(v107);
          }

          v109 = __p;
          if (__p != v4)
          {
LABEL_128:
            free(v109);
          }
        }

        return v1;
      }

      OUTLINED_FUNCTION_101_7();
      if (v39)
      {
        break;
      }
    }
  }

  mlir::FunctionType::getResults(&v235);
  OUTLINED_FUNCTION_103_5();
  OUTLINED_FUNCTION_16_4();
  OUTLINED_FUNCTION_87_7(v40, v205, v216, v227, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);
  if (v2)
  {
    OUTLINED_FUNCTION_62_6();
    while (v9 != v5)
    {
      mlir::detail::OpResultImpl::getNextResultAtOffset(v4, v5);
      OUTLINED_FUNCTION_99_7();
      if (!v39)
      {
        OUTLINED_FUNCTION_70_6(v41, v42, v43, v44, v45, v46, v47, v48);
        if (v238)
        {
          OUTLINED_FUNCTION_98_5();
          OUTLINED_FUNCTION_20_13("expected a result of type ");
          if (v60)
          {
            OUTLINED_FUNCTION_5_3();
            if (v181 <= v182 && (v183 & 1) != 0)
            {
              v201 = v182 - v181;
              OUTLINED_FUNCTION_45_4(v6 + 24);
              v118 = v241;
              v119 = (v241 + v201);
            }

            else
            {
              OUTLINED_FUNCTION_45_4(v6 + 24);
              OUTLINED_FUNCTION_61_6();
            }
          }

          OUTLINED_FUNCTION_7_19((v118 + 24 * v242), *v119);
          if (v238)
          {
            v120 = OUTLINED_FUNCTION_60_7();
            mlir::DiagnosticArgument::DiagnosticArgument(v120, v121);
            OUTLINED_FUNCTION_19_11();
            if (v60)
            {
              OUTLINED_FUNCTION_88_1();
              if (v187 <= v3 && (v186 & 1) != 0)
              {
                OUTLINED_FUNCTION_95_7();
                OUTLINED_FUNCTION_46_1();
                OUTLINED_FUNCTION_96_7();
              }

              else
              {
                OUTLINED_FUNCTION_46_1();
                v122 = v241;
              }
            }

            OUTLINED_FUNCTION_6_20(v122);
            OUTLINED_FUNCTION_39_8();
            if (v123)
            {
              OUTLINED_FUNCTION_49_9();
              v287 = " but got ";
              v288 = v124;
              OUTLINED_FUNCTION_38_13();
              if (v60)
              {
                OUTLINED_FUNCTION_13_4();
                if (v193 <= v194 && (v195 & 1) != 0)
                {
                  v3 = (v194 - v193);
                  OUTLINED_FUNCTION_44_8(v6 + 24, v192);
                  OUTLINED_FUNCTION_93_7();
                }

                else
                {
                  OUTLINED_FUNCTION_44_8(v6 + 24, v192);
                  OUTLINED_FUNCTION_59_5();
                }
              }

              OUTLINED_FUNCTION_7_19((v125 + 24 * v242), *v126);
              if (v238)
              {
                v127 = OUTLINED_FUNCTION_60_7();
                mlir::DiagnosticArgument::DiagnosticArgument(v127, v2);
                OUTLINED_FUNCTION_19_11();
                if (v60)
                {
                  OUTLINED_FUNCTION_88_1();
                  if (v199 <= v3 && (v198 & 1) != 0)
                  {
                    OUTLINED_FUNCTION_94_5();
                    OUTLINED_FUNCTION_46_1();
                    OUTLINED_FUNCTION_97_6();
                  }

                  else
                  {
                    OUTLINED_FUNCTION_46_1();
                    v128 = v241;
                  }
                }

                OUTLINED_FUNCTION_6_20(v128);
                OUTLINED_FUNCTION_16_15();
              }
            }
          }
        }

        OUTLINED_FUNCTION_116_6(v110, v111, v112, v113, v114, v115, v116, v117, v206, v217, v228, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);
        if (v238)
        {
          mlir::InFlightDiagnostic::report(&v238);
        }

        OUTLINED_FUNCTION_92_7();
        if (v39)
        {
          v136 = v261;
          if (v261 != " but got ")
          {
            free(v261);
          }

          v137 = v258;
          if (v258)
          {
            v138 = OUTLINED_FUNCTION_48_8(v136, v129, v130, v131, v132, v133, v134, v135, v210, v221, v232, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259);
            if (!v39)
            {
              do
              {
                v138 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v138 - 8));
              }

              while (v138 != v137);
              v139 = v258;
            }

            OUTLINED_FUNCTION_118_6(v139, v211, v222, v233, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259);
          }

          v140 = v255;
          if (v255)
          {
            v141 = OUTLINED_FUNCTION_58_4();
            if (!v39)
            {
              do
              {
                v142 = OUTLINED_FUNCTION_17_5();
                if (v142)
                {
                  operator delete[](v142);
                }
              }

              while (v3 != v140);
              v141 = v255;
            }

            v256 = v140;
            operator delete(v141);
          }

          v143 = OUTLINED_FUNCTION_114_3(v136, v129, v130, v131, v132, v133, v134, v135, v210, v221, v232, v235, v236, v237, v238, v239, v240, v241);
          if (!v39)
          {
            free(v143);
          }
        }

        OUTLINED_FUNCTION_113_6();
        mlir::Diagnostic::attachNote((v8 + 8), v144, 1);
        OUTLINED_FUNCTION_26_14();
        OUTLINED_FUNCTION_25_13();
        if (v60)
        {
          OUTLINED_FUNCTION_5_3();
          if (v173 <= v175 && (v174 & 1) != 0)
          {
            v3 = &v238 - v173;
            OUTLINED_FUNCTION_34_12();
            OUTLINED_FUNCTION_108_6();
          }

          else
          {
            OUTLINED_FUNCTION_34_12();
            OUTLINED_FUNCTION_111_5();
          }
        }

        OUTLINED_FUNCTION_0_3(v145);
        OUTLINED_FUNCTION_24_15();
        OUTLINED_FUNCTION_72_5(v146, v147, v148, v149, v150, v151);
        OUTLINED_FUNCTION_57_5();
        if (v60)
        {
          OUTLINED_FUNCTION_88_1();
          if (v176 <= v3 && (v177 & 1) != 0)
          {
            v3 = &v238 - v176;
            OUTLINED_FUNCTION_35_12();
            OUTLINED_FUNCTION_110_3();
          }

          else
          {
            OUTLINED_FUNCTION_35_12();
            OUTLINED_FUNCTION_109_6();
          }
        }

        OUTLINED_FUNCTION_6_20(v152);
        OUTLINED_FUNCTION_24_15();
        mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v264);
        OUTLINED_FUNCTION_107_5();
        if (v153)
        {
          mlir::InFlightDiagnostic::report(&v264);
        }

        OUTLINED_FUNCTION_106_4();
        if (!v39)
        {
          return v1;
        }

        v161 = v286;
        if (v286 != v210)
        {
          free(v286);
        }

        v162 = v284;
        if (v284)
        {
          v163 = OUTLINED_FUNCTION_56_8(v161, v154, v155, v156, v157, v158, v159, v160, v210, v221, v232, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, __p, v268, v269, v270, v271, v272, v273, v274, v275, v276, v277, v278, v279, v280, v281, v282, v283, v284, v285);
          if (!v39)
          {
            do
            {
              v163 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v163 - 8));
            }

            while (v163 != v162);
            v164 = v284;
          }

          OUTLINED_FUNCTION_117_5(v164, v212, v223, v234, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, __p, v268, v269, v270, v271, v272, v273, v274, v275, v276, v277, v278, v279, v280, v281, v282, v283, v284, v285);
        }

        v165 = v281;
        if (v281)
        {
          v166 = OUTLINED_FUNCTION_55_8();
          if (!v39)
          {
            do
            {
              v167 = OUTLINED_FUNCTION_17_5();
              if (v167)
              {
                operator delete[](v167);
              }
            }

            while (v3 != v165);
            v166 = v281;
          }

          v282 = v165;
          operator delete(v166);
        }

        v109 = __p;
        if (__p == v221)
        {
          return v1;
        }

        goto LABEL_128;
      }

      v3 += 8;
      ++v5;
      v7 -= 8;
      if (!v7)
      {
        return 1;
      }
    }
  }

  return 1;
}

uint64_t mlir::ODIE::Compiler::CoreML::GraphOp::verifySufficientMatch(uint64_t a1)
{
  v235 = OUTLINED_FUNCTION_66_9(a1, *MEMORY[0x1E69E9840], v202, v213, v224, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);
  mlir::ODIE::Compiler::CoreML::CallOp::getCalleeAttr(&v236);
  OUTLINED_FUNCTION_24_6();
  if (v11 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ParamBindAttr,void>::id)
  {
    v12 = v10;
  }

  else
  {
    v12 = 0;
  }

  v225 = v12;
  if (v12)
  {
    mlir::ODIE::Compiler::CoreML::detail::ParamScopeOpInterfaceTrait<mlir::ODIE::Compiler::CoreML::FuncOp>::getAllParamDecls(&v237, &v238);
    OUTLINED_FUNCTION_84_7();
    OUTLINED_FUNCTION_89_8(v13, v14, v15, v16, v17, v18, v19, v20, v203, v214, v225, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);
    if (v289 == v1)
    {
      (*(*v289 + 32))(v289);
    }

    else if (v289)
    {
      (*(*v289 + 40))(v289);
    }

    v21 = mlir::AttrTypeReplacer::replace(&v264, v235);
    OUTLINED_FUNCTION_90_7(v21, v22, v23, v24, v25, v26, v27, v28, v204, v215, v226, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, __p, v268, v269, v270, v271, v272);
  }

  mlir::FunctionType::getInputs(&v235);
  OUTLINED_FUNCTION_103_5();
  if ((*(v236 + 46) & 0x80) != 0)
  {
    v29 = *(v236 + 72);
  }

  else
  {
    v29 = 0;
  }

  OUTLINED_FUNCTION_86_7(v29, v203, v214, 0, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);
  if (v2)
  {
    OUTLINED_FUNCTION_47_8();
    while (v30)
    {
      OUTLINED_FUNCTION_79_7();
      if (!v39)
      {
        OUTLINED_FUNCTION_70_6(v31, v32, v33, v34, v35, v36, v37, v38);
        if (v238)
        {
          OUTLINED_FUNCTION_98_5();
          OUTLINED_FUNCTION_20_13("expected an argument of type ");
          if (v60)
          {
            OUTLINED_FUNCTION_5_3();
            if (v178 <= v179 && (v180 & 1) != 0)
            {
              v200 = v179 - v178;
              OUTLINED_FUNCTION_45_4(v8 + 24);
              v58 = v241;
              v59 = (v241 + v200);
            }

            else
            {
              OUTLINED_FUNCTION_45_4(v8 + 24);
              OUTLINED_FUNCTION_61_6();
            }
          }

          OUTLINED_FUNCTION_7_19((v58 + 24 * v242), *v59);
          if (v238)
          {
            v61 = OUTLINED_FUNCTION_60_7();
            mlir::DiagnosticArgument::DiagnosticArgument(v61, v62);
            OUTLINED_FUNCTION_19_11();
            if (v60)
            {
              OUTLINED_FUNCTION_88_1();
              if (v185 <= v3 && (v184 & 1) != 0)
              {
                OUTLINED_FUNCTION_95_7();
                OUTLINED_FUNCTION_33_6();
                OUTLINED_FUNCTION_96_7();
              }

              else
              {
                OUTLINED_FUNCTION_33_6();
                v63 = v241;
              }
            }

            OUTLINED_FUNCTION_6_20(v63);
            OUTLINED_FUNCTION_39_8();
            if (v64)
            {
              OUTLINED_FUNCTION_49_9();
              v287 = " but got ";
              v288 = v65;
              OUTLINED_FUNCTION_38_13();
              if (v60)
              {
                OUTLINED_FUNCTION_13_4();
                if (v189 <= v190 && (v191 & 1) != 0)
                {
                  v3 = (v190 - v189);
                  OUTLINED_FUNCTION_44_8(v8 + 24, v188);
                  OUTLINED_FUNCTION_93_7();
                }

                else
                {
                  OUTLINED_FUNCTION_44_8(v8 + 24, v188);
                  OUTLINED_FUNCTION_59_5();
                }
              }

              OUTLINED_FUNCTION_7_19((v66 + 24 * v242), *v67);
              if (v238)
              {
                v68 = OUTLINED_FUNCTION_60_7();
                mlir::DiagnosticArgument::DiagnosticArgument(v68, v2);
                OUTLINED_FUNCTION_19_11();
                if (v60)
                {
                  OUTLINED_FUNCTION_88_1();
                  if (v197 <= v3 && (v196 & 1) != 0)
                  {
                    OUTLINED_FUNCTION_94_5();
                    OUTLINED_FUNCTION_33_6();
                    OUTLINED_FUNCTION_97_6();
                  }

                  else
                  {
                    OUTLINED_FUNCTION_33_6();
                    v69 = v241;
                  }
                }

                OUTLINED_FUNCTION_6_20(v69);
                OUTLINED_FUNCTION_16_15();
              }
            }
          }
        }

        OUTLINED_FUNCTION_116_6(v50, v51, v52, v53, v54, v55, v56, v57, v205, v216, v227, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);
        if (v238)
        {
          mlir::InFlightDiagnostic::report(&v238);
        }

        OUTLINED_FUNCTION_92_7();
        if (v39)
        {
          v77 = v261;
          if (v261 != v7)
          {
            free(v261);
          }

          v78 = v258;
          if (v258)
          {
            v79 = OUTLINED_FUNCTION_48_8(v77, v70, v71, v72, v73, v74, v75, v76, v207, v218, v229, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259);
            if (!v39)
            {
              do
              {
                v79 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v79 - 8));
              }

              while (v79 != v78);
              v80 = v258;
            }

            OUTLINED_FUNCTION_118_6(v80, v208, v219, v230, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259);
          }

          v81 = v255;
          if (v255)
          {
            v82 = OUTLINED_FUNCTION_58_4();
            if (!v39)
            {
              do
              {
                v83 = OUTLINED_FUNCTION_17_5();
                if (v83)
                {
                  operator delete[](v83);
                }
              }

              while (v3 != v81);
              v82 = v255;
            }

            v256 = v81;
            operator delete(v82);
          }

          v84 = OUTLINED_FUNCTION_114_3(v77, v70, v71, v72, v73, v74, v75, v76, v207, v218, v229, v235, v236, v237, v238, v239, v240, v241);
          if (!v39)
          {
            free(v84);
          }
        }

        OUTLINED_FUNCTION_113_6();
        mlir::Diagnostic::attachNote((v6 + 8), v85, 1);
        OUTLINED_FUNCTION_26_14();
        OUTLINED_FUNCTION_25_13();
        if (v60)
        {
          OUTLINED_FUNCTION_5_3();
          if (v168 <= v170 && (v169 & 1) != 0)
          {
            v3 = &v238 - v168;
            OUTLINED_FUNCTION_34_12();
            OUTLINED_FUNCTION_108_6();
          }

          else
          {
            OUTLINED_FUNCTION_34_12();
            OUTLINED_FUNCTION_111_5();
          }
        }

        OUTLINED_FUNCTION_0_3(v86);
        OUTLINED_FUNCTION_24_15();
        OUTLINED_FUNCTION_72_5(v87, v88, v89, v90, v91, v92);
        OUTLINED_FUNCTION_57_5();
        if (v60)
        {
          OUTLINED_FUNCTION_88_1();
          if (v171 <= v3 && (v172 & 1) != 0)
          {
            v3 = &v238 - v171;
            OUTLINED_FUNCTION_35_12();
            OUTLINED_FUNCTION_110_3();
          }

          else
          {
            OUTLINED_FUNCTION_35_12();
            OUTLINED_FUNCTION_109_6();
          }
        }

        OUTLINED_FUNCTION_6_20(v93);
        OUTLINED_FUNCTION_24_15();
        mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v264);
        OUTLINED_FUNCTION_107_5();
        if (v94)
        {
          mlir::InFlightDiagnostic::report(&v264);
        }

        OUTLINED_FUNCTION_106_4();
        if (v39)
        {
          v102 = v286;
          if (v286 != v5)
          {
            free(v286);
          }

          v103 = v284;
          if (v284)
          {
            v104 = OUTLINED_FUNCTION_56_8(v102, v95, v96, v97, v98, v99, v100, v101, v207, v218, v229, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, __p, v268, v269, v270, v271, v272, v273, v274, v275, v276, v277, v278, v279, v280, v281, v282, v283, v284, v285);
            if (!v39)
            {
              do
              {
                v104 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v104 - 8));
              }

              while (v104 != v103);
              v105 = v284;
            }

            OUTLINED_FUNCTION_117_5(v105, v209, v220, v231, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, __p, v268, v269, v270, v271, v272, v273, v274, v275, v276, v277, v278, v279, v280, v281, v282, v283, v284, v285);
          }

          v106 = v281;
          if (v281)
          {
            v107 = OUTLINED_FUNCTION_55_8();
            if (!v39)
            {
              do
              {
                v108 = OUTLINED_FUNCTION_17_5();
                if (v108)
                {
                  operator delete[](v108);
                }
              }

              while (v3 != v106);
              v107 = v281;
            }

            v282 = v106;
            operator delete(v107);
          }

          v109 = __p;
          if (__p != v4)
          {
LABEL_128:
            free(v109);
          }
        }

        return v1;
      }

      OUTLINED_FUNCTION_101_7();
      if (v39)
      {
        break;
      }
    }
  }

  mlir::FunctionType::getResults(&v235);
  OUTLINED_FUNCTION_103_5();
  OUTLINED_FUNCTION_16_4();
  OUTLINED_FUNCTION_87_7(v40, v205, v216, v227, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);
  if (v2)
  {
    OUTLINED_FUNCTION_62_6();
    while (v9 != v5)
    {
      mlir::detail::OpResultImpl::getNextResultAtOffset(v4, v5);
      OUTLINED_FUNCTION_99_7();
      if (!v39)
      {
        OUTLINED_FUNCTION_70_6(v41, v42, v43, v44, v45, v46, v47, v48);
        if (v238)
        {
          OUTLINED_FUNCTION_98_5();
          OUTLINED_FUNCTION_20_13("expected a result of type ");
          if (v60)
          {
            OUTLINED_FUNCTION_5_3();
            if (v181 <= v182 && (v183 & 1) != 0)
            {
              v201 = v182 - v181;
              OUTLINED_FUNCTION_45_4(v6 + 24);
              v118 = v241;
              v119 = (v241 + v201);
            }

            else
            {
              OUTLINED_FUNCTION_45_4(v6 + 24);
              OUTLINED_FUNCTION_61_6();
            }
          }

          OUTLINED_FUNCTION_7_19((v118 + 24 * v242), *v119);
          if (v238)
          {
            v120 = OUTLINED_FUNCTION_60_7();
            mlir::DiagnosticArgument::DiagnosticArgument(v120, v121);
            OUTLINED_FUNCTION_19_11();
            if (v60)
            {
              OUTLINED_FUNCTION_88_1();
              if (v187 <= v3 && (v186 & 1) != 0)
              {
                OUTLINED_FUNCTION_95_7();
                OUTLINED_FUNCTION_46_1();
                OUTLINED_FUNCTION_96_7();
              }

              else
              {
                OUTLINED_FUNCTION_46_1();
                v122 = v241;
              }
            }

            OUTLINED_FUNCTION_6_20(v122);
            OUTLINED_FUNCTION_39_8();
            if (v123)
            {
              OUTLINED_FUNCTION_49_9();
              v287 = " but got ";
              v288 = v124;
              OUTLINED_FUNCTION_38_13();
              if (v60)
              {
                OUTLINED_FUNCTION_13_4();
                if (v193 <= v194 && (v195 & 1) != 0)
                {
                  v3 = (v194 - v193);
                  OUTLINED_FUNCTION_44_8(v6 + 24, v192);
                  OUTLINED_FUNCTION_93_7();
                }

                else
                {
                  OUTLINED_FUNCTION_44_8(v6 + 24, v192);
                  OUTLINED_FUNCTION_59_5();
                }
              }

              OUTLINED_FUNCTION_7_19((v125 + 24 * v242), *v126);
              if (v238)
              {
                v127 = OUTLINED_FUNCTION_60_7();
                mlir::DiagnosticArgument::DiagnosticArgument(v127, v2);
                OUTLINED_FUNCTION_19_11();
                if (v60)
                {
                  OUTLINED_FUNCTION_88_1();
                  if (v199 <= v3 && (v198 & 1) != 0)
                  {
                    OUTLINED_FUNCTION_94_5();
                    OUTLINED_FUNCTION_46_1();
                    OUTLINED_FUNCTION_97_6();
                  }

                  else
                  {
                    OUTLINED_FUNCTION_46_1();
                    v128 = v241;
                  }
                }

                OUTLINED_FUNCTION_6_20(v128);
                OUTLINED_FUNCTION_16_15();
              }
            }
          }
        }

        OUTLINED_FUNCTION_116_6(v110, v111, v112, v113, v114, v115, v116, v117, v206, v217, v228, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);
        if (v238)
        {
          mlir::InFlightDiagnostic::report(&v238);
        }

        OUTLINED_FUNCTION_92_7();
        if (v39)
        {
          v136 = v261;
          if (v261 != " but got ")
          {
            free(v261);
          }

          v137 = v258;
          if (v258)
          {
            v138 = OUTLINED_FUNCTION_48_8(v136, v129, v130, v131, v132, v133, v134, v135, v210, v221, v232, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259);
            if (!v39)
            {
              do
              {
                v138 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v138 - 8));
              }

              while (v138 != v137);
              v139 = v258;
            }

            OUTLINED_FUNCTION_118_6(v139, v211, v222, v233, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259);
          }

          v140 = v255;
          if (v255)
          {
            v141 = OUTLINED_FUNCTION_58_4();
            if (!v39)
            {
              do
              {
                v142 = OUTLINED_FUNCTION_17_5();
                if (v142)
                {
                  operator delete[](v142);
                }
              }

              while (v3 != v140);
              v141 = v255;
            }

            v256 = v140;
            operator delete(v141);
          }

          v143 = OUTLINED_FUNCTION_114_3(v136, v129, v130, v131, v132, v133, v134, v135, v210, v221, v232, v235, v236, v237, v238, v239, v240, v241);
          if (!v39)
          {
            free(v143);
          }
        }

        OUTLINED_FUNCTION_113_6();
        mlir::Diagnostic::attachNote((v8 + 8), v144, 1);
        OUTLINED_FUNCTION_26_14();
        OUTLINED_FUNCTION_25_13();
        if (v60)
        {
          OUTLINED_FUNCTION_5_3();
          if (v173 <= v175 && (v174 & 1) != 0)
          {
            v3 = &v238 - v173;
            OUTLINED_FUNCTION_34_12();
            OUTLINED_FUNCTION_108_6();
          }

          else
          {
            OUTLINED_FUNCTION_34_12();
            OUTLINED_FUNCTION_111_5();
          }
        }

        OUTLINED_FUNCTION_0_3(v145);
        OUTLINED_FUNCTION_24_15();
        OUTLINED_FUNCTION_72_5(v146, v147, v148, v149, v150, v151);
        OUTLINED_FUNCTION_57_5();
        if (v60)
        {
          OUTLINED_FUNCTION_88_1();
          if (v176 <= v3 && (v177 & 1) != 0)
          {
            v3 = &v238 - v176;
            OUTLINED_FUNCTION_35_12();
            OUTLINED_FUNCTION_110_3();
          }

          else
          {
            OUTLINED_FUNCTION_35_12();
            OUTLINED_FUNCTION_109_6();
          }
        }

        OUTLINED_FUNCTION_6_20(v152);
        OUTLINED_FUNCTION_24_15();
        mlir::InFlightDiagnostic::operator llvm::LogicalResult(&v264);
        OUTLINED_FUNCTION_107_5();
        if (v153)
        {
          mlir::InFlightDiagnostic::report(&v264);
        }

        OUTLINED_FUNCTION_106_4();
        if (!v39)
        {
          return v1;
        }

        v161 = v286;
        if (v286 != v210)
        {
          free(v286);
        }

        v162 = v284;
        if (v284)
        {
          v163 = OUTLINED_FUNCTION_56_8(v161, v154, v155, v156, v157, v158, v159, v160, v210, v221, v232, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, __p, v268, v269, v270, v271, v272, v273, v274, v275, v276, v277, v278, v279, v280, v281, v282, v283, v284, v285);
          if (!v39)
          {
            do
            {
              v163 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100]((v163 - 8));
            }

            while (v163 != v162);
            v164 = v284;
          }

          OUTLINED_FUNCTION_117_5(v164, v212, v223, v234, v235, v236, v237, v238, v239, v240, v241, v242, v243, v244, v245, v246, v247, v248, v249, v250, v251, v252, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, __p, v268, v269, v270, v271, v272, v273, v274, v275, v276, v277, v278, v279, v280, v281, v282, v283, v284, v285);
        }

        v165 = v281;
        if (v281)
        {
          v166 = OUTLINED_FUNCTION_55_8();
          if (!v39)
          {
            do
            {
              v167 = OUTLINED_FUNCTION_17_5();
              if (v167)
              {
                operator delete[](v167);
              }
            }

            while (v3 != v165);
            v166 = v281;
          }

          v282 = v165;
          operator delete(v166);
        }

        v109 = __p;
        if (__p == v221)
        {
          return v1;
        }

        goto LABEL_128;
      }

      v3 += 8;
      ++v5;
      v7 -= 8;
      if (!v7)
      {
        return 1;
      }
    }
  }

  return 1;
}

llvm::raw_ostream *mlir::ODIE::Compiler::CoreML::CallOp::print(mlir::ODIE::Compiler::CoreML::CallOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v50[2] = *MEMORY[0x1E69E9840];
  (*(*v6 + 16))(v6);
  OUTLINED_FUNCTION_17_2();
  if (v9)
  {
    llvm::raw_ostream::write(v7, " ", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v7, v8);
  }

  mlir::ODIE::Compiler::CoreML::CallOp::getCalleeAttr(v3);
  OUTLINED_FUNCTION_24_6();
  if (v11 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ParamConstantAttr,void>::id)
  {
    v12 = v10;
  }

  else
  {
    v12 = 0;
  }

  v50[0] = v12;
  if (v12)
  {
    Value = mlir::AffineMapAttr::getValue(v50);
LABEL_9:
    (*(*v2 + 40))(v2, Value);
    goto LABEL_10;
  }

  Value = v10;
  if (!v10 || v11 != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ParamBindAttr,void>::id)
  {
    goto LABEL_9;
  }

  mlir::ODIE::Compiler::CoreML::prettyPrintBindAttr(v2, v10);
LABEL_10:
  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v9)
  {
    llvm::raw_ostream::write(v14, "(", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v14, v15);
  }

  OUTLINED_FUNCTION_47_0();
  if (v16 < 0)
  {
    OUTLINED_FUNCTION_177_0();
  }

  else
  {
    OUTLINED_FUNCTION_99_3();
  }

  (*(*v2 + 16))(v2);
  if (v5)
  {
    OUTLINED_FUNCTION_17_10();
    (*(v17 + 160))(v2);
    v18 = v5 - 1;
    if (v18)
    {
      v19 = v4 + 56;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v9 & v21)
        {
          OUTLINED_FUNCTION_21_5(v20);
        }

        else
        {
          OUTLINED_FUNCTION_42_0();
        }

        v19 += 32;
        OUTLINED_FUNCTION_104();
        (*(v22 + 160))(v2);
        --v18;
      }

      while (v18);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_4_3();
  if (!v9 & v21)
  {
    *v24 = 8233;
    OUTLINED_FUNCTION_24_2(v23);
  }

  else
  {
    llvm::raw_ostream::write(v23, ") ", 2uLL);
  }

  AttrDictionary = mlir::Operation::getAttrDictionary(*v3);
  v33 = OUTLINED_FUNCTION_81_2(AttrDictionary, v26, v27, v28, v29, v30, v31, v32, v48, v50[0]);
  v50[0] = OUTLINED_FUNCTION_69_8(v33, v34, v35, v36, v37, v38, v39, v40, v49);
  v50[1] = v41;
  OUTLINED_FUNCTION_104();
  v42 = OUTLINED_FUNCTION_76_8();
  v43(v42);
  OUTLINED_FUNCTION_104();
  v45 = (*(v44 + 16))(v2);
  v46 = v45[4];
  if ((v45[3] - v46) > 2)
  {
    OUTLINED_FUNCTION_67_7(v45, v46);
  }

  else
  {
    llvm::raw_ostream::write(v45, " : ", 3uLL);
  }

  return mlir::OpAsmPrinter::printFunctionalType(v2, *v3);
}

void mlir::ODIE::Compiler::CoreML::OutputOp::print(mlir::ODIE::Compiler::CoreML::OutputOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v54 = *MEMORY[0x1E69E9840];
  v7 = *v6;
  if ((*(v7 + 46) & 0x80) != 0 && *(v7 + 68))
  {
    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v10)
    {
      llvm::raw_ostream::write(v8, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v8, v9);
    }

    OUTLINED_FUNCTION_47_0();
    if (v11 < 0)
    {
      OUTLINED_FUNCTION_177_0();
    }

    else
    {
      OUTLINED_FUNCTION_99_3();
    }

    (*(*v2 + 16))(v2);
    if (v5)
    {
      OUTLINED_FUNCTION_17_10();
      (*(v12 + 160))(v2);
      v13 = v5 - 1;
      if (v13)
      {
        v14 = v4 + 56;
        do
        {
          OUTLINED_FUNCTION_30_2();
          if (!v16 & v10)
          {
            OUTLINED_FUNCTION_21_5(v15);
          }

          else
          {
            OUTLINED_FUNCTION_42_0();
          }

          v14 += 32;
          OUTLINED_FUNCTION_104();
          (*(v17 + 160))(v2);
          --v13;
        }

        while (v13);
      }
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v10)
    {
      llvm::raw_ostream::write(v18, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v18, v19);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_17_2();
    if (v16)
    {
      llvm::raw_ostream::write(v20, ":", 1uLL);
    }

    else
    {
      OUTLINED_FUNCTION_4_1(v20, v21);
    }

    (*(*v2 + 16))(v2);
    OUTLINED_FUNCTION_13_3();
    if (v10)
    {
      llvm::raw_ostream::write(v22, 32);
    }

    else
    {
      OUTLINED_FUNCTION_5_2(v22, v23);
    }

    OUTLINED_FUNCTION_90_2();
    if (v24 < 0)
    {
      OUTLINED_FUNCTION_89_2();
    }

    else
    {
      OUTLINED_FUNCTION_84_2();
    }

    v49[0] = v26;
    v49[1] = v25;
    mlir::OperandRange::getTypes(v49, &v50);
    v27 = v51;
    v28 = v53;
    if (v51 != v53)
    {
      v29 = v50 + 32 * v51;
      OUTLINED_FUNCTION_104();
      v30 = OUTLINED_FUNCTION_12_4();
      v31(v30);
      if (v27 + 1 != v28)
      {
        v32 = ~v27 + v28;
        v33 = v29 + 56;
        do
        {
          (*(*v2 + 16))(v2);
          OUTLINED_FUNCTION_4_3();
          if (!v16 & v10)
          {
            *v35 = 8236;
            OUTLINED_FUNCTION_24_2(v34);
          }

          else
          {
            llvm::raw_ostream::write(v34, ", ", 2uLL);
          }

          v33 += 32;
          OUTLINED_FUNCTION_104();
          v36 = OUTLINED_FUNCTION_12_4();
          v37(v36);
          --v32;
        }

        while (v32);
      }
    }

    v7 = *v3;
  }

  v50 = &v52;
  v51 = 0x200000000;
  AttrDictionary = mlir::Operation::getAttrDictionary(v7);
  OUTLINED_FUNCTION_81_2(AttrDictionary, v39, v40, v41, v42, v43, v44, v45, v48, v49[0]);
  OUTLINED_FUNCTION_104();
  v46 = OUTLINED_FUNCTION_31_3();
  v47(v46);
  if (v50 != &v52)
  {
    free(v50);
  }
}

void mlir::ODIE::Compiler::CoreML::PlaceholderOp::print(mlir::ODIE::Compiler::CoreML::PlaceholderOp *this, mlir::OpAsmPrinter *a2)
{
  OUTLINED_FUNCTION_70_0();
  v43[4] = *MEMORY[0x1E69E9840];
  (*(*v6 + 16))(v6);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v7, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v7, v8);
  }

  OUTLINED_FUNCTION_104();
  (*(v10 + 48))(v2);
  OUTLINED_FUNCTION_104();
  (*(v11 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v12, "(", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v12, v13);
  }

  OUTLINED_FUNCTION_47_0();
  if (v15 < 0)
  {
    OUTLINED_FUNCTION_177_0();
  }

  else
  {
    OUTLINED_FUNCTION_99_3();
  }

  (*(*v2 + 16))(v2);
  if (v5)
  {
    OUTLINED_FUNCTION_17_10();
    (*(v16 + 160))(v2);
    v17 = v5 - 1;
    if (v17)
    {
      v18 = v4 + 56;
      do
      {
        OUTLINED_FUNCTION_30_2();
        if (!v14 & v9)
        {
          OUTLINED_FUNCTION_21_5(v19);
        }

        else
        {
          OUTLINED_FUNCTION_42_0();
        }

        v18 += 32;
        OUTLINED_FUNCTION_104();
        (*(v20 + 160))(v2);
        --v17;
      }

      while (v17);
    }
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v21, ")", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v21, v22);
  }

  v41 = v43;
  v43[0] = "opname";
  v43[1] = 6;
  v42 = 0x200000001;
  v40[0] = mlir::Operation::getAttrDictionary(*v3);
  mlir::ArrayAttr::getValue(v40);
  OUTLINED_FUNCTION_104();
  v23 = OUTLINED_FUNCTION_31_3();
  v24(v23);
  OUTLINED_FUNCTION_104();
  (*(v25 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v26, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v26, v27);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_17_2();
  if (v14)
  {
    llvm::raw_ostream::write(v28, ":", 1uLL);
  }

  else
  {
    OUTLINED_FUNCTION_4_1(v28, v29);
  }

  (*(*v2 + 16))(v2);
  OUTLINED_FUNCTION_13_3();
  if (v9)
  {
    llvm::raw_ostream::write(v30, 32);
  }

  else
  {
    OUTLINED_FUNCTION_5_2(v30, v31);
  }

  OUTLINED_FUNCTION_90_2();
  if (v32 < 0)
  {
    OUTLINED_FUNCTION_89_2();
  }

  else
  {
    OUTLINED_FUNCTION_84_2();
  }

  v39[0] = v34;
  v39[1] = v33;
  mlir::OperandRange::getTypes(v39, v40);
  OUTLINED_FUNCTION_16_4();
  v37[0] = v35;
  v37[1] = v36;
  mlir::OperandRange::getTypes(v37, v38);
  mlir::AsmPrinter::printFunctionalType<mlir::ValueTypeRange<mlir::OperandRange>,mlir::ValueTypeRange<mlir::ResultRange>>(v2, v40, v38);
  if (v41 != v43)
  {
    free(v41);
  }
}

void mlir::ODIE::Compiler::CoreML::EqualOp::inferReturnTypes()
{
  {
    v0 = llvm::getTypeName<mlir::ShapedType>();
    mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::CastOp::inferReturnTypeComponents()
{
  {
    v0 = llvm::getTypeName<mlir::ShapedType>();
    mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::CreateComplexOp,mlir::ShapedType &,mlir::ODIE::Compiler::CoreML::CastOp &,mlir::ODIE::Compiler::CoreML::CastOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.create_complex";
  *(a2 + 24) = 21;
}

void mlir::ODIE::Compiler::CoreML::ModuleOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::ModuleOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::ModuleOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::ImportOp::parse()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::ImportOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::ImportOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::GraphOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::GraphOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::GraphOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::CallOp::verifySymbolUses()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::ParamAttrInterface>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ParamAttrInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::InvokeOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::InvokeOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::InvokeOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::ConcatOp::refineReturnTypes()
{
  {
    v0 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AddOp,mlir::TensorType,mlir::ODIE::Compiler::CoreML::RealPartOp &,mlir::ODIE::Compiler::CoreML::RealPartOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.add";
  *(a2 + 24) = 10;
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BatchMatmulOp,mlir::ShapedType &,mlir::ODIE::Compiler::CoreML::RealPartOp &,mlir::ODIE::Compiler::CoreML::RealPartOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.batch_matmul";
  *(a2 + 24) = 19;
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::SubOp,mlir::ShapedType &,mlir::ODIE::Compiler::CoreML::BatchMatmulOp &,mlir::ODIE::Compiler::CoreML::BatchMatmulOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.sub";
  *(a2 + 24) = 10;
}

void mlir::ODIE::Compiler::CoreML::CallOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::CallOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::CallOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::ClassOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::ClassOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::ClassOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::ConcatOp::verifyInvariantsImpl(uint64_t *a1, BOOL *a2)
{
  v23 = *MEMORY[0x1E69E9840];
  v12 = "failed to verify that Operation must have at least two operands.";
  v13 = 259;
  mlir::OpState::emitOpError(a1, &v12, v14);
  *a2 = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v14);
  if (v14[0])
  {
    mlir::InFlightDiagnostic::report(v14);
  }

  if (v22 == 1)
  {
    if (v21 != &v22)
    {
      free(v21);
    }

    v3 = __p;
    if (__p)
    {
      v4 = v20;
      v5 = __p;
      if (v20 != __p)
      {
        do
        {
          v4 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v4 - 1);
        }

        while (v4 != v3);
        v5 = __p;
      }

      v20 = v3;
      operator delete(v5);
    }

    v6 = v17;
    if (v17)
    {
      v7 = v18;
      v8 = OUTLINED_FUNCTION_83_7();
      if (!v9)
      {
        do
        {
          v11 = *--v7;
          v10 = v11;
          *v7 = 0;
          if (v11)
          {
            operator delete[](v10);
          }
        }

        while (v7 != v6);
        v8 = v17;
      }

      v18 = v6;
      operator delete(v8);
    }

    if (v15 != &v16)
    {
      free(v15);
    }
  }
}

void mlir::ODIE::Compiler::CoreML::ConstantOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::ConstantOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::ConstantOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::DelegateOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::DelegateOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::DelegateOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::ErrorOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::ErrorOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::ErrorOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::FuncOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::FuncOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::FuncOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::GELUOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::GELUOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::GELUOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::IsolatedGroupOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::IsolatedGroupOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::IsolatedGroupOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::MemberOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::MemberOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::MemberOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::ODIE::Compiler::CoreML::PlaceholderOp::readProperties()
{
  {
    v0 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::detail::PlaceholderOpGenericAdaptorBase::Properties>();
    mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::detail::PlaceholderOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v0, v1);
  }
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::RealPartOp,mlir::ShapedType &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.real_part";
  *(a2 + 24) = 16;
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ImaginaryPartOp,mlir::ShapedType &,mlir::Value &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.imaginary_part";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ReshapeOp,mlir::RankedTensorType,mlir::detail::TypedValue<mlir::TensorType> &,mlir::ODIE::Compiler::CoreML::ConstantOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.reshape";
  *(a2 + 24) = 14;
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BroadcastInDimsOp,mlir::RankedTensorType,mlir::detail::TypedValue<mlir::TensorType> &,mlir::ODIE::Compiler::CoreML::ConstantOp &,mlir::ODIE::Compiler::CoreML::ConstantOp &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.broadcast_in_dims";
  *(a2 + 24) = 24;
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::ODIE::Compiler::Transforms::segmentFunctionOpInterfaceForDelegate(mlir::FunctionOpInterface,llvm::function_ref<llvm::LogicalResult ()(mlir::Operation *)>,llvm::StringRef,mlir::IRRewriter &)::$_3 const>(uint64_t a1, uint64_t a2)
{
  v29[8] = *MEMORY[0x1E69E9840];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 68);
    if (v2)
    {
      v4 = *(a2 + 72);
      v5 = v4 + 32 * v2;
      while (1)
      {
        v28 = *(v4 + 24);
        DefiningOp = mlir::Value::getDefiningOp(&v28);
        v7 = *(a1 + 16);
        if (DefiningOp && (v8 = DefiningOp, *(DefiningOp + 16) == v7))
        {
          {
            v26 = llvm::getTypeName<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v26, v27);
          }

          if ((*(**(v8 + 6) + 32))(*(v8 + 6), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id))
          {
            mlir::OpBuilder::clone((*a1 + 8), v8);
          }

          v7 = *(a1 + 16);
          v9 = 1;
        }

        else
        {
          v9 = 0;
        }

        v11 = *(v7 + 48);
        v10 = *(v7 + 56);
        if (v10 != v11)
        {
          while (*v11 != v28)
          {
            if (++v11 == v10)
            {
              v11 = v10;
              break;
            }
          }
        }

        if (((v11 == v10) & ~v9) != 0)
        {
          goto LABEL_20;
        }

        v12 = v28;
        if (!*(*(a1 + 24) + 16))
        {
          goto LABEL_17;
        }

        OUTLINED_FUNCTION_1_32();
        if (!v17)
        {
          break;
        }

LABEL_15:
        if (v15 == v13 || !*(v14 + 16 * v15 + 8))
        {
          goto LABEL_17;
        }

LABEL_20:
        v4 += 32;
        if (v4 == v5)
        {
          return;
        }
      }

      while (v16 != -4096)
      {
        OUTLINED_FUNCTION_1_32();
        if (v17)
        {
          goto LABEL_15;
        }
      }

LABEL_17:
      v18 = **(a1 + 8);
      v19 = v12[1];
      Loc = mlir::Value::getLoc(&v28);
      v21 = mlir::Block::addArgument(v18, v19 & 0xFFFFFFFFFFFFFFF8, Loc);
      v22 = *(a1 + 24);
      v29[0] = v28;
      *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::operator[](v22, v29) = v21;
      v23 = *(a1 + 32);
      v24 = v28;
      v25 = *(v23 + 8);
      if (v25 >= *(v23 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(*(a1 + 32), v23 + 16, v25 + 1, 8);
        v25 = *(v23 + 8);
      }

      *(*v23 + 8 * v25) = v24;
      ++*(v23 + 8);
      goto LABEL_20;
    }
  }
}

uint64_t llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::ODIE::Compiler::Transforms::segmentFunctionOpInterfaceForDelegate(mlir::FunctionOpInterface,llvm::function_ref<llvm::LogicalResult ()(mlir::Operation *)>,llvm::StringRef,mlir::IRRewriter &)::$_2 const>(void *a1, uint64_t a2)
{
  v3 = *a1;
  v4 = a1[1];
  (*(**a1 + 40))(*a1);
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 68);
    if (v5)
    {
      v6 = *(v4 + 4);
      if (v6)
      {
        v7 = *(a2 + 72);
        v8 = &v7[4 * v5];
        v9 = *v4;
        v10 = v6 - 1;
        do
        {
          v11 = v7[3];
          v12 = 0x9DDFEA08EB382D69 * ((8 * v11 - 0xAE502812AA7333) ^ HIDWORD(v11));
          v13 = 0x9DDFEA08EB382D69 * (HIDWORD(v11) ^ (v12 >> 47) ^ v12);
          v14 = (-348639895 * ((v13 >> 47) ^ v13)) & v10;
          v15 = *(v9 + 16 * v14);
          if (v15 == v11)
          {
LABEL_6:
            if (v14 != v6)
            {
              v16 = *(v9 + 16 * v14 + 8);
              if (v11 != v16)
              {
                v17 = v7[1];
                if (v17)
                {
                  v18 = *v7;
                  *v17 = *v7;
                  if (v18)
                  {
                    *(v18 + 8) = v17;
                  }
                }

                v7[3] = v16;
                v19 = *v16;
                *v7 = *v16;
                v7[1] = v16;
                if (v19)
                {
                  *(v19 + 8) = v7;
                }

                *v16 = v7;
              }
            }
          }

          else
          {
            v20 = 1;
            while (v15 != -4096)
            {
              v21 = v14 + v20++;
              v14 = v21 & v10;
              v15 = *(v9 + 16 * v14);
              if (v15 == v11)
              {
                goto LABEL_6;
              }
            }
          }

          v7 += 4;
        }

        while (v7 != v8);
      }
    }
  }

  v22 = *(*v3 + 48);

  return v22(v3, a2);
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::YieldOp,llvm::SmallVector<mlir::Value,6u> &>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.yield";
  *(a2 + 24) = 12;
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::IsolatedGroupOp,llvm::ArrayRef<mlir::Type>,llvm::SmallVector<mlir::Value,6u> const&,mlir::StringAttr>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.isolated_group";
  *(a2 + 24) = 21;
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::DelegateOp,llvm::ArrayRef<mlir::Type> &,llvm::MutableArrayRef<mlir::BlockArgument>,mlir::StringAttr,mlir::detail::DenseArrayAttrImpl<signed char>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.delegate";
  *(a2 + 24) = 15;
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OutputOp,mlir::ResultRange>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.output";
  *(a2 + 24) = 13;
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreMLAX::CastOp,mlir::RankedTensorType,mlir::detail::TypedValue<mlir::RankedTensorType>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coremlax.cast";
  *(a2 + 24) = 13;
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreMLAX::CopyWithConstraintsOp,mlir::RankedTensorType,mlir::detail::TypedValue<mlir::RankedTensorType>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coremlax.copy_with_constraints";
  *(a2 + 24) = 30;
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreMLAX::ViewOp,mlir::RankedTensorType const&,mlir::detail::TypedValue<mlir::RankedTensorType>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coremlax.view";
  *(a2 + 24) = 13;
}

void mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ConstantOp,mlir::ElementsAttr &>(llvm::Twine *a1, uint64_t a2, uint64_t a3)
{
  *(a2 + 32) = 1283;
  *(a2 + 16) = "coreml.constant";
  *(a2 + 24) = 15;
  *(a3 + 32) = 259;
  llvm::operator+(a2, a3, a1);
  llvm::report_fatal_error(a1, 1);
}

void llvm::APInt::shlSlowCase(const void **this, unsigned int a2)
{
  v2 = this;
  v3 = *(this + 2);
  if (a2)
  {
    v4 = *this;
    v5 = (v3 + 63) >> 6;
    if (a2 >> 6 >= v5)
    {
      v6 = (v3 + 63) >> 6;
    }

    else
    {
      v6 = a2 >> 6;
    }

    v7 = a2 & 0x3F;
    if ((a2 & 0x3F) != 0)
    {
      if (a2 >> 6 < v5)
      {
        v8 = v5 - 1;
        v9 = v4[v5 - 1 - v6] << v7;
        v10 = &v4[(v5 - 1)];
        *v10 = v9;
        if (v5 - 1 > v6)
        {
          v11 = &v4[v8 - v6 - 1];
          v12 = v5 - 2;
          v13 = v5 - 2 - v6;
          v14 = &v4[v12];
          do
          {
            v15 = *v11--;
            *v10 = (v15 >> (64 - v7)) | v9;
            --v8;
            v9 = v4[v13] << v7;
            v10 = &v4[v8];
            *v14-- = v9;
            --v13;
          }

          while (v6 < v8);
        }
      }
    }

    else
    {
      memmove(&v4[v6], *this, 8 * (v5 - v6));
    }

    bzero(v4, 8 * v6);
    LODWORD(v3) = *(v2 + 2);
  }

  if (v3)
  {
    v16 = 0xFFFFFFFFFFFFFFFFLL >> -v3;
    if (v3 >= 0x41)
    {
      v2 = (*v2 + 8 * ((v3 + 63) >> 6) - 8);
    }
  }

  else
  {
    v16 = 0;
  }

  *v2 = (*v2 & v16);
}

void *llvm::APInt::initSlowCase(unint64_t a1, unint64_t *a2, uint64_t a3, unsigned int a4)
{
  v7 = a1 >> 6;
  v8 = 8 * (a1 >> 6);
  v9 = operator new[](v8);
  *a2 = v9;
  *v9 = a3;
  result = memset((v9 + 8), 255, (v8 - 8));
  if (a4)
  {
    v11 = 0xFFFFFFFFFFFFFFFFLL >> -a4;
    if (a4 >= 0x41)
    {
      a2 = (v9 + 8 * (v7 - 1));
      v9 = *a2;
    }
  }

  else
  {
    v11 = 0;
  }

  *a2 = v9 & v11;
  return result;
}

void *llvm::APInt::ashrSlowCase(uint64_t a1, unsigned int a2)
{
  v2 = a1;
  v3 = *(a1 + 8);
  v4 = v3 - 1;
  v5 = a1;
  if (v3 >= 0x41)
  {
    v5 = (*a1 + 8 * (v4 >> 6));
  }

  v6 = *v5 & (1 << v4);
  v7 = a2 >> 6;
  v8 = (v3 + 63) >> 6;
  v9 = v8 - (a2 >> 6);
  if (v8 != a2 >> 6)
  {
    v10 = v8 - 1;
    *(*a1 + 8 * v10) = (*(*a1 + 8 * v10) << -v3) >> -v3;
    v11 = a2 & 0x3F;
    if ((a2 & 0x3F) != 0)
    {
      v12 = v9 - 1;
      if (v9 == 1)
      {
        v12 = 0;
      }

      else
      {
        v13 = 0;
        v14 = a2 >> 6;
        do
        {
          v15 = *(*a1 + 8 * v14++) >> v11;
          *(*a1 + v13) = (*(*a1 + 8 * v14) << (64 - v11)) | v15;
          v13 += 8;
        }

        while (8 * (v9 - 1) != v13);
      }

      *(*a1 + 8 * v12) = *(*a1 + 8 * v10) >> v11;
      *(*a1 + 8 * v12) = (*(*a1 + 8 * v12) << v11) >> v11;
    }

    else
    {
      memmove(*a1, (*a1 + 8 * v7), 8 * v9);
    }
  }

  if (v6)
  {
    v16 = -1;
  }

  else
  {
    v16 = 0;
  }

  result = memset((*v2 + 8 * v9), v16, 8 * v7);
  v18 = *(v2 + 8);
  if (v18)
  {
    v19 = 0xFFFFFFFFFFFFFFFFLL >> -v18;
    if (v18 >= 0x41)
    {
      v2 = *v2 + 8 * (((v18 + 63) >> 6) - 1);
    }
  }

  else
  {
    v19 = 0;
  }

  *v2 &= v19;
  return result;
}

void llvm::cl::Option::addCategory()
{
  v0 = __cxa_guard_acquire(&_MergedGlobals_50);
  if (v0)
  {
    OUTLINED_FUNCTION_0_23(v0, "General options", v1, "");

    __cxa_guard_release(&_MergedGlobals_50);
  }
}

void llvm::CrashRecoveryContext::Enable()
{
  v0 = __cxa_guard_acquire(qword_1EE17CAF0);
  if (v0)
  {

    __cxa_guard_release(qword_1EE17CAF0);
  }
}

void llvm::initDebugCounterOptions()
{
  v0 = __cxa_guard_acquire(_MergedGlobals_52);
  if (v0)
  {
    OUTLINED_FUNCTION_0_25(v1, v2, &dword_1DF9BF000);

    __cxa_guard_release(_MergedGlobals_52);
  }
}

void llvm::DebugCounter::push_back()
{
  v0 = __cxa_guard_acquire(_MergedGlobals_52);
  if (v0)
  {
    OUTLINED_FUNCTION_0_25(v1, v2, &dword_1DF9BF000);
    __cxa_guard_release(_MergedGlobals_52);
  }
}

void llvm::ErrorList::convertToErrorCode()
{
  if (v0)
  {
    OUTLINED_FUNCTION_0_26(v0, &getErrorErrorCat(void)::ErrorErrorCat, &dword_1DF9BF000);
  }
}

void llvm::errorToErrorCode()
{
  if (v0)
  {
    OUTLINED_FUNCTION_0_26(v0, &getErrorErrorCat(void)::ErrorErrorCat, &dword_1DF9BF000);
  }
}

void llvm::ManagedStaticBase::RegisterManagedStatic()
{
  if (__cxa_guard_acquire(&qword_1EE17CE20))
  {
    MEMORY[0x1E12E57B0](&unk_1EE17CE28);
    __cxa_atexit(MEMORY[0x1E69E52E0], &unk_1EE17CE28, &dword_1DF9BF000);

    __cxa_guard_release(&qword_1EE17CE20);
  }
}

void getOpenFileImpl<llvm::MemoryBuffer>()
{
  v0 = __cxa_guard_acquire(&qword_1EE17CE78);
  if (v0)
  {
    dword_1EE17CE6C = llvm::sys::Process::getPageSizeEstimate(v0);

    __cxa_guard_release(&qword_1EE17CE78);
  }
}

void llvm::initStatisticOptions()
{
  if (__cxa_guard_acquire(&qword_1EE17CE88))
  {
    *&v2 = "Enable statistics output from program (available with Asserts)";
    *(&v2 + 1) = 62;
    v3 = &_MergedGlobals_55;
    v4 = 1;
    llvm::cl::opt<BOOL,true,llvm::cl::parser<BOOL>>::opt<char [6],llvm::cl::desc,llvm::cl::LocationClass<BOOL>,llvm::cl::OptionHidden>(&unk_1EE17CEC8, "stats", &v2, &v3, &v4);
    v0 = OUTLINED_FUNCTION_0_27();
    __cxa_atexit(v0, &unk_1EE17CEC8, v1);
    __cxa_guard_release(&qword_1EE17CE88);
  }
}

{
  if (__cxa_guard_acquire(qword_1EE17CE90))
  {
    *&v2 = "Display statistics as json data";
    *(&v2 + 1) = 31;
    v3 = &unk_1EE17CE81;
    v4 = 1;
    llvm::cl::opt<BOOL,true,llvm::cl::parser<BOOL>>::opt<char [6],llvm::cl::desc,llvm::cl::LocationClass<BOOL>,llvm::cl::OptionHidden>(&unk_1EE17CF88, "stats-json", &v2, &v3, &v4);
    v0 = OUTLINED_FUNCTION_0_27();
    __cxa_atexit(v0, &unk_1EE17CF88, v1);
    __cxa_guard_release(qword_1EE17CE90);
  }
}

void llvm::vfs::getRealFileSystem()
{
  if (__cxa_guard_acquire(&qword_1EE17D118))
  {
    v0 = operator new(0x150uLL);
    v0[2] = 0;
    *v0 = &unk_1F5B3F6D0;
    *(v0 + 16) = 0;
    *(v0 + 328) = 0;
    _MergedGlobals_57 = v0;
    atomic_fetch_add_explicit(v0 + 2, 1u, memory_order_relaxed);
    __cxa_atexit(llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>::~IntrusiveRefCntPtr, &_MergedGlobals_57, &dword_1DF9BF000);

    __cxa_guard_release(&qword_1EE17D118);
  }
}

void anonymous namespace::CreateUseColor::call()
{
  if (__cxa_guard_acquire(&_MergedGlobals_58))
  {
    qword_1EE17D128 = "Color Options";
    qword_1EE17D130 = 13;
    unk_1EE17D138 = "";
    qword_1EE17D140 = 0;
    llvm::cl::OptionCategory::registerCategory(&qword_1EE17D128);

    __cxa_guard_release(&_MergedGlobals_58);
  }
}

void llvm::outs()
{
  v0 = __cxa_guard_acquire(&_MergedGlobals_59);
  if (v0)
  {
    OUTLINED_FUNCTION_1_33(v0, "-");
    v1 = OUTLINED_FUNCTION_0_28();
    __cxa_atexit(v1, &unk_1EE17D190, v2);

    __cxa_guard_release(&_MergedGlobals_59);
  }
}

void llvm::errs()
{
  if (__cxa_guard_acquire(qword_1EE17D150))
  {
    llvm::raw_fd_ostream::raw_fd_ostream(&unk_1EE17D1F0, 2u, 0, 1, 0);
    v0 = OUTLINED_FUNCTION_0_28();
    __cxa_atexit(v0, &unk_1EE17D1F0, v1);

    __cxa_guard_release(qword_1EE17D150);
  }
}

void llvm::sys::Memory::allocateMappedMemory()
{
  v0 = __cxa_guard_acquire(&qword_1EE17D260);
  if (v0)
  {
    qword_1EE17D258 = llvm::sys::Process::getPageSizeEstimate(v0);

    __cxa_guard_release(&qword_1EE17D260);
  }
}

void llvm::sys::Memory::protectMappedMemory()
{
  v0 = __cxa_guard_acquire(&qword_1EE17D268);
  if (v0)
  {
    _MergedGlobals_60 = 63 - __clz(llvm::sys::Process::getPageSizeEstimate(v0));

    __cxa_guard_release(&qword_1EE17D268);
  }
}

void llvm::sys::Process::getPageSize()
{
  if (__cxa_guard_acquire(&qword_1EE17D278))
  {
    _MergedGlobals_61 = getpagesize();

    __cxa_guard_release(&qword_1EE17D278);
  }
}

void llvm::ThreadPoolStrategy::compute_thread_count()
{
  if (__cxa_guard_acquire(&qword_1EE17DDA8))
  {
    _MergedGlobals_63 = computeHostNumPhysicalCores();

    __cxa_guard_release(&qword_1EE17DDA8);
  }
}

uint64_t MPSKernelDAG::constantOp()
{
  return MEMORY[0x1EEDCDD70]();
}

{
  return MEMORY[0x1EEDCDD78]();
}

uint64_t MPSKernelDAG::padOp()
{
  return MEMORY[0x1EEDCDF30]();
}

{
  return MEMORY[0x1EEDCDF38]();
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__filename(const std::__fs::filesystem::path *this)
{
  v1 = MEMORY[0x1EEE63A08](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__parent_path(const std::__fs::filesystem::path *this)
{
  v1 = MEMORY[0x1EEE63A18](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__root_directory(const std::__fs::filesystem::path *this)
{
  v1 = MEMORY[0x1EEE63A20](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
  MEMORY[0x1EEE63B50](this);
}

{
  MEMORY[0x1EEE63B58](this);
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1EEE63EB8]();
}

{
  return MEMORY[0x1EEE63ED0]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, uint64_t __val)
{
  return MEMORY[0x1EEE644C0](retstr, __val);
}

{
  return MEMORY[0x1EEE644D0](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return MEMORY[0x1EEE644C8](retstr, __val);
}

{
  return MEMORY[0x1EEE644D8](retstr, __val);
}

void operator delete[](void *__p)
{
    ;
  }
}

void operator delete[]()
{
    ;
  }
}

void operator delete(void *__p)
{
    ;
  }
}

void operator delete(void *__p, std::align_val_t a2)
{
    ;
  }
}

void operator delete()
{
    ;
  }
}

void *__cdecl operator new[](size_t __sz)
{
    ;
  }
}

void operator new[]()
{
    ;
  }
}

void *__cdecl operator new(size_t __sz)
{
    ;
  }
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
    ;
  }
}

void *__cdecl operator new(size_t __sz, std::align_val_t a2)
{
    ;
  }
}

void operator new()
{
    ;
  }
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x1EEE73578](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}