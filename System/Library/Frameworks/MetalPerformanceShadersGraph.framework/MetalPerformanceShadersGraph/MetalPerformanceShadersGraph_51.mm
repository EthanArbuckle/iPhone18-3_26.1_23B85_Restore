void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps7(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps13(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps14(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void mlir::OpBuilder::createOrFold<mlir::memref::DimOp,mlir::Value &,long long &>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, mlir::MLIRContext **a5)
{
  v32[38] = *MEMORY[0x1E69E9840];
  v29 = a3;
  Context = mlir::Attribute::getContext(&v29);
  v11 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::DimOp,void>::id, Context);
  if ((v12 & 1) == 0)
  {
    mlir::OpBuilder::createOrFold<mlir::memref::DimOp,mlir::Value &,long long &>(v32, v31, v30);
  }

  mlir::OperationState::OperationState(v32, a3, v11);
  v13 = *a4;
  v31[0] = *a5;
  v14 = mlir::OpBuilder::create<mlir::arith::ConstantIndexOp,long long &>(a1, v32[0], v31);
  mlir::memref::DimOp::build(a1, v32, v13, v14 - 16);
  v16 = mlir::Operation::create(v32, v15);
  v17 = *(a1 + 16);
  if (v17)
  {
    v18 = *(a1 + 24);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v17 + 32, v16);
    v20 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v16, v19);
    v21 = *v18;
    *v20 = *v18;
    v20[1] = v18;
    *(v21 + 8) = v20;
    *v18 = v20;
    MPSGraphDelegateCompiler.precompilationDescriptor.modify(v16, v22);
  }

  if ((mlir::OpBuilder::tryFold(a1, v16, a2) & 1) != 0 && *(a2 + 8))
  {
    mlir::Operation::erase(v16);
    goto LABEL_19;
  }

  v23 = v16[9];
  if (v23)
  {
    v24 = (v16 - 4);
  }

  else
  {
    v24 = 0;
  }

  *(a2 + 8) = 0;
  if (v23 > *(a2 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2, a2 + 16, v23, 8);
    v25 = *(a2 + 8);
LABEL_14:
    v26 = 0;
    v27 = *a2 + 8 * v25;
    do
    {
      *(v27 + 8 * v26) = mlir::detail::OpResultImpl::getNextResultAtOffset(v24, v26);
      ++v26;
    }

    while (v23 != v26);
    *(a2 + 8) += v23;
    if (!*(a1 + 16))
    {
      goto LABEL_19;
    }

    goto LABEL_17;
  }

  if (v23)
  {
    v25 = 0;
    goto LABEL_14;
  }

  *(a2 + 8) = 0;
  if (!*(a1 + 16))
  {
    goto LABEL_19;
  }

LABEL_17:
  v28 = *(a1 + 8);
  if (v28)
  {
    (*(*v28 + 16))(v28, v16, 0, 0);
  }

LABEL_19:
  mlir::OperationState::~OperationState(v32);
}

void *anonymous namespace::SimplifyAllocConst<mlir::memref::AllocOp>::~SimplifyAllocConst(void *a1)
{
  v2 = a1[10];
  if (v2 != a1 + 12)
  {
    free(v2);
  }

  v3 = a1[4];
  if (v3 != a1 + 6)
  {
    free(v3);
  }

  return a1;
}

void anonymous namespace::SimplifyAllocConst<mlir::memref::AllocOp>::~SimplifyAllocConst(void *__p)
{
  v2 = __p[10];
  if (v2 != __p + 12)
  {
    free(v2);
  }

  v3 = __p[4];
  if (v3 != __p + 6)
  {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpBuilder::create<mlir::memref::AllocOp,mlir::MemRefType &,llvm::SmallVector<mlir::Value,4u> &,mlir::OperandRange,mlir::IntegerAttr>(uint64_t **a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  v22[5] = *MEMORY[0x1E69E9840];
  v19 = a2;
  Context = mlir::Attribute::getContext(&v19);
  v13 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::AllocOp,void>::id, Context);
  if ((v14 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::AllocOp,mlir::MemRefType &,llvm::SmallVector<mlir::Value,4u> &,mlir::OperandRange,mlir::IntegerAttr>(v20, v22, v21);
  }

  mlir::OperationState::OperationState(v20, a2, v13);
  v15 = *a3;
  mlir::ValueRange::ValueRange(v22, *a4, *(a4 + 8));
  mlir::ValueRange::ValueRange(v21, *a5, *(a5 + 8));
  mlir::memref::AllocOp::build(a1, v20, v15, v22[0], v22[1], v21[0], v21[1], *a6);
  v16 = mlir::OpBuilder::create(a1, v20);
  if (*(*(v16 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::AllocOp,void>::id)
  {
    v17 = v16;
  }

  else
  {
    v17 = 0;
  }

  mlir::OperationState::~OperationState(v20);
  return v17;
}

uint64_t mlir::OpBuilder::create<mlir::memref::CastOp,mlir::MemRefType,mlir::memref::AllocOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v23[28] = *MEMORY[0x1E69E9840];
  v16 = a2;
  Context = mlir::Attribute::getContext(&v16);
  v9 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::CastOp,void>::id, Context);
  if ((v10 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::CastOp,mlir::MemRefType,mlir::memref::AllocOp &>(v19, v18, v17);
  }

  mlir::OperationState::OperationState(v19, a2, v9);
  v11 = *a3;
  v18[0] = *a4 - 16;
  mlir::OperationState::addOperands(v19, v18, 1uLL);
  v12 = v21;
  if (v21 >= v22)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v20, v23, v21 + 1, 8);
    v12 = v21;
  }

  *(v20 + 8 * v12) = v11;
  ++v21;
  v13 = mlir::OpBuilder::create(a1, v19);
  if (*(*(v13 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::CastOp,void>::id)
  {
    v14 = v13;
  }

  else
  {
    v14 = 0;
  }

  mlir::OperationState::~OperationState(v19);
  return v14;
}

void *anonymous namespace::SimplifyDeadAlloc<mlir::memref::AllocOp>::~SimplifyDeadAlloc(void *a1)
{
  v2 = a1[10];
  if (v2 != a1 + 12)
  {
    free(v2);
  }

  v3 = a1[4];
  if (v3 != a1 + 6)
  {
    free(v3);
  }

  return a1;
}

void anonymous namespace::SimplifyDeadAlloc<mlir::memref::AllocOp>::~SimplifyDeadAlloc(void *__p)
{
  v2 = __p[10];
  if (v2 != __p + 12)
  {
    free(v2);
  }

  v3 = __p[4];
  if (v3 != __p + 6)
  {
    free(v3);
  }

  operator delete(__p);
}

uint64_t anonymous namespace::SimplifyDeadAlloc<mlir::memref::AllocOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v31 = *MEMORY[0x1E69E9840];
  v5 = *(a2 + 36);
  v6 = a2 - 16;
  if (v5)
  {
    v7 = a2 - 16;
  }

  else
  {
    v7 = 0;
  }

  v27.n128_u64[0] = v7;
  v27.n128_u64[1] = v5;
  mlir::ResultRange::use_begin(&v27, &v28);
  v8 = *(a2 + 36);
  if (v8)
  {
    v9 = v6;
  }

  else
  {
    v9 = 0;
  }

  v27.n128_u64[0] = v9;
  v27.n128_u64[1] = v8;
  mlir::ResultRange::use_end(&v27, v25);
  v10 = v30;
  j = v30;
  v22 = v28;
  v23 = v29;
  for (i = v26; v30 != i; v10 = v30)
  {
    v12 = *(v10 + 16);
    v13 = *(*(v12 + 48) + 16);
    if (v12)
    {
      v14 = v13 == &mlir::detail::TypeIDResolver<mlir::memref::StoreOp,void>::id;
    }

    else
    {
      v14 = 0;
    }

    if (v14)
    {
      if (*(*(v12 + 72) + 24) == v6)
      {
        return 0;
      }
    }

    else if (v13 != &mlir::detail::TypeIDResolver<mlir::memref::DeallocOp,void>::id)
    {
      return 0;
    }

    mlir::ResultRange::UseIterator::operator++(&v28);
  }

  v16 = *(a2 + 36);
  if (v16)
  {
    v17 = v6;
  }

  else
  {
    v17 = 0;
  }

  *&v22 = v17;
  *(&v22 + 1) = v16;
  mlir::ResultRange::use_begin(&v22, &v28);
  v18 = *(a2 + 36);
  if (v18)
  {
    v19 = v6;
  }

  else
  {
    v19 = 0;
  }

  v27.n128_u64[0] = v19;
  v27.n128_u64[1] = v18;
  mlir::ResultRange::use_end(&v27, v25);
  v20 = v26;
  v22 = v28;
  v23 = v29;
  v21 = v30;
  for (j = v30; j != v20; v21 = j)
  {
    mlir::ResultRange::UseIterator::operator++(&v22);
    (*(*a3 + 16))(a3, *(v21 + 16));
  }

  (*(*a3 + 16))(a3, a2);
  return 1;
}

void *anonymous namespace::SimplifyAllocConst<mlir::memref::AllocaOp>::~SimplifyAllocConst(void *a1)
{
  v2 = a1[10];
  if (v2 != a1 + 12)
  {
    free(v2);
  }

  v3 = a1[4];
  if (v3 != a1 + 6)
  {
    free(v3);
  }

  return a1;
}

void anonymous namespace::SimplifyAllocConst<mlir::memref::AllocaOp>::~SimplifyAllocConst(void *__p)
{
  v2 = __p[10];
  if (v2 != __p + 12)
  {
    free(v2);
  }

  v3 = __p[4];
  if (v3 != __p + 6)
  {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpBuilder::create<mlir::memref::AllocaOp,mlir::MemRefType &,llvm::SmallVector<mlir::Value,4u> &,mlir::OperandRange,mlir::IntegerAttr>(uint64_t **a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  v22[5] = *MEMORY[0x1E69E9840];
  v19 = a2;
  Context = mlir::Attribute::getContext(&v19);
  v13 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::AllocaOp,void>::id, Context);
  if ((v14 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::AllocaOp,mlir::MemRefType &>(v20, v22, v21);
  }

  mlir::OperationState::OperationState(v20, a2, v13);
  v15 = *a3;
  mlir::ValueRange::ValueRange(v22, *a4, *(a4 + 8));
  mlir::ValueRange::ValueRange(v21, *a5, *(a5 + 8));
  mlir::memref::AllocOp::build(a1, v20, v15, v22[0], v22[1], v21[0], v21[1], *a6);
  v16 = mlir::OpBuilder::create(a1, v20);
  if (*(*(v16 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::AllocaOp,void>::id)
  {
    v17 = v16;
  }

  else
  {
    v17 = 0;
  }

  mlir::OperationState::~OperationState(v20);
  return v17;
}

void *anonymous namespace::SimplifyDeadAlloc<mlir::memref::AllocaOp>::~SimplifyDeadAlloc(void *a1)
{
  v2 = a1[10];
  if (v2 != a1 + 12)
  {
    free(v2);
  }

  v3 = a1[4];
  if (v3 != a1 + 6)
  {
    free(v3);
  }

  return a1;
}

void anonymous namespace::SimplifyDeadAlloc<mlir::memref::AllocaOp>::~SimplifyDeadAlloc(void *__p)
{
  v2 = __p[10];
  if (v2 != __p + 12)
  {
    free(v2);
  }

  v3 = __p[4];
  if (v3 != __p + 6)
  {
    free(v3);
  }

  operator delete(__p);
}

uint64_t anonymous namespace::SimplifyDeadAlloc<mlir::memref::AllocaOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v31 = *MEMORY[0x1E69E9840];
  v5 = *(a2 + 36);
  v6 = a2 - 16;
  if (v5)
  {
    v7 = a2 - 16;
  }

  else
  {
    v7 = 0;
  }

  v27.n128_u64[0] = v7;
  v27.n128_u64[1] = v5;
  mlir::ResultRange::use_begin(&v27, &v28);
  v8 = *(a2 + 36);
  if (v8)
  {
    v9 = v6;
  }

  else
  {
    v9 = 0;
  }

  v27.n128_u64[0] = v9;
  v27.n128_u64[1] = v8;
  mlir::ResultRange::use_end(&v27, v25);
  v10 = v30;
  j = v30;
  v22 = v28;
  v23 = v29;
  for (i = v26; v30 != i; v10 = v30)
  {
    v12 = *(v10 + 16);
    v13 = *(*(v12 + 48) + 16);
    if (v12)
    {
      v14 = v13 == &mlir::detail::TypeIDResolver<mlir::memref::StoreOp,void>::id;
    }

    else
    {
      v14 = 0;
    }

    if (v14)
    {
      if (*(*(v12 + 72) + 24) == v6)
      {
        return 0;
      }
    }

    else if (v13 != &mlir::detail::TypeIDResolver<mlir::memref::DeallocOp,void>::id)
    {
      return 0;
    }

    mlir::ResultRange::UseIterator::operator++(&v28);
  }

  v16 = *(a2 + 36);
  if (v16)
  {
    v17 = v6;
  }

  else
  {
    v17 = 0;
  }

  *&v22 = v17;
  *(&v22 + 1) = v16;
  mlir::ResultRange::use_begin(&v22, &v28);
  v18 = *(a2 + 36);
  if (v18)
  {
    v19 = v6;
  }

  else
  {
    v19 = 0;
  }

  v27.n128_u64[0] = v19;
  v27.n128_u64[1] = v18;
  mlir::ResultRange::use_end(&v27, v25);
  v20 = v26;
  v22 = v28;
  v23 = v29;
  v21 = v30;
  for (j = v30; j != v20; v21 = j)
  {
    mlir::ResultRange::UseIterator::operator++(&v22);
    (*(*a3 + 16))(a3, *(v21 + 16));
  }

  (*(*a3 + 16))(a3, a2);
  return 1;
}

void *anonymous namespace::SimplifyDeadAlloc<mlir::memref::ReallocOp>::~SimplifyDeadAlloc(void *a1)
{
  v2 = a1[10];
  if (v2 != a1 + 12)
  {
    free(v2);
  }

  v3 = a1[4];
  if (v3 != a1 + 6)
  {
    free(v3);
  }

  return a1;
}

void anonymous namespace::SimplifyDeadAlloc<mlir::memref::ReallocOp>::~SimplifyDeadAlloc(void *__p)
{
  v2 = __p[10];
  if (v2 != __p + 12)
  {
    free(v2);
  }

  v3 = __p[4];
  if (v3 != __p + 6)
  {
    free(v3);
  }

  operator delete(__p);
}

uint64_t anonymous namespace::SimplifyDeadAlloc<mlir::memref::ReallocOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v31 = *MEMORY[0x1E69E9840];
  v5 = *(a2 + 36);
  v6 = a2 - 16;
  if (v5)
  {
    v7 = a2 - 16;
  }

  else
  {
    v7 = 0;
  }

  v27.n128_u64[0] = v7;
  v27.n128_u64[1] = v5;
  mlir::ResultRange::use_begin(&v27, &v28);
  v8 = *(a2 + 36);
  if (v8)
  {
    v9 = v6;
  }

  else
  {
    v9 = 0;
  }

  v27.n128_u64[0] = v9;
  v27.n128_u64[1] = v8;
  mlir::ResultRange::use_end(&v27, v25);
  v10 = v30;
  j = v30;
  v22 = v28;
  v23 = v29;
  for (i = v26; v30 != i; v10 = v30)
  {
    v12 = *(v10 + 16);
    v13 = *(*(v12 + 48) + 16);
    if (v12)
    {
      v14 = v13 == &mlir::detail::TypeIDResolver<mlir::memref::StoreOp,void>::id;
    }

    else
    {
      v14 = 0;
    }

    if (v14)
    {
      if (*(*(v12 + 72) + 24) == v6)
      {
        return 0;
      }
    }

    else if (v13 != &mlir::detail::TypeIDResolver<mlir::memref::DeallocOp,void>::id)
    {
      return 0;
    }

    mlir::ResultRange::UseIterator::operator++(&v28);
  }

  v16 = *(a2 + 36);
  if (v16)
  {
    v17 = v6;
  }

  else
  {
    v17 = 0;
  }

  *&v22 = v17;
  *(&v22 + 1) = v16;
  mlir::ResultRange::use_begin(&v22, &v28);
  v18 = *(a2 + 36);
  if (v18)
  {
    v19 = v6;
  }

  else
  {
    v19 = 0;
  }

  v27.n128_u64[0] = v19;
  v27.n128_u64[1] = v18;
  mlir::ResultRange::use_end(&v27, v25);
  v20 = v26;
  v22 = v28;
  v23 = v29;
  v21 = v30;
  for (j = v30; j != v20; v21 = j)
  {
    mlir::ResultRange::UseIterator::operator++(&v22);
    (*(*a3 + 16))(a3, *(v21 + 16));
  }

  (*(*a3 + 16))(a3, a2);
  return 1;
}

uint64_t mlir::OpTrait::SingleBlockImplicitTerminator<mlir::memref::AllocaScopeReturnOp>::Impl<mlir::memref::AllocaScopeOp>::buildTerminator(uint64_t a1, uint64_t a2)
{
  v5[38] = *MEMORY[0x1E69E9840];
  mlir::OperationState::OperationState(v5, a2, "memref.alloca_scope.return", 26);
  v3 = mlir::Operation::create(v5, v2);
  mlir::OperationState::~OperationState(v5);
  return v3;
}

void mlir::RewritePatternSet::addImpl<AllocaScopeInliner,mlir::MLIRContext *&>(void *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  v8 = operator new(0x60uLL);
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v31, 1);
  mlir::Pattern::Pattern((v8 + 1), "memref.alloca_scope", 19, v31, v9, 0, 0);
  *v8 = &unk_1F5AFA4C8;
  if (v8[9])
  {
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v31 = "StringRef llvm::getTypeName() [DesiredTypeName = AllocaScopeInliner]";
    v32 = 68;
    v23 = llvm::StringRef::find(&v31, "DesiredTypeName = ", 0x12uLL, 0);
    if (v32 >= v23)
    {
      v24 = v23;
    }

    else
    {
      v24 = v32;
    }

    v25 = &v31[v24];
    v26 = v32 - v24;
    if (v32 - v24 >= 0x12)
    {
      v27 = 18;
    }

    else
    {
      v27 = v32 - v24;
    }

    v28 = &v25[v27];
    v29 = v26 - v27;
    if (v29 >= v29 - 1)
    {
      --v29;
    }

    v8[8] = v28;
    v8[9] = v29;
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
LABEL_3:
      if (!a3)
      {
        goto LABEL_5;
      }

      goto LABEL_4;
    }
  }

  llvm::SmallVectorBase<unsigned int>::grow_pod((v8 + 10), (v8 + 12), v12, 16);
  LODWORD(v11) = *(v8 + 22);
  if (a3)
  {
LABEL_4:
    memcpy((v8[10] + 16 * v11), a2, v10);
    LODWORD(v11) = *(v8 + 22);
  }

LABEL_5:
  *(v8 + 22) = v11 + (v10 >> 4);
  v14 = a1[2];
  v13 = a1[3];
  if (v14 >= v13)
  {
    v16 = a1[1];
    v17 = v14 - v16;
    v18 = (v14 - v16) >> 3;
    v19 = v18 + 1;
    if ((v18 + 1) >> 61)
    {
      std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
    }

    v20 = v13 - v16;
    if (v20 >> 2 > v19)
    {
      v19 = v20 >> 2;
    }

    if (v20 >= 0x7FFFFFFFFFFFFFF8)
    {
      v21 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v21 = v19;
    }

    if (v21)
    {
      if (v21 >> 61)
      {
        std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
      }

      v22 = operator new(8 * v21);
    }

    else
    {
      v22 = 0;
    }

    v30 = &v22[8 * v18];
    *v30 = v8;
    v15 = v30 + 8;
    memcpy(v22, v16, v17);
    a1[1] = v22;
    a1[2] = v15;
    a1[3] = &v22[8 * v21];
    if (v16)
    {
      operator delete(v16);
    }
  }

  else
  {
    *v14 = v8;
    v15 = v14 + 8;
  }

  a1[2] = v15;
}

void mlir::RewritePatternSet::addImpl<AllocaScopeHoister,mlir::MLIRContext *&>(void *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  v8 = operator new(0x60uLL);
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v31, 1);
  mlir::Pattern::Pattern((v8 + 1), "memref.alloca_scope", 19, v31, v9, 0, 0);
  *v8 = &unk_1F5AFA568;
  if (v8[9])
  {
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v31 = "StringRef llvm::getTypeName() [DesiredTypeName = AllocaScopeHoister]";
    v32 = 68;
    v23 = llvm::StringRef::find(&v31, "DesiredTypeName = ", 0x12uLL, 0);
    if (v32 >= v23)
    {
      v24 = v23;
    }

    else
    {
      v24 = v32;
    }

    v25 = &v31[v24];
    v26 = v32 - v24;
    if (v32 - v24 >= 0x12)
    {
      v27 = 18;
    }

    else
    {
      v27 = v32 - v24;
    }

    v28 = &v25[v27];
    v29 = v26 - v27;
    if (v29 >= v29 - 1)
    {
      --v29;
    }

    v8[8] = v28;
    v8[9] = v29;
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
LABEL_3:
      if (!a3)
      {
        goto LABEL_5;
      }

      goto LABEL_4;
    }
  }

  llvm::SmallVectorBase<unsigned int>::grow_pod((v8 + 10), (v8 + 12), v12, 16);
  LODWORD(v11) = *(v8 + 22);
  if (a3)
  {
LABEL_4:
    memcpy((v8[10] + 16 * v11), a2, v10);
    LODWORD(v11) = *(v8 + 22);
  }

LABEL_5:
  *(v8 + 22) = v11 + (v10 >> 4);
  v14 = a1[2];
  v13 = a1[3];
  if (v14 >= v13)
  {
    v16 = a1[1];
    v17 = v14 - v16;
    v18 = (v14 - v16) >> 3;
    v19 = v18 + 1;
    if ((v18 + 1) >> 61)
    {
      std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
    }

    v20 = v13 - v16;
    if (v20 >> 2 > v19)
    {
      v19 = v20 >> 2;
    }

    if (v20 >= 0x7FFFFFFFFFFFFFF8)
    {
      v21 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v21 = v19;
    }

    if (v21)
    {
      if (v21 >> 61)
      {
        std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
      }

      v22 = operator new(8 * v21);
    }

    else
    {
      v22 = 0;
    }

    v30 = &v22[8 * v18];
    *v30 = v8;
    v15 = v30 + 8;
    memcpy(v22, v16, v17);
    a1[1] = v22;
    a1[2] = v15;
    a1[3] = &v22[8 * v21];
    if (v16)
    {
      operator delete(v16);
    }
  }

  else
  {
    *v14 = v8;
    v15 = v14 + 8;
  }

  a1[2] = v15;
}

void AllocaScopeInliner::~AllocaScopeInliner(AllocaScopeInliner *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t AllocaScopeInliner::matchAndRewrite(uint64_t a1, mlir::ForwardIterator *a2)
{
  v13 = &v14;
  v14 = a2;
  if (mlir::detail::walk<mlir::ForwardIterator>(a2, llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<AllocaScopeInliner::matchAndRewrite(mlir::memref::AllocaScopeOp,mlir::PatternRewriter &)::{lambda(mlir::Operation *)#1}>, &v13, 0))
  {
    goto LABEL_17;
  }

  ParentOp = *(v14 + 2);
  if (ParentOp)
  {
    ParentOp = mlir::Block::getParentOp(ParentOp);
  }

  {
    v12 = ParentOp;
    AllocaScopeInliner::matchAndRewrite();
    ParentOp = v12;
  }

  result = (*(**(ParentOp + 6) + 32))(*(ParentOp + 6), mlir::detail::TypeIDResolver<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>,void>::resolveTypeID(void)::id);
  if (result)
  {
    v5 = v14;
    v6 = *(v14 + 2);
    if (*(v14 + 1) == (v6 + 32))
    {
      if (mlir::Block::getTerminator(v6, v4))
      {
        return 0;
      }
    }

    else
    {
      v7 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(*(v14 + 1), v4);
      if (v7 != mlir::Block::getTerminator(*(v5 + 2), v8))
      {
        return 0;
      }
    }

    Parent = mlir::Block::getParent(*(v5 + 2));
    v10 = *(Parent + 8);
    if (v10 == Parent)
    {
      return 0;
    }

    v11 = 1;
    do
    {
      v10 = *(v10 + 8);
      --v11;
    }

    while (v10 != Parent);
    if (v11)
    {
      return 0;
    }

LABEL_17:
    AllocaScopeInliner::matchAndRewrite();
    return 1;
  }

  return result;
}

uint64_t AllocaScopeInliner::matchAndRewrite(mlir::memref::AllocaScopeOp,mlir::PatternRewriter &)const::{lambda(mlir::Operation *)#1}::operator()(void **a1, uint64_t a2)
{
  v16[20] = *MEMORY[0x1E69E9840];
  if (**a1 == a2)
  {
    return 1;
  }

  {
    mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::memref::AllocaScopeReturnOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>();
  }

  if ((*(**(a2 + 48) + 32))(*(a2 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>,void>::resolveTypeID(void)::id))
  {
    goto LABEL_5;
  }

  if (!mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor(a2))
  {
    v11 = 0;
    InterfaceFor = 0;
    return 0;
  }

  v11 = a2;
  InterfaceFor = mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  if (!a2)
  {
    return 0;
  }

  v5 = *(a2 + 36);
  if (v5)
  {
    v6 = a2 - 16;
  }

  else
  {
    v6 = 0;
  }

  if (v5)
  {
    for (i = 0; v5 != i; ++i)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, i);
      v14 = v16;
      v15 = 0x400000000;
      mlir::RegionBranchOpInterface::getEntrySuccessorOperands(&v11, &v14);
      v8 = llvm::find_if<llvm::SmallVector<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,4u> &,std::optional<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>> mlir::MemoryEffectOpInterface::getEffectOnValue<mlir::MemoryEffects::Allocate>(mlir::Value)::{lambda(llvm::SmallVector<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,4u> & &)#1}>(&v14, &NextResultAtOffset);
      v9 = (v14 + 40 * v15);
      if (v8 != v9)
      {
        v2 = v8[1];
      }

      if (v14 != v16)
      {
        free(v14);
      }

      if (v8 != v9)
      {
        v10 = v2[1];
        {
          if (v10 == mlir::detail::TypeIDResolver<mlir::SideEffects::AutomaticAllocationScopeResource,void>::resolveTypeID(void)::id)
          {
            return 0;
          }
        }

        else
        {
          AllocaScopeInliner::matchAndRewrite(mlir::memref::AllocaScopeOp,mlir::PatternRewriter &)const::{lambda(mlir::Operation *)#1}::operator()();
          if (v10 == mlir::detail::TypeIDResolver<mlir::SideEffects::AutomaticAllocationScopeResource,void>::resolveTypeID(void)::id)
          {
            return 0;
          }
        }
      }
    }
  }

LABEL_5:
  {
    AllocaScopeInliner::matchAndRewrite();
  }

  if ((*(**(a2 + 48) + 32))(*(a2 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>,void>::resolveTypeID(void)::id))
  {
    return 2;
  }

  else
  {
    return 1;
  }
}

void AllocaScopeHoister::~AllocaScopeHoister(AllocaScopeHoister *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t AllocaScopeHoister::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v42[6] = *MEMORY[0x1E69E9840];
  result = mlir::Operation::getParentWithTrait<mlir::OpTrait::AutomaticAllocationScope>(a2);
  if (!result)
  {
    return result;
  }

  result = *(a2 + 16);
  if (!result)
  {
    return result;
  }

  result = mlir::Block::getParentOp(result);
  if (!result)
  {
    return result;
  }

  v6 = result;
  {
    mlir::Operation::getParentWithTrait<mlir::OpTrait::AutomaticAllocationScope>();
  }

  if ((*(**(v6 + 48) + 32))(*(v6 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>,void>::resolveTypeID(void)::id))
  {
    return 0;
  }

  v8 = *(a2 + 16);
  if (*(a2 + 8) == (v8 + 32))
  {
    if (!mlir::Block::getTerminator(v8, v7))
    {
      goto LABEL_11;
    }

    return 0;
  }

  v9 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(*(a2 + 8), v7);
  if (v9 != mlir::Block::getTerminator(*(a2 + 16), v10))
  {
    return 0;
  }

LABEL_11:
  Parent = mlir::Block::getParent(*(a2 + 16));
  v13 = *(Parent + 8);
  if (v13 == Parent)
  {
    return 0;
  }

  v14 = 1;
  do
  {
    v13 = *(v13 + 8);
    --v14;
  }

  while (v13 != Parent);
  if (v14)
  {
    return 0;
  }

  v15 = *(v6 + 16);
  if (*(v6 + 8) == (v15 + 32))
  {
    v16 = 0;
  }

  else
  {
    v16 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(*(v6 + 8), v12);
    v15 = *(v6 + 16);
  }

  if (v16 != mlir::Block::getTerminator(v15, v12))
  {
    return 0;
  }

  v17 = mlir::Block::getParent(*(v6 + 16));
  v18 = *(v17 + 8);
  if (v18 == v17)
  {
    return 0;
  }

  v19 = 1;
  do
  {
    v18 = *(v18 + 8);
    --v19;
  }

  while (v18 != v17);
  if (v19)
  {
    return 0;
  }

  while (1)
  {
    ParentOp = *(v6 + 16);
    if (ParentOp)
    {
      ParentOp = mlir::Block::getParentOp(ParentOp);
    }

    {
      v26 = ParentOp;
      mlir::Operation::getParentWithTrait<mlir::OpTrait::AutomaticAllocationScope>();
      ParentOp = v26;
    }

    if ((*(**(ParentOp + 6) + 32))(*(ParentOp + 6), mlir::detail::TypeIDResolver<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>,void>::resolveTypeID(void)::id))
    {
      break;
    }

    result = *(v6 + 16);
    if (!result)
    {
      return result;
    }

    result = mlir::Block::getParentOp(result);
    if (!result)
    {
      return result;
    }

    v6 = result;
    v21 = *(result + 16);
    if (*(v6 + 8) == (v21 + 32))
    {
      v22 = 0;
    }

    else
    {
      v22 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(*(v6 + 8), v20);
      v21 = *(v6 + 16);
    }

    if (v22 != mlir::Block::getTerminator(v21, v20))
    {
      return 0;
    }

    v23 = mlir::Block::getParent(*(v6 + 16));
    v24 = *(v23 + 8);
    if (v24 == v23)
    {
      return 0;
    }

    v25 = 1;
    do
    {
      v24 = *(v24 + 8);
      --v25;
    }

    while (v24 != v23);
    result = 0;
    if (v25)
    {
      return result;
    }
  }

  v28 = *(v6 + 44);
  v29 = 0;
  if ((v28 & 0x7FFFFF) != 0)
  {
    v30 = (((v6 + 16 * ((v28 >> 23) & 1) + ((v28 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v6 + 40));
    v31 = 24 * (v28 & 0x7FFFFF);
    do
    {
      v32 = *(a2 + 16);
      if (v32)
      {
        v33 = mlir::Block::getParent(v32);
      }

      else
      {
        v33 = 0;
      }

      if (v30 == v33 || mlir::Region::isProperAncestor(v30, v33))
      {
        v29 = v30;
      }

      v30 = (v30 + 24);
      v31 -= 24;
    }

    while (v31);
  }

  v39[1] = &v40;
  v40 = v42;
  v41 = 0x600000000;
  v38 = v29;
  v39[0] = &v38;
  mlir::detail::walk<mlir::ForwardIterator>(a2, llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<AllocaScopeHoister::matchAndRewrite(mlir::memref::AllocaScopeOp,mlir::PatternRewriter &)::{lambda(mlir::Operation *)#1}>, v39, 1);
  if (v41)
  {
    v35 = *(v6 + 16);
    v36 = MPSGraphDelegateCompiler.precompilationDescriptor.modify(v6, v34);
    *(a3 + 24) = v35;
    *(a3 + 32) = v36;
    if (v41)
    {
      mlir::OpBuilder::clone((a3 + 8), *v40);
    }

    result = 1;
  }

  else
  {
    result = 0;
  }

  if (v40 != v42)
  {
    v37 = result;
    free(v40);
    return v37;
  }

  return result;
}

uint64_t AllocaScopeHoister::matchAndRewrite(mlir::memref::AllocaScopeOp,mlir::PatternRewriter &)const::{lambda(mlir::Operation *)#1}::operator()(uint64_t *a1, uint64_t a2)
{
  v23[20] = *MEMORY[0x1E69E9840];
  if (!mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor(a2))
  {
    v18 = 0;
    InterfaceFor = 0;
    return 2;
  }

  if (!a2)
  {
    v18 = 0;
    InterfaceFor = 0;
    return 2;
  }

  v16 = a1;
  v18 = a2;
  InterfaceFor = mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  v4 = *(a2 + 36);
  if (v4)
  {
    v5 = a2 - 16;
  }

  else
  {
    v5 = 0;
  }

  if (!v4)
  {
    return 2;
  }

  v6 = 0;
  while (1)
  {
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, v6);
    v21 = v23;
    v22 = 0x400000000;
    mlir::RegionBranchOpInterface::getEntrySuccessorOperands(&v18, &v21);
    v7 = llvm::find_if<llvm::SmallVector<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,4u> &,std::optional<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>> mlir::MemoryEffectOpInterface::getEffectOnValue<mlir::MemoryEffects::Allocate>(mlir::Value)::{lambda(llvm::SmallVector<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,4u> & &)#1}>(&v21, &NextResultAtOffset);
    v8 = (v21 + 40 * v22);
    if (v7 != v8)
    {
      a1 = v7[1];
    }

    if (v21 != v23)
    {
      free(v21);
    }

    if (v7 == v8)
    {
      goto LABEL_12;
    }

    v9 = a1[1];
    {
      break;
    }

    AllocaScopeInliner::matchAndRewrite(mlir::memref::AllocaScopeOp,mlir::PatternRewriter &)const::{lambda(mlir::Operation *)#1}::operator()();
    if (v9 == mlir::detail::TypeIDResolver<mlir::SideEffects::AutomaticAllocationScopeResource,void>::resolveTypeID(void)::id)
    {
      goto LABEL_20;
    }

LABEL_12:
    if (v4 == ++v6)
    {
      return 2;
    }
  }

  if (v9 != mlir::detail::TypeIDResolver<mlir::SideEffects::AutomaticAllocationScopeResource,void>::resolveTypeID(void)::id)
  {
    goto LABEL_12;
  }

LABEL_20:
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v10 = *(a2 + 68);
    if (v10)
    {
      v11 = *v16;
      v12 = (*(a2 + 72) + 24);
      do
      {
        v21 = *v12;
        v13 = *v11;
        ParentRegion = mlir::Value::getParentRegion(&v21);
        if (v13 == ParentRegion || (mlir::Region::isProperAncestor(v13, ParentRegion) & 1) != 0)
        {
          return 2;
        }

        v12 += 4;
      }

      while (--v10);
    }
  }

  AllocaScopeHoister::matchAndRewrite(mlir::memref::AllocaScopeOp,mlir::PatternRewriter &)const::{lambda(mlir::Operation *)#1}::operator()(v16, a2);
  return 1;
}

void anonymous namespace::FoldCopyOfCast::~FoldCopyOfCast(_anonymous_namespace_::FoldCopyOfCast *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t anonymous namespace::FoldCopyOfCast::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v39 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v39);
  if (!DefiningOp || *(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::memref::CastOp,void>::id)
  {
    goto LABEL_15;
  }

  v6 = *(*(*(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v7 = *(*v6 + 136);
  if (v7 != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
  {
    v6 = 0;
  }

  v38 = v6;
  v39 = v6;
  if (v7 == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id && (v8 = DefiningOp, Value = mlir::ArrayAttr::getValue(&v39), v11 = v10, v12 = mlir::ArrayAttr::getValue(&v38), v11 == v13) && !memcmp(Value, v12, 8 * v11) && (RHS = mlir::AffineBinaryOpExpr::getRHS(&v39), RHS == mlir::AffineBinaryOpExpr::getRHS(&v38)))
  {
    (*(*a3 + 40))(a3, a2);
    v15 = *(a2 + 72);
    v16 = *(*(v8 + 72) + 24);
    v17 = v15[1];
    if (v17)
    {
      v18 = *v15;
      *v17 = *v15;
      if (v18)
      {
        *(v18 + 8) = v17;
      }
    }

    v15[3] = v16;
    v15[1] = v16;
    v19 = *v16;
    *v15 = *v16;
    if (v19)
    {
      *(v19 + 8) = v15;
    }

    *v16 = v15;
    (*(*a3 + 48))(a3, a2);
    v20 = 1;
  }

  else
  {
LABEL_15:
    v20 = 0;
  }

  v39 = *(*(a2 + 72) + 56);
  v21 = mlir::Value::getDefiningOp(&v39);
  if (v21 && *(*(v21 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::CastOp,void>::id)
  {
    v22 = *(*(*(v21 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
    v23 = *(*v22 + 136);
    if (v23 != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
    {
      v22 = 0;
    }

    v38 = v22;
    v39 = v22;
    if (v23 == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
    {
      v24 = v21;
      v25 = mlir::ArrayAttr::getValue(&v39);
      v27 = v26;
      v28 = mlir::ArrayAttr::getValue(&v38);
      if (v27 == v29 && !memcmp(v25, v28, 8 * v27))
      {
        v30 = mlir::AffineBinaryOpExpr::getRHS(&v39);
        if (v30 == mlir::AffineBinaryOpExpr::getRHS(&v38))
        {
          (*(*a3 + 40))(a3, a2);
          v31 = *(a2 + 72);
          v32 = *(*(v24 + 72) + 24);
          v33 = v31 + 4;
          v34 = v31[5];
          if (v34)
          {
            v35 = *v33;
            *v34 = *v33;
            if (v35)
            {
              *(v35 + 8) = v34;
            }
          }

          v31[7] = v32;
          v31[5] = v32;
          v36 = *v32;
          v31[4] = *v32;
          if (v36)
          {
            *(v36 + 8) = v33;
          }

          *v32 = v33;
          (*(*a3 + 48))(a3, a2);
          return 1;
        }
      }
    }
  }

  return v20;
}

void anonymous namespace::FoldEmptyCopy::~FoldEmptyCopy(_anonymous_namespace_::FoldEmptyCopy *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t anonymous namespace::FoldEmptyCopy::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v14 = *(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (mlir::BaseMemRefType::hasRank(&v14))
  {
    Value = mlir::ArrayAttr::getValue(&v14);
    if (v6)
    {
      v7 = 8 * v6;
      v8 = Value;
      while (*v8)
      {
        ++v8;
        v7 -= 8;
        if (!v7)
        {
          goto LABEL_9;
        }
      }
    }

    else
    {
      v8 = Value;
    }

    if (v8 != (Value + 8 * v6))
    {
      goto LABEL_17;
    }
  }

LABEL_9:
  v14 = *(*(*(a2 + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (mlir::BaseMemRefType::hasRank(&v14))
  {
    v9 = mlir::ArrayAttr::getValue(&v14);
    if (v10)
    {
      v11 = 8 * v10;
      for (i = v9; *i; ++i)
      {
        v11 -= 8;
        if (!v11)
        {
          return 0;
        }
      }
    }

    else
    {
      i = v9;
    }

    if (i != (v9 + 8 * v10))
    {
LABEL_17:
      (*(*a3 + 16))(a3, a2);
      return 1;
    }
  }

  return 0;
}

void anonymous namespace::FoldSelfCopy::~FoldSelfCopy(_anonymous_namespace_::FoldSelfCopy *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t anonymous namespace::FoldSelfCopy::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(*(a2 + 72) + 24) != *(*(a2 + 72) + 56))
  {
    return 0;
  }

  (*(*a3 + 16))(a3);
  return 1;
}

void anonymous namespace::DimOfMemRefReshape::~DimOfMemRefReshape(_anonymous_namespace_::DimOfMemRefReshape *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t anonymous namespace::DimOfMemRefReshape::matchAndRewrite(uint64_t a1, void *a2, uint64_t a3)
{
  v23[0] = *(a2[9] + 24);
  DefiningOp = mlir::Value::getDefiningOp(v23);
  if (!DefiningOp || (v6 = DefiningOp, *(*(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::memref::ReshapeOp,void>::id))
  {
    v7 = "Dim op is not defined by a reshape op.";
LABEL_4:
    v23[0] = v7;
    v24 = 259;
    v25 = v23;
    v8 = *(a3 + 16);
    if (v8)
    {
      if (mlir::RewriterBase::Listener::classof(v8))
      {
        (*(*v8 + 88))(v8, a2[3], llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::memref::DimOp &>(mlir::memref::DimOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v25);
      }
    }

    return 0;
  }

  v23[0] = *(a2[9] + 56);
  ParentBlock = mlir::Value::getParentBlock(v23);
  v12 = *(v6 + 16);
  if (ParentBlock == v12)
  {
    v23[0] = *(a2[9] + 56);
    v16 = mlir::Value::getDefiningOp(v23);
    if (v16 && mlir::Operation::isBeforeInBlock(v6, v16))
    {
      v7 = "dim.getIndex is not defined before reshape in the same block.";
      goto LABEL_4;
    }
  }

  else if (a2[2] != v12)
  {
    v23[0] = *(a2[9] + 56);
    ParentRegion = mlir::Value::getParentRegion(v23);
    if (*(v6 + 16))
    {
      v14 = ParentRegion;
      Parent = mlir::Block::getParent(*(v6 + 16));
      if ((mlir::Region::isProperAncestor(v14, Parent) & 1) == 0)
      {
        goto LABEL_20;
      }
    }

    else if ((mlir::Region::isProperAncestor(ParentRegion, 0) & 1) == 0)
    {
LABEL_20:
      v7 = "dim.getIndex does not dominate reshape.";
      goto LABEL_4;
    }
  }

  v17 = *(v6 + 16);
  v18 = *(MPSGraphDelegateCompiler.precompilationDescriptor.modify(v6, v11) + 8);
  *(a3 + 24) = v17;
  *(a3 + 32) = v18;
  v19 = a2[3];
  v25 = *(*(v6 + 72) + 56);
  v22 = *(a2[9] + 56);
  v20 = mlir::OpBuilder::create<mlir::memref::LoadOp,mlir::detail::TypedValue<mlir::MemRefType>,mlir::detail::TypedValue<mlir::IndexType>>((a3 + 8), v19, &v25, &v22);
  v23[0] = v20 - 16;
  v21 = *(a2 - 1);
  if ((v21 ^ *(v20 - 8)) >= 8)
  {
    v25 = (v21 & 0xFFFFFFFFFFFFFFF8);
    v23[0] = mlir::OpBuilder::create<mlir::arith::IndexCastOp,mlir::IndexType,mlir::Value &>((a3 + 8), v19, &v25, v23) - 16;
  }

  (**a3)(a3, a2, v23, 1);
  return 1;
}

uint64_t mlir::OpBuilder::create<mlir::memref::LoadOp,mlir::detail::TypedValue<mlir::MemRefType>,mlir::detail::TypedValue<mlir::IndexType>>(mlir::BoolAttr **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v17[38] = *MEMORY[0x1E69E9840];
  v14 = a2;
  Context = mlir::Attribute::getContext(&v14);
  v9 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::LoadOp,void>::id, Context);
  if ((v10 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::LoadOp,mlir::detail::TypedValue<mlir::MemRefType>,mlir::detail::TypedValue<mlir::IndexType>>(v17, v16, v15);
  }

  mlir::OperationState::OperationState(v17, a2, v9);
  mlir::memref::LoadOp::build(a1, v17, *a3, a4, 1uLL, 0);
  v11 = mlir::OpBuilder::create(a1, v17);
  if (*(*(v11 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::LoadOp,void>::id)
  {
    v12 = v11;
  }

  else
  {
    v12 = 0;
  }

  mlir::OperationState::~OperationState(v17);
  return v12;
}

uint64_t mlir::OpBuilder::create<mlir::arith::IndexCastOp,mlir::IndexType,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v17[38] = *MEMORY[0x1E69E9840];
  v14 = a2;
  Context = mlir::Attribute::getContext(&v14);
  v9 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::arith::IndexCastOp,void>::id, Context);
  if ((v10 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::arith::IndexCastOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(v17, v16, v15);
  }

  mlir::OperationState::OperationState(v17, a2, v9);
  mlir::arith::BitcastOp::build(a1, v17, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, v17);
  if (*(*(v11 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::IndexCastOp,void>::id)
  {
    v12 = v11;
  }

  else
  {
    v12 = 0;
  }

  mlir::OperationState::~OperationState(v17);
  return v12;
}

uint64_t llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::memref::GenericAtomicRMWOp::verify(void)::$_0>(uint64_t a1, mlir *a2)
{
  v23 = *MEMORY[0x1E69E9840];
  if (mlir::isMemoryEffectFree(a2, a2))
  {
    return 1;
  }

  v12 = "body of 'memref.generic_atomic_rmw' should contain only operations with no side effects";
  v13 = 259;
  mlir::Operation::emitError(a2, &v12, v14);
  if (v14[0])
  {
    mlir::InFlightDiagnostic::report(v14);
  }

  if (v22 == 1)
  {
    if (v21 != &v22)
    {
      free(v21);
    }

    v4 = __p;
    if (__p)
    {
      v5 = v20;
      v6 = __p;
      if (v20 != __p)
      {
        do
        {
          v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v5 - 1);
        }

        while (v5 != v4);
        v6 = __p;
      }

      v20 = v4;
      operator delete(v6);
    }

    v7 = v17;
    if (v17)
    {
      v8 = v18;
      v9 = v17;
      if (v18 != v17)
      {
        do
        {
          v11 = *--v8;
          v10 = v11;
          *v8 = 0;
          if (v11)
          {
            operator delete[](v10);
          }
        }

        while (v8 != v7);
        v9 = v17;
      }

      v18 = v7;
      operator delete(v9);
    }

    if (v15 != &v16)
    {
      free(v15);
    }
  }

  return 0;
}

void anonymous namespace::ReinterpretCastOpExtractStridedMetadataFolder::~ReinterpretCastOpExtractStridedMetadataFolder(_anonymous_namespace_::ReinterpretCastOpExtractStridedMetadataFolder *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t anonymous namespace::ReinterpretCastOpExtractStridedMetadataFolder::matchAndRewrite(uint64_t a1, uint64_t a2, void (***a3)(void, uint64_t, unint64_t *, uint64_t))
{
  v56[6] = *MEMORY[0x1E69E9840];
  v46 = a2;
  v54 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v54);
  v5 = DefiningOp;
  if (!DefiningOp)
  {
    return v5;
  }

  v6 = *(*(DefiningOp + 48) + 16);
  v7 = v6 == &mlir::detail::TypeIDResolver<mlir::memref::ExtractStridedMetadataOp,void>::id;
  if (v6 == &mlir::detail::TypeIDResolver<mlir::memref::ExtractStridedMetadataOp,void>::id)
  {
    v8 = DefiningOp;
  }

  else
  {
    v8 = 0;
  }

  v45 = v8;
  if (!v7)
  {
    return 0;
  }

  v9 = *(DefiningOp + 36);
  v10 = (v9 - 2) >> 1;
  if (v9)
  {
    v11 = DefiningOp - 16;
  }

  else
  {
    v11 = 0;
  }

  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, v10 + 2);
  mlir::ValueRange::ValueRange(&v51, NextResultAtOffset, v10 + 2 + v10 - (v10 + 2));
  mlir::getAsOpFoldResult(v51, v52, &v54);
  v13 = *(*(*(v5 + 72) + 24) + 8);
  Context = mlir::Attribute::getContext((v5 + 24));
  constifyIndexValues(&v54, v13 & 0xFFFFFFFFFFFFFFF8, Context, llvm::function_ref<llvm::SmallVector<long long,6u> ()(mlir::MemRefType)>::callback_fn<llvm::SmallVector<long long,6u> ()(mlir::MemRefType)>, getConstantStrides, llvm::function_ref<BOOL ()(long long)>::callback_fn<BOOL ()(long long)>, mlir::ShapedType::isDynamic);
  mlir::memref::ReinterpretCastOp::getConstifiedMixedStrides(&v46, &v51);
  if (v55 != v52)
  {
    goto LABEL_32;
  }

  if (*(v46 + 36))
  {
    v15 = v46 - 16;
  }

  else
  {
    v15 = 0;
  }

  v49[0] = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ArrayAttr::getValue(v49);
  v17 = v16;
  if (!v16)
  {
LABEL_18:
    v24 = *(v5 + 36);
    if (v24)
    {
      v25 = v5 - 16;
    }

    else
    {
      v25 = 0;
    }

    v26 = mlir::detail::OpResultImpl::getNextResultAtOffset(v25, 2);
    mlir::ValueRange::ValueRange(v47, v26, (v24 - 2) >> 1);
    mlir::getAsOpFoldResult(v47[0], v47[1], v49);
    v27 = *(*(*(v5 + 72) + 24) + 8);
    v28 = mlir::Attribute::getContext((v5 + 24));
    constifyIndexValues(v49, v27 & 0xFFFFFFFFFFFFFFF8, v28, llvm::function_ref<llvm::SmallVector<long long,6u> ()(mlir::MemRefType)>::callback_fn<llvm::SmallVector<long long,6u> ()(mlir::MemRefType)>, getConstantSizes, llvm::function_ref<BOOL ()(long long)>::callback_fn<BOOL ()(long long)>, mlir::ShapedType::isDynamic);
    mlir::memref::ReinterpretCastOp::getConstifiedMixedSizes(&v46, v47);
    if (v17)
    {
      v29 = v49[0];
      v30 = v47[0];
      while (1)
      {
        v32 = *v29++;
        v31 = v32;
        v33 = *v30++;
        if (v31 != v33)
        {
          break;
        }

        if (!--v17)
        {
          goto LABEL_25;
        }
      }

LABEL_33:
      v5 = 0;
      v39 = v47[0];
      if (v47[0] == v48)
      {
        goto LABEL_35;
      }

      goto LABEL_34;
    }

LABEL_25:
    ConstifiedMixedOffset = mlir::memref::ExtractStridedMetadataOp::getConstifiedMixedOffset(&v45);
    if (ConstifiedMixedOffset != mlir::memref::ReinterpretCastOp::getConstifiedMixedOffset(&v46))
    {
      goto LABEL_33;
    }

    if (*(v46 + 36))
    {
      v36 = v46 - 16;
    }

    else
    {
      v36 = 0;
    }

    v35 = *(*(*(v5 + 72) + 24) + 8);
    v37 = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v36, 0) + 8) ^ v35;
    v38 = v46;
    if (v37 > 7)
    {
      if (*(v46 + 36))
      {
        v41 = v46 - 16;
      }

      else
      {
        v41 = 0;
      }

      v42 = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v41, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      v43 = *(*(v5 + 72) + 24);
      v44 = v42;
      mlir::RewriterBase::replaceOpWithNewOp<mlir::memref::CastOp,mlir::MemRefType,mlir::detail::TypedValue<mlir::MemRefType>>(a3, v38, &v44, &v43);
      v5 = 1;
      v39 = v47[0];
      if (v47[0] == v48)
      {
LABEL_35:
        if (v49[0] != &v50)
        {
          free(v49[0]);
        }

        goto LABEL_37;
      }
    }

    else
    {
      v44 = *(*(v5 + 72) + 24);
      v5 = 1;
      (**a3)(a3, v46, &v44, 1);
      v39 = v47[0];
      if (v47[0] == v48)
      {
        goto LABEL_35;
      }
    }

LABEL_34:
    free(v39);
    goto LABEL_35;
  }

  v18 = v54;
  v19 = v51;
  v20 = v16;
  while (1)
  {
    v22 = *v18++;
    v21 = v22;
    v23 = *v19++;
    if (v21 != v23)
    {
      break;
    }

    if (!--v20)
    {
      goto LABEL_18;
    }
  }

LABEL_32:
  v5 = 0;
LABEL_37:
  if (v51 != &v53)
  {
    free(v51);
  }

  if (v54 != v56)
  {
    free(v54);
  }

  return v5;
}

uint64_t mlir::RewriterBase::replaceOpWithNewOp<mlir::memref::CastOp,mlir::MemRefType,mlir::detail::TypedValue<mlir::MemRefType>>(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v6 = mlir::OpBuilder::create<mlir::memref::CastOp,mlir::MemRefType,mlir::detail::TypedValue<mlir::MemRefType>>((a1 + 8), *(a2 + 24), a3, a4);
  (*(*a1 + 8))(a1, a2, v6);
  return v6;
}

uint64_t mlir::OpBuilder::create<mlir::memref::CastOp,mlir::MemRefType,mlir::detail::TypedValue<mlir::MemRefType>>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v23[28] = *MEMORY[0x1E69E9840];
  v16 = a2;
  Context = mlir::Attribute::getContext(&v16);
  v9 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::CastOp,void>::id, Context);
  if ((v10 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::CastOp,mlir::MemRefType,mlir::memref::AllocOp &>(v19, v18, v17);
  }

  mlir::OperationState::OperationState(v19, a2, v9);
  v11 = *a3;
  v18[0] = *a4;
  mlir::OperationState::addOperands(v19, v18, 1uLL);
  v12 = v21;
  if (v21 >= v22)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v20, v23, v21 + 1, 8);
    v12 = v21;
  }

  *(v20 + 8 * v12) = v11;
  ++v21;
  v13 = mlir::OpBuilder::create(a1, v19);
  if (*(*(v13 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::CastOp,void>::id)
  {
    v14 = v13;
  }

  else
  {
    v14 = 0;
  }

  mlir::OperationState::~OperationState(v19);
  return v14;
}

void llvm::SmallVectorImpl<llvm::SmallVector<mlir::OpFoldResult,6u>>::assign(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a1 + 8);
  if (v6)
  {
    v7 = v6 << 6;
    v8 = (v7 + *a1 - 64);
    v9 = -v7;
    do
    {
      if (v8 + 2 != *v8)
      {
        free(*v8);
      }

      v8 -= 8;
      v9 += 64;
    }

    while (v9);
  }

  *(a1 + 8) = 0;
  v10 = a3 << 6 >> 6;
  if (v10 > *(a1 + 12))
  {
    llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::OpFoldResult,6u>,false>::grow(a1, v10);
    v11 = *(a1 + 8);
    v12 = *(a1 + 8);
    v13 = a3 << 6;
    if (!a3)
    {
      goto LABEL_21;
    }

    goto LABEL_10;
  }

  v11 = 0;
  v12 = 0;
  v13 = a3 << 6;
  if (a3)
  {
LABEL_10:
    v14 = 0;
    v15 = *a1 + (v11 << 6);
    v16 = a3 << 6;
    while (1)
    {
      v18 = (v15 + v14);
      v19 = (v15 + v14 + 16);
      *v18 = v19;
      v18[1] = 0x600000000;
      if (a2 == v15)
      {
        goto LABEL_14;
      }

      v20 = a2 + v14;
      v21 = *(a2 + v14 + 8);
      if (!*(a2 + v14 + 8))
      {
        goto LABEL_14;
      }

      if (v21 < 7)
      {
        v17 = *(a2 + v14 + 8);
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v15 + v14, v15 + v14 + 16, *(a2 + v14 + 8), 8);
        v17 = *(v20 + 8);
        if (!v17)
        {
          goto LABEL_13;
        }

        v19 = *v18;
      }

      memcpy(v19, *v20, 8 * v17);
LABEL_13:
      *(v18 + 2) = v21;
LABEL_14:
      v14 += 64;
      if (v16 == v14)
      {
        v12 = *(a1 + 8);
        break;
      }
    }
  }

LABEL_21:
  *(a1 + 8) = v12 + (v13 >> 6);
}

uint64_t llvm::SmallVectorImpl<llvm::SmallVector<mlir::AffineExpr,2u>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    v4 = a2 + 16;
    v5 = *a2;
    if (*a2 != a2 + 16)
    {
      v6 = *a1;
      v7 = *(a1 + 8);
      if (v7)
      {
        v8 = 32 * v7;
        v9 = &v6[v8 - 16];
        v10 = -v8;
        do
        {
          v11 = *(v9 - 16);
          if (v9 != v11)
          {
            free(v11);
          }

          v9 -= 32;
          v10 += 32;
        }

        while (v10);
        v6 = *a1;
      }

      if (v6 != (a1 + 16))
      {
        free(v6);
      }

      *a1 = *a2;
      v12 = (a2 + 8);
      *(a1 + 8) = *(a2 + 8);
      *a2 = v4;
      *(a2 + 12) = 0;
LABEL_12:
      *v12 = 0;
      return a1;
    }

    v12 = (a2 + 8);
    v14 = *(a2 + 8);
    v15 = *(a1 + 8);
    if (v15 < v14)
    {
      if (*(a1 + 12) >= v14)
      {
        if (!v15)
        {
          v15 = 0;
          v24 = *a2;
          v25 = *(a2 + 8);
          if (*(a2 + 8))
          {
LABEL_32:
            v26 = *a1;
            v27 = 32 * v15;
            v28 = 32 * v25;
            do
            {
              v29 = &v26[v27];
              *v29 = &v26[v27 + 16];
              *(v29 + 1) = 0x200000000;
              if (LODWORD(v24[v27 / 8 + 1]))
              {
                llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v29, &v24[v27 / 8]);
              }

              v26 += 32;
              v28 -= 32;
              v24 += 4;
            }

            while (v27 != v28);
            v24 = *a2;
          }

LABEL_37:
          *(a1 + 8) = v14;
          v30 = *v12;
          if (v30)
          {
            v31 = 4 * v30;
            v32 = &v24[v31 - 2];
            v33 = -(v31 * 8);
            do
            {
              v34 = *(v32 - 16);
              if (v32 != v34)
              {
                free(v34);
              }

              v32 -= 32;
              v33 += 32;
            }

            while (v33);
          }

          goto LABEL_12;
        }

        v22 = *a1;
        v23 = 32 * v15;
        do
        {
          llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v22, v5);
          v5 += 4;
          v22 += 32;
          v23 -= 32;
        }

        while (v23);
      }

      else
      {
        if (v15)
        {
          v16 = 32 * v15 + *a1 - 16;
          v17 = -32 * v15;
          do
          {
            v18 = *(v16 - 16);
            if (v16 != v18)
            {
              free(v18);
            }

            v16 -= 32;
            v17 += 32;
          }

          while (v17);
        }

        *(a1 + 8) = 0;
        llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::AffineExpr,2u>,false>::grow(a1, v14);
        v15 = 0;
      }

      v24 = *a2;
      v25 = *(a2 + 8);
      if (v15 != v25)
      {
        goto LABEL_32;
      }

      goto LABEL_37;
    }

    v19 = *a1;
    if (v14)
    {
      v20 = 32 * v14;
      do
      {
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v19, v5);
        v5 += 4;
        v19 += 32;
        v20 -= 32;
      }

      while (v20);
      v21 = *a1 + 32 * *(a1 + 8);
      if (v21 == v19)
      {
LABEL_47:
        *(a1 + 8) = v14;
        v38 = *(a2 + 8);
        if (v38)
        {
          v39 = 32 * v38;
          v40 = v39 + *a2 - 16;
          v41 = -v39;
          do
          {
            v42 = *(v40 - 16);
            if (v40 != v42)
            {
              free(v42);
            }

            v40 -= 32;
            v41 += 32;
          }

          while (v41);
        }

        goto LABEL_12;
      }
    }

    else
    {
      v21 = v19 + 32 * v15;
      if (v21 == v19)
      {
        goto LABEL_47;
      }
    }

    v35 = (v21 - 16);
    do
    {
      v37 = *(v35 - 2);
      if (v35 != v37)
      {
        free(v37);
      }

      v36 = v35 - 16;
      v35 -= 32;
    }

    while (v36 != v19);
    goto LABEL_47;
  }

  return a1;
}

void mlir::RewritePatternSet::addImpl<mlir::ComposeReassociativeReshapeOps<mlir::memref::ExpandShapeOp,(mlir::ReshapeOpKind)0>,mlir::MLIRContext *&>(void *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  v8 = operator new(0x60uLL);
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v31, 1);
  mlir::Pattern::Pattern((v8 + 1), "memref.expand_shape", 19, v31, v9, 0, 0);
  *v8 = &unk_1F5AFA868;
  if (v8[9])
  {
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v31 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ComposeReassociativeReshapeOps<mlir::memref::ExpandShapeOp, mlir::ReshapeOpKind::kExpand>]";
    v32 = 145;
    v23 = llvm::StringRef::find(&v31, "DesiredTypeName = ", 0x12uLL, 0);
    if (v32 >= v23)
    {
      v24 = v23;
    }

    else
    {
      v24 = v32;
    }

    v25 = &v31[v24];
    v26 = v32 - v24;
    if (v32 - v24 >= 0x12)
    {
      v27 = 18;
    }

    else
    {
      v27 = v32 - v24;
    }

    v28 = &v25[v27];
    v29 = v26 - v27;
    if (v29 >= v29 - 1)
    {
      --v29;
    }

    v8[8] = v28;
    v8[9] = v29;
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
LABEL_3:
      if (!a3)
      {
        goto LABEL_5;
      }

      goto LABEL_4;
    }
  }

  llvm::SmallVectorBase<unsigned int>::grow_pod((v8 + 10), (v8 + 12), v12, 16);
  LODWORD(v11) = *(v8 + 22);
  if (a3)
  {
LABEL_4:
    memcpy((v8[10] + 16 * v11), a2, v10);
    LODWORD(v11) = *(v8 + 22);
  }

LABEL_5:
  *(v8 + 22) = v11 + (v10 >> 4);
  v14 = a1[2];
  v13 = a1[3];
  if (v14 >= v13)
  {
    v16 = a1[1];
    v17 = v14 - v16;
    v18 = (v14 - v16) >> 3;
    v19 = v18 + 1;
    if ((v18 + 1) >> 61)
    {
      std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
    }

    v20 = v13 - v16;
    if (v20 >> 2 > v19)
    {
      v19 = v20 >> 2;
    }

    if (v20 >= 0x7FFFFFFFFFFFFFF8)
    {
      v21 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v21 = v19;
    }

    if (v21)
    {
      if (v21 >> 61)
      {
        std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
      }

      v22 = operator new(8 * v21);
    }

    else
    {
      v22 = 0;
    }

    v30 = &v22[8 * v18];
    *v30 = v8;
    v15 = v30 + 8;
    memcpy(v22, v16, v17);
    a1[1] = v22;
    a1[2] = v15;
    a1[3] = &v22[8 * v21];
    if (v16)
    {
      operator delete(v16);
    }
  }

  else
  {
    *v14 = v8;
    v15 = v14 + 8;
  }

  a1[2] = v15;
}

void mlir::RewritePatternSet::addImpl<mlir::ComposeExpandOfCollapseOp<mlir::memref::ExpandShapeOp,mlir::memref::CollapseShapeOp>,mlir::MLIRContext *&>(void *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  v8 = operator new(0x60uLL);
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v31, 1);
  mlir::Pattern::Pattern((v8 + 1), "memref.expand_shape", 19, v31, v9, 0, 0);
  *v8 = &unk_1F5AFA908;
  if (v8[9])
  {
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v31 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ComposeExpandOfCollapseOp<mlir::memref::ExpandShapeOp, mlir::memref::CollapseShapeOp>]";
    v32 = 141;
    v23 = llvm::StringRef::find(&v31, "DesiredTypeName = ", 0x12uLL, 0);
    if (v32 >= v23)
    {
      v24 = v23;
    }

    else
    {
      v24 = v32;
    }

    v25 = &v31[v24];
    v26 = v32 - v24;
    if (v32 - v24 >= 0x12)
    {
      v27 = 18;
    }

    else
    {
      v27 = v32 - v24;
    }

    v28 = &v25[v27];
    v29 = v26 - v27;
    if (v29 >= v29 - 1)
    {
      --v29;
    }

    v8[8] = v28;
    v8[9] = v29;
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
LABEL_3:
      if (!a3)
      {
        goto LABEL_5;
      }

      goto LABEL_4;
    }
  }

  llvm::SmallVectorBase<unsigned int>::grow_pod((v8 + 10), (v8 + 12), v12, 16);
  LODWORD(v11) = *(v8 + 22);
  if (a3)
  {
LABEL_4:
    memcpy((v8[10] + 16 * v11), a2, v10);
    LODWORD(v11) = *(v8 + 22);
  }

LABEL_5:
  *(v8 + 22) = v11 + (v10 >> 4);
  v14 = a1[2];
  v13 = a1[3];
  if (v14 >= v13)
  {
    v16 = a1[1];
    v17 = v14 - v16;
    v18 = (v14 - v16) >> 3;
    v19 = v18 + 1;
    if ((v18 + 1) >> 61)
    {
      std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
    }

    v20 = v13 - v16;
    if (v20 >> 2 > v19)
    {
      v19 = v20 >> 2;
    }

    if (v20 >= 0x7FFFFFFFFFFFFFF8)
    {
      v21 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v21 = v19;
    }

    if (v21)
    {
      if (v21 >> 61)
      {
        std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
      }

      v22 = operator new(8 * v21);
    }

    else
    {
      v22 = 0;
    }

    v30 = &v22[8 * v18];
    *v30 = v8;
    v15 = v30 + 8;
    memcpy(v22, v16, v17);
    a1[1] = v22;
    a1[2] = v15;
    a1[3] = &v22[8 * v21];
    if (v16)
    {
      operator delete(v16);
    }
  }

  else
  {
    *v14 = v8;
    v15 = v14 + 8;
  }

  a1[2] = v15;
}

void *mlir::ComposeReassociativeReshapeOps<mlir::memref::ExpandShapeOp,(mlir::ReshapeOpKind)0>::~ComposeReassociativeReshapeOps(void *a1)
{
  v2 = a1[10];
  if (v2 != a1 + 12)
  {
    free(v2);
  }

  v3 = a1[4];
  if (v3 != a1 + 6)
  {
    free(v3);
  }

  return a1;
}

void mlir::ComposeReassociativeReshapeOps<mlir::memref::ExpandShapeOp,(mlir::ReshapeOpKind)0>::~ComposeReassociativeReshapeOps(void *__p)
{
  v2 = __p[10];
  if (v2 != __p + 12)
  {
    free(v2);
  }

  v3 = __p[4];
  if (v3 != __p + 6)
  {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::ComposeReassociativeReshapeOps<mlir::memref::ExpandShapeOp,(mlir::ReshapeOpKind)0>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  v47 = *MEMORY[0x1E69E9840];
  v36 = a2;
  v40 = *(*(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp(&v40);
  if (result)
  {
    v6 = *(*(result + 48) + 16);
    v7 = v6 == &mlir::detail::TypeIDResolver<mlir::memref::ExpandShapeOp,void>::id;
    if (v6 == &mlir::detail::TypeIDResolver<mlir::memref::ExpandShapeOp,void>::id)
    {
      v8 = result;
    }

    else
    {
      v8 = 0;
    }

    v35 = v8;
    if (!v7)
    {
      return 0;
    }

    v9 = *(a2 + 36) ? a2 - 16 : 0;
    v40 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    v34[0] = llvm::cast<mlir::ShapedType,mlir::Type>(&v40);
    v34[1] = v10;
    if (mlir::hasNonIdentityLayout(*(*(*(v35 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0 || (mlir::hasNonIdentityLayout(*(*(*(v36 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      return 0;
    }

    v11 = *(v36 + 36) ? v36 - 16 : 0;
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
    if (mlir::hasNonIdentityLayout(*(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      return 0;
    }

    mlir::memref::CollapseShapeOp::getReassociationIndices(&v35, &v40);
    v13 = v40;
    v14 = v41;
    mlir::memref::CollapseShapeOp::getReassociationIndices(&v36, &v37);
    mlir::composeReassociationIndices(v13, v14, v37, v38, &v43);
    v15 = v37;
    if (v38)
    {
      v16 = v37 + 32 * v38 - 16;
      v17 = -32 * v38;
      do
      {
        v18 = *(v16 - 2);
        if (v16 != v18)
        {
          free(v18);
        }

        v16 -= 32;
        v17 += 32;
      }

      while (v17);
      v15 = v37;
    }

    if (v15 != &v39)
    {
      free(v15);
    }

    v19 = v40;
    if (v41)
    {
      v20 = v40 + 32 * v41 - 16;
      v21 = -32 * v41;
      do
      {
        v22 = *(v20 - 2);
        if (v20 != v22)
        {
          free(v22);
        }

        v20 -= 32;
        v21 += 32;
      }

      while (v21);
      v19 = v40;
    }

    if (v19 != v42)
    {
      free(v19);
    }

    if (v46 != 1)
    {
      return 0;
    }

    else
    {
      v40 = *(v36 + 16 * ((*(v36 + 44) >> 23) & 1) + 72);
      v23 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&v40);
      v25 = v24;
      if ((*(v36 + 46) & 0x80) != 0)
      {
        v26 = *(v36 + 72);
        v27 = *(v36 + 68) - 1;
      }

      else
      {
        v26 = 0;
        v27 = -1;
      }

      mlir::ValueRange::ValueRange(&v37, v26 + 32, v27);
      mlir::getMixedValues(v23, v25, v37, v38, a3 + 1, &v40);
      v28 = v36;
      v37 = *(*(v35 + 72) + 24);
      v29 = mlir::OpBuilder::create<mlir::memref::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(a3 + 1, *(v36 + 24), v34, &v37, &v43, &v40);
      ((*a3)[1])(a3, v28, v29);
      if (v40 != v42)
      {
        free(v40);
      }

      if (v46)
      {
        v30 = v43;
        if (v44)
        {
          v31 = &v43[4 * v44 - 2];
          v32 = -32 * v44;
          do
          {
            v33 = *(v31 - 16);
            if (v31 != v33)
            {
              free(v33);
            }

            v31 -= 32;
            v32 += 32;
          }

          while (v32);
          v30 = v43;
        }

        if (v30 != &v45)
        {
          free(v30);
        }
      }

      return 1;
    }
  }

  return result;
}

uint64_t mlir::RewriterBase::replaceOpWithNewOp<mlir::memref::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(uint64_t **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  v8 = mlir::OpBuilder::create<mlir::memref::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(a1 + 1, *(a2 + 24), a3, a4, a5, a6);
  ((*a1)[1])(a1, a2, v8);
  return v8;
}

uint64_t std::optional<llvm::SmallVector<llvm::SmallVector<long long,2u>,1u>>::~optional(uint64_t a1)
{
  if (*(a1 + 48) == 1)
  {
    v2 = *a1;
    v3 = *(a1 + 8);
    if (v3)
    {
      v4 = 32 * v3;
      v5 = v2 + v4 - 16;
      v6 = -v4;
      do
      {
        v7 = *(v5 - 16);
        if (v5 != v7)
        {
          free(v7);
        }

        v5 -= 32;
        v6 += 32;
      }

      while (v6);
      v2 = *a1;
    }

    if (v2 != (a1 + 16))
    {
      free(v2);
    }
  }

  return a1;
}

uint64_t mlir::OpBuilder::create<mlir::memref::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(uint64_t **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  v21[38] = *MEMORY[0x1E69E9840];
  v18 = a2;
  Context = mlir::Attribute::getContext(&v18);
  v13 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::ExpandShapeOp,void>::id, Context);
  if ((v14 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(v21, v20, v19);
  }

  mlir::OperationState::OperationState(v21, a2, v13);
  mlir::memref::ExpandShapeOp::build(a1, v21, *a3, *a4, *a5, *(a5 + 8), *a6, *(a6 + 8));
  v15 = mlir::OpBuilder::create(a1, v21);
  if (*(*(v15 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::ExpandShapeOp,void>::id)
  {
    v16 = v15;
  }

  else
  {
    v16 = 0;
  }

  mlir::OperationState::~OperationState(v21);
  return v16;
}

void *mlir::ComposeExpandOfCollapseOp<mlir::memref::ExpandShapeOp,mlir::memref::CollapseShapeOp>::~ComposeExpandOfCollapseOp(void *a1)
{
  v2 = a1[10];
  if (v2 != a1 + 12)
  {
    free(v2);
  }

  v3 = a1[4];
  if (v3 != a1 + 6)
  {
    free(v3);
  }

  return a1;
}

void mlir::ComposeExpandOfCollapseOp<mlir::memref::ExpandShapeOp,mlir::memref::CollapseShapeOp>::~ComposeExpandOfCollapseOp(void *__p)
{
  v2 = __p[10];
  if (v2 != __p + 12)
  {
    free(v2);
  }

  v3 = __p[4];
  if (v3 != __p + 6)
  {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::ComposeExpandOfCollapseOp<mlir::memref::ExpandShapeOp,mlir::memref::CollapseShapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  v67[16] = *MEMORY[0x1E69E9840];
  v56 = a2;
  v65 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v65);
  if (!DefiningOp)
  {
    return 0;
  }

  v6 = *(*(DefiningOp + 48) + 16);
  v7 = v6 == &mlir::detail::TypeIDResolver<mlir::memref::CollapseShapeOp,void>::id;
  v8 = v6 == &mlir::detail::TypeIDResolver<mlir::memref::CollapseShapeOp,void>::id ? DefiningOp : 0;
  v55 = v8;
  if (!v7)
  {
    return 0;
  }

  v9 = DefiningOp;
  v65 = (*(*(*(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v54[0] = llvm::cast<mlir::ShapedType,mlir::Type>(&v65);
  v54[1] = v10;
  v11 = *(a2 + 36) ? a2 - 16 : 0;
  v65 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v53[0] = llvm::cast<mlir::ShapedType,mlir::Type>(&v65);
  v53[1] = v12;
  if (mlir::hasNonIdentityLayout(*(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0 || (mlir::hasNonIdentityLayout(*(*(*(v9 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    return 0;
  }

  v13 = *(v9 + 36) ? v9 - 16 : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v13, 0);
  if (mlir::hasNonIdentityLayout(*(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    return 0;
  }

  mlir::CallableOpInterface::getArgAttrsAttr(v54);
  v16 = v15;
  mlir::CallableOpInterface::getArgAttrsAttr(v53);
  if (v54[0] == v53[0])
  {
    return 0;
  }

  v18 = v17;
  mlir::memref::CollapseShapeOp::getReassociationIndices(&v55, &v65);
  mlir::memref::CollapseShapeOp::getReassociationIndices(&v56, &v62);
  if (v16 <= v18)
  {
    v31 = v62;
    v32 = v63;
    v33 = v65;
    v34 = v66;
    ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr(v53);
    v37 = v36;
    v38 = mlir::CallableOpInterface::getArgAttrsAttr(v54);
    mlir::ComposeExpandOfCollapseOp<mlir::memref::ExpandShapeOp,mlir::memref::CollapseShapeOp>::findCollapsingReassociation(v31, v32, v33, v34, ArgAttrsAttr, v37, v60, v38, v39);
    if (v61 == 1)
    {
      v58[0] = *(v56 + 16 * ((*(v56 + 44) >> 23) & 1) + 72);
      v40 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(v58);
      v42 = v41;
      if ((*(v56 + 46) & 0x80) != 0)
      {
        v43 = *(v56 + 72);
        v44 = *(v56 + 68) - 1;
      }

      else
      {
        v43 = 0;
        v44 = -1;
      }

      mlir::ValueRange::ValueRange(v57, v43 + 32, v44);
      mlir::getMixedValues(v40, v42, v57[0], v57[1], a3 + 1, v58);
      v57[0] = *(*(v55 + 72) + 24);
      mlir::RewriterBase::replaceOpWithNewOp<mlir::memref::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(a3, v56, v53, v57, v60, v58);
      if (v58[0] != v59)
      {
        free(v58[0]);
      }

      v28 = 1;
    }

    else
    {
      v28 = 0;
    }

    v29 = v60;
  }

  else
  {
    v19 = v65;
    v20 = v66;
    v21 = v62;
    v22 = v63;
    v23 = mlir::CallableOpInterface::getArgAttrsAttr(v54);
    v25 = v24;
    v26 = mlir::CallableOpInterface::getArgAttrsAttr(v53);
    mlir::ComposeExpandOfCollapseOp<mlir::memref::ExpandShapeOp,mlir::memref::CollapseShapeOp>::findCollapsingReassociation(v19, v20, v21, v22, v23, v25, v58, v26, v27);
    if (v59[32] == 1)
    {
      v60[0] = *(*(v55 + 72) + 24);
      mlir::RewriterBase::replaceOpWithNewOp<mlir::memref::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(a3, v56, v53, v60, v58);
      v28 = 1;
    }

    else
    {
      v28 = 0;
    }

    v29 = v58;
  }

  std::optional<llvm::SmallVector<llvm::SmallVector<long long,2u>,1u>>::~optional(v29);
  v45 = v62;
  if (v63)
  {
    v46 = v62 + 32 * v63 - 16;
    v47 = -32 * v63;
    do
    {
      v48 = *(v46 - 2);
      if (v46 != v48)
      {
        free(v48);
      }

      v46 -= 32;
      v47 += 32;
    }

    while (v47);
    v45 = v62;
  }

  if (v45 != &v64)
  {
    free(v45);
  }

  v49 = v65;
  if (v66)
  {
    v50 = &v65[4 * v66 - 2];
    v51 = -32 * v66;
    do
    {
      v52 = *(v50 - 2);
      if (v50 != v52)
      {
        free(v52);
      }

      v50 -= 4;
      v51 += 32;
    }

    while (v51);
    v49 = v65;
  }

  if (v49 != v67)
  {
    free(v49);
  }

  return v28;
}

void mlir::ComposeExpandOfCollapseOp<mlir::memref::ExpandShapeOp,mlir::memref::CollapseShapeOp>::findCollapsingReassociation(uint64_t **a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t a7@<X8>, uint64_t a8, unint64_t a9)
{
  v9 = a5;
  v10 = a8;
  v68[16] = *MEMORY[0x1E69E9840];
  v66 = v68;
  v67 = 0x400000000;
  if (!a2)
  {
    mlir::getReassociationIndicesForCollapse(a5, a6, a8, a9, a7);
    v47 = v66;
    goto LABEL_67;
  }

  v11 = a3;
  v12 = a1;
  v57 = &a1[4 * a2];
  v58 = a3 + 32 * a4;
  v55 = a5 + 16;
  v54 = vnegq_f64(0);
LABEL_4:
  if (v11 != v58)
  {
    v13 = **v12;
    v14 = *(v12 + 2);
    v15 = v9 + 8 * v13;
    v16 = *(v11 + 8);
    v17 = (v10 + 8 * **v11);
    if (v14 != v16)
    {
LABEL_18:
      mlir::getReassociationIndicesForCollapse(v9 + 8 * v13, v14, v17, v16, &v62);
      if ((v65 & 1) == 0)
      {
LABEL_61:
        *a7 = 0;
        *(a7 + 48) = 0;
        v47 = v66;
        v48 = v67;
        if (!v67)
        {
          goto LABEL_67;
        }

        goto LABEL_62;
      }

      v28 = v62;
      if (!v63)
      {
        v10 = a8;
        v9 = a5;
LABEL_52:
        if (v28 != v64)
        {
          goto LABEL_55;
        }

        goto LABEL_3;
      }

      v29 = v62 + 32 * v63;
      while (1)
      {
        v59 = v61;
        v60 = 0x200000000;
        v30 = *(v28 + 2);
        if (v30)
        {
          v31 = 0;
          v32 = *v28;
          v33 = 8 * v30;
          do
          {
            v34 = *v32;
            v35 = **v12;
            if (v31 >= HIDWORD(v60))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(&v59, v61, v31 + 1, 8);
              v31 = v60;
            }

            *(v59 + v31) = v35 + v34;
            v31 = v60 + 1;
            LODWORD(v60) = v60 + 1;
            ++v32;
            v33 -= 8;
          }

          while (v33);
        }

        v36 = v66;
        if (v67 >= HIDWORD(v67))
        {
          if (v66 <= &v59 && v66 + 32 * v67 > &v59)
          {
            v43 = &v59 - v66;
            llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(&v66, v67 + 1);
            v36 = v66;
            v37 = (v66 + v43);
          }

          else
          {
            llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(&v66, v67 + 1);
            v37 = &v59;
            v36 = v66;
          }
        }

        else
        {
          v37 = &v59;
        }

        v38 = &v36[32 * v67];
        v39 = v38 + 2;
        *v38 = v38 + 2;
        v38[1] = 0x200000000;
        v40 = *(v37 + 2);
        if (v38 == v37 || v40 == 0)
        {
          goto LABEL_39;
        }

        if (v40 < 3)
        {
          break;
        }

        llvm::SmallVectorBase<unsigned int>::grow_pod(v38, (v38 + 2), *(v37 + 2), 8);
        v42 = *(v37 + 2);
        if (v42)
        {
          v39 = *v38;
LABEL_37:
          memcpy(v39, *v37, 8 * v42);
        }

        *(v38 + 2) = v40;
LABEL_39:
        LODWORD(v67) = v67 + 1;
        if (v59 != v61)
        {
          free(v59);
        }

        v28 += 32;
        if (v28 == v29)
        {
          v10 = a8;
          v9 = a5;
          if ((v65 & 1) == 0)
          {
            goto LABEL_3;
          }

          v28 = v62;
          if (!v63)
          {
            goto LABEL_52;
          }

          v44 = v62 + 32 * v63 - 16;
          v45 = -32 * v63;
          do
          {
            v46 = *(v44 - 2);
            if (v44 != v46)
            {
              free(v46);
            }

            v44 -= 32;
            v45 += 32;
          }

          while (v45);
          v28 = v62;
          if (v62 != v64)
          {
LABEL_55:
            free(v28);
          }

LABEL_3:
          v12 += 4;
          v11 += 32;
          if (v12 == v57)
          {
            goto LABEL_57;
          }

          goto LABEL_4;
        }
      }

      v42 = *(v37 + 2);
      goto LABEL_37;
    }

    if (memcmp((v9 + 8 * v13), v17, 8 * v14))
    {
      goto LABEL_61;
    }

    if (!v14)
    {
LABEL_17:
      llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::push_back(&v66, v12);
      goto LABEL_18;
    }

    v18 = (v14 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v18 >= 3)
    {
      v21 = v18 + 1;
      v22 = (v18 + 1) & 0x3FFFFFFFFFFFFFFCLL;
      v20 = (v15 + 8 * v22);
      v23 = (v55 + 8 * v13);
      v24 = 0uLL;
      v25 = v22;
      v26 = 0uLL;
      do
      {
        v24 = vsubq_s64(v24, vceqq_s64(v23[-1], v54));
        v26 = vsubq_s64(v26, vceqq_s64(*v23, v54));
        v23 += 2;
        v25 -= 4;
      }

      while (v25);
      v19 = vaddvq_s64(vaddq_s64(v26, v24));
      if (v21 == v22)
      {
        goto LABEL_16;
      }
    }

    else
    {
      v19 = 0;
      v20 = (v9 + 8 * v13);
    }

    do
    {
      v27 = *v20++;
      if (v27 == 0x8000000000000000)
      {
        ++v19;
      }
    }

    while (v20 != (v15 + 8 * v14));
LABEL_16:
    if (v19 > 1)
    {
      goto LABEL_61;
    }

    goto LABEL_17;
  }

LABEL_57:
  *a7 = a7 + 16;
  *(a7 + 8) = 0x100000000;
  if (v67)
  {
    llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=(a7, &v66);
  }

  *(a7 + 48) = 1;
  v47 = v66;
  v48 = v67;
  if (v67)
  {
LABEL_62:
    v49 = 4 * v48;
    v50 = &v47[v49 - 2];
    v51 = -(v49 * 8);
    do
    {
      v52 = *(v50 - 16);
      if (v50 != v52)
      {
        free(v52);
      }

      v50 -= 32;
      v51 += 32;
    }

    while (v51);
    v47 = v66;
  }

LABEL_67:
  if (v47 != v68)
  {
    free(v47);
  }
}

uint64_t mlir::RewriterBase::replaceOpWithNewOp<mlir::memref::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(uint64_t **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v7 = mlir::OpBuilder::create<mlir::memref::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(a1 + 1, *(a2 + 24), a3, a4, a5);
  ((*a1)[1])(a1, a2, v7);
  return v7;
}

uint64_t mlir::OpBuilder::create<mlir::memref::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(uint64_t **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v32 = *MEMORY[0x1E69E9840];
  v23 = a2;
  Context = mlir::Attribute::getContext(&v23);
  v11 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::CollapseShapeOp,void>::id, Context);
  if ((v12 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(v27, &v29, v24);
  }

  mlir::OperationState::OperationState(v27, a2, v11);
  v13 = *a3;
  v14 = *a5;
  v15 = *(a5 + 8);
  v25 = *a4;
  v26 = v13;
  ReassociationIndicesAttribute = mlir::getReassociationIndicesAttribute(a1, v14, v15);
  v17 = mlir::Attribute::getContext(v27);
  v31 = 261;
  v29 = "reassociation";
  v30 = 13;
  v18 = mlir::StringAttr::get(v17, &v29);
  mlir::NamedAttribute::NamedAttribute(v24, v18, ReassociationIndicesAttribute);
  mlir::NamedAttrList::push_back(&v28, v24[0], v24[1]);
  v19 = mlir::ValueRange::ValueRange(&v29, &v26, 1uLL);
  mlir::memref::CollapseShapeOp::build(v19, v27, v29, v30, &v25, 1uLL, 0, 0);
  v20 = mlir::OpBuilder::create(a1, v27);
  if (*(*(v20 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::CollapseShapeOp,void>::id)
  {
    v21 = v20;
  }

  else
  {
    v21 = 0;
  }

  mlir::OperationState::~OperationState(v27);
  return v21;
}

void mlir::RewritePatternSet::addImpl<mlir::ComposeReassociativeReshapeOps<mlir::memref::CollapseShapeOp,(mlir::ReshapeOpKind)1>,mlir::MLIRContext *&>(void *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  v8 = operator new(0x60uLL);
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v31, 1);
  mlir::Pattern::Pattern((v8 + 1), "memref.collapse_shape", 21, v31, v9, 0, 0);
  *v8 = &unk_1F5AFA978;
  if (v8[9])
  {
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v31 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ComposeReassociativeReshapeOps<mlir::memref::CollapseShapeOp, mlir::ReshapeOpKind::kCollapse>]";
    v32 = 149;
    v23 = llvm::StringRef::find(&v31, "DesiredTypeName = ", 0x12uLL, 0);
    if (v32 >= v23)
    {
      v24 = v23;
    }

    else
    {
      v24 = v32;
    }

    v25 = &v31[v24];
    v26 = v32 - v24;
    if (v32 - v24 >= 0x12)
    {
      v27 = 18;
    }

    else
    {
      v27 = v32 - v24;
    }

    v28 = &v25[v27];
    v29 = v26 - v27;
    if (v29 >= v29 - 1)
    {
      --v29;
    }

    v8[8] = v28;
    v8[9] = v29;
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
LABEL_3:
      if (!a3)
      {
        goto LABEL_5;
      }

      goto LABEL_4;
    }
  }

  llvm::SmallVectorBase<unsigned int>::grow_pod((v8 + 10), (v8 + 12), v12, 16);
  LODWORD(v11) = *(v8 + 22);
  if (a3)
  {
LABEL_4:
    memcpy((v8[10] + 16 * v11), a2, v10);
    LODWORD(v11) = *(v8 + 22);
  }

LABEL_5:
  *(v8 + 22) = v11 + (v10 >> 4);
  v14 = a1[2];
  v13 = a1[3];
  if (v14 >= v13)
  {
    v16 = a1[1];
    v17 = v14 - v16;
    v18 = (v14 - v16) >> 3;
    v19 = v18 + 1;
    if ((v18 + 1) >> 61)
    {
      std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
    }

    v20 = v13 - v16;
    if (v20 >> 2 > v19)
    {
      v19 = v20 >> 2;
    }

    if (v20 >= 0x7FFFFFFFFFFFFFF8)
    {
      v21 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v21 = v19;
    }

    if (v21)
    {
      if (v21 >> 61)
      {
        std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
      }

      v22 = operator new(8 * v21);
    }

    else
    {
      v22 = 0;
    }

    v30 = &v22[8 * v18];
    *v30 = v8;
    v15 = v30 + 8;
    memcpy(v22, v16, v17);
    a1[1] = v22;
    a1[2] = v15;
    a1[3] = &v22[8 * v21];
    if (v16)
    {
      operator delete(v16);
    }
  }

  else
  {
    *v14 = v8;
    v15 = v14 + 8;
  }

  a1[2] = v15;
}

void mlir::RewritePatternSet::addImpl<mlir::ComposeCollapseOfExpandOp<mlir::memref::CollapseShapeOp,mlir::memref::ExpandShapeOp,mlir::memref::CastOp,mlir::memref::DimOp,mlir::MemRefType>,mlir::MLIRContext *&>(void *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  v8 = operator new(0x60uLL);
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v31, 1);
  mlir::Pattern::Pattern((v8 + 1), "memref.collapse_shape", 21, v31, v9, 0, 0);
  *v8 = &unk_1F5AFAA18;
  if (v8[9])
  {
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v31 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ComposeCollapseOfExpandOp<mlir::memref::CollapseShapeOp, mlir::memref::ExpandShapeOp, mlir::memref::CastOp, mlir::memref::DimOp, mlir::MemRefType>]";
    v32 = 202;
    v23 = llvm::StringRef::find(&v31, "DesiredTypeName = ", 0x12uLL, 0);
    if (v32 >= v23)
    {
      v24 = v23;
    }

    else
    {
      v24 = v32;
    }

    v25 = &v31[v24];
    v26 = v32 - v24;
    if (v32 - v24 >= 0x12)
    {
      v27 = 18;
    }

    else
    {
      v27 = v32 - v24;
    }

    v28 = &v25[v27];
    v29 = v26 - v27;
    if (v29 >= v29 - 1)
    {
      --v29;
    }

    v8[8] = v28;
    v8[9] = v29;
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
LABEL_3:
      if (!a3)
      {
        goto LABEL_5;
      }

      goto LABEL_4;
    }
  }

  llvm::SmallVectorBase<unsigned int>::grow_pod((v8 + 10), (v8 + 12), v12, 16);
  LODWORD(v11) = *(v8 + 22);
  if (a3)
  {
LABEL_4:
    memcpy((v8[10] + 16 * v11), a2, v10);
    LODWORD(v11) = *(v8 + 22);
  }

LABEL_5:
  *(v8 + 22) = v11 + (v10 >> 4);
  v14 = a1[2];
  v13 = a1[3];
  if (v14 >= v13)
  {
    v16 = a1[1];
    v17 = v14 - v16;
    v18 = (v14 - v16) >> 3;
    v19 = v18 + 1;
    if ((v18 + 1) >> 61)
    {
      std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
    }

    v20 = v13 - v16;
    if (v20 >> 2 > v19)
    {
      v19 = v20 >> 2;
    }

    if (v20 >= 0x7FFFFFFFFFFFFFF8)
    {
      v21 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v21 = v19;
    }

    if (v21)
    {
      if (v21 >> 61)
      {
        std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
      }

      v22 = operator new(8 * v21);
    }

    else
    {
      v22 = 0;
    }

    v30 = &v22[8 * v18];
    *v30 = v8;
    v15 = v30 + 8;
    memcpy(v22, v16, v17);
    a1[1] = v22;
    a1[2] = v15;
    a1[3] = &v22[8 * v21];
    if (v16)
    {
      operator delete(v16);
    }
  }

  else
  {
    *v14 = v8;
    v15 = v14 + 8;
  }

  a1[2] = v15;
}

void mlir::RewritePatternSet::addImpl<CollapseShapeOpMemRefCastFolder,mlir::MLIRContext *&>(void *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  v8 = operator new(0x60uLL);
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v31, 1);
  mlir::Pattern::Pattern((v8 + 1), "memref.collapse_shape", 21, v31, v9, 0, 0);
  *v8 = &unk_1F5AFAA88;
  if (v8[9])
  {
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v31 = "StringRef llvm::getTypeName() [DesiredTypeName = CollapseShapeOpMemRefCastFolder]";
    v32 = 81;
    v23 = llvm::StringRef::find(&v31, "DesiredTypeName = ", 0x12uLL, 0);
    if (v32 >= v23)
    {
      v24 = v23;
    }

    else
    {
      v24 = v32;
    }

    v25 = &v31[v24];
    v26 = v32 - v24;
    if (v32 - v24 >= 0x12)
    {
      v27 = 18;
    }

    else
    {
      v27 = v32 - v24;
    }

    v28 = &v25[v27];
    v29 = v26 - v27;
    if (v29 >= v29 - 1)
    {
      --v29;
    }

    v8[8] = v28;
    v8[9] = v29;
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
LABEL_3:
      if (!a3)
      {
        goto LABEL_5;
      }

      goto LABEL_4;
    }
  }

  llvm::SmallVectorBase<unsigned int>::grow_pod((v8 + 10), (v8 + 12), v12, 16);
  LODWORD(v11) = *(v8 + 22);
  if (a3)
  {
LABEL_4:
    memcpy((v8[10] + 16 * v11), a2, v10);
    LODWORD(v11) = *(v8 + 22);
  }

LABEL_5:
  *(v8 + 22) = v11 + (v10 >> 4);
  v14 = a1[2];
  v13 = a1[3];
  if (v14 >= v13)
  {
    v16 = a1[1];
    v17 = v14 - v16;
    v18 = (v14 - v16) >> 3;
    v19 = v18 + 1;
    if ((v18 + 1) >> 61)
    {
      std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
    }

    v20 = v13 - v16;
    if (v20 >> 2 > v19)
    {
      v19 = v20 >> 2;
    }

    if (v20 >= 0x7FFFFFFFFFFFFFF8)
    {
      v21 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v21 = v19;
    }

    if (v21)
    {
      if (v21 >> 61)
      {
        std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
      }

      v22 = operator new(8 * v21);
    }

    else
    {
      v22 = 0;
    }

    v30 = &v22[8 * v18];
    *v30 = v8;
    v15 = v30 + 8;
    memcpy(v22, v16, v17);
    a1[1] = v22;
    a1[2] = v15;
    a1[3] = &v22[8 * v21];
    if (v16)
    {
      operator delete(v16);
    }
  }

  else
  {
    *v14 = v8;
    v15 = v14 + 8;
  }

  a1[2] = v15;
}

void *mlir::ComposeReassociativeReshapeOps<mlir::memref::CollapseShapeOp,(mlir::ReshapeOpKind)1>::~ComposeReassociativeReshapeOps(void *a1)
{
  v2 = a1[10];
  if (v2 != a1 + 12)
  {
    free(v2);
  }

  v3 = a1[4];
  if (v3 != a1 + 6)
  {
    free(v3);
  }

  return a1;
}

void mlir::ComposeReassociativeReshapeOps<mlir::memref::CollapseShapeOp,(mlir::ReshapeOpKind)1>::~ComposeReassociativeReshapeOps(void *__p)
{
  v2 = __p[10];
  if (v2 != __p + 12)
  {
    free(v2);
  }

  v3 = __p[4];
  if (v3 != __p + 6)
  {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::ComposeReassociativeReshapeOps<mlir::memref::CollapseShapeOp,(mlir::ReshapeOpKind)1>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  v43 = *MEMORY[0x1E69E9840];
  v32 = a2;
  v36 = *(*(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp(&v36);
  if (result)
  {
    v6 = *(*(result + 48) + 16);
    v7 = v6 == &mlir::detail::TypeIDResolver<mlir::memref::CollapseShapeOp,void>::id;
    if (v6 == &mlir::detail::TypeIDResolver<mlir::memref::CollapseShapeOp,void>::id)
    {
      v8 = result;
    }

    else
    {
      v8 = 0;
    }

    v31 = v8;
    if (!v7)
    {
      return 0;
    }

    v9 = *(a2 + 36) ? a2 - 16 : 0;
    v10 = result;
    v36 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    v30[0] = llvm::cast<mlir::ShapedType,mlir::Type>(&v36);
    v30[1] = v11;
    if (mlir::hasNonIdentityLayout(*(*(*(v10 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0 || (mlir::hasNonIdentityLayout(*(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      return 0;
    }

    v12 = *(a2 + 36) ? a2 - 16 : 0;
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v12, 0);
    if (mlir::hasNonIdentityLayout(*(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      return 0;
    }

    mlir::memref::CollapseShapeOp::getReassociationIndices(&v31, &v36);
    v14 = v36;
    v15 = v37;
    mlir::memref::CollapseShapeOp::getReassociationIndices(&v32, &v33);
    mlir::composeReassociationIndices(v14, v15, v33, v34, &v39);
    v16 = v33;
    if (v34)
    {
      v17 = v33 + 32 * v34 - 16;
      v18 = -32 * v34;
      do
      {
        v19 = *(v17 - 2);
        if (v17 != v19)
        {
          free(v19);
        }

        v17 -= 32;
        v18 += 32;
      }

      while (v18);
      v16 = v33;
    }

    if (v16 != &v35)
    {
      free(v16);
    }

    v20 = v36;
    if (v37)
    {
      v21 = v36 + 32 * v37 - 16;
      v22 = -32 * v37;
      do
      {
        v23 = *(v21 - 2);
        if (v21 != v23)
        {
          free(v23);
        }

        v21 -= 32;
        v22 += 32;
      }

      while (v22);
      v20 = v36;
    }

    if (v20 != &v38)
    {
      free(v20);
    }

    if (v42 != 1)
    {
      return 0;
    }

    else
    {
      v24 = v32;
      v36 = *(*(v31 + 72) + 24);
      v25 = mlir::OpBuilder::create<mlir::memref::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(a3 + 1, *(v32 + 24), v30, &v36, &v39);
      ((*a3)[1])(a3, v24, v25);
      if (v42)
      {
        v26 = v39;
        if (v40)
        {
          v27 = &v39[4 * v40 - 2];
          v28 = -32 * v40;
          do
          {
            v29 = *(v27 - 16);
            if (v27 != v29)
            {
              free(v29);
            }

            v27 -= 32;
            v28 += 32;
          }

          while (v28);
          v26 = v39;
        }

        if (v26 != &v41)
        {
          free(v26);
        }
      }

      return 1;
    }
  }

  return result;
}

void *mlir::ComposeCollapseOfExpandOp<mlir::memref::CollapseShapeOp,mlir::memref::ExpandShapeOp,mlir::memref::CastOp,mlir::memref::DimOp,mlir::MemRefType>::~ComposeCollapseOfExpandOp(void *a1)
{
  v2 = a1[10];
  if (v2 != a1 + 12)
  {
    free(v2);
  }

  v3 = a1[4];
  if (v3 != a1 + 6)
  {
    free(v3);
  }

  return a1;
}

void mlir::ComposeCollapseOfExpandOp<mlir::memref::CollapseShapeOp,mlir::memref::ExpandShapeOp,mlir::memref::CastOp,mlir::memref::DimOp,mlir::MemRefType>::~ComposeCollapseOfExpandOp(void *__p)
{
  v2 = __p[10];
  if (v2 != __p + 12)
  {
    free(v2);
  }

  v3 = __p[4];
  if (v3 != __p + 6)
  {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::ComposeCollapseOfExpandOp<mlir::memref::CollapseShapeOp,mlir::memref::ExpandShapeOp,mlir::memref::CastOp,mlir::memref::DimOp,mlir::MemRefType>::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::IndexType **a3)
{
  v54[16] = *MEMORY[0x1E69E9840];
  v42 = a2;
  v52 = *(*(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp(&v52);
  if (!DefiningOp)
  {
    return 0;
  }

  v5 = *(*(DefiningOp + 48) + 16);
  v6 = v5 == &mlir::detail::TypeIDResolver<mlir::memref::ExpandShapeOp,void>::id;
  v7 = v5 == &mlir::detail::TypeIDResolver<mlir::memref::ExpandShapeOp,void>::id ? DefiningOp : 0;
  v41 = v7;
  if (!v6)
  {
    return 0;
  }

  v52 = (*(*(*(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v40[0] = llvm::cast<mlir::ShapedType,mlir::Type>(&v52);
  v40[1] = v8;
  v9 = *(v42 + 36) ? v42 - 16 : 0;
  v52 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v39[0] = llvm::cast<mlir::ShapedType,mlir::Type>(&v52);
  v39[1] = v10;
  if (mlir::hasNonIdentityLayout(*(*(*(v42 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0 || (mlir::hasNonIdentityLayout(*(*(*(v41 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    return 0;
  }

  v11 = *(v41 + 36) ? v41 - 16 : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  if (mlir::hasNonIdentityLayout(*(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    return 0;
  }

  mlir::CallableOpInterface::getArgAttrsAttr(v40);
  v14 = v13;
  mlir::CallableOpInterface::getArgAttrsAttr(v39);
  if (v40[0] == v39[0])
  {
    return 0;
  }

  v16 = v15;
  v52 = v54;
  v53 = 0x400000000;
  v49 = v51;
  v50 = 0x400000000;
  if (v14 <= v15)
  {
    mlir::memref::CollapseShapeOp::getReassociationIndices(&v42, &v46);
    llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=(&v52, &v46);
    llvm::SmallVector<llvm::SmallVector<long long,2u>,4u>::~SmallVector(&v46);
    mlir::memref::CollapseShapeOp::getReassociationIndices(&v41, &v46);
  }

  else
  {
    mlir::memref::CollapseShapeOp::getReassociationIndices(&v41, &v46);
    llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=(&v52, &v46);
    llvm::SmallVector<llvm::SmallVector<long long,2u>,4u>::~SmallVector(&v46);
    mlir::memref::CollapseShapeOp::getReassociationIndices(&v42, &v46);
  }

  llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=(&v49, &v46);
  llvm::SmallVector<llvm::SmallVector<long long,2u>,4u>::~SmallVector(&v46);
  v46 = v48;
  v47 = 0x400000000;
  if (v50)
  {
    v19 = 0;
    v20 = v49;
    v21 = v49 + 32 * v50;
    while (1)
    {
      v22 = 0;
      v43 = v45;
      v44 = 0x200000000;
      v23 = 4 * v19;
      while (1)
      {
        if (v19 >= v53)
        {
LABEL_30:
          llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::push_back(&v46, &v43);
          v25 = 1;
          v26 = v43;
          if (v43 == v45)
          {
            goto LABEL_32;
          }

LABEL_31:
          free(v26);
          goto LABEL_32;
        }

        v24 = *(v52[v23] + 8 * LODWORD(v52[v23 + 1]) - 8);
        if (v24 > *(*v20 + 8 * *(v20 + 2) - 8))
        {
          break;
        }

        if (v22 >= HIDWORD(v44))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v43, v45, v22 + 1, 8);
          v22 = v44;
        }

        *(v43 + v22) = v19;
        v22 = v44 + 1;
        LODWORD(v44) = v44 + 1;
        v23 += 4;
        ++v19;
        if (v24 == *(*v20 + 8 * *(v20 + 2) - 8))
        {
          goto LABEL_30;
        }
      }

      v25 = 0;
      v26 = v43;
      if (v43 != v45)
      {
        goto LABEL_31;
      }

LABEL_32:
      if ((v25 & 1) == 0)
      {
        break;
      }

      v20 += 32;
      if (v20 == v21)
      {
        goto LABEL_37;
      }
    }

    v17 = 0;
  }

  else
  {
LABEL_37:
    if (v14 <= v16)
    {
      v43 = *(*(v41 + 72) + 24);
      if (v14 < v16)
      {
        mlir::RewriterBase::replaceOpWithNewOp<mlir::memref::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,4u> &>(a3, v42, v39, &v43, &v46);
      }

      else
      {
        mlir::RewriterBase::replaceOpWithNewOp<mlir::memref::CastOp,mlir::MemRefType,mlir::detail::TypedValue<mlir::MemRefType>>(a3, v42, v39, &v43);
      }
    }

    else
    {
      v43 = *(*(v41 + 72) + 24);
      mlir::RewriterBase::replaceOpWithNewOp<mlir::memref::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(a3, v42, v39, &v43, &v46);
    }

    v17 = 1;
  }

  v27 = v46;
  if (v47)
  {
    v28 = v46 + 32 * v47 - 16;
    v29 = -32 * v47;
    do
    {
      v30 = *(v28 - 2);
      if (v28 != v30)
      {
        free(v30);
      }

      v28 -= 32;
      v29 += 32;
    }

    while (v29);
    v27 = v46;
  }

  if (v27 != v48)
  {
    free(v27);
  }

  v31 = v49;
  if (v50)
  {
    v32 = v49 + 32 * v50 - 16;
    v33 = -32 * v50;
    do
    {
      v34 = *(v32 - 2);
      if (v32 != v34)
      {
        free(v34);
      }

      v32 -= 32;
      v33 += 32;
    }

    while (v33);
    v31 = v49;
  }

  if (v31 != v51)
  {
    free(v31);
  }

  v35 = v52;
  if (v53)
  {
    v36 = &v52[4 * v53 - 2];
    v37 = -32 * v53;
    do
    {
      v38 = *(v36 - 2);
      if (v36 != v38)
      {
        free(v38);
      }

      v36 -= 4;
      v37 += 32;
    }

    while (v37);
    v35 = v52;
  }

  if (v35 != v54)
  {
    free(v35);
  }

  return v17;
}

uint64_t mlir::RewriterBase::replaceOpWithNewOp<mlir::memref::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,4u> &>(mlir::IndexType **a1, uint64_t a2, void **a3, uint64_t *a4, uint64_t a5)
{
  v7 = mlir::OpBuilder::create<mlir::memref::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,4u> &>(a1 + 1, *(a2 + 24), a3, a4, a5);
  (*(*a1 + 1))(a1, a2, v7);
  return v7;
}

uint64_t mlir::OpBuilder::create<mlir::memref::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,4u> &>(mlir::IndexType **a1, uint64_t a2, void **a3, uint64_t *a4, uint64_t a5)
{
  v19[38] = *MEMORY[0x1E69E9840];
  v16 = a2;
  Context = mlir::Attribute::getContext(&v16);
  v11 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::ExpandShapeOp,void>::id, Context);
  if ((v12 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(v19, v18, v17);
  }

  mlir::OperationState::OperationState(v19, a2, v11);
  mlir::memref::ExpandShapeOp::build(a1, v19, *a3, *a4, *a5, *(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, v19);
  if (*(*(v13 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::ExpandShapeOp,void>::id)
  {
    v14 = v13;
  }

  else
  {
    v14 = 0;
  }

  mlir::OperationState::~OperationState(v19);
  return v14;
}

void CollapseShapeOpMemRefCastFolder::~CollapseShapeOpMemRefCastFolder(CollapseShapeOpMemRefCastFolder *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t CollapseShapeOpMemRefCastFolder::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  v32[16] = *MEMORY[0x1E69E9840];
  v4 = *(*(a2 + 72) + 24);
  v29 = a2;
  v30 = v4;
  result = mlir::Value::getDefiningOp(&v30);
  if (result)
  {
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::CastOp,void>::id)
    {
      v6 = result;
    }

    else
    {
      v6 = 0;
    }

    if (v6)
    {
      result = mlir::memref::CastOp::canFoldIntoConsumerOp(v6);
      if (result)
      {
        v7 = *(*(*(v6 + 72) + 24) + 8);
        mlir::memref::CollapseShapeOp::getReassociationIndices(&v29, &v30);
        v8 = mlir::memref::CollapseShapeOp::computeCollapsedType(v7 & 0xFFFFFFFFFFFFFFF8, v30, v31);
        v9 = v30;
        if (v31)
        {
          v10 = v30 + 32 * v31 - 16;
          v11 = -32 * v31;
          do
          {
            v12 = *(v10 - 2);
            if (v10 != v12)
            {
              free(v12);
            }

            v10 -= 32;
            v11 += 32;
          }

          while (v11);
          v9 = v30;
        }

        if (v9 != v32)
        {
          free(v9);
        }

        if (*(v29 + 36))
        {
          v13 = v29 - 16;
        }

        else
        {
          v13 = 0;
        }

        if (v8 == (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v13, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
        {
          v14 = v29;
          ((*a3)[5])(a3, v29);
          v15 = *(v29 + 72);
          v16 = *(*(v6 + 72) + 24);
          v17 = v15[1];
          if (v17)
          {
            v18 = *v15;
            *v17 = *v15;
            if (v18)
            {
              *(v18 + 8) = v17;
            }
          }

          v15[3] = v16;
          v15[1] = v16;
          v19 = *v16;
          *v15 = *v16;
          if (v19)
          {
            *(v19 + 8) = v15;
          }

          *v16 = v15;
          ((*a3)[6])(a3, v14);
        }

        else
        {
          v20 = *(v29 + 24);
          v27 = *(*(v6 + 72) + 24);
          mlir::memref::CollapseShapeOp::getReassociationIndices(&v29, &v30);
          v28 = mlir::OpBuilder::create<mlir::memref::CollapseShapeOp,mlir::detail::TypedValue<mlir::BaseMemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,4u>>(a3 + 1, v20, &v27, &v30) - 16;
          v21 = v30;
          if (v31)
          {
            v22 = v30 + 32 * v31 - 16;
            v23 = -32 * v31;
            do
            {
              v24 = *(v22 - 2);
              if (v22 != v24)
              {
                free(v24);
              }

              v22 -= 32;
              v23 += 32;
            }

            while (v23);
            v21 = v30;
          }

          if (v21 != v32)
          {
            free(v21);
          }

          v25 = v29;
          v30 = (*(v29 - 8) & 0xFFFFFFFFFFFFFFF8);
          v26 = mlir::OpBuilder::create<mlir::memref::CastOp,mlir::MemRefType,mlir::detail::TypedValue<mlir::MemRefType>>((a3 + 1), *(v29 + 24), &v30, &v28);
          ((*a3)[1])(a3, v25, v26);
        }

        return 1;
      }
    }

    else
    {
      return 0;
    }
  }

  return result;
}

uint64_t mlir::OpBuilder::create<mlir::memref::CollapseShapeOp,mlir::detail::TypedValue<mlir::BaseMemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,4u>>(uint64_t **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v17[38] = *MEMORY[0x1E69E9840];
  v14 = a2;
  Context = mlir::Attribute::getContext(&v14);
  v9 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::CollapseShapeOp,void>::id, Context);
  if ((v10 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(v17, v16, v15);
  }

  mlir::OperationState::OperationState(v17, a2, v9);
  mlir::memref::CollapseShapeOp::build(a1, v17, *a3, *a4, *(a4 + 8), 0, 0);
  v11 = mlir::OpBuilder::create(a1, v17);
  if (*(*(v11 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::CollapseShapeOp,void>::id)
  {
    v12 = v11;
  }

  else
  {
    v12 = 0;
  }

  mlir::OperationState::~OperationState(v17);
  return v12;
}

BOOL llvm::all_of<llvm::SmallVector<llvm::SmallVector<long long,2u>,4u> &,mlir::OpFoldResult mlir::foldReshapeOp<mlir::memref::ExpandShapeOp,mlir::memref::CollapseShapeOp>(mlir::memref::ExpandShapeOp,llvm::ArrayRef<mlir::Attribute>)::{lambda(mlir::memref::ExpandShapeOp)#1}>(uint64_t a1, unsigned int a2, mlir::ArrayAttr *this)
{
  v28[2] = *MEMORY[0x1E69E9840];
  if (a2)
  {
    v4 = a1;
    v5 = a1 + 32 * a2;
    v25 = vnegq_f64(0);
    while (1)
    {
      __dst = v28;
      v27 = 0x200000000;
      v7 = *(v4 + 8);
      if (&__dst != v4 && v7 != 0)
      {
        break;
      }

LABEL_16:
      Value = mlir::ArrayAttr::getValue(this);
      if (!v27)
      {
        v16 = 1;
        if (__dst == v28)
        {
          goto LABEL_3;
        }

LABEL_28:
        free(__dst);
        goto LABEL_3;
      }

      v12 = (Value + 8 * *__dst);
      v13 = (v27 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v13 >= 3)
      {
        v17 = v13 + 1;
        v18 = (v13 + 1) & 0x3FFFFFFFFFFFFFFCLL;
        v15 = &v12->i64[v18];
        v19 = v12 + 1;
        v20 = 0uLL;
        v21 = v18;
        v22 = 0uLL;
        do
        {
          v20 = vsubq_s64(v20, vceqq_s64(v19[-1], v25));
          v22 = vsubq_s64(v22, vceqq_s64(*v19, v25));
          v19 += 2;
          v21 -= 4;
        }

        while (v21);
        v14 = vaddvq_s64(vaddq_s64(v22, v20));
        if (v17 == v18)
        {
          goto LABEL_27;
        }
      }

      else
      {
        v14 = 0;
        v15 = v12;
      }

      do
      {
        v23 = *v15++;
        if (v23 == 0x8000000000000000)
        {
          ++v14;
        }
      }

      while (v15 != (v12 + 8 * v27));
LABEL_27:
      v16 = v14 < 2;
      if (__dst != v28)
      {
        goto LABEL_28;
      }

LABEL_3:
      v4 += 32;
      if (v4 == v5 || !v16)
      {
        return v16;
      }
    }

    v9 = v28;
    v10 = *(v4 + 8);
    if (v7 >= 3)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(&__dst, v28, *(v4 + 8), 8);
      v10 = *(v4 + 8);
      if (!v10)
      {
LABEL_15:
        LODWORD(v27) = v7;
        goto LABEL_16;
      }

      v9 = __dst;
    }

    memcpy(v9, *v4, 8 * v10);
    goto LABEL_15;
  }

  return 1;
}

void mlir::RewritePatternSet::addImpl<mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp,SubViewReturnTypeCanonicalizer,SubViewCanonicalizer>,mlir::MLIRContext *&>(void *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  v8 = operator new(0x60uLL);
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v31, 1);
  mlir::Pattern::Pattern((v8 + 1), "memref.subview", 14, v31, v9, 0, 0);
  *v8 = &unk_1F5AFAAF8;
  if (v8[9])
  {
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v31 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer>]";
    v32 = 184;
    v23 = llvm::StringRef::find(&v31, "DesiredTypeName = ", 0x12uLL, 0);
    if (v32 >= v23)
    {
      v24 = v23;
    }

    else
    {
      v24 = v32;
    }

    v25 = &v31[v24];
    v26 = v32 - v24;
    if (v32 - v24 >= 0x12)
    {
      v27 = 18;
    }

    else
    {
      v27 = v32 - v24;
    }

    v28 = &v25[v27];
    v29 = v26 - v27;
    if (v29 >= v29 - 1)
    {
      --v29;
    }

    v8[8] = v28;
    v8[9] = v29;
    v10 = 16 * a3;
    v11 = *(v8 + 22);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(v8 + 23))
    {
LABEL_3:
      if (!a3)
      {
        goto LABEL_5;
      }

      goto LABEL_4;
    }
  }

  llvm::SmallVectorBase<unsigned int>::grow_pod((v8 + 10), (v8 + 12), v12, 16);
  LODWORD(v11) = *(v8 + 22);
  if (a3)
  {
LABEL_4:
    memcpy((v8[10] + 16 * v11), a2, v10);
    LODWORD(v11) = *(v8 + 22);
  }

LABEL_5:
  *(v8 + 22) = v11 + (v10 >> 4);
  v14 = a1[2];
  v13 = a1[3];
  if (v14 >= v13)
  {
    v16 = a1[1];
    v17 = v14 - v16;
    v18 = (v14 - v16) >> 3;
    v19 = v18 + 1;
    if ((v18 + 1) >> 61)
    {
      std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
    }

    v20 = v13 - v16;
    if (v20 >> 2 > v19)
    {
      v19 = v20 >> 2;
    }

    if (v20 >= 0x7FFFFFFFFFFFFFF8)
    {
      v21 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v21 = v19;
    }

    if (v21)
    {
      if (v21 >> 61)
      {
        std::vector<mlir::CallGraphNode *>::__throw_length_error[abi:nn200100]();
      }

      v22 = operator new(8 * v21);
    }

    else
    {
      v22 = 0;
    }

    v30 = &v22[8 * v18];
    *v30 = v8;
    v15 = v30 + 8;
    memcpy(v22, v16, v17);
    a1[1] = v22;
    a1[2] = v15;
    a1[3] = &v22[8 * v21];
    if (v16)
    {
      operator delete(v16);
    }
  }

  else
  {
    *v14 = v8;
    v15 = v14 + 8;
  }

  a1[2] = v15;
}

void *mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp,SubViewReturnTypeCanonicalizer,SubViewCanonicalizer>::~OpWithOffsetSizesAndStridesConstantArgumentFolder(void *a1)
{
  v2 = a1[10];
  if (v2 != a1 + 12)
  {
    free(v2);
  }

  v3 = a1[4];
  if (v3 != a1 + 6)
  {
    free(v3);
  }

  return a1;
}

void mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp,SubViewReturnTypeCanonicalizer,SubViewCanonicalizer>::~OpWithOffsetSizesAndStridesConstantArgumentFolder(void *__p)
{
  v2 = __p[10];
  if (v2 != __p + 12)
  {
    free(v2);
  }

  v3 = __p[4];
  if (v3 != __p + 6)
  {
    free(v3);
  }

  operator delete(__p);
}

uint64_t SubViewReturnTypeCanonicalizer::operator()(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  v55[7] = *MEMORY[0x1E69E9840];
  v47 = a2;
  v9 = mlir::memref::SubViewOp::inferResultType(*(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, a3, a4, a5, a6, a7, a8);
  if (!v9)
  {
    return 0;
  }

  v46 = v9;
  mlir::memref::SubViewOp::getDroppedDims(&v47, &__p);
  v10 = __p;
  if (__p)
  {
    if (((__p >> 1) & ~(-1 << (__p >> 58))) != 0)
    {
      goto LABEL_10;
    }

LABEL_27:
    v14 = v46;
    if (__p)
    {
      return v14;
    }

    goto LABEL_51;
  }

  v11 = *(__p + 2);
  if (!v11)
  {
    goto LABEL_27;
  }

  v12 = *__p;
  v13 = 8 * v11;
  while (!*v12)
  {
    ++v12;
    v13 -= 8;
    if (!v13)
    {
      goto LABEL_27;
    }
  }

LABEL_10:
  mlir::getStridesAndOffset(v46, &v54);
  v51 = v53;
  v52 = 0x600000000;
  v48 = v50;
  v49 = 0x600000000;
  if (a6 < 1)
  {
    v15 = 0;
  }

  else
  {
    v15 = 0;
    v16 = 0;
    if (v10)
    {
      v17 = (v10 >> 1) & ~(-1 << (v10 >> 58));
      do
      {
        if (((v17 >> v16) & 1) == 0)
        {
          v22 = v54[v16];
          v23 = v49;
          if (v49 >= HIDWORD(v49))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(&v48, v50, v49 + 1, 8);
            v23 = v49;
          }

          *(v48 + v23) = v22;
          LODWORD(v49) = v49 + 1;
          v24 = *(mlir::ArrayAttr::getValue(&v46) + 8 * v16);
          v25 = v52;
          if (v52 >= HIDWORD(v52))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(&v51, v53, v52 + 1, 8);
            v25 = v52;
          }

          *(v51 + v25) = v24;
          v15 = v52 + 1;
          LODWORD(v52) = v52 + 1;
        }

        ++v16;
      }

      while (a6 != v16);
    }

    else
    {
      do
      {
        if (((*(*v10 + (v16 >> 6)) >> v16) & 1) == 0)
        {
          v18 = v54[v16];
          v19 = v49;
          if (v49 >= HIDWORD(v49))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(&v48, v50, v49 + 1, 8);
            v19 = v49;
          }

          *(v48 + v19) = v18;
          LODWORD(v49) = v49 + 1;
          v20 = *(mlir::ArrayAttr::getValue(&v46) + 8 * v16);
          v21 = v52;
          if (v52 >= HIDWORD(v52))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(&v51, v53, v52 + 1, 8);
            v21 = v52;
          }

          *(v51 + v21) = v20;
          v15 = v52 + 1;
          LODWORD(v52) = v52 + 1;
        }

        ++v16;
      }

      while (a6 != v16);
    }
  }

  v26 = v51;
  v27 = v15;
  RHS = mlir::AffineBinaryOpExpr::getRHS(&v46);
  Context = mlir::Attribute::getContext(&v46);
  v30 = mlir::StridedLayoutAttr::get(Context, v55[6], v48, v49);
  v31 = v30;
  if (!v30)
  {
    goto LABEL_43;
  }

  v32 = *v30;
  {
    mlir::memref::ExpandShapeOp::computeExpandedType();
    v33 = mlir::detail::TypeIDResolver<mlir::MemRefLayoutAttrInterface,void>::resolveTypeID(void)::id;
    v34 = *(v32 + 8);
    v35 = *(v32 + 16);
    if (v35)
    {
      goto LABEL_33;
    }

LABEL_43:
    v42 = 0;
    goto LABEL_44;
  }

  v33 = mlir::detail::TypeIDResolver<mlir::MemRefLayoutAttrInterface,void>::resolveTypeID(void)::id;
  v34 = *(v32 + 8);
  v35 = *(v32 + 16);
  if (!v35)
  {
    goto LABEL_43;
  }

LABEL_33:
  v36 = v34;
  v37 = v35;
  do
  {
    v38 = v37 >> 1;
    v39 = &v36[2 * (v37 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v37 += ~(v37 >> 1);
    if (v41 < v33)
    {
      v36 = v40;
    }

    else
    {
      v37 = v38;
    }
  }

  while (v37);
  if (v36 == &v34[2 * v35] || *v36 != v33)
  {
    goto LABEL_43;
  }

  v42 = v36[1];
LABEL_44:
  MemorySpace = mlir::MemRefType::getMemorySpace(&v46);
  v14 = mlir::MemRefType::get(v26, v27, RHS, v31, v42, MemorySpace);
  if (v48 != v50)
  {
    free(v48);
  }

  if (v51 != v53)
  {
    free(v51);
  }

  if (v54 != v55)
  {
    free(v54);
  }

  v10 = __p;
  if ((__p & 1) == 0)
  {
LABEL_51:
    if (v10)
    {
      if (*v10 != v10 + 2)
      {
        free(*v10);
      }

      operator delete(v10);
    }
  }

  return v14;
}

uint64_t mlir::OpBuilder::create<mlir::memref::SubViewOp,mlir::MemRefType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(uint64_t **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v23[38] = *MEMORY[0x1E69E9840];
  v20 = a2;
  Context = mlir::Attribute::getContext(&v20);
  v15 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::SubViewOp,void>::id, Context);
  if ((v16 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::SubViewOp,mlir::MemRefType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(v23, v22, v21);
  }

  mlir::OperationState::OperationState(v23, a2, v15);
  mlir::memref::SubViewOp::build(a1, v23, *a3, *a4, *a5, *(a5 + 8), *a6, *(a6 + 8), *a7, *(a7 + 8), 0, 0);
  v17 = mlir::OpBuilder::create(a1, v23);
  if (*(*(v17 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::SubViewOp,void>::id)
  {
    v18 = v17;
  }

  else
  {
    v18 = 0;
  }

  mlir::OperationState::~OperationState(v23);
  return v18;
}

void anonymous namespace::SubViewOpMemRefCastFolder::~SubViewOpMemRefCastFolder(_anonymous_namespace_::SubViewOpMemRefCastFolder *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t anonymous namespace::SubViewOpMemRefCastFolder::matchAndRewrite(uint64_t DefiningOp, uint64_t a2, uint64_t **a3)
{
  v129[6] = *MEMORY[0x1E69E9840];
  v109 = a2;
  v4 = *(a2 + 68);
  if (v4)
  {
    v5 = (*(a2 + 72) + 24);
    while (1)
    {
      v6 = *v5;
      MPSGraphDelegateCompiler.precompilationDescriptor.modify(DefiningOp, a2);
      v127 = v6;
      DefiningOp = mlir::Value::getDefiningOp(&v127);
      if (DefiningOp)
      {
        DefiningOp = mlir::arith::ConstantIndexOp::classof(DefiningOp, a2);
        if (DefiningOp)
        {
          return 0;
        }
      }

      v5 += 4;
      if (!--v4)
      {
        a2 = v109;
        break;
      }
    }
  }

  v127 = *(*(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp(&v127);
  if (!result)
  {
    return result;
  }

  if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::CastOp,void>::id)
  {
    v8 = result;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    return 0;
  }

  result = mlir::memref::CastOp::canFoldIntoConsumerOp(v8);
  if (!result)
  {
    return result;
  }

  if (*(v109 + 36))
  {
    v9 = v109 - 16;
  }

  else
  {
    v9 = 0;
  }

  v10 = *(mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0) + 8);
  v11 = *(*(*(v109 + 72) + 24) + 8);
  v12 = *(*(*(v8 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedOffsets(&v109, &v121);
  v13 = v121;
  v14 = v122;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes(&v109, &v118);
  v15 = v118;
  v16 = v119;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides(&v109, &v115);
  v114 = v12;
  v113 = mlir::memref::SubViewOp::inferResultType(v12, v13, v14, v15, v16, v115, v116);
  computeMemRefRankReductionMask(&__p, v11 & 0xFFFFFFFFFFFFFFF8, v10 & 0xFFFFFFFFFFFFFFF8, v15, v16);
  v17 = 0;
  if (v112 == 1)
  {
    RawStringData = mlir::DenseElementsAttr::getRawStringData(&v113);
    v127 = v129;
    v128 = 0x600000000;
    v124 = v126;
    v125 = 0x600000000;
    mlir::ArrayAttr::getValue(&v113);
    v19 = __p;
    if (__p)
    {
      v25 = vcnt_s8(((__p >> 1) & ~(-1 << (__p >> 58))));
      v25.i16[0] = vaddlv_u8(v25);
      v26 = v25.i32[0];
      goto LABEL_30;
    }

    v20 = *(__p + 2);
    if (!v20)
    {
      v26 = 0;
      goto LABEL_30;
    }

    v21 = *__p;
    v22 = (v20 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v22 >= 7)
    {
      v27 = v22 + 1;
      v28 = (v22 + 1) & 0x3FFFFFFFFFFFFFF8;
      v24 = &v21[v28];
      v29 = &v21[4];
      v30 = 0uLL;
      v31 = v28;
      v32 = 0uLL;
      do
      {
        v33 = v29[-2];
        v34 = v29[-1];
        v35 = *v29;
        v36 = v29[1];
        v29 += 4;
        v30 = vaddq_s32(v30, vuzp1q_s32(vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(vcntq_s8(v33)))), vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(vcntq_s8(v34))))));
        v32 = vaddq_s32(v32, vuzp1q_s32(vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(vcntq_s8(v35)))), vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(vcntq_s8(v36))))));
        v31 -= 8;
      }

      while (v31);
      v23 = vaddvq_s32(vaddq_s32(v32, v30));
      if (v27 == v28)
      {
        goto LABEL_29;
      }
    }

    else
    {
      v23 = 0;
      v24 = *__p;
    }

    v37 = &v21[v20];
    do
    {
      v38 = *v24++;
      v39 = vcnt_s8(v38);
      v39.i16[0] = vaddlv_u8(v39);
      v23 += v39.i32[0];
    }

    while (v24 != v37);
LABEL_29:
    v26 = v23;
LABEL_30:
    v40 = (v18 - v26);
    if (v40 > HIDWORD(v128))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(&v127, v129, v40, 8);
    }

    if (v40 > HIDWORD(v125))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(&v124, v126, v40, 8);
    }

    mlir::ArrayAttr::getValue(&v113);
    v42 = v41;
    Value = mlir::ArrayAttr::getValue(&v113);
    v45 = v44;
    AttrData = mlir::OpaqueAttr::getAttrData(&RawStringData);
    if (v42 && v45 && v47)
    {
      v48 = 8 * v47;
      v49 = 8 * v45;
      v50 = 0;
      if (v19)
      {
        v59 = (v19 >> 1) & ~(-1 << (v19 >> 58));
        v60 = v48 - 8;
        v61 = v49 - 8;
        v62 = v42 - 1;
        do
        {
          if (((v59 >> v50) & 1) == 0)
          {
            v63 = *(Value + 8 * v50);
            v64 = v128;
            if (v128 >= HIDWORD(v128))
            {
              v107 = AttrData;
              llvm::SmallVectorBase<unsigned int>::grow_pod(&v127, v129, v128 + 1, 8);
              AttrData = v107;
              v64 = v128;
            }

            v127[v64] = v63;
            LODWORD(v128) = v128 + 1;
            v65 = *(AttrData + 8 * v50);
            v66 = v125;
            if (v125 >= HIDWORD(v125))
            {
              v108 = AttrData;
              llvm::SmallVectorBase<unsigned int>::grow_pod(&v124, v126, v125 + 1, 8);
              AttrData = v108;
              v66 = v125;
            }

            *(v124 + v66) = v65;
            LODWORD(v125) = v125 + 1;
          }

          if (v62 == v50)
          {
            break;
          }

          if (!v61)
          {
            break;
          }

          ++v50;
          v67 = v60;
          v60 -= 8;
          v61 -= 8;
        }

        while (v67);
      }

      else
      {
        v51 = v48 - 8;
        v52 = v49 - 8;
        v53 = v42 - 1;
        do
        {
          if (((*(*v19 + 8 * (v50 >> 6)) >> v50) & 1) == 0)
          {
            v54 = *(Value + 8 * v50);
            v55 = v128;
            if (v128 >= HIDWORD(v128))
            {
              v105 = AttrData;
              llvm::SmallVectorBase<unsigned int>::grow_pod(&v127, v129, v128 + 1, 8);
              AttrData = v105;
              v55 = v128;
            }

            v127[v55] = v54;
            LODWORD(v128) = v128 + 1;
            v56 = *(AttrData + 8 * v50);
            v57 = v125;
            if (v125 >= HIDWORD(v125))
            {
              v106 = AttrData;
              llvm::SmallVectorBase<unsigned int>::grow_pod(&v124, v126, v125 + 1, 8);
              AttrData = v106;
              v57 = v125;
            }

            *(v124 + v57) = v56;
            LODWORD(v125) = v125 + 1;
          }

          if (v53 == v50)
          {
            break;
          }

          if (!v52)
          {
            break;
          }

          ++v50;
          v58 = v51;
          v51 -= 8;
          v52 -= 8;
        }

        while (v58);
      }
    }

    v68 = v127;
    v69 = v128;
    RHS = mlir::AffineBinaryOpExpr::getRHS(&v113);
    Context = mlir::Attribute::getContext(&v114);
    v72 = mlir::AffineMapAttr::getValue(&RawStringData);
    v73 = mlir::StridedLayoutAttr::get(Context, v72, v124, v125);
    v74 = v73;
    if (!v73)
    {
      v85 = 0;
LABEL_75:
      MemorySpace = mlir::MemRefType::getMemorySpace(&v113);
      v17 = mlir::MemRefType::get(v68, v69, RHS, v74, v85, MemorySpace);
      if (v124 != v126)
      {
        free(v124);
      }

      if (v127 != v129)
      {
        free(v127);
      }

      if (v112)
      {
        v87 = __p;
        if ((__p & 1) == 0)
        {
          if (__p)
          {
            if (*__p != __p + 16)
            {
              free(*__p);
            }

            operator delete(v87);
          }
        }
      }

      goto LABEL_85;
    }

    v75 = *v73;
    {
      v76 = mlir::detail::TypeIDResolver<mlir::MemRefLayoutAttrInterface,void>::resolveTypeID(void)::id;
      v77 = *(v75 + 8);
      v78 = *(v75 + 16);
      if (v78)
      {
        goto LABEL_62;
      }
    }

    else
    {
      mlir::memref::ExpandShapeOp::computeExpandedType();
      v76 = mlir::detail::TypeIDResolver<mlir::MemRefLayoutAttrInterface,void>::resolveTypeID(void)::id;
      v77 = *(v75 + 8);
      v78 = *(v75 + 16);
      if (v78)
      {
LABEL_62:
        v79 = v77;
        v80 = v78;
        do
        {
          v81 = v80 >> 1;
          v82 = &v79[2 * (v80 >> 1)];
          v84 = *v82;
          v83 = v82 + 2;
          v80 += ~(v80 >> 1);
          if (v84 < v76)
          {
            v79 = v83;
          }

          else
          {
            v80 = v81;
          }
        }

        while (v80);
        goto LABEL_71;
      }
    }

    v78 = 0;
    v79 = v77;
LABEL_71:
    if (v79 != &v77[2 * v78] && *v79 == v76)
    {
      v85 = v79[1];
    }

    else
    {
      v85 = 0;
    }

    goto LABEL_75;
  }

LABEL_85:
  v114 = v17;
  if (v115 != &v117)
  {
    free(v115);
  }

  if (v118 != &v120)
  {
    free(v118);
  }

  if (v121 != &v123)
  {
    free(v121);
  }

  if (!v17)
  {
    return 0;
  }

  v88 = *(v109 + 24);
  RawStringData = *(*(v8 + 72) + 24);
  v89 = *(v109 + 44);
  v90 = v109 + 16 * ((v89 >> 23) & 1);
  v91 = *(v90 + 88);
  v92 = *(v90 + 92);
  if ((v89 & 0x800000) != 0)
  {
    v93 = (v92 + v91);
    v127 = (*(v109 + 72) + 32 * v91);
    v128 = v93 - v91;
    v94 = (*(v90 + 96) + v93);
    v124 = (*(v109 + 72) + 32 * v93);
    v125 = v94 - v93;
    v95 = *(v109 + 72);
  }

  else
  {
    v95 = 0;
    v104 = (v92 + v91);
    v127 = (32 * v91);
    v128 = v104 - v91;
    v94 = (*(v90 + 96) + v104);
    v124 = (32 * v104);
    v125 = v94 - v104;
  }

  v96 = (v95 + 32 * v94);
  v97 = (*(v90 + 100) + v94) - v94;
  v121 = v96;
  v122 = v97;
  v118 = *(v90 + 64);
  v118 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&v118);
  v119 = v98;
  v115 = *(v109 + 16 * ((*(v109 + 44) >> 23) & 1) + 72);
  v115 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&v115);
  v116 = v99;
  __p = *(v109 + 16 * ((*(v109 + 44) >> 23) & 1) + 80);
  __p = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&__p);
  v112 = v100;
  v113 = mlir::OpBuilder::create<mlir::memref::SubViewOp,mlir::MemRefType &,mlir::detail::TypedValue<mlir::BaseMemRefType>,mlir::OperandRange,mlir::OperandRange,mlir::OperandRange,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>>(a3 + 1, v88, &v114, &RawStringData, &v127, &v124, &v121, &v118, &v115, &__p) - 16;
  v101 = v109;
  if (*(v109 + 36))
  {
    v102 = v109 - 16;
  }

  else
  {
    v102 = 0;
  }

  v127 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v102, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v103 = mlir::OpBuilder::create<mlir::memref::CastOp,mlir::MemRefType,mlir::detail::TypedValue<mlir::MemRefType>>((a3 + 1), *(v101 + 24), &v127, &v113);
  ((*a3)[1])(a3, v101, v103);
  return 1;
}

uint64_t mlir::OpBuilder::create<mlir::memref::SubViewOp,mlir::MemRefType &,mlir::detail::TypedValue<mlir::BaseMemRefType>,mlir::OperandRange,mlir::OperandRange,mlir::OperandRange,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>>(uint64_t **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  v30[5] = *MEMORY[0x1E69E9840];
  v26 = a2;
  Context = mlir::Attribute::getContext(&v26);
  v19 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::SubViewOp,void>::id, Context);
  if ((v20 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::SubViewOp,mlir::MemRefType &,mlir::detail::TypedValue<mlir::MemRefType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(v28, v30, v29);
  }

  mlir::OperationState::OperationState(v28, a2, v19);
  v21 = *a3;
  v22 = *a4;
  mlir::ValueRange::ValueRange(v30, *a5, *(a5 + 8));
  mlir::ValueRange::ValueRange(v29, *a6, *(a6 + 8));
  mlir::ValueRange::ValueRange(v27, *a7, *(a7 + 8));
  mlir::memref::SubViewOp::build(a1, v28, v21, v22, v30[0], v30[1], v29[0], v29[1], v27[0], v27[1], *a8, *(a8 + 8), *a9, *(a9 + 8), *a10, *(a10 + 8));
  v23 = mlir::OpBuilder::create(a1, v28);
  if (*(*(v23 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::SubViewOp,void>::id)
  {
    v24 = v23;
  }

  else
  {
    v24 = 0;
  }

  mlir::OperationState::~OperationState(v28);
  return v24;
}

void anonymous namespace::TrivialSubViewOpFolder::~TrivialSubViewOpFolder(_anonymous_namespace_::TrivialSubViewOpFolder *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t anonymous namespace::TrivialSubViewOpFolder::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v45[4] = *MEMORY[0x1E69E9840];
  v36 = a2;
  v43 = (*(*(*(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ArrayAttr::getValue(&v43);
  v6 = v5;
  if (*(a2 + 36))
  {
    v7 = a2 - 16;
  }

  else
  {
    v7 = 0;
  }

  v40 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ArrayAttr::getValue(&v40);
  if (v6 != v8)
  {
    return 0;
  }

  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedOffsets(&v36, &v43);
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes(&v36, &v40);
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides(&v36, &v37);
  if (v44)
  {
    v11 = v43;
    v12 = 8 * v44 - 8;
    do
    {
      v13 = *v11++;
      v14 = mlir::getConstantIntValue(v13) == 0;
      v16 = v15 & v14;
      v17 = v16 != 1 || v12 == 0;
      v12 -= 8;
    }

    while (!v17);
    if (!v16)
    {
      goto LABEL_29;
    }
  }

  if (v38)
  {
    v18 = v37;
    v19 = 8 * v38 - 8;
    do
    {
      v20 = *v18++;
      v21 = mlir::getConstantIntValue(v20) == 1;
      v23 = v22 & v21;
      v24 = v23 != 1 || v19 == 0;
      v19 -= 8;
    }

    while (!v24);
    if (!v23)
    {
      goto LABEL_29;
    }
  }

  v35 = *(*(*(v36 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  Value = mlir::ArrayAttr::getValue(&v35);
  if (v41)
  {
    v26 = Value;
    v27 = v40;
    v28 = 8 * v41;
    while (1)
    {
      ConstantIntValue = mlir::getConstantIntValue(*v27);
      if ((v30 & 1) == 0 || ConstantIntValue != *v26)
      {
        break;
      }

      ++v27;
      ++v26;
      v28 -= 8;
      if (!v28)
      {
        goto LABEL_28;
      }
    }

LABEL_29:
    v9 = 0;
    goto LABEL_30;
  }

LABEL_28:
  v9 = 1;
LABEL_30:
  if (v37 != &v39)
  {
    free(v37);
  }

  if (v40 != &v42)
  {
    free(v40);
  }

  if (v43 != v45)
  {
    free(v43);
  }

  if (v9)
  {
    if (*(a2 + 36))
    {
      v32 = a2 - 16;
    }

    else
    {
      v32 = 0;
    }

    v31 = *(*(*(a2 + 72) + 24) + 8);
    if ((*(mlir::detail::OpResultImpl::getNextResultAtOffset(v32, 0) + 8) ^ v31) > 7)
    {
      if (*(a2 + 36))
      {
        v33 = a2 - 16;
      }

      else
      {
        v33 = 0;
      }

      v43 = (*(mlir::detail::OpResultImpl::getNextResultAtOffset(v33, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      v40 = *(*(a2 + 72) + 24);
      v34 = mlir::OpBuilder::create<mlir::memref::CastOp,mlir::MemRefType,mlir::detail::TypedValue<mlir::MemRefType>>((a3 + 8), *(a2 + 24), &v43, &v40);
      (*(*a3 + 8))(a3, a2, v34);
      return 1;
    }

    else
    {
      v43 = *(*(a2 + 72) + 24);
      v9 = 1;
      (**a3)(a3, a2, &v43, 1);
    }
  }

  return v9;
}

void anonymous namespace::ViewOpShapeFolder::~ViewOpShapeFolder(_anonymous_namespace_::ViewOpShapeFolder *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpBuilder::create<mlir::memref::ViewOp,mlir::MemRefType &,mlir::Value,mlir::detail::TypedValue<mlir::IndexType>,llvm::SmallVector<mlir::Value,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  v32[5] = *MEMORY[0x1E69E9840];
  v24 = a2;
  Context = mlir::Attribute::getContext(&v24);
  v13 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::ViewOp,void>::id, Context);
  if ((v14 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::ViewOp,mlir::MemRefType &,mlir::Value,mlir::detail::TypedValue<mlir::IndexType>,llvm::SmallVector<mlir::Value,4u> &>(v27, v32, v25);
  }

  mlir::OperationState::OperationState(v27, a2, v13);
  v15 = *a3;
  v16 = *a4;
  v17 = *a5;
  mlir::ValueRange::ValueRange(v32, *a6, *(a6 + 8));
  v18 = v32[0];
  v19 = v32[1];
  v25[0] = v16;
  v26 = v17;
  mlir::OperationState::addOperands(v27, v25, 1uLL);
  mlir::OperationState::addOperands(v27, &v26, 1uLL);
  mlir::OperationState::addOperands(v27, v18, v19);
  v20 = v29;
  if (v29 >= v30)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v28, &v31, v29 + 1, 8);
    v20 = v29;
  }

  *(v28 + 8 * v20) = v15;
  ++v29;
  v21 = mlir::OpBuilder::create(a1, v27);
  if (*(*(v21 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::ViewOp,void>::id)
  {
    v22 = v21;
  }

  else
  {
    v22 = 0;
  }

  mlir::OperationState::~OperationState(v27);
  return v22;
}

void anonymous namespace::ViewOpMemrefCastFolder::~ViewOpMemrefCastFolder(_anonymous_namespace_::ViewOpMemrefCastFolder *this)
{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }
}

{
  v2 = *(this + 10);
  if (v2 != this + 96)
  {
    free(v2);
  }

  v3 = *(this + 4);
  if (v3 != this + 48)
  {
    free(v3);
  }

  operator delete(this);
}

uint64_t anonymous namespace::ViewOpMemrefCastFolder::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v14 = *(*(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp(&v14);
  if (result)
  {
    if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::CastOp,void>::id)
    {
      v13 = *(*(result + 72) + 24);
      result = mlir::Value::getDefiningOp(&v13);
      if (result)
      {
        if (*(*(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::AllocOp,void>::id)
        {
          v6 = *(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
          v7 = *(a2 + 72);
          v11 = *(v7 + 56);
          v12 = v6;
          v8 = *(a2 + 68) - 2;
          v10[0] = v7 + 64;
          v10[1] = v8;
          v9 = mlir::OpBuilder::create<mlir::memref::ViewOp,mlir::MemRefType,mlir::Value &,mlir::detail::TypedValue<mlir::IndexType>,mlir::OperandRange>((a3 + 8), *(a2 + 24), &v12, &v13, &v11, v10);
          (*(*a3 + 8))(a3, a2, v9);
          return 1;
        }

        else
        {
          return 0;
        }
      }
    }

    else
    {
      return 0;
    }
  }

  return result;
}

uint64_t mlir::OpBuilder::create<mlir::memref::ViewOp,mlir::MemRefType,mlir::Value &,mlir::detail::TypedValue<mlir::IndexType>,mlir::OperandRange>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  v32[5] = *MEMORY[0x1E69E9840];
  v24 = a2;
  Context = mlir::Attribute::getContext(&v24);
  v13 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::ViewOp,void>::id, Context);
  if ((v14 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::ViewOp,mlir::MemRefType &,mlir::Value,mlir::detail::TypedValue<mlir::IndexType>,llvm::SmallVector<mlir::Value,4u> &>(v27, v32, v25);
  }

  mlir::OperationState::OperationState(v27, a2, v13);
  v15 = *a3;
  v16 = *a4;
  v17 = *a5;
  mlir::ValueRange::ValueRange(v32, *a6, *(a6 + 8));
  v18 = v32[0];
  v19 = v32[1];
  v25[0] = v16;
  v26 = v17;
  mlir::OperationState::addOperands(v27, v25, 1uLL);
  mlir::OperationState::addOperands(v27, &v26, 1uLL);
  mlir::OperationState::addOperands(v27, v18, v19);
  v20 = v29;
  if (v29 >= v30)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v28, &v31, v29 + 1, 8);
    v20 = v29;
  }

  *(v28 + 8 * v20) = v15;
  ++v29;
  v21 = mlir::OpBuilder::create(a1, v27);
  if (*(*(v21 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::ViewOp,void>::id)
  {
    v22 = v21;
  }

  else
  {
    v22 = 0;
  }

  mlir::OperationState::~OperationState(v27);
  return v22;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::AssumeAlignmentOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::AssumeAlignmentOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

const char *llvm::getTypeName<mlir::memref::detail::AssumeAlignmentOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::AssumeAlignmentOpGenericAdaptorBase::Properties]";
  v6 = 119;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

BOOL mlir::AsmParser::parseAttribute<mlir::IntegerAttr>(uint64_t a1, void *a2, uint64_t a3)
{
  v30 = *MEMORY[0x1E69E9840];
  v6 = (*(*a1 + 40))(a1);
  v20 = 0;
  if (((*(*a1 + 440))(a1, &v20, a3) & 1) == 0)
  {
    return 0;
  }

  v7 = v20;
  if (*(*v20 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v7 = 0;
  }

  *a2 = v7;
  if (v7)
  {
    return 1;
  }

  v18 = "invalid kind of attribute specified";
  v19 = 259;
  (*(*a1 + 24))(v21, a1, v6, &v18);
  result = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v21);
  v9 = result;
  if (v21[0])
  {
    mlir::InFlightDiagnostic::report(v21);
    result = v9;
  }

  if (v29 == 1)
  {
    if (v28 != &v29)
    {
      free(v28);
      result = v9;
    }

    v10 = __p;
    if (__p)
    {
      v11 = v27;
      v12 = __p;
      if (v27 != __p)
      {
        do
        {
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v11 - 1);
        }

        while (v11 != v10);
        v12 = __p;
      }

      v27 = v10;
      operator delete(v12);
      result = v9;
    }

    v13 = v24;
    if (v24)
    {
      v14 = v25;
      v15 = v24;
      if (v25 != v24)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
          {
            operator delete[](v16);
          }
        }

        while (v14 != v13);
        v15 = v24;
      }

      v25 = v13;
      operator delete(v15);
      result = v9;
    }

    if (v22 != &v23)
    {
      free(v22);
      return v9;
    }
  }

  return result;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::AssumeAlignmentOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v4 = &v24;
    v5 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = v30;
        v4 = v30 + v22;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v4 = &v24;
        v5 = v30;
      }
    }

    v6 = &v5[24 * v31];
    v7 = *v4;
    *(v6 + 2) = *(v4 + 2);
    *v6 = v7;
    ++v31;
  }

  v24 = *(*(a1[2] + 8) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = AttrData;
    v25 = v9;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v10 = &v24;
      v11 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = v30;
          v10 = v30 + v23;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v10 = &v24;
          v11 = v30;
        }
      }

      v12 = &v11[24 * v31];
      v13 = *v10;
      *(v12 + 2) = *(v10 + 2);
      *v12 = v13;
      ++v31;
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v37;
      v16 = __p;
      if (v37 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v37 = v14;
      operator delete(v16);
    }

    v17 = v34;
    if (v34)
    {
      v18 = v35;
      v19 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v34;
      }

      v35 = v17;
      operator delete(v19);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

BOOL mlir::AsmParser::parseType<mlir::MemRefType>(uint64_t a1, void *a2)
{
  v28 = *MEMORY[0x1E69E9840];
  v4 = (*(*a1 + 40))(a1);
  v18 = 0;
  if (((*(*a1 + 536))(a1, &v18) & 1) == 0)
  {
    return 0;
  }

  v5 = v18;
  if (*(*v18 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
  {
    v5 = 0;
  }

  *a2 = v5;
  if (v5)
  {
    return 1;
  }

  v16 = "invalid kind of type specified";
  v17 = 259;
  (*(*a1 + 24))(v19, a1, v4, &v16);
  result = mlir::InFlightDiagnostic::operator llvm::LogicalResult(v19);
  v7 = result;
  if (v19[0])
  {
    mlir::InFlightDiagnostic::report(v19);
    result = v7;
  }

  if (v27 == 1)
  {
    if (v26 != &v27)
    {
      free(v26);
      result = v7;
    }

    v8 = __p;
    if (__p)
    {
      v9 = v25;
      v10 = __p;
      if (v25 != __p)
      {
        do
        {
          v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v9 - 1);
        }

        while (v9 != v8);
        v10 = __p;
      }

      v25 = v8;
      operator delete(v10);
      result = v7;
    }

    v11 = v22;
    if (v22)
    {
      v12 = v23;
      v13 = v22;
      if (v23 != v22)
      {
        do
        {
          v15 = *--v12;
          v14 = v15;
          *v12 = 0;
          if (v15)
          {
            operator delete[](v14);
          }
        }

        while (v12 != v11);
        v13 = v22;
      }

      v23 = v11;
      operator delete(v13);
      result = v7;
    }

    if (v20 != &v21)
    {
      free(v20);
      return v7;
    }
  }

  return result;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::AtomicRMWOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::AtomicRMWOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

const char *llvm::getTypeName<mlir::memref::detail::AtomicRMWOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::AtomicRMWOpGenericAdaptorBase::Properties]";
  v6 = 113;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::AtomicRMWOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v4 = &v24;
    v5 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = v30;
        v4 = v30 + v22;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v4 = &v24;
        v5 = v30;
      }
    }

    v6 = &v5[24 * v31];
    v7 = *v4;
    *(v6 + 2) = *(v4 + 2);
    *v6 = v7;
    ++v31;
  }

  v24 = *(*(a1[2] + 8) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = AttrData;
    v25 = v9;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v10 = &v24;
      v11 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = v30;
          v10 = v30 + v23;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v10 = &v24;
          v11 = v30;
        }
      }

      v12 = &v11[24 * v31];
      v13 = *v10;
      *(v12 + 2) = *(v10 + 2);
      *v12 = v13;
      ++v31;
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v37;
      v16 = __p;
      if (v37 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v37 = v14;
      operator delete(v16);
    }

    v17 = v34;
    if (v34)
    {
      v18 = v35;
      v19 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v34;
      }

      v35 = v17;
      operator delete(v19);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::LoadOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::LoadOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

const char *llvm::getTypeName<mlir::memref::detail::LoadOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::LoadOpGenericAdaptorBase::Properties]";
  v6 = 108;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::LoadOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v4 = &v24;
    v5 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = v30;
        v4 = v30 + v22;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v4 = &v24;
        v5 = v30;
      }
    }

    v6 = &v5[24 * v31];
    v7 = *v4;
    *(v6 + 2) = *(v4 + 2);
    *v6 = v7;
    ++v31;
  }

  v24 = *(*(a1[2] + 8) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = AttrData;
    v25 = v9;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v10 = &v24;
      v11 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = v30;
          v10 = v30 + v23;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v10 = &v24;
          v11 = v30;
        }
      }

      v12 = &v11[24 * v31];
      v13 = *v10;
      *(v12 + 2) = *(v10 + 2);
      *v12 = v13;
      ++v31;
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v37;
      v16 = __p;
      if (v37 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v37 = v14;
      operator delete(v16);
    }

    v17 = v34;
    if (v34)
    {
      v18 = v35;
      v19 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v34;
      }

      v35 = v17;
      operator delete(v19);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::AllocOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::AllocOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::AllocOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::AllocOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result = *a3;
  *a2 = *a3;
  return result;
}

const char *llvm::getTypeName<mlir::memref::detail::AllocOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::AllocOpGenericAdaptorBase::Properties]";
  v6 = 109;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::AllocOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v4 = &v24;
    v5 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = v30;
        v4 = v30 + v22;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v4 = &v24;
        v5 = v30;
      }
    }

    v6 = &v5[24 * v31];
    v7 = *v4;
    *(v6 + 2) = *(v4 + 2);
    *v6 = v7;
    ++v31;
  }

  v24 = *(*(a1[2] + 8) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = AttrData;
    v25 = v9;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v10 = &v24;
      v11 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = v30;
          v10 = v30 + v23;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v10 = &v24;
          v11 = v30;
        }
      }

      v12 = &v11[24 * v31];
      v13 = *v10;
      *(v12 + 2) = *(v10 + 2);
      *v12 = v13;
      ++v31;
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v37;
      v16 = __p;
      if (v37 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v37 = v14;
      operator delete(v16);
    }

    v17 = v34;
    if (v34)
    {
      v18 = v35;
      v19 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v34;
      }

      v35 = v17;
      operator delete(v19);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::AllocaOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::AllocaOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::AllocaOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::AllocaOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result = *a3;
  *a2 = *a3;
  return result;
}

const char *llvm::getTypeName<mlir::memref::detail::AllocaOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::AllocaOpGenericAdaptorBase::Properties]";
  v6 = 110;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::AllocaOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v4 = &v24;
    v5 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = v30;
        v4 = v30 + v22;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v4 = &v24;
        v5 = v30;
      }
    }

    v6 = &v5[24 * v31];
    v7 = *v4;
    *(v6 + 2) = *(v4 + 2);
    *v6 = v7;
    ++v31;
  }

  v24 = *(*(a1[2] + 8) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = AttrData;
    v25 = v9;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v10 = &v24;
      v11 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = v30;
          v10 = v30 + v23;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v10 = &v24;
          v11 = v30;
        }
      }

      v12 = &v11[24 * v31];
      v13 = *v10;
      *(v12 + 2) = *(v10 + 2);
      *v12 = v13;
      ++v31;
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v37;
      v16 = __p;
      if (v37 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v37 = v14;
      operator delete(v16);
    }

    v17 = v34;
    if (v34)
    {
      v18 = v35;
      v19 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v34;
      }

      v35 = v17;
      operator delete(v19);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::CollapseShapeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::CollapseShapeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

const char *llvm::getTypeName<mlir::memref::detail::CollapseShapeOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::CollapseShapeOpGenericAdaptorBase::Properties]";
  v6 = 117;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::CollapseShapeOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v4 = &v24;
    v5 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = v30;
        v4 = v30 + v22;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v4 = &v24;
        v5 = v30;
      }
    }

    v6 = &v5[24 * v31];
    v7 = *v4;
    *(v6 + 2) = *(v4 + 2);
    *v6 = v7;
    ++v31;
  }

  v24 = *(*(a1[2] + 8) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = AttrData;
    v25 = v9;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v10 = &v24;
      v11 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = v30;
          v10 = v30 + v23;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v10 = &v24;
          v11 = v30;
        }
      }

      v12 = &v11[24 * v31];
      v13 = *v10;
      *(v12 + 2) = *(v10 + 2);
      *v12 = v13;
      ++v31;
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v37;
      v16 = __p;
      if (v37 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v37 = v14;
      operator delete(v16);
    }

    v17 = v34;
    if (v34)
    {
      v18 = v35;
      v19 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v34;
      }

      v35 = v17;
      operator delete(v19);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

void *mlir::MemoryEffects::Free::Free(void *this)
{
  {
    *this = mlir::detail::TypeIDResolver<mlir::MemoryEffects::Free,void>::resolveTypeID(void)::id;
  }

  else
  {
    v1 = this;
    mlir::MemoryEffects::Free::Free();
    this = v1;
    *v1 = mlir::detail::TypeIDResolver<mlir::MemoryEffects::Free,void>::resolveTypeID(void)::id;
  }

  return this;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::ExpandShapeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::ExpandShapeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::ExpandShapeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::ExpandShapeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result = *a3;
  *a2 = *a3;
  return result;
}

const char *llvm::getTypeName<mlir::memref::detail::ExpandShapeOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::ExpandShapeOpGenericAdaptorBase::Properties]";
  v6 = 115;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::ExpandShapeOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v4 = &v24;
    v5 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = v30;
        v4 = v30 + v22;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v4 = &v24;
        v5 = v30;
      }
    }

    v6 = &v5[24 * v31];
    v7 = *v4;
    *(v6 + 2) = *(v4 + 2);
    *v6 = v7;
    ++v31;
  }

  v24 = *(*(a1[2] + 8) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = AttrData;
    v25 = v9;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v10 = &v24;
      v11 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = v30;
          v10 = v30 + v23;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v10 = &v24;
          v11 = v30;
        }
      }

      v12 = &v11[24 * v31];
      v13 = *v10;
      *(v12 + 2) = *(v10 + 2);
      *v12 = v13;
      ++v31;
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v37;
      v16 = __p;
      if (v37 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v37 = v14;
      operator delete(v16);
    }

    v17 = v34;
    if (v34)
    {
      v18 = v35;
      v19 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v34;
      }

      v35 = v17;
      operator delete(v19);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::GetGlobalOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::GetGlobalOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

const char *llvm::getTypeName<mlir::memref::detail::GetGlobalOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::GetGlobalOpGenericAdaptorBase::Properties]";
  v6 = 113;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::GetGlobalOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v4 = &v24;
    v5 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = v30;
        v4 = v30 + v22;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v4 = &v24;
        v5 = v30;
      }
    }

    v6 = &v5[24 * v31];
    v7 = *v4;
    *(v6 + 2) = *(v4 + 2);
    *v6 = v7;
    ++v31;
  }

  v24 = *(*(a1[2] + 8) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = AttrData;
    v25 = v9;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v10 = &v24;
      v11 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = v30;
          v10 = v30 + v23;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v10 = &v24;
          v11 = v30;
        }
      }

      v12 = &v11[24 * v31];
      v13 = *v10;
      *(v12 + 2) = *(v10 + 2);
      *v12 = v13;
      ++v31;
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v37;
      v16 = __p;
      if (v37 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v37 = v14;
      operator delete(v16);
    }

    v17 = v34;
    if (v34)
    {
      v18 = v35;
      v19 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v34;
      }

      v35 = v17;
      operator delete(v19);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

unint64_t llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>(char *a1, unint64_t a2, void *a3, char *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10)
{
  v22 = a2;
  v15 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v22, a3, a4, *a5);
  v23 = v22;
  v16 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v23, v15, a4, *a6);
  v24 = v23;
  v17 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v24, v16, a4, *a7);
  v25 = v24;
  v18 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v25, v17, a4, *a8);
  v26 = v25;
  v19 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v26, v18, a4, *a9);
  v27 = v26;
  v20 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v27, v19, a4, *a10);
  return llvm::hashing::detail::hash_combine_recursive_helper::combine(a1, v27, v20, a4);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::GlobalOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::GlobalOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::GlobalOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::GlobalOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = *a3;
  v4 = *(a3 + 32);
  *(a2 + 16) = *(a3 + 16);
  *(a2 + 32) = v4;
  *a2 = result;
  return result;
}

const char *llvm::getTypeName<mlir::memref::detail::GlobalOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::GlobalOpGenericAdaptorBase::Properties]";
  v6 = 110;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::GlobalOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v4 = &v24;
    v5 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = v30;
        v4 = v30 + v22;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v4 = &v24;
        v5 = v30;
      }
    }

    v6 = &v5[24 * v31];
    v7 = *v4;
    *(v6 + 2) = *(v4 + 2);
    *v6 = v7;
    ++v31;
  }

  v24 = *(*(a1[2] + 8) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = AttrData;
    v25 = v9;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v10 = &v24;
      v11 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = v30;
          v10 = v30 + v23;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v10 = &v24;
          v11 = v30;
        }
      }

      v12 = &v11[24 * v31];
      v13 = *v10;
      *(v12 + 2) = *(v10 + 2);
      *v12 = v13;
      ++v31;
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v37;
      v16 = __p;
      if (v37 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v37 = v14;
      operator delete(v16);
    }

    v17 = v34;
    if (v34)
    {
      v18 = v35;
      v19 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v34;
      }

      v35 = v17;
      operator delete(v19);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::PrefetchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::PrefetchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::PrefetchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::PrefetchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  return result;
}

const char *llvm::getTypeName<mlir::memref::detail::PrefetchOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::PrefetchOpGenericAdaptorBase::Properties]";
  v6 = 112;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::ReallocOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::ReallocOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

const char *llvm::getTypeName<mlir::memref::detail::ReallocOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::ReallocOpGenericAdaptorBase::Properties]";
  v6 = 111;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::ReallocOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v4 = &v24;
    v5 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = v30;
        v4 = v30 + v22;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v4 = &v24;
        v5 = v30;
      }
    }

    v6 = &v5[24 * v31];
    v7 = *v4;
    *(v6 + 2) = *(v4 + 2);
    *v6 = v7;
    ++v31;
  }

  v24 = *(*(a1[2] + 8) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = AttrData;
    v25 = v9;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v10 = &v24;
      v11 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = v30;
          v10 = v30 + v23;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v10 = &v24;
          v11 = v30;
        }
      }

      v12 = &v11[24 * v31];
      v13 = *v10;
      *(v12 + 2) = *(v10 + 2);
      *v12 = v13;
      ++v31;
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v37;
      v16 = __p;
      if (v37 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v37 = v14;
      operator delete(v16);
    }

    v17 = v34;
    if (v34)
    {
      v18 = v35;
      v19 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v34;
      }

      v35 = v17;
      operator delete(v19);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::ReinterpretCastOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::ReinterpretCastOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::ReinterpretCastOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::ReinterpretCastOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = *a3;
  v4 = *(a3 + 16);
  *(a2 + 32) = *(a3 + 32);
  *a2 = result;
  *(a2 + 16) = v4;
  return result;
}

const char *llvm::getTypeName<mlir::memref::detail::ReinterpretCastOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::ReinterpretCastOpGenericAdaptorBase::Properties]";
  v6 = 119;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::ReinterpretCastOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v4 = &v24;
    v5 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = v30;
        v4 = v30 + v22;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v4 = &v24;
        v5 = v30;
      }
    }

    v6 = &v5[24 * v31];
    v7 = *v4;
    *(v6 + 2) = *(v4 + 2);
    *v6 = v7;
    ++v31;
  }

  v24 = *(*(a1[2] + 8) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = AttrData;
    v25 = v9;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v10 = &v24;
      v11 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = v30;
          v10 = v30 + v23;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v10 = &v24;
          v11 = v30;
        }
      }

      v12 = &v11[24 * v31];
      v13 = *v10;
      *(v12 + 2) = *(v10 + 2);
      *v12 = v13;
      ++v31;
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v37;
      v16 = __p;
      if (v37 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v37 = v14;
      operator delete(v16);
    }

    v17 = v34;
    if (v34)
    {
      v18 = v35;
      v19 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v34;
      }

      v35 = v17;
      operator delete(v19);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::StoreOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::StoreOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

const char *llvm::getTypeName<mlir::memref::detail::StoreOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::StoreOpGenericAdaptorBase::Properties]";
  v6 = 109;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::StoreOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v4 = &v24;
    v5 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = v30;
        v4 = v30 + v22;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v4 = &v24;
        v5 = v30;
      }
    }

    v6 = &v5[24 * v31];
    v7 = *v4;
    *(v6 + 2) = *(v4 + 2);
    *v6 = v7;
    ++v31;
  }

  v24 = *(*(a1[2] + 8) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = AttrData;
    v25 = v9;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v10 = &v24;
      v11 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = v30;
          v10 = v30 + v23;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v10 = &v24;
          v11 = v30;
        }
      }

      v12 = &v11[24 * v31];
      v13 = *v10;
      *(v12 + 2) = *(v10 + 2);
      *v12 = v13;
      ++v31;
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v37;
      v16 = __p;
      if (v37 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v37 = v14;
      operator delete(v16);
    }

    v17 = v34;
    if (v34)
    {
      v18 = v35;
      v19 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v34;
      }

      v35 = v17;
      operator delete(v19);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::TransposeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::TransposeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

const char *llvm::getTypeName<mlir::memref::detail::TransposeOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::TransposeOpGenericAdaptorBase::Properties]";
  v6 = 113;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::SubViewOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::SubViewOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::memref::detail::SubViewOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::memref::detail::SubViewOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = *a3;
  v4 = *(a3 + 16);
  *(a2 + 32) = *(a3 + 32);
  *a2 = result;
  *(a2 + 16) = v4;
  return result;
}

const char *llvm::getTypeName<mlir::memref::detail::SubViewOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::memref::detail::SubViewOpGenericAdaptorBase::Properties]";
  v6 = 111;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::memref::SubViewOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  v40 = *MEMORY[0x1E69E9840];
  (*(**a1 + 24))(&v28);
  if (v28)
  {
    LODWORD(v24) = 3;
    v25 = "'";
    v26 = 1;
    v4 = &v24;
    v5 = v30;
    if (v31 >= v32)
    {
      if (v30 <= &v24 && v30 + 24 * v31 > &v24)
      {
        v22 = &v24 - v30;
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v5 = v30;
        v4 = v30 + v22;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
        v4 = &v24;
        v5 = v30;
      }
    }

    v6 = &v5[24 * v31];
    v7 = *v4;
    *(v6 + 2) = *(v4 + 2);
    *v6 = v7;
    ++v31;
  }

  v24 = *(*(a1[2] + 8) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData(&v24);
  if (v28)
  {
    v27 = 261;
    v24 = AttrData;
    v25 = v9;
    mlir::Diagnostic::operator<<(&v29, &v24);
    if (v28)
    {
      LODWORD(v24) = 3;
      v25 = "' op ";
      v26 = 5;
      v10 = &v24;
      v11 = v30;
      if (v31 >= v32)
      {
        if (v30 <= &v24 && v30 + 24 * v31 > &v24)
        {
          v23 = &v24 - v30;
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v11 = v30;
          v10 = v30 + v23;
        }

        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(&v30, v33, v31 + 1, 24);
          v10 = &v24;
          v11 = v30;
        }
      }

      v12 = &v11[24 * v31];
      v13 = *v10;
      *(v12 + 2) = *(v10 + 2);
      *v12 = v13;
      ++v31;
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v28);
  if (v28)
  {
    mlir::InFlightDiagnostic::report(&v28);
  }

  if (v39 == 1)
  {
    if (v38 != &v39)
    {
      free(v38);
    }

    v14 = __p;
    if (__p)
    {
      v15 = v37;
      v16 = __p;
      if (v37 != __p)
      {
        do
        {
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn200100](v15 - 1);
        }

        while (v15 != v14);
        v16 = __p;
      }

      v37 = v14;
      operator delete(v16);
    }

    v17 = v34;
    if (v34)
    {
      v18 = v35;
      v19 = v34;
      if (v35 != v34)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
          {
            operator delete[](v20);
          }
        }

        while (v18 != v17);
        v19 = v34;
      }

      v35 = v17;
      operator delete(v19);
    }

    if (v30 != v33)
    {
      free(v30);
    }
  }
}

llvm::raw_ostream *OUTLINED_FUNCTION_15_7(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{

  return mlir::printDynamicIndexList(v15, v16, v17, v18, v19, v20, 0, 0, a14, a15, 2);
}

uint64_t OUTLINED_FUNCTION_25_5()
{
  if (*(*v0 + 36))
  {
    v2 = *v0 - 16;
  }

  else
  {
    v2 = 0;
  }

  return mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
}

uint64_t OUTLINED_FUNCTION_28_4@<X0>(uint64_t a1@<X8>)
{
  v2 = *(a1 + 36);
  v3 = a1 - 16;
  if (v2)
  {
    v4 = v3;
  }

  else
  {
    v4 = 0;
  }

  return mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
}

void OUTLINED_FUNCTION_37_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);

  llvm::SmallVectorBase<unsigned int>::grow_pod(v17 + 24, va, v16 + 1, 24);
}

void OUTLINED_FUNCTION_65_0(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{

  llvm::SmallVectorBase<unsigned int>::grow_pod(&a20, a5, a1 + 1, 8);
}

void OUTLINED_FUNCTION_74_0(void *a1@<X8>)
{
  v1[3] = a1;
  *v1 = *a1;
  v1[1] = a1;
}

void OUTLINED_FUNCTION_77_0(uint64_t a1@<X0>, uint64_t a2@<X8>, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{

  llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a6, a2 + 1, 8);
}

uint64_t OUTLINED_FUNCTION_84_0@<X0>(void *a1@<X2>, uint64_t a2@<X8>)
{

  return mlir::memref::__mlir_ods_local_type_constraint_MemRefOps1(a2, v2 & 0xFFFFFFFFFFFFFFF8, a1, 6, 0);
}

void OUTLINED_FUNCTION_99_0(void *a1@<X8>)
{
  v1[3] = a1;
  *v1 = *a1;
  v1[1] = a1;
}

uint64_t OUTLINED_FUNCTION_101_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  a18 = *(*(v18 + 72) + 32 * v19 + 24);

  return mlir::Value::getDefiningOp(&a18);
}

void OUTLINED_FUNCTION_106(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  a9 = a1;
  a10 = v12;
  a11 = v13;
  a12 = 14;
  a8 = 0x200000002;

  llvm::SmallVectorBase<unsigned int>::grow_pod(&a7, v14, 3uLL, 16);
}

uint64_t OUTLINED_FUNCTION_119_0@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  a6 = *(a1 + 80);

  return mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&a6);
}

void OUTLINED_FUNCTION_124_0(uint64_t a1@<X0>, uint64_t a2@<X8>)
{

  llvm::SmallVectorBase<unsigned int>::grow_pod(a1, v2, a2 + 1, 16);
}

uint64_t OUTLINED_FUNCTION_125_0@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  a6 = *(a1 + 8);

  return mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&a6);
}

unint64_t OUTLINED_FUNCTION_141@<X0>(void *a1@<X8>)
{
  *a1 = v1;
  a1[1] = 14;
  v4 = *v2;

  return mlir::Operation::getAttrDictionary(v4);
}

uint64_t OUTLINED_FUNCTION_142@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  a6 = *(a1 + 64);

  return mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>(&a6);
}

uint64_t OUTLINED_FUNCTION_143(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, unsigned int a28)
{

  return mlir::MemRefType::get(a27, a28, v28, v29, v30, a1);
}

void OUTLINED_FUNCTION_144(uint64_t a1, ...)
{
  va_start(va1, a1);
  va_start(va, a1);
  v3 = va_arg(va1, void *);
  v5 = va_arg(va1, void);
  v6 = va_arg(va1, void);
  v7 = va_arg(va1, void);
  v8 = va_arg(va1, void);
  v9 = va_arg(va1, void);
  v10 = va_arg(va1, void);
  v11 = va_arg(va1, void);
  v12 = va_arg(va1, void);
  v13 = va_arg(va1, void);
  LOWORD(v8) = 257;

  mlir::OpState::emitOpError(v1, va, va1);
}

uint64_t OUTLINED_FUNCTION_145(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t *a21, uint64_t a22, uint64_t a23)
{
  a21 = &a23;
  a22 = v24;

  return mlir::ArrayAttr::getValue(&a17);
}

uint64_t OUTLINED_FUNCTION_146(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  va_arg(va1, void);
  va_arg(va1, void);
  v13 = va_arg(va1, void);
  v14 = va_arg(va1, void);
  v15 = va_arg(va1, void);
  v16 = va_arg(va1, void);
  LOWORD(v15) = 261;
  v10 = a1;
  v12 = a2;

  return mlir::Diagnostic::operator<<(va1, va);
}

uint64_t OUTLINED_FUNCTION_162(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, unint64_t *a19, uint64_t a20)
{
  a19 = &a20;
  a20 = 0;

  return mlir::detail::constant_op_binder<mlir::Attribute>::match(&a19, a1);
}

void OUTLINED_FUNCTION_163(uint64_t a1@<X0>, uint64_t a2@<X8>, uint64_t a3, uint64_t a4, unint64_t a5)
{

  llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a5, a2 + 1, 8);
}

void OUTLINED_FUNCTION_164(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);

  llvm::SmallVectorBase<unsigned int>::grow_pod(v15 + 24, va, a1 + 1, 24);
}

uint64_t OUTLINED_FUNCTION_165(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  a9 = a1;

  return mlir::ArrayAttr::getValue(&a9);
}

uint64_t OUTLINED_FUNCTION_166(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, int a28)
{
  v31 = *v28;
  a28 = v29;
  a27 = 0;
  a20 = v31;

  return mlir::Value::getDefiningOp(&a20);
}

double OUTLINED_FUNCTION_184(uint32x4_t a1, uint8x8_t a2)
{
  a2.i32[0] = *v2;
  *&result = vaddw_u16(a1, *&vmovl_u8(a2)).u64[0];
  return result;
}

void OUTLINED_FUNCTION_187(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{

  llvm::SmallVectorBase<unsigned int>::grow_pod(&a27, v27, a2, 8);
}

uint64_t OUTLINED_FUNCTION_188(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, unint64_t *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
  a21 = 0;
  a15 = v22;

  return mlir::detail::constant_op_binder<mlir::Attribute>::match(&a15, v21);
}

unint64_t OUTLINED_FUNCTION_189()
{
  v2 = *v0;

  return mlir::Operation::getAttrDictionary(v2);
}

uint64_t mlir::DialectRegistry::addExtension<mlir::memref::MemRefDialect>(uint64_t a1, uint64_t *a2)
{
  v4 = operator new(0x50uLL);
  v4[3] = "memref";
  v4[4] = 6;
  v4[2] = 0x300000001;
  *v4 = &unk_1F5AFAD88;
  v4[1] = v4 + 3;
  v4[9] = a2;
  v9 = v4;
  v10 = a2;
  v12 = a2;
  v13 = 0;
  llvm::DenseMapBase<llvm::DenseMap<mlir::Region *,unsigned int,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,unsigned int>>,mlir::Region *,unsigned int,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,unsigned int>>::try_emplace<unsigned int const&>(a1 + 24, &v12, &v13, &v14);
  v5 = v15;
  if (v15)
  {
    v6 = *(a1 + 56);
    *(v14 + 8) = v6;
    v12 = &v10;
    v11 = &v9;
    if (v6 >= *(a1 + 60))
    {
      llvm::SmallVectorTemplateBase<std::pair<mlir::TypeID,std::unique_ptr<mlir::DialectExtensionBase>>,false>::growAndEmplaceBack<std::piecewise_construct_t const&,std::tuple<mlir::TypeID const&>,std::tuple<std::unique_ptr<mlir::DialectExtensionBase>&&>>(a1 + 48, &std::piecewise_construct, &v12, &v11);
      v4 = v9;
      v9 = 0;
      if (!v4)
      {
        return v5;
      }
    }

    else
    {
      v7 = (*(a1 + 48) + 16 * v6);
      *v7 = a2;
      v9 = 0;
      v7[1] = v4;
      *(a1 + 56) = v6 + 1;
      v4 = v9;
      v9 = 0;
      if (!v4)
      {
        return v5;
      }
    }
  }

  else
  {
    v9 = 0;
  }

  (*(*v4 + 8))(v4);
  return v5;
}

void mlir::memref::registerAllocationOpInterfaceExternalModels(mlir::DialectRegistry &)::$_0::__invoke(uint64_t a1)
{
  v2 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::AllocOp,void>::id, a1);
  if ((v3 & 1) == 0)
  {
    v36 = 1283;
    v33 = "Attempting to attach an interface to an unregistered operation ";
    v34 = "memref.alloc";
    v25 = 12;
    goto LABEL_26;
  }

  v4 = v2;
  v5 = v2[2];
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v37[0] = v2[1];
    Values = mlir::SparseElementsAttr::getValues(v37);
    v5 = v4[2];
    {
      goto LABEL_4;
    }
  }

  else
  {
    Values = v2[3];
    {
      goto LABEL_4;
    }
  }

  v27 = v5;
  v22 = Values;
  mlir::memref::registerAllocationOpInterfaceExternalModels(mlir::DialectRegistry &)::$_0::__invoke();
  Values = v22;
  v5 = v27;
LABEL_4:
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(Values, v5, mlir::detail::TypeIDResolver<mlir::bufferization::AllocationOpInterface,void>::resolveTypeID(void)::id);
  v7 = malloc(0x20uLL);
  v8 = v7;
  {
    v29 = v7;
    mlir::memref::registerAllocationOpInterfaceExternalModels(mlir::DialectRegistry &)::$_0::__invoke();
    v8 = v29;
  }

  mlir::detail::InterfaceMap::insert((v4 + 4), mlir::detail::TypeIDResolver<mlir::bufferization::AllocationOpInterface,void>::resolveTypeID(void)::id, v8);
  v9 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::AllocaOp,void>::id, a1);
  if ((v10 & 1) == 0)
  {
    v36 = 1283;
    v33 = "Attempting to attach an interface to an unregistered operation ";
    v34 = "memref.alloca";
    v25 = 13;
    goto LABEL_26;
  }

  v11 = v9;
  v12 = v9[2];
  if (v12 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v37[0] = v9[1];
    v13 = mlir::SparseElementsAttr::getValues(v37);
    v12 = v11[2];
    {
      goto LABEL_9;
    }
  }

  else
  {
    v13 = v9[3];
    {
      goto LABEL_9;
    }
  }

  v26 = v13;
  v28 = v12;
  mlir::memref::registerAllocationOpInterfaceExternalModels(mlir::DialectRegistry &)::$_0::__invoke();
  v13 = v26;
  v12 = v28;
LABEL_9:
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v13, v12, mlir::detail::TypeIDResolver<mlir::bufferization::AllocationOpInterface,void>::resolveTypeID(void)::id);
  v14 = malloc(0x20uLL);
  v15 = v14;
  {
    v30 = v14;
    mlir::memref::registerAllocationOpInterfaceExternalModels(mlir::DialectRegistry &)::$_0::__invoke();
    v15 = v30;
  }

  mlir::detail::InterfaceMap::insert((v11 + 4), mlir::detail::TypeIDResolver<mlir::bufferization::AllocationOpInterface,void>::resolveTypeID(void)::id, v15);
  v16 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::ReallocOp,void>::id, a1);
  if ((v17 & 1) == 0)
  {
    v36 = 1283;
    v33 = "Attempting to attach an interface to an unregistered operation ";
    v34 = "memref.realloc";
    v25 = 14;
LABEL_26:
    v35 = v25;
    v31 = ".";
    v32 = 259;
    llvm::operator+(&v33, &v31, v37);
    llvm::report_fatal_error(v37, 1);
  }

  v18 = v16;
  v19 = v16[2];
  if (v19 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v37[0] = v16[1];
    v20 = mlir::SparseElementsAttr::getValues(v37);
    v19 = v18[2];
    {
      goto LABEL_14;
    }
  }

  else
  {
    v20 = v16[3];
    {
      goto LABEL_14;
    }
  }

  v23 = v19;
  v24 = v20;
  mlir::memref::registerAllocationOpInterfaceExternalModels(mlir::DialectRegistry &)::$_0::__invoke();
  v20 = v24;
  v19 = v23;
LABEL_14:
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v20, v19, mlir::detail::TypeIDResolver<mlir::bufferization::AllocationOpInterface,void>::resolveTypeID(void)::id);
  v21 = malloc(0x20uLL);
  {
    mlir::memref::registerAllocationOpInterfaceExternalModels(mlir::DialectRegistry &)::$_0::__invoke();
  }

  mlir::detail::InterfaceMap::insert((v18 + 4), mlir::detail::TypeIDResolver<mlir::bufferization::AllocationOpInterface,void>::resolveTypeID(void)::id, v21);
}

uint64_t mlir::bufferization::detail::AllocationOpInterfaceInterfaceTraits::FallbackModel<anonymous namespace::DefaultAllocationInterface>::buildDealloc(mlir::OpBuilder *a1, uint64_t a2)
{
  v5 = a2;
  Loc = mlir::Value::getLoc(&v5);
  return mlir::OpBuilder::create<mlir::memref::DeallocOp,mlir::Value &>(a1, Loc, &v5);
}

uint64_t mlir::bufferization::detail::AllocationOpInterfaceInterfaceTraits::FallbackModel<anonymous namespace::DefaultAllocationInterface>::buildClone(mlir::OpBuilder *a1, uint64_t a2)
{
  v5 = a2;
  Loc = mlir::Value::getLoc(&v5);
  return mlir::OpBuilder::create<mlir::bufferization::CloneOp,mlir::Value &>(a1, Loc, &v5) - 16;
}

uint64_t mlir::OpBuilder::create<mlir::memref::AllocaOp,mlir::MemRefType,mlir::OperandRange,llvm::ArrayRef<mlir::NamedAttribute>>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v19[5] = *MEMORY[0x1E69E9840];
  v16 = a2;
  Context = mlir::Attribute::getContext(&v16);
  v11 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::memref::AllocaOp,void>::id, Context);
  if ((v12 & 1) == 0)
  {
    mlir::OpBuilder::create<mlir::memref::AllocaOp,mlir::MemRefType &>(v17, v19, v18);
  }

  mlir::OperationState::OperationState(v17, a2, v11);
  mlir::ValueRange::ValueRange(v19, a3, 1uLL);
  mlir::ValueRange::ValueRange(v18, *a4, *(a4 + 8));
  mlir::memref::AllocaOp::build(a1, v17, v19[0], v19[1], v18[0], v18[1], *a5, *(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, v17);
  if (*(*(v13 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::memref::AllocaOp,void>::id)
  {
    v14 = v13;
  }

  else
  {
    v14 = 0;
  }

  mlir::OperationState::~OperationState(v17);
  return v14;
}

void mlir::DialectRegistry::addExtension<mlir::memref::MemRefDialect>(void (*)(mlir::MLIRContext *,mlir::memref::MemRefDialect *))::Extension::~Extension(mlir::DialectExtensionBase *a1)
{
  mlir::DialectExtensionBase::~DialectExtensionBase(a1);

  operator delete(v1);
}